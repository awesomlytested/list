{"repo":"logaretm/vee-validate","url":"https://github.com/logaretm/vee-validate","branch":"main","configs":[{"package":"@vee-validate/i18n","lang":"ts","dir":"packages/i18n/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vee-validate/rules","lang":"ts","dir":"packages/rules/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"vee-validate","lang":"ts","dir":"packages/vee-validate/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@vee-validate/zod","lang":"ts","dir":"packages/zod/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"can define new locales","suites":[],"updatePoint":{"line":18,"column":28},"line":18,"code":"test('can define new locales', async () => {\n  configure({\n    generateMessage: localize('ar', {\n      messages: {\n        required: 'هذا الحقل مطلوب',\n      },\n    }),\n  });\n\n  const wrapper = mountWithHoc({\n    template: `\n      <div>\n        <Field name=\"field\" validateOnMount rules=\"required\" v-slot=\"{ field, errors }\">\n          <input v-bind=\"field\" type=\"text\">\n          <span id=\"error\">{{ errors[0] }}</span>\n        </Field>\n      </div>\n    `,\n  });\n\n  const error = wrapper.$el.querySelector('#error');\n\n  // flush the pending validation.\n  await flushPromises();\n\n  expect(error.textContent).toContain('هذا الحقل مطلوب');\n});","file":"index.spec.ts","skipped":false,"dir":"packages/i18n/tests"},{"name":"can define specific messages for specific fields","suites":[],"updatePoint":{"line":46,"column":54},"line":46,"code":"test('can define specific messages for specific fields', async () => {\n  configure({\n    generateMessage: localize('en', {\n      fields: {\n        test: {\n          required: 'WRONG!',\n        },\n      },\n    }),\n  });\n\n  const wrapper = mountWithHoc({\n    template: `\n        <div>\n          <Field name=\"test\" :validateOnMount=\"true\" rules=\"required\" v-slot=\"{ field, errors }\">\n            <input v-bind=\"field\" type=\"text\">\n            <span class=\"error\">{{ errors[0] }}</span>\n          </Field>\n\n          <Field name=\"name\" :validateOnMount=\"true\" rules=\"required\" v-slot=\"{ field, errors }\">\n            <input v-bind=\"field\" type=\"text\">\n            <span class=\"error\">{{ errors[0] }}</span>\n          </Field>\n        </div>\n      `,\n  });\n\n  await flushPromises();\n  const errors = wrapper.$el.querySelectorAll('.error');\n  expect(errors).toHaveLength(2);\n\n  expect(errors[0].textContent).toContain('WRONG!');\n  expect(errors[1].textContent).toContain('The name is required');\n});","file":"index.spec.ts","skipped":false,"dir":"packages/i18n/tests"},{"name":"can define specific messages for specific fields with labels","suites":[],"updatePoint":{"line":82,"column":66},"line":82,"code":"test('can define specific messages for specific fields with labels', async () => {\n  configure({\n    generateMessage: localize('en', {\n      fields: {\n        test: {\n          required: '{field} WRONG!',\n        },\n      },\n    }),\n  });\n\n  const wrapper = mountWithHoc({\n    template: `\n        <div>\n          <Field name=\"test\" :validateOnMount=\"true\" rules=\"required\" v-slot=\"{ field, errors }\" label=\"field\">\n            <input v-bind=\"field\" type=\"text\">\n            <span class=\"error\">{{ errors[0] }}</span>\n          </Field>\n\n          <Field name=\"name\" :validateOnMount=\"true\" rules=\"required\" v-slot=\"{ field, errors }\">\n            <input v-bind=\"field\" type=\"text\">\n            <span class=\"error\">{{ errors[0] }}</span>\n          </Field>\n        </div>\n      `,\n  });\n\n  await flushPromises();\n  const errors = wrapper.$el.querySelectorAll('.error');\n  expect(errors).toHaveLength(2);\n\n  expect(errors[0].textContent).toContain('field WRONG!');\n  expect(errors[1].textContent).toContain('The name is required');\n});","file":"index.spec.ts","skipped":false,"dir":"packages/i18n/tests"},{"name":"can define specific messages for specific fields with labels and form schema","suites":[],"updatePoint":{"line":118,"column":82},"line":118,"code":"test('can define specific messages for specific fields with labels and form schema', async () => {\n  configure({\n    generateMessage: localize('en', {\n      fields: {\n        test: {\n          required: '{field} WRONG!',\n        },\n      },\n    }),\n  });\n\n  const wrapper = mountWithHoc({\n    template: `\n        <VForm :validation-schema=\"schema\">\n          <Field name=\"test\" :validateOnMount=\"true\" v-slot=\"{ field, errors }\" label=\"field\">\n            <input v-bind=\"field\" type=\"text\">\n            <span class=\"error\">{{ errors[0] }}</span>\n          </Field>\n\n          <Field name=\"name\" :validateOnMount=\"true\" v-slot=\"{ field, errors }\">\n            <input v-bind=\"field\" type=\"text\">\n            <span class=\"error\">{{ errors[0] }}</span>\n          </Field>\n        </VForm>\n      `,\n    setup() {\n      return {\n        schema: {\n          test: 'required',\n          name: 'required',\n        },\n      };\n    },\n  });\n\n  await flushPromises();\n  const errors = wrapper.$el.querySelectorAll('.error');\n  expect(errors).toHaveLength(2);\n\n  expect(errors[0].textContent).toContain('field WRONG!');\n  expect(errors[1].textContent).toContain('The name is required');\n});","file":"index.spec.ts","skipped":false,"dir":"packages/i18n/tests"},{"name":"can define labels or names for fields","suites":[],"updatePoint":{"line":161,"column":43},"line":161,"code":"test('can define labels or names for fields', async () => {\n  configure({\n    generateMessage: localize('en', {\n      messages: { required: '{field} is required' },\n      names: {\n        first: 'First test',\n        second: 'Second test',\n      },\n    }),\n  });\n\n  const wrapper = mountWithHoc({\n    template: `\n        <div>\n          <Field name=\"first\" :validateOnMount=\"true\" rules=\"required\" v-slot=\"{ field, errors }\">\n            <input v-bind=\"field\" type=\"text\">\n            <span class=\"error\">{{ errors[0] }}</span>\n          </Field>\n\n          <Field name=\"second\" :validateOnMount=\"true\" rules=\"required\" v-slot=\"{ field, errors }\">\n            <input v-bind=\"field\" type=\"text\">\n            <span class=\"error\">{{ errors[0] }}</span>\n          </Field>\n        </div>\n      `,\n  });\n\n  await flushPromises();\n  const errors = wrapper.$el.querySelectorAll('.error');\n  expect(errors).toHaveLength(2);\n\n  expect(errors[0].textContent).toContain('First test is required');\n  expect(errors[1].textContent).toContain('Second test is required');\n});","file":"index.spec.ts","skipped":false,"dir":"packages/i18n/tests"},{"name":"can define labels or names for fields with useField","suites":[],"updatePoint":{"line":197,"column":57},"line":197,"code":"test('can define labels or names for fields with useField', async () => {\n  let errorMessage!: Ref<string | undefined>;\n  configure({\n    generateMessage: localize('en', {\n      messages: { required: '{field} is required' },\n      names: {\n        first: 'First test',\n        second: 'Second test',\n      },\n    }),\n  });\n\n  mountWithHoc({\n    setup() {\n      const field = useField('first', 'required', { validateOnMount: true });\n      errorMessage = field.errorMessage;\n    },\n    template: `\n        <div>\n        </div>\n      `,\n  });\n\n  await flushPromises();\n  expect(errorMessage.value).toBe('First test is required');\n});","file":"index.spec.ts","skipped":false,"dir":"packages/i18n/tests"},{"name":"can merge locales without setting the current one","suites":[],"updatePoint":{"line":224,"column":55},"line":224,"code":"test('can merge locales without setting the current one', async () => {\n  configure({\n    generateMessage: localize({\n      ar: {\n        messages: {\n          required: 'هذا الحقل مطلوب',\n        },\n      },\n    }),\n  });\n\n  const wrapper = mountWithHoc({\n    template: `\n        <div>\n          <Field name=\"field\" :validateOnMount=\"true\" rules=\"required\" v-slot=\"{ field, errors }\">\n            <input v-bind=\"field\" type=\"text\">\n            <span id=\"error\">{{ errors[0] }}</span>\n          </Field>\n        </div>\n      `,\n  });\n\n  const error = wrapper.$el.querySelector('#error');\n  // flush the pending validation.\n  await flushPromises();\n\n  // locale wasn't set.\n  expect(error.textContent).toContain('The field is required');\n});","file":"index.spec.ts","skipped":false,"dir":"packages/i18n/tests"},{"name":"falls back to the default message if rule without message exists","suites":[],"updatePoint":{"line":254,"column":70},"line":254,"code":"test('falls back to the default message if rule without message exists', async () => {\n  defineRule('i18n', () => false);\n\n  const wrapper = mountWithHoc({\n    template: `\n      <div>\n        <Field name=\"name\" rules=\"required|i18n\" v-slot=\"{ field, errors }\">\n          <input v-bind=\"field\" type=\"text\">\n          <span id=\"error\">{{ errors[0] }}</span>\n        </Field>\n      </div>\n    `,\n  });\n\n  const error = wrapper.$el.querySelector('#error');\n  const input = wrapper.$el.querySelector('input');\n  setValue(input, '12');\n  await flushPromises();\n\n  expect(error.textContent).toContain('name is not valid');\n});","file":"index.spec.ts","skipped":false,"dir":"packages/i18n/tests"},{"name":"falls back to a language specific default message if rule without message exists","suites":[],"updatePoint":{"line":276,"column":86},"line":276,"code":"test('falls back to a language specific default message if rule without message exists', async () => {\n  defineRule('i18n', () => false);\n  configure({\n    generateMessage: localize('nl', {\n      messages: {\n        _default: '{field} is ongeldig',\n      },\n    }),\n  });\n  setLocale('nl');\n\n  const wrapper = mountWithHoc({\n    template: `\n      <div>\n        <Field name=\"field\" rules=\"required|i18n\" v-slot=\"{ field, errors }\">\n          <input v-bind=\"field\" type=\"text\">\n          <span id=\"error\">{{ errors[0] }}</span>\n        </Field>\n      </div>\n    `,\n  });\n\n  const error = wrapper.$el.querySelector('#error');\n  const input = wrapper.$el.querySelector('input');\n  setValue(input, '12');\n  await flushPromises();\n\n  expect(error.textContent).toContain('field is ongeldig');\n});","file":"index.spec.ts","skipped":false,"dir":"packages/i18n/tests"},{"name":"can switch between locales with setLocale","suites":[],"updatePoint":{"line":306,"column":47},"line":306,"code":"test('can switch between locales with setLocale', async () => {\n  configure({\n    generateMessage: localize({\n      en: {\n        messages: {\n          required: 'This field is required',\n        },\n      },\n      ar: {\n        messages: {\n          required: 'هذا الحقل مطلوب',\n        },\n      },\n    }),\n  });\n\n  setLocale('en');\n\n  const wrapper = mountWithHoc({\n    template: `\n      <div>\n        <Field name=\"field\" validateOnMount rules=\"required\" v-slot=\"{ field, errors }\">\n          <input v-bind=\"field\" type=\"text\">\n          <span id=\"error\">{{ errors[0] }}</span>\n        </Field>\n      </div>\n    `,\n  });\n\n  const error = wrapper.$el.querySelector('#error');\n\n  // flush the pending validation.\n  await flushPromises();\n\n  expect(error.textContent).toContain('This field is required');\n  setLocale('ar');\n  setValue(wrapper.$el.querySelector('input'), '');\n\n  await flushPromises();\n  expect(error.textContent).toContain('هذا الحقل مطلوب');\n});","file":"index.spec.ts","skipped":false,"dir":"packages/i18n/tests"},{"name":"interpolates object params with short format","suites":[],"updatePoint":{"line":348,"column":50},"line":348,"code":"test('interpolates object params with short format', async () => {\n  configure({\n    generateMessage: localize('en', {\n      messages: {\n        between: `The {field} field must be between {min} and {max}`,\n      },\n    }),\n  });\n\n  const wrapper = mountWithHoc({\n    template: `\n        <div>\n          <Field name=\"name\" value=\"-1\" :validateOnMount=\"true\" :rules=\"{ between: { min: 1, max: 10 } }\" v-slot=\"{ field, errors }\">\n            <input v-bind=\"field\" type=\"text\">\n            <span id=\"error\">{{ errors[0] }}</span>\n          </Field>\n        </div>\n      `,\n  });\n\n  const error = wrapper.$el.querySelector('#error');\n  // flush the pending validation.\n  await flushPromises();\n\n  // locale wasn't set.\n  expect(error.textContent).toContain('The name field must be between 1 and 10');\n});","file":"index.spec.ts","skipped":false,"dir":"packages/i18n/tests"},{"name":"interpolates object params with extended format","suites":[],"updatePoint":{"line":376,"column":53},"line":376,"code":"test('interpolates object params with extended format', async () => {\n  configure({\n    generateMessage: localize('en', {\n      messages: {\n        between: `The {field} field must be between 0:{min} and 1:{max}`,\n      },\n    }),\n  });\n\n  const wrapper = mountWithHoc({\n    template: `\n        <div>\n          <Field name=\"name\" value=\"-1\" :validateOnMount=\"true\" :rules=\"{ between: { min: 1, max: 10 } }\" v-slot=\"{ field, errors }\">\n            <input v-bind=\"field\" type=\"text\">\n            <span id=\"error\">{{ errors[0] }}</span>\n          </Field>\n        </div>\n      `,\n  });\n\n  const error = wrapper.$el.querySelector('#error');\n  // flush the pending validation.\n  await flushPromises();\n\n  // locale wasn't set.\n  expect(error.textContent).toContain('The name field must be between 1 and 10');\n});","file":"index.spec.ts","skipped":false,"dir":"packages/i18n/tests"},{"name":"interpolates array params","suites":[],"updatePoint":{"line":404,"column":31},"line":404,"code":"test('interpolates array params', async () => {\n  configure({\n    generateMessage: localize('en', {\n      messages: {\n        between: 'The {field} field must be between 0:{min} and 1:{max}',\n      },\n    }),\n  });\n\n  const wrapper = mountWithHoc({\n    template: `\n        <div>\n          <Field name=\"name\" value=\"-1\" :validateOnMount=\"true\" :rules=\"{ between: [1, 10] }\" v-slot=\"{ field, errors }\">\n            <input v-bind=\"field\" type=\"text\">\n            <span id=\"error\">{{ errors[0] }}</span>\n          </Field>\n        </div>\n      `,\n  });\n\n  const error = wrapper.$el.querySelector('#error');\n  // flush the pending validation.\n  await flushPromises();\n\n  // locale wasn't set.\n  expect(error.textContent).toContain('The name field must be between 1 and 10');\n});","file":"index.spec.ts","skipped":false,"dir":"packages/i18n/tests"},{"name":"interpolates string params","suites":[],"updatePoint":{"line":432,"column":32},"line":432,"code":"test('interpolates string params', async () => {\n  configure({\n    generateMessage: localize('en', {\n      messages: {\n        between: 'The {field} field must be between 0:{min} and 1:{max}',\n      },\n    }),\n  });\n\n  const wrapper = mountWithHoc({\n    template: `\n        <div>\n          <Field name=\"name\" value=\"-1\" :validateOnMount=\"true\" rules=\"between:1,10\" v-slot=\"{ field, errors }\">\n            <input v-bind=\"field\" type=\"text\">\n            <span id=\"error\">{{ errors[0] }}</span>\n          </Field>\n        </div>\n      `,\n  });\n\n  const error = wrapper.$el.querySelector('#error');\n  // flush the pending validation.\n  await flushPromises();\n\n  // locale wasn't set.\n  expect(error.textContent).toContain('The name field must be between 1 and 10');\n});","file":"index.spec.ts","skipped":false,"dir":"packages/i18n/tests"},{"name":"array format","suites":["interpolation preserves placeholders if not found"],"updatePoint":{"line":461,"column":20},"line":461,"code":"  test('array format', async () => {\n    configure({\n      generateMessage: localize('en', {\n        messages: {\n          between: 'The {field} field must be between 0:{min} and 1:{max}',\n        },\n      }),\n    });\n\n    const wrapper = mountWithHoc({\n      template: `\n        <div>\n          <Field name=\"name\" value=\"-1\" :validateOnMount=\"true\" :rules=\"{ between: [1] }\" v-slot=\"{ field, errors }\">\n            <input v-bind=\"field\" type=\"text\">\n            <span id=\"error\">{{ errors[0] }}</span>\n          </Field>\n        </div>\n      `,\n    });\n\n    const error = wrapper.$el.querySelector('#error');\n    // flush the pending validation.\n    await flushPromises();\n\n    // locale wasn't set.\n    expect(error.textContent).toContain('The name field must be between 1 and 1:{max}');\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/i18n/tests"},{"name":"object format","suites":["interpolation preserves placeholders if not found"],"updatePoint":{"line":489,"column":21},"line":489,"code":"  test('object format', async () => {\n    configure({\n      generateMessage: localize('en', {\n        messages: {\n          between: 'The {field} field must be between 0:{min} and 1:{max}',\n        },\n      }),\n    });\n\n    const wrapper = mountWithHoc({\n      template: `\n        <div>\n          <Field name=\"name\" value=\"-1\" :validateOnMount=\"true\" :rules=\"{ between: { min: 0 } }\" v-slot=\"{ field, errors }\">\n            <input v-bind=\"field\" type=\"text\">\n            <span id=\"error\">{{ errors[0] }}</span>\n          </Field>\n        </div>\n      `,\n    });\n\n    const error = wrapper.$el.querySelector('#error');\n    // flush the pending validation.\n    await flushPromises();\n\n    // locale wasn't set.\n    expect(error.textContent).toContain('The name field must be between 0 and {max}');\n  });","file":"index.spec.ts","skipped":false,"dir":"packages/i18n/tests"},{"name":"validates that the string may only contain alpha-numeric characters as well as dashes and spaces","suites":[],"updatePoint":{"line":3,"column":102},"line":3,"code":"test('validates that the string may only contain alpha-numeric characters as well as dashes and spaces', () => {\n  expect(validate('a', [undefined])).toBe(true);\n  expect(validate('abcdefgHijklMnOpqRsTUVwxYZ', [undefined])).toBe(true);\n  expect(validate('1234567890', [undefined])).toBe(true);\n  expect(validate('abc123', [undefined])).toBe(true);\n  expect(validate(123, [undefined])).toBe(true);\n  expect(validate('', [undefined])).toBe(true);\n  expect(validate(null, [undefined])).toBe(true);\n  expect(validate(undefined, [undefined])).toBe(true);\n  expect(validate('null', [undefined])).toBe(true);\n  expect(validate('undefined', [undefined])).toBe(true);\n  expect(validate('123-abc', [undefined])).toBe(true);\n  expect(validate('123_abc', [undefined])).toBe(true);\n  expect(validate(true, [undefined])).toBe(true);\n  expect(validate(false, [undefined])).toBe(true);\n  expect(validate(['a', 'b', 'cdef-_'], [undefined])).toBe(true);\n\n  expect(validate('this is sparta', [undefined])).toBe(false);\n  expect(validate({}, [undefined])).toBe(false);\n  expect(validate(' ', [undefined])).toBe(false);\n  expect(validate([' ', 'ada as'], [undefined])).toBe(false);\n});","file":"alpha_dash.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates the string contains alphabetic chars from other locales","suites":[],"updatePoint":{"line":26,"column":71},"line":26,"code":"test('validates the string contains alphabetic chars from other locales', () => {\n  // any locale.\n  expect(validate('سلا-م_', [undefined])).toBe(true);\n  expect(validate('Привет_-', [undefined])).toBe(true);\n\n  // specfic locale\n  expect(validate('peace', { locale: 'ar' })).toBe(false);\n  expect(validate('peace', { locale: 'ru' })).toBe(false);\n\n  // non-existant locale defaults to english validation.\n  expect(validate('peace', { locale: 'blah' })).toBe(true);\n  expect(validate('اين اشيائي', { locale: 'blah' })).toBe(false); // non english characters.\n});","file":"alpha_dash.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates that the string may only contain alphabetic and numeric characters","suites":[],"updatePoint":{"line":3,"column":82},"line":3,"code":"test('validates that the string may only contain alphabetic and numeric characters', () => {\n  expect(validate('a', [undefined])).toBe(true);\n  expect(validate('abcdefgHijklMnOpqRsTUVwxYZ', [undefined])).toBe(true);\n  expect(validate('1234567890', [undefined])).toBe(true);\n  expect(validate('abc123', [undefined])).toBe(true);\n  expect(validate(123, [undefined])).toBe(true);\n  expect(validate('', [undefined])).toBe(true);\n  expect(validate(null, [undefined])).toBe(true);\n  expect(validate(undefined, [undefined])).toBe(true);\n  expect(validate('null', [undefined])).toBe(true);\n  expect(validate('undefined', [undefined])).toBe(true);\n  expect(validate(true, [undefined])).toBe(true);\n  expect(validate(false, [undefined])).toBe(true);\n  expect(validate(['asdad', 123, 'asd2123'], [undefined])).toBe(true);\n\n  expect(validate('this is sparta', [undefined])).toBe(false);\n  expect(validate('123-abc', [undefined])).toBe(false);\n  expect(validate({}, [undefined])).toBe(false);\n  expect(validate(' ', [undefined])).toBe(false);\n  expect(validate(['asdasda  ', '123 ad'], [undefined])).toBe(false);\n});","file":"alpha_num.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates the string contains alphabetic chars from other locales","suites":[],"updatePoint":{"line":25,"column":71},"line":25,"code":"test('validates the string contains alphabetic chars from other locales', () => {\n  // any locale.\n  expect(validate('سلام12', [undefined])).toBe(true);\n  expect(validate('Привет12', [undefined])).toBe(true);\n\n  // specfic locale\n  expect(validate('peace', { locale: 'ar' })).toBe(false);\n  expect(validate('peace', { locale: 'ru' })).toBe(false);\n\n  // non-existant locale defaults to english validation.\n  expect(validate('peace', { locale: 'blah' })).toBe(true);\n  expect(validate('اين اشيائي', { locale: 'blah' })).toBe(false); // non english characters.\n});","file":"alpha_num.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates that the string may only contain alphabetic characters and spaces","suites":[],"updatePoint":{"line":3,"column":81},"line":3,"code":"test('validates that the string may only contain alphabetic characters and spaces', () => {\n  expect(validate('a', [undefined])).toBe(true);\n  expect(validate('abcdefgHijklMnOpqRsTUVwxYZ', [undefined])).toBe(true);\n  expect(validate('', [undefined])).toBe(true);\n  expect(validate(null, [undefined])).toBe(true);\n  expect(validate(undefined, [undefined])).toBe(true);\n  expect(validate('null', [undefined])).toBe(true);\n  expect(validate('undefined', [undefined])).toBe(true);\n  expect(validate(true, [undefined])).toBe(true);\n  expect(validate(false, [undefined])).toBe(true);\n  expect(validate('this is sparta', [undefined])).toBe(true);\n  expect(validate(' ', [undefined])).toBe(true);\n  expect(validate(['adasd dasdasda', 'yy'], [undefined])).toBe(true);\n\n  // invalid\n  expect(validate('123-abc', [undefined])).toBe(false);\n  expect(validate({}, [undefined])).toBe(false);\n  expect(validate('1234567890', [undefined])).toBe(false);\n  expect(validate('abc123', [undefined])).toBe(false);\n  expect(validate(123, [undefined])).toBe(false);\n  expect(validate(['adasd dasdasda', '123'], [undefined])).toBe(false);\n});","file":"alpha_spaces.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates the string contains alphabetic chars from other locales","suites":[],"updatePoint":{"line":26,"column":71},"line":26,"code":"test('validates the string contains alphabetic chars from other locales', () => {\n  // any locale.\n  expect(validate('سلام عليكم', [undefined])).toBe(true);\n  expect(validate('Привет т', [undefined])).toBe(true);\n\n  // specfic locale\n  expect(validate('peace', { locale: 'ar' })).toBe(false);\n  expect(validate('peace', { locale: 'ru' })).toBe(false);\n\n  // non-existant locale defaults to english validation.\n  expect(validate('peace', { locale: 'blah' })).toBe(true);\n  expect(validate('اين اشيائي', { locale: 'blah' })).toBe(false); // non english characters.\n});","file":"alpha_spaces.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates that the string may only contains alphabetic characters","suites":[],"updatePoint":{"line":3,"column":71},"line":3,"code":"test('validates that the string may only contains alphabetic characters', () => {\n  expect(validate('abcdefgHijklMnOpqRsTUVwxYZ', [undefined])).toBe(true);\n  expect(validate('', [undefined])).toBe(true);\n  expect(validate(null, [undefined])).toBe(true);\n  expect(validate(undefined, [undefined])).toBe(true);\n  expect(validate('null', [undefined])).toBe(true);\n  expect(validate('undefined', [undefined])).toBe(true);\n  expect(validate(true, [undefined])).toBe(true);\n  expect(validate(false, [undefined])).toBe(true);\n  expect(validate(['abcdefg', 'hijk', 'lmnopq'], [undefined])).toBe(true);\n\n  // invalid\n  expect(validate('this is sparta', [undefined])).toBe(false);\n  expect(validate('1234567a89', [undefined])).toBe(false);\n  expect(validate({}, [undefined])).toBe(false);\n  expect(validate(' ', [undefined])).toBe(false);\n  expect(validate(['abcdefg', 'hijk', 'lmnopq123'], [undefined])).toBe(false);\n});","file":"alpha.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates the string contains alphabetic chars from other locales","suites":[],"updatePoint":{"line":22,"column":71},"line":22,"code":"test('validates the string contains alphabetic chars from other locales', () => {\n  // any locale.\n  expect(validate('سلام', [undefined])).toBe(true);\n  expect(validate('Привет', [undefined])).toBe(true);\n\n  // specfic locale\n  expect(validate('peace', { locale: 'ar' })).toBe(false);\n  expect(validate('peace', { locale: 'ru' })).toBe(false);\n\n  // non-existant locale defaults to english validation.\n  expect(validate('peace', { locale: 'blah' })).toBe(true);\n  expect(validate('اين اشيائي', { locale: 'blah' })).toBe(false); // non english characters.\n});","file":"alpha.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates numbers range","suites":[],"updatePoint":{"line":3,"column":29},"line":3,"code":"test('validates numbers range', () => {\n  const params = { min: 1, max: 3 };\n  expect(validate('1', params)).toBe(true);\n  expect(validate(2, params)).toBe(true);\n  expect(validate(3, params)).toBe(true);\n  expect(validate([1, 2, 3], params)).toBe(true);\n  expect(validate(undefined, params)).toBe(true);\n  expect(validate(null, params)).toBe(true);\n  expect(validate('', params)).toBe(true);\n  expect(validate([], params)).toBe(true);\n\n  // invalid\n  expect(validate({}, params)).toBe(false);\n  expect(validate('1234', params)).toBe(false);\n  expect(validate('12', params)).toBe(false);\n  expect(validate('abc', params)).toBe(false);\n  expect(validate('12a', params)).toBe(false);\n  expect(validate(0, params)).toBe(false);\n  expect(validate(4, params)).toBe(false);\n  expect(validate(-1, params)).toBe(false);\n  expect(validate([4, 5, 6], params)).toBe(false);\n});","file":"between.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates numbers range including negative numbers","suites":[],"updatePoint":{"line":26,"column":56},"line":26,"code":"test('validates numbers range including negative numbers', () => {\n  const range = { min: -10, max: 1 };\n  expect(validate(0, range)).toBe(true);\n  expect(validate('-9', range)).toBe(true);\n});","file":"between.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates a field confirmation","suites":[],"updatePoint":{"line":3,"column":36},"line":3,"code":"test('validates a field confirmation', () => {\n  expect(validate('p@$$word', { target: 'p@$$word' })).toBe(true);\n\n  // fields do not match.\n  expect(validate('password', { target: 'p@$$word' })).toBe(false);\n});","file":"confirmed.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates digits","suites":[],"updatePoint":{"line":3,"column":22},"line":3,"code":"test('validates digits', () => {\n  const params = { length: 3 }; // 3 digits only.\n  expect(validate('123', params)).toBe(true);\n  expect(validate('456', params)).toBe(true);\n  expect(validate('789', params)).toBe(true);\n  expect(validate('012', params)).toBe(true);\n  expect(validate('000', params)).toBe(true);\n  expect(validate(['012', '789'], params)).toBe(true);\n  expect(validate(undefined, params)).toBe(true);\n  expect(validate(null, params)).toBe(true);\n  expect(validate('', params)).toBe(true);\n  expect(validate([], params)).toBe(true);\n\n  // invalid\n  expect(validate(0, params)).toBe(false);\n  expect(validate({}, params)).toBe(false);\n  expect(validate('1234', params)).toBe(false);\n  expect(validate('12', params)).toBe(false);\n  expect(validate('abc', params)).toBe(false);\n  expect(validate('12a', params)).toBe(false);\n  expect(validate(['123', '12a'], params)).toBe(false);\n});","file":"digits.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates image dimensions","suites":[],"updatePoint":{"line":32,"column":32},"line":32,"code":"test('validates image dimensions', async () => {\n  let result = await validate(helpers.file('file.jpg', 'image/jpeg', 10), { width: 150, height: 100 });\n  expect(result).toBe(true);\n\n  // mock a failing Image, even with the right dimensions.\n  fails = true;\n  result = await validate([helpers.file('file.jpg', 'image/jpeg', 10)], { width: 150, height: 100 });\n  expect(result).toBe(false);\n\n  fails = false;\n  // not an image.\n  result = await validate([helpers.file('file.pdf', 'application/pdf', 10)], { width: 150, height: 100 });\n  expect(result).toBe(false);\n\n  // wrong dimensions.\n  result = await validate([helpers.file('file.jpg', 'image/jpeg', 10)], { width: 15, height: 10 });\n  expect(result).toBe(false);\n\n  (window as any).URL = undefined; // test webkit fallback.\n  result = await validate([helpers.file('file.jpg', 'image/jpeg', 10)], { width: 150, height: 100 });\n  expect(result).toBe(true);\n});","file":"dimensions.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates that the string is a valid email address","suites":[],"updatePoint":{"line":3,"column":56},"line":3,"code":"test('validates that the string is a valid email address', () => {\n  expect(validate('someone@example.com')).toBe(true);\n  expect(validate('someone@example.co')).toBe(true);\n  expect(validate('someone123@example.co.uk')).toBe(true);\n  expect(validate('Pelé@example.com')).toBe(true);\n  expect(validate('very.common@example.com')).toBe(true);\n  expect(validate('other.email-with-dash@example.com')).toBe(true);\n  expect(validate('disposable.style.email.with+symbol@example.com')).toBe(true);\n  expect(validate(['someone@example.com', 'someone12@example.com'])).toBe(true);\n  expect(validate(undefined)).toBe(true);\n  expect(validate(null)).toBe(true);\n  expect(validate('')).toBe(true);\n  expect(validate([])).toBe(true);\n\n  // invalid\n  expect(validate('@example.com')).toBe(false);\n  expect(validate('@example')).toBe(false);\n  expect(validate('undefined')).toBe(false);\n  expect(validate('null')).toBe(false);\n  expect(validate('someone@example.c')).toBe(false);\n  expect(validate(['someone@example.com', 'someone@example.c'])).toBe(false);\n});","file":"email.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates files extensions","suites":[],"updatePoint":{"line":3,"column":32},"line":3,"code":"test('validates files extensions', () => {\n  const params = ['txt', 'jpg', 'svg'];\n  const validFiles = [\n    helpers.file('file.txt', 'text/plain'),\n    helpers.file('file.jpg', 'image/jpeg'),\n    helpers.file('file.svg', 'image/svg'),\n  ];\n\n  expect(validate(validFiles, params)).toBe(true);\n  expect(validate(helpers.file('file.pdf', 'application/pdf'), params)).toBe(false);\n  expect(validate(helpers.file('filetxt', 'text/plain'), params)).toBe(false);\n  expect(validate(helpers.file('file.jpgg', 'image/jpeg'), params)).toBe(false);\n});","file":"ext.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates image files","suites":[],"updatePoint":{"line":3,"column":27},"line":3,"code":"test('validates image files', () => {\n  const validFiles = [\n    helpers.file('file.gif', 'image/gif'),\n    helpers.file('file.jpg', 'image/jpeg'),\n    helpers.file('file.jpeg', 'image/jpeg'),\n    helpers.file('file.svg', 'image/svg'),\n    helpers.file('file.bmp', 'image/bmp'),\n    helpers.file('file.png', 'image/png'),\n    helpers.file('file.png', 'image/webp'),\n  ];\n\n  expect(validate(validFiles)).toBe(true);\n  expect(validate(helpers.file('file.pdf', 'application/pdf'))).toBe(false);\n});","file":"image.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates integer numbers","suites":[],"updatePoint":{"line":3,"column":31},"line":3,"code":"test('validates integer numbers', () => {\n  expect(validate('1234567890')).toBe(true);\n  expect(validate(123)).toBe(true);\n  expect(validate(-123)).toBe(true);\n  expect(validate('-1234')).toBe(true);\n  expect(validate(undefined)).toBe(true);\n  expect(validate(null)).toBe(true);\n  expect(validate('')).toBe(true);\n  expect(validate([])).toBe(true);\n  expect(validate(0)).toBe(true);\n\n  // invalid\n  expect(validate('a')).toBe(false);\n  expect(validate('1234567a89')).toBe(false);\n  expect(validate(true)).toBe(false);\n  expect(validate(false)).toBe(false);\n  expect(validate({})).toBe(false);\n  expect(validate('+123')).toBe(false);\n  expect(validate(12.2)).toBe(false);\n  expect(validate('13.3')).toBe(false);\n});","file":"integer.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"checks if the value does not match another","suites":[],"updatePoint":{"line":3,"column":48},"line":3,"code":"test('checks if the value does not match another', () => {\n  expect(validate(1, { other: '1' })).toBe(true);\n  expect(validate(1, { other: 1 })).toBe(false);\n  expect(validate(1, { other: 2 })).toBe(true);\n  expect(validate({}, { other: {} })).toBe(true);\n  const obj = {};\n  expect(validate(obj, { other: obj })).toBe(false);\n});","file":"is_not.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"checks if the value matches another","suites":[],"updatePoint":{"line":3,"column":41},"line":3,"code":"test('checks if the value matches another', () => {\n  expect(validate(1, { other: '1' })).toBe(false);\n  expect(validate(1, { other: 1 })).toBe(true);\n  expect(validate(1, { other: 2 })).toBe(false);\n  expect(validate({}, { other: {} })).toBe(false);\n  const obj = {};\n  expect(validate(obj, { other: obj })).toBe(true);\n});","file":"is.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates number of characters in a string","suites":[],"updatePoint":{"line":3,"column":48},"line":3,"code":"test('validates number of characters in a string', () => {\n  // exact length\n  expect(validate('hey', { length: 3 })).toBe(true);\n  expect(validate('hello', { length: 3 })).toBe(false);\n});","file":"length.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"null and undefined are always rejected","suites":[],"updatePoint":{"line":9,"column":44},"line":9,"code":"test('null and undefined are always rejected', () => {\n  expect(validate(null as any, { length: 3 })).toBe(false);\n  expect(validate(undefined as any, { length: 3 })).toBe(false);\n});","file":"length.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates number of elements in an enumerable","suites":[],"updatePoint":{"line":14,"column":51},"line":14,"code":"test('validates number of elements in an enumerable', () => {\n  const firstSet = new Set(['h', 'e', 'y']);\n  const secondSet = new Set(['h', 'e', 'l', 'l']);\n  expect(validate(firstSet as any, { length: 3 })).toBe(true);\n  expect(validate(secondSet as any, { length: 4 })).toBe(false);\n});","file":"length.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates number of elements in an array","suites":[],"updatePoint":{"line":21,"column":46},"line":21,"code":"test('validates number of elements in an array', () => {\n  // exact length\n  expect(validate(['h', 'e', 'y'], { length: 3 })).toBe(true);\n  expect(validate(['h', 'e', 'l', 'l', 'o'], { length: 3 })).toBe(false);\n});","file":"length.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates strings consisting of numbers","suites":[],"updatePoint":{"line":27,"column":45},"line":27,"code":"test('validates strings consisting of numbers', () => {\n  expect(validate(123 as any, { length: 3 })).toBe(true);\n});","file":"length.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates number maximum value","suites":[],"updatePoint":{"line":3,"column":36},"line":3,"code":"test('validates number maximum value', () => {\n  const params = { max: 10 };\n\n  // valid.\n  expect(validate(0, params)).toBe(true);\n  expect(validate('1', params)).toBe(true);\n  expect(validate(10, params)).toBe(true);\n  expect(validate([10], params)).toBe(true);\n  expect(validate(undefined, params)).toBe(true);\n  expect(validate(null, params)).toBe(true);\n  expect(validate('', params)).toBe(true);\n  expect(validate([], params)).toBe(true);\n\n  // invalid\n  expect(validate(10.01, params)).toBe(false);\n  expect(validate(11, params)).toBe(false);\n  expect(validate({}, params)).toBe(false);\n  expect(validate('abc', params)).toBe(false);\n  expect(validate([10.01], params)).toBe(false);\n});","file":"max_value.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates maximum number of characters in a string","suites":[],"updatePoint":{"line":3,"column":56},"line":3,"code":"test('validates maximum number of characters in a string', () => {\n  const params = { length: 3 };\n  // valid\n  expect(validate(123, params)).toBe(true);\n  expect(validate('abc', params)).toBe(true);\n  expect(validate(1, params)).toBe(true);\n  expect(validate(12, params)).toBe(true);\n  expect(validate(undefined, params)).toBe(true);\n  expect(validate(null, params)).toBe(true);\n  expect(validate('', params)).toBe(true);\n  expect(validate([1, 2], params)).toBe(true);\n  expect(validate('𩸽寿司', params)).toBe(true);\n\n  // invalid\n  expect(validate('abcde', params)).toBe(false);\n  expect(validate('null', params)).toBe(false);\n  expect(validate('undefined', params)).toBe(false);\n  expect(validate(['1234'], params)).toBe(false);\n  expect(validate('𩸽寿司の', params)).toBe(false);\n});","file":"max.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates mime types","suites":[],"updatePoint":{"line":3,"column":26},"line":3,"code":"test('validates mime types', () => {\n  const params = ['image/*', 'text/plain'];\n\n  expect(\n    validate(\n      [\n        helpers.file('file.txt', 'text/plain'),\n        helpers.file('file.jpg', 'image/jpeg'),\n        helpers.file('file.svg', 'image/svg'),\n      ],\n      params\n    )\n  ).toBe(true);\n\n  expect(validate(helpers.file('file.pdf', 'application/pdf'), params)).toBe(false);\n});","file":"mimes.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates number minimum value","suites":[],"updatePoint":{"line":3,"column":36},"line":3,"code":"test('validates number minimum value', () => {\n  const params = { min: -1 };\n  expect(validate(-1, params)).toBe(true);\n  expect(validate(0, params)).toBe(true);\n  expect(validate('5', params)).toBe(true);\n  expect(validate([-1, 5], params)).toBe(true);\n  expect(validate(undefined, params)).toBe(true);\n  expect(validate(null, params)).toBe(true);\n  expect(validate('', params)).toBe(true);\n  expect(validate([], params)).toBe(true);\n\n  // invalid\n  expect(validate({}, params)).toBe(false);\n  expect(validate('abc', params)).toBe(false);\n  expect(validate(-2, params)).toBe(false);\n  expect(validate('-3', params)).toBe(false);\n  expect(validate(['-3'], params)).toBe(false);\n});","file":"min_value.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates minimum number of characters in a string","suites":[],"updatePoint":{"line":3,"column":56},"line":3,"code":"test('validates minimum number of characters in a string', () => {\n  const params = { length: 3 };\n  // valid.\n  expect(validate('asjdj', params)).toBe(true);\n  expect(validate('null', params)).toBe(true);\n  expect(validate('undefined', params)).toBe(true);\n  expect(validate(123, params)).toBe(true);\n  expect(validate('abc', params)).toBe(true);\n  expect(validate([123, '123', 'abc'], params)).toBe(true);\n  expect(validate(undefined, params)).toBe(true);\n  expect(validate(null, params)).toBe(true);\n  expect(validate('', params)).toBe(true);\n  expect(validate([], params)).toBe(true);\n  expect(validate('𩸽寿司', params)).toBe(true);\n\n  // invalid\n  expect(validate(1, params)).toBe(false);\n  expect(validate(12, params)).toBe(false);\n  expect(validate([1], params)).toBe(false);\n  expect(validate('𩸽', params)).toBe(false);\n});","file":"min.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates that the value does not exist within a list","suites":[],"updatePoint":{"line":3,"column":59},"line":3,"code":"test('validates that the value does not exist within a list', () => {\n  const list = [1, 2, 3, 4, 5];\n\n  // valid.\n  expect(validate(0, list)).toBe(true);\n  expect(validate(6, list)).toBe(true);\n  expect(validate([6], list)).toBe(true);\n\n  // invalid\n  expect(validate(1, list)).toBe(false);\n  expect(validate(2, list)).toBe(false);\n  expect(validate(3, list)).toBe(false);\n  expect(validate(4, list)).toBe(false);\n  expect(validate(5, list)).toBe(false);\n  expect(validate([1, 2], list)).toBe(false);\n});","file":"not_one_of.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates that the string only contains numeric characters","suites":[],"updatePoint":{"line":3,"column":64},"line":3,"code":"test('validates that the string only contains numeric characters', () => {\n  // valid.\n  expect(validate('1234567890')).toBe(true);\n  expect(validate(123)).toBe(true);\n  expect(validate('٠١٢٣٤')).toBe(true);\n  expect(validate('٠١٢٣٤٥٦٧٨٩')).toBe(true);\n  expect(validate(undefined)).toBe(true);\n  expect(validate(null)).toBe(true);\n  expect(validate('')).toBe(true);\n  expect(validate([])).toBe(true);\n  expect(validate(0)).toBe(true);\n\n  // invalid\n  expect(validate('a')).toBe(false);\n  expect(validate('1234567a89')).toBe(false);\n  expect(validate(true)).toBe(false);\n  expect(validate(false)).toBe(false);\n  expect(validate({})).toBe(false);\n  expect(validate('+123')).toBe(false);\n  expect(validate('-123')).toBe(false);\n});","file":"numeric.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates that the value exists within a list","suites":[],"updatePoint":{"line":3,"column":51},"line":3,"code":"test('validates that the value exists within a list', () => {\n  const list = [1, 2, 3, 4, 5];\n\n  // valid.\n  expect(validate(1, list)).toBe(true);\n  expect(validate(2, list)).toBe(true);\n  expect(validate(3, list)).toBe(true);\n  expect(validate(4, list)).toBe(true);\n  expect(validate(5, list)).toBe(true);\n\n  // invalid\n  expect(validate(0, list)).toBe(false);\n  expect(validate(6, list)).toBe(false);\n  expect(validate([1, 6], list)).toBe(false);\n});","file":"one_of.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates regular expressions","suites":[],"updatePoint":{"line":3,"column":35},"line":3,"code":"test('validates regular expressions', () => {\n  const params = { regex: /^[0-9]+$/ };\n  expect(validate('1234567890', params)).toBe(true);\n  expect(validate('abc', params)).toBe(false);\n  expect(validate('abc-123', params)).toBe(false);\n  expect(validate('1234abc5', params)).toBe(false);\n  expect(validate(['1234567890', '321'], params)).toBe(true);\n  expect(validate(['1234567890', 'abc'], params)).toBe(false);\n\n  // empty values should pass\n  expect(validate('', params)).toBe(true); // empty values pass\n  expect(validate(undefined, params)).toBe(true); // empty values pass\n  expect(validate(null, params)).toBe(true); // empty values pass\n  expect(validate([], params)).toBe(true); // empty values pass\n});","file":"regex.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates required","suites":[],"updatePoint":{"line":3,"column":24},"line":3,"code":"test('validates required', () => {\n  // valid\n  expect(validate('asjdj')).toBe(true);\n  expect(validate(0)).toBe(true);\n  expect(validate('undefined')).toBe(true);\n  expect(validate('null')).toBe(true);\n  expect(validate('s ')).toBe(true);\n  expect(validate(true)).toBe(true);\n\n  // invalid\n  expect(validate('')).toBe(false);\n  expect(validate(' ')).toBe(false);\n  expect(validate([])).toBe(false);\n  expect(validate(undefined)).toBe(false);\n  expect(validate(null)).toBe(false);\n  expect(validate(false)).toBe(false);\n});","file":"required.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates file size","suites":[],"updatePoint":{"line":4,"column":25},"line":4,"code":"test('validates file size', () => {\n  const params = { size: 15 };\n  expect(validate([helpers.file('file.txt', 'text/plain', 10)], params)).toBe(true);\n  expect(validate(helpers.file('file.txt', 'text/plain', 15), params)).toBe(true);\n  expect(validate([helpers.file('file.txt', 'text/plain', 16)], params)).toBe(false);\n  expect(validate([helpers.file('file.txt', 'text/plain', 16)], { size: 'not a number' })).toBe(false);\n});","file":"size.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates typed schema form with global rules","suites":[],"updatePoint":{"line":16,"column":51},"line":16,"code":"test('validates typed schema form with global rules', async () => {\n  const wrapper = mountWithHoc({\n    setup() {\n      const schema = toTypedSchema<{ email: string; password: string }>({\n        email: 'required|email',\n        password: 'required|min:8',\n      });\n\n      const { useFieldModel, errors } = useForm({\n        validationSchema: schema,\n        validateOnMount: true,\n      });\n\n      const [email, password] = useFieldModel(['email', 'password']);\n\n      return {\n        schema,\n        email,\n        password,\n        errors,\n      };\n    },\n    template: `\n      <div>\n        <input id=\"email\" name=\"email\" v-model=\"email\" />\n        <span id=\"emailErr\">{{ errors.email }}</span>\n\n        <input id=\"password\" name=\"password\" type=\"password\" v-model=\"password\" />\n        <span id=\"passwordErr\">{{ errors.password }}</span>\n      </div>\n    `,\n  });\n\n  const email = wrapper.$el.querySelector('#email');\n  const password = wrapper.$el.querySelector('#password');\n  const emailError = wrapper.$el.querySelector('#emailErr');\n  const passwordError = wrapper.$el.querySelector('#passwordErr');\n\n  await flushPromises();\n\n  setValue(email, 'hello@');\n  setValue(password, '1234');\n  await flushPromises();\n\n  expect(emailError.textContent).toBe(EMAIL_MSG);\n  expect(passwordError.textContent).toBe(MIN_MSG);\n\n  setValue(email, 'hello@email.com');\n  setValue(password, '12346789');\n  await flushPromises();\n\n  expect(emailError.textContent).toBe('');\n  expect(passwordError.textContent).toBe('');\n});","file":"toTypedSchema.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates typed field with global rules","suites":[],"updatePoint":{"line":71,"column":45},"line":71,"code":"test('validates typed field with global rules', async () => {\n  const wrapper = mountWithHoc({\n    setup() {\n      const rules = toTypedSchema<string>('required|min:8');\n      const { value, errorMessage } = useField('test', rules);\n\n      return {\n        value,\n        errorMessage,\n      };\n    },\n    template: `\n      <div>\n          <input v-model=\"value\" type=\"text\">\n          <p>{{ errorMessage }}</p>\n      </div>\n    `,\n  });\n\n  const input = wrapper.$el.querySelector('input');\n  const error = wrapper.$el.querySelector('p');\n\n  setValue(input, '');\n  await flushPromises();\n  expect(error.textContent).toBe(REQUIRED_MSG);\n  setValue(input, '12');\n  await flushPromises();\n  expect(error.textContent).toBe(MIN_MSG);\n  setValue(input, '12345678');\n  await flushPromises();\n  expect(error.textContent).toBe('');\n});","file":"toTypedSchema.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"validates url","suites":[],"updatePoint":{"line":3,"column":19},"line":3,"code":"test('validates url', () => {\n  const validUrl = 'https://test.com:8080/en/whatever/?q=test#wow';\n\n  // no pattern\n  expect(validate(validUrl, {})).toBe(true);\n  expect(validate('/only/path', {})).toBe(false);\n  expect(validate('invalid', {})).toBe(false);\n\n  // with pattern\n  expect(validate(validUrl, { pattern: 'https://.*' })).toBe(true);\n  expect(validate(validUrl, { pattern: /http:\\/\\/.*/ })).toBe(false);\n  expect(validate(validUrl, ['/en/whatever/'])).toBe(true);\n  expect(validate(validUrl, ['/fr/whatever/'])).toBe(false);\n});","file":"url.spec.ts","skipped":false,"dir":"packages/rules/tests"},{"name":"passing a non-function as the validate method will throw","suites":[],"updatePoint":{"line":3,"column":62},"line":3,"code":"test('passing a non-function as the validate method will throw', () => {\n  expect(() => {\n    defineRule('noFn', '' as unknown as (value: any) => boolean);\n  }).toThrow();\n});","file":"define.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"define global validations using string ids","suites":[],"updatePoint":{"line":9,"column":48},"line":9,"code":"test('define global validations using string ids', async () => {\n  defineRule('test-direct', (value, _, { field }) => {\n    if (value === '1') {\n      return 'Cannot be 1';\n    }\n\n    if (value === '2') {\n      return `${field} Cannot be 2`;\n    }\n\n    return true;\n  });\n\n  let result = await validate('1', 'test-direct');\n  expect(result.errors[0]).toBe('Cannot be 1');\n\n  result = await validate('2', 'test-direct', { name: 'test' });\n  expect(result.errors[0]).toBe('test Cannot be 2');\n});","file":"define.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"does not render if no errors are present","suites":["<ErrorMessage />"],"updatePoint":{"line":14,"column":48},"line":14,"code":"  test('does not render if no errors are present', async () => {\n    const wrapper = mountWithHoc({\n      components: {\n        ErrorMessage,\n      },\n      template: `\n      <VForm>\n        <Field name=\"field\" rules=\"required\" />\n        <ErrorMessage name=\"field\" id=\"error\" />\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    expect(wrapper.$el.querySelector('#error')).toBe(null);\n  });","file":"ErrorMessage.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"shows error messages for a field","suites":["<ErrorMessage />"],"updatePoint":{"line":31,"column":40},"line":31,"code":"  test('shows error messages for a field', async () => {\n    const wrapper = mountWithHoc({\n      components: {\n        ErrorMessage,\n      },\n      template: `\n      <VForm>\n        <Field name=\"field\" rules=\"required\" />\n        <ErrorMessage name=\"field\" id=\"error\" />\n      </VForm>\n    `,\n    });\n\n    const input = wrapper.$el.querySelector('input');\n    setValue(input, '');\n    await flushPromises();\n\n    const error = wrapper.$el.querySelector('#error');\n    expect(error.tagName).toBe('SPAN');\n    await flushPromises();\n\n    expect(error.textContent).toBe(REQUIRED_MESSAGE);\n    setValue(input, '12');\n    await flushPromises();\n\n    // was removed\n    expect(wrapper.$el.querySelector('#error')).toBe(null);\n  });","file":"ErrorMessage.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"render with \"as\" prop","suites":["<ErrorMessage />"],"updatePoint":{"line":60,"column":29},"line":60,"code":"  test('render with \"as\" prop', async () => {\n    const wrapper = mountWithHoc({\n      components: {\n        ErrorMessage,\n      },\n      template: `\n      <VForm>\n        <Field name=\"field\" rules=\"required\" />\n        <ErrorMessage as=\"div\" name=\"field\" id=\"error\" />\n\n        <button>Validate</button>\n      </VForm>\n    `,\n    });\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    const error = wrapper.$el.querySelector('#error');\n    expect(error.tagName).toBe('DIV');\n\n    expect(error.textContent).toBe(REQUIRED_MESSAGE);\n  });","file":"ErrorMessage.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"render with \"as\" prop and child nodes","suites":["<ErrorMessage />"],"updatePoint":{"line":83,"column":45},"line":83,"code":"  test('render with \"as\" prop and child nodes', async () => {\n    const wrapper = mountWithHoc({\n      components: {\n        ErrorMessage,\n      },\n      template: `\n      <VForm>\n        <Field name=\"field\" rules=\"required\" />\n        <ErrorMessage as=\"div\" name=\"field\" id=\"error\" v-slot=\"{ message }\">\n          <span>icon</span>\n          <span>{{ message }}</span>\n        </ErrorMessage>\n\n        <button>Validate</button>\n      </VForm>\n    `,\n    });\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n\n    const error = wrapper.$el.querySelector('#error');\n    expect(error.tagName).toBe('DIV');\n    expect(error.textContent).toContain(REQUIRED_MESSAGE);\n  });","file":"ErrorMessage.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"render with scoped slots","suites":["<ErrorMessage />"],"updatePoint":{"line":108,"column":32},"line":108,"code":"  test('render with scoped slots', async () => {\n    const wrapper = mountWithHoc({\n      components: {\n        ErrorMessage,\n      },\n      template: `\n      <VForm>\n        <Field name=\"field\" rules=\"required\" />\n        <ErrorMessage name=\"field\" v-slot=\"{ message }\">\n          <p id=\"error\">{{ message }}</p>\n        </ErrorMessage>\n\n        <button>Validate</button>\n      </VForm>\n    `,\n    });\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    const error = wrapper.$el.querySelector('#error');\n    expect(error.tagName).toBe('P');\n\n    expect(error.textContent).toBe(REQUIRED_MESSAGE);\n  });","file":"ErrorMessage.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"renders an input by default","suites":["<Field />"],"updatePoint":{"line":46,"column":35},"line":46,"code":"  test('renders an input by default', () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <Field name=\"field\" />\n    `,\n    });\n\n    expect(wrapper.$el.tagName).toBe(`INPUT`);\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"renders the as prop","suites":["<Field />"],"updatePoint":{"line":56,"column":27},"line":56,"code":"  test('renders the as prop', () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <Field name=\"field\" as=\"div\" />\n    `,\n    });\n\n    expect(wrapper.$el.tagName).toBe(`DIV`);\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"renderless if no as prop and default slot exists","suites":["<Field />"],"updatePoint":{"line":66,"column":56},"line":66,"code":"  test('renderless if no as prop and default slot exists', () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <Field name=\"field\" v-slot=\"{ field }\">\n        <select v-bind=\"field\">\n          <option>1</option>\n        </select>\n      </Field>\n    `,\n    });\n\n    expect(wrapper.$el.tagName).toBe(undefined);\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"accepts functions to be passed as rules","suites":["<Field />"],"updatePoint":{"line":80,"column":47},"line":80,"code":"  test('accepts functions to be passed as rules', async () => {\n    const isRequired = (val: any) => (val ? true : 'Field is required');\n\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          rules: isRequired,\n        };\n      },\n      template: `\n      <div>\n        <Field name=\"field\" :rules=\"rules\" v-slot=\"{ errors, field, meta }\">\n          <input v-bind=\"field\" type=\"text\">\n          <span>{{ errors[0] }}</span>\n        </Field>\n      </div>\n    `,\n    });\n\n    const input = wrapper.$el.querySelector('input');\n    const error = wrapper.$el.querySelector('span');\n    expect(error.textContent).toBe('');\n    setValue(input, '');\n    await flushPromises();\n    expect(error.textContent).toBe('Field is required');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"accepts objects to be passed as rules","suites":["<Field />"],"updatePoint":{"line":107,"column":45},"line":107,"code":"  test('accepts objects to be passed as rules', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          rules: { required: true, min: [3], confirmedObj: { target: '@other' } },\n        };\n      },\n      template: `\n      <VForm>\n        <Field name=\"field\" :rules=\"rules\" v-slot=\"{ errors, field }\">\n          <input v-bind=\"field\" type=\"text\">\n          <span id=\"fieldError\">{{ errors[0] }}</span>\n        </Field>\n\n        <Field name=\"other\" rules=\"required\" v-slot=\"{ errors, field }\">\n          <input v-bind=\"field\" type=\"text\">\n          <span>{{ errors[0] }}</span>\n        </Field>\n      </VForm>\n    `,\n    });\n\n    const input = wrapper.$el.querySelector('input');\n    const error = wrapper.$el.querySelector('#fieldError');\n    expect(error.textContent).toBe('');\n    setValue(input, '1');\n    await flushPromises();\n    expect(error.textContent).toBe('This field must be at least 3 characters');\n    setValue(input, '123');\n    await flushPromises();\n    expect(error.textContent).toBe('inputs do not match');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"listens for input and blur events to set meta flags","suites":["<Field />"],"updatePoint":{"line":140,"column":59},"line":140,"code":"  test('listens for input and blur events to set meta flags', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <div>\n        <Field name=\"field\" rules=\"required\" v-slot=\"{ errors, field, meta }\">\n          <input v-bind=\"field\" type=\"text\">\n          <pre id=\"pre\">{{ meta }}</pre>\n        </Field>\n      </div>\n    `,\n    });\n\n    const input = wrapper.$el.querySelector('input');\n    const pre = wrapper.$el.querySelector('pre');\n\n    expect(pre.textContent).toContain('\"touched\": false');\n    expect(pre.textContent).toContain('\"dirty\": false');\n    dispatchEvent(input, 'blur');\n    await flushPromises();\n    expect(pre.textContent).toContain('\"touched\": true');\n    expect(pre.textContent).toContain('\"dirty\": false');\n    dispatchEvent(input, 'input');\n    await flushPromises();\n    expect(pre.textContent).toContain('\"dirty\": true');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"listens for change events","suites":["<Field />"],"updatePoint":{"line":166,"column":33},"line":166,"code":"  test('listens for change events', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm v-slot=\"{ errors }\">\n        <Field name=\"select\" as=\"select\" rules=\"required\">\n          <option value=\"\">0</option>\n          <option value=\"1\">1</option>\n        </Field>\n        <span id=\"error\">{{ errors.select }}</span>\n      </VForm>\n    `,\n    });\n\n    const select = wrapper.$el.querySelector('select');\n    const error = wrapper.$el.querySelector('#error');\n\n    setValue(select, '');\n    await flushPromises();\n    // validation triggered on change.\n    expect(error.textContent).toBe(REQUIRED_MESSAGE);\n\n    setValue(select, '1');\n    await flushPromises();\n\n    expect(error.textContent).toBe('');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"validates initially with validateOnMount prop","suites":["<Field />"],"updatePoint":{"line":193,"column":53},"line":193,"code":"  test('validates initially with validateOnMount prop', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <div>\n        <Field name=\"field\" validateOnMount rules=\"required\" v-slot=\"{ field, errors }\">\n          <input v-bind=\"field\" type=\"text\">\n          <span id=\"error\">{{ errors[0] }}</span>\n        </Field>\n      </div>\n    `,\n    });\n\n    const error = wrapper.$el.querySelector('#error');\n\n    // flush the pending validation.\n    await flushPromises();\n\n    expect(error.textContent).toContain(REQUIRED_MESSAGE);\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"watches rules and re-validates","suites":["<Field />"],"updatePoint":{"line":213,"column":38},"line":213,"code":"  test('watches rules and re-validates', async () => {\n    let rules!: Ref<any>;\n    const wrapper = mountWithHoc({\n      setup() {\n        rules = ref({ required: true });\n\n        return {\n          rules,\n        };\n      },\n      template: `\n        <div>\n          <Field name=\"field\" :rules=\"rules\" v-slot=\"{ field, errors }\">\n            <input v-bind=\"field\" type=\"text\">\n            <span id=\"error\">{{ errors[0] }}</span>\n          </Field>\n        </div>\n      `,\n    });\n\n    const input = wrapper.$el.querySelector('input');\n    const error = wrapper.$el.querySelector('#error');\n    setValue(input, '1');\n    // flush the pending validation.\n    await flushPromises();\n\n    expect(error.textContent).toBe('');\n\n    rules.value = {\n      required: false,\n      min: 3,\n    };\n\n    await flushPromises();\n    expect(error.textContent).toBe('This field must be at least 3 characters');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"validates custom components","suites":["<Field />"],"updatePoint":{"line":250,"column":35},"line":250,"code":"  test('validates custom components', async () => {\n    const wrapper = mountWithHoc({\n      components: {\n        TextInput: {\n          props: ['value'],\n          template: `\n            <div>\n              <input id=\"input\" :value=\"value\" @input=\"$emit('change', $event.target.value)\">\n            </div>\n          `,\n        },\n      },\n      template: `\n        <div>\n          <Field name=\"field\" rules=\"required\" v-slot=\"{ field, errors }\">\n            <TextInput ref=\"input\" v-bind=\"field\" />\n            <span id=\"error\">{{ errors && errors[0] }}</span>\n          </Field>\n        </div>\n      `,\n    });\n\n    const error = wrapper.$el.querySelector('#error');\n    const input = wrapper.$el.querySelector('#input');\n\n    expect(error.textContent).toBe('');\n\n    setValue(input, '');\n    await flushPromises();\n\n    expect(error.textContent).toBe(REQUIRED_MESSAGE);\n\n    setValue(input, 'val');\n    await flushPromises();\n    expect(error.textContent).toBe('');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"validates target fields using targeted params","suites":["<Field />"],"updatePoint":{"line":287,"column":53},"line":287,"code":"  test('validates target fields using targeted params', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm>\n        <Field rules=\"required\" name=\"confirmation\" />\n\n        <Field name=\"password\" rules=\"required|confirmed:@confirmation\" v-slot=\"{ field, errors }\">\n          <input type=\"password\" v-bind=\"field\">\n          <span id=\"err\">{{ errors[0] }}</span>\n        </Field>\n      </VForm>\n    `,\n    });\n\n    const error = wrapper.$el.querySelector('#err');\n    const inputs = wrapper.$el.querySelectorAll('input');\n\n    expect(error.textContent).toBeFalsy();\n    setValue(inputs[0], 'val');\n    await flushPromises();\n    // the password input hasn't changed yet.\n    expect(error.textContent).toBeFalsy();\n    setValue(inputs[1], '12');\n    await flushPromises();\n    // the password input was interacted with and should be validated.\n    expect(error.textContent).toBeTruthy();\n\n    setValue(inputs[1], 'val');\n    await flushPromises();\n    // the password input now matches the confirmation.\n    expect(error.textContent).toBeFalsy();\n\n    setValue(inputs[0], 'val1');\n    await flushPromises();\n    expect(error.textContent).toBeTruthy();\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"validates file input in scoped slots","suites":["<Field />"],"updatePoint":{"line":324,"column":44},"line":324,"code":"  test('validates file input in scoped slots', async () => {\n    defineRule('atLeastOne', (files: File[]) => {\n      return files && files.length >= 1;\n    });\n\n    const wrapper = mountWithHoc({\n      template: `\n      <div>\n        <Field name=\"field\" rules=\"required|atLeastOne\" v-slot=\"{ field, errors }\">\n          <input type=\"file\" v-bind=\"field\">\n          <p id=\"error\">{{ errors[0] }}</p>\n        </Field>\n      </div>\n    `,\n    });\n\n    const input = wrapper.$el.querySelector('input');\n    dispatchEvent(input, 'change');\n    await flushPromises();\n\n    const error = wrapper.$el.querySelector('#error');\n    expect(error.textContent).toBeTruthy();\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"validates file input by rendering","suites":["<Field />"],"updatePoint":{"line":348,"column":41},"line":348,"code":"  test('validates file input by rendering', async () => {\n    defineRule('atLeastOne', (files: File[]) => {\n      return files && files.length >= 1;\n    });\n\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm v-slot=\"{ errors }\">\n        <Field name=\"field\" rules=\"required|atLeastOne\" type=\"file\" />\n        <span id=\"error\">{{ errors.field }}</span>\n      </VForm>\n    `,\n    });\n\n    const input = wrapper.$el.querySelector('input');\n    dispatchEvent(input, 'change');\n    await flushPromises();\n\n    const error = wrapper.$el.querySelector('#error');\n    expect(error.textContent).toBeTruthy();\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"file values are normalized depending","suites":["<Field />"],"updatePoint":{"line":370,"column":44},"line":370,"code":"  test('file values are normalized depending', async () => {\n    const onSubmit = vi.fn();\n\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm @submit=\"onSubmit\">\n        <Field name=\"single\" type=\"file\" />\n        <Field name=\"multiple\" type=\"file\" multiple />\n\n        <button>submit</button>\n      </VForm>\n    `,\n      setup() {\n        return {\n          onSubmit,\n        };\n      },\n    });\n\n    await flushPromises();\n    const getInput = (name: string) => wrapper.$el.querySelector(`input[name=\"${name}\"]`) as HTMLInputElement;\n    const button = wrapper.$el.querySelector(`button`) as HTMLElement;\n\n    await dispatchFileEvent(getInput('single'), 'test.jpg');\n    await dispatchFileEvent(getInput('multiple'), ['one.jpg', 'two.jpg']);\n\n    button.click();\n    await flushPromises();\n\n    expect(onSubmit).toHaveBeenLastCalledWith(\n      expect.objectContaining({\n        single: expect.any(File),\n        multiple: expect.arrayContaining([expect.any(File), expect.any(File)]),\n      }),\n      expect.anything()\n    );\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"setting bails prop to false disables exit on first error","suites":["<Field />"],"updatePoint":{"line":408,"column":64},"line":408,"code":"  test('setting bails prop to false disables exit on first error', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <div>\n        <Field :bails=\"false\" name=\"field\" rules=\"email|min:3\" v-slot=\"{ field, errors }\">\n          <input v-bind=\"field\" type=\"text\">\n          <p v-for=\"error in errors\">{{ error }}</p>\n        </Field>\n      </div>\n    `,\n    });\n\n    const input = wrapper.$el.querySelector('input');\n    setValue(input, '1');\n    await flushPromises();\n\n    const errors = wrapper.$el.querySelectorAll('p');\n    expect(errors).toHaveLength(2);\n    expect(errors[0].textContent).toBe('The field must be a valid email');\n    expect(errors[1].textContent).toBe('This field must be at least 3 characters');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"yup rules can be used","suites":["<Field />"],"updatePoint":{"line":430,"column":29},"line":430,"code":"  test('yup rules can be used', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        const rules = yup.string().required().min(8);\n\n        return {\n          rules,\n        };\n      },\n      template: `\n      <div>\n        <Field name=\"field\" :rules=\"rules\" v-slot=\"{ field, errors }\">\n          <input v-bind=\"field\" type=\"text\">\n          <p>{{ errors[0] }}</p>\n        </Field>\n      </div>\n    `,\n    });\n\n    const input = wrapper.$el.querySelector('input');\n    const error = wrapper.$el.querySelector('p');\n\n    setValue(input, '');\n    await flushPromises();\n    expect(error.textContent).toBe('this is a required field');\n    setValue(input, '12');\n    await flushPromises();\n    expect(error.textContent).toBe('this must be at least 8 characters');\n    setValue(input, '12345678');\n    await flushPromises();\n    expect(error.textContent).toBe('');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"avoids race conditions between successive validations","suites":["<Field />"],"updatePoint":{"line":463,"column":61},"line":463,"code":"  test('avoids race conditions between successive validations', async () => {\n    // A decreasing timeout (the most recent validation will finish before new ones).\n    defineRule('longRunning', (value: unknown): Promise<boolean | string> => {\n      return new Promise(resolve => {\n        setTimeout(() => {\n          resolve(value === 42 ? true : 'No Life');\n        }, 20);\n      });\n    });\n\n    const wrapper = mountWithHoc({\n      template: `\n      <div>\n        <Field name=\"field\" rules=\"required|longRunning\" v-slot=\"{ field, errors }\">\n          <input v-bind=\"field\" type=\"text\">\n          <p>{{ errors[0] }}</p>\n        </Field>\n      </div>\n    `,\n    });\n\n    const input = wrapper.$el.querySelector('input');\n    const error = wrapper.$el.querySelector('p');\n\n    setValue(input, '123');\n    setValue(input, '12');\n    setValue(input, '');\n    vi.advanceTimersByTime(100);\n    await flushPromises();\n    // LAST message should be the required one.\n    expect(error.textContent).toBe(REQUIRED_MESSAGE);\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"resets validation state using handleReset() in slot scope props","suites":["<Field />"],"updatePoint":{"line":496,"column":71},"line":496,"code":"  test('resets validation state using handleReset() in slot scope props', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <div>\n        <Field name=\"field\" rules=\"required\" v-slot=\"{ field, errors, handleReset }\">\n          <input type=\"text\" v-bind=\"field\">\n          <span id=\"error\">{{ errors && errors[0] }}</span>\n          <button @click=\"handleReset\">Reset</button>\n        </Field>\n      </div>\n    `,\n    });\n\n    const error = wrapper.$el.querySelector('#error');\n    const input = wrapper.$el.querySelector('input');\n\n    expect(error.textContent).toBe('');\n\n    setValue(input, '');\n    await flushPromises();\n    expect(error.textContent).toBe(REQUIRED_MESSAGE);\n    setValue(input, '123');\n    await flushPromises();\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(error.textContent).toBe('');\n    expect(input.value).toBe('');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"resets validation state using resetField() in slot scope props","suites":["<Field />"],"updatePoint":{"line":525,"column":70},"line":525,"code":"  test('resets validation state using resetField() in slot scope props', async () => {\n    const resetMessage = 'field is bad';\n    const resetValue = 'val';\n    const wrapper = mountWithHoc({\n      template: `\n      <div>\n        <Field name=\"field\" rules=\"required\" v-slot=\"{ field, errors, resetField, meta }\">\n          <input type=\"text\" v-bind=\"field\">\n          <span id=\"error\">{{ errors && errors[0] }}</span>\n          <span id=\"touched\">{{ meta.touched.toString() }}</span>\n          <span id=\"dirty\">{{ meta.dirty.toString() }}</span>\n          <button @click=\"resetField({ value: '${resetValue}', touched: true, errors: ['${resetMessage}'] })\">Reset</button>\n        </Field>\n      </div>\n    `,\n    });\n\n    const error = wrapper.$el.querySelector('#error');\n    const input = wrapper.$el.querySelector('input');\n    const dirty = wrapper.$el.querySelector('#dirty');\n    const touched = wrapper.$el.querySelector('#touched');\n\n    expect(error.textContent).toBe('');\n\n    setValue(input, '');\n    await flushPromises();\n    expect(error.textContent).toBe(REQUIRED_MESSAGE);\n    expect(dirty.textContent).toBe('true');\n    expect(touched.textContent).toBe('false');\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(error.textContent).toBe(resetMessage);\n    expect(input.value).toBe(resetValue);\n    expect(dirty.textContent).toBe('false');\n    expect(touched.textContent).toBe('true');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"yup abortEarly is set by bails global option","suites":["<Field />"],"updatePoint":{"line":562,"column":52},"line":562,"code":"  test('yup abortEarly is set by bails global option', async () => {\n    configure({\n      bails: false,\n    });\n    const wrapper = mountWithHoc({\n      setup() {\n        const rules = yup.string().min(8).url();\n\n        return {\n          rules,\n        };\n      },\n      template: `\n      <div>\n        <Field name=\"field\" :rules=\"rules\" v-slot=\"{ errors, field }\">\n          <input type=\"text\" v-bind=\"field\">\n          <ul>\n            <li v-for=\"error in errors\">{{ error }}</li>\n          </ul>\n        </Field>\n      </div>\n    `,\n    });\n\n    await flushPromises();\n    const errors = wrapper.$el.querySelector('ul');\n    const input = wrapper.$el.querySelector('input');\n    expect(errors.children).toHaveLength(0);\n\n    setValue(input, '1234');\n    await flushPromises();\n    expect(errors.children).toHaveLength(2);\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"yup abortEarly is set by bails prop","suites":["<Field />"],"updatePoint":{"line":596,"column":43},"line":596,"code":"  test('yup abortEarly is set by bails prop', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        const rules = yup.string().min(8).url();\n\n        return {\n          rules,\n        };\n      },\n      template: `\n      <div>\n        <Field name=\"field\" :rules=\"rules\" v-slot=\"{ errors, field }\" :bails=\"false\">\n          <input type=\"text\" v-bind=\"field\">\n          <ul>\n            <li v-for=\"error in errors\">{{ error }}</li>\n          </ul>\n        </Field>\n      </div>\n    `,\n    });\n\n    await flushPromises();\n    const errors = wrapper.$el.querySelector('ul');\n    const input = wrapper.$el.querySelector('input');\n    expect(errors.children).toHaveLength(0);\n\n    setValue(input, '1234');\n    await flushPromises();\n    expect(errors.children).toHaveLength(2);\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"handleInput() updates the model","suites":["<Field />"],"updatePoint":{"line":627,"column":39},"line":627,"code":"  test('handleInput() updates the model', async () => {\n    let inputValue!: Ref<string>;\n    const wrapper = mountWithHoc({\n      setup() {\n        inputValue = ref('');\n        return {\n          value: inputValue,\n        };\n      },\n      template: `\n      <div>\n        <Field v-model=\"value\" name=\"field\" v-slot=\"{ handleInput }\">\n          <input :value=\"value\" @input=\"handleInput\" />\n        </Field>\n      </div>\n    `,\n    });\n\n    await flushPromises();\n    const input = wrapper.$el.querySelector('input');\n    setValue(input, '1234');\n    await flushPromises();\n    expect(inputValue.value).toBe('1234');\n\n    inputValue.value = '455';\n    await flushPromises();\n    expect(input.value).toBe('455');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"generateMessage is invoked with custom fn rules","suites":["<Field />"],"updatePoint":{"line":656,"column":55},"line":656,"code":"  test('generateMessage is invoked with custom fn rules', async () => {\n    configure({\n      generateMessage: ({ field }) => `${field} is bad`,\n    });\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          rules: () => false,\n        };\n      },\n      template: `\n      <div>\n        <Field :rules=\"rules\" name=\"field\" v-slot=\"{ field, errors }\">\n          <input type=\"text\" v-bind=\"field\">\n          <p id=\"error\">{{ errors[0] }}</p>\n        </Field>\n      </div>\n    `,\n    });\n\n    await flushPromises();\n    const input = wrapper.$el.querySelector('input');\n    const error = wrapper.$el.querySelector('#error');\n    setValue(input, '1234');\n    await flushPromises();\n    expect(error.textContent).toBe('field is bad');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can customize validation triggers via global config","suites":["<Field />"],"updatePoint":{"line":684,"column":59},"line":684,"code":"  test('can customize validation triggers via global config', async () => {\n    configure({\n      validateOnChange: false,\n      validateOnInput: true,\n    });\n\n    const wrapper = mountWithHoc({\n      template: `\n      <div>\n        <Field name=\"field\" rules=\"required\" v-slot=\"{ field, errors }\">\n          <input v-bind=\"field\" type=\"text\">\n          <span id=\"error\">{{ errors[0] }}</span>\n        </Field>\n      </div>\n    `,\n    });\n\n    const error = wrapper.$el.querySelector('#error');\n    const input = wrapper.$el.querySelector('input');\n    input.value = '';\n    dispatchEvent(input, 'change');\n    await flushPromises();\n    // nothing got triggered\n    expect(error.textContent).toBe('');\n\n    input.value = '';\n    dispatchEvent(input, 'input');\n    await flushPromises();\n    expect(error.textContent).toBe(REQUIRED_MESSAGE);\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can customize validation triggers via props","suites":["<Field />"],"updatePoint":{"line":715,"column":51},"line":715,"code":"  test('can customize validation triggers via props', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <div>\n        <Field name=\"field\" rules=\"required\" v-slot=\"{ field, errors }\" validateOnInput :validateOnChange=\"false\">\n          <input v-bind=\"field\" type=\"text\">\n          <span id=\"error\">{{ errors[0] }}</span>\n        </Field>\n      </div>\n    `,\n    });\n\n    const error = wrapper.$el.querySelector('#error');\n    const input = wrapper.$el.querySelector('input');\n    input.value = '';\n    dispatchEvent(input, 'change');\n    await flushPromises();\n    // nothing got triggered\n    expect(error.textContent).toBe('');\n\n    input.value = '';\n    dispatchEvent(input, 'input');\n    await flushPromises();\n    expect(error.textContent).toBe(REQUIRED_MESSAGE);\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can show custom labels for fields in messages","suites":["<Field />"],"updatePoint":{"line":741,"column":53},"line":741,"code":"  test('can show custom labels for fields in messages', async () => {\n    configure({\n      generateMessage: ({ field }) => `${field} is bad`,\n    });\n\n    defineRule('noMessage', (value: number) => {\n      return value === 48;\n    });\n\n    const wrapper = mountWithHoc({\n      template: `\n      <div>\n        <Field name=\"_bad_field_name\" label=\"nice name\" rules=\"noMessage\" v-slot=\"{ field, errors }\">\n          <input v-bind=\"field\" type=\"text\">\n          <span id=\"error\">{{ errors[0] }}</span>\n        </Field>\n      </div>\n    `,\n    });\n\n    const error = wrapper.$el.querySelector('#error');\n    const input = wrapper.$el.querySelector('input');\n    setValue(input, '3');\n    await flushPromises();\n    expect(error.textContent).toBe('nice name is bad');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can set touched meta","suites":["<Field />"],"updatePoint":{"line":768,"column":28},"line":768,"code":"  test('can set touched meta', async () => {\n    mountWithHoc({\n      template: `\n      <Field name=\"field\" v-slot=\"{ meta, setTouched }\">\n        <span>{{ meta.touched }}</span>\n        <button @click=\"setTouched(true)\">Set Meta</button>\n      </Field>\n    `,\n    });\n\n    await flushPromises();\n    const span = document.querySelector('span');\n    expect(span?.textContent).toBe('false');\n    document.querySelector('button')?.click();\n    await flushPromises();\n    expect(span?.textContent).toBe('true');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"labels can be set dynamically","suites":["<Field />"],"updatePoint":{"line":787,"column":37},"line":787,"code":"  test('labels can be set dynamically', async () => {\n    const label = ref('label');\n    const message = (field: string) => `${field} is not valid`;\n\n    mountWithHoc({\n      setup() {\n        const rules = (_: any, { field }: any) => message(field);\n\n        return {\n          rules,\n          label,\n        };\n      },\n      template: `\n        <Field name=\"field\" :rules=\"rules\" :label=\"label\" v-slot=\"{ errors, field }\">\n          <input v-bind=\"field\" type=\"text\">\n          <span>{{ errors[0] }}</span>\n        </Field>\n    `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input') as HTMLInputElement;\n    setValue(input, '1');\n    await flushPromises();\n    expect(document.querySelector('span')?.textContent).toBe(message(label.value));\n\n    label.value = 'updated';\n    await flushPromises();\n    setValue(input, '2');\n    await flushPromises();\n    expect(document.querySelector('span')?.textContent).toBe(message(label.value));\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"proxies native listeners","suites":["<Field />"],"updatePoint":{"line":822,"column":32},"line":822,"code":"  test('proxies native listeners', async () => {\n    const onBlur = vi.fn();\n    mountWithHoc({\n      setup() {\n        return {\n          onBlur,\n        };\n      },\n      template: `\n      <Field name=\"field\" @blur=\"onBlur\" />\n    `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input');\n    dispatchEvent(input as HTMLInputElement, 'blur');\n    expect(onBlur).toHaveBeenCalledTimes(1);\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can customize checkboxes unchecked value","suites":["<Field />"],"updatePoint":{"line":841,"column":48},"line":841,"code":"  test('can customize checkboxes unchecked value', async () => {\n    const spy = vi.fn();\n    const wrapper = mountWithHoc({\n      setup() {\n        return { onSubmit: spy };\n      },\n      template: `\n      <VForm @submit=\"onSubmit\">\n        <Field name=\"terms\" type=\"checkbox\" :unchecked-value=\"false\" :value=\"true\" /> Coffee\n\n        <button type=\"submit\">Submit</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const input = wrapper.$el.querySelector('input');\n    setChecked(input, true);\n    await flushPromises();\n    setChecked(input, false);\n    await flushPromises();\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(spy).toHaveBeenCalledWith(expect.objectContaining({ terms: false }), expect.anything());\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"single checkboxes without forms toggles their value with v-model","suites":["<Field />"],"updatePoint":{"line":868,"column":72},"line":868,"code":"  test('single checkboxes without forms toggles their value with v-model', async () => {\n    let model!: Ref<boolean>;\n    const wrapper = mountWithHoc({\n      setup() {\n        model = ref(false);\n\n        return { model };\n      },\n      template: `\n      <div>\n        <Field name=\"terms\" type=\"checkbox\" v-model=\"model\" :unchecked-value=\"false\" :value=\"true\" /> Dinner?\n      </div>\n    `,\n    });\n\n    await flushPromises();\n    const input = wrapper.$el.querySelector('input');\n    setChecked(input, true);\n    await flushPromises();\n    expect(model.value).toBe(true);\n    setChecked(input, false);\n    await flushPromises();\n    expect(model.value).toBe(false);\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"sets initial value with v-model","suites":["<Field />"],"updatePoint":{"line":894,"column":39},"line":894,"code":"  test('sets initial value with v-model', async () => {\n    const modelValue = 'allo';\n    const wrapper = mountWithHoc({\n      setup() {\n        const model = ref(modelValue);\n\n        return { model };\n      },\n      template: `\n      <div>\n        <Field name=\"whatever\" v-model=\"model\" />\n      </div>\n    `,\n    });\n\n    await flushPromises();\n    const input = wrapper.$el.querySelector('input');\n    expect(input.value).toBe(modelValue);\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"resetField should reset the valid flag to false if the rules are incorrect","suites":["<Field />"],"updatePoint":{"line":914,"column":82},"line":914,"code":"  test('resetField should reset the valid flag to false if the rules are incorrect', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <div>\n        <Field name=\"whatever\" v-slot=\"{ meta, field, resetField }\" rules=\"required\">\n          <input v-bind=\"field\" />\n          <span id=\"meta\">{{ meta.valid ? 'valid' : 'invalid' }}</span>\n          <button @click=\"resetField\">Reset</button>\n        </Field>\n      </div>\n    `,\n    });\n\n    await flushPromises();\n    const input = wrapper.$el.querySelector('input');\n    const meta = wrapper.$el.querySelector('#meta');\n\n    expect(meta?.textContent).toBe('invalid');\n    setValue(input, '');\n    await flushPromises();\n    expect(meta?.textContent).toBe('invalid');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(meta?.textContent).toBe('invalid');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"valid flag is synced with the field errors array length","suites":["<Field />"],"updatePoint":{"line":941,"column":63},"line":941,"code":"  test('valid flag is synced with the field errors array length', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <div>\n        <Field name=\"whatever\" v-slot=\"{ meta, field, resetField }\" rules=\"required\">\n          <input v-bind=\"field\" />\n          <span id=\"meta\">{{ meta.valid ? 'valid' : 'invalid' }}</span>\n          <button @click=\"resetField({ errors: ['bad'] })\">Reset</button>\n        </Field>\n      </div>\n    `,\n    });\n\n    await flushPromises();\n    const meta = wrapper.$el.querySelector('#meta');\n    expect(meta?.textContent).toBe('invalid');\n    const input = wrapper.$el.querySelector('input');\n    setValue(input, '');\n    await flushPromises();\n    expect(meta?.textContent).toBe('invalid');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(meta?.textContent).toBe('invalid');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can set multiple field errors","suites":["<Field />"],"updatePoint":{"line":967,"column":37},"line":967,"code":"  test('can set multiple field errors', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <div>\n        <Field name=\"whatever\" v-slot=\"{ field, errors, setErrors }\" rules=\"required\">\n          <input v-bind=\"field\" />\n          <ul>\n            <li v-for=\"error in errors\">{{ error }}</li>\n          </ul>\n          <button type=\"button\" @click=\"setErrors(['bad', 'wrong'])\">Set errors</button>\n        </Field>\n      </div>\n    `,\n    });\n\n    await flushPromises();\n    const list = document.querySelector('ul');\n    expect(list?.children).toHaveLength(0);\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(list?.children).toHaveLength(2);\n    expect(list?.textContent).toBe('badwrong');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"v-model.number should not ignore the validation triggers","suites":["<Field />"],"updatePoint":{"line":992,"column":64},"line":992,"code":"  test('v-model.number should not ignore the validation triggers', async () => {\n    const errorMessage = 'Field is invalid';\n    let model!: Ref<string | number>;\n    const wrapper = mountWithHoc({\n      setup() {\n        model = ref('');\n        const isAlwaysInvalid = () => errorMessage;\n\n        return { model, isAlwaysInvalid };\n      },\n      template: `\n      <div>\n        <Field v-model.number=\"model\" name=\"field\" :rules=\"isAlwaysInvalid\" v-slot=\"{ field, errors }\" :validateOnModelUpdate=\"false\">\n          <input v-bind=\"field\" id=\"input\" type=\"text\">\n          <span id=\"error\">{{ errors[0] }}</span>\n        </Field>\n      </div>\n    `,\n    });\n\n    const error = wrapper.$el.querySelector('#error');\n    const input = wrapper.$el.querySelector('#input');\n    input.value = '310';\n    dispatchEvent(input, 'input');\n    await flushPromises();\n    expect(model.value).toBe(310);\n    expect(error.textContent).toBe('');\n\n    dispatchEvent(input, 'blur');\n    await flushPromises();\n    expect(error.textContent).toBe(errorMessage);\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"v-model on a non-existent nested prop should still emit model events","suites":["<Field />"],"updatePoint":{"line":1026,"column":76},"line":1026,"code":"  test('v-model on a non-existent nested prop should still emit model events', async () => {\n    const form = reactive({});\n    const wrapper = mountWithHoc({\n      setup() {\n        return { form };\n      },\n      template: `\n      <div>\n        <Field v-model=\"form.field\" name=\"field\" />\n      </div>\n    `,\n    });\n\n    await flushPromises();\n    const input = wrapper.$el.querySelector('input');\n    input.value = 'hello';\n    dispatchEvent(input, 'input');\n    await flushPromises();\n    expect((form as any).field).toBe('hello');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"should preserve select input options value type","suites":["<Field />"],"updatePoint":{"line":1048,"column":55},"line":1048,"code":"  test('should preserve select input options value type', async () => {\n    const value = ref();\n\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          value,\n        };\n      },\n      template: `\n        <Field as=\"select\" v-model=\"value\" name=\"hello\">\n          <option id=\"true\" :value=\"true\">Yes</option>\n          <option id=\"false\" :value=\"false\">No</option>\n        </Field>\n    `,\n    });\n\n    await flushPromises();\n    const select = document.querySelector('select') as HTMLSelectElement;\n    const optTrue = document.querySelector('#true') as HTMLOptionElement;\n    const optFalse = document.querySelector('#false') as HTMLOptionElement;\n\n    optTrue.selected = true;\n    dispatchEvent(select, 'change');\n    await flushPromises();\n    expect(value.value).toBe(true);\n\n    optFalse.selected = true;\n    dispatchEvent(select, 'change');\n    await flushPromises();\n    expect(value.value).toBe(false);\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"should avoid setting the absent value to Vue","suites":["<Field />"],"updatePoint":{"line":1082,"column":52},"line":1082,"code":"  test('should avoid setting the absent value to Vue', async () => {\n    const form = ref({});\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          form,\n        };\n      },\n      template: `\n        <Field v-model=\"form.value\" name=\"hello\" />\n      `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input') as HTMLInputElement;\n    setValue(input, '1234');\n    await flushPromises();\n    expect(input.value).toBe('1234');\n    form.value = {};\n    await flushPromises();\n    expect(input.value).toBe('');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"computed rules should not generate errors unless the field was validated before","suites":["<Field />"],"updatePoint":{"line":1106,"column":87},"line":1106,"code":"  test('computed rules should not generate errors unless the field was validated before', async () => {\n    const isRequired = ref(false);\n    const rules = computed(() => (isRequired.value ? 'required' : ''));\n    mountWithHoc({\n      setup() {\n        return {\n          rules,\n        };\n      },\n      template: `\n        <Field name=\"field\" :rules=\"rules\" v-slot=\"{ errorMessage, field }\">\n          <input v-bind=\"field\" />\n          <span>{{ errorMessage }}</span>\n        </Field>\n      `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input') as HTMLInputElement;\n    const error = document.querySelector('span') as HTMLInputElement;\n    isRequired.value = true;\n    await flushPromises();\n    expect(error.textContent).toBe('');\n    isRequired.value = false;\n    await flushPromises();\n    expect(error.textContent).toBe('');\n    setValue(input, '');\n    await flushPromises();\n    isRequired.value = true;\n    await flushPromises();\n    expect(error.textContent).toBe(REQUIRED_MESSAGE);\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"resets validation state using refs and exposed API","suites":["<Field />"],"updatePoint":{"line":1139,"column":58},"line":1139,"code":"  test('resets validation state using refs and exposed API', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <div>\n        <Field name=\"field\" ref=\"field\" rules=\"required\" v-slot=\"{ errors, field }\">\n          <input type=\"text\" v-bind=\"field\">\n          <span id=\"error\">{{ errors && errors[0] }}</span>\n        </Field>\n\n        <button @click=\"$refs.field.reset()\">Reset</button>\n      </div>\n    `,\n    });\n\n    const error = wrapper.$el.querySelector('#error');\n    const input = wrapper.$el.querySelector('input');\n\n    expect(error.textContent).toBe('');\n\n    setValue(input, '');\n    await flushPromises();\n    expect(error.textContent).toBe(REQUIRED_MESSAGE);\n    setValue(input, '123');\n    await flushPromises();\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(error.textContent).toBe('');\n    expect(input.value).toBe('');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"should have correct field object binding properties based on file type","suites":["<Field />"],"updatePoint":{"line":1169,"column":78},"line":1169,"code":"  test('should have correct field object binding properties based on file type', async () => {\n    const textualType = vi.fn();\n    const fileType = vi.fn();\n    const checkboxType = vi.fn();\n    const radioType = vi.fn();\n\n    mountWithHoc({\n      template: `\n      <div>\n        <Field name=\"text\" v-slot=\"{ field }\">\n          {{ textualType(field) }}\n        </Field>\n        <Field name=\"file\" type=\"file\" v-slot=\"{ field }\">\n          {{ fileType(field) }}\n        </Field>\n        <Field name=\"checkbox\" type=\"checkbox\" v-slot=\"{ field }\">\n          {{ checkboxType(field) }}\n        </Field>\n        <Field name=\"radio\" type=\"radio\" v-slot=\"{ field }\">\n          {{ radioType(field) }}\n        </Field>\n      </div>\n    `,\n      setup() {\n        return {\n          textualType,\n          fileType,\n          checkboxType,\n          radioType,\n        };\n      },\n    });\n\n    await flushPromises();\n    const lastCallOf = (fn: ReturnType<typeof vi.fn>) => fn.mock.calls[fn.mock.calls.length - 1][0];\n    expect(lastCallOf(textualType)).toHaveProperty('value');\n    expect(lastCallOf(fileType)).not.toHaveProperty('value');\n    expect(lastCallOf(checkboxType)).toHaveProperty('checked');\n    expect(lastCallOf(checkboxType)).not.toHaveProperty('value');\n    expect(lastCallOf(radioType)).toHaveProperty('checked');\n    expect(lastCallOf(radioType)).not.toHaveProperty('value');\n  });","file":"Field.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"warns if no form is detected","suites":[],"updatePoint":{"line":8,"column":34},"line":8,"code":"test('warns if no form is detected', async () => {\n  const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n    // NOOP\n  });\n\n  mountWithHoc({\n    template: `\n      <FieldArray name=\"users\" />\n    `,\n  });\n\n  await flushPromises();\n  expect(spy).toHaveBeenCalled();\n  spy.mockRestore();\n});","file":"FieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"warns if no name path is provided","suites":[],"updatePoint":{"line":24,"column":39},"line":24,"code":"test('warns if no name path is provided', async () => {\n  const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n    // NOOP\n  });\n\n  mountWithHoc({\n    template: `\n      <VForm>\n        <FieldArray />\n      </VForm>\n      `,\n  });\n\n  await flushPromises();\n  expect(spy).toHaveBeenCalled();\n  spy.mockRestore();\n});","file":"FieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"adds items to the end of the array with push()","suites":[],"updatePoint":{"line":42,"column":52},"line":42,"code":"test('adds items to the end of the array with push()', async () => {\n  const onSubmit = vi.fn();\n  mountWithHoc({\n    setup() {\n      const initialValues = {\n        users: [{ name: '111' }, { name: '222' }, { name: '333' }],\n      };\n\n      return {\n        onSubmit,\n        initialValues,\n      };\n    },\n    template: `\n      <VForm @submit=\"onSubmit\" :initial-values=\"initialValues\">\n        <FieldArray name=\"users\" v-slot=\"{ remove, push, fields }\">\n          <fieldset v-for=\"(field, idx) in fields\" :key=\"field.key\">\n            <legend>User #{{ idx }}</legend>\n            <label :for=\"'name_' + idx\">Name</label>\n            <Field :id=\"'name_' + idx\" :name=\"'users[' + idx + '].name'\" />\n            <ErrorMessage :name=\"'users[' + idx + '].name'\" />\n\n            <button class=\"remove\" type=\"button\" @click=\"remove(idx)\">X</button>\n          </fieldset>\n\n          <button class=\"add\" type=\"button\" @click=\"push({ name: 'new' })\">Add User +</button>\n        </FieldArray>\n\n        <button class=\"submit\" type=\"submit\">Submit</button>\n      </VForm>\n    `,\n  });\n\n  await flushPromises();\n  const submitBtn = document.querySelector('.submit') as HTMLButtonElement;\n  const inputs = Array.from(document.querySelectorAll('input')) as HTMLInputElement[];\n  const removeBtn = document.querySelectorAll('.remove')[1] as HTMLButtonElement; // remove the second item\n  setValue(inputs[0], '111');\n  setValue(inputs[1], '222');\n  setValue(inputs[2], '333');\n  await flushPromises();\n  removeBtn.click();\n  await flushPromises();\n  (submitBtn as HTMLButtonElement).click();\n  await flushPromises();\n  expect(onSubmit).toHaveBeenLastCalledWith(\n    expect.objectContaining({\n      users: [{ name: '111' }, { name: '333' }],\n    }),\n    expect.anything()\n  );\n\n  dispatchEvent('.add', 'click');\n  await flushPromises();\n  (submitBtn as HTMLButtonElement).click();\n  await flushPromises();\n  expect(onSubmit).toHaveBeenLastCalledWith(\n    expect.objectContaining({\n      users: [{ name: '111' }, { name: '333' }, { name: 'new' }],\n    }),\n    expect.anything()\n  );\n});","file":"FieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"array fields should update their values when swapped","suites":[],"updatePoint":{"line":106,"column":58},"line":106,"code":"test('array fields should update their values when swapped', async () => {\n  mountWithHoc({\n    setup() {\n      const initial = {\n        users: [\n          {\n            name: 'first',\n          },\n          {\n            name: 'second',\n          },\n          {\n            name: 'third',\n          },\n        ],\n      };\n\n      return {\n        initial,\n      };\n    },\n    template: `\n      <VForm :initial-values=\"initial\">\n\n        <FieldArray name=\"users\" v-slot=\"{ remove, push, fields }\">\n          <fieldset v-for=\"(field, idx) in fields\" :key=\"field.key\">\n            <Field :id=\"\\`name_\\${idx}\\`\" :name=\"\\`users[\\${idx}].name\\`\" />\n            <button :class=\"\\`remove_\\${idx}\\`\" type=\"button\" @click=\"remove(idx)\">X</button>\n          </fieldset>\n\n          <button class=\"add\" type=\"button\" @click=\"push({ name: '' })\">Add User +</button>\n        </FieldArray>\n\n        <button type=\"submit\">Submit</button>\n      </VForm>\n    `,\n  });\n\n  await flushPromises();\n  expect(document.querySelectorAll('input')).toHaveLength(3);\n  dispatchEvent('.remove_0', 'click');\n  await flushPromises();\n  expect(document.querySelectorAll('input')).toHaveLength(2);\n  expect(getValue('#name_0')).toBe('second');\n\n  dispatchEvent('.add', 'click');\n  await flushPromises();\n  expect(document.querySelectorAll('input')).toHaveLength(3);\n  expect(getValue('#name_2')).toBe('');\n});","file":"FieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can swap array fields with swap helper","suites":[],"updatePoint":{"line":157,"column":44},"line":157,"code":"test('can swap array fields with swap helper', async () => {\n  const onSubmit = vi.fn();\n  mountWithHoc({\n    setup() {\n      const schema = yup.object({\n        users: yup\n          .array()\n          .of(\n            yup.object({\n              name: yup.string().required(REQUIRED_MESSAGE),\n            })\n          )\n          .strict(),\n      });\n\n      const initial = {\n        users: [\n          {\n            name: 'first',\n          },\n          {\n            name: 'second',\n          },\n          {\n            name: 'third',\n          },\n        ],\n      };\n\n      return {\n        initial,\n        schema,\n        onSubmit,\n      };\n    },\n    template: `\n    <VForm @submit=\"onSubmit\" :validation-schema=\"schema\" :initial-values=\"initial\">\n      <FieldArray name=\"users\" v-slot=\"{ swap, fields }\">\n          <div v-for=\"(field, idx) in fields\" :key=\"field.key\">\n            <button class=\"up\" @click=\"swap(idx, idx - 1)\" type=\"button\">⬆️</button>\n\n            <Field :name=\"'users[' + idx + '].name'\" />\n            <ErrorMessage :class=\"'error-' + idx\" :name=\"'users[' + idx + '].name'\" />\n          </div>\n      </FieldArray>\n\n      <button class=\"submit\" type=\"submit\">Submit</button>\n    </VForm>\n    `,\n  });\n\n  await flushPromises();\n  const inputAt = (idx: number) => (document.querySelectorAll('input') || [])[idx] as HTMLInputElement;\n  const errorAt = (idx: number) => document.querySelector(`.error-${idx}`) as HTMLElement;\n  const upButtonAt = (idx: number) => (document.querySelectorAll('.up') || [])[idx] as HTMLElement;\n  const submitBtn = () => document.querySelector('.submit') as HTMLButtonElement;\n\n  expect(getValue(inputAt(0))).toBe('first');\n  expect(getValue(inputAt(1))).toBe('second');\n  expect(getValue(inputAt(2))).toBe('third');\n\n  setValue(inputAt(1), '');\n  await flushPromises();\n  expect(errorAt(1)?.textContent).toBe(REQUIRED_MESSAGE);\n\n  upButtonAt(2).click();\n  await flushPromises();\n  expect(getValue(inputAt(1))).toBe('third');\n  // undefined because it should be unmounted\n  expect(errorAt(1)?.textContent).toBe(undefined);\n\n  expect(getValue(inputAt(2))).toBe('');\n  expect(errorAt(2)?.textContent).toBe(REQUIRED_MESSAGE);\n\n  setValue(inputAt(2), 'edited');\n  await flushPromises();\n\n  submitBtn().click();\n  await flushPromises();\n\n  expect(onSubmit).toHaveBeenCalledTimes(1);\n  expect(onSubmit).toHaveBeenLastCalledWith(\n    expect.objectContaining({\n      users: [\n        {\n          name: 'first',\n        },\n        {\n          name: 'third',\n        },\n        {\n          name: 'edited',\n        },\n      ],\n    }),\n    expect.anything()\n  );\n});","file":"FieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"fields have isFirst and isLast flags to help with conditions","suites":[],"updatePoint":{"line":256,"column":66},"line":256,"code":"test('fields have isFirst and isLast flags to help with conditions', async () => {\n  mountWithHoc({\n    setup() {\n      const initial = {\n        users: [\n          {\n            name: 'first',\n          },\n          {\n            name: 'second',\n          },\n          {\n            name: 'third',\n          },\n        ],\n      };\n\n      return {\n        initial,\n      };\n    },\n    template: `\n    <VForm :initial-values=\"initial\">\n      <FieldArray name=\"users\" v-slot=\"{ swap, fields, push, remove }\">\n          <div v-for=\"(field, idx) in fields\" :key=\"field.key\">\n            <button class=\"up\" @click=\"swap(idx, idx - 1)\" :disabled=\"field.isFirst\" type=\"button\">⬆️</button>\n            <button class=\"down\" @click=\"swap(idx, idx + 1)\" :disabled=\"field.isLast\" type=\"button\">⬇️</button>\n            <button class=\"remove\" type=\"button\" @click=\"remove(idx)\">X</button>\n\n\n            <Field :name=\"'users[' + idx + '].name'\" />\n          </div>\n          <button class=\"add\" type=\"button\" @click=\"push({ name: '' })\">Add User +</button>\n      </FieldArray>\n\n    </VForm>\n    `,\n  });\n\n  await flushPromises();\n  const upButtonAt = (idx: number) => (document.querySelectorAll('.up') || [])[idx] as HTMLButtonElement;\n  const downButtonAt = (idx: number) => (document.querySelectorAll('.down') || [])[idx] as HTMLButtonElement;\n  const rmButtonAt = (idx: number) => (document.querySelectorAll('.remove') || [])[idx] as HTMLButtonElement;\n  const addButton = () => document.querySelector('.add') as HTMLButtonElement;\n\n  expect(upButtonAt(0).disabled).toBe(true);\n  expect(upButtonAt(1).disabled).toBe(false);\n  expect(upButtonAt(2).disabled).toBe(false);\n\n  expect(downButtonAt(0).disabled).toBe(false);\n  expect(downButtonAt(1).disabled).toBe(false);\n  expect(downButtonAt(2).disabled).toBe(true);\n\n  addButton().click();\n  await flushPromises();\n\n  expect(upButtonAt(0).disabled).toBe(true);\n  expect(upButtonAt(1).disabled).toBe(false);\n  expect(upButtonAt(2).disabled).toBe(false);\n  expect(upButtonAt(3).disabled).toBe(false);\n\n  expect(downButtonAt(0).disabled).toBe(false);\n  expect(downButtonAt(1).disabled).toBe(false);\n  expect(downButtonAt(2).disabled).toBe(false);\n  expect(downButtonAt(3).disabled).toBe(true);\n\n  rmButtonAt(2).click();\n  await flushPromises();\n\n  expect(upButtonAt(0).disabled).toBe(true);\n  expect(upButtonAt(1).disabled).toBe(false);\n  expect(upButtonAt(2).disabled).toBe(false);\n\n  expect(downButtonAt(0).disabled).toBe(false);\n  expect(downButtonAt(1).disabled).toBe(false);\n  expect(downButtonAt(2).disabled).toBe(true);\n});","file":"FieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can insert new items at specific index","suites":[],"updatePoint":{"line":334,"column":44},"line":334,"code":"test('can insert new items at specific index', async () => {\n  mountWithHoc({\n    setup() {\n      const initial = {\n        users: [\n          {\n            name: 'first',\n          },\n          {\n            name: 'second',\n          },\n          {\n            name: 'third',\n          },\n        ],\n      };\n\n      return {\n        initial,\n      };\n    },\n    template: `\n    <VForm :initial-values=\"initial\">\n      <FieldArray name=\"users\" v-slot=\"{ fields, insert }\">\n          <div v-for=\"(field, idx) in fields\" :key=\"field.key\">\n            <Field :name=\"'users[' + idx + '].name'\" />\n          </div>\n          <button class=\"insert\" type=\"button\" @click=\"insert(1, { name: 'inserted' })\">Add User +</button>\n      </FieldArray>\n    </VForm>\n    `,\n  });\n\n  await flushPromises();\n  const inputAt = (idx: number) => (document.querySelectorAll('input') || [])[idx] as HTMLInputElement;\n  const insertButton = () => document.querySelector('.insert') as HTMLButtonElement;\n\n  expect(getValue(inputAt(1))).toBe('second');\n  expect(getValue(inputAt(2))).toBe('third');\n\n  insertButton().click();\n  await flushPromises();\n\n  expect(getValue(inputAt(1))).toBe('inserted');\n  expect(getValue(inputAt(2))).toBe('second');\n  expect(getValue(inputAt(3))).toBe('third');\n});","file":"FieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can replace all the items in the field array","suites":[],"updatePoint":{"line":382,"column":50},"line":382,"code":"test('can replace all the items in the field array', async () => {\n  mountWithHoc({\n    setup() {\n      const initial = {\n        users: [\n          {\n            name: 'first',\n          },\n          {\n            name: 'second',\n          },\n          {\n            name: 'third',\n          },\n        ],\n      };\n\n      return {\n        initial,\n      };\n    },\n    template: `\n    <VForm :initial-values=\"initial\">\n      <FieldArray name=\"users\" v-slot=\"{ fields, replace }\">\n          <div v-for=\"(field, idx) in fields\" :key=\"field.key\">\n            <Field :name=\"'users[' + idx + '].name'\" />\n          </div>\n          <button class=\"replace\" type=\"button\" @click=\"replace([{ name: 'replaced' }])\">Replace</button>\n      </FieldArray>\n    </VForm>\n    `,\n  });\n\n  await flushPromises();\n  const inputAt = (idx: number) => (document.querySelectorAll('input') || [])[idx] as HTMLInputElement;\n  const replaceButton = () => document.querySelector('.replace') as HTMLButtonElement;\n\n  expect(getValue(inputAt(0))).toBe('first');\n  expect(getValue(inputAt(1))).toBe('second');\n  expect(getValue(inputAt(2))).toBe('third');\n\n  replaceButton().click();\n  await flushPromises();\n\n  expect(getValue(inputAt(0))).toBe('replaced');\n  expect(getValue(inputAt(1))).toBe(undefined);\n  expect(getValue(inputAt(2))).toBe(undefined);\n});","file":"FieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can update an item value at a given array index","suites":[],"updatePoint":{"line":431,"column":53},"line":431,"code":"test('can update an item value at a given array index', async () => {\n  mountWithHoc({\n    setup() {\n      const initial = {\n        users: [\n          {\n            name: 'first',\n          },\n          {\n            name: 'second',\n          },\n          {\n            name: 'third',\n          },\n        ],\n      };\n\n      return {\n        initial,\n      };\n    },\n    template: `\n    <VForm :initial-values=\"initial\">\n      <FieldArray name=\"users\" v-slot=\"{ fields, update }\">\n          <div v-for=\"(field, idx) in fields\" :key=\"field.key\">\n            <Field :name=\"'users[' + idx + '].name'\" />\n          </div>\n          <button class=\"update\" type=\"button\" @click=\"update(1, { name: 'updated' })\">Update</button>\n      </FieldArray>\n    </VForm>\n    `,\n  });\n\n  await flushPromises();\n  const inputAt = (idx: number) => (document.querySelectorAll('input') || [])[idx] as HTMLInputElement;\n  const updateButton = () => document.querySelector('.update') as HTMLButtonElement;\n\n  expect(getValue(inputAt(1))).toBe('second');\n\n  updateButton().click();\n  await flushPromises();\n\n  expect(getValue(inputAt(1))).toBe('updated');\n});","file":"FieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can update an item value directly with .value setter","suites":[],"updatePoint":{"line":476,"column":58},"line":476,"code":"test('can update an item value directly with .value setter', async () => {\n  const onSubmit = vi.fn();\n  mountWithHoc({\n    setup() {\n      const initial = {\n        users: [\n          {\n            name: 'first',\n          },\n        ],\n      };\n\n      return {\n        initial,\n        onSubmit,\n      };\n    },\n    template: `\n    <VForm :initial-values=\"initial\" @submit=\"onSubmit\">\n      <FieldArray name=\"users\" v-slot=\"{ fields }\">\n          <div v-for=\"(field, idx) in fields\" :key=\"field.key\">\n            <input v-model=\"fields[idx].value.name\" />\n          </div>\n      </FieldArray>\n\n      <button>Submit</button>\n    </VForm>\n    `,\n  });\n\n  await flushPromises();\n  const inputAt = (idx: number) => (document.querySelectorAll('input') || [])[idx] as HTMLInputElement;\n\n  expect(getValue(inputAt(0))).toBe('first');\n  setValue(inputAt(0), 'updated');\n  await flushPromises();\n  expect(getValue(inputAt(0))).toBe('updated');\n  document.querySelector('button')?.click();\n  await flushPromises();\n\n  expect(onSubmit).toHaveBeenLastCalledWith(\n    expect.objectContaining({\n      users: [\n        {\n          name: 'updated',\n        },\n      ],\n    }),\n    expect.anything()\n  );\n});","file":"FieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"adds items to the start of the array with prepend()","suites":[],"updatePoint":{"line":528,"column":57},"line":528,"code":"test('adds items to the start of the array with prepend()', async () => {\n  const onSubmit = vi.fn();\n  mountWithHoc({\n    setup() {\n      const initialValues = {\n        users: [{ name: '111' }, { name: '222' }],\n      };\n\n      return {\n        onSubmit,\n        initialValues,\n      };\n    },\n    template: `\n      <VForm @submit=\"onSubmit\" :initial-values=\"initialValues\">\n        <FieldArray name=\"users\" v-slot=\"{ remove, prepend, fields }\">\n          <fieldset v-for=\"(field, idx) in fields\" :key=\"field.key\">\n            <legend>User #{{ idx }}</legend>\n            <label :for=\"'name_' + idx\">Name</label>\n            <Field :id=\"'name_' + idx\" :name=\"'users[' + idx + '].name'\" />\n            <ErrorMessage :name=\"'users[' + idx + '].name'\" />\n\n            <button class=\"remove\" type=\"button\" @click=\"remove(idx)\">X</button>\n          </fieldset>\n\n          <button class=\"prepend\" type=\"button\" @click=\"prepend({ name: 'new' })\">Add User +</button>\n        </FieldArray>\n\n        <button class=\"submit\" type=\"submit\">Submit</button>\n      </VForm>\n    `,\n  });\n\n  await flushPromises();\n  const submitBtn = document.querySelector('.submit') as HTMLButtonElement;\n  const inputAt = (idx: number) => (document.querySelectorAll('input') || [])[idx] as HTMLInputElement;\n\n  expect(getValue(inputAt(0))).toBe('111');\n  expect(getValue(inputAt(1))).toBe('222');\n  dispatchEvent('.prepend', 'click');\n  await flushPromises();\n  expect(getValue(inputAt(0))).toBe('new');\n  expect(getValue(inputAt(1))).toBe('111');\n  expect(getValue(inputAt(2))).toBe('222');\n  (submitBtn as HTMLButtonElement).click();\n  await flushPromises();\n  expect(onSubmit).toHaveBeenLastCalledWith(\n    expect.objectContaining({\n      users: [{ name: 'new' }, { name: '111' }, { name: '222' }],\n    }),\n    expect.anything()\n  );\n});","file":"FieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"clears old errors path when item is removed when no form schema is present","suites":[],"updatePoint":{"line":583,"column":80},"line":583,"code":"test('clears old errors path when item is removed when no form schema is present', async () => {\n  const onSubmit = vi.fn();\n  mountWithHoc({\n    setup() {\n      const initialValues = {\n        users: [{ name: '' }, { name: '' }, { name: '' }],\n      };\n\n      const schema = yup.string().required();\n\n      return {\n        onSubmit,\n        schema,\n        initialValues,\n      };\n    },\n    template: `\n      <VForm @submit=\"onSubmit\" :initial-values=\"initialValues\" v-slot=\"{ errors }\">\n        <FieldArray name=\"users\" v-slot=\"{ remove, push, fields }\">\n          <fieldset v-for=\"(field, idx) in fields\" :key=\"field.key\">\n            <legend>User #{{ idx }}</legend>\n            <label :for=\"'name_' + idx\">Name</label>\n            <Field :id=\"'name_' + idx\" :name=\"'users[' + idx + '].name'\" :rules=\"schema\" />\n            <ErrorMessage :name=\"'users[' + idx + '].name'\" />\n\n            <button class=\"remove\" type=\"button\" @click=\"remove(idx)\">X</button>\n          </fieldset>\n        </FieldArray>\n\n\n        <ul class=\"errors\">\n          <li v-for=\"error in errors\">{{ error }}</li>\n        </ul>\n\n        <button class=\"submit\" type=\"submit\">Submit</button>\n      </VForm>\n    `,\n  });\n\n  await flushPromises();\n  const submitBtn = document.querySelector('.submit') as HTMLButtonElement;\n  const errorList = document.querySelector('ul') as HTMLUListElement;\n  const removeBtnAt = (idx: number) => document.querySelectorAll('.remove')[idx] as HTMLButtonElement; // remove the second item\n\n  submitBtn.click();\n  await flushPromises();\n  expect(errorList.children).toHaveLength(3);\n  removeBtnAt(1).click();\n  await flushPromises();\n\n  expect(errorList.children).toHaveLength(2);\n});","file":"FieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"clears old errors path when last item is removed and value update validation is on","suites":[],"updatePoint":{"line":637,"column":88},"line":637,"code":"test('clears old errors path when last item is removed and value update validation is on', async () => {\n  const onSubmit = vi.fn();\n  defineRule('required', (v: any) => (v ? true : REQUIRED_MESSAGE));\n  const InputField = defineComponent({\n    props: {\n      rules: {\n        type: String,\n        required: true,\n      },\n      name: {\n        type: String,\n        required: true,\n      },\n      label: String,\n      type: { type: String, default: 'text' },\n    },\n    setup(props) {\n      const { value, handleChange, errors } = useField(toRef(props, 'name'), props.rules, {\n        label: props.label,\n        type: props.type,\n      });\n\n      return {\n        value,\n        errors,\n        handleChange,\n      };\n    },\n    template: `\n      <label :for=\"name\">{{ label }}</label>\n      <input :type=\"type\" :name=\"name\" :value=\"value\" @input=\"handleChange\" />\n      <span>{{ errors[0] }}</span>\n      `,\n  });\n\n  mountWithHoc({\n    components: {\n      InputField,\n    },\n    setup() {\n      const initialValues = {\n        users: ['first', 'second', 'third'],\n      };\n\n      const schema = yup.string().required();\n\n      return {\n        onSubmit,\n        schema,\n        initialValues,\n      };\n    },\n    template: `\n      <VForm @submit=\"onSubmit\" :initial-values=\"initialValues\" v-slot=\"{ errors }\">\n        <FieldArray name=\"users\" v-slot=\"{ remove, push, fields }\">\n          <fieldset v-for=\"(field, idx) in fields\" :key=\"field.key\">\n            <legend>User #{{ idx }}</legend>\n            <label :for=\"'name_' + idx\">Name</label>\n            <InputField :name=\"'users[' + idx + ']'\" rules=\"required\" />\n\n            <button class=\"remove\" type=\"button\" @click=\"remove(idx)\">X</button>\n          </fieldset>\n        </FieldArray>\n\n\n        <ul class=\"errors\">\n          <li v-for=\"error in errors\">{{ error }}</li>\n        </ul>\n\n        <button class=\"submit\" type=\"submit\">Submit</button>\n      </VForm>\n    `,\n  });\n\n  await flushPromises();\n  const submitBtn = document.querySelector('.submit') as HTMLButtonElement;\n  const errorList = document.querySelector('ul') as HTMLUListElement;\n  const removeBtnAt = (idx: number) => document.querySelectorAll('.remove')[idx] as HTMLButtonElement; // remove the second item\n\n  submitBtn.click();\n  await flushPromises();\n  expect(errorList.children).toHaveLength(0);\n  removeBtnAt(2).click();\n  await flushPromises();\n\n  expect(errorList.children).toHaveLength(0);\n});","file":"FieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"moves items around the array with move()","suites":[],"updatePoint":{"line":725,"column":46},"line":725,"code":"test('moves items around the array with move()', async () => {\n  const onSubmit = vi.fn();\n  mountWithHoc({\n    setup() {\n      const initialValues = {\n        users: [{ name: '1' }, { name: '2' }, { name: '3' }, { name: '4' }],\n      };\n\n      return {\n        onSubmit,\n        initialValues,\n      };\n    },\n    template: `\n      <VForm @submit=\"onSubmit\" :initial-values=\"initialValues\">\n        <FieldArray name=\"users\" v-slot=\"{ move, fields }\">\n          <fieldset v-for=\"(field, idx) in fields\" :key=\"field.key\">\n            <legend>User #{{ idx }}</legend>\n            <label :for=\"'name_' + idx\">Name</label>\n            <Field :id=\"'name_' + idx\" :name=\"'users[' + idx + '].name'\" />\n            <ErrorMessage :name=\"'users[' + idx + '].name'\" />\n\n            <button class=\"move\" type=\"button\" @click=\"move(idx, 0)\">Move</button>\n          </fieldset>\n        </FieldArray>\n\n        <button class=\"submit\" type=\"submit\">Submit</button>\n      </VForm>\n    `,\n  });\n\n  await flushPromises();\n  const submitBtn = document.querySelector('.submit') as HTMLButtonElement;\n  const inputAt = (idx: number) => (document.querySelectorAll('input') || [])[idx] as HTMLInputElement;\n  const moveElAt = (idx: number) => (document.querySelectorAll('.move') || [])[idx] as HTMLInputElement;\n\n  expect(getValue(inputAt(0))).toBe('1');\n  expect(getValue(inputAt(1))).toBe('2');\n  expect(getValue(inputAt(2))).toBe('3');\n  expect(getValue(inputAt(3))).toBe('4');\n  dispatchEvent(moveElAt(3), 'click');\n  await flushPromises();\n  expect(getValue(inputAt(0))).toBe('4');\n  expect(getValue(inputAt(1))).toBe('1');\n  expect(getValue(inputAt(2))).toBe('2');\n  expect(getValue(inputAt(3))).toBe('3');\n  (submitBtn as HTMLButtonElement).click();\n  await flushPromises();\n  expect(onSubmit).toHaveBeenLastCalledWith(\n    expect.objectContaining({\n      users: [{ name: '4' }, { name: '1' }, { name: '2' }, { name: '3' }],\n    }),\n    expect.anything()\n  );\n});","file":"FieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"removing an item marks the form as dirty","suites":[],"updatePoint":{"line":782,"column":46},"line":782,"code":"test('removing an item marks the form as dirty', async () => {\n  const onSubmit = vi.fn();\n  mountWithHoc({\n    setup() {\n      const initialValues = {\n        users: [{ name: '1' }, { name: '2' }, { name: '3' }],\n      };\n\n      return {\n        onSubmit,\n        initialValues,\n      };\n    },\n    template: `\n      <VForm @submit=\"onSubmit\" :initial-values=\"initialValues\" v-slot=\"{ meta }\">\n        <FieldArray name=\"users\" v-slot=\"{ remove, fields }\">\n          <fieldset v-for=\"(field, idx) in fields\" :key=\"field.key\">\n            <legend>User #{{ idx }}</legend>\n            <label :for=\"'name_' + idx\">Name</label>\n            <Field :id=\"'name_' + idx\" :name=\"'users[' + idx + '].name'\" />\n\n            <button class=\"remove\" type=\"button\" @click=\"remove(idx)\">X</button>\n          </fieldset>\n        </FieldArray>\n\n        <pre>{{ meta.dirty }}</pre>\n      </VForm>\n    `,\n  });\n\n  await flushPromises();\n  const getDirtyPre = () => document.querySelector('pre') as HTMLElement;\n  const removeBtnAt = (idx: number) => (document.querySelectorAll('.remove') || [])[idx] as HTMLInputElement;\n\n  await expect(getDirtyPre().textContent).toBe('false');\n  dispatchEvent(removeBtnAt(2), 'click');\n  await flushPromises();\n\n  await expect(getDirtyPre().textContent).toBe('true');\n});","file":"FieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"clean up form registration on unmount","suites":[],"updatePoint":{"line":823,"column":43},"line":823,"code":"test('clean up form registration on unmount', async () => {\n  const shown = ref(true);\n  mountWithHoc({\n    setup() {\n      const initialValues = {\n        users: [{ name: '1' }, { name: '2' }, { name: '3' }],\n      };\n\n      return {\n        initialValues,\n        shown,\n      };\n    },\n    template: `\n      <VForm :initial-values=\"initialValues\">\n        <FieldArray v-if=\"shown\" name=\"users\" v-slot=\"{ remove, fields }\">\n          <fieldset v-for=\"(field, idx) in fields\" :key=\"field.key\">\n            <legend>User #{{ idx }}</legend>\n            <label :for=\"'name_' + idx\">Name</label>\n            <Field :id=\"'name_' + idx\" :name=\"'users[' + idx + '].name'\" />\n\n          </fieldset>\n        </FieldArray>\n      </VForm>\n    `,\n  });\n\n  await flushPromises();\n  shown.value = false;\n  await flushPromises();\n  expect(1).toBe(1);\n});","file":"FieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"adding or removing fields should update form dirty correctly","suites":[],"updatePoint":{"line":857,"column":66},"line":857,"code":"test('adding or removing fields should update form dirty correctly', async () => {\n  mountWithHoc({\n    setup() {\n      const initialValues = {\n        users: [''],\n      };\n\n      return {\n        initialValues,\n      };\n    },\n    template: `\n      <VForm v-slot=\"{ meta }\" :initial-values=\"initialValues\">\n        <FieldArray name=\"users\" v-slot=\"{ remove, fields, push }\">\n          <fieldset v-for=\"(field, idx) in fields\" :key=\"field.key\">\n            <legend>User #{{ idx }}</legend>\n            <label :for=\"'name_' + idx\">Name</label>\n            <Field :id=\"'name_' + idx\" :name=\"'users[' + idx + ']'\" />\n\n            </fieldset>\n            <button id=\"push\" type=\"button\" @click=\"push('')\"></button>\n            <button id=\"remove\"  type=\"button\"  @click=\"remove(1)\"></button>\n        </FieldArray>\n\n        <pre id=\"dirty\">{{ meta.dirty }}</pre>\n      </VForm>\n    `,\n  });\n\n  await flushPromises();\n  const pushBtn = document.querySelector('#push') as HTMLElement;\n  const removeBtn = document.querySelector('#remove') as HTMLElement;\n  const dirty = document.querySelector('#dirty') as HTMLElement;\n\n  expect(dirty?.textContent).toBe('false');\n  pushBtn.click();\n  await flushPromises();\n  expect(dirty.textContent).toBe('true');\n  removeBtn.click();\n  await flushPromises();\n  expect(dirty.textContent).toBe('false');\n});","file":"FieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"renders the as prop","suites":["<Form />"],"updatePoint":{"line":25,"column":27},"line":25,"code":"  test('renders the as prop', () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <div>\n        <VForm />\n      </div>\n    `,\n    });\n\n    expect(wrapper.$el.innerHTML).toBe(`<form novalidate=\"\"></form>`);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"observes the current state of providers","suites":["<Form />"],"updatePoint":{"line":37,"column":47},"line":37,"code":"  test('observes the current state of providers', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm v-slot=\"{ meta }\">\n        <Field name=\"field\" rules=\"required\" type=\"text\" />\n\n        <span id=\"state\">{{ meta.valid }}</span>\n      </VForm>\n    `,\n    });\n\n    const stateSpan = wrapper.$el.querySelector('#state');\n    const input = wrapper.$el.querySelector('input');\n    setValue(input, '');\n\n    await flushPromises();\n    // initially the field valid flag is false.\n    expect(stateSpan.textContent).toBe('false');\n\n    setValue(input, 'value');\n    await flushPromises();\n\n    expect(stateSpan.textContent).toBe('true');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"submit handler only executes if observer is valid","suites":["<Form />"],"updatePoint":{"line":62,"column":57},"line":62,"code":"  test('submit handler only executes if observer is valid', async () => {\n    let calls = 0;\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          submit() {\n            calls++;\n          },\n        };\n      },\n      template: `\n      <VForm @submit=\"submit\" v-slot=\"{ errors }\">\n        <Field name=\"field\" rules=\"required\" />\n        <span id=\"error\">{{ errors.field }}</span>\n\n        <button>Validate</button>\n      </VForm>\n    `,\n    });\n\n    const error = wrapper.$el.querySelector('#error');\n    const input = wrapper.$el.querySelector('input');\n    await flushPromises();\n    expect(error.textContent).toBe('');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(calls).toBe(0);\n\n    expect(error.textContent).toBe(REQUIRED_MESSAGE);\n    setValue(input, '12');\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n\n    expect(error.textContent).toBe('');\n    expect(calls).toBe(1);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"handles reset event","suites":["<Form />"],"updatePoint":{"line":100,"column":27},"line":100,"code":"  test('handles reset event', async () => {\n    let isReset = false;\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          reset: () => {\n            isReset = true;\n          },\n        };\n      },\n      template: `\n      <VForm @reset=\"reset\" v-slot=\"{ errors }\">\n        <Field rules=\"required\" name=\"field\" />\n        <span id=\"error\">{{ errors.field }}</span>\n\n        <button id=\"submit\">Validate</button>\n        <button id=\"reset\" type=\"reset\">Reset</button>\n      </VForm>\n    `,\n    });\n\n    const error = wrapper.$el.querySelector('#error');\n    const input = wrapper.$el.querySelector('input');\n\n    expect(error.textContent).toBe('');\n\n    wrapper.$el.querySelector('#submit').click();\n    await flushPromises();\n\n    expect(error.textContent).toBe(REQUIRED_MESSAGE);\n\n    setValue(input, 'value');\n    await flushPromises();\n    wrapper.$el.querySelector('#reset').click();\n    await flushPromises();\n\n    // value was reset\n    expect(input.value).toBe('');\n    // errors were cleared\n    expect(error.textContent).toBe('');\n    expect(isReset).toBe(true);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"handles reset with resetForm slot prop","suites":["<Form />"],"updatePoint":{"line":143,"column":46},"line":143,"code":"  test('handles reset with resetForm slot prop', async () => {\n    const resetError = 'Field is wrong';\n    const resetValue = 'I was reset';\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm v-slot=\"{ errors, resetForm, meta, values }\">\n        <Field rules=\"required\" name=\"field\" />\n        <span id=\"error\">{{ errors.field }}</span>\n        <span id=\"dirty\">{{ meta.dirty.toString() }}</span>\n        <span id=\"touched\">{{ meta.touched.toString() }}</span>\n\n        <button id=\"submit\">Validate</button>\n        <button id=\"reset\" type=\"button\" @click=\"resetForm({ values: { field: '${resetValue}' }, errors: { field: '${resetError}' }, touched: { field: true } })\">Reset</button>\n      </VForm>\n    `,\n    });\n\n    const error = wrapper.$el.querySelector('#error');\n    const input = wrapper.$el.querySelector('input');\n\n    expect(error.textContent).toBe('');\n\n    wrapper.$el.querySelector('#submit').click();\n    await flushPromises();\n\n    expect(error.textContent).toBe(REQUIRED_MESSAGE);\n\n    setValue(input, 'value');\n    await flushPromises();\n    wrapper.$el.querySelector('#reset').click();\n    await flushPromises();\n\n    // value was reset\n    expect(input.value).toBe(resetValue);\n    // errors were cleared\n    expect(error.textContent).toBe(resetError);\n    expect(wrapper.$el.querySelector('#dirty').textContent).toBe('false');\n    expect(wrapper.$el.querySelector('#touched').textContent).toBe('true');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"initial values can be set with initialValues prop","suites":["<Form />"],"updatePoint":{"line":183,"column":57},"line":183,"code":"  test('initial values can be set with initialValues prop', async () => {\n    const initialValues = {\n      field: 'hello',\n    };\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          initialValues,\n        };\n      },\n      template: `\n      <VForm :initialValues=\"initialValues\">\n        <Field rules=\"required\" name=\"field\" />\n\n        <button id=\"submit\">Submit</button>\n      </VForm>\n    `,\n    });\n\n    const input = wrapper.$el.querySelector('input');\n\n    expect(input.value).toBe(initialValues.field);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"initial values can be reactive and will update non-touched fields","suites":["<Form />"],"updatePoint":{"line":207,"column":73},"line":207,"code":"  test('initial values can be reactive and will update non-touched fields', async () => {\n    let initialValues!: Record<string, any>;\n\n    const wrapper = mountWithHoc({\n      setup() {\n        initialValues = reactive({\n          field1: 'hello',\n          field2: 'hi',\n        });\n\n        return {\n          initialValues,\n        };\n      },\n      template: `\n      <VForm :initialValues=\"initialValues\">\n        <Field rules=\"required\" name=\"field1\" />\n        <Field rules=\"required\" name=\"field2\" />\n\n        <button id=\"submit\">Submit</button>\n      </VForm>\n    `,\n    });\n\n    const inputs = wrapper.$el.querySelectorAll('input');\n\n    await flushPromises();\n    setValue(inputs[0], '12');\n    dispatchEvent(inputs[0], 'blur');\n    await flushPromises();\n    initialValues.field1 = 'new';\n    initialValues.field2 = 'tada';\n    await flushPromises();\n\n    // this was not updated because it was changed by user\n    expect(inputs[0].value).not.toBe(initialValues.field1);\n\n    // this is updated because it wasn't changed by user\n    expect(inputs[1].value).toBe(initialValues.field2);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"initial values can be refs and will update non-touched fields","suites":["<Form />"],"updatePoint":{"line":248,"column":69},"line":248,"code":"  test('initial values can be refs and will update non-touched fields', async () => {\n    let initialValues!: Record<string, any>;\n\n    const wrapper = mountWithHoc({\n      setup() {\n        initialValues = ref({\n          field1: 'hello',\n          field2: 'hi',\n        });\n\n        return {\n          initialValues,\n        };\n      },\n      template: `\n      <VForm :initialValues=\"initialValues\">\n        <Field rules=\"required\" name=\"field1\" />\n        <Field rules=\"required\" name=\"field2\" />\n\n        <button id=\"submit\">Submit</button>\n      </VForm>\n    `,\n    });\n\n    const inputs = wrapper.$el.querySelectorAll('input');\n\n    await flushPromises();\n    setValue(inputs[0], '12');\n    dispatchEvent(inputs[0], 'blur');\n    await flushPromises();\n    initialValues.value = {\n      field1: 'new',\n      field2: 'tada',\n    };\n\n    await flushPromises();\n\n    // this was not updated because it was changed by user\n    expect(inputs[0].value).not.toBe(initialValues.value.field1);\n\n    // this is updated because it wasn't changed by user\n    expect(inputs[1].value).toBe(initialValues.value.field2);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"having no submit listener will submit the form natively","suites":["<Form />"],"updatePoint":{"line":292,"column":63},"line":292,"code":"  test('having no submit listener will submit the form natively', async () => {\n    const submitMock = vi.fn();\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm v-slot=\"{ errors }\">\n        <Field name=\"field\" rules=\"required\" />\n        <span id=\"error\">{{ errors.field }}</span>\n\n        <button>Validate</button>\n      </VForm>\n    `,\n    });\n\n    const form = wrapper.$el;\n    form.submit = submitMock;\n    const input = wrapper.$el.querySelector('input');\n    await flushPromises();\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(submitMock).toHaveBeenCalledTimes(0);\n\n    setValue(input, '12');\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n\n    expect(submitMock).toHaveBeenCalledTimes(1);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can be renderless","suites":["<Form />"],"updatePoint":{"line":321,"column":25},"line":321,"code":"  test('can be renderless', async () => {\n    const submitMock = vi.fn();\n    const wrapper = mountWithHoc({\n      template: `\n      <div>\n        <VForm as=\"\" v-slot=\"{ errors, submitForm }\">\n          <form @submit=\"submitForm\">\n            <Field name=\"field\" rules=\"required\" />\n            <span id=\"error\">{{ errors.field }}</span>\n\n            <button>Validate</button>\n          </form>\n        </VForm>\n      </div>\n    `,\n    });\n\n    const form = wrapper.$el.querySelector('form');\n    form.submit = submitMock;\n    const input = wrapper.$el.querySelector('input');\n    await flushPromises();\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(submitMock).toHaveBeenCalledTimes(0);\n\n    setValue(input, '12');\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n\n    expect(submitMock).toHaveBeenCalledTimes(1);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"validation schema with yup","suites":["<Form />"],"updatePoint":{"line":354,"column":34},"line":354,"code":"  test('validation schema with yup', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = yup.object({\n          email: yup.string().required().email(),\n          password: yup.string().required().min(8),\n        });\n\n        return {\n          schema,\n        };\n      },\n      template: `\n      <VForm :validationSchema=\"schema\" v-slot=\"{ errors }\">\n        <Field id=\"email\" name=\"email\" />\n        <span id=\"emailErr\">{{ errors.email }}</span>\n\n        <Field id=\"password\" name=\"password\" type=\"password\" />\n        <span id=\"passwordErr\">{{ errors.password }}</span>\n\n        <button>Validate</button>\n      </VForm>\n    `,\n    });\n\n    const email = wrapper.$el.querySelector('#email');\n    const password = wrapper.$el.querySelector('#password');\n    const emailError = wrapper.$el.querySelector('#emailErr');\n    const passwordError = wrapper.$el.querySelector('#passwordErr');\n\n    wrapper.$el.querySelector('button').click();\n\n    await flushPromises();\n\n    expect(emailError.textContent).toBe('email is a required field');\n    expect(passwordError.textContent).toBe('password is a required field');\n\n    setValue(email, 'hello@');\n    setValue(password, '1234');\n\n    await flushPromises();\n\n    expect(emailError.textContent).toBe('email must be a valid email');\n    expect(passwordError.textContent).toBe('password must be at least 8 characters');\n\n    setValue(email, 'hello@email.com');\n    setValue(password, '12346789');\n\n    await flushPromises();\n\n    expect(emailError.textContent).toBe('');\n    expect(passwordError.textContent).toBe('');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"validation schema to validate form","suites":["<Form />"],"updatePoint":{"line":408,"column":42},"line":408,"code":"  test('validation schema to validate form', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = {\n          field: 'required',\n          other: 'required',\n        };\n\n        return {\n          schema,\n        };\n      },\n      template: `\n      <VForm :validationSchema=\"schema\" v-slot=\"{ errors }\">\n        <Field name=\"field\" />\n        <span id=\"field\">{{ errors.field }}</span>\n\n        <Field name=\"other\" />\n        <span id=\"other\">{{ errors.other }}</span>\n\n        <button>Validate</button>\n      </VForm>\n    `,\n    });\n\n    const first = wrapper.$el.querySelector('#field');\n    const second = wrapper.$el.querySelector('#other');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n\n    expect(first.textContent).toBe(REQUIRED_MESSAGE);\n    expect(second.textContent).toBe(REQUIRED_MESSAGE);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"cross field validation with yup schema","suites":["<Form />"],"updatePoint":{"line":443,"column":46},"line":443,"code":"  test('cross field validation with yup schema', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = yup.object({\n          password: yup.string().required(),\n          confirmation: yup.string().oneOf([yup.ref('password')], 'passwords must match'),\n        });\n\n        return {\n          schema,\n        };\n      },\n      template: `\n      <VForm :validationSchema=\"schema\" v-slot=\"{ errors }\">\n        <Field id=\"password\" name=\"password\" />\n        <span id=\"field\">{{ errors.password }}</span>\n\n        <Field id=\"confirmation\" name=\"confirmation\" />\n        <span id=\"confirmationError\">{{ errors.confirmation }}</span>\n\n        <button>Validate</button>\n      </VForm>\n    `,\n    });\n\n    const password = wrapper.$el.querySelector('#password');\n    const confirmation = wrapper.$el.querySelector('#confirmation');\n    const confirmationError = wrapper.$el.querySelector('#confirmationError');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n\n    setValue(password, 'hello@');\n    setValue(confirmation, '1234');\n    await flushPromises();\n    expect(confirmationError.textContent).toBe('passwords must match');\n\n    setValue(password, '1234');\n    setValue(confirmation, '1234');\n    await flushPromises();\n    expect(confirmationError.textContent).toBe('');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"supports radio inputs","suites":["<Form />"],"updatePoint":{"line":486,"column":29},"line":486,"code":"  test('supports radio inputs', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = {\n          drink: 'required',\n        };\n\n        return {\n          schema,\n        };\n      },\n      template: `\n      <VForm :validation-schema=\"schema\" v-slot=\"{ errors }\">\n        <Field name=\"drink\" type=\"radio\" value=\"\" /> Coffee\n        <Field name=\"drink\" type=\"radio\" value=\"Tea\" /> Tea\n        <Field name=\"drink\" type=\"radio\" value=\"Coke\" /> Coke\n\n        <span id=\"err\">{{ errors.drink }}</span>\n\n        <button>Submit</button>\n      </VForm>\n    `,\n    });\n\n    const err = wrapper.$el.querySelector('#err');\n    const inputs = wrapper.$el.querySelectorAll('input');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(err.textContent).toBe(REQUIRED_MESSAGE);\n    setChecked(inputs[2]);\n    await flushPromises();\n    expect(err.textContent).toBe('');\n\n    setChecked(inputs[0]);\n    await flushPromises();\n    expect(err.textContent).toBe(REQUIRED_MESSAGE);\n\n    setChecked(inputs[1]);\n    await flushPromises();\n    expect(err.textContent).toBe('');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"supports radio inputs with check after submit","suites":["<Form />"],"updatePoint":{"line":529,"column":53},"line":529,"code":"  test('supports radio inputs with check after submit', async () => {\n    const initialValues = { test: 'one' };\n\n    const showFields = ref(true);\n    const result = ref();\n\n    const wrapper = mountWithHoc({\n      setup() {\n        const values = ['one', 'two', 'three'];\n        const onSubmit = (formData: Record<string, any>) => {\n          result.value = formData.test;\n        };\n\n        return {\n          values,\n          onSubmit,\n          initialValues,\n          showFields,\n          result,\n        };\n      },\n      template: `\n      <VForm  @submit=\"onSubmit\"  >\n\n        <label v-for=\"(value, index) in values\" v-bind:key=\"index\">\n          <div v-if=\"showFields\">\n            <Field name=\"test\" type=\"radio\" :value=\"value\" /> {{value}}\n          </div>\n        </label>\n        <button>Submit</button>\n      </VForm>\n    `,\n    });\n\n    // const err = wrapper.$el.querySelector('#err');\n    const inputs = wrapper.$el.querySelectorAll('input');\n\n    setChecked(inputs[1]);\n    await flushPromises();\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    showFields.value = false;\n    await flushPromises();\n    expect(result.value).toBe('two');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"supports radio inputs with check after submit (nested)","suites":["<Form />"],"updatePoint":{"line":575,"column":62},"line":575,"code":"  test('supports radio inputs with check after submit (nested)', async () => {\n    const initialValues = { test: { fieldOne: { option: 'one' } } };\n\n    const showFields = ref(true);\n    const result = ref();\n\n    const wrapper = mountWithHoc({\n      setup() {\n        const values = ['one', 'two', 'three'];\n        const onSubmit = (formData: Record<string, any>) => {\n          result.value = formData.test;\n        };\n\n        return {\n          values,\n          onSubmit,\n          initialValues,\n          showFields,\n          result,\n        };\n      },\n      template: `\n      <VForm  @submit=\"onSubmit\" :initialValues=\"initialValues\" >\n        <label v-for=\"(value, index) in values\" v-bind:key=\"index\">\n          <div v-if=\"showFields\">\n            <Field name=\"test.fieldOne.option\" type=\"radio\" :value=\"value\" /> {{value}}\n          </div>\n        </label>\n\n        <button>Submit</button>\n      </VForm>\n    `,\n    });\n\n    // const err = wrapper.$el.querySelector('#err');\n    const inputs = wrapper.$el.querySelectorAll('input');\n    await flushPromises();\n    expect(inputs[0].checked).toBe(true);\n\n    setChecked(inputs[1]);\n    await flushPromises();\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    showFields.value = false;\n    await flushPromises();\n    expect(result.value.fieldOne.option).toBe('two');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"supports checkboxes inputs","suites":["<Form />"],"updatePoint":{"line":623,"column":34},"line":623,"code":"  test('supports checkboxes inputs', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = {\n          drink: 'required',\n        };\n\n        return {\n          schema,\n        };\n      },\n      template: `\n      <VForm :validation-schema=\"schema\" v-slot=\"{ errors, values }\">\n        <Field name=\"drink\" type=\"checkbox\" value=\"\" /> Coffee\n        <Field name=\"drink\" type=\"checkbox\" value=\"Tea\" /> Tea\n        <Field name=\"drink\" type=\"checkbox\" value=\"Coke\" /> Coke\n\n        <span id=\"err\">{{ errors.drink }}</span>\n        <span id=\"values\">{{ values.drink && values.drink.toString() }}</span>\n\n        <button>Submit</button>\n      </VForm>\n    `,\n    });\n\n    const err = wrapper.$el.querySelector('#err');\n    const values = wrapper.$el.querySelector('#values');\n    const inputs = wrapper.$el.querySelectorAll('input');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(err.textContent).toBe(REQUIRED_MESSAGE);\n    setChecked(inputs[2]);\n    await flushPromises();\n    expect(err.textContent).toBe('');\n\n    setChecked(inputs[0]);\n    await flushPromises();\n    expect(err.textContent).toBe('');\n\n    setChecked(inputs[1]);\n    await flushPromises();\n    expect(err.textContent).toBe('');\n\n    expect(values.textContent).toBe(['Coke', '', 'Tea'].toString());\n\n    setChecked(inputs[1], false);\n    await flushPromises();\n    expect(values.textContent).toBe(['Coke', ''].toString());\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"supports a single checkbox","suites":["<Form />"],"updatePoint":{"line":674,"column":34},"line":674,"code":"  test('supports a single checkbox', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = {\n          drink: 'required',\n        };\n\n        return {\n          schema,\n        };\n      },\n      template: `\n      <VForm :validation-schema=\"schema\" v-slot=\"{ errors, values }\">\n        <Field name=\"drink\" type=\"checkbox\" :value=\"true\" /> Coffee\n\n        <span id=\"err\">{{ errors.drink }}</span>\n        <span id=\"value\">{{ typeof values.drink }}</span>\n\n        <button>Submit</button>\n      </VForm>\n    `,\n    });\n\n    const err = wrapper.$el.querySelector('#err');\n    const value = wrapper.$el.querySelector('#value');\n    const input = wrapper.$el.querySelector('input');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(err.textContent).toBe(REQUIRED_MESSAGE);\n    setChecked(input, true);\n    await flushPromises();\n    expect(err.textContent).toBe('');\n    expect(value.textContent).toBe('boolean');\n    setChecked(input, false);\n    await flushPromises();\n    expect(err.textContent).toBe(REQUIRED_MESSAGE);\n    expect(value.textContent).toBe('undefined');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"unmounted fields gets unregistered and their values cleaned up","suites":["<Form />"],"updatePoint":{"line":714,"column":70},"line":714,"code":"  test('unmounted fields gets unregistered and their values cleaned up', async () => {\n    const showFields = ref(true);\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = computed(() => ({\n          field: showFields.value ? 'required' : '',\n          drink: 'required',\n        }));\n\n        return {\n          schema,\n          showFields,\n        };\n      },\n      template: `\n      <VForm :validationSchema=\"schema\" v-slot=\"{ errors, values }\">\n        <template v-if=\"showFields\">\n          <Field name=\"field\" />\n          <Field name=\"nested.field\" />\n          <Field name=\"[non-nested.field]\" />\n          <Field name=\"drink\" type=\"checkbox\" value=\"\" /> Coffee\n          <Field name=\"drink\" type=\"checkbox\" value=\"Tea\" /> Tea\n        </template>\n        <Field name=\"drink\" type=\"checkbox\" value=\"Coke\" /> Coke\n\n        <span id=\"errors\">{{ errors }}</span>\n        <span id=\"values\">{{ values }}</span>\n\n        <button>Validate</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const errors = wrapper.$el.querySelector('#errors');\n    const values = wrapper.$el.querySelector('#values');\n    const inputs = wrapper.$el.querySelectorAll('input');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(errors.textContent).toBeTruthy();\n    setChecked(inputs[4]);\n    setChecked(inputs[5]);\n    setValue(inputs[0], 'test');\n    setValue(inputs[1], '12');\n    setValue(inputs[2], '12');\n    await flushPromises();\n    expect(JSON.parse(values.textContent)).toEqual({\n      drink: ['Tea', 'Coke'],\n      field: 'test',\n      'non-nested.field': '12',\n      nested: { field: '12' },\n    });\n\n    showFields.value = false;\n    await flushPromises();\n    expect(errors.textContent).toBe('{}');\n    expect(JSON.parse(values.textContent)).toEqual({ drink: ['Coke'] });\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"unmounted fields gets unregistered and submitted values do not include them","suites":["<Form />"],"updatePoint":{"line":774,"column":83},"line":774,"code":"  test('unmounted fields gets unregistered and submitted values do not include them', async () => {\n    let showFields!: Ref<boolean>;\n    const spy = vi.fn();\n    const wrapper = mountWithHoc({\n      setup() {\n        showFields = ref(true);\n\n        return {\n          showFields,\n          onSubmit(values: any) {\n            spy(values);\n          },\n        };\n      },\n      template: `\n      <VForm @submit=\"onSubmit\" v-slot=\"{ errors }\">\n        <template v-if=\"showFields\">\n          <Field name=\"field\" rules=\"required\" />\n          <Field name=\"nested.field\" rules=\"required\" />\n          <Field name=\"[non-nested.field]\" rules=\"required\" />\n          <Field name=\"drink\" type=\"checkbox\" value=\"\" rules=\"required\" /> Coffee\n          <Field name=\"drink\" type=\"checkbox\" value=\"Tea\" rules=\"required\" /> Tea\n        </template>\n        <Field name=\"drink\" type=\"checkbox\" value=\"Coke\" rules=\"required\" /> Coke\n\n        <span id=\"errors\">{{ errors }}</span>\n\n        <button>Submit</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const errors = wrapper.$el.querySelector('#errors');\n    const button = wrapper.$el.querySelector('button');\n    const inputs = wrapper.$el.querySelectorAll('input');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(errors.textContent).toBeTruthy();\n    setChecked(inputs[4]);\n    setChecked(inputs[5]);\n    setValue(inputs[0], 'test');\n    setValue(inputs[1], '12');\n    setValue(inputs[2], '12');\n    await flushPromises();\n    button.click();\n    await flushPromises();\n    expect(spy).toHaveBeenLastCalledWith({\n      drink: ['Tea', 'Coke'],\n      field: 'test',\n      'non-nested.field': '12',\n      nested: { field: '12' },\n    });\n\n    showFields.value = false;\n    await flushPromises();\n    expect(errors.textContent).toBe('{}');\n    button.click();\n    await flushPromises();\n    expect(spy).toHaveBeenLastCalledWith({ drink: ['Coke'] });\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"unmounted fields gets unregistered and their values are kept if configured on the form level","suites":["<Form />"],"updatePoint":{"line":837,"column":100},"line":837,"code":"  test('unmounted fields gets unregistered and their values are kept if configured on the form level', async () => {\n    const showFields = ref(true);\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = computed(() => ({\n          field: showFields.value ? 'required' : '',\n          drink: 'required',\n        }));\n\n        return {\n          schema,\n          showFields,\n        };\n      },\n      template: `\n      <VForm :validationSchema=\"schema\" v-slot=\"{ errors, values }\" keep-values>\n        <template v-if=\"showFields\">\n          <Field name=\"field\" />\n          <Field name=\"nested.field\" />\n          <Field name=\"[non-nested.field]\" />\n          <Field name=\"drink\" type=\"checkbox\" value=\"\" /> Coffee\n          <Field name=\"drink\" type=\"checkbox\" value=\"Tea\" /> Tea\n        </template>\n        <Field name=\"drink\" type=\"checkbox\" value=\"Coke\" /> Coke\n\n        <span id=\"errors\">{{ errors }}</span>\n        <span id=\"values\">{{ values }}</span>\n\n        <button>Validate</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const errors = wrapper.$el.querySelector('#errors');\n    const values = wrapper.$el.querySelector('#values');\n    const inputs = wrapper.$el.querySelectorAll('input');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(errors.textContent).toBeTruthy();\n    setChecked(inputs[4]);\n    setChecked(inputs[5]);\n    setValue(inputs[0], 'test');\n    setValue(inputs[1], '12');\n    setValue(inputs[2], '12');\n    await flushPromises();\n    const expected = {\n      drink: ['Tea', 'Coke'],\n      field: 'test',\n      'non-nested.field': '12',\n      nested: { field: '12' },\n    };\n    expect(JSON.parse(values.textContent)).toEqual(expected);\n\n    showFields.value = false;\n    await flushPromises();\n    // errors were cleared\n    expect(errors.textContent).toBe('{}');\n    expect(JSON.parse(values.textContent)).toEqual(expected);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"unmounted fields gets unregistered and their submitted values are kept if configured on the form level","suites":["<Form />"],"updatePoint":{"line":899,"column":110},"line":899,"code":"  test('unmounted fields gets unregistered and their submitted values are kept if configured on the form level', async () => {\n    let showFields!: Ref<boolean>;\n    const spy = vi.fn();\n    const wrapper = mountWithHoc({\n      setup() {\n        showFields = ref(true);\n\n        return {\n          showFields,\n          onSubmit(values: any) {\n            spy(values);\n          },\n        };\n      },\n      template: `\n      <VForm @submit=\"onSubmit\" v-slot=\"{ errors }\" keep-values>\n        <template v-if=\"showFields\">\n          <Field name=\"field\" rules=\"required\" />\n          <Field name=\"nested.field\" rules=\"required\" />\n          <Field name=\"[non-nested.field]\" rules=\"required\" />\n          <Field name=\"drink\" type=\"checkbox\" value=\"\" rules=\"required\" /> Coffee\n          <Field name=\"drink\" type=\"checkbox\" value=\"Tea\" rules=\"required\" /> Tea\n        </template>\n\n        <Field name=\"drink\" type=\"checkbox\" value=\"Coke\" rules=\"required\" /> Coke\n\n        <span id=\"errors\">{{ errors }}</span>\n\n        <button>Submit</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const errors = wrapper.$el.querySelector('#errors');\n    const button = wrapper.$el.querySelector('button');\n    const inputs = wrapper.$el.querySelectorAll('input');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(errors.textContent).toBeTruthy();\n    setChecked(inputs[4]);\n    setChecked(inputs[5]);\n    setValue(inputs[0], 'test');\n    setValue(inputs[1], '12');\n    setValue(inputs[2], '12');\n    await flushPromises();\n    button.click();\n    await flushPromises();\n    const expected = {\n      drink: ['Tea', 'Coke'],\n      field: 'test',\n      'non-nested.field': '12',\n      nested: { field: '12' },\n    };\n    expect(spy).toHaveBeenLastCalledWith(expected);\n\n    showFields.value = false;\n    await flushPromises();\n    expect(errors.textContent).toBe('{}');\n    button.click();\n    await flushPromises();\n    expect(spy).toHaveBeenLastCalledWith(expected);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"unmounted fields gets unregistered and their values are kept if configured on the field level","suites":["<Form />"],"updatePoint":{"line":964,"column":101},"line":964,"code":"  test('unmounted fields gets unregistered and their values are kept if configured on the field level', async () => {\n    const showFields = ref(true);\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = computed(() => ({\n          field: showFields.value ? 'required' : '',\n          drink: 'required',\n        }));\n\n        return {\n          schema,\n          showFields,\n        };\n      },\n      template: `\n      <VForm :validationSchema=\"schema\" v-slot=\"{ errors, values }\">\n        <template v-if=\"showFields\">\n          <Field name=\"field\" />\n          <Field name=\"nested.field\" keep-value />\n          <Field name=\"[non-nested.field]\" keep-value />\n          <Field name=\"drink\" type=\"checkbox\" value=\"\" /> Coffee\n          <Field name=\"drink\" type=\"checkbox\" value=\"Tea\" keep-value /> Tea\n        </template>\n        <Field name=\"drink\" type=\"checkbox\" value=\"Coke\" /> Coke\n\n        <span id=\"errors\">{{ errors }}</span>\n        <span id=\"values\">{{ values }}</span>\n\n        <button>Validate</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const errors = wrapper.$el.querySelector('#errors');\n    const values = wrapper.$el.querySelector('#values');\n    const inputs = wrapper.$el.querySelectorAll('input');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(errors.textContent).toBeTruthy();\n    setChecked(inputs[4]);\n    setChecked(inputs[5]);\n    setValue(inputs[0], 'test');\n    setValue(inputs[1], '12');\n    setValue(inputs[2], '12');\n    await flushPromises();\n    expect(JSON.parse(values.textContent)).toEqual({\n      drink: ['Tea', 'Coke'],\n      field: 'test',\n      'non-nested.field': '12',\n      nested: { field: '12' },\n    });\n\n    showFields.value = false;\n    await flushPromises();\n    // errors were cleared\n    expect(errors.textContent).toBe('{}');\n    expect(JSON.parse(values.textContent)).toEqual({\n      drink: ['Tea', 'Coke'],\n      'non-nested.field': '12',\n      nested: { field: '12' },\n    });\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"unmounted fields gets unregistered and their submitted values are kept if configured on the field level","suites":["<Form />"],"updatePoint":{"line":1029,"column":111},"line":1029,"code":"  test('unmounted fields gets unregistered and their submitted values are kept if configured on the field level', async () => {\n    let showFields!: Ref<boolean>;\n    const spy = vi.fn();\n    const wrapper = mountWithHoc({\n      setup() {\n        showFields = ref(true);\n\n        return {\n          showFields,\n          onSubmit(values: any) {\n            spy(values);\n          },\n        };\n      },\n      template: `\n      <VForm @submit=\"onSubmit\" v-slot=\"{ errors }\">\n        <template v-if=\"showFields\">\n          <Field name=\"field\" rules=\"required\" />\n          <Field name=\"nested.field\" rules=\"required\" keep-value />\n          <Field name=\"[non-nested.field]\" rules=\"required\" keep-value />\n          <Field name=\"drink\" type=\"checkbox\" value=\"\" rules=\"required\" /> Coffee\n          <Field name=\"drink\" type=\"checkbox\" value=\"Tea\" rules=\"required\" keep-value /> Tea\n        </template>\n        <Field name=\"drink\" type=\"checkbox\" value=\"Coke\" rules=\"required\" /> Coke\n\n        <span id=\"errors\">{{ errors }}</span>\n\n        <button>Submit</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const errors = wrapper.$el.querySelector('#errors');\n    const button = wrapper.$el.querySelector('button');\n    const inputs = wrapper.$el.querySelectorAll('input');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(errors.textContent).toBeTruthy();\n    setChecked(inputs[4]);\n    setChecked(inputs[5]);\n    setValue(inputs[0], 'test');\n    setValue(inputs[1], '12');\n    setValue(inputs[2], '12');\n    await flushPromises();\n    button.click();\n    await flushPromises();\n    expect(spy).toHaveBeenLastCalledWith({\n      drink: ['Tea', 'Coke'],\n      field: 'test',\n      'non-nested.field': '12',\n      nested: { field: '12' },\n    });\n\n    showFields.value = false;\n    await flushPromises();\n    expect(errors.textContent).toBe('{}');\n    button.click();\n    await flushPromises();\n    expect(spy).toHaveBeenLastCalledWith({\n      drink: ['Tea', 'Coke'],\n      'non-nested.field': '12',\n      nested: { field: '12' },\n    });\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can specify which fields get their value kept with field setting priority","suites":["<Form />"],"updatePoint":{"line":1096,"column":81},"line":1096,"code":"  test('can specify which fields get their value kept with field setting priority', async () => {\n    const showFields = ref(true);\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = computed(() => ({\n          field: showFields.value ? 'required' : '',\n          drink: 'required',\n        }));\n\n        return {\n          schema,\n          showFields,\n        };\n      },\n      template: `\n      <VForm :validationSchema=\"schema\" v-slot=\"{ errors, values }\" keep-values>\n        <template v-if=\"showFields\">\n          <Field name=\"field\" />\n          <Field name=\"nested.field\" :keep-value=\"false\" />\n          <Field name=\"[non-nested.field]\" :keep-value=\"false\" />\n          <Field name=\"drink\" type=\"checkbox\" value=\"\" /> Coffee\n          <Field name=\"drink\" type=\"checkbox\" value=\"Tea\" :keep-value=\"false\" /> Tea\n          <Field name=\"drink\" type=\"checkbox\" value=\"Coke\" /> Coke\n        </template>\n\n        <span id=\"errors\">{{ errors }}</span>\n        <span id=\"values\">{{ values }}</span>\n\n        <button>Validate</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const errors = wrapper.$el.querySelector('#errors');\n    const values = wrapper.$el.querySelector('#values');\n    const inputs = wrapper.$el.querySelectorAll('input');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(errors.textContent).toBeTruthy();\n    setChecked(inputs[4]);\n    setChecked(inputs[5]);\n    setValue(inputs[0], 'test');\n    setValue(inputs[1], '12');\n    setValue(inputs[2], '12');\n    await flushPromises();\n    expect(JSON.parse(values.textContent)).toEqual({\n      drink: ['Tea', 'Coke'],\n      field: 'test',\n      'non-nested.field': '12',\n      nested: { field: '12' },\n    });\n\n    showFields.value = false;\n    await flushPromises();\n    // errors were cleared\n    expect(errors.textContent).toBe('{}');\n    expect(JSON.parse(values.textContent)).toEqual({\n      drink: ['Coke'],\n      field: 'test',\n    });\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"checkboxes with yup schema","suites":["<Form />"],"updatePoint":{"line":1160,"column":34},"line":1160,"code":"  test('checkboxes with yup schema', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = yup.object({\n          drink: yup.array().required().min(1),\n        });\n\n        return {\n          schema,\n        };\n      },\n      template: `\n      <VForm :validation-schema=\"schema\" v-slot=\"{ errors, values }\">\n        <Field name=\"drink\" type=\"checkbox\" value=\"\" /> Coffee\n        <Field name=\"drink\" type=\"checkbox\" value=\"Tea\" /> Tea\n        <Field name=\"drink\" type=\"checkbox\" value=\"Coke\" /> Coke\n\n        <span id=\"err\">{{ errors.drink }}</span>\n        <span id=\"values\">{{ values.drink && values.drink.toString() }}</span>\n\n        <button>Submit</button>\n      </VForm>\n    `,\n    });\n\n    const err = wrapper.$el.querySelector('#err');\n    const values = wrapper.$el.querySelector('#values');\n    const inputs = wrapper.$el.querySelectorAll('input');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(err.textContent).toBe('drink is a required field');\n    setChecked(inputs[2]);\n    await flushPromises();\n    expect(err.textContent).toBe('');\n\n    setChecked(inputs[0]);\n    await flushPromises();\n    expect(err.textContent).toBe('');\n\n    setChecked(inputs[1]);\n    await flushPromises();\n    expect(err.textContent).toBe('');\n\n    expect(values.textContent).toBe(['Coke', '', 'Tea'].toString());\n\n    setChecked(inputs[1], false);\n    await flushPromises();\n    expect(values.textContent).toBe(['Coke', ''].toString());\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"checkboxes with object values","suites":["<Form />"],"updatePoint":{"line":1211,"column":37},"line":1211,"code":"  test('checkboxes with object values', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = yup.object({\n          drink: yup.array().required().min(1),\n        });\n\n        return {\n          schema,\n        };\n      },\n      template: `\n      <VForm :validation-schema=\"schema\" v-slot=\"{ errors, values }\">\n        <Field name=\"drink\" type=\"checkbox\" :value=\"{ id: '' }\" /> Coffee\n        <Field name=\"drink\" type=\"checkbox\" :value=\"{ id: 'tea' }\" /> Tea\n        <Field name=\"drink\" type=\"checkbox\" :value=\"{ id: 'coke' }\" /> Coke\n\n        <span id=\"err\">{{ errors.drink }}</span>\n        <span id=\"values\">{{ JSON.stringify(values.drink) }}</span>\n\n        <button>Submit</button>\n      </VForm>\n    `,\n    });\n\n    const err = wrapper.$el.querySelector('#err');\n    const values = wrapper.$el.querySelector('#values');\n    const inputs = wrapper.$el.querySelectorAll('input');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(err.textContent).toBe('drink is a required field');\n    setChecked(inputs[2]);\n    await flushPromises();\n    expect(err.textContent).toBe('');\n\n    setChecked(inputs[0]);\n    await flushPromises();\n    expect(err.textContent).toBe('');\n\n    setChecked(inputs[1]);\n    await flushPromises();\n    expect(err.textContent).toBe('');\n\n    expect(values.textContent).toBe(JSON.stringify([{ id: 'coke' }, { id: '' }, { id: 'tea' }]));\n\n    setChecked(inputs[1], false);\n    await flushPromises();\n    expect(values.textContent).toBe(JSON.stringify([{ id: 'coke' }, { id: '' }]));\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"checkboxes v-model value syncing","suites":["<Form />"],"updatePoint":{"line":1262,"column":40},"line":1262,"code":"  test('checkboxes v-model value syncing', async () => {\n    const drinks = ref<string[]>([]);\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = yup.object({\n          drink: yup.array().required().min(1),\n        });\n\n        return {\n          schema,\n          drinks,\n        };\n      },\n      template: `\n      <VForm :validation-schema=\"schema\" v-slot=\"{ errors, values }\">\n        <Field v-model=\"drinks\" name=\"drink\" type=\"checkbox\" value=\"\" /> Coffee\n        <Field v-model=\"drinks\" name=\"drink\" type=\"checkbox\" value=\"Tea\" /> Tea\n        <Field v-model=\"drinks\" name=\"drink\" type=\"checkbox\" value=\"Coke\" /> Coke\n\n        <span id=\"err\">{{ errors.drink }}</span>\n        <span id=\"values\">{{ values.drink && values.drink.toString() }}</span>\n\n        <button>Submit</button>\n      </VForm>\n    `,\n    });\n\n    const err = wrapper.$el.querySelector('#err');\n    const values = wrapper.$el.querySelector('#values');\n    const inputs = wrapper.$el.querySelectorAll('input');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(err.textContent).toBe('drink field must have at least 1 items');\n    setChecked(inputs[1]);\n    await flushPromises();\n    expect(err.textContent).toBe('');\n    expect(drinks.value).toEqual(['Tea']);\n\n    drinks.value = [];\n    await flushPromises();\n    expect(err.textContent).toBe('drink field must have at least 1 items');\n    expect(values.textContent).toBe('');\n\n    drinks.value = ['Coke'];\n    await flushPromises();\n    expect(err.textContent).toBe('');\n    expect(values.textContent).toBe(['Coke'].toString());\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"isSubmitting state","suites":["<Form />"],"updatePoint":{"line":1312,"column":26},"line":1312,"code":"  test('isSubmitting state', async () => {\n    let throws = false;\n    const wrapper = mountWithHoc({\n      setup() {\n        onErrorCaptured(() => false);\n        return {\n          onSubmit() {\n            return new Promise((resolve, reject) => {\n              if (throws) {\n                setTimeout(() => {\n                  reject(new Error('Sorry'));\n                }, 500);\n                return;\n              }\n\n              setTimeout(resolve, 1000);\n            });\n          },\n        };\n      },\n      template: `\n      <VForm @submit=\"onSubmit\" v-slot=\"{ isSubmitting }\">\n\n        <button id=\"submit\">Submit</button>\n        <span id=\"submitting\">{{ isSubmitting }}</span>\n      </VForm>\n    `,\n    });\n\n    const submit = wrapper.$el.querySelector('#submit');\n    const submitting = wrapper.$el.querySelector('#submitting');\n    submit.click();\n    await flushPromises();\n    expect(submitting.textContent).toBe('true');\n    vi.advanceTimersByTime(1001);\n    await flushPromises();\n    expect(submitting.textContent).toBe('false');\n\n    throws = true;\n    submit.click();\n    await flushPromises();\n    expect(submitting.textContent).toBe('true');\n    vi.advanceTimersByTime(501);\n    await flushPromises();\n    expect(submitting.textContent).toBe('false');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"aggregated meta reactivity","suites":["<Form />"],"updatePoint":{"line":1359,"column":34},"line":1359,"code":"  test('aggregated meta reactivity', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm v-slot=\"{ meta }\">\n        <Field name=\"field\" rules=\"required\"  />\n\n        <button :disabled=\"!meta.valid\" id=\"submit\">Submit</button>\n      </VForm>\n    `,\n    });\n\n    const submitBtn = wrapper.$el.querySelector('#submit');\n    const input = wrapper.$el.querySelector('input');\n    await flushPromises();\n    expect(submitBtn.disabled).toBe(true);\n    setValue(input, '12');\n    await flushPromises();\n    expect(submitBtn.disabled).toBe(false);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"nested object fields","suites":["<Form />"],"updatePoint":{"line":1379,"column":28},"line":1379,"code":"  test('nested object fields', async () => {\n    const fn = vi.fn();\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          onSubmit(values: any) {\n            fn(values);\n          },\n        };\n      },\n      template: `\n      <VForm @submit=\"onSubmit\" v-slot=\"{ values }\">\n        <Field name=\"user.name\" rules=\"required\"  />\n        <Field name=\"user.addresses.0\" id=\"address\" rules=\"required\"  />\n        <pre>{{ values }}</pre>\n\n        <button id=\"submit\">Submit</button>\n      </VForm>\n    `,\n    });\n\n    const submitBtn = wrapper.$el.querySelector('#submit');\n    const name = wrapper.$el.querySelector('input');\n    const address = wrapper.$el.querySelector('#address');\n    const pre = wrapper.$el.querySelector('pre');\n    setValue(name, '12');\n    setValue(address, 'abc');\n    await flushPromises();\n    expect(pre.textContent).toBe(JSON.stringify({ user: { name: '12', addresses: ['abc'] } }, null, 2));\n    submitBtn.click();\n    await flushPromises();\n    expect(fn).toHaveBeenCalledWith({ user: { name: '12', addresses: ['abc'] } });\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"nested object fields validation with yup nested objects","suites":["<Form />"],"updatePoint":{"line":1413,"column":63},"line":1413,"code":"  test('nested object fields validation with yup nested objects', async () => {\n    const fn = vi.fn();\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          schema: yup.object({\n            user: yup.object({\n              name: yup.string().required(),\n              addresses: yup.array().of(yup.string().required().min(3)).required(),\n            }),\n          }),\n          onSubmit(values: any) {\n            fn(values);\n          },\n        };\n      },\n      template: `\n      <VForm @submit=\"onSubmit\" v-slot=\"{ errors }\" :validation-schema=\"schema\">\n        <Field name=\"user.name\" />\n        <span id=\"nameErr\">{{ errors['user.name'] }}</span>\n        <Field name=\"user.addresses[0]\" id=\"address\" />\n        <span id=\"addrErr\">{{ errors['user.addresses[0]'] }}</span>\n\n        <button id=\"submit\">Submit</button>\n      </VForm>\n    `,\n    });\n\n    const submitBtn = wrapper.$el.querySelector('#submit');\n    const name = wrapper.$el.querySelector('input');\n    const nameErr = wrapper.$el.querySelector('#nameErr');\n    const address = wrapper.$el.querySelector('#address');\n    const addrErr = wrapper.$el.querySelector('#addrErr');\n    submitBtn.click();\n    await flushPromises();\n\n    expect(fn).not.toHaveBeenCalled();\n    expect(nameErr.textContent).toBeTruthy();\n    expect(addrErr.textContent).toBeTruthy();\n    setValue(name, '12');\n    setValue(address, 'abc');\n    await flushPromises();\n    expect(nameErr.textContent).toBe('');\n    expect(addrErr.textContent).toBe('');\n    submitBtn.click();\n    await flushPromises();\n\n    expect(fn).toHaveBeenCalledWith({ user: { name: '12', addresses: ['abc'] } });\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can opt out of nested object fields","suites":["<Form />"],"updatePoint":{"line":1463,"column":43},"line":1463,"code":"  test('can opt out of nested object fields', async () => {\n    const fn = vi.fn();\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          onSubmit(values: any) {\n            fn(values);\n          },\n        };\n      },\n      template: `\n      <VForm @submit=\"onSubmit\" v-slot=\"{ values }\">\n        <Field name=\"[user.name]\" rules=\"required\"  />\n        <Field name=\"[user.addresses.0]\" id=\"address\" rules=\"required\"  />\n        <pre>{{ values }}</pre>\n\n        <button id=\"submit\">Submit</button>\n      </VForm>\n    `,\n    });\n\n    const submitBtn = wrapper.$el.querySelector('#submit');\n    const name = wrapper.$el.querySelector('input');\n    const address = wrapper.$el.querySelector('#address');\n    const pre = wrapper.$el.querySelector('pre');\n    setValue(name, '12');\n    setValue(address, 'abc');\n    await flushPromises();\n    expect(pre.textContent).toBe(JSON.stringify({ 'user.name': '12', 'user.addresses.0': 'abc' }, null, 2));\n    submitBtn.click();\n    await flushPromises();\n    expect(fn).toHaveBeenCalledWith({ 'user.name': '12', 'user.addresses.0': 'abc' });\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"validate fields on mount with validateOnMount = true","suites":["<Form />"],"updatePoint":{"line":1497,"column":60},"line":1497,"code":"  test('validate fields on mount with validateOnMount = true', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = yup.object({\n          email: yup.string().required().email(),\n          password: yup.string().required().min(8),\n        });\n\n        return {\n          schema,\n        };\n      },\n      template: `\n      <VForm :validationSchema=\"schema\" validateOnMount v-slot=\"{ errors }\">\n        <Field id=\"email\" name=\"email\" />\n        <span id=\"emailErr\">{{ errors.email }}</span>\n\n        <Field id=\"password\" name=\"password\" type=\"password\" />\n        <span id=\"passwordErr\">{{ errors.password }}</span>\n\n        <button>Validate</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n\n    const emailError = wrapper.$el.querySelector('#emailErr');\n    const passwordError = wrapper.$el.querySelector('#passwordErr');\n\n    await flushPromises();\n\n    expect(emailError.textContent).toBe('email is a required field');\n    expect(passwordError.textContent).toBe('password is a required field');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"sets individual field error message with setFieldError()","suites":["<Form />"],"updatePoint":{"line":1533,"column":64},"line":1533,"code":"  test('sets individual field error message with setFieldError()', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm ref=\"form\" v-slot=\"{ errors }\">\n        <Field id=\"email\" name=\"email\" />\n        <span id=\"emailErr\">{{ errors.email }}</span>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const emailError = wrapper.$el.querySelector('#emailErr');\n    (wrapper.$refs as any)?.form.setFieldError('email', 'WRONG');\n    await flushPromises();\n\n    expect(emailError.textContent).toBe('WRONG');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"sets multiple field error messages with setErrors()","suites":["<Form />"],"updatePoint":{"line":1551,"column":59},"line":1551,"code":"  test('sets multiple field error messages with setErrors()', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm ref=\"form\" v-slot=\"{ errors }\">\n        <Field id=\"email\" name=\"email\" />\n        <span id=\"emailErr\">{{ errors.email }}</span>\n\n        <Field id=\"password\" name=\"password\" type=\"password\" />\n        <span id=\"passwordErr\">{{ errors.password }}</span>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const emailError = wrapper.$el.querySelector('#emailErr');\n    const passwordError = wrapper.$el.querySelector('#passwordErr');\n\n    (wrapper.$refs as any)?.form.setErrors({\n      email: 'WRONG',\n      password: 'WRONG AGAIN',\n    });\n    await flushPromises();\n\n    expect(emailError.textContent).toBe('WRONG');\n    expect(passwordError.textContent).toBe('WRONG AGAIN');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"sets error message with setFieldError for checkboxes","suites":["<Form />"],"updatePoint":{"line":1578,"column":60},"line":1578,"code":"  test('sets error message with setFieldError for checkboxes', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm ref=\"form\" v-slot=\"{ errors }\">\n        <Field name=\"drink\" type=\"checkbox\" value=\"\" /> Coffee\n        <Field name=\"drink\" type=\"checkbox\" value=\"Tea\" /> Tea\n        <Field name=\"drink\" type=\"checkbox\" value=\"Coke\" /> Coke\n\n        <span id=\"err\">{{ errors.drink }}</span>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const error = wrapper.$el.querySelector('#err');\n    (wrapper.$refs as any)?.form.setFieldError('drink', 'WRONG');\n    await flushPromises();\n    expect(error.textContent).toBe('WRONG');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"sets individual field value with setFieldValue()","suites":["<Form />"],"updatePoint":{"line":1598,"column":56},"line":1598,"code":"  test('sets individual field value with setFieldValue()', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm ref=\"form\">\n        <Field id=\"email\" name=\"email\" />\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const value = 'example@gmail.com';\n    const email = wrapper.$el.querySelector('#email');\n    (wrapper.$refs as any)?.form.setFieldValue('email', value);\n    await flushPromises();\n    expect(email.value).toBe(value);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"sets multiple fields values with setValues()","suites":["<Form />"],"updatePoint":{"line":1615,"column":52},"line":1615,"code":"  test('sets multiple fields values with setValues()', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm ref=\"form\">\n        <Field id=\"email\" name=\"email\" />\n        <Field id=\"password\" name=\"password\" />\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const values = {\n      email: 'example@gmail.com',\n      password: '12345',\n    };\n    const inputs = wrapper.$el.querySelectorAll('input');\n    (wrapper.$refs as any)?.form.setValues(values);\n    await flushPromises();\n    expect(inputs[0].value).toBe(values.email);\n    expect(inputs[1].value).toBe(values.password);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"handles submit with handleSubmit and passing the event object","suites":["<Form />"],"updatePoint":{"line":1637,"column":69},"line":1637,"code":"  test('handles submit with handleSubmit and passing the event object', async () => {\n    const spy = vi.fn();\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = yup.object({\n          email: yup.string().required().email(),\n          password: yup.string().required().min(8),\n        });\n\n        return {\n          schema,\n          onSubmit: spy,\n        };\n      },\n      template: `\n      <VForm as=\"div\" :validationSchema=\"schema\" v-slot=\"{ errors, handleSubmit }\">\n        <form @submit=\"handleSubmit($event, onSubmit)\">\n          <Field id=\"email\" name=\"email\" />\n          <span id=\"emailErr\">{{ errors.email }}</span>\n\n          <Field id=\"password\" name=\"password\" type=\"password\" />\n          <span id=\"passwordErr\">{{ errors.password }}</span>\n\n          <button>Validate</button>\n        </form>\n      </VForm>\n    `,\n    });\n\n    const email = wrapper.$el.querySelector('#email');\n    const password = wrapper.$el.querySelector('#password');\n    const emailError = wrapper.$el.querySelector('#emailErr');\n    const passwordError = wrapper.$el.querySelector('#passwordErr');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n\n    expect(emailError.textContent).toBe('email is a required field');\n    expect(passwordError.textContent).toBe('password is a required field');\n    expect(spy).toHaveBeenCalledTimes(0);\n\n    setValue(email, 'hello@email.com');\n    setValue(password, '12346789');\n    wrapper.$el.querySelector('button').click();\n\n    await flushPromises();\n\n    expect(emailError.textContent).toBe('');\n    expect(passwordError.textContent).toBe('');\n    expect(spy).toHaveBeenCalledTimes(1);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"handles submit with handleSubmit without the event object","suites":["<Form />"],"updatePoint":{"line":1689,"column":65},"line":1689,"code":"  test('handles submit with handleSubmit without the event object', async () => {\n    const spy = vi.fn();\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = yup.object({\n          email: yup.string().required().email(),\n          password: yup.string().required().min(8),\n        });\n\n        return {\n          schema,\n          onSubmit: spy,\n        };\n      },\n      template: `\n      <VForm as=\"div\" :validationSchema=\"schema\" v-slot=\"{ errors, handleSubmit }\">\n        <form @submit.prevent.stop=\"handleSubmit(onSubmit)\">\n          <Field id=\"email\" name=\"email\" />\n          <span id=\"emailErr\">{{ errors.email }}</span>\n\n          <Field id=\"password\" name=\"password\" type=\"password\" />\n          <span id=\"passwordErr\">{{ errors.password }}</span>\n\n          <button>Validate</button>\n        </form>\n      </VForm>\n    `,\n    });\n\n    const email = wrapper.$el.querySelector('#email');\n    const password = wrapper.$el.querySelector('#password');\n    const emailError = wrapper.$el.querySelector('#emailErr');\n    const passwordError = wrapper.$el.querySelector('#passwordErr');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n\n    expect(emailError.textContent).toBe('email is a required field');\n    expect(passwordError.textContent).toBe('password is a required field');\n    expect(spy).toHaveBeenCalledTimes(0);\n\n    setValue(email, 'hello@email.com');\n    setValue(password, '12346789');\n    wrapper.$el.querySelector('button').click();\n\n    await flushPromises();\n\n    expect(emailError.textContent).toBe('');\n    expect(passwordError.textContent).toBe('');\n    expect(spy).toHaveBeenCalledTimes(1);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"sets meta touched with setFieldTouched for checkboxes","suites":["<Form />"],"updatePoint":{"line":1741,"column":61},"line":1741,"code":"  test('sets meta touched with setFieldTouched for checkboxes', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm ref=\"form\" v-slot=\"{ meta }\">\n        <Field name=\"drink\" type=\"checkbox\" value=\"\" /> Coffee\n        <Field name=\"drink\" type=\"checkbox\" value=\"Tea\" /> Tea\n        <Field name=\"drink\" type=\"checkbox\" value=\"Coke\" /> Coke\n\n        <span id=\"meta\">{{ meta.touched }}</span>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const meta = wrapper.$el.querySelector('#meta');\n    expect(meta?.textContent).toBe('false');\n    (wrapper.$refs as any)?.form.setFieldTouched('drink', true);\n    await flushPromises();\n    expect(meta?.textContent).toBe('true');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"sets initial errors with initialErrors","suites":["<Form />"],"updatePoint":{"line":1762,"column":46},"line":1762,"code":"  test('sets initial errors with initialErrors', async () => {\n    const errors = {\n      password: 'too short',\n      email: 'wrong',\n    };\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          errors,\n        };\n      },\n      template: `\n      <VForm ref=\"form\" :initial-errors=\"errors\">\n        <Field id=\"email\" name=\"email\" />\n        <ErrorMessage name=\"email\" />\n        <Field id=\"password\" name=\"password\" />\n        <ErrorMessage name=\"password\" />\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const errorEls = wrapper.$el.querySelectorAll('span');\n    await flushPromises();\n    expect(errorEls[0].textContent).toBe(errors.email);\n    expect(errorEls[1].textContent).toBe(errors.password);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"sets touched with initial touched","suites":["<Form />"],"updatePoint":{"line":1790,"column":41},"line":1790,"code":"  test('sets touched with initial touched', async () => {\n    const touched = {\n      email: true,\n    };\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          touched,\n        };\n      },\n      template: `\n      <VForm ref=\"form\" :initial-touched=\"touched\">\n        <Field id=\"email\" name=\"email\"  v-slot=\"{ meta, field }\">\n          <input v-bind=\"field\" />\n          <span>{{ meta.touched }}</span>\n        </Field>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const meta = wrapper.$el.querySelector('span');\n    await flushPromises();\n    expect(meta.textContent).toBe('true');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"counts the number of submission attempts","suites":["<Form />"],"updatePoint":{"line":1816,"column":48},"line":1816,"code":"  test('counts the number of submission attempts', async () => {\n    const spy = vi.fn();\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          onSubmit: spy,\n        };\n      },\n      template: `\n      <VForm @submit=\"onSubmit\" v-slot=\"{ submitCount }\">\n        <Field id=\"email\" name=\"email\" />\n        <span>{{ submitCount }}</span>\n\n        <button>Submit</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const countSpan = wrapper.$el.querySelector('span');\n    expect(countSpan.textContent).toBe('0');\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(countSpan.textContent).toBe('1');\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(countSpan.textContent).toBe('2');\n    expect(spy).toHaveReturnedTimes(2);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can reset the submit count to whatever value with resetForm","suites":["<Form />"],"updatePoint":{"line":1846,"column":67},"line":1846,"code":"  test('can reset the submit count to whatever value with resetForm', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          onSubmit: vi.fn(),\n        };\n      },\n      template: `\n      <VForm @submit=\"onSubmit\" v-slot=\"{ submitCount, resetForm }\">\n        <Field id=\"email\" name=\"email\" />\n        <span>{{ submitCount }}</span>\n\n        <button>Submit</button>\n        <button type=\"button\" id=\"reset\" @click=\"resetForm({ submitCount: 5 })\">Submit</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const countSpan = wrapper.$el.querySelector('span');\n    expect(countSpan.textContent).toBe('0');\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(countSpan.textContent).toBe('1');\n    wrapper.$el.querySelector('#reset').click();\n    await flushPromises();\n    expect(countSpan.textContent).toBe('5');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"reset should not toggle the checkbox values","suites":["<Form />"],"updatePoint":{"line":1876,"column":51},"line":1876,"code":"  test('reset should not toggle the checkbox values', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm>\n        <Field name=\"field\" type=\"checkbox\" :value=\"true\" />\n\n        <button type=\"reset\">Submit</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const input = wrapper.$el.querySelector('input');\n    const btn = wrapper.$el.querySelector('button');\n    setChecked(input, true);\n    await flushPromises();\n    btn.click();\n    await flushPromises();\n    expect(input.checked).toBe(false);\n\n    btn.click();\n    await flushPromises();\n    expect(input.checked).toBe(false);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"fields replacing others with the same name should have their value set correctly","suites":["<Form />"],"updatePoint":{"line":1902,"column":88},"line":1902,"code":"  test('fields replacing others with the same name should have their value set correctly', async () => {\n    const data = [\n      {\n        id: 1,\n        title: 'this is a test no 1',\n      },\n      {\n        id: 2,\n        title: 'this is a test no 2',\n      },\n      {\n        id: 3,\n        title: 'this is a test no 3',\n      },\n      {\n        id: 4,\n        title: 'this is a test no 4',\n      },\n    ];\n    let setModified!: (field: { id: number; title: string }) => void;\n    mountWithHoc({\n      setup() {\n        const fields = ref(data);\n        const modified = ref({ id: -1, title: '' });\n        setModified = (item: { id: number; title: string }) => {\n          modified.value = { ...item };\n        };\n\n        return {\n          fields,\n          setModified,\n          modified,\n        };\n      },\n      template: `\n        <VForm>\n          <ul>\n            <li v-for=\"field in fields\" :key=\"field.id\">\n              <Field v-if=\"modified.id === field.id\" name=\"test\" v-model=\"modified.title\" type=\"text\" />\n            </li>\n          </ul>\n        </VForm>\n    `,\n    });\n\n    await flushPromises();\n\n    const input = () => document.querySelector('input');\n    setModified(data[3]);\n    await flushPromises();\n    expect(input()?.value).toBe(data[3].title);\n\n    setModified(data[2]);\n    await flushPromises();\n    expect(input()?.value).toBe(data[2].title);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"resetForm should reset the meta flag","suites":["<Form />"],"updatePoint":{"line":1959,"column":44},"line":1959,"code":"  test('resetForm should reset the meta flag', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm  v-slot=\"{ meta, resetForm }\">\n        <Field id=\"email\" name=\"email\" rules=\"required\" />\n        <Field id=\"password\" name=\"password\" rules=\"required\" />\n\n        <span id=\"meta\">{{ meta.valid ? 'valid' : 'invalid' }}</span>\n        <button type=\"button\" @click=\"resetForm()\">Reset</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const span = wrapper.$el.querySelector('#meta');\n    const input = wrapper.$el.querySelector('input');\n    expect(span.textContent).toBe('invalid');\n    setValue(input, '');\n    await flushPromises();\n\n    expect(span.textContent).toBe('invalid');\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(span.textContent).toBe('invalid');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"resetForm should reset the meta flag based on the errors length","suites":["<Form />"],"updatePoint":{"line":1985,"column":71},"line":1985,"code":"  test('resetForm should reset the meta flag based on the errors length', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm :initial-values=\"{ email: '2', password: '3' }\"  v-slot=\"{ meta, resetForm }\">\n        <Field id=\"email\" name=\"email\" rules=\"required\" />\n        <Field id=\"password\" name=\"password\" rules=\"required\" />\n\n        <span id=\"meta\">{{ meta.valid ? 'valid' : 'invalid' }}</span>\n        <button type=\"button\" @click=\"resetForm({ errors: { email: 'bad' } })\">Reset</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const span = wrapper.$el.querySelector('#meta');\n    expect(span.textContent).toBe('valid');\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(span.textContent).toBe('invalid');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"valid flag should reflect the accurate form validity","suites":["<Form />"],"updatePoint":{"line":2006,"column":60},"line":2006,"code":"  test('valid flag should reflect the accurate form validity', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm  v-slot=\"{ meta, resetForm }\">\n        <Field id=\"email\" name=\"email\" rules=\"required\" />\n        <Field id=\"password\" name=\"password\" rules=\"required\" />\n\n        <span id=\"meta\">{{ meta.valid ? 'valid' : 'invalid' }}</span>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const span = wrapper.$el.querySelector('#meta');\n    expect(span.textContent).toBe('invalid');\n\n    const email = wrapper.$el.querySelector('#email');\n    setValue(email, '');\n    await flushPromises();\n    // the email field is invalid\n    expect(span.textContent).toBe('invalid');\n\n    // should be valid now\n    setValue(email, 'example@test.com');\n    await flushPromises();\n    // still invalid because the password is invalid\n    expect(span.textContent).toBe('invalid');\n\n    const password = wrapper.$el.querySelector('#password');\n    setValue(password, '12');\n    await flushPromises();\n    expect(span.textContent).toBe('valid');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"should not validate touched fields with yup schema if other fields value change","suites":["<Form />"],"updatePoint":{"line":2041,"column":87},"line":2041,"code":"  test('should not validate touched fields with yup schema if other fields value change', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = yup.object({\n          email: yup.string().required(),\n          password: yup.string().required(),\n        });\n\n        return {\n          schema,\n        };\n      },\n      template: `\n      <VForm :validation-schema=\"schema\"  v-slot=\"{ errors }\">\n        <Field id=\"email\" name=\"email\" :validate-on-blur=\"false\" />\n        <Field id=\"password\" name=\"password\" :validate-on-blur=\"false\" />\n\n        <span>{{ errors.email }}</span>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const span = wrapper.$el.querySelector('span');\n    const email = wrapper.$el.querySelector('#email');\n    const password = wrapper.$el.querySelector('#password');\n    // the field is now blurred\n    dispatchEvent(email, 'blur');\n    await flushPromises();\n    // no error messages for email\n    expect(span.textContent).toBe('');\n\n    // should be valid now\n    setValue(password, '');\n    await flushPromises();\n    // again there should be no error messages for email, only the password\n    expect(span.textContent).toBe('');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can set multiple field errors on the form level","suites":["<Form />"],"updatePoint":{"line":2080,"column":55},"line":2080,"code":"  test('can set multiple field errors on the form level', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm v-slot=\"{ setFieldError }\">\n        <Field name=\"whatever\" v-slot=\"{ field, errors, setErrors }\" rules=\"required\">\n          <input v-bind=\"field\" />\n          <ul>\n            <li v-for=\"error in errors\">{{ error }}</li>\n          </ul>\n          <button type=\"button\" @click=\"setFieldError('whatever', ['bad', 'wrong'])\">Set errors</button>\n        </Field>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const list = document.querySelector('ul');\n    expect(list?.children).toHaveLength(0);\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(list?.children).toHaveLength(2);\n    expect(list?.textContent).toBe('badwrong');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"supports computed yup schemas","suites":["<Form />"],"updatePoint":{"line":2104,"column":37},"line":2104,"code":"  test('supports computed yup schemas', async () => {\n    mountWithHoc({\n      setup() {\n        const acceptList = ref(['1', '2']);\n        const schema = computed(() => {\n          return yup.object({\n            password: yup.string().oneOf(acceptList.value),\n          });\n        });\n\n        return {\n          schema,\n        };\n      },\n      template: `\n      <VForm :validation-schema=\"schema\" v-slot=\"{ errors }\">\n        <Field name=\"password\" />\n        <span>{{ errors.password }}</span>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input') as HTMLInputElement;\n    expect(document.querySelector('span')?.textContent).toBe('');\n    setValue(input, '3');\n    await flushPromises();\n    // 3 is not allowed yet\n    expect(document.querySelector('span')?.textContent).toBeTruthy();\n    await flushPromises();\n    // field is re-validated\n    setValue(input, '2');\n    await flushPromises();\n\n    expect(document.querySelector('span')?.textContent).toBe('');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"re-validates when a computed yup schema changes","suites":["<Form />"],"updatePoint":{"line":2141,"column":55},"line":2141,"code":"  test('re-validates when a computed yup schema changes', async () => {\n    const acceptList = ref(['1', '2']);\n    function addItem(item: string) {\n      acceptList.value.push(item);\n    }\n\n    mountWithHoc({\n      setup() {\n        const schema = computed(() => {\n          return yup.object({\n            password: yup.string().oneOf(acceptList.value),\n          });\n        });\n\n        return {\n          schema,\n        };\n      },\n      template: `\n      <VForm :validation-schema=\"schema\" v-slot=\"{ errors }\">\n        <Field name=\"password\" />\n        <span>{{ errors.password }}</span>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input') as HTMLInputElement;\n    expect(document.querySelector('span')?.textContent).toBe('');\n    setValue(input, '3');\n    await flushPromises();\n    // 3 is not allowed yet\n    expect(document.querySelector('span')?.textContent).toBeTruthy();\n\n    // field is re-validated automatically\n    addItem('3');\n    await flushPromises();\n    expect(document.querySelector('span')?.textContent).toBe('');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"submitting forms should touch fields","suites":["<Form />"],"updatePoint":{"line":2181,"column":44},"line":2181,"code":"  test('submitting forms should touch fields', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          onSubmit: vi.fn(),\n        };\n      },\n      template: `\n      <VForm @submit=\"onSubmit\" v-slot=\"{ meta }\">\n        <Field id=\"email\" name=\"email\" rules=\"required\" />\n        <Field id=\"password\" name=\"password\" rules=\"required\" v-slot=\"fieldProps\">\n          <input v-bind=\"fieldProps.field\" />\n          <span id=\"fieldMeta\">{{ fieldProps.meta.touched ? 'touched' : 'untouched' }}</span>\n        </Field>\n\n        <span id=\"meta\">{{ meta.touched ? 'touched' : 'untouched' }}</span>\n        <button type=\"submit\">Submit</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const formMeta = wrapper.$el.querySelector('#meta');\n    const fieldMeta = wrapper.$el.querySelector('#fieldMeta');\n    expect(formMeta.textContent).toBe('untouched');\n    expect(fieldMeta.textContent).toBe('untouched');\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(formMeta.textContent).toBe('touched');\n    expect(fieldMeta.textContent).toBe('touched');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"non-rendered fields defined in yup schema are not ignored","suites":["<Form />"],"updatePoint":{"line":2213,"column":65},"line":2213,"code":"  test('non-rendered fields defined in yup schema are not ignored', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = yup.object({\n          email: yup.string().required(),\n          password: yup.string().required(),\n        });\n\n        return {\n          onSubmit: vi.fn(),\n          schema,\n        };\n      },\n      template: `\n      <VForm @submit=\"onSubmit\" :validation-schema=\"schema\" v-slot=\"{ errors }\">\n        <Field name=\"email\" />\n        <span id=\"passwordError\">{{ errors.password }}</span>\n\n        <button type=\"submit\">Submit</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const passwordError = wrapper.$el.querySelector('#passwordError');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(passwordError.textContent).toBeTruthy();\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"non-rendered fields defined in schema are not ignored","suites":["<Form />"],"updatePoint":{"line":2244,"column":61},"line":2244,"code":"  test('non-rendered fields defined in schema are not ignored', async () => {\n    const submit = vi.fn();\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = {\n          email: 'required',\n          password: 'required',\n        };\n\n        return {\n          onSubmit: submit,\n          schema,\n        };\n      },\n      template: `\n      <VForm @submit=\"onSubmit\" :validation-schema=\"schema\" v-slot=\"{ errors }\">\n        <Field name=\"email\" />\n        <span id=\"passwordError\">{{ errors.password }}</span>\n\n        <button type=\"submit\">Submit</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const passwordError = wrapper.$el.querySelector('#passwordError');\n\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(passwordError.textContent).toBeTruthy();\n    expect(submit).not.toHaveBeenCalled();\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"setting errors for non-existing fields creates them as virtual","suites":["<Form />"],"updatePoint":{"line":2277,"column":70},"line":2277,"code":"  test('setting errors for non-existing fields creates them as virtual', async () => {\n    const errorMessage = 'bad pw';\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm v-slot=\"{ errors, setFieldError }\">\n        <span id=\"passwordError\">{{ errors.password }}</span>\n        <button type=\"button\" @click=\"setFieldError('password', '${errorMessage}')\">Set error</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const passwordError = wrapper.$el.querySelector('#passwordError');\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(passwordError.textContent).toBe(errorMessage);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"setting values for non-existing fields creates them as virtual","suites":["<Form />"],"updatePoint":{"line":2295,"column":70},"line":2295,"code":"  test('setting values for non-existing fields creates them as virtual', async () => {\n    const value = '123';\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm v-slot=\"{ values, setFieldValue }\">\n        <span id=\"passwordValue\">{{ values.password }}</span>\n        <button type=\"button\" @click=\"setFieldValue('password', '${value}')\">Set value</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const passwordValue = wrapper.$el.querySelector('#passwordValue');\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(passwordValue.textContent).toBe(value);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"reset virtual fields errors and values","suites":["<Form />"],"updatePoint":{"line":2313,"column":46},"line":2313,"code":"  test('reset virtual fields errors and values', async () => {\n    const errorMessage = 'bad pw';\n    const value = '123';\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm v-slot=\"{ errors, values, setFieldError, setFieldValue, resetForm }\">\n        <span id=\"passwordError\">{{ errors.password }}</span>\n        <span id=\"passwordValue\">{{ values.password }}</span>\n\n        <button id=\"setError\" type=\"button\" @click=\"setFieldError('password', '${errorMessage}')\">Set error</button>\n        <button id=\"setValue\" type=\"button\" @click=\"setFieldValue('password', '${value}')\">Set value</button>\n\n        <button id=\"reset\" type=\"button\" @click=\"resetForm()\">Reset</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const passwordError = wrapper.$el.querySelector('#passwordError');\n    const passwordValue = wrapper.$el.querySelector('#passwordValue');\n    wrapper.$el.querySelector('#setValue').click();\n    await flushPromises();\n    wrapper.$el.querySelector('#setError').click();\n    await flushPromises();\n    expect(passwordError.textContent).toBe(errorMessage);\n    expect(passwordValue.textContent).toBe(value);\n    wrapper.$el.querySelector('#reset').click();\n    await flushPromises();\n    expect(passwordError.textContent).toBe('');\n    expect(passwordValue.textContent).toBe('');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"reset virtual field state to specific value and error","suites":["<Form />"],"updatePoint":{"line":2345,"column":61},"line":2345,"code":"  test('reset virtual field state to specific value and error', async () => {\n    const errorMessage = 'bad pw';\n    const value = '123';\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm v-slot=\"{ errors, values, resetForm }\">\n        <span id=\"passwordError\">{{ errors.password }}</span>\n        <span id=\"passwordValue\">{{ values.password }}</span>\n        <button id=\"reset\" type=\"button\" @click=\"resetForm({ values: { password: '${value}' }, errors: { password: '${errorMessage}' } })\">Reset</button>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const passwordError = wrapper.$el.querySelector('#passwordError');\n    const passwordValue = wrapper.$el.querySelector('#passwordValue');\n    expect(passwordError.textContent).toBe('');\n    expect(passwordValue.textContent).toBe('');\n    wrapper.$el.querySelector('#reset').click();\n    await flushPromises();\n    expect(passwordError.textContent).toBe(errorMessage);\n    expect(passwordValue.textContent).toBe(value);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"field bails prop should work with validation schema","suites":["<Form />"],"updatePoint":{"line":2370,"column":59},"line":2370,"code":"  test('field bails prop should work with validation schema', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          schema: {\n            fname: 'required|min:3',\n          },\n        };\n      },\n      template: `\n      <VForm :validation-schema=\"schema\">\n        <Field name=\"fname\" :bails=\"false\" v-slot=\"{ field, errors }\">\n          <input type=\"text\" v-bind=\"field\" />\n          <div v-for=\"error in errors\" :key=\"error\" class=\"error\">\n            {{ error }}\n          </div>\n        </Field>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const input = wrapper.$el.querySelector('input');\n    setValue(input, '');\n    await flushPromises();\n    expect(document.querySelectorAll('.error')).toHaveLength(2);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"field with pre-register errors should be checked on register","suites":["<Form />"],"updatePoint":{"line":2399,"column":68},"line":2399,"code":"  test('field with pre-register errors should be checked on register', async () => {\n    const isShown = ref(false);\n    const modelValue = ref('');\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          isShown,\n          modelValue,\n          schema: {\n            fname: 'required',\n          },\n        };\n      },\n      template: `\n      <VForm :validation-schema=\"schema\" v-slot=\"{ errors }\">\n        <Field v-if=\"isShown\" name=\"fname\" v-model=\"modelValue\" />\n        <span>{{ errors.fname }}</span>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const span = wrapper.$el.querySelector('span');\n    expect(span.textContent).toBe(REQUIRED_MESSAGE);\n    modelValue.value = 'hello';\n    isShown.value = true;\n\n    await flushPromises();\n    // field was re-checked\n    expect(span.textContent).toBe('');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"field errors should be removed when its unmounted","suites":["<Form />"],"updatePoint":{"line":2431,"column":57},"line":2431,"code":"  test('field errors should be removed when its unmounted', async () => {\n    const isShown = ref(true);\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          isShown,\n        };\n      },\n      template: `\n      <VForm v-slot=\"{ errors }\">\n        <Field v-if=\"isShown\" name=\"fname\"  rules=\"required\"/>\n        <span>{{ errors.fname }}</span>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const span = wrapper.$el.querySelector('span');\n    setValue(wrapper.$el.querySelector('input'), '');\n    await flushPromises();\n    expect(span.textContent).toBe(REQUIRED_MESSAGE);\n    isShown.value = false;\n\n    await flushPromises();\n    // field was re-checked\n    expect(span.textContent).toBe('');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"standalone fields are excluded from form state","suites":["<Form />"],"updatePoint":{"line":2459,"column":54},"line":2459,"code":"  test('standalone fields are excluded from form state', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        return {};\n      },\n      template: `\n      <VForm  v-slot=\"{ errors, meta }\">\n        <Field name=\"fname\" standalone v-slot=\"{ errorMessage, field }\" rules=\"required\">\n          <input v-bind=\"field\" />\n          <span id=\"fieldError\">{{ errorMessage }}</span>\n        </Field>\n        <span id=\"formError\">{{ errors.fname }}</span>\n        <span id=\"meta\">{{ meta.valid }}</span>\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const formError = wrapper.$el.querySelector('#formError');\n    const fieldError = wrapper.$el.querySelector('#fieldError');\n    const meta = wrapper.$el.querySelector('#meta');\n\n    expect(formError.textContent).toBe('');\n    expect(fieldError.textContent).toBe('');\n    expect(meta.textContent).toBe('true');\n\n    setValue(wrapper.$el.querySelector('input'), '');\n    await flushPromises();\n\n    expect(formError.textContent).toBe('');\n    expect(fieldError.textContent).toBe(REQUIRED_MESSAGE);\n    expect(meta.textContent).toBe('true');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"Checkbox with v-model should not propagate the empty value symbol","suites":["<Form />"],"updatePoint":{"line":2494,"column":73},"line":2494,"code":"  test('Checkbox with v-model should not propagate the empty value symbol', async () => {\n    const value = ref('');\n    mountWithHoc({\n      setup() {\n        return {\n          value,\n        };\n      },\n      template: `\n      <VForm>\n        <Field name=\"check\" type=\"checkbox\" v-model=\"value\" value=\"CHECKED\" />\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input') as HTMLInputElement;\n    setChecked(input, true);\n    await flushPromises();\n    expect(value.value).toBe('CHECKED');\n\n    setChecked(input, false);\n    await flushPromises();\n\n    expect(value.value).toBe(undefined);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"Two fields of the same name should not override each other value when either is mounted","suites":["<Form />"],"updatePoint":{"line":2522,"column":95},"line":2522,"code":"  test('Two fields of the same name should not override each other value when either is mounted', async () => {\n    const isHidden = ref(false);\n    const value = ref('');\n    mountWithHoc({\n      setup() {\n        return {\n          value,\n          isHidden,\n        };\n      },\n      template: `\n      <VForm>\n        <Field name=\"name\" type=\"text\" v-model=\"value\" />\n        <Field v-if=\"isHidden\" name=\"name\" type=\"text\" v-model=\"value\" />\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input') as HTMLInputElement;\n    setValue(input, '1234');\n    await flushPromises();\n    isHidden.value = true;\n    await flushPromises();\n    expect(input.value).toBe(value.value);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"Falsy model value should still have priority over form value","suites":["<Form />"],"updatePoint":{"line":2550,"column":68},"line":2550,"code":"  test('Falsy model value should still have priority over form value', async () => {\n    const value = ref(0);\n    mountWithHoc({\n      setup() {\n        const initials = { age: 2 };\n        return {\n          value,\n          initials,\n        };\n      },\n      template: `\n      <VForm :initial-values=\"initials\">\n        <Field name=\"age\" type=\"number\" v-model=\"value\" />\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input') as HTMLInputElement;\n    expect(input.value).toBe('0');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"handles invalid submissions","suites":["<Form />"],"updatePoint":{"line":2572,"column":35},"line":2572,"code":"  test('handles invalid submissions', async () => {\n    const invalidSpy = vi.fn();\n    const validSpy = vi.fn();\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = yup.object({\n          email: yup.string().required().email(),\n          password: yup.string().required().min(8),\n        });\n\n        return {\n          schema,\n          onInvalidSubmit: invalidSpy,\n          onSubmit: validSpy,\n        };\n      },\n      template: `\n      <VForm :validationSchema=\"schema\" @invalid-submit=\"onInvalidSubmit\" @submit=\"onSubmit\" v-slot=\"{ errors }\">\n        <Field id=\"email\" name=\"email\" />\n        <span id=\"emailErr\">{{ errors.email }}</span>\n\n        <Field id=\"password\" name=\"password\" type=\"password\" />\n        <span id=\"passwordErr\">{{ errors.password }}</span>\n\n        <button>Submit</button>\n      </VForm>\n    `,\n    });\n\n    const expectedEmailError = 'email is a required field';\n    const expectedPasswordError = 'password is a required field';\n    await flushPromises();\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(invalidSpy).toHaveBeenCalledTimes(1);\n    expect(invalidSpy).toHaveBeenLastCalledWith({\n      values: {\n        email: undefined,\n        password: undefined,\n      },\n      errors: {\n        email: expectedEmailError,\n        password: expectedPasswordError,\n      },\n      evt: expect.anything(),\n      results: {\n        email: {\n          valid: false,\n          errors: [expectedEmailError],\n        },\n        password: {\n          valid: false,\n          errors: [expectedPasswordError],\n        },\n      },\n    } as InvalidSubmissionContext);\n    expect(validSpy).not.toHaveBeenCalled();\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"handles invalid submissions with submitForm","suites":["<Form />"],"updatePoint":{"line":2631,"column":51},"line":2631,"code":"  test('handles invalid submissions with submitForm', async () => {\n    const invalidSpy = vi.fn();\n    const validSpy = vi.fn();\n    const wrapper = mountWithHoc({\n      setup() {\n        const schema = yup.object({\n          email: yup.string().required().email(),\n          password: yup.string().required().min(8),\n        });\n\n        return {\n          schema,\n          onInvalidSubmit: invalidSpy,\n          onSubmit: validSpy,\n        };\n      },\n      template: `\n      <VForm v-slot=\"{ submitForm, errors }\" :validationSchema=\"schema\" @invalid-submit=\"onInvalidSubmit\">\n        <form @submit=\"submitForm\">\n            <Field id=\"email\" name=\"email\" />\n            <span id=\"emailErr\">{{ errors.email }}</span>\n\n            <Field id=\"password\" name=\"password\" type=\"password\" />\n            <span id=\"passwordErr\">{{ errors.password }}</span>\n\n            <button>Submit</button>\n        </form>\n      </VForm>\n    `,\n    });\n\n    const expectedEmailError = 'email is a required field';\n    const expectedPasswordError = 'password is a required field';\n    await flushPromises();\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(invalidSpy).toHaveBeenCalledTimes(1);\n    expect(invalidSpy).toHaveBeenLastCalledWith({\n      values: {\n        email: undefined,\n        password: undefined,\n      },\n      errors: {\n        email: expectedEmailError,\n        password: expectedPasswordError,\n      },\n      evt: expect.anything(),\n      results: {\n        email: {\n          valid: false,\n          errors: [expectedEmailError],\n        },\n        password: {\n          valid: false,\n          errors: [expectedPasswordError],\n        },\n      },\n    } as InvalidSubmissionContext);\n    expect(validSpy).not.toHaveBeenCalled();\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"resets checkboxes according to initial values","suites":["<Form />"],"updatePoint":{"line":2693,"column":53},"line":2693,"code":"  test('resets checkboxes according to initial values', async () => {\n    const wrapper = mountWithHoc({\n      setup() {\n        return {\n          values: {\n            terms: true,\n            termsUnslotted: true,\n            array: ['coffee', 'tea'],\n          },\n        };\n      },\n      template: `\n      <VForm v-slot=\"{  resetForm }\" :initial-values=\"values\">\n        <Field v-slot=\"{ field }\" name=\"terms\" type=\"checkbox\" :value=\"true\" :unchecked-value=\"false\">\n          <label>\n            <input type=\"checkbox\" name=\"terms\" v-bind=\"field\" :value=\"true\" :unchecked-value=\"false\" />\n          </label>\n        </Field>\n\n        <Field name=\"termsUnslotted\" type=\"checkbox\" :value=\"true\" :unchecked-value=\"false\"></Field>\n\n        <Field name=\"array\" type=\"checkbox\" value=\"coffee\"></Field>\n        <Field name=\"array\" type=\"checkbox\" value=\"tea\"></Field>\n\n        <button id=\"reset1\" type=\"button\" @click=\"resetForm()\">Reset</button>\n        <button id=\"reset2\" type=\"button\" @click=\"resetForm({ values: { terms: false, termsUnslotted: true, array: ['coffee'] } })\">Reset</button>\n      </VForm>\n    `,\n    });\n\n    const inputAt = (idx: number) => wrapper.$el.querySelectorAll('input')[idx] as HTMLInputElement;\n    expect(inputAt(0).checked).toBe(true);\n    expect(inputAt(1).checked).toBe(true);\n    expect(inputAt(2).checked).toBe(true);\n    expect(inputAt(3).checked).toBe(true);\n\n    dispatchEvent('#reset1', 'click');\n    await flushPromises();\n    expect(inputAt(0).checked).toBe(true);\n    expect(inputAt(1).checked).toBe(true);\n    expect(inputAt(2).checked).toBe(true);\n    expect(inputAt(3).checked).toBe(true);\n\n    dispatchEvent('#reset2', 'click');\n    await flushPromises();\n    expect(inputAt(0).checked).toBe(false);\n    expect(inputAt(1).checked).toBe(true);\n    expect(inputAt(2).checked).toBe(true);\n    expect(inputAt(3).checked).toBe(false);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"single checkbox component with v-model in a form","suites":["<Form />"],"updatePoint":{"line":2745,"column":56},"line":2745,"code":"  test('single checkbox component with v-model in a form', async () => {\n    const value = ref(false);\n    const Checkbox = defineComponent({\n      props: { value: Boolean, modelValue: Boolean },\n      template: `<input type=\"checkbox\" @change=\"handleChange\" :checked=\"checked\" :value=\"true\" />`,\n      setup() {\n        const { handleChange, checked } = useField('field', undefined, {\n          type: 'checkbox',\n          uncheckedValue: false,\n          checkedValue: true,\n        });\n\n        return {\n          handleChange,\n          checked,\n        };\n      },\n    });\n    const wrapper = mountWithHoc({\n      components: {\n        Checkbox,\n      },\n      setup() {\n        return {\n          value,\n        };\n      },\n      template: `\n      <VForm>\n        <Checkbox v-model=\"value\" />\n      </VForm>\n    `,\n    });\n\n    await flushPromises();\n    const inputAt = (idx: number) => wrapper.$el.querySelectorAll('input')[idx] as HTMLInputElement;\n    expect(value.value).toBe(false);\n    setChecked(inputAt(0), true);\n    await flushPromises();\n    expect(value.value).toBe(true);\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"resets a single field  resetField() to initial state in slot scope props","suites":["<Form />"],"updatePoint":{"line":2787,"column":80},"line":2787,"code":"  test('resets a single field  resetField() to initial state in slot scope props', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm v-slot=\"{ resetField }\">\n        <Field name=\"field\" rules=\"required\" v-slot=\"{ field, errors, meta }\">\n          <input type=\"text\" v-bind=\"field\">\n          <span id=\"error\">{{ errors && errors[0] }}</span>\n          <span id=\"touched\">{{ meta.touched }}</span>\n          <button @click=\"resetField('field')\" type=\"button\">Reset</button>\n        </Field>\n      </VForm>\n    `,\n    });\n\n    const error = wrapper.$el.querySelector('#error');\n    const touched = wrapper.$el.querySelector('#touched');\n    const input = wrapper.$el.querySelector('input');\n\n    expect(error.textContent).toBe('');\n\n    setValue(input, '');\n    await flushPromises();\n    expect(error.textContent).toBe(REQUIRED_MESSAGE);\n    setValue(input, '123');\n    dispatchEvent(input, 'blur');\n    await flushPromises();\n    expect(touched.textContent).toBe('true');\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(error.textContent).toBe('');\n    expect(input.value).toBe('');\n    expect(touched.textContent).toBe('false');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"resets a single field resetField() to specific state in slot scope props","suites":["<Form />"],"updatePoint":{"line":2821,"column":80},"line":2821,"code":"  test('resets a single field resetField() to specific state in slot scope props', async () => {\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm v-slot=\"{ resetField }\">\n        <Field name=\"field\" rules=\"required\" v-slot=\"{ field, errors, meta }\">\n          <input type=\"text\" v-bind=\"field\">\n          <span id=\"error\">{{ errors && errors[0] }}</span>\n          <span id=\"touched\">{{ meta.touched }}</span>\n          <button @click=\"resetField('field', { value: 'test', touched: true })\" type=\"button\">Reset</button>\n        </Field>\n      </VForm>\n    `,\n    });\n\n    const error = wrapper.$el.querySelector('#error');\n    const touched = wrapper.$el.querySelector('#touched');\n    const input = wrapper.$el.querySelector('input');\n\n    expect(error.textContent).toBe('');\n\n    setValue(input, '');\n    await flushPromises();\n    expect(error.textContent).toBe(REQUIRED_MESSAGE);\n    setValue(input, '123');\n    dispatchEvent(input, 'blur');\n    await flushPromises();\n    expect(touched.textContent).toBe('true');\n    wrapper.$el.querySelector('button').click();\n    await flushPromises();\n    expect(error.textContent).toBe('');\n    expect(input.value).toBe('test');\n    expect(touched.textContent).toBe('true');\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"exposes values and meta with getValues and getMeta exposed APIs","suites":["<Form />"],"updatePoint":{"line":2855,"column":71},"line":2855,"code":"  test('exposes values and meta with getValues and getMeta exposed APIs', async () => {\n    const formRef = ref<InstanceType<typeof Form>>();\n    const wrapper = mountWithHoc({\n      template: `\n      <VForm ref=\"formRef\">\n        <Field name=\"field\" rules=\"required|min:3\" />\n      </VForm>\n    `,\n      setup() {\n        return {\n          formRef,\n        };\n      },\n    });\n\n    const input = wrapper.$el.querySelector('input');\n    setValue(input, '1');\n    dispatchEvent(input, 'blur');\n    await flushPromises();\n\n    expect(formRef.value?.getValues()).toEqual({ field: '1' });\n    expect(formRef.value?.getMeta()).toEqual({\n      touched: true,\n      dirty: true,\n      valid: false,\n      pending: false,\n      initialValues: {},\n    });\n    expect(formRef.value?.getErrors()).toEqual({ field: MIN_MESSAGE });\n  });","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"unmounted radio fields gets unregistered and their submitted values are kept if configured on the form level","suites":["<Form />"],"updatePoint":{"line":2888,"column":114},"line":2888,"code":"test('unmounted radio fields gets unregistered and their submitted values are kept if configured on the form level', async () => {\n  let showFields!: Ref<boolean>;\n  const spy = vi.fn();\n  const wrapper = mountWithHoc({\n    setup() {\n      showFields = ref(true);\n\n      return {\n        showFields,\n        onSubmit(values: any) {\n          spy(values);\n        },\n      };\n    },\n    template: `\n      <VForm @submit=\"onSubmit\" v-slot=\"{ errors }\" keep-values>\n        <template v-if=\"showFields\">\n          <Field name=\"drink\"  type=\"radio\" value=\"\" rules=\"required\" /> Coffee\n          <Field name=\"drink\"  type=\"radio\" value=\"Tea\" rules=\"required\" /> Tea\n        </template>\n\n        <Field name=\"drink\"  type=\"radio\" value=\"Coke\" rules=\"required\" /> Coke\n\n        <span id=\"errors\">{{ errors }}</span>\n\n        <button>Submit</button>\n      </VForm>\n    `,\n  });\n\n  await flushPromises();\n  const errors = wrapper.$el.querySelector('#errors');\n  const button = wrapper.$el.querySelector('button');\n  const inputs = wrapper.$el.querySelectorAll('input');\n\n  wrapper.$el.querySelector('button').click();\n  await flushPromises();\n  expect(errors.textContent).toBeTruthy();\n  setChecked(inputs[1]);\n\n  await flushPromises();\n  button.click();\n  await flushPromises();\n  const expected = {\n    drink: 'Tea',\n  };\n  expect(spy).toHaveBeenLastCalledWith(expected);\n\n  showFields.value = false;\n  await flushPromises();\n  expect(errors.textContent).toBe('{}');\n  button.click();\n  await flushPromises();\n  expect(spy).toHaveBeenLastCalledWith(expected);\n});","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"unmounted radio fields gets unregistered and their submitted values are removed","suites":["<Form />"],"updatePoint":{"line":2945,"column":85},"line":2945,"code":"test('unmounted radio fields gets unregistered and their submitted values are removed', async () => {\n  let showFields!: Ref<boolean>;\n  const spy = vi.fn();\n  const wrapper = mountWithHoc({\n    setup() {\n      showFields = ref(true);\n\n      return {\n        showFields,\n        onSubmit(values: any) {\n          spy(values);\n        },\n      };\n    },\n    template: `\n      <VForm @submit=\"onSubmit\" v-slot=\"{ errors }\">\n        <template v-if=\"showFields\">\n          <Field name=\"drink\" type=\"radio\" value=\"\" /> Coffee\n          <Field name=\"drink\" type=\"radio\" value=\"Tea\" /> Tea\n        </template>\n\n        <Field name=\"drink\"  type=\"radio\" value=\"Coke\" /> Coke\n\n        <span id=\"errors\">{{ errors }}</span>\n\n        <button>Submit</button>\n      </VForm>\n    `,\n  });\n\n  await flushPromises();\n  const errors = wrapper.$el.querySelector('#errors');\n  const button = wrapper.$el.querySelector('button');\n  const inputs = wrapper.$el.querySelectorAll('input');\n\n  wrapper.$el.querySelector('button').click();\n  await flushPromises();\n  expect(errors.textContent).toBeTruthy();\n  setChecked(inputs[1]);\n\n  await flushPromises();\n  button.click();\n  await flushPromises();\n  expect(spy).toHaveBeenLastCalledWith({ drink: 'Tea' });\n\n  showFields.value = false;\n  await flushPromises();\n  expect(errors.textContent).toBe('{}');\n  button.click();\n  await flushPromises();\n  expect(spy).toHaveBeenLastCalledWith({});\n});","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"unmounted radio fields gets unregistered and their values are removed if configured on the field level","suites":["<Form />"],"updatePoint":{"line":2999,"column":108},"line":2999,"code":"test('unmounted radio fields gets unregistered and their values are removed if configured on the field level', async () => {\n  const showFields = ref(true);\n\n  const wrapper = mountWithHoc({\n    setup() {\n      return {\n        showFields,\n      };\n    },\n    template: `\n      <VForm v-slot=\"{ errors, values }\" keep-values>\n        <template v-if=\"showFields\">\n          <Field name=\"drink\"  type=\"radio\" value=\"\" rules=\"required\" /> Coffee\n          <Field name=\"drink\"  type=\"radio\" value=\"Tea\" rules=\"required\" :keep-value=\"false\" /> Tea\n        </template>\n\n        <Field name=\"drink\"  type=\"radio\" value=\"Coke\" rules=\"required\" /> Coke\n\n        <span id=\"errors\">{{ errors }}</span>\n        <span id=\"values\">{{ values }}</span>\n\n        <button>Validate</button>\n      </VForm>\n    `,\n  });\n\n  await flushPromises();\n  const errors = wrapper.$el.querySelector('#errors');\n  const values = wrapper.$el.querySelector('#values');\n  const inputs = wrapper.$el.querySelectorAll('input');\n\n  wrapper.$el.querySelector('button').click();\n  await flushPromises();\n  expect(errors.textContent).toBeTruthy();\n  setChecked(inputs[1]);\n\n  await flushPromises();\n  expect(JSON.parse(values.textContent)).toEqual({\n    drink: 'Tea',\n  });\n\n  showFields.value = false;\n  await flushPromises();\n  // errors were cleared\n  expect(errors.textContent).toBe('{}');\n  expect(JSON.parse(values.textContent)).toEqual({});\n});","file":"Form.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"validates when value changes","suites":["useField()"],"updatePoint":{"line":8,"column":36},"line":8,"code":"  test('validates when value changes', async () => {\n    mountWithHoc({\n      setup() {\n        const { value, errorMessage } = useField('field', val => (val ? true : REQUIRED_MESSAGE));\n\n        return {\n          value,\n          errorMessage,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <span>{{ errorMessage }}</span>\n    `,\n    });\n\n    const input = document.querySelector('input');\n    const error = document.querySelector('span');\n\n    setValue(input as any, '');\n    await flushPromises();\n    expect(error?.textContent).toBe(REQUIRED_MESSAGE);\n  });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"validates when nested value changes","suites":["useField()"],"updatePoint":{"line":33,"column":43},"line":33,"code":"  test('validates when nested value changes', async () => {\n    mountWithHoc({\n      setup() {\n        const { value, errorMessage } = useField<any>(\n          'field',\n          val => {\n            if (!val?.name) {\n              return REQUIRED_MESSAGE;\n            }\n\n            return true;\n          },\n          {\n            initialValue: { name: 'test' },\n          }\n        );\n\n        onMounted(() => {\n          value.value.name = '';\n        });\n\n        return {\n          value,\n          errorMessage,\n        };\n      },\n      template: `\n      <span>{{ errorMessage }}</span>\n    `,\n    });\n\n    const error = document.querySelector('span');\n\n    await flushPromises();\n    expect(error?.textContent).toBe(REQUIRED_MESSAGE);\n  });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"valid flag is correct after reset","suites":["useField()"],"updatePoint":{"line":70,"column":41},"line":70,"code":"  test('valid flag is correct after reset', async () => {\n    mountWithHoc({\n      setup() {\n        const {\n          value: value1,\n          meta: meta1,\n          resetField: reset1,\n        } = useField('field', val => (val ? true : REQUIRED_MESSAGE));\n        const {\n          value: value2,\n          meta: meta2,\n          resetField: reset2,\n        } = useField('field', val => (!val || (val as string).length >= 3 ? true : MIN_MESSAGE));\n\n        return {\n          value1,\n          value2,\n          meta1,\n          meta2,\n          reset1,\n          reset2,\n        };\n      },\n      template: `\n      <input id=\"input1\" name=\"field\" v-model=\"value1\" />\n      <span id=\"meta1\">{{ meta1.valid ? 'valid' : 'invalid' }}</span>\n      <button id=\"r1\" @click=\"reset1()\">Reset</button>\n      <input id=\"input2\" name=\"field\" v-model=\"value2\" />\n      <span id=\"meta2\">{{ meta2.valid ? 'valid' : 'invalid' }}</span>\n      <button id=\"r2\" @click=\"reset2()\">Reset</button>\n    `,\n    });\n\n    const input1 = document.querySelector('#input1') as HTMLInputElement;\n    const meta1 = document.querySelector('#meta1');\n    const input2 = document.querySelector('#input2') as HTMLInputElement;\n    const meta2 = document.querySelector('#meta2');\n\n    await flushPromises();\n    expect(meta1?.textContent).toBe('invalid');\n    expect(meta2?.textContent).toBe('valid');\n\n    setValue(input1, '12');\n    setValue(input2, '12');\n    await flushPromises();\n    expect(meta1?.textContent).toBe('valid');\n    expect(meta2?.textContent).toBe('invalid');\n\n    // trigger reset\n    (document.querySelector('#r1') as HTMLButtonElement).click();\n    (document.querySelector('#r2') as HTMLButtonElement).click();\n    await flushPromises();\n    expect(meta1?.textContent).toBe('invalid');\n    expect(meta2?.textContent).toBe('valid');\n  });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"valid flag is synced with fields errors length","suites":["useField()"],"updatePoint":{"line":126,"column":54},"line":126,"code":"  test('valid flag is synced with fields errors length', async () => {\n    mountWithHoc({\n      setup() {\n        const { value, meta, resetField } = useField('field', val => (val ? true : REQUIRED_MESSAGE));\n\n        return {\n          value,\n          meta,\n          resetField,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <span id=\"meta\">{{ meta.valid ? 'valid' : 'invalid' }}</span>\n      <button @click=\"resetField({ errors: ['bad'] })\">Reset</button>\n    `,\n    });\n\n    await flushPromises();\n    const meta = document.querySelector('#meta');\n    const input = document.querySelector('input') as HTMLInputElement;\n\n    expect(meta?.textContent).toBe('invalid');\n\n    setValue(input, '12');\n    await flushPromises();\n    expect(meta?.textContent).toBe('valid');\n\n    // trigger reset\n    document.querySelector('button')?.click();\n    await flushPromises();\n    expect(meta?.textContent).toBe('invalid');\n  });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"dirty flag is false after reset","suites":["useField()"],"updatePoint":{"line":160,"column":39},"line":160,"code":"  test('dirty flag is false after reset', async () => {\n    mountWithHoc({\n      setup() {\n        const { value, meta, resetField } = useField('field', val => (val ? true : REQUIRED_MESSAGE));\n\n        return {\n          value,\n          meta,\n          resetField,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <span id=\"meta\">{{ meta.dirty ? 'dirty' : 'clean' }}</span>\n      <button @click=\"resetField()\">Reset</button>\n    `,\n    });\n\n    const input = document.querySelector('input') as HTMLInputElement;\n    const meta = document.querySelector('#meta');\n\n    await flushPromises();\n    expect(meta?.textContent).toBe('clean');\n\n    setValue(input, '');\n    await flushPromises();\n    expect(meta?.textContent).toBe('dirty');\n\n    // trigger reset\n    document.querySelector('button')?.click();\n    await flushPromises();\n    expect(meta?.textContent).toBe('clean');\n  });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"dirty flag is false after reset with a new value","suites":["useField()"],"updatePoint":{"line":194,"column":56},"line":194,"code":"  test('dirty flag is false after reset with a new value', async () => {\n    mountWithHoc({\n      setup() {\n        const { value, meta, resetField } = useField('field', val => (val ? true : REQUIRED_MESSAGE));\n\n        return {\n          value,\n          meta,\n          resetField,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <span id=\"meta\">{{ meta.dirty ? 'dirty' : 'clean' }}</span>\n      <button @click=\"resetField({ value: '12' })\">Reset</button>\n    `,\n    });\n\n    const input = document.querySelector('input') as HTMLInputElement;\n    const meta = document.querySelector('#meta');\n\n    await flushPromises();\n    expect(meta?.textContent).toBe('clean');\n\n    setValue(input, '');\n    await flushPromises();\n    expect(meta?.textContent).toBe('dirty');\n\n    // trigger reset\n    document.querySelector('button')?.click();\n    await flushPromises();\n    expect(meta?.textContent).toBe('clean');\n  });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"dirty flag is false after reset with a new value when a form is present","suites":["useField()"],"updatePoint":{"line":229,"column":79},"line":229,"code":"  test('dirty flag is false after reset with a new value when a form is present', async () => {\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { value, meta, resetField } = useField('field', val => (val ? true : REQUIRED_MESSAGE));\n\n        return {\n          value,\n          meta,\n          resetField,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <span id=\"meta\">{{ meta.dirty ? 'dirty' : 'clean' }}</span>\n      <button @click=\"resetField({ value: '12' })\">Reset</button>\n    `,\n    });\n\n    const input = document.querySelector('input') as HTMLInputElement;\n    const meta = document.querySelector('#meta');\n\n    await flushPromises();\n    expect(meta?.textContent).toBe('clean');\n\n    setValue(input, '');\n    await flushPromises();\n    expect(meta?.textContent).toBe('dirty');\n\n    // trigger reset\n    document.querySelector('button')?.click();\n    await flushPromises();\n    expect(meta?.textContent).toBe('clean');\n  });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"silent mode does not generate messages","suites":["useField()","has validation modes"],"updatePoint":{"line":265,"column":48},"line":265,"code":"    test('silent mode does not generate messages', async () => {\n      let validateFn!: ReturnType<typeof useField>['validate'];\n      mountWithHoc({\n        setup() {\n          const { errorMessage, validate } = useField('field', val => (val ? true : REQUIRED_MESSAGE));\n          validateFn = validate;\n\n          return {\n            errorMessage,\n          };\n        },\n        template: `\n      <span>{{ errorMessage }}</span>\n    `,\n      });\n      const error = document.querySelector('span');\n      expect(error?.textContent).toBe('');\n\n      // won't show any errors\n      await validateFn({ mode: 'silent' });\n      await flushPromises();\n      expect(error?.textContent).toBe('');\n    });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"validated-only mode only generates messages when it was validated before by user action","suites":["useField()","has validation modes"],"updatePoint":{"line":289,"column":97},"line":289,"code":"    test('validated-only mode only generates messages when it was validated before by user action', async () => {\n      let validateFn!: ReturnType<typeof useField>['validate'];\n      mountWithHoc({\n        setup() {\n          const { errorMessage, validate, value, setErrors } = useField('field', val =>\n            val ? true : REQUIRED_MESSAGE\n          );\n          validateFn = validate;\n          // marks it as dirty/touched\n          value.value = '';\n          onMounted(() => {\n            setErrors('');\n          });\n\n          return {\n            errorMessage,\n          };\n        },\n        template: `\n      <span>{{ errorMessage }}</span>\n    `,\n      });\n      const error = document.querySelector('span');\n      expect(error?.textContent).toBe('');\n\n      // won't show any errors\n      await validateFn({ mode: 'validated-only' });\n      await flushPromises();\n      expect(error?.textContent).toBe(REQUIRED_MESSAGE);\n    });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"force mode always generates new error messages","suites":["useField()","has validation modes"],"updatePoint":{"line":320,"column":56},"line":320,"code":"    test('force mode always generates new error messages', async () => {\n      let validateFn!: ReturnType<typeof useField>['validate'];\n      mountWithHoc({\n        setup() {\n          const { errorMessage, validate } = useField('field', val => (val ? true : REQUIRED_MESSAGE));\n          validateFn = validate;\n\n          return {\n            errorMessage,\n          };\n        },\n        template: `\n      <span>{{ errorMessage }}</span>\n    `,\n      });\n      const error = document.querySelector('span');\n      expect(error?.textContent).toBe('');\n\n      // won't show any errors\n      await validateFn({ mode: 'force' });\n      await flushPromises();\n      expect(error?.textContent).toBe(REQUIRED_MESSAGE);\n    });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"when bails is true","suites":["useField()","generic function chains"],"updatePoint":{"line":346,"column":28},"line":346,"code":"    test('when bails is true', async () => {\n      mountWithHoc({\n        setup() {\n          const {\n            value: value1,\n            meta: meta1,\n            errors: errors1,\n            resetField: reset1,\n          } = useField('field', [\n            val => (val ? true : REQUIRED_MESSAGE),\n            val => ((val as string)?.length >= 3 ? true : MIN_MESSAGE),\n          ]);\n          const {\n            value: value2,\n            meta: meta2,\n            errors: errors2,\n            resetField: reset2,\n          } = useField('field', [\n            val => ((val as string)?.length >= 3 ? true : MIN_MESSAGE),\n            val => (val ? true : REQUIRED_MESSAGE),\n          ]);\n\n          return {\n            value1,\n            value2,\n            meta1,\n            meta2,\n            errors1,\n            errors2,\n            reset1,\n            reset2,\n          };\n        },\n        template: `\n        <input id=\"input1\" name=\"field\" v-model=\"value1\" />\n        <span id=\"meta1\">{{ meta1.valid ? 'valid' : 'invalid' }}</span>\n        <span id=\"errors1\">{{ errors1.length }}</span>\n        <span v-for=\"(e, idx) in errors1\" :id=\"'errormessage1' + idx\">{{ e }}</span>\n        <button id=\"r1\" @click=\"reset1()\">Reset</button>\n        <input id=\"input2\" name=\"field\" v-model=\"value2\" />\n        <span id=\"meta2\">{{ meta2.valid ? 'valid' : 'invalid' }}</span>\n        <span id=\"errors2\">{{ errors2.length }}</span>\n        <span v-for=\"(e, idx) in errors2\" :id=\"'errormessage2' + idx\">{{ e }}</span>\n        <button id=\"r2\" @click=\"reset2()\">Reset</button>\n      `,\n      });\n\n      const input1 = document.querySelector('#input1') as HTMLInputElement;\n      const meta1 = document.querySelector('#meta1');\n      const errors1 = document.querySelector('#errors1');\n      const input2 = document.querySelector('#input2') as HTMLInputElement;\n      const meta2 = document.querySelector('#meta2');\n      const errors2 = document.querySelector('#errors2');\n\n      await flushPromises();\n\n      expect(meta1?.textContent).toBe('invalid');\n      expect(meta2?.textContent).toBe('invalid');\n      setValue(input1, '');\n      setValue(input2, '');\n\n      await flushPromises();\n\n      let errorMessage10 = document.querySelector('#errormessage10');\n      let errorMessage20 = document.querySelector('#errormessage20');\n\n      expect(meta1?.textContent).toBe('invalid');\n      expect(meta2?.textContent).toBe('invalid');\n      expect(errors1?.textContent).toBe('1');\n      expect(errors2?.textContent).toBe('1');\n      expect(errorMessage10?.textContent).toBe(REQUIRED_MESSAGE);\n      expect(errorMessage20?.textContent).toBe(MIN_MESSAGE);\n\n      setValue(input1, '12');\n      setValue(input2, '12');\n\n      await flushPromises();\n\n      errorMessage10 = document.querySelector('#errormessage10');\n      errorMessage20 = document.querySelector('#errormessage20');\n\n      expect(meta1?.textContent).toBe('invalid');\n      expect(meta2?.textContent).toBe('invalid');\n      expect(errors1?.textContent).toBe('1');\n      expect(errors2?.textContent).toBe('1');\n      expect(errorMessage10?.textContent).toBe(MIN_MESSAGE);\n      expect(errorMessage20?.textContent).toBe(MIN_MESSAGE);\n\n      setValue(input1, '123');\n      setValue(input2, '123');\n\n      await flushPromises();\n\n      expect(meta1?.textContent).toBe('valid');\n      expect(meta2?.textContent).toBe('valid');\n      expect(errors1?.textContent).toBe('0');\n      expect(errors2?.textContent).toBe('0');\n\n      // trigger reset\n      (document.querySelector('#r1') as HTMLButtonElement).click();\n      (document.querySelector('#r2') as HTMLButtonElement).click();\n      await flushPromises();\n      expect(meta1?.textContent).toBe('invalid');\n      expect(meta2?.textContent).toBe('invalid');\n    });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"when bails is false","suites":["useField()","generic function chains"],"updatePoint":{"line":452,"column":29},"line":452,"code":"    test('when bails is false', async () => {\n      mountWithHoc({\n        setup() {\n          const {\n            value: value1,\n            meta: meta1,\n            errors: errors1,\n            resetField: reset1,\n          } = useField(\n            'field',\n            [val => (val ? true : REQUIRED_MESSAGE), val => ((val as string)?.length >= 3 ? true : MIN_MESSAGE)],\n            { bails: false }\n          );\n          const {\n            value: value2,\n            meta: meta2,\n            errors: errors2,\n            resetField: reset2,\n          } = useField(\n            'field',\n            [val => ((val as string)?.length >= 3 ? true : MIN_MESSAGE), val => (val ? true : REQUIRED_MESSAGE)],\n            { bails: false }\n          );\n\n          return {\n            value1,\n            value2,\n            meta1,\n            meta2,\n            errors1,\n            errors2,\n            reset1,\n            reset2,\n          };\n        },\n        template: `\n        <input id=\"input1\" name=\"field\" v-model=\"value1\" />\n        <span id=\"meta1\">{{ meta1.valid ? 'valid' : 'invalid' }}</span>\n        <span id=\"errors1\">{{ errors1.length }}</span>\n        <span v-for=\"(e, idx) in errors1\" :id=\"'errormessage1' + idx\">{{ e }}</span>\n        <button id=\"r1\" @click=\"reset1()\">Reset</button>\n        <input id=\"input2\" name=\"field\" v-model=\"value2\" />\n        <span id=\"meta2\">{{ meta2.valid ? 'valid' : 'invalid' }}</span>\n        <span id=\"errors2\">{{ errors2.length }}</span>\n        <span v-for=\"(e, idx) in errors2\" :id=\"'errormessage2' + idx\">{{ e }}</span>\n        <button id=\"r2\" @click=\"reset2()\">Reset</button>\n      `,\n      });\n\n      const input1 = document.querySelector('#input1') as HTMLInputElement;\n      const meta1 = document.querySelector('#meta1');\n      const errors1 = document.querySelector('#errors1');\n      const input2 = document.querySelector('#input2') as HTMLInputElement;\n      const meta2 = document.querySelector('#meta2');\n      const errors2 = document.querySelector('#errors2');\n\n      await flushPromises();\n\n      expect(meta1?.textContent).toBe('invalid');\n      expect(meta2?.textContent).toBe('invalid');\n      setValue(input1, '');\n      setValue(input2, '');\n\n      await flushPromises();\n\n      let errorMessage10 = document.querySelector('#errormessage10');\n      const errorMessage11 = document.querySelector('#errormessage11');\n      let errorMessage20 = document.querySelector('#errormessage20');\n      const errorMessage21 = document.querySelector('#errormessage21');\n\n      expect(meta1?.textContent).toBe('invalid');\n      expect(meta2?.textContent).toBe('invalid');\n      expect(errors1?.textContent).toBe('2');\n      expect(errors2?.textContent).toBe('2');\n      expect(errorMessage10?.textContent).toBe(REQUIRED_MESSAGE);\n      expect(errorMessage11?.textContent).toBe(MIN_MESSAGE);\n      expect(errorMessage20?.textContent).toBe(MIN_MESSAGE);\n      expect(errorMessage21?.textContent).toBe(REQUIRED_MESSAGE);\n\n      setValue(input1, '12');\n      setValue(input2, '12');\n\n      await flushPromises();\n\n      errorMessage10 = document.querySelector('#errormessage10');\n      errorMessage20 = document.querySelector('#errormessage20');\n\n      expect(meta1?.textContent).toBe('invalid');\n      expect(meta2?.textContent).toBe('invalid');\n      expect(errors1?.textContent).toBe('1');\n      expect(errors2?.textContent).toBe('1');\n      expect(errorMessage10?.textContent).toBe(MIN_MESSAGE);\n      expect(errorMessage20?.textContent).toBe(MIN_MESSAGE);\n\n      setValue(input1, '123');\n      setValue(input2, '123');\n\n      await flushPromises();\n\n      expect(meta1?.textContent).toBe('valid');\n      expect(meta2?.textContent).toBe('valid');\n      expect(errors1?.textContent).toBe('0');\n      expect(errors2?.textContent).toBe('0');\n\n      // trigger reset\n      (document.querySelector('#r1') as HTMLButtonElement).click();\n      (document.querySelector('#r2') as HTMLButtonElement).click();\n      await flushPromises();\n      expect(meta1?.textContent).toBe('invalid');\n      expect(meta2?.textContent).toBe('invalid');\n    });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"emits model events for v-model support and syncing","suites":["useField()","generic function chains"],"updatePoint":{"line":565,"column":58},"line":565,"code":"  test('emits model events for v-model support and syncing', async () => {\n    const model = ref('');\n    const InputComponent = defineComponent({\n      props: {\n        modelValue: String,\n      },\n      setup() {\n        const { value, errorMessage } = useField('field');\n\n        return {\n          value,\n          errorMessage,\n        };\n      },\n      template: `\n        <input v-model=\"value\" />\n      `,\n    });\n\n    mountWithHoc({\n      components: {\n        InputComponent,\n      },\n      setup() {\n        return {\n          model,\n        };\n      },\n      template: `\n      <InputComponent v-model=\"model\" />\n    `,\n    });\n\n    const input = document.querySelector('input');\n\n    setValue(input as any, '123');\n    await flushPromises();\n    expect(model.value).toBe('123');\n    model.value = '321';\n    await flushPromises();\n    expect(input?.value).toBe('321');\n  });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"uses initial model value when sync v-model is set","suites":["useField()","generic function chains"],"updatePoint":{"line":608,"column":57},"line":608,"code":"  test('uses initial model value when sync v-model is set', async () => {\n    const model = ref('test');\n    const InputComponent = defineComponent({\n      props: {\n        modelValue: String,\n      },\n      setup() {\n        const { value, errorMessage } = useField('field');\n\n        return {\n          value,\n          errorMessage,\n        };\n      },\n      template: `\n        <input v-model=\"value\" />\n      `,\n    });\n\n    mountWithHoc({\n      components: {\n        InputComponent,\n      },\n      setup() {\n        return {\n          model,\n        };\n      },\n      template: `\n      <InputComponent v-model=\"model\" />\n    `,\n    });\n\n    const input = document.querySelector('input');\n\n    await flushPromises();\n    expect(model.value).toBe('test');\n    expect(input?.value).toBe('test');\n  });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can disable model events","suites":["useField()","generic function chains"],"updatePoint":{"line":648,"column":32},"line":648,"code":"  test('can disable model events', async () => {\n    const model = ref('');\n    const InputComponent = defineComponent({\n      props: {\n        modelValue: String,\n      },\n      setup() {\n        const { value, errorMessage } = useField('field', undefined, {\n          syncVModel: false,\n        });\n\n        return {\n          value,\n          errorMessage,\n        };\n      },\n      template: `\n        <input v-model=\"value\" />\n      `,\n    });\n\n    mountWithHoc({\n      components: {\n        InputComponent,\n      },\n      setup() {\n        return {\n          model,\n        };\n      },\n      template: `\n      <InputComponent v-model=\"model\" />\n    `,\n    });\n\n    const input = document.querySelector('input');\n\n    setValue(input as any, '123');\n    await flushPromises();\n    expect(model.value).toBe('');\n    model.value = '321';\n    await flushPromises();\n    expect(input?.value).toBe('123');\n  });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"emits model events for custom models support and syncing","suites":["useField()","generic function chains"],"updatePoint":{"line":693,"column":64},"line":693,"code":"  test('emits model events for custom models support and syncing', async () => {\n    const model = ref('');\n    const InputComponent = defineComponent({\n      props: {\n        textVal: String,\n      },\n      setup() {\n        const { value, errorMessage } = useField('field', undefined, {\n          modelPropName: 'textVal',\n        });\n\n        return {\n          value,\n          errorMessage,\n        };\n      },\n      template: `\n        <input v-model=\"value\" />\n      `,\n    });\n\n    mountWithHoc({\n      components: {\n        InputComponent,\n      },\n      setup() {\n        return {\n          model,\n        };\n      },\n      template: `\n      <InputComponent v-model:textVal=\"model\" />\n    `,\n    });\n\n    const input = document.querySelector('input');\n\n    setValue(input as any, '123');\n    await flushPromises();\n    expect(model.value).toBe('123');\n    model.value = '321';\n    await flushPromises();\n    expect(input?.value).toBe('321');\n  });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"only latest validation run messages are used","suites":["useField()","generic function chains"],"updatePoint":{"line":739,"column":52},"line":739,"code":"  test('only latest validation run messages are used', async () => {\n    function validator(value: string | undefined) {\n      if (!value) {\n        return true;\n      }\n\n      if (value.toLowerCase().startsWith('b')) {\n        return 'not b';\n      }\n\n      return new Promise<string | boolean>(resolve => {\n        setTimeout(() => {\n          if (value.toLowerCase().startsWith('a')) {\n            resolve('not a');\n            return;\n          }\n\n          resolve(true);\n        }, 100);\n      });\n    }\n\n    mountWithHoc({\n      setup() {\n        const { value, errorMessage } = useField<string>('field', validator);\n\n        return {\n          value,\n          errorMessage,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <span>{{ errorMessage }}</span>\n    `,\n    });\n\n    const input = document.querySelector('input');\n    const error = document.querySelector('span');\n\n    setValue(input as any, 'a');\n    await flushPromises();\n    setValue(input as any, 'b');\n    await flushPromises();\n    vi.advanceTimersByTime(200);\n    await flushPromises();\n    expect(error?.textContent).toBe('not b');\n  });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"allows explicit forms to be provided via the form option","suites":["useField()","generic function chains"],"updatePoint":{"line":788,"column":64},"line":788,"code":"  test('allows explicit forms to be provided via the form option', async () => {\n    let form1!: FormContext;\n    let form2!: FormContext;\n    let field1!: FieldContext;\n    let field2!: FieldContext;\n    mountWithHoc({\n      setup() {\n        form1 = useForm();\n        form2 = useForm();\n        field1 = useField('field', undefined, {\n          form: form1,\n        });\n        field2 = useField('field', undefined, {\n          form: form2,\n        });\n\n        return {};\n      },\n      template: `\n      <div></div>\n    `,\n    });\n\n    await flushPromises();\n    field1.value.value = '1';\n    field2.value.value = '2';\n    await flushPromises();\n\n    expect(form1.values.field).toBe('1');\n    expect(form2.values.field).toBe('2');\n  });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"allows lazy name expressions","suites":["useField()","generic function chains"],"updatePoint":{"line":820,"column":36},"line":820,"code":"  test('allows lazy name expressions', async () => {\n    const nameRef = ref('first');\n    mountWithHoc({\n      setup() {\n        const { name } = useField(() => nameRef.value);\n\n        return {\n          name,\n        };\n      },\n      template: `\n      <span>{{ name }}</span>\n    `,\n    });\n\n    const name = document.querySelector('span');\n\n    await flushPromises();\n    expect(name?.textContent).toBe('first');\n    nameRef.value = 'second';\n    await flushPromises();\n    expect(name?.textContent).toBe('second');\n  });","file":"useField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can update a field entry model directly","suites":[],"updatePoint":{"line":6,"column":45},"line":6,"code":"test('can update a field entry model directly', async () => {\n  mountWithHoc({\n    setup() {\n      useForm({\n        initialValues: {\n          users: ['1'],\n        },\n      });\n\n      const { fields } = useFieldArray('users');\n      onMounted(() => {\n        const item = fields.value[0];\n        item.value = 'test';\n      });\n\n      return {\n        fields,\n      };\n    },\n    template: `\n      <p>{{ fields[0].value }}</p>\n    `,\n  });\n\n  await flushPromises();\n  expect(document.querySelector('p')?.innerHTML).toBe('test');\n});","file":"useFieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can update a field entry deep model directly and validate it","suites":[],"updatePoint":{"line":34,"column":66},"line":34,"code":"test('can update a field entry deep model directly and validate it', async () => {\n  let fields!: Ref<FieldEntry<{ name: string }>[]>;\n  mountWithHoc({\n    setup() {\n      const { errors } = useForm({\n        validateOnMount: true,\n        validationSchema: yup.object({\n          users: yup.array().of(\n            yup.object({\n              name: yup.string().required(),\n            })\n          ),\n        }),\n        initialValues: {\n          users: [{ name: '' }],\n        },\n      });\n\n      fields = useFieldArray<{ name: string }>('users').fields;\n\n      return {\n        fields,\n        errors,\n      };\n    },\n    template: `\n      <p>{{ fields[0].value.name }}</p>\n      <span>{{ errors }}</span>\n    `,\n  });\n\n  await flushPromises();\n  expect(document.querySelector('p')?.innerHTML).toBe('');\n  expect(document.querySelector('span')?.innerHTML).toBeTruthy();\n\n  const item = fields.value[0];\n  item.value.name = 'test';\n\n  await flushPromises();\n  expect(document.querySelector('p')?.innerHTML).toBe('test');\n  expect(document.querySelector('span')?.innerHTML).toBe('{}');\n});","file":"useFieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"warns when updating a no-longer existing item","suites":[],"updatePoint":{"line":77,"column":51},"line":77,"code":"test('warns when updating a no-longer existing item', async () => {\n  const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n    // NOOP\n  });\n  mountWithHoc({\n    setup() {\n      useForm({\n        initialValues: {\n          users: ['1'],\n        },\n      });\n\n      const { remove, fields } = useFieldArray('users');\n      onMounted(() => {\n        const item = fields.value[0];\n        remove(0);\n        item.value = 'test';\n      });\n    },\n    template: `\n      <div></div>\n    `,\n  });\n\n  await flushPromises();\n\n  expect(spy).toHaveBeenCalled();\n  spy.mockRestore();\n});","file":"useFieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"duplicate calls yields the same instance","suites":[],"updatePoint":{"line":107,"column":46},"line":107,"code":"test('duplicate calls yields the same instance', async () => {\n  let removeFn!: (idx: number) => void;\n  mountWithHoc({\n    setup() {\n      useForm({\n        initialValues: {\n          users: ['one'],\n        },\n      });\n\n      const { fields, push } = useFieldArray('users');\n      const { fields: fields2, remove } = useFieldArray('users');\n\n      removeFn = remove;\n\n      onMounted(() => {\n        push('two');\n      });\n\n      return {\n        fields,\n        fields2,\n      };\n    },\n    template: `\n      <p id=\"arr1\">{{ fields.map(f => f.value).join(', ') }}</p>\n      <p id=\"arr2\">{{ fields2.map(f => f.value).join(', ') }}</p>\n    `,\n  });\n\n  await flushPromises();\n  expect(document.querySelector('#arr1')?.innerHTML).toBe('one, two');\n  expect(document.querySelector('#arr2')?.innerHTML).toBe('one, two');\n  removeFn(0);\n  await flushPromises();\n  expect(document.querySelector('#arr1')?.innerHTML).toBe('two');\n  expect(document.querySelector('#arr2')?.innerHTML).toBe('two');\n});","file":"useFieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"array push should trigger a silent validation","suites":[],"updatePoint":{"line":147,"column":51},"line":147,"code":"test('array push should trigger a silent validation', async () => {\n  let form!: FormContext;\n  let arr!: FieldArrayContext;\n  mountWithHoc({\n    setup() {\n      form = useForm<any>({\n        initialValues: {\n          users: ['one'],\n        },\n        validationSchema: yup.object({\n          users: yup.array().of(yup.string().required().min(1)),\n        }),\n      });\n\n      arr = useFieldArray('users');\n    },\n    template: `\n      <div></div>\n    `,\n  });\n\n  await flushPromises();\n  expect(form.meta.value.valid).toBe(true);\n  arr.push('');\n  await flushPromises();\n  expect(form.meta.value.valid).toBe(false);\n});","file":"useFieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"array prepend should trigger a silent validation","suites":[],"updatePoint":{"line":176,"column":54},"line":176,"code":"test('array prepend should trigger a silent validation', async () => {\n  let form!: FormContext;\n  let arr!: FieldArrayContext;\n  mountWithHoc({\n    setup() {\n      form = useForm<any>({\n        initialValues: {\n          users: ['one'],\n        },\n        validationSchema: yup.object({\n          users: yup.array().of(yup.string().required().min(1)),\n        }),\n      });\n\n      arr = useFieldArray('users');\n    },\n    template: `\n      <div></div>\n    `,\n  });\n\n  await flushPromises();\n  expect(form.meta.value.valid).toBe(true);\n  arr.prepend('');\n  await flushPromises();\n  expect(form.meta.value.valid).toBe(false);\n});","file":"useFieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"array insert should trigger a silent validation","suites":[],"updatePoint":{"line":205,"column":53},"line":205,"code":"test('array insert should trigger a silent validation', async () => {\n  let form!: FormContext;\n  let arr!: FieldArrayContext;\n  mountWithHoc({\n    setup() {\n      form = useForm<any>({\n        initialValues: {\n          users: ['one', 'two'],\n        },\n        validationSchema: yup.object({\n          users: yup.array().of(yup.string().required().min(1)),\n        }),\n      });\n\n      arr = useFieldArray('users');\n    },\n    template: `\n      <div></div>\n    `,\n  });\n\n  await flushPromises();\n  expect(form.meta.value.valid).toBe(true);\n  arr.insert(1, '');\n  await flushPromises();\n  expect(form.meta.value.valid).toBe(false);\n});","file":"useFieldArray.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"gives access to a single field error message","suites":["useFieldError()"],"updatePoint":{"line":9,"column":52},"line":9,"code":"  test('gives access to a single field error message', async () => {\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { value } = useField('test', validate);\n        const message = useFieldError('test');\n\n        return {\n          value,\n          message,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <span>{{ message }}</span>\n    `,\n    });\n    await flushPromises();\n\n    const input = document.querySelector('input');\n    const error = document.querySelector('span');\n    setValue(input as any, '');\n    await flushPromises();\n    expect(error?.textContent).toBe(REQUIRED_MESSAGE);\n  });","file":"useFieldError.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"gives access to a single field error message in a child component with specifying a path","suites":["useFieldError()"],"updatePoint":{"line":35,"column":96},"line":35,"code":"  test('gives access to a single field error message in a child component with specifying a path', async () => {\n    const CustomErrorComponent = defineComponent({\n      template: '<span>{{ message }}</span>',\n      setup() {\n        const message = useFieldError();\n\n        return {\n          message,\n        };\n      },\n    });\n    mountWithHoc({\n      components: {\n        CustomErrorComponent,\n      },\n      setup() {\n        useForm();\n        const { value } = useField('test', validate);\n\n        return {\n          value,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <CustomErrorComponent />\n    `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input');\n    const error = document.querySelector('span');\n    setValue(input as any, '');\n    await flushPromises();\n    expect(error?.textContent).toBe(REQUIRED_MESSAGE);\n  });","file":"useFieldError.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"gives access to array fields error message","suites":["useFieldError()"],"updatePoint":{"line":72,"column":50},"line":72,"code":"  test('gives access to array fields error message', async () => {\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { value } = useField('test', validate);\n        useField('test', validate);\n        const message = useFieldError('test');\n\n        return {\n          value,\n          message,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <span>{{ message }}</span>\n    `,\n    });\n    await flushPromises();\n\n    const input = document.querySelector('input');\n    const error = document.querySelector('span');\n    setValue(input as any, '');\n    await flushPromises();\n    expect(error?.textContent).toBe(REQUIRED_MESSAGE);\n  });","file":"useFieldError.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns undefined if field not found","suites":["useFieldError()"],"updatePoint":{"line":99,"column":44},"line":99,"code":"  test('returns undefined if field not found', async () => {\n    mountWithHoc({\n      setup() {\n        useForm();\n        const message = useFieldError('something');\n\n        return {\n          message,\n        };\n      },\n      template: `\n      <span>{{ message }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('');\n  });","file":"useFieldError.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns undefined if form is not found","suites":["useFieldError()"],"updatePoint":{"line":119,"column":46},"line":119,"code":"  test('returns undefined if form is not found', async () => {\n    mountWithHoc({\n      setup() {\n        const message = useFieldError('something');\n\n        return {\n          message,\n        };\n      },\n      template: `\n      <span>{{ message }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('');\n  });","file":"useFieldError.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"gives access to a single field value","suites":["useFieldValue()"],"updatePoint":{"line":9,"column":44},"line":9,"code":"  test('gives access to a single field value', async () => {\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { value, setValue } = useField('test', validate);\n        const currValue = useFieldValue('test');\n\n        return {\n          value,\n          currValue,\n          setValue,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <span>{{ currValue }}</span>\n      <button @click=\"setValue('5')\"></button>\n    `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input');\n    const valueSpan = document.querySelector('span');\n    const inputValue = '1234';\n    setValue(input as any, inputValue);\n    await flushPromises();\n    expect(valueSpan?.textContent).toBe(inputValue);\n\n    // test value setting\n    const btn = document.querySelector('button');\n    btn?.click();\n    await flushPromises();\n    expect(input?.value).toBe('5');\n  });","file":"useFieldValue.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"gives access to a single field value in a child component without specifying a path","suites":["useFieldValue()"],"updatePoint":{"line":44,"column":91},"line":44,"code":"  test('gives access to a single field value in a child component without specifying a path', async () => {\n    const CustomChildValueDisplay = defineComponent({\n      template: '<span>{{ value }}</span>',\n      setup() {\n        const value = useFieldValue();\n\n        return {\n          value,\n        };\n      },\n    });\n\n    mountWithHoc({\n      components: {\n        CustomChildValueDisplay,\n      },\n      setup() {\n        useForm();\n        const { value } = useField('test');\n\n        return {\n          value,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <CustomChildValueDisplay />\n    `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input');\n    const inputValue = '1234';\n    setValue(input as any, inputValue);\n    await flushPromises();\n    const valueSpan = document.querySelector('span');\n    expect(valueSpan?.textContent).toBe(inputValue);\n  });","file":"useFieldValue.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns undefined if field not found","suites":["useFieldValue()"],"updatePoint":{"line":83,"column":44},"line":83,"code":"  test('returns undefined if field not found', async () => {\n    mountWithHoc({\n      setup() {\n        useForm();\n        const value = useFieldValue('something');\n\n        return {\n          value,\n        };\n      },\n      template: `\n      <span>{{ value }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('');\n  });","file":"useFieldValue.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns undefined if form is not found","suites":["useFieldValue()"],"updatePoint":{"line":103,"column":46},"line":103,"code":"  test('returns undefined if form is not found', async () => {\n    mountWithHoc({\n      setup() {\n        const value = useFieldValue('something');\n\n        return {\n          value,\n        };\n      },\n      template: `\n      <span>{{ value }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('');\n  });","file":"useFieldValue.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"sets individual field error message","suites":["useForm()"],"updatePoint":{"line":9,"column":43},"line":9,"code":"  test('sets individual field error message', async () => {\n    mountWithHoc({\n      setup() {\n        const { setFieldError } = useForm();\n        const { errorMessage } = useField('field', val => (val ? true : REQUIRED_MESSAGE));\n\n        return {\n          errorMessage,\n          setFieldError,\n        };\n      },\n      template: `\n      <span>{{ errorMessage }}</span>\n      <button @click=\"setFieldError('field', 'WRONG')\">Set Field Error</button>\n    `,\n    });\n\n    const error = document.querySelector('span');\n    await flushPromises();\n    expect(error?.textContent).toBe('');\n    document.querySelector('button')?.click();\n    await flushPromises();\n    expect(error?.textContent).toBe('WRONG');\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"can clear individual field error messages","suites":["useForm()"],"updatePoint":{"line":34,"column":49},"line":34,"code":"  test('can clear individual field error messages', async () => {\n    let setFieldError!: FormContext['setFieldError'];\n    mountWithHoc({\n      setup() {\n        const form = useForm();\n        setFieldError = form.setFieldError;\n        const { errorMessage } = useField('field', val => (val ? true : REQUIRED_MESSAGE));\n\n        return {\n          errorMessage,\n          setFieldError,\n        };\n      },\n      template: `\n      <span>{{ errorMessage }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const error = document.querySelector('span');\n    setFieldError('field', 'WRONG');\n    await flushPromises();\n    expect(error?.textContent).toBe('WRONG');\n    setFieldError('field', undefined);\n    await flushPromises();\n    expect(error?.textContent).toBe('');\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"sets multiple field error messages","suites":["useForm()"],"updatePoint":{"line":62,"column":42},"line":62,"code":"  test('sets multiple field error messages', async () => {\n    mountWithHoc({\n      setup() {\n        const { setErrors } = useForm();\n        const { errorMessage: err1 } = useField('field1', val => (val ? true : REQUIRED_MESSAGE));\n        const { errorMessage: err2 } = useField('field2', val => (val ? true : REQUIRED_MESSAGE));\n\n        return {\n          err1,\n          err2,\n          setErrors,\n        };\n      },\n      template: `\n      <span>{{ err1 }}</span>\n      <span>{{ err2 }}</span>\n      <button @click=\"setErrors({ field1: 'WRONG', field2: 'WRONG AGAIN', field3: 'huh' })\">Set Field Error</button>\n    `,\n    });\n\n    const errors = document.querySelectorAll('span');\n    await flushPromises();\n    expect(errors[0]?.textContent).toBe('');\n    expect(errors[1]?.textContent).toBe('');\n    document.querySelector('button')?.click();\n    await flushPromises();\n    expect(errors[0]?.textContent).toBe('WRONG');\n    expect(errors[1]?.textContent).toBe('WRONG AGAIN');\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"sets individual field touched meta","suites":["useForm()"],"updatePoint":{"line":92,"column":42},"line":92,"code":"  test('sets individual field touched meta', async () => {\n    mountWithHoc({\n      setup() {\n        const { setFieldTouched, meta: formMeta } = useForm();\n        const { meta } = useField('field', val => (val ? true : REQUIRED_MESSAGE));\n\n        return {\n          meta,\n          formMeta,\n          setFieldTouched,\n        };\n      },\n      template: `\n      <span id=\"field\">{{ meta.touched }}</span>\n      <span id=\"form\">{{ formMeta.touched }}</span>\n      <button @click=\"setFieldTouched('field', true)\">Set Meta</button>\n    `,\n    });\n\n    const fieldMeta = document.querySelector('#field');\n    const formMeta = document.querySelector('#form');\n    await flushPromises();\n    expect(fieldMeta?.textContent).toBe('false');\n    expect(formMeta?.textContent).toBe('false');\n    document.querySelector('button')?.click();\n    await flushPromises();\n    expect(fieldMeta?.textContent).toBe('true');\n    expect(formMeta?.textContent).toBe('true');\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"sets multiple fields touched meta","suites":["useForm()"],"updatePoint":{"line":122,"column":41},"line":122,"code":"  test('sets multiple fields touched meta', async () => {\n    mountWithHoc({\n      setup() {\n        const { setTouched, meta: formMeta } = useForm();\n        const { meta: meta1 } = useField('field1', val => (val ? true : REQUIRED_MESSAGE));\n        const { meta: meta2 } = useField('field2', val => (val ? true : REQUIRED_MESSAGE));\n\n        return {\n          meta1,\n          meta2,\n          formMeta,\n          setTouched,\n        };\n      },\n      template: `\n      <span>{{ meta1.touched }}</span>\n      <span>{{ meta2.touched }}</span>\n      <span>{{ formMeta.touched }}</span>\n      <button @click=\"setTouched({ field1: true, field2: false, field3: false })\">Set Meta</button>\n    `,\n    });\n\n    const meta = document.querySelectorAll('span');\n\n    await flushPromises();\n    expect(meta[0]?.textContent).toBe('false');\n    expect(meta[1]?.textContent).toBe('false');\n    expect(meta[2]?.textContent).toBe('false');\n    document.querySelector('button')?.click();\n    await flushPromises();\n    expect(meta[0]?.textContent).toBe('true');\n    expect(meta[1]?.textContent).toBe('false');\n    expect(meta[2]?.textContent).toBe('true');\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"has a validate() method that returns an aggregate of validation results using field rules","suites":["useForm()"],"updatePoint":{"line":157,"column":97},"line":157,"code":"  test('has a validate() method that returns an aggregate of validation results using field rules', async () => {\n    let validate: any;\n    mountWithHoc({\n      setup() {\n        const form = useForm();\n        validate = form.validate;\n        useField('field1', val => (val ? true : REQUIRED_MESSAGE));\n        useField('field2', val => (val ? true : REQUIRED_MESSAGE));\n\n        return {};\n      },\n      template: `<div></div>`,\n    });\n\n    await flushPromises();\n    const result = await validate();\n    expect(result).toEqual({\n      valid: false,\n      errors: {\n        field1: REQUIRED_MESSAGE,\n        field2: REQUIRED_MESSAGE,\n      },\n      results: {\n        field1: {\n          valid: false,\n          errors: [REQUIRED_MESSAGE],\n        },\n        field2: {\n          valid: false,\n          errors: [REQUIRED_MESSAGE],\n        },\n      },\n    });\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"has a validate method that returns an aggregate of validation results using validation schema","suites":["useForm()"],"updatePoint":{"line":192,"column":101},"line":192,"code":"  test('has a validate method that returns an aggregate of validation results using validation schema', async () => {\n    let validate: any;\n    mountWithHoc({\n      setup() {\n        const form = useForm({\n          validationSchema: yup.object({\n            field1: yup.string().required(REQUIRED_MESSAGE),\n            field2: yup.string().required(REQUIRED_MESSAGE),\n          }),\n        });\n\n        validate = form.validate;\n        useField('field1');\n        useField('field2');\n\n        return {};\n      },\n      template: `<div></div>`,\n    });\n\n    await flushPromises();\n    const pending = validate();\n    await flushPromises();\n    const result = await pending;\n    expect(result).toEqual({\n      valid: false,\n      errors: {\n        field1: REQUIRED_MESSAGE,\n        field2: REQUIRED_MESSAGE,\n      },\n      results: {\n        field1: {\n          valid: false,\n          errors: [REQUIRED_MESSAGE],\n        },\n        field2: {\n          valid: false,\n          errors: [REQUIRED_MESSAGE],\n        },\n      },\n    });\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"has a validateField() method that validates a specific field","suites":["useForm()"],"updatePoint":{"line":235,"column":68},"line":235,"code":"  test('has a validateField() method that validates a specific field', async () => {\n    let validateField: any;\n    mountWithHoc({\n      setup() {\n        const form = useForm();\n        validateField = form.validateField;\n        const { errorMessage: f1 } = useField('field1', val => (val ? true : REQUIRED_MESSAGE));\n        const { errorMessage: f2 } = useField('field2', val => (val ? true : REQUIRED_MESSAGE));\n\n        return { f1, f2 };\n      },\n      template: `<div>\n        <span id=\"f1\">{{ f1 }}</span>\n        <span id=\"f2\">{{ f2 }}</span>\n      </div>`,\n    });\n\n    await flushPromises();\n    const result = await validateField('field2');\n    expect(result).toEqual({\n      valid: false,\n      errors: [REQUIRED_MESSAGE],\n    });\n\n    expect(document.querySelector('#f2')?.textContent).toBe(REQUIRED_MESSAGE);\n    expect(document.querySelector('#f1')?.textContent).toBe('');\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"warns when validateField() is called on a non-existent field","suites":["useForm()"],"updatePoint":{"line":263,"column":68},"line":263,"code":"  test('warns when validateField() is called on a non-existent field', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n\n    let validateField: any;\n    mountWithHoc({\n      setup() {\n        const form = useForm();\n        validateField = form.validateField;\n\n        return {};\n      },\n      template: `<div></div>`,\n    });\n\n    await flushPromises();\n    const result = await validateField('field2');\n    expect(result).toEqual({\n      valid: true,\n      errors: [],\n    });\n\n    expect(spy).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"resets the meta valid state on reset","suites":["useForm()"],"updatePoint":{"line":290,"column":44},"line":290,"code":"  test('resets the meta valid state on reset', async () => {\n    let passwordValue!: Ref<string>;\n    mountWithHoc({\n      setup() {\n        const { meta: formMeta, resetForm, errors } = useForm();\n        const { value } = useField('field', val => (val ? true : REQUIRED_MESSAGE));\n        const { value: pwValue } = useField<string>('password', val => (val ? true : REQUIRED_MESSAGE));\n        passwordValue = pwValue;\n\n        return {\n          value,\n          formMeta,\n          resetForm,\n          errors,\n        };\n      },\n      template: `\n      <input v-model=\"value\" />\n      <span id=\"meta\">{{ formMeta.valid ? 'valid': 'invalid' }}</span>\n      <span id=\"errors\">{{ errors }}</span>\n      <button @click=\"resetForm()\">Reset Meta</button>\n    `,\n    });\n\n    await flushPromises();\n    const span = document.querySelector('#meta');\n    const errors = document.querySelector('#errors');\n    const input = document.querySelector('input') as HTMLInputElement;\n    expect(span?.textContent).toBe('invalid');\n    setValue(input, '12');\n    await flushPromises();\n    // still other field is invalid\n    expect(span?.textContent).toBe('invalid');\n    // but the error is silent so errors should be empty\n    expect(errors?.textContent).toBe('{}');\n\n    passwordValue.value = '12';\n    await flushPromises();\n    // now both should be valid\n    expect(span?.textContent).toBe('valid');\n    expect(errors?.textContent).toBe('{}');\n\n    document.querySelector('button')?.click();\n    await flushPromises();\n    // validation was run again silently\n    expect(span?.textContent).toBe('invalid');\n    expect(errors?.textContent).toBe('{}');\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"resets the meta valid state on reset with the errors length","suites":["useForm()"],"updatePoint":{"line":339,"column":67},"line":339,"code":"  test('resets the meta valid state on reset with the errors length', async () => {\n    mountWithHoc({\n      setup() {\n        const { meta: formMeta, resetForm } = useForm();\n        const { value } = useField('field', val => (val ? true : REQUIRED_MESSAGE));\n\n        return {\n          value,\n          formMeta,\n          resetForm,\n        };\n      },\n      template: `\n      <input v-model=\"value\" />\n      <span id=\"meta\">{{ formMeta.valid ? 'valid': 'invalid' }}</span>\n      <button @click=\"resetForm({ errors: { field: 'test' } })\">Reset Meta</button>\n    `,\n    });\n\n    await flushPromises();\n    const span = document.querySelector('#meta');\n    expect(span?.textContent).toBe('invalid');\n\n    const input = document.querySelector('input') as HTMLInputElement;\n    setValue(input, '12');\n    await flushPromises();\n    expect(span?.textContent).toBe('valid');\n\n    document.querySelector('button')?.click();\n    await flushPromises();\n    expect(span?.textContent).toBe('invalid');\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"resets the meta dirty on reset","suites":["useForm()"],"updatePoint":{"line":372,"column":38},"line":372,"code":"  test('resets the meta dirty on reset', async () => {\n    mountWithHoc({\n      setup() {\n        const { meta: formMeta, resetForm } = useForm();\n        const { meta: meta1, value } = useField('field1', val => (val ? true : REQUIRED_MESSAGE));\n        const { meta: meta2 } = useField('field2', val => (val ? true : REQUIRED_MESSAGE));\n\n        return {\n          meta1,\n          meta2,\n          formMeta,\n          resetForm,\n          value,\n        };\n      },\n      template: `\n      <input v-model=\"value\">\n      <span>{{ meta1.dirty }}</span>\n      <span>{{ meta2.dirty }}</span>\n      <span>{{ formMeta.dirty }}</span>\n      <button @click=\"resetForm()\">Reset</button>\n    `,\n    });\n\n    const meta = document.querySelectorAll('span');\n    const input = document.querySelector('input') as HTMLInputElement;\n\n    await flushPromises();\n    expect(meta[0]?.textContent).toBe('false');\n    expect(meta[1]?.textContent).toBe('false');\n    expect(meta[2]?.textContent).toBe('false');\n\n    setValue(input, '1');\n    await flushPromises();\n    expect(meta[0]?.textContent).toBe('true');\n    expect(meta[1]?.textContent).toBe('false');\n    expect(meta[2]?.textContent).toBe('true');\n\n    document.querySelector('button')?.click();\n    await flushPromises();\n    expect(meta[0]?.textContent).toBe('false');\n    expect(meta[1]?.textContent).toBe('false');\n    expect(meta[2]?.textContent).toBe('false');\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"Creates a writeable model for a field path","suites":["useForm()"],"updatePoint":{"line":417,"column":50},"line":417,"code":"  test('Creates a writeable model for a field path', async () => {\n    await runInSetup(() => {\n      const { values, useFieldModel } = useForm({\n        initialValues: {\n          greet: 'hey',\n          age: 1,\n        },\n      });\n      const greet = useFieldModel('greet');\n      const age = useFieldModel('age');\n\n      expect(values.greet).toBe('hey');\n      expect(values.age).toBe(1);\n      greet.value = 'hello';\n      age.value = 2;\n      expect(values.greet).toBe('hello');\n      expect(values.age).toBe(2);\n    });\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"Creates multiple writeable models for given field paths","suites":["useForm()"],"updatePoint":{"line":437,"column":63},"line":437,"code":"  test('Creates multiple writeable models for given field paths', async () => {\n    await runInSetup(() => {\n      const { values, useFieldModel } = useForm({\n        initialValues: {\n          greet: 'hey',\n          age: 1,\n        },\n      });\n\n      const [age, greet] = useFieldModel(['age', 'greet']);\n\n      expect(values.greet).toBe('hey');\n      expect(values.age).toBe(1);\n      greet.value = 'hello';\n      age.value = 2;\n      expect(values.greet).toBe('hello');\n      expect(values.age).toBe(2);\n    });\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"only latest schema validation run messages are used","suites":["useForm()"],"updatePoint":{"line":458,"column":59},"line":458,"code":"  test('only latest schema validation run messages are used', async () => {\n    function validator(value: string | undefined) {\n      if (!value) {\n        return true;\n      }\n\n      if (value.toLowerCase().startsWith('b')) {\n        return 'not b';\n      }\n\n      return new Promise<string | boolean>(resolve => {\n        setTimeout(() => {\n          if (value.toLowerCase().startsWith('a')) {\n            resolve('not a');\n            return;\n          }\n\n          resolve(true);\n        }, 100);\n      });\n    }\n\n    mountWithHoc({\n      setup() {\n        const { errors, useFieldModel } = useForm({\n          validationSchema: {\n            test: validator,\n          },\n        });\n        const model = useFieldModel('test');\n\n        return {\n          model,\n          errors,\n        };\n      },\n      template: `\n        <input name=\"field\" v-model=\"model\" />\n        <span>{{ errors.test }}</span>\n      `,\n    });\n\n    await flushPromises();\n\n    const input = document.querySelector('input');\n    const error = document.querySelector('span');\n\n    setValue(input as any, 'a');\n    await flushPromises();\n    setValue(input as any, 'b');\n    await flushPromises();\n    vi.advanceTimersByTime(200);\n    await flushPromises();\n    expect(error?.textContent).toBe('not b');\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"exposes controlled only values","suites":["useForm()"],"updatePoint":{"line":515,"column":38},"line":515,"code":"  test('exposes controlled only values', async () => {\n    const spy = vi.fn();\n    const initial = {\n      field: '111',\n      createdAt: Date.now(),\n    };\n    mountWithHoc({\n      setup() {\n        const { controlledValues, handleSubmit } = useForm({\n          initialValues: initial,\n        });\n\n        const onSubmit = handleSubmit(values => {\n          spy({ values, controlled: controlledValues.value });\n        });\n\n        useField('field');\n\n        onMounted(onSubmit);\n\n        return {};\n      },\n      template: `\n        <div></div>\n      `,\n    });\n\n    await flushPromises();\n    expect(spy).toHaveBeenCalledTimes(1);\n    expect(spy).toHaveBeenLastCalledWith(\n      expect.objectContaining({\n        values: initial,\n        controlled: { field: initial.field },\n      })\n    );\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"exposes controlled only via submission handler withControlled","suites":["useForm()"],"updatePoint":{"line":553,"column":69},"line":553,"code":"  test('exposes controlled only via submission handler withControlled', async () => {\n    const spy = vi.fn();\n    const initial = {\n      field: '111',\n      createdAt: Date.now(),\n    };\n    mountWithHoc({\n      setup() {\n        const { handleSubmit } = useForm({\n          initialValues: initial,\n        });\n\n        const onSubmit = handleSubmit.withControlled(values => {\n          spy({ values });\n        });\n\n        useField('field');\n\n        onMounted(onSubmit);\n\n        return {};\n      },\n      template: `\n        <div></div>\n      `,\n    });\n\n    await flushPromises();\n    expect(spy).toHaveBeenCalledTimes(1);\n    expect(spy).toHaveBeenLastCalledWith(\n      expect.objectContaining({\n        values: { field: initial.field },\n      })\n    );\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"useFieldModel marks the field as controlled","suites":["useForm()"],"updatePoint":{"line":589,"column":51},"line":589,"code":"  test('useFieldModel marks the field as controlled', async () => {\n    const spy = vi.fn();\n    const initial = {\n      field: '111',\n      field2: '222',\n      createdAt: Date.now(),\n    };\n    mountWithHoc({\n      setup() {\n        const { handleSubmit, useFieldModel } = useForm({\n          initialValues: initial,\n        });\n\n        const onSubmit = handleSubmit.withControlled(values => {\n          spy({ values });\n        });\n\n        const fields = useFieldModel(['field', 'field2']);\n\n        onMounted(onSubmit);\n\n        return {};\n      },\n      template: `\n        <div></div>\n      `,\n    });\n\n    await flushPromises();\n    expect(spy).toHaveBeenCalledTimes(1);\n    expect(spy).toHaveBeenLastCalledWith(\n      expect.objectContaining({\n        values: { field: initial.field, field2: initial.field2 },\n      })\n    );\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"fields validated meta should not be mutated when silently validating fields","suites":["useForm()"],"updatePoint":{"line":627,"column":83},"line":627,"code":"  test('fields validated meta should not be mutated when silently validating fields', async () => {\n    let meta!: FieldMeta<any>;\n\n    mountWithHoc({\n      setup() {\n        const { validate } = useForm({\n          validationSchema: yup.object({\n            name: yup.string().required(),\n          }),\n        });\n\n        const field = useField('name');\n        meta = field.meta;\n\n        onMounted(() => {\n          validate({ mode: 'silent' });\n          validate({ mode: 'validated-only' });\n        });\n\n        return {};\n      },\n      template: `\n        <div></div>\n      `,\n    });\n\n    await flushPromises();\n    expect(meta.validated).toBe(false);\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"initial value should not be mutable if nested field model is used","suites":["useForm()"],"updatePoint":{"line":658,"column":73},"line":658,"code":"  test('initial value should not be mutable if nested field model is used', async () => {\n    let model!: Ref<{ name: string }>;\n    let formMeta!: Ref<FormMeta<{ field: { name: string } }>>;\n    let reset!: () => void;\n\n    mountWithHoc({\n      setup() {\n        const { meta, resetForm } = useForm({\n          initialValues: { field: { name: '1' } },\n          validationSchema: yup.object({\n            name: yup.string().required(),\n          }),\n        });\n\n        const field = useField<{ name: string }>('field');\n        model = field.value;\n        formMeta = meta;\n        reset = resetForm;\n\n        return {};\n      },\n      template: `\n        <div></div>\n      `,\n    });\n\n    await flushPromises();\n    expect(formMeta.value.initialValues?.field?.name).toBe('1');\n    model.value.name = 'test';\n    await flushPromises();\n    expect(model.value).toEqual({ name: 'test' });\n    expect(formMeta.value.initialValues?.field?.name).toBe('1');\n    reset();\n    await flushPromises();\n    expect(model.value).toEqual({ name: '1' });\n    expect(formMeta.value.initialValues?.field?.name).toBe('1');\n\n    model.value.name = 'test';\n    await flushPromises();\n    expect(model.value).toEqual({ name: 'test' });\n    expect(formMeta.value.initialValues?.field?.name).toBe('1');\n  });","file":"useForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"gives access to all form errors","suites":["useFormErrors()"],"updatePoint":{"line":8,"column":39},"line":8,"code":"  test('gives access to all form errors', async () => {\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { value } = useField('test', validate);\n        const messages = useFormErrors();\n\n        return {\n          value,\n          messages,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <span>{{ messages.test }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input');\n    const error = document.querySelector('span');\n    setValue(input as any, '');\n    await flushPromises();\n    expect(error?.textContent).toBe(REQUIRED_MESSAGE);\n  });","file":"useFormErrors.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns empty object and warns if form is not found","suites":["useFormErrors()"],"updatePoint":{"line":34,"column":59},"line":34,"code":"  test('returns empty object and warns if form is not found', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n\n    mountWithHoc({\n      setup() {\n        const messages = useFormErrors();\n\n        return {\n          messages,\n        };\n      },\n      template: `\n      <span>{{ messages }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('{}');\n    expect(spy).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useFormErrors.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"gives access to all form values","suites":["useFormValues()"],"updatePoint":{"line":8,"column":39},"line":8,"code":"  test('gives access to all form values', async () => {\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { value } = useField('test', validate);\n        const values = useFormValues();\n\n        return {\n          value,\n          values,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <span>{{ values.test }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input');\n    const valueSpan = document.querySelector('span');\n    const inputValue = '1234';\n    setValue(input as any, inputValue);\n    await flushPromises();\n    expect(valueSpan?.textContent).toBe(inputValue);\n  });","file":"useFormValues.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns empty object and warns if form is not found","suites":["useFormValues()"],"updatePoint":{"line":35,"column":59},"line":35,"code":"  test('returns empty object and warns if form is not found', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n\n    mountWithHoc({\n      setup() {\n        const values = useFormValues();\n\n        return {\n          values,\n        };\n      },\n      template: `\n      <span>{{ values }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const valuesSpan = document.querySelector('span');\n    expect(valuesSpan?.textContent).toBe('{}');\n    expect(spy).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useFormValues.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"gives access to a single field isDirty status","suites":["useIsFieldDirty()"],"updatePoint":{"line":6,"column":53},"line":6,"code":"  test('gives access to a single field isDirty status', async () => {\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { value, handleChange } = useField('test');\n        const isDirty = useIsFieldDirty('test');\n\n        return {\n          value,\n          isDirty,\n          handleInput: (e: any) => handleChange(e, false),\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" @input=\"handleInput\" />\n      <span>{{ isDirty.toString() }}</span>\n    `,\n    });\n    await flushPromises();\n\n    const input = document.querySelector('input');\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('false');\n\n    setValue(input as any, '');\n    await flushPromises();\n    expect(error?.textContent).toBe('true');\n  });","file":"useIsFieldDirty.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"gives access to a single field isDirty status in a child component without specifying a path","suites":["useIsFieldDirty()"],"updatePoint":{"line":35,"column":100},"line":35,"code":"  test('gives access to a single field isDirty status in a child component without specifying a path', async () => {\n    const DirtyIcon = defineComponent({\n      template: '<span>{{ isDirty.toString() }}</span>',\n      setup() {\n        const isDirty = useIsFieldDirty();\n\n        return {\n          isDirty,\n        };\n      },\n    });\n    mountWithHoc({\n      components: {\n        DirtyIcon,\n      },\n      setup() {\n        useForm();\n        const { value, handleChange } = useField('test');\n\n        return {\n          value,\n          handleInput: (e: any) => handleChange(e, false),\n        };\n      },\n      template: `\n        <input name=\"field\" v-model=\"value\" @input=\"handleInput\" />\n        <DirtyIcon />\n      `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input');\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('false');\n\n    setValue(input as any, '');\n    await flushPromises();\n    expect(error?.textContent).toBe('true');\n  });","file":"useIsFieldDirty.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"gives access to array fields isDirty status","suites":["useIsFieldDirty()"],"updatePoint":{"line":75,"column":51},"line":75,"code":"  test('gives access to array fields isDirty status', async () => {\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { value, handleChange } = useField('test');\n        useField('test');\n        const isDirty = useIsFieldDirty('test');\n\n        return {\n          value,\n          isDirty,\n          handleInput: (e: any) => handleChange(e, false),\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" @input=\"handleInput\" />\n      <span>{{ isDirty.toString() }}</span>\n    `,\n    });\n    await flushPromises();\n\n    const input = document.querySelector('input');\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('false');\n\n    setValue(input as any, '');\n    await flushPromises();\n    expect(error?.textContent).toBe('true');\n  });","file":"useIsFieldDirty.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns false and warns if field does not exist","suites":["useIsFieldDirty()"],"updatePoint":{"line":105,"column":55},"line":105,"code":"  test('returns false and warns if field does not exist', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n\n    mountWithHoc({\n      setup() {\n        useForm();\n        const isDirty = useIsFieldDirty('something');\n\n        return {\n          isDirty,\n        };\n      },\n      template: `\n      <span>{{ isDirty.toString() }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('false');\n    expect(spy).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useIsFieldDirty.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns false and warns if form does not exist","suites":["useIsFieldDirty()"],"updatePoint":{"line":131,"column":54},"line":131,"code":"  test('returns false and warns if form does not exist', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n\n    mountWithHoc({\n      setup() {\n        const isDirty = useIsFieldDirty('something');\n\n        return {\n          isDirty,\n        };\n      },\n      template: `\n      <span>{{ isDirty.toString() }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('false');\n    expect(spy).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useIsFieldDirty.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"gives access to a single field isTouched status","suites":["useIsFieldTouched()"],"updatePoint":{"line":6,"column":55},"line":6,"code":"  test('gives access to a single field isTouched status', async () => {\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { value, handleBlur } = useField('test');\n        const isTouched = useIsFieldTouched('test');\n\n        return {\n          value,\n          isTouched,\n          handleBlur,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" @blur=\"handleBlur\" />\n      <span>{{ isTouched.toString() }}</span>\n    `,\n    });\n    await flushPromises();\n\n    const input = document.querySelector('input');\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('false');\n\n    dispatchEvent(input as any, 'blur');\n\n    await flushPromises();\n    expect(error?.textContent).toBe('true');\n  });","file":"useIsFieldTouched.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"gives access to a single field isTouched status in child components without path prop","suites":["useIsFieldTouched()"],"updatePoint":{"line":36,"column":93},"line":36,"code":"  test('gives access to a single field isTouched status in child components without path prop', async () => {\n    const TouchedIcon = defineComponent({\n      template: '<span>{{ isTouched.toString() }}</span>',\n      setup() {\n        const isTouched = useIsFieldTouched();\n\n        return {\n          isTouched,\n        };\n      },\n    });\n    mountWithHoc({\n      components: {\n        TouchedIcon,\n      },\n      setup() {\n        useForm();\n        const { value, handleBlur } = useField('test');\n\n        return {\n          value,\n          handleBlur,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" @blur=\"handleBlur\" />\n      <TouchedIcon />\n    `,\n    });\n    await flushPromises();\n\n    const input = document.querySelector('input');\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('false');\n\n    dispatchEvent(input as any, 'blur');\n\n    await flushPromises();\n    expect(error?.textContent).toBe('true');\n  });","file":"useIsFieldTouched.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"gives access to array fields isTouched status","suites":["useIsFieldTouched()"],"updatePoint":{"line":77,"column":53},"line":77,"code":"  test('gives access to array fields isTouched status', async () => {\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { value, handleBlur } = useField('test', undefined, { type: 'checkbox' });\n        useField('test', undefined, { type: 'checkbox' });\n        const isTouched = useIsFieldTouched('test');\n\n        return {\n          value,\n          isTouched,\n          handleBlur,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" @blur=\"handleBlur\" />\n      <span>{{ isTouched.toString() }}</span>\n    `,\n    });\n    await flushPromises();\n\n    const input = document.querySelector('input');\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('false');\n\n    dispatchEvent(input as any, 'blur');\n\n    await flushPromises();\n    expect(error?.textContent).toBe('true');\n  });","file":"useIsFieldTouched.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns false and warns if field does not exist","suites":["useIsFieldTouched()"],"updatePoint":{"line":108,"column":55},"line":108,"code":"  test('returns false and warns if field does not exist', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n\n    mountWithHoc({\n      setup() {\n        useForm();\n        const isTouched = useIsFieldTouched('something');\n\n        return {\n          isTouched,\n        };\n      },\n      template: `\n      <span>{{ isTouched.toString() }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('false');\n    expect(spy).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useIsFieldTouched.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns false and warns if form does not exist","suites":["useIsFieldTouched()"],"updatePoint":{"line":134,"column":54},"line":134,"code":"  test('returns false and warns if form does not exist', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n\n    mountWithHoc({\n      setup() {\n        const isTouched = useIsFieldTouched('something');\n\n        return {\n          isTouched,\n        };\n      },\n      template: `\n      <span>{{ isTouched.toString() }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('false');\n    expect(spy).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useIsFieldTouched.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns the validity of a single field","suites":["useIsFieldValid()"],"updatePoint":{"line":9,"column":46},"line":9,"code":"  test('returns the validity of a single field', async () => {\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { value } = useField('test', validate);\n        const isValid = useIsFieldValid('test');\n\n        return {\n          value,\n          isValid,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <span>{{ isValid.toString() }}</span>\n    `,\n    });\n    await flushPromises();\n\n    const input = document.querySelector('input');\n    const span = document.querySelector('span');\n    setValue(input as any, '');\n    await flushPromises();\n    expect(span?.textContent).toBe('false');\n    setValue(input as any, '12');\n    await flushPromises();\n    expect(span?.textContent).toBe('true');\n  });","file":"useIsFieldValid.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns the validity of a single field in child components without specifying a path","suites":["useIsFieldValid()"],"updatePoint":{"line":38,"column":92},"line":38,"code":"  test('returns the validity of a single field in child components without specifying a path', async () => {\n    const ValidIcon = defineComponent({\n      template: '<span>{{ isValid.toString() }}</span>',\n      setup() {\n        const isValid = useIsFieldValid();\n\n        return {\n          isValid,\n        };\n      },\n    });\n    mountWithHoc({\n      components: {\n        ValidIcon,\n      },\n      setup() {\n        useForm();\n        const { value } = useField('test', validate);\n\n        return {\n          value,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <ValidIcon />\n    `,\n    });\n\n    await flushPromises();\n\n    const input = document.querySelector('input');\n    const span = document.querySelector('span');\n    setValue(input as any, '');\n    await flushPromises();\n    expect(span?.textContent).toBe('false');\n    setValue(input as any, '12');\n    await flushPromises();\n    expect(span?.textContent).toBe('true');\n  });","file":"useIsFieldValid.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns the validity of array fields","suites":["useIsFieldValid()"],"updatePoint":{"line":79,"column":44},"line":79,"code":"  test('returns the validity of array fields', async () => {\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { value } = useField('test', validate);\n        useField('test', validate);\n        const isValid = useIsFieldValid('test');\n\n        return {\n          value,\n          isValid,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <span>{{ isValid.toString() }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input');\n    const span = document.querySelector('span');\n    setValue(input as any, '');\n    await flushPromises();\n    expect(span?.textContent).toBe('false');\n    setValue(input as any, '12');\n    await flushPromises();\n    expect(span?.textContent).toBe('true');\n  });","file":"useIsFieldValid.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns false and warns if field is not found","suites":["useIsFieldValid()"],"updatePoint":{"line":109,"column":53},"line":109,"code":"  test('returns false and warns if field is not found', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n\n    mountWithHoc({\n      setup() {\n        useForm();\n        const isValid = useIsFieldValid('test');\n\n        return {\n          isValid,\n        };\n      },\n      template: `\n      <span>{{ isValid.toString() }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const span = document.querySelector('span');\n    expect(span?.textContent).toBe('false');\n    expect(spy).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useIsFieldValid.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns false and warns if form is not found","suites":["useIsFieldValid()"],"updatePoint":{"line":135,"column":52},"line":135,"code":"  test('returns false and warns if form is not found', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n\n    mountWithHoc({\n      setup() {\n        const isValid = useIsFieldValid('test');\n\n        return {\n          isValid,\n        };\n      },\n      template: `\n      <span>{{ isValid.toString() }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const span = document.querySelector('span');\n    expect(span?.textContent).toBe('false');\n    expect(spy).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useIsFieldValid.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"gives access to the forms isDirty status","suites":["useIsFormDirty()"],"updatePoint":{"line":5,"column":48},"line":5,"code":"  test('gives access to the forms isDirty status', async () => {\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { value, handleChange } = useField('test');\n        const isDirty = useIsFormDirty();\n\n        return {\n          value,\n          isDirty,\n          handleInput: (e: any) => handleChange(e, false),\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" @input=\"handleInput\" />\n      <span>{{ isDirty.toString()  }}</span>\n    `,\n    });\n\n    const input = document.querySelector('input');\n    const dirty = document.querySelector('span');\n    expect(dirty?.textContent).toBe('false');\n\n    setValue(input as any, '');\n    await flushPromises();\n    expect(dirty?.textContent).toBe('true');\n  });","file":"useIsFormDirty.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns false and warns if form is not found","suites":["useIsFormDirty()"],"updatePoint":{"line":33,"column":52},"line":33,"code":"  test('returns false and warns if form is not found', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n\n    mountWithHoc({\n      setup() {\n        const isDirty = useIsFormDirty();\n\n        return {\n          isDirty,\n        };\n      },\n      template: `\n      <span>{{ isDirty.toString() }}</span>\n    `,\n    });\n\n    const dirty = document.querySelector('span');\n\n    await flushPromises();\n    expect(dirty?.textContent).toBe('false');\n    expect(spy).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useIsFormDirty.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"gives access to the forms isTouched status","suites":["useIsFormTouched()"],"updatePoint":{"line":5,"column":50},"line":5,"code":"  test('gives access to the forms isTouched status', async () => {\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { value, handleBlur } = useField('test');\n        const isTouched = useIsFormTouched();\n\n        return {\n          value,\n          isTouched,\n          handleBlur,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" @blur=\"handleBlur\" />\n      <span>{{ isTouched.toString()  }}</span>\n    `,\n    });\n\n    const input = document.querySelector('input');\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('false');\n\n    dispatchEvent(input as any, 'blur');\n    await flushPromises();\n    expect(error?.textContent).toBe('true');\n  });","file":"useIsFormTouched.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns false and warns if form is not found","suites":["useIsFormTouched()"],"updatePoint":{"line":33,"column":52},"line":33,"code":"  test('returns false and warns if form is not found', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n\n    mountWithHoc({\n      setup() {\n        const isTouched = useIsFormTouched();\n\n        return {\n          isTouched,\n        };\n      },\n      template: `\n      <span>{{ isTouched.toString() }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('false');\n    expect(spy).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useIsFormTouched.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns validity of the form","suites":["useIsFormValid()"],"updatePoint":{"line":8,"column":36},"line":8,"code":"  test('returns validity of the form', async () => {\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { value } = useField('test', validate);\n        const isValid = useIsFormValid();\n\n        return {\n          value,\n          isValid,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <span>{{ isValid.toString() }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input');\n    const span = document.querySelector('span');\n    setValue(input as any, '');\n    await flushPromises();\n    expect(span?.textContent).toBe('false');\n    setValue(input as any, '12');\n    await flushPromises();\n    expect(span?.textContent).toBe('true');\n  });","file":"useIsFormValid.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns false and warns if form is not found","suites":["useIsFormValid()"],"updatePoint":{"line":37,"column":52},"line":37,"code":"  test('returns false and warns if form is not found', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n\n    mountWithHoc({\n      setup() {\n        const isValid = useIsFormValid();\n\n        return {\n          isValid,\n        };\n      },\n      template: `\n      <span>{{ isValid.toString() }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const span = document.querySelector('span');\n    expect(span?.textContent).toBe('false');\n    expect(spy).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useIsFormValid.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"indicates if a form is submitting","suites":["useIsSubmitting()"],"updatePoint":{"line":12,"column":41},"line":12,"code":"  test('indicates if a form is submitting', async () => {\n    mountWithHoc({\n      setup() {\n        const { submitForm } = useForm();\n        useField('test', validate);\n        const isSubmitting = useIsSubmitting();\n\n        return {\n          isSubmitting,\n          submitForm,\n        };\n      },\n      template: `\n      <button @click=\"submitForm\">Submit</button>\n      <span>{{ isSubmitting.toString() }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const button = document.querySelector('button');\n    const submitText = document.querySelector('span');\n    expect(submitText?.textContent).toBe('false');\n    button?.click();\n\n    await flushPromises();\n    expect(submitText?.textContent).toBe('true');\n    vi.runAllTimers();\n    await flushPromises();\n    expect(submitText?.textContent).toBe('false');\n  });","file":"useIsSubmitting.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns false and warns if form is not found","suites":["useIsSubmitting()"],"updatePoint":{"line":43,"column":52},"line":43,"code":"  test('returns false and warns if form is not found', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n    mountWithHoc({\n      setup() {\n        const isSubmitting = useIsSubmitting();\n\n        return {\n          isSubmitting,\n        };\n      },\n      template: `\n      <span>{{ isSubmitting.toString() }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const submitText = document.querySelector('span');\n    expect(submitText?.textContent).toBe('false');\n    expect(console.warn).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useIsSubmitting.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"resets a form","suites":["useResetForm()"],"updatePoint":{"line":8,"column":21},"line":8,"code":"  test('resets a form', async () => {\n    let resetForm: any;\n    let value: any;\n    let errorMessage: any;\n    mountWithHoc({\n      setup() {\n        useForm();\n        const field = useField('test', validate);\n        value = field.value;\n        errorMessage = field.errorMessage;\n        resetForm = useResetForm();\n\n        return {\n          value,\n          errorMessage,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <span>{{ errorMessage }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input');\n    const error = document.querySelector('span');\n    setValue(input as any, '');\n    await flushPromises();\n    expect(error?.textContent).toBe(REQUIRED_MESSAGE);\n\n    const inputValue = '123';\n\n    resetForm({\n      values: {\n        test: inputValue,\n      },\n    });\n\n    await flushPromises();\n    expect(error?.textContent).toBe('');\n    expect(input?.value).toBe(inputValue);\n  });","file":"useResetForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"warns if the form does not exist","suites":["useResetForm()"],"updatePoint":{"line":51,"column":40},"line":51,"code":"  test('warns if the form does not exist', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n    let resetForm: any;\n\n    mountWithHoc({\n      setup() {\n        resetForm = useResetForm();\n\n        return {};\n      },\n      template: `<div></div>`,\n    });\n\n    resetForm({\n      values: {\n        test: 'someValue',\n      },\n    });\n\n    await flushPromises();\n    expect(spy).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useResetForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"indicates the number of submissions","suites":["useSubmitCount()"],"updatePoint":{"line":5,"column":43},"line":5,"code":"  test('indicates the number of submissions', async () => {\n    mountWithHoc({\n      setup() {\n        const { submitForm } = useForm();\n        useField('test');\n        const submitCount = useSubmitCount();\n\n        return {\n          submitCount,\n          submitForm,\n        };\n      },\n      template: `\n      <button @click=\"submitForm()\">Submit</button>\n      <span>{{ submitCount }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const button = document.querySelector('button');\n    const submitText = document.querySelector('span');\n    expect(submitText?.textContent).toBe('0');\n    button?.click();\n    await flushPromises();\n    expect(submitText?.textContent).toBe('1');\n  });","file":"useSubmitCount.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"returns 0 and warns if form is not found","suites":["useSubmitCount()"],"updatePoint":{"line":32,"column":48},"line":32,"code":"  test('returns 0 and warns if form is not found', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n    mountWithHoc({\n      setup() {\n        const submitCount = useSubmitCount();\n\n        return {\n          submitCount,\n        };\n      },\n      template: `\n      <span>{{ submitCount }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const submitText = document.querySelector('span');\n    expect(submitText?.textContent).toBe('0');\n    expect(console.warn).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useSubmitCount.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"executes a form submission callback","suites":["useSubmitForm()"],"updatePoint":{"line":8,"column":43},"line":8,"code":"  test('executes a form submission callback', async () => {\n    const spy = vi.fn();\n    mountWithHoc({\n      setup() {\n        useForm();\n        const field = useField('test', validate);\n        const value = field.value;\n        const errorMessage = field.errorMessage;\n        const submitForm = useSubmitForm(spy);\n\n        return {\n          value,\n          errorMessage,\n          submitForm,\n        };\n      },\n      template: `\n      <input name=\"field\" v-model=\"value\" />\n      <span>{{ errorMessage }}</span>\n      <button @click=\"submitForm\"></button>\n    `,\n    });\n\n    await flushPromises();\n    const input = document.querySelector('input');\n    const error = document.querySelector('span');\n    const submitBtn = document.querySelector('button');\n    submitBtn?.click();\n    await flushPromises();\n    expect(error?.textContent).toBe(REQUIRED_MESSAGE);\n    expect(spy).not.toHaveBeenCalled();\n\n    const inputValue = '123';\n\n    setValue(input as any, inputValue);\n    submitBtn?.click();\n    await flushPromises();\n    expect(spy).toHaveBeenCalledWith({ test: inputValue }, expect.anything());\n  });","file":"useSubmitForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"warns if the form does not exist","suites":["useSubmitForm()"],"updatePoint":{"line":48,"column":40},"line":48,"code":"  test('warns if the form does not exist', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n\n    mountWithHoc({\n      setup() {\n        useSubmitForm(() => {\n          // nothing...\n        });\n\n        return {};\n      },\n      template: `<div></div>`,\n    });\n\n    await flushPromises();\n    expect(spy).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useSubmitForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"validates a single field","suites":["useValidateField()"],"updatePoint":{"line":9,"column":32},"line":9,"code":"  test('validates a single field', async () => {\n    let validate!: ReturnType<typeof useValidateField>;\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { errorMessage } = useField('test', rules);\n        validate = useValidateField('test');\n\n        return {\n          errorMessage,\n        };\n      },\n      template: `\n      <span>{{ errorMessage }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('');\n    await validate();\n    await flushPromises();\n\n    await flushPromises();\n    expect(error?.textContent).toBe(REQUIRED_MESSAGE);\n  });","file":"useValidateField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"validates a single field from a child component without specifying a path","suites":["useValidateField()"],"updatePoint":{"line":36,"column":81},"line":36,"code":"  test('validates a single field from a child component without specifying a path', async () => {\n    const ValidateBtn = defineComponent({\n      setup() {\n        const validate = useValidateField();\n\n        return {\n          validate,\n        };\n      },\n      template: '<button @click=\"validate\"></button>',\n    });\n    mountWithHoc({\n      components: {\n        ValidateBtn,\n      },\n      setup() {\n        useForm();\n        const { errorMessage } = useField('test', rules);\n\n        return {\n          errorMessage,\n        };\n      },\n      template: `\n      <span>{{ errorMessage }}</span>\n      <ValidateBtn />\n    `,\n    });\n\n    await flushPromises();\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('');\n    document.querySelector('button')?.click();\n    await flushPromises();\n\n    await flushPromises();\n    expect(error?.textContent).toBe(REQUIRED_MESSAGE);\n  });","file":"useValidateField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"validates array fields","suites":["useValidateField()"],"updatePoint":{"line":75,"column":30},"line":75,"code":"  test('validates array fields', async () => {\n    let validate!: ReturnType<typeof useValidateField>;\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { errorMessage } = useField('test', rules);\n        useField('test', rules);\n        validate = useValidateField('test');\n\n        return {\n          errorMessage,\n        };\n      },\n      template: `\n      <span>{{ errorMessage }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const error = document.querySelector('span');\n    expect(error?.textContent).toBe('');\n    await validate();\n    await flushPromises();\n\n    await flushPromises();\n    expect(error?.textContent).toBe(REQUIRED_MESSAGE);\n  });","file":"useValidateField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"warns if the field does not exist","suites":["useValidateField()"],"updatePoint":{"line":103,"column":41},"line":103,"code":"  test('warns if the field does not exist', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n    let validate!: ReturnType<typeof useValidateField>;\n    mountWithHoc({\n      setup() {\n        useForm();\n        validate = useValidateField('something');\n\n        return {};\n      },\n      template: `<div></div>`,\n    });\n\n    await validate();\n    await flushPromises();\n    expect(console.warn).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useValidateField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"warns if the form does not exist","suites":["useValidateField()"],"updatePoint":{"line":124,"column":40},"line":124,"code":"  test('warns if the form does not exist', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n    let validate!: ReturnType<typeof useValidateField>;\n    mountWithHoc({\n      setup() {\n        validate = useValidateField('something');\n\n        return {};\n      },\n      template: `<div></div>`,\n    });\n\n    await validate();\n    await flushPromises();\n    expect(console.warn).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useValidateField.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"validates all fields","suites":["useValidateForm()"],"updatePoint":{"line":8,"column":28},"line":8,"code":"  test('validates all fields', async () => {\n    let validate!: ReturnType<typeof useValidateForm>;\n    mountWithHoc({\n      setup() {\n        useForm();\n        const { errorMessage: e1 } = useField('test', rules);\n        const { errorMessage: e2 } = useField('another', rules);\n        validate = useValidateForm();\n\n        return {\n          e1,\n          e2,\n        };\n      },\n      template: `\n      <span>{{ e1 }}</span>\n      <span>{{ e2 }}</span>\n    `,\n    });\n\n    await flushPromises();\n    const errors = Array.from(document.querySelectorAll('span'));\n    expect(errors.map(span => span.textContent)).toEqual(['', '']);\n    await validate();\n    await flushPromises();\n    expect(errors.map(span => span.textContent)).toEqual([REQUIRED_MESSAGE, REQUIRED_MESSAGE]);\n  });","file":"useValidateForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"warns if form is not found","suites":["useValidateForm()"],"updatePoint":{"line":36,"column":34},"line":36,"code":"  test('warns if form is not found', async () => {\n    const spy = vi.spyOn(console, 'warn').mockImplementation(() => {\n      // NOOP\n    });\n    let validate!: ReturnType<typeof useValidateForm>;\n    mountWithHoc({\n      setup() {\n        validate = useValidateForm();\n\n        return {};\n      },\n      template: `<div></div>`,\n    });\n\n    await validate();\n    await flushPromises();\n    expect(console.warn).toHaveBeenCalled();\n    spy.mockRestore();\n  });","file":"useValidateForm.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"allows empty rules for the string format","suites":[],"updatePoint":{"line":5,"column":46},"line":5,"code":"test('allows empty rules for the string format', async () => {\n  defineRule('numeric', numeric);\n  let result = await validate(100, '|numeric');\n  expect(result.errors).toHaveLength(0);\n\n  result = await validate(100, '||||numeric');\n  expect(result.errors).toHaveLength(0);\n});","file":"validate.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"handles targets expressed in objects","suites":[],"updatePoint":{"line":14,"column":42},"line":14,"code":"test('handles targets expressed in objects', async () => {\n  defineRule('confirmed', (value: string, { target }: any) => {\n    return value === target ? true : 'must match';\n  });\n\n  let result = await validate('test', { confirmed: { target: '@other' } }, { values: { other: '' } });\n  expect(result.errors).toHaveLength(1);\n\n  result = await validate('test', { confirmed: { target: '@other' } }, { values: { other: 'test' } });\n  expect(result.errors).toHaveLength(0);\n});","file":"validate.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"target params are filled in the params in message context","suites":[],"updatePoint":{"line":27,"column":63},"line":27,"code":"test('target params are filled in the params in message context', async () => {\n  defineRule('lessThan', (value: number, params: any) => Number(value) < Number(params[0]));\n  const { generateMessage: original } = getConfig();\n  configure({\n    generateMessage: context => {\n      const params = context.rule?.params as any;\n      return `This value must be less than ${params[0]}`;\n    },\n  });\n\n  const result = await validate(2, 'lessThan:@other', { values: { other: 1 } });\n  expect(result.errors).toContain(`This value must be less than 1`);\n\n  configure({\n    generateMessage: original,\n  });\n});","file":"validate.spec.ts","skipped":false,"dir":"packages/vee-validate/tests"},{"name":"validates typed field with zod","suites":[],"updatePoint":{"line":11,"column":36},"line":11,"code":"test('validates typed field with zod', async () => {\n  const wrapper = mountWithHoc({\n    setup() {\n      const rules = toTypedSchema(z.string().min(1, REQUIRED_MSG).min(8, MIN_MSG));\n      const { value, errorMessage } = useField('test', rules);\n\n      return {\n        value,\n        errorMessage,\n      };\n    },\n    template: `\n      <div>\n          <input v-model=\"value\" type=\"text\">\n          <p>{{ errorMessage }}</p>\n      </div>\n    `,\n  });\n\n  const input = wrapper.$el.querySelector('input');\n  const error = wrapper.$el.querySelector('p');\n\n  setValue(input, '');\n  await flushPromises();\n  expect(error.textContent).toBe(REQUIRED_MSG);\n  setValue(input, '12');\n  await flushPromises();\n  expect(error.textContent).toBe(MIN_MSG);\n  setValue(input, '12345678');\n  await flushPromises();\n  expect(error.textContent).toBe('');\n});","file":"zod.spec.ts","skipped":false,"dir":"packages/zod/tests"},{"name":"generates multiple errors for any given field","suites":[],"updatePoint":{"line":44,"column":51},"line":44,"code":"test('generates multiple errors for any given field', async () => {\n  let errors!: Ref<string[]>;\n  const wrapper = mountWithHoc({\n    setup() {\n      const rules = toTypedSchema(z.string().min(1, REQUIRED_MSG).min(8, MIN_MSG));\n      const { value, errors: fieldErrors } = useField('test', rules);\n\n      errors = fieldErrors;\n      return {\n        value,\n      };\n    },\n    template: `\n      <div>\n          <input v-model=\"value\" type=\"text\">\n      </div>\n    `,\n  });\n\n  const input = wrapper.$el.querySelector('input');\n\n  setValue(input, '');\n  await flushPromises();\n  expect(errors.value).toHaveLength(2);\n  expect(errors.value).toEqual([REQUIRED_MSG, MIN_MSG]);\n});","file":"zod.spec.ts","skipped":false,"dir":"packages/zod/tests"},{"name":"shows multiple errors using error bag","suites":[],"updatePoint":{"line":71,"column":43},"line":71,"code":"test('shows multiple errors using error bag', async () => {\n  const wrapper = mountWithHoc({\n    setup() {\n      const schema = toTypedSchema(\n        z.object({\n          email: z.string().email(EMAIL_MSG).min(7, MIN_MSG),\n          password: z.string().min(8, MIN_MSG),\n        })\n      );\n\n      const { useFieldModel, errorBag } = useForm({\n        validationSchema: schema,\n        validateOnMount: true,\n      });\n\n      const [email, password] = useFieldModel(['email', 'password']);\n\n      return {\n        schema,\n        email,\n        password,\n        errorBag,\n      };\n    },\n    template: `\n      <div>\n        <input id=\"email\" name=\"email\" v-model=\"email\" />\n        <span id=\"emailErr\">{{ errorBag.email?.join(',') }}</span>\n\n        <input id=\"password\" name=\"password\" type=\"password\" v-model=\"password\" />\n        <span id=\"passwordErr\">{{ errorBag.password?.join(',') }}</span>\n      </div>\n    `,\n  });\n\n  const email = wrapper.$el.querySelector('#email');\n  const password = wrapper.$el.querySelector('#password');\n  const emailError = wrapper.$el.querySelector('#emailErr');\n  const passwordError = wrapper.$el.querySelector('#passwordErr');\n\n  await flushPromises();\n\n  setValue(email, 'hello@');\n  setValue(password, '1234');\n  await flushPromises();\n\n  expect(emailError.textContent).toBe([EMAIL_MSG, MIN_MSG].join(','));\n  expect(passwordError.textContent).toBe([MIN_MSG].join(','));\n\n  setValue(email, 'hello@email.com');\n  setValue(password, '12346789');\n  await flushPromises();\n\n  expect(emailError.textContent).toBe('');\n  expect(passwordError.textContent).toBe('');\n});","file":"zod.spec.ts","skipped":false,"dir":"packages/zod/tests"},{"name":"validates typed schema form with zod","suites":[],"updatePoint":{"line":128,"column":42},"line":128,"code":"test('validates typed schema form with zod', async () => {\n  const wrapper = mountWithHoc({\n    setup() {\n      const schema = toTypedSchema(\n        z.object({\n          email: z.string().email(EMAIL_MSG).min(1, REQUIRED_MSG),\n          password: z.string().min(8, MIN_MSG),\n        })\n      );\n\n      const { useFieldModel, errors } = useForm({\n        validationSchema: schema,\n        validateOnMount: true,\n      });\n\n      const [email, password] = useFieldModel(['email', 'password']);\n\n      return {\n        schema,\n        email,\n        password,\n        errors,\n      };\n    },\n    template: `\n    <div>\n      <input id=\"email\" name=\"email\" v-model=\"email\" />\n      <span id=\"emailErr\">{{ errors.email }}</span>\n\n      <input id=\"password\" name=\"password\" type=\"password\" v-model=\"password\" />\n      <span id=\"passwordErr\">{{ errors.password }}</span>\n    </div>\n    `,\n  });\n\n  const email = wrapper.$el.querySelector('#email');\n  const password = wrapper.$el.querySelector('#password');\n  const emailError = wrapper.$el.querySelector('#emailErr');\n  const passwordError = wrapper.$el.querySelector('#passwordErr');\n\n  await flushPromises();\n\n  setValue(email, 'hello@');\n  setValue(password, '1234');\n  await flushPromises();\n\n  expect(emailError.textContent).toBe(EMAIL_MSG);\n  expect(passwordError.textContent).toBe(MIN_MSG);\n\n  setValue(email, 'hello@email.com');\n  setValue(password, '12346789');\n  await flushPromises();\n\n  expect(emailError.textContent).toBe('');\n  expect(passwordError.textContent).toBe('');\n});","file":"zod.spec.ts","skipped":false,"dir":"packages/zod/tests"},{"name":"handles zod union errors","suites":[],"updatePoint":{"line":186,"column":30},"line":186,"code":"test('handles zod union errors', async () => {\n  const wrapper = mountWithHoc({\n    setup() {\n      const schema = z.object({\n        email: z.string().email({ message: 'valid email' }).min(1, 'Email is required'),\n        name: z.string().min(1, 'Name is required'),\n      });\n\n      const schemaBothUndefined = z.object({\n        email: z.undefined(),\n        name: z.undefined(),\n      });\n\n      const bothOrNeither = schema.or(schemaBothUndefined);\n\n      const { useFieldModel, errors } = useForm({\n        validationSchema: toTypedSchema(bothOrNeither),\n      });\n\n      const [email, name] = useFieldModel(['email', 'name']);\n\n      return {\n        schema,\n        email,\n        name,\n        errors,\n      };\n    },\n    template: `\n    <div>\n      <input id=\"email\" name=\"email\" v-model=\"email\" />\n      <span id=\"emailErr\">{{ errors.email }}</span>\n\n      <input id=\"name\" name=\"name\" v-model=\"name\" />\n      <span id=\"nameErr\">{{ errors.name }}</span>\n    </div>\n    `,\n  });\n\n  const email = wrapper.$el.querySelector('#email');\n  const name = wrapper.$el.querySelector('#name');\n  const emailError = wrapper.$el.querySelector('#emailErr');\n  const nameError = wrapper.$el.querySelector('#nameErr');\n\n  await flushPromises();\n\n  setValue(name, '4');\n  await flushPromises();\n  expect(nameError.textContent).toBe('Expected undefined, received string');\n\n  setValue(email, 'test@gmail.com');\n  await flushPromises();\n\n  expect(emailError.textContent).toBe('');\n  expect(nameError.textContent).toBe('');\n});","file":"zod.spec.ts","skipped":false,"dir":"packages/zod/tests"},{"name":"uses zod for form values transformations and parsing","suites":[],"updatePoint":{"line":243,"column":58},"line":243,"code":"test('uses zod for form values transformations and parsing', async () => {\n  const submitSpy = vi.fn();\n  mountWithHoc({\n    setup() {\n      const schema = toTypedSchema(\n        z.object({\n          age: z.preprocess(arg => Number(arg), z.number()),\n        })\n      );\n\n      const { handleSubmit } = useForm({\n        validationSchema: schema,\n        initialValues: { age: '11' },\n      });\n\n      // submit now\n      handleSubmit(submitSpy)();\n\n      return {\n        schema,\n      };\n    },\n    template: `<div></div>`,\n  });\n\n  await flushPromises();\n  await expect(submitSpy).toHaveBeenCalledTimes(1);\n  await expect(submitSpy).toHaveBeenLastCalledWith(\n    expect.objectContaining({\n      age: 11,\n    }),\n    expect.anything()\n  );\n});","file":"zod.spec.ts","skipped":false,"dir":"packages/zod/tests"},{"name":"uses zod default values for submission","suites":[],"updatePoint":{"line":278,"column":44},"line":278,"code":"test('uses zod default values for submission', async () => {\n  const submitSpy = vi.fn();\n\n  mountWithHoc({\n    setup() {\n      const schema = toTypedSchema(\n        z.object({\n          age: z.number().default(11),\n        })\n      );\n\n      const { handleSubmit } = useForm({\n        validationSchema: schema,\n      });\n\n      // submit now\n      handleSubmit(submitSpy)();\n\n      return {\n        schema,\n      };\n    },\n    template: `<div></div>`,\n  });\n\n  await flushPromises();\n  await expect(submitSpy).toHaveBeenCalledTimes(1);\n  await expect(submitSpy).toHaveBeenLastCalledWith(\n    expect.objectContaining({\n      age: 11,\n    }),\n    expect.anything()\n  );\n});","file":"zod.spec.ts","skipped":false,"dir":"packages/zod/tests"},{"name":"uses zod default values for initial values","suites":[],"updatePoint":{"line":313,"column":48},"line":313,"code":"test('uses zod default values for initial values', async () => {\n  const initialSpy = vi.fn();\n  mountWithHoc({\n    setup() {\n      const schema = toTypedSchema(\n        z.object({\n          name: z.string().default('test'),\n          age: z.number().default(11),\n          unknownKey: z.string(),\n          object: z.object({\n            nestedKey: z.string(),\n            nestedDefault: z.string().default('nested'),\n          }),\n        })\n      );\n\n      const { values } = useForm({\n        validationSchema: schema,\n      });\n\n      // submit now\n      initialSpy(values);\n\n      return {\n        schema,\n      };\n    },\n    template: `<div></div>`,\n  });\n\n  await flushPromises();\n  await expect(initialSpy).toHaveBeenCalledTimes(1);\n  await expect(initialSpy).toHaveBeenLastCalledWith(\n    expect.objectContaining({\n      age: 11,\n      name: 'test',\n      object: {\n        nestedDefault: 'nested',\n      },\n    })\n  );\n});","file":"zod.spec.ts","skipped":false,"dir":"packages/zod/tests"},{"name":"default values should not be undefined","suites":[],"updatePoint":{"line":357,"column":44},"line":357,"code":"test('default values should not be undefined', async () => {\n  const initialSpy = vi.fn();\n  mountWithHoc({\n    setup() {\n      const schema = toTypedSchema(\n        z.object({\n          email: z.string().min(1),\n        })\n      );\n\n      const { values } = useForm({\n        validationSchema: schema,\n      });\n\n      // submit now\n      initialSpy(values);\n\n      return {\n        schema,\n      };\n    },\n    template: `<div></div>`,\n  });\n\n  await flushPromises();\n  await expect(initialSpy).toHaveBeenCalledTimes(1);\n  await expect(initialSpy).toHaveBeenLastCalledWith(expect.objectContaining({}));\n});","file":"zod.spec.ts","skipped":false,"dir":"packages/zod/tests"}]}