{"repo":"mcollina/autocannon","url":"https://github.com/mcollina/autocannon","branch":"master","configs":[{"package":"autocannon","lang":"js","dir":"test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"exec separate autocannon instances with skipAggregateResult, then aggregateResult afterwards","suites":[],"updatePoint":{"line":11,"column":98,"index":365},"line":11,"code":"test('exec separate autocannon instances with skipAggregateResult, then aggregateResult afterwards', async t => {\n  t.plan(2);\n  const opts = {\n    url,\n    connections: 1,\n    maxOverallRequests: 10,\n    skipAggregateResult: true\n  };\n  const results = await Promise.all([autocannon(opts), autocannon(opts)]);\n  const aggregateResults = aggregateResult(results, opts);\n  t.equal(aggregateResults['2xx'], 20);\n  t.equal(aggregateResults.requests.total, 20);\n});","file":"aggregateResult.test.js","skipped":false,"dir":"test"},{"name":"aggregateResult must be passed opts with at least a URL or socketPath property","suites":[],"updatePoint":{"line":24,"column":84,"index":813},"line":24,"code":"test('aggregateResult must be passed opts with at least a URL or socketPath property', async t => {\n  t.plan(2);\n  t.throws(() => aggregateResult([]), 'url or socketPath option required');\n  t.throws(() => aggregateResult([], {}), 'url or socketPath option required');\n});","file":"aggregateResult.test.js","skipped":false,"dir":"test"},{"name":"parse argument","suites":[],"updatePoint":{"line":6,"column":20,"index":141},"line":6,"code":"test('parse argument', t => {\n  t.plan(4);\n  const args = Autocannon.parseArguments(['-H', 'X-Http-Method-Override=GET', '-m', 'POST', '-b', 'the body', 'http://localhost/foo/bar']);\n  t.equal(args.url, 'http://localhost/foo/bar');\n  t.strictSame(args.headers, {\n    'X-Http-Method-Override': 'GET'\n  });\n  t.equal(args.method, 'POST');\n  t.equal(args.body, 'the body');\n});","file":"argumentParsing.test.js","skipped":false,"dir":"test"},{"name":"parse argument with multiple headers","suites":[],"updatePoint":{"line":16,"column":42,"index":538},"line":16,"code":"test('parse argument with multiple headers', t => {\n  t.plan(3);\n  const args = Autocannon.parseArguments(['-H', 'header1=value1', '-H', 'header2=value2', '-H', 'header3=value3', '-H', 'header4=value4', '-H', 'header5=value5', 'http://localhost/foo/bar']);\n  t.equal(args.url, 'http://localhost/foo/bar');\n  t.strictSame(args.headers, {\n    header1: 'value1',\n    header2: 'value2',\n    header3: 'value3',\n    header4: 'value4',\n    header5: 'value5'\n  });\n  t.equal(args.method, 'GET');\n});","file":"argumentParsing.test.js","skipped":false,"dir":"test"},{"name":"parse argument with multiple complex headers","suites":[],"updatePoint":{"line":29,"column":50,"index":1038},"line":29,"code":"test('parse argument with multiple complex headers', t => {\n  t.plan(3);\n  const args = Autocannon.parseArguments(['-H', 'header1=value1;data=asd', '-H', 'header2=value2;data=asd', '-H', 'header3=value3;data=asd', '-H', 'header4=value4;data=asd', '-H', 'header5=value5;data=asd', 'http://localhost/foo/bar']);\n  t.equal(args.url, 'http://localhost/foo/bar');\n  t.strictSame(args.headers, {\n    header1: 'value1;data=asd',\n    header2: 'value2;data=asd',\n    header3: 'value3;data=asd',\n    header4: 'value4;data=asd',\n    header5: 'value5;data=asd'\n  });\n  t.equal(args.method, 'GET');\n});","file":"argumentParsing.test.js","skipped":false,"dir":"test"},{"name":"parse argument with multiple headers in standard notation","suites":[],"updatePoint":{"line":42,"column":63,"index":1641},"line":42,"code":"test('parse argument with multiple headers in standard notation', t => {\n  t.plan(3);\n  const args = Autocannon.parseArguments(['-H', 'header1: value1', '-H', 'header2: value2', '-H', 'header3: value3', '-H', 'header4: value4', '-H', 'header5: value5', 'http://localhost/foo/bar']);\n  t.equal(args.url, 'http://localhost/foo/bar');\n  t.strictSame(args.headers, {\n    header1: ' value1',\n    header2: ' value2',\n    header3: ' value3',\n    header4: ' value4',\n    header5: ' value5'\n  });\n  t.equal(args.method, 'GET');\n});","file":"argumentParsing.test.js","skipped":false,"dir":"test"},{"name":"parse argument with multiple complex headers in standard notation","suites":[],"updatePoint":{"line":55,"column":71,"index":2172},"line":55,"code":"test('parse argument with multiple complex headers in standard notation', t => {\n  t.plan(3);\n  const args = Autocannon.parseArguments(['-H', 'header1:value1;data=asd', '-H', 'header2:value2;data=asd', '-H', 'header3:value3;data=asd', '-H', 'header4:value4;data=asd', '-H', 'header5:value5;data=asd', 'http://localhost/foo/bar']);\n  t.equal(args.url, 'http://localhost/foo/bar');\n  t.strictSame(args.headers, {\n    header1: 'value1;data=asd',\n    header2: 'value2;data=asd',\n    header3: 'value3;data=asd',\n    header4: 'value4;data=asd',\n    header5: 'value5;data=asd'\n  });\n  t.equal(args.method, 'GET');\n});","file":"argumentParsing.test.js","skipped":false,"dir":"test"},{"name":"parse argument with \"=\" in value header","suites":[],"updatePoint":{"line":68,"column":45,"index":2757},"line":68,"code":"test('parse argument with \"=\" in value header', t => {\n  t.plan(1);\n  const args = Autocannon.parseArguments(['-H', 'header1=foo=bar', 'http://localhost/foo/bar']);\n  t.strictSame(args.headers, {\n    header1: 'foo=bar'\n  });\n});","file":"argumentParsing.test.js","skipped":false,"dir":"test"},{"name":"parse argument ending space in value header","suites":[],"updatePoint":{"line":75,"column":49,"index":2990},"line":75,"code":"test('parse argument ending space in value header', t => {\n  t.plan(1);\n  const args = Autocannon.parseArguments(['-H', 'header1=foo=bar ', 'http://localhost/foo/bar']);\n  t.strictSame(args.headers, {\n    header1: 'foo=bar '\n  });\n});","file":"argumentParsing.test.js","skipped":false,"dir":"test"},{"name":"parse argument with \":\" in value header","suites":[],"updatePoint":{"line":82,"column":45,"index":3221},"line":82,"code":"test('parse argument with \":\" in value header', t => {\n  t.plan(1);\n  const args = Autocannon.parseArguments(['-H', 'header1=foo:bar', 'http://localhost/foo/bar']);\n  t.strictSame(args.headers, {\n    header1: 'foo:bar'\n  });\n});","file":"argumentParsing.test.js","skipped":false,"dir":"test"},{"name":"parse argument not correctly formatted header","suites":[],"updatePoint":{"line":89,"column":51,"index":3456},"line":89,"code":"test('parse argument not correctly formatted header', t => {\n  t.plan(1);\n  t.throws(() => {\n    Autocannon.parseArguments(['-H', 'header1', 'http://localhost/foo/bar']);\n  }, /An HTTP header was not correctly formatted/);\n});","file":"argumentParsing.test.js","skipped":false,"dir":"test"},{"name":"parse argument with multiple url","suites":[],"updatePoint":{"line":95,"column":38,"index":3670},"line":95,"code":"test('parse argument with multiple url', t => {\n  t.plan(2);\n  const args = Autocannon.parseArguments(['localhost/foo/bar', 'http://localhost/baz/qux']);\n  t.equal(args.url[0], 'http://localhost/foo/bar');\n  t.equal(args.url[1], 'http://localhost/baz/qux');\n});","file":"argumentParsing.test.js","skipped":false,"dir":"test"},{"name":"parse argument with input file and multiple workers","suites":[],"updatePoint":{"line":101,"column":57,"index":3951},"line":101,"code":"test('parse argument with input file and multiple workers', t => {\n  t.plan(3);\n  const inputPath = 'help.txt';\n  const args = Autocannon.parseArguments(['-m', 'POST', '-w', '2', '-a', 10, '-i', inputPath, '-H', 'Content-Type=application/json', 'http://localhost/foo/bar']);\n  t.equal(args.url, 'http://localhost/foo/bar');\n  t.equal(args.method, 'POST');\n  t.equal(args.body, fs.readFileSync(inputPath, 'utf8'));\n});","file":"argumentParsing.test.js","skipped":false,"dir":"test"},{"name":"parse argument with cert, key and multiple ca paths","suites":[],"updatePoint":{"line":109,"column":57,"index":4369},"line":109,"code":"test('parse argument with cert, key and multiple ca paths', t => {\n  t.plan(5);\n  const certPath = 'test/cert.pem';\n  const keyPath = 'test/key.pem';\n  const caPath1 = 'help.txt';\n  const caPath2 = 'package.json';\n  const args = Autocannon.parseArguments(['-m', 'POST', '--cert', certPath, '--key', keyPath, '--ca', '[', caPath1, caPath2, ']', 'http://localhost/foo/bar']);\n  t.equal(args.url, 'http://localhost/foo/bar');\n  t.equal(args.method, 'POST');\n  t.same(args.tlsOptions.cert, fs.readFileSync(certPath));\n  t.same(args.tlsOptions.key, fs.readFileSync(keyPath));\n  t.same(args.tlsOptions.ca, [fs.readFileSync(caPath1), fs.readFileSync(caPath2)]);\n});","file":"argumentParsing.test.js","skipped":false,"dir":"test"},{"name":"parse argument with cert, key and single ca path","suites":[],"updatePoint":{"line":122,"column":54,"index":5025},"line":122,"code":"test('parse argument with cert, key and single ca path', t => {\n  t.plan(5);\n  const certPath = 'test/cert.pem';\n  const keyPath = 'test/key.pem';\n  const caPath = 'help.txt';\n  const args = Autocannon.parseArguments(['-m', 'POST', '--cert', certPath, '--key', keyPath, '--ca', caPath, 'http://localhost/foo/bar']);\n  t.equal(args.url, 'http://localhost/foo/bar');\n  t.equal(args.method, 'POST');\n  t.same(args.tlsOptions.cert, fs.readFileSync(certPath));\n  t.same(args.tlsOptions.key, fs.readFileSync(keyPath));\n  t.same(args.tlsOptions.ca, [fs.readFileSync(caPath)]);\n});","file":"argumentParsing.test.js","skipped":false,"dir":"test"},{"name":"should run benchmark against server","suites":[],"updatePoint":{"line":13,"column":41,"index":344},"line":13,"code":"test('should run benchmark against server', t => {\n  const lines = [/Running 1s test @ .*$/, /10 connections.*$/, /$/, /.*/, /$/, /Stat.*2\\.5%.*50%.*97\\.5%.*99%.*Avg.*Stdev.*Max.*$/, /.*/, /Latency.*$/, /$/, /.*/, /Stat.*1%.*2\\.5%.*50%.*97\\.5%.*Avg.*Stdev.*Min.*$/, /.*/, /Req\\/Sec.*$/, /.*/, /Bytes\\/Sec.*$/, /.*/, /$/, /Req\\/Bytes counts sampled once per second.*$/, /# of samples: 1.*$/, /$/, /.* requests in ([0-9]|\\.)+s, .* read/];\n  t.plan(lines.length * 2);\n  const server = helper.startServer();\n  const url = 'http://localhost:' + server.address().port;\n  const child = childProcess.spawn(process.execPath, [path.join(__dirname, '..'), '-d', '1', url], {\n    cwd: __dirname,\n    env: process.env,\n    stdio: ['ignore', 'pipe', 'pipe'],\n    detached: false\n  });\n  t.teardown(() => {\n    child.kill();\n  });\n  child.stderr.pipe(split()).on('data', line => {\n    const regexp = lines.shift();\n    t.ok(regexp, 'we are expecting this line');\n    t.ok(regexp.test(line), 'line matches ' + regexp);\n  }).on('end', t.end);\n});","file":"cli.test.js","skipped":false,"dir":"test"},{"name":"should parse HAR file and run requests","suites":[],"updatePoint":{"line":33,"column":44,"index":1377},"line":33,"code":"test('should parse HAR file and run requests', t => {\n  const lines = [/Running \\d+ requests test @ .*$/, /1 connections.*$/, /$/, /.*/, /$/, /Stat.*2\\.5%.*50%.*97\\.5%.*99%.*Avg.*Stdev.*Max.*$/, /.*/, /Latency.*$/, /$/, /.*/, /Stat.*1%.*2\\.5%.*50%.*97\\.5%.*Avg.*Stdev.*Min.*$/, /.*/, /Req\\/Sec.*$/, /.*/, /Bytes\\/Sec.*$/, /.*/, /$/, /Req\\/Bytes counts sampled once per second.*$/, /# of samples: 1.*$/, /$/, /.* requests in ([0-9]|\\.)+s, .* read/];\n  t.plan(lines.length);\n  const server = helper.startServer();\n  const url = `http://localhost:${server.address().port}`;\n  const harPath = path.join(os.tmpdir(), 'autocannon-test.har');\n  const har = helper.customizeHAR('./fixtures/httpbin-simple-get.json', 'https://httpbin.org', url);\n  fs.writeFileSync(harPath, JSON.stringify(har));\n  const child = childProcess.spawn(process.execPath, [path.join(__dirname, '..'), '-a', 4, '-c', 1, '--har', harPath, url], {\n    cwd: __dirname,\n    env: process.env,\n    stdio: ['ignore', 'pipe', 'pipe'],\n    detached: false\n  });\n  t.teardown(() => {\n    child.kill();\n  });\n  child.stderr.pipe(split()).on('data', line => {\n    const regexp = lines.shift();\n    t.ok(regexp.test(line), `\"${line}\" matches ${regexp}`);\n  }).on('end', t.end);\n});","file":"cli.test.js","skipped":false,"dir":"test"},{"name":"should throw on unknown HAR file","suites":[],"updatePoint":{"line":55,"column":38,"index":2607},"line":55,"code":"test('should throw on unknown HAR file', t => {\n  t.plan(1);\n  const child = childProcess.spawn(process.execPath, [path.join(__dirname, '..'), '-a', 4, '-c', 1, '--har', 'does not exist', 'http://localhost'], {\n    cwd: __dirname,\n    env: process.env,\n    stdio: ['ignore', 'pipe', 'pipe'],\n    detached: false\n  });\n  t.teardown(() => {\n    child.kill();\n  });\n  const lines = [];\n  child.stderr.pipe(split()).on('data', line => lines.push(line)).on('end', () => {\n    const output = lines.join('\\n');\n    t.ok(output.includes('Error: Failed to load HAR file content: ENOENT'), `Unexpected output:\\n${output}`);\n    t.end();\n  });\n});","file":"cli.test.js","skipped":false,"dir":"test"},{"name":"should throw on invalid HAR file","suites":[],"updatePoint":{"line":73,"column":38,"index":3244},"line":73,"code":"test('should throw on invalid HAR file', t => {\n  t.plan(1);\n  const harPath = path.join(os.tmpdir(), 'autocannon-test.har');\n  fs.writeFileSync(harPath, 'not valid JSON content');\n  const child = childProcess.spawn(process.execPath, [path.join(__dirname, '..'), '-a', 4, '-c', 1, '--har', harPath, 'http://localhost'], {\n    cwd: __dirname,\n    env: process.env,\n    stdio: ['ignore', 'pipe', 'pipe'],\n    detached: false\n  });\n  t.teardown(() => {\n    child.kill();\n  });\n  const lines = [];\n  child.stderr.pipe(split()).on('data', line => lines.push(line)).on('end', () => {\n    const output = lines.join('\\n');\n    t.ok(output.includes('Error: Failed to load HAR file content: Unexpected token'), `Unexpected output:\\n${output}`);\n    t.end();\n  });\n});","file":"cli.test.js","skipped":false,"dir":"test"},{"name":"should write warning about unused HAR requests","suites":[],"updatePoint":{"line":93,"column":52,"index":4016},"line":93,"code":"test('should write warning about unused HAR requests', t => {\n  t.plan(1);\n  const server = helper.startServer();\n  const url = `http://localhost:${server.address().port}`;\n  const harPath = path.join(os.tmpdir(), 'autocannon-test.har');\n  const har = helper.customizeHAR('./fixtures/multi-domains.json', 'https://httpbin.org', url);\n  fs.writeFileSync(harPath, JSON.stringify(har));\n  const child = childProcess.spawn(process.execPath, [path.join(__dirname, '..'), '-a', 4, '-c', 1, '--har', harPath, url], {\n    cwd: __dirname,\n    env: process.env,\n    stdio: ['ignore', 'pipe', 'pipe'],\n    detached: false\n  });\n  t.teardown(() => {\n    child.kill();\n  });\n  const lines = [];\n  child.stderr.pipe(split()).on('data', line => lines.push(line)).on('end', () => {\n    const output = lines.join('\\n');\n    t.ok(output.includes(`Warning: skipping requests to 'https://github.com' as the target is ${url}`), `Unexpected output:\\n${output}`);\n    t.end();\n  });\n});","file":"cli.test.js","skipped":false,"dir":"test"},{"name":"run with workers","suites":[],"updatePoint":{"line":116,"column":22,"index":4950},"line":116,"code":"test('run with workers', {\n  skip: !hasWorkerSupport\n}, t => {\n  const lines = [/Running 1s test @ .*$/, /10 connections.*$/, /4 workers.*$/, /$/, /.*/, /$/, /Stat.*2\\.5%.*50%.*97\\.5%.*99%.*Avg.*Stdev.*Max.*$/, /.*/, /Latency.*$/, /$/, /.*/, /Stat.*1%.*2\\.5%.*50%.*97\\.5%.*Avg.*Stdev.*Min.*$/, /.*/, /Req\\/Sec.*$/, /.*/, /Bytes\\/Sec.*$/, /.*/, /$/, /Req\\/Bytes counts sampled once per second.*$/, /.*$/, /$/, /.* requests in ([0-9]|\\.)+s, .* read/];\n  t.plan(lines.length * 2);\n  const server = helper.startServer();\n  const url = 'http://localhost:' + server.address().port;\n  const child = childProcess.spawn(process.execPath, [path.join(__dirname, '..'), '-d', '1', url, '--workers', '4'], {\n    cwd: __dirname,\n    env: process.env,\n    stdio: ['ignore', 'pipe', 'pipe'],\n    detached: false\n  });\n  t.teardown(() => {\n    child.kill();\n  });\n  child.stderr.pipe(split()).on('data', line => {\n    const regexp = lines.shift();\n    t.ok(regexp, 'we are expecting this line');\n    t.ok(regexp.test(line), 'line matches ' + regexp);\n  }).on('end', t.end);\n});","file":"cli.test.js","skipped":false,"dir":"test"},{"name":"debug works","suites":[],"updatePoint":{"line":5,"column":17,"index":112},"line":5,"code":"test('debug works', t => {\n  t.plan(5);\n  const args = Autocannon.parseArguments(['-H', 'X-Http-Method-Override=GET', '-m', 'POST', '-b', 'the body', '--debug', 'http://localhost/foo/bar']);\n  t.equal(args.url, 'http://localhost/foo/bar');\n  t.strictSame(args.headers, {\n    'X-Http-Method-Override': 'GET'\n  });\n  t.equal(args.method, 'POST');\n  t.equal(args.body, 'the body');\n  t.equal(args.debug, true);\n});","file":"debug.test.js","skipped":false,"dir":"test"},{"name":"running with forever set to true and passing in a callback should cause an error to be returned in the callback","suites":[],"updatePoint":{"line":7,"column":117,"index":280},"line":7,"code":"test('running with forever set to true and passing in a callback should cause an error to be returned in the callback', t => {\n  t.plan(2);\n  initJob({\n    url: `http://localhost:${server.address().port}`,\n    forever: true\n  }, (err, res) => {\n    t.ok(err, 'should be error when callback passed to run');\n    t.notOk(res, 'should not exist');\n    t.end();\n  });\n});","file":"forever.test.js","skipped":false,"dir":"test"},{"name":"run forever should run until .stop() is called","suites":[],"updatePoint":{"line":18,"column":52,"index":583},"line":18,"code":"test('run forever should run until .stop() is called', t => {\n  t.plan(3);\n  let numRuns = 0;\n  const instance = initJob({\n    url: `http://localhost:${server.address().port}`,\n    duration: 0.5,\n    forever: true\n  });\n  instance.on('done', results => {\n    t.ok(results, 'should have gotten results');\n    if (++numRuns === 2) {\n      instance.stop();\n      setTimeout(() => {\n        t.ok(true, 'should have reached here without the callback being called again');\n        t.end();\n      }, 1000);\n    }\n  });\n});","file":"forever.test.js","skipped":false,"dir":"test"},{"name":"format  into ","suites":[],"updatePoint":{"line":13,"column":43,"index":285},"line":13,"code":"  test(`format ${original} into ${expected}`, t => {\n    t.equal(expected, format(original));\n    t.end();\n  });","file":"format.test.js","skipped":false,"dir":"test"},{"name":"client calls a server twice","suites":[],"updatePoint":{"line":31,"column":33,"index":994},"line":31,"code":"test('client calls a server twice', t => {\n  t.plan(4);\n  const client = new Client(server.address());\n  let count = 0;\n  client.on('response', (statusCode, length) => {\n    t.equal(statusCode, 200, 'status code matches');\n    t.ok(length > 'hello world'.length, 'length includes the headers');\n    if (count++ > 0) {\n      client.destroy();\n    }\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client calls a https server twice","suites":[],"updatePoint":{"line":43,"column":39,"index":1358},"line":43,"code":"test('client calls a https server twice', t => {\n  t.plan(4);\n  const opts = httpsServer.address();\n  opts.protocol = 'https:';\n  const client = new Client(opts);\n  let count = 0;\n  client.on('response', (statusCode, length) => {\n    t.equal(statusCode, 200, 'status code matches');\n    t.ok(length > 'hello world'.length, 'length includes the headers');\n    if (count++ > 0) {\n      client.destroy();\n    }\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client calculates correct duration when using pipelining","suites":[],"updatePoint":{"line":57,"column":62,"index":1799},"line":57,"code":"test('client calculates correct duration when using pipelining', t => {\n  t.plan(6);\n  const delayResponse = 500;\n  const lazyServer = helper.startServer({\n    delayResponse\n  });\n  const opts = lazyServer.address();\n  opts.pipelining = 2;\n  const startTime = process.hrtime();\n  const client = new Client(opts);\n  let count = 0;\n  client.on('response', (statusCode, length, duration) => {\n    t.equal(statusCode, 200, 'status code matches');\n    t.ok(duration > delayResponse, `Expected response delay > ${delayResponse}ms but got ${duration}ms`);\n    const hrduration = process.hrtime(startTime);\n    const maxExpectedDuration = hrduration[0] * 1e3 + hrduration[1] / 1e6;\n    t.ok(duration < maxExpectedDuration, `Expected response delay < ${maxExpectedDuration}ms but got ${duration}ms`);\n    if (++count === 2) {\n      client.destroy();\n    }\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client calls a tls server without SNI servername twice","suites":[],"updatePoint":{"line":79,"column":60,"index":2654},"line":79,"code":"test('client calls a tls server without SNI servername twice', t => {\n  t.plan(4);\n  const opts = tlsServer.address();\n  opts.protocol = 'https:';\n  const client = new Client(opts);\n  let count = 0;\n  client.on('headers', response => {\n    t.equal(response.statusCode, 200, 'status code matches');\n    t.same(response.headers, ['X-servername', '', 'Content-Length', '0']);\n    if (count++ > 0) {\n      client.destroy();\n    }\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client calls a tls server with SNI servername twice","suites":[],"updatePoint":{"line":93,"column":57,"index":3087},"line":93,"code":"test('client calls a tls server with SNI servername twice', t => {\n  t.plan(4);\n  const opts = tlsServer.address();\n  opts.protocol = 'https:';\n  opts.servername = 'example.com';\n  const client = new Client(opts);\n  let count = 0;\n  client.on('headers', response => {\n    t.equal(response.statusCode, 200, 'status code matches');\n    t.same(response.headers, ['X-servername', opts.servername, 'Content-Length', '0']);\n    if (count++ > 0) {\n      client.destroy();\n    }\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client uses SNI servername from URL hostname by default","suites":[],"updatePoint":{"line":108,"column":61,"index":3572},"line":108,"code":"test('client uses SNI servername from URL hostname by default', t => {\n  t.plan(4);\n  const opts = tlsServer.address();\n  opts.protocol = 'https:';\n  opts.hostname = 'localhost';\n  const client = new Client(opts);\n  let count = 0;\n  client.on('headers', response => {\n    t.equal(response.statusCode, 200, 'status code matches');\n    t.same(response.headers, ['X-servername', opts.hostname, 'Content-Length', '0']);\n    if (count++ > 0) {\n      client.destroy();\n    }\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client prefers SNI servername from opts over URL hostname","suites":[],"updatePoint":{"line":123,"column":63,"index":4053},"line":123,"code":"test('client prefers SNI servername from opts over URL hostname', t => {\n  t.plan(4);\n  const opts = tlsServer.address();\n  opts.protocol = 'https:';\n  opts.hostname = 'localhost';\n  opts.servername = 'example.com';\n  const client = new Client(opts);\n  let count = 0;\n  client.on('headers', response => {\n    t.equal(response.statusCode, 200, 'status code matches');\n    t.same(response.headers, ['X-servername', opts.servername, 'Content-Length', '0']);\n    if (count++ > 0) {\n      client.destroy();\n    }\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client ignores IP address in hostname-derived SNI servername","suites":[],"updatePoint":{"line":139,"column":66,"index":4574},"line":139,"code":"test('client ignores IP address in hostname-derived SNI servername', t => {\n  t.plan(4);\n  const opts = tlsServer.address();\n  opts.protocol = 'https:';\n  opts.hostname = opts.address;\n  const client = new Client(opts);\n  let count = 0;\n  client.on('headers', response => {\n    t.equal(response.statusCode, 200, 'status code matches');\n    t.same(response.headers, ['X-servername', '', 'Content-Length', '0']);\n    if (count++ > 0) {\n      client.destroy();\n    }\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client ignores falsy SNI servername","suites":[],"updatePoint":{"line":154,"column":41,"index":5023},"line":154,"code":"test('client ignores falsy SNI servername', t => {\n  t.plan(4);\n  const opts = tlsServer.address();\n  opts.protocol = 'https:';\n  opts.servername = '';\n  const client = new Client(opts);\n  let count = 0;\n  client.on('headers', response => {\n    t.equal(response.statusCode, 200, 'status code matches');\n    t.same(response.headers, ['X-servername', '', 'Content-Length', '0']);\n    if (count++ > 0) {\n      client.destroy();\n    }\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client passes through tlsOptions to connect","suites":[],"updatePoint":{"line":169,"column":49,"index":5472},"line":169,"code":"test('client passes through tlsOptions to connect', t => {\n  t.plan(4);\n  const opts = tlsServer.address();\n  opts.protocol = 'https:';\n  opts.tlsOptions = {\n    key: fs.readFileSync(path.join(__dirname, '/key.pem')),\n    cert: fs.readFileSync(path.join(__dirname, '/cert.pem')),\n    passphrase: 'test'\n  };\n  const client = new Client(opts);\n  let count = 0;\n  client.on('headers', response => {\n    t.equal(response.statusCode, 200, 'status code matches');\n    t.same(response.headers, ['X-servername', '', 'X-email', 'tes@test.com', 'Content-Length', '0']);\n    if (count++ > 0) {\n      client.destroy();\n    }\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"http client automatically reconnects","suites":[],"updatePoint":{"line":188,"column":42,"index":6089},"line":188,"code":"test('http client automatically reconnects', t => {\n  t.plan(4);\n  const client = new Client(server.address());\n  let count = 0;\n  client.on('response', (statusCode, length) => {\n    t.equal(statusCode, 200, 'status code matches');\n    t.ok(length > 'hello world'.length, 'length includes the headers');\n    if (count++ > 0) {\n      client.destroy();\n    }\n  });\n  server.once('request', function (req, res) {\n    setImmediate(() => {\n      req.socket.destroy();\n    });\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"http clients should have a different body","suites":[],"updatePoint":{"line":205,"column":47,"index":6575},"line":205,"code":"test('http clients should have a different body', t => {\n  t.plan(3);\n  let clientCnt = 0;\n  const clients = [];\n  const reqArray = ['John', 'Gabriel', 'Jason'];\n  const opts = server.address();\n  opts.setupClient = client => {\n    client.setBody(JSON.stringify({\n      name: reqArray[clientCnt]\n    }));\n    clientCnt++;\n  };\n  for (let i = 0; i < 3; i++) {\n    const client = new Client(opts);\n    clients.push(client);\n  }\n  for (let i = 0; i < clients.length; i++) {\n    const client = clients[i];\n    const body = JSON.parse(client.requestIterator.currentRequest.body);\n    t.equal(body.name, reqArray[i], 'body match');\n    client.destroy();\n  }\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports custom headers","suites":[],"updatePoint":{"line":228,"column":36,"index":7220},"line":228,"code":"test('client supports custom headers', t => {\n  t.plan(3);\n  const opts = server.address();\n  opts.headers = {\n    hello: 'world'\n  };\n  const client = new Client(opts);\n  server.once('request', (req, res) => {\n    t.equal(req.headers.hello, 'world', 'custom header matches');\n  });\n  client.on('response', (statusCode, length) => {\n    t.equal(statusCode, 200, 'status code matches');\n    t.ok(length > 'hello world'.length, 'length includes the headers');\n    client.destroy();\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports custom headers in requests","suites":[],"updatePoint":{"line":244,"column":48,"index":7722},"line":244,"code":"test('client supports custom headers in requests', t => {\n  t.plan(2);\n  const opts = server.address();\n  opts.requests = [{\n    path: '/',\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json'\n    },\n    body: JSON.stringify({\n      foo: 'example'\n    })\n  }];\n  const client = new Client(opts);\n  server.once('request', (req, res) => {\n    t.equal(req.headers['content-type'], 'application/json', 'custom header matches');\n  });\n  client.on('response', (statusCode, length) => {\n    t.equal(statusCode, 200, 'status code matches');\n    client.destroy();\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports host custom header","suites":[],"updatePoint":{"line":266,"column":40,"index":8302},"line":266,"code":"test('client supports host custom header', t => {\n  t.plan(2);\n  const opts = server.address();\n  opts.headers = {\n    host: 'www.autocannon.com'\n  };\n  const client = new Client(opts);\n  server.once('request', (req, res) => {\n    t.equal(req.headers.host, 'www.autocannon.com', 'host header matches');\n  });\n  client.on('response', (statusCode, length) => {\n    t.equal(statusCode, 200, 'status code matches');\n    client.destroy();\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports host custom header with mixed case","suites":[],"updatePoint":{"line":281,"column":56,"index":8762},"line":281,"code":"test('client supports host custom header with mixed case', t => {\n  t.plan(2);\n  const opts = server.address();\n  opts.headers = {\n    Host: 'www.autocannon.com'\n  };\n  const client = new Client(opts);\n  server.once('request', (req, res) => {\n    t.equal(req.headers.host, 'www.autocannon.com', 'host header matches');\n  });\n  client.on('response', (statusCode, length) => {\n    t.equal(statusCode, 200, 'status code matches');\n    client.destroy();\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports response trailers","suites":[],"updatePoint":{"line":296,"column":39,"index":9205},"line":296,"code":"test('client supports response trailers', t => {\n  t.plan(3);\n  const client = new Client(trailerServer.address());\n  let n = 0;\n  client.on('body', raw => {\n    if (++n === 1) {\n      // trailer value\n      t.ok(/7895bf4b8828b55ceaf47747b4bca667/.test(raw.toString()));\n    }\n  });\n  client.on('response', (statusCode, length) => {\n    t.equal(statusCode, 200, 'status code matches');\n    t.ok(length > 'hello world'.length, 'length includes the headers');\n    client.destroy();\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports ","suites":[],"updatePoint":{"line":313,"column":33,"index":9735},"line":313,"code":"  test(`client supports ${method}`, t => {\n    t.plan(3);\n    const opts = server.address();\n    opts.method = method;\n    const client = new Client(opts);\n    server.once('request', (req, res) => {\n      t.equal(req.method, method, 'custom method matches');\n    });\n    client.on('response', (statusCode, length) => {\n      t.equal(statusCode, 200, 'status code matches');\n      t.ok(length > 'hello world'.length, 'length includes the headers');\n      client.destroy();\n    });\n  });","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports sending a body","suites":[],"updatePoint":{"line":328,"column":36,"index":10228},"line":328,"code":"test('client supports sending a body', t => {\n  t.plan(4);\n  const opts = server.address();\n  opts.method = 'POST';\n  opts.body = Buffer.from('hello world');\n  const client = new Client(opts);\n  server.once('request', (req, res) => {\n    req.pipe(bl((err, body) => {\n      t.error(err);\n      t.same(body.toString(), opts.body.toString(), 'body matches');\n    }));\n  });\n  client.on('response', (statusCode, length) => {\n    t.equal(statusCode, 200, 'status code matches');\n    t.ok(length > 'hello world'.length, 'length includes the headers');\n    client.destroy();\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports sending a body which is a string","suites":[],"updatePoint":{"line":346,"column":54,"index":10824},"line":346,"code":"test('client supports sending a body which is a string', t => {\n  t.plan(4);\n  const opts = server.address();\n  opts.method = 'POST';\n  opts.body = 'hello world';\n  const client = new Client(opts);\n  server.once('request', (req, res) => {\n    req.pipe(bl((err, body) => {\n      t.error(err);\n      t.same(body.toString(), opts.body, 'body matches');\n    }));\n  });\n  client.on('response', (statusCode, length) => {\n    t.equal(statusCode, 200, 'status code matches');\n    t.ok(length > 'hello world'.length, 'length includes the headers');\n    client.destroy();\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports sending a body passed on the CLI as JSON array","suites":[],"updatePoint":{"line":364,"column":68,"index":11410},"line":364,"code":"test('client supports sending a body passed on the CLI as JSON array', t => {\n  t.plan(3);\n  const body = [{\n    a: [{\n      b: 1\n    }]\n  }];\n  const jsonBody = JSON.stringify(body);\n\n  // this odd format is parsed by the subarg parser when body is a JSON array\n  const mangledBody = {\n    _: [JSON.stringify(body[0])]\n  };\n  const opts = server.address();\n  opts.method = 'POST';\n  opts.body = mangledBody;\n  const client = new Client(opts);\n  server.once('request', (req, res) => {\n    req.pipe(bl((err, body) => {\n      t.error(err);\n      t.same(body.toString(), jsonBody, 'body matches');\n    }));\n  });\n  client.on('response', (statusCode, length) => {\n    t.equal(statusCode, 200, 'status code matches');\n    client.destroy();\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports changing the body","suites":[],"updatePoint":{"line":392,"column":39,"index":12126},"line":392,"code":"test('client supports changing the body', t => {\n  t.plan(2);\n  const opts = server.address();\n  opts.method = 'POST';\n  opts.body = 'hello world';\n  const client = new Client(opts);\n  t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n    server,\n    ...opts\n  }), 'request is okay before modifying');\n  const body = 'modified';\n  client.setBody(body);\n  t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n    server,\n    ...opts,\n    body\n  }), 'body changes updated request');\n  client.destroy();\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports changing the headers","suites":[],"updatePoint":{"line":411,"column":42,"index":12667},"line":411,"code":"test('client supports changing the headers', t => {\n  t.plan(2);\n  const opts = server.address();\n  opts.method = 'POST';\n  const client = new Client(opts);\n  t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n    server,\n    ...opts\n  }), 'request is okay before modifying');\n  const headers = {\n    header: 'modified'\n  };\n  client.setHeaders(headers);\n  t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n    server,\n    ...opts,\n    headers\n  }), 'header changes updated request');\n  client.destroy();\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports changing the headers and body","suites":[],"updatePoint":{"line":431,"column":51,"index":13220},"line":431,"code":"test('client supports changing the headers and body', t => {\n  t.plan(2);\n  const opts = server.address();\n  opts.body = 'hello world';\n  opts.method = 'POST';\n  const client = new Client(opts);\n  t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n    server,\n    ...opts\n  }), 'request is okay before modifying');\n  const body = 'modified';\n  const headers = {\n    header: 'modifiedHeader'\n  };\n  client.setBody(body);\n  client.setHeaders(headers);\n  t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n    server,\n    ...opts,\n    headers,\n    body\n  }), 'changes updated request');\n  client.destroy();\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports changing the headers and body together","suites":[],"updatePoint":{"line":455,"column":60,"index":13871},"line":455,"code":"test('client supports changing the headers and body together', t => {\n  t.plan(2);\n  const opts = server.address();\n  opts.body = 'hello world';\n  opts.method = 'POST';\n  const client = new Client(opts);\n  t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n    server,\n    ...opts\n  }), 'request is okay before modifying');\n  const body = 'modified';\n  const headers = {\n    header: 'modifiedHeader'\n  };\n  client.setHeadersAndBody(headers, body);\n  t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n    server,\n    ...opts,\n    headers,\n    body\n  }), 'changes updated request');\n  client.destroy();\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports changing the headers and body with null values","suites":[],"updatePoint":{"line":478,"column":68,"index":14519},"line":478,"code":"test('client supports changing the headers and body with null values', t => {\n  t.plan(2);\n  const opts = server.address();\n  opts.body = 'hello world';\n  opts.method = 'POST';\n  const client = new Client(opts);\n  t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n    server,\n    ...opts\n  }), 'request is okay before modifying');\n  client.setBody(null);\n  client.setHeaders(null);\n  t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n    server,\n    method: 'POST'\n  }), 'changes updated request');\n  client.destroy();\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports changing the headers and body together with null values","suites":[],"updatePoint":{"line":496,"column":77,"index":15087},"line":496,"code":"test('client supports changing the headers and body together with null values', t => {\n  t.plan(2);\n  const opts = server.address();\n  opts.body = 'hello world';\n  opts.method = 'POST';\n  const client = new Client(opts);\n  t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n    server,\n    ...opts\n  }), 'request is okay before modifying');\n  client.setHeadersAndBody(null, null);\n  t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n    server,\n    method: 'POST'\n  }), 'changes updated request');\n  client.destroy();\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports updating the current request object","suites":[],"updatePoint":{"line":513,"column":57,"index":15624},"line":513,"code":"test('client supports updating the current request object', t => {\n  t.plan(2);\n  const opts = server.address();\n  opts.body = 'hello world';\n  opts.method = 'POST';\n  const client = new Client(opts);\n  t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n    server,\n    ...opts\n  }), 'request is okay before modifying');\n  const newReq = {\n    headers: {\n      header: 'modifiedHeader'\n    },\n    body: 'modified',\n    method: 'GET'\n  };\n  client.setRequest(newReq);\n  t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n    server,\n    ...newReq\n  }), 'changes updated request');\n  client.destroy();\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client customiseRequest function overwrites the headers and body","suites":[],"updatePoint":{"line":537,"column":70,"index":16275},"line":537,"code":"test('client customiseRequest function overwrites the headers and body', t => {\n  t.plan(5);\n  const opts = server.address();\n  opts.body = 'hello world';\n  opts.method = 'POST';\n  const body = 'modified';\n  const headers = {\n    header: 'modifiedHeader'\n  };\n  opts.setupClient = client => {\n    t.ok(client.setHeadersAndBody, 'client had setHeadersAndBody method');\n    t.ok(client.setHeaders, 'client had setHeaders method');\n    t.ok(client.setBody, 'client had setBody method');\n    client.setHeadersAndBody(headers, body);\n  };\n  const client = new Client(opts);\n  t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n    server,\n    ...opts,\n    headers,\n    body\n  }), 'changes updated request');\n  t.notSame(client.getRequestBuffer().toString(), makeResponseFromBody({\n    server,\n    ...opts\n  }), 'changes updated request');\n  client.destroy();\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client should throw when attempting to modify the request with a pipelining greater than 1","suites":[],"updatePoint":{"line":565,"column":96,"index":17176},"line":565,"code":"test('client should throw when attempting to modify the request with a pipelining greater than 1', t => {\n  t.plan(1);\n  const opts = server.address();\n  opts.pipelining = 10;\n  const client = new Client(opts);\n  t.throws(() => client.setHeaders({}));\n  client.destroy();\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client pipelined requests count should equal pipelining when greater than 1","suites":[],"updatePoint":{"line":573,"column":81,"index":17437},"line":573,"code":"test('client pipelined requests count should equal pipelining when greater than 1', t => {\n  t.plan(1);\n  const opts = server.address();\n  opts.pipelining = 10;\n  const client = new Client(opts);\n  t.equal(client.pipelinedRequests.size(), client.opts.pipelining);\n  client.destroy();\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client should emit a timeout when no response is received","suites":[],"updatePoint":{"line":581,"column":63,"index":17707},"line":581,"code":"test('client should emit a timeout when no response is received', t => {\n  t.plan(1);\n  const opts = timeoutServer.address();\n  opts.timeout = 1;\n  const client = new Client(opts);\n  client.on('timeout', () => {\n    t.ok(1, 'timeout should have happened');\n    client.destroy();\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client should emit 2 timeouts when no responses are received","suites":[],"updatePoint":{"line":591,"column":66,"index":17999},"line":591,"code":"test('client should emit 2 timeouts when no responses are received', t => {\n  t.plan(2);\n  const opts = timeoutServer.address();\n  opts.timeout = 1;\n  const client = new Client(opts);\n  let count = 0;\n  client.on('timeout', () => {\n    t.ok(1, 'timeout should have happened');\n    if (count++ > 0) {\n      client.destroy();\n    }\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client should have 2 different requests it iterates over","suites":[],"updatePoint":{"line":604,"column":62,"index":18335},"line":604,"code":"test('client should have 2 different requests it iterates over', t => {\n  t.plan(3);\n  const server = helper.startServer();\n  const opts = server.address();\n  const requests = [{\n    method: 'POST',\n    body: 'hello world again'\n  }, {\n    method: 'GET',\n    body: 'modified'\n  }];\n  const client = new Client(opts);\n  let number = 0;\n  client.setRequests(requests);\n  client.on('response', (statusCode, length) => {\n    number++;\n    switch (number) {\n      case 1:\n      case 3:\n        t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n          server,\n          ...requests[0]\n        }), 'request was okay');\n        break;\n      case 2:\n        t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n          server,\n          ...requests[1]\n        }), 'body changes updated request');\n        break;\n      case 4:\n        client.destroy();\n        t.end();\n        break;\n    }\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client should emit reset when request iterator has reset","suites":[],"updatePoint":{"line":641,"column":62,"index":19264},"line":641,"code":"test('client should emit reset when request iterator has reset', t => {\n  t.plan(1);\n  const server = helper.startServer();\n  const opts = server.address();\n  const requests = [{\n    method: 'POST',\n    body: 'hello world again'\n  }, {\n    method: 'POST',\n    body: 'modified',\n    // falsey result will reset\n    setupRequest: () => {}\n  }, {\n    method: 'POST',\n    body: 'never used'\n  }];\n  const client = new Client(opts);\n  client.setRequests(requests);\n  client.on('reset', () => {\n    client.destroy();\n    t.end();\n  });\n  client.on('response', () => {\n    t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n      server,\n      ...requests[0]\n    }), 'first request was okay');\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client should stop when first setupRequest() fails","suites":[],"updatePoint":{"line":670,"column":56,"index":19972},"line":670,"code":"test('client should stop when first setupRequest() fails', t => {\n  t.plan(1);\n  const server = helper.startServer();\n  const opts = server.address();\n  const client = new Client(opts);\n  t.throws(() => client.setRequests([{\n    method: 'GET',\n    setupRequest: () => {}\n  }]), 'First setupRequest() failed did not returned valid request. Stopping');\n  client.destroy();\n  t.end();\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client exposes response bodies and statuses","suites":[],"updatePoint":{"line":682,"column":49,"index":20351},"line":682,"code":"test('client exposes response bodies and statuses', t => {\n  const server = helper.startServer({\n    body: ({\n      method\n    }) => method === 'POST' ? 'hello!' : 'world!'\n  });\n  const opts = server.address();\n  opts.requests = [{\n    method: 'POST',\n    body: 'hello world!',\n    onResponse: (status, body) => responses.push({\n      status,\n      body\n    })\n  }, {\n    method: 'POST',\n    body: 'hello world again'\n  }, {\n    method: 'GET',\n    onResponse: (status, body) => responses.push({\n      status,\n      body\n    })\n  }];\n  const responses = [];\n  const client = new Client(opts);\n  let number = 0;\n  client.on('response', (statusCode, length) => {\n    number++;\n    switch (number) {\n      case 1:\n        t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n          server,\n          ...opts.requests[0]\n        }), 'first request');\n        t.same(responses, [{\n          status: 200,\n          body: 'hello!'\n        }]);\n        break;\n      case 2:\n        t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n          server,\n          ...opts.requests[1]\n        }), 'second request');\n        t.same(responses, [{\n          status: 200,\n          body: 'hello!'\n        }]);\n        break;\n      case 3:\n        t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n          server,\n          ...opts.requests[2]\n        }), 'third request');\n        t.same(responses, [{\n          status: 200,\n          body: 'hello!'\n        }, {\n          status: 200,\n          body: 'world!'\n        }]);\n        break;\n      case 4:\n        t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n          server,\n          ...opts.requests[0]\n        }), 'first request');\n        t.same(responses, [{\n          status: 200,\n          body: 'hello!'\n        }, {\n          status: 200,\n          body: 'world!'\n        }, {\n          status: 200,\n          body: 'hello!'\n        }]);\n        client.destroy();\n        t.end();\n        break;\n    }\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client keeps context and reset it when looping on requests","suites":[],"updatePoint":{"line":766,"column":64,"index":22398},"line":766,"code":"test('client keeps context and reset it when looping on requests', t => {\n  const server = helper.startServer();\n  const opts = server.address();\n  let number = 0;\n  const expectedResponse = 'hello world';\n  opts.requests = [{\n    method: 'POST',\n    body: 'hello world again',\n    onResponse: (status, body, context) => {\n      if (number < 3) {\n        t.same(context, {}, 'context was supposed to be null');\n        context.previousRes = body;\n      }\n    }\n  }, {\n    method: 'PUT',\n    setupRequest: (req, context) => {\n      if (number < 3) {\n        t.same(context, {\n          previousRes: expectedResponse\n        }, 'context was supposed to contain previous response');\n      }\n      return Object.assign({}, req, {\n        body: context.previousRes\n      });\n    }\n  }];\n  const client = new Client(opts);\n  client.on('response', (statusCode, length) => {\n    number++;\n    switch (number) {\n      case 1:\n        t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n          server,\n          ...opts.requests[0]\n        }), 'hard-coded body');\n        break;\n      case 2:\n        t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n          server,\n          method: 'PUT',\n          body: expectedResponse\n        }), 'dynamic body');\n        client.destroy();\n        t.end();\n        break;\n    }\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports http basic authentication","suites":[],"updatePoint":{"line":815,"column":47,"index":23738},"line":815,"code":"test('client supports http basic authentication', t => {\n  t.plan(2);\n  const server = helper.startServer();\n  const opts = server.address();\n  opts.auth = 'username:password';\n  const client = new Client(opts);\n  server.once('request', (req, res) => {\n    t.equal(req.headers.authorization, 'Basic dXNlcm5hbWU6cGFzc3dvcmQ=', 'authorization header matches');\n  });\n  client.on('response', (statusCode, length) => {\n    t.equal(statusCode, 200, 'status code matches');\n    client.destroy();\n    t.end();\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"should return client instance","suites":[],"updatePoint":{"line":830,"column":35,"index":24239},"line":830,"code":"test('should return client instance', t => {\n  t.plan(1);\n  const caller = {};\n  const opts = server.address();\n  opts.auth = 'username:password';\n  const client = Client.call(caller, opts);\n  t.type(client, Client);\n  client.destroy();\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client calls twice using socket on secure server","suites":[],"updatePoint":{"line":839,"column":54,"index":24499},"line":839,"code":"test('client calls twice using socket on secure server', t => {\n  t.plan(4);\n  const socketPath = process.platform === 'win32' ? path.join('\\\\\\\\?\\\\pipe', process.cwd(), 'autocannon-' + Date.now()) : path.join(os.tmpdir(), 'autocannon-' + Date.now() + '.sock');\n  helper.startHttpsServer({\n    socketPath\n  });\n  const client = new Client({\n    url: 'localhost',\n    protocol: 'https:',\n    socketPath,\n    connections: 1\n  });\n  let count = 0;\n  client.on('response', (statusCode, length) => {\n    t.equal(statusCode, 200, 'status code matches');\n    t.ok(length > 'hello world'.length, 'length includes the headers');\n    if (count++ > 0) {\n      client.destroy();\n      t.end();\n    }\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client emits mistmatch when expectBody doesn't match actual body","suites":[],"updatePoint":{"line":861,"column":71,"index":25213},"line":861,"code":"test('client emits mistmatch when expectBody doesn\\'t match actual body', t => {\n  const responses = ['hello...', 'world!'];\n  const server = helper.startServer({\n    body: ({\n      method\n    }) => responses[method === 'POST' ? 0 : 1]\n  });\n  const opts = server.address();\n  opts.requests = [{\n    method: 'POST',\n    body: 'hi there!'\n  }, {\n    method: 'GET'\n  }];\n  opts.expectBody = responses[0];\n  const client = new Client(opts);\n  client.on('mismatch', body => {\n    // we expect body mismatch on second request\n    t.same(body, responses[1]);\n    client.destroy();\n    t.end();\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client invokes appropriate onResponse when using pipelining","suites":[],"updatePoint":{"line":884,"column":65,"index":25805},"line":884,"code":"test('client invokes appropriate onResponse when using pipelining', t => {\n  const server = helper.startServer({\n    body: ({\n      method\n    }) => method\n  });\n  const opts = server.address();\n  opts.pipelining = 2;\n  const responses = [];\n  const onResponse = (status, body) => responses.push(body);\n  opts.requests = [{\n    method: 'POST',\n    onResponse\n  }, {\n    method: 'GET',\n    onResponse\n  }, {\n    method: 'PUT',\n    onResponse\n  }];\n  const client = new Client(opts);\n  let number = 0;\n  client.on('response', (statusCode, length) => {\n    number++;\n    switch (number) {\n      case 1:\n        // 1st & 2nd were sent, receiving 1st\n        t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n          server,\n          method: 'GET'\n        }), 'current should be second request');\n        t.same(responses, ['POST']);\n        break;\n      case 2:\n        // 3rd was sent as 1st is finished, receiving 2nd\n        t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n          server,\n          method: 'PUT'\n        }), 'current should be third request');\n        t.same(responses, ['POST', 'GET']);\n        break;\n      case 3:\n        // 1st was resent, receiving 3rd\n        t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n          server,\n          method: 'POST'\n        }), 'current should be first request');\n        t.same(responses, ['POST', 'GET', 'PUT']);\n        break;\n      case 4:\n        // 2nd was resent, receiving 1st\n        t.same(client.getRequestBuffer().toString(), makeResponseFromBody({\n          server,\n          method: 'GET'\n        }), 'current should be second request');\n        t.same(responses, ['POST', 'GET', 'PUT', 'POST']);\n        client.destroy();\n        t.end();\n        break;\n    }\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"client supports receiving large response body","suites":[],"updatePoint":{"line":946,"column":51,"index":27596},"line":946,"code":"test('client supports receiving large response body', t => {\n  t.plan(2);\n  const mockBody = Array.from({\n    length: 1024 * 10\n  }, (_, i) => `str-${i}`).join('\\n');\n  const server = http.createServer((req, res) => {\n    res.end(mockBody);\n  });\n  server.listen(0);\n  server.unref();\n  let onResponseCalled = 0;\n  const opts = server.address();\n  opts.method = 'POST';\n  opts.body = Buffer.from('hello world');\n  opts.requests = [{\n    path: '/',\n    method: 'GET',\n    onResponse: (...args) => {\n      onResponseCalled++;\n    }\n  }];\n  const client = new Client(opts);\n  client.on('response', (statusCode, length) => {\n    t.equal(onResponseCalled, 1, 'onResponse should be called only once');\n    t.equal(statusCode, 200, 'status code matches');\n    client.destroy();\n  });\n});","file":"httpClient.test.js","skipped":false,"dir":"test"},{"name":"request builder should create a request with sensible defaults","suites":[],"updatePoint":{"line":8,"column":68,"index":303},"line":8,"code":"test('request builder should create a request with sensible defaults', t => {\n  t.plan(1);\n  const opts = server.address();\n  const build = RequestBuilder(opts);\n  const result = build();\n  t.same(result, Buffer.from(`GET / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\n\\r\\n`), 'request is okay');\n});","file":"httpRequestBuilder.test.js","skipped":false,"dir":"test"},{"name":"request builder should allow default overwriting","suites":[],"updatePoint":{"line":15,"column":54,"index":627},"line":15,"code":"test('request builder should allow default overwriting', t => {\n  t.plan(1);\n  const opts = server.address();\n  opts.method = 'POST';\n  const build = RequestBuilder(opts);\n  const result = build();\n  t.same(result, Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\n\\r\\n`), 'request is okay');\n});","file":"httpRequestBuilder.test.js","skipped":false,"dir":"test"},{"name":"request builder should allow per build overwriting","suites":[],"updatePoint":{"line":23,"column":56,"index":978},"line":23,"code":"test('request builder should allow per build overwriting', t => {\n  t.plan(1);\n  const opts = server.address();\n  opts.method = 'POST';\n  const build = RequestBuilder(opts);\n  const result = build({\n    method: 'GET'\n  });\n  t.same(result, Buffer.from(`GET / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\n\\r\\n`), 'request is okay');\n});","file":"httpRequestBuilder.test.js","skipped":false,"dir":"test"},{"name":"request builder should throw on unknown http method","suites":[],"updatePoint":{"line":33,"column":57,"index":1352},"line":33,"code":"test('request builder should throw on unknown http method', t => {\n  t.plan(1);\n  const opts = server.address();\n  const build = RequestBuilder(opts);\n  t.throws(() => build({\n    method: 'UNKNOWN'\n  }));\n});","file":"httpRequestBuilder.test.js","skipped":false,"dir":"test"},{"name":"request builder should accept all valid standard http methods","suites":[],"updatePoint":{"line":41,"column":67,"index":1571},"line":41,"code":"test('request builder should accept all valid standard http methods', t => {\n  t.plan(httpMethods.length);\n  httpMethods.forEach(method => {\n    const opts = server.address();\n    const build = RequestBuilder(opts);\n    t.doesNotThrow(() => build({\n      method\n    }), `${method} should be usable by the request builded`);\n  });\n  t.end();\n});","file":"httpRequestBuilder.test.js","skipped":false,"dir":"test"},{"name":"request builder should add a Content-Length header when the body buffer exists as a default override","suites":[],"updatePoint":{"line":52,"column":106,"index":1955},"line":52,"code":"test('request builder should add a Content-Length header when the body buffer exists as a default override', t => {\n  t.plan(1);\n  const opts = server.address();\n  opts.method = 'POST';\n  opts.body = 'body';\n  const build = RequestBuilder(opts);\n  const result = build();\n  t.same(result, Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 4\\r\\n\\r\\nbody`), 'request is okay');\n});","file":"httpRequestBuilder.test.js","skipped":false,"dir":"test"},{"name":"request builder should add a Content-Length header when the body buffer exists as per build override","suites":[],"updatePoint":{"line":61,"column":106,"index":2403},"line":61,"code":"test('request builder should add a Content-Length header when the body buffer exists as per build override', t => {\n  t.plan(1);\n  const opts = server.address();\n  opts.method = 'POST';\n  const build = RequestBuilder(opts);\n  const result = build({\n    body: 'body'\n  });\n  t.same(result, Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 4\\r\\n\\r\\nbody`), 'request is okay');\n});","file":"httpRequestBuilder.test.js","skipped":false,"dir":"test"},{"name":"request builder should add a Content-Length header with correct calculated value when the body buffer exists and idReplacement is enabled as a default override","suites":[],"updatePoint":{"line":71,"column":165,"index":2910},"line":71,"code":"test('request builder should add a Content-Length header with correct calculated value when the body buffer exists and idReplacement is enabled as a default override', t => {\n  t.plan(1);\n  const opts = server.address();\n  opts.method = 'POST';\n  opts.body = '[<id>]';\n  opts.idReplacement = true;\n  const build = RequestBuilder(opts);\n  const result = build();\n  t.same(result, Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 33\\r\\n\\r\\n[<id>]`), 'request is okay');\n});","file":"httpRequestBuilder.test.js","skipped":false,"dir":"test"},{"name":"request builder should add a Content-Length header with value \"[<contentLength>]\" when the body buffer exists and idReplacement is enabled as a per build override","suites":[],"updatePoint":{"line":81,"column":168,"index":3454},"line":81,"code":"test('request builder should add a Content-Length header with value \"[<contentLength>]\" when the body buffer exists and idReplacement is enabled as a per build override', t => {\n  t.plan(1);\n  const opts = server.address();\n  opts.method = 'POST';\n  opts.body = '[<id>]';\n  const build = RequestBuilder(opts);\n  const result = build({\n    idReplacement: true\n  });\n  t.same(result, Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 33\\r\\n\\r\\n[<id>]`), 'request is okay');\n});","file":"httpRequestBuilder.test.js","skipped":false,"dir":"test"},{"name":"request builder should allow http basic authentication","suites":[],"updatePoint":{"line":92,"column":60,"index":3890},"line":92,"code":"test('request builder should allow http basic authentication', t => {\n  t.plan(1);\n  const opts = server.address();\n  opts.auth = 'username:password';\n  const build = RequestBuilder(opts);\n  const result = build();\n  t.same(result, Buffer.from(`GET / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nAuthorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=\\r\\n\\r\\n`), 'request is okay');\n});","file":"httpRequestBuilder.test.js","skipped":false,"dir":"test"},{"name":"should throw error if body is not a string or a buffer","suites":[],"updatePoint":{"line":100,"column":60,"index":4304},"line":100,"code":"test('should throw error if body is not a string or a buffer', t => {\n  t.plan(1);\n  const opts = server.address();\n  const build = RequestBuilder(opts);\n  try {\n    build({\n      body: []\n    });\n  } catch (error) {\n    t.equal(error.message, 'body must be either a string or a buffer');\n  }\n});","file":"httpRequestBuilder.test.js","skipped":false,"dir":"test"},{"name":"--on-port flag","suites":[],"updatePoint":{"line":10,"column":20,"index":230},"line":10,"code":"test('--on-port flag', {\n  skip: !hasAsyncHooks()\n}, t => {\n  const lines = [/Running 1s test @ .*$/, /10 connections.*$/, /$/, /.*/, /$/, /Stat.*2\\.5%.*50%.*97\\.5%.*99%.*Avg.*Stdev.*Max.*$/, /.*/, /Latency.*$/, /$/, /.*/, /Stat.*1%.*2\\.5%.*50%.*97\\.5%.*Avg.*Stdev.*Min.*$/, /.*/, /Req\\/Sec.*$/, /$/, /Bytes\\/Sec.*$/, /.*/, /$/, /Req\\/Bytes counts sampled once per second.*$/, /# of samples: 10*$/, /$/, /.* requests in ([0-9]|\\.)+s, .* read/];\n  t.plan(lines.length * 2);\n  const child = spawn(process.execPath, [path.join(__dirname, '..'), '-c', '10', '-d', '1', '--on-port', '/', '--', 'node', path.join(__dirname, './targetProcess')], {\n    cwd: __dirname,\n    env: process.env,\n    stdio: ['ignore', 'pipe', 'pipe'],\n    detached: false\n  });\n  t.teardown(() => {\n    child.kill();\n  });\n  child.stderr.pipe(split()).on('data', line => {\n    const regexp = lines.shift();\n    t.ok(regexp, 'we are expecting this line');\n    t.ok(regexp.test(line), 'line matches ' + regexp);\n  });\n});","file":"onPort.test.js","skipped":false,"dir":"test"},{"name":"should throw on empty HAR","suites":[],"updatePoint":{"line":7,"column":31,"index":132},"line":7,"code":"test('should throw on empty HAR', t => {\n  t.plan(1);\n  t.throws(() => parseHAR(null), /Could not parse HAR content: no entries found/);\n  t.end();\n});","file":"parseHAR.test.js","skipped":false,"dir":"test"},{"name":"should throw on HAR with no entries","suites":[],"updatePoint":{"line":12,"column":41,"index":294},"line":12,"code":"test('should throw on HAR with no entries', t => {\n  t.plan(1);\n  t.throws(() => parseHAR({\n    log: {\n      version: '1.2',\n      creator: {\n        name: 'Firefox',\n        version: '80.0.1'\n      },\n      pages: [{\n        startedDateTime: '2020-09-28T16:43:28.987+02:00',\n        id: 'page_1',\n        title: 'mcollina/autocannon: fast HTTP/1.1 benchmarking tool written in Node.js',\n        pageTimings: {\n          onContentLoad: 1234,\n          onLoad: 1952\n        }\n      }]\n    }\n  }), /Could not parse HAR content: no entries found/);\n  t.end();\n});","file":"parseHAR.test.js","skipped":false,"dir":"test"},{"name":"should throw on HAR with empty entries","suites":[],"updatePoint":{"line":34,"column":44,"index":858},"line":34,"code":"test('should throw on HAR with empty entries', t => {\n  t.plan(1);\n  t.throws(() => parseHAR({\n    log: {\n      version: '1.2',\n      creator: {\n        name: 'Firefox',\n        version: '80.0.1'\n      },\n      pages: [{\n        startedDateTime: '2020-09-28T16:43:28.987+02:00',\n        id: 'page_1',\n        title: 'mcollina/autocannon: fast HTTP/1.1 benchmarking tool written in Node.js',\n        pageTimings: {\n          onContentLoad: 1234,\n          onLoad: 1952\n        }\n      }],\n      entries: []\n    }\n  }), /Could not parse HAR content: no entries found/);\n  t.end();\n});","file":"parseHAR.test.js","skipped":false,"dir":"test"},{"name":"should parse and return GET entries","suites":[],"updatePoint":{"line":57,"column":41,"index":1438},"line":57,"code":"test('should parse and return GET entries', t => {\n  t.plan(1);\n  t.strictSame(parseHAR(require('./fixtures/httpbin-get.json')).get('https://httpbin.org'), [{\n    method: 'GET',\n    origin: 'https://httpbin.org',\n    path: '/get',\n    headers: {\n      Host: 'httpbin.org',\n      'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:80.0) Gecko/20100101 Firefox/80.0',\n      Accept: '*/*',\n      'Accept-Language': 'fr,en;q=0.5',\n      'Accept-Encoding': 'gzip, deflate, br',\n      Referer: 'https://httpbin.org/',\n      DNT: '1',\n      Connection: 'keep-alive'\n    }\n  }, {\n    method: 'GET',\n    origin: 'https://httpbin.org',\n    path: '/get?from=10&size=20&sort=+name',\n    headers: {\n      Host: 'httpbin.org',\n      'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:80.0) Gecko/20100101 Firefox/80.0',\n      Accept: '*/*',\n      'Accept-Language': 'fr,en;q=0.5',\n      'Accept-Encoding': 'gzip, deflate, br',\n      Referer: 'https://httpbin.org/',\n      DNT: '1',\n      Connection: 'keep-alive',\n      TE: 'Trailers'\n    }\n  }]);\n  t.end();\n});","file":"parseHAR.test.js","skipped":false,"dir":"test"},{"name":"should throw on HAR with invalid entries","suites":[],"updatePoint":{"line":91,"column":46,"index":2506},"line":91,"code":"test('should throw on HAR with invalid entries', t => {\n  t.plan(2);\n  t.throws(() => parseHAR({\n    log: {\n      entries: ['invalid']\n    }\n  }), /Could not parse HAR content: invalid request in entry #1/);\n  t.throws(() => parseHAR({\n    log: {\n      entries: [{\n        request: {\n          headers: [],\n          url: 'http://localhost'\n        }\n      }, {\n        request: null\n      }]\n    }\n  }), /Could not parse HAR content: invalid request in entry #2/);\n  t.end();\n});","file":"parseHAR.test.js","skipped":false,"dir":"test"},{"name":"should throw on HAR with invalid headers","suites":[],"updatePoint":{"line":112,"column":46,"index":2987},"line":112,"code":"test('should throw on HAR with invalid headers', t => {\n  t.plan(2);\n  const url = 'http://localhost';\n  t.throws(() => parseHAR({\n    log: {\n      entries: [{\n        request: {\n          headers: [],\n          url\n        }\n      }, {\n        request: {\n          headers: ['foo'],\n          url\n        }\n      }]\n    }\n  }), /Could not parse HAR content: invalid name or value in header #1 of entry #2/);\n  t.throws(() => parseHAR({\n    log: {\n      entries: [{\n        request: {\n          headers: null\n        }\n      }]\n    }\n  }), /Could not parse HAR content: invalid headers array in entry #1/);\n  t.end();\n});","file":"parseHAR.test.js","skipped":false,"dir":"test"},{"name":"should parse and return POST entries","suites":[],"updatePoint":{"line":141,"column":42,"index":3605},"line":141,"code":"test('should parse and return POST entries', t => {\n  t.plan(1);\n  t.strictSame(parseHAR(require('./fixtures/httpbin-post.json')).get('https://httpbin.org'), [{\n    method: 'POST',\n    origin: 'https://httpbin.org',\n    path: '/post',\n    headers: {\n      Host: 'httpbin.org',\n      'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:80.0) Gecko/20100101 Firefox/80.0',\n      Accept: '*/*',\n      'Accept-Language': 'fr,en;q=0.5',\n      'Accept-Encoding': 'gzip, deflate, br',\n      Referer: 'https://httpbin.org/',\n      'Content-Type': 'multipart/form-data; boundary=---------------------------31420230025845772252453285324',\n      Origin: 'https://httpbin.org',\n      'Content-Length': '362',\n      DNT: '1',\n      Connection: 'keep-alive',\n      TE: 'Trailers'\n    },\n    body: '-----------------------------31420230025845772252453285324\\r\\nContent-Disposition: form-data; name=\"text\"\\r\\n\\r\\na text value\\r\\n-----------------------------31420230025845772252453285324\\r\\nContent-Disposition: form-data; name=\"file\"; filename=\"blob\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\nHello World!\\n\\r\\n-----------------------------31420230025845772252453285324--\\r\\n'\n  }, {\n    method: 'POST',\n    origin: 'https://httpbin.org',\n    path: '/post',\n    headers: {\n      Host: 'httpbin.org',\n      'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:80.0) Gecko/20100101 Firefox/80.0',\n      Accept: '*/*',\n      'Accept-Language': 'fr,en;q=0.5',\n      'Accept-Encoding': 'gzip, deflate, br',\n      Referer: 'https://httpbin.org/',\n      'Content-Type': 'application/x-www-form-urlencoded',\n      Origin: 'https://httpbin.org',\n      'Content-Length': '27',\n      DNT: '1',\n      Connection: 'keep-alive',\n      TE: 'Trailers'\n    },\n    body: 'text=a+text+value&number=10'\n  }]);\n  t.end();\n});","file":"parseHAR.test.js","skipped":false,"dir":"test"},{"name":"should split requests per origin","suites":[],"updatePoint":{"line":184,"column":38,"index":5409},"line":184,"code":"test('should split requests per origin', t => {\n  t.plan(2);\n  const requetsPerOrigin = parseHAR(require('./fixtures/multi-domains.json'));\n  t.strictSame(requetsPerOrigin.get('https://httpbin.org'), [{\n    method: 'POST',\n    origin: 'https://httpbin.org',\n    path: '/post',\n    headers: {\n      Host: 'httpbin.org',\n      'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:80.0) Gecko/20100101 Firefox/80.0',\n      Accept: '*/*',\n      'Accept-Language': 'fr,en;q=0.5',\n      'Accept-Encoding': 'gzip, deflate, br',\n      Referer: 'https://httpbin.org/',\n      'Content-Type': 'multipart/form-data; boundary=---------------------------31420230025845772252453285324',\n      Origin: 'https://httpbin.org',\n      'Content-Length': '362',\n      DNT: '1',\n      Connection: 'keep-alive',\n      TE: 'Trailers'\n    },\n    body: '-----------------------------31420230025845772252453285324\\r\\nContent-Disposition: form-data; name=\"text\"\\r\\n\\r\\na text value\\r\\n-----------------------------31420230025845772252453285324\\r\\nContent-Disposition: form-data; name=\"file\"; filename=\"blob\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\nHello World!\\n\\r\\n-----------------------------31420230025845772252453285324--\\r\\n'\n  }, {\n    method: 'GET',\n    origin: 'https://httpbin.org',\n    path: '/get?from=10&size=20&sort=+name',\n    headers: {\n      Host: 'httpbin.org',\n      'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:80.0) Gecko/20100101 Firefox/80.0',\n      Accept: '*/*',\n      'Accept-Language': 'fr,en;q=0.5',\n      'Accept-Encoding': 'gzip, deflate, br',\n      Referer: 'https://httpbin.org/',\n      DNT: '1',\n      Connection: 'keep-alive',\n      TE: 'Trailers'\n    }\n  }]);\n  t.strictSame(requetsPerOrigin.get('https://github.com'), [{\n    method: 'POST',\n    origin: 'https://github.com',\n    path: '/',\n    headers: {\n      Host: 'github.com',\n      'User-Agent': 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:80.0) Gecko/20100101 Firefox/80.0',\n      Accept: '*/*',\n      'Accept-Language': 'fr,en;q=0.5',\n      'Accept-Encoding': 'gzip, deflate, br',\n      Referer: 'https://github.com/',\n      'Content-Type': 'application/x-www-form-urlencoded',\n      Origin: 'https://github.com',\n      'Content-Length': '27',\n      DNT: '1',\n      Connection: 'keep-alive',\n      TE: 'Trailers'\n    },\n    body: 'text=a+text+value&number=10'\n  }]);\n  t.end();\n});","file":"parseHAR.test.js","skipped":false,"dir":"test"},{"name":"PipelinedRequestsQueue measures time precisely","suites":[],"updatePoint":{"line":5,"column":52,"index":175},"line":5,"code":"test('PipelinedRequestsQueue measures time precisely', t => {\n  t.plan(2);\n  const delay = 42;\n  const queue = new PipelinedRequestsQueue();\n  const startTime = process.hrtime();\n  queue.insertRequest();\n  setTimeout(() => {\n    const data = queue.terminateRequest();\n    t.ok(data.duration > delay, `Calculated duration ${data.duration} should not be less than the induced delay ${delay}`);\n    const hrduration = process.hrtime(startTime);\n    const maxExpectedDuration = Math.ceil(hrduration[0] * 1e3 + hrduration[1] / 1e6);\n    t.ok(data.duration <= maxExpectedDuration, `Calculated duration ${data.duration} should be less than the max expected duration ${maxExpectedDuration}`);\n  }, delay);\n});","file":"pipelinedRequestsQueue.test.js","skipped":false,"dir":"test"},{"name":"PipelinedRequestsQueue is a queue/FIFO","suites":[],"updatePoint":{"line":19,"column":44,"index":869},"line":19,"code":"test('PipelinedRequestsQueue is a queue/FIFO', t => {\n  const COUNT = 3;\n  t.plan(COUNT);\n  const queue = new PipelinedRequestsQueue();\n  let count = COUNT;\n  while (count > 0) {\n    queue.insertRequest(count--);\n  }\n  count = COUNT;\n  while (count > 0) {\n    t.equal(queue.terminateRequest().req, count--);\n  }\n});","file":"pipelinedRequestsQueue.test.js","skipped":false,"dir":"test"},{"name":"PipelinedRequestsQueue.clear() empties the queue","suites":[],"updatePoint":{"line":32,"column":54,"index":1195},"line":32,"code":"test('PipelinedRequestsQueue.clear() empties the queue', t => {\n  t.plan(5);\n  const queue = new PipelinedRequestsQueue();\n  t.equal(queue.size(), 0);\n  t.equal(queue.toArray().length, 0);\n  queue.insertRequest();\n  queue.insertRequest();\n  queue.insertRequest();\n  t.equal(queue.size(), 3);\n  t.equal(queue.toArray().length, 3);\n  queue.clear();\n  t.equal(queue.terminateRequest(), undefined);\n});","file":"pipelinedRequestsQueue.test.js","skipped":false,"dir":"test"},{"name":"PipelinedRequestsQueue methods set values to the request in first-in-last-out order","suites":[],"updatePoint":{"line":45,"column":89,"index":1629},"line":45,"code":"test('PipelinedRequestsQueue methods set values to the request in first-in-last-out order', t => {\n  t.plan(6);\n  const queue = new PipelinedRequestsQueue();\n  queue.insertRequest(1);\n  queue.insertRequest(2);\n  queue.addBody('1');\n  queue.addByteCount(1);\n  queue.setHeaders({\n    val: '1'\n  });\n  const req1 = queue.terminateRequest();\n  t.equal(req1.req, 1);\n  t.equal(req1.body, '1');\n  t.same(req1.headers, {\n    val: '1'\n  });\n  queue.addBody('2');\n  queue.addByteCount(2);\n  queue.setHeaders({\n    val: '2'\n  });\n  const req2 = queue.terminateRequest();\n  t.equal(req2.req, 2);\n  t.equal(req2.body, '2');\n  t.same(req2.headers, {\n    val: '2'\n  });\n});","file":"pipelinedRequestsQueue.test.js","skipped":false,"dir":"test"},{"name":"should stdout (print) the result","suites":[],"updatePoint":{"line":7,"column":38,"index":198},"line":7,"code":"test('should stdout (print) the result', t => {\n  const lines = [/.*/, /$/, /Stat.*2\\.5%.*50%.*97\\.5%.*99%.*Avg.*Stdev.*Max.*$/, /.*/, /Latency.*$/, /$/, /.*/, /Stat.*1%.*2\\.5%.*50%.*97\\.5%.*Avg.*Stdev.*Min.*$/, /.*/, /Req\\/Sec.*$/, /.*/, /Bytes\\/Sec.*$/, /.*/, /.*/, /Code.*Count.*$/, /.*/, /200.*500.*$/, /.*/, /302.*0.*$/, /.*/, /401.*0.*$/, /.*/, /403.*0.*$/, /.*/, /$/, /Req\\/Bytes counts sampled once per second.*$/, /# of samples: 10.*$/, /$/, /.* requests in ([0-9]|\\.)+s, .* read/];\n  t.plan(lines.length * 2);\n  const child = childProcess.spawn(process.execPath, [path.join(__dirname, 'printResult-process.js'), '--renderStatusCodes', 'http://127.0.0.1'], {\n    cwd: __dirname,\n    env: process.env,\n    stdio: ['ignore', 'pipe', 'pipe'],\n    detached: false\n  });\n  t.teardown(() => {\n    child.kill();\n  });\n  child.stderr.pipe(split()).on('data', line => {\n    const regexp = lines.shift();\n    t.ok(regexp, 'we are expecting this line');\n    t.ok(regexp.test(line), 'line matches ' + regexp);\n  }).on('end', t.end);\n});","file":"printResult-renderStatusCodes.test.js","skipped":false,"dir":"test"},{"name":"should stdout (print) the result","suites":[],"updatePoint":{"line":8,"column":38,"index":249},"line":8,"code":"test('should stdout (print) the result', t => {\n  const lines = [/.*/, /$/, /Stat.*2\\.5%.*50%.*97\\.5%.*99%.*Avg.*Stdev.*Max.*$/, /.*/, /Latency.*$/, /$/, /.*/, /Stat.*1%.*2\\.5%.*50%.*97\\.5%.*Avg.*Stdev.*Min.*$/, /.*/, /Req\\/Sec.*$/, /.*/, /Bytes\\/Sec.*$/, /.*/, /$/, /Req\\/Bytes counts sampled once per second.*$/, /# of samples: 10*$/, /$/, /.* requests in ([0-9]|\\.)+s, .* read/];\n  t.plan(lines.length * 2);\n  const child = childProcess.spawn(process.execPath, [path.join(__dirname, 'printResult-process.js')], {\n    cwd: __dirname,\n    env: process.env,\n    stdio: ['ignore', 'pipe', 'pipe'],\n    detached: false\n  });\n  t.teardown(() => {\n    child.kill();\n  });\n  child.stderr.pipe(split()).on('data', line => {\n    const regexp = lines.shift();\n    t.ok(regexp, 'we are expecting this line');\n    t.ok(regexp.test(line), 'line matches ' + regexp);\n  }).on('end', t.end);\n});","file":"printResult.test.js","skipped":false,"dir":"test"},{"name":"verify amount of total requests","suites":[],"updatePoint":{"line":26,"column":37,"index":1130},"line":26,"code":"test('verify amount of total requests', t => {\n  t.plan(1);\n\n  // arrange\n  const connections = 10;\n  const pipelining = 2;\n  const result = {\n    connections,\n    pipelining,\n    latency: {},\n    requests: {\n      sent: connections * pipelining\n    },\n    throughput: {\n      average: 3319,\n      mean: 3319,\n      stddev: 0,\n      min: 3318,\n      max: 3318,\n      total: 3318,\n      p0_001: 3319,\n      p0_01: 3319,\n      p0_1: 3319,\n      p1: 3319,\n      p2_5: 3319,\n      p10: 3319,\n      p25: 3319,\n      p50: 3319,\n      p75: 3319,\n      p90: 3319,\n      p97_5: 3319,\n      p99: 3319,\n      p99_9: 3319,\n      p99_99: 3319,\n      p99_999: 3319\n    }\n  };\n\n  // act\n  const output = printResult(result, {});\n\n  // assert\n  const expectedRequests = connections * pipelining;\n  t.match(output.includes(`${expectedRequests} requests in`), true);\n});","file":"printResult.test.js","skipped":false,"dir":"test"},{"name":"should not emit warnings when using >=  workers","suites":[],"updatePoint":{"line":16,"column":75,"index":388},"line":16,"code":"test(`should not emit warnings when using >= ${defaultMaxListeners} workers`, {\n  skip: !hasWorkerSupport\n}, t => {\n  const server = helper.startServer();\n  const instance = autocannon({\n    url: `http://localhost:${server.address().port}`,\n    workers: defaultMaxListeners,\n    duration: 1\n  });\n  setTimeout(() => {\n    instance.stop();\n    t.notOk(emitWarningSpy.called);\n    emitWarningSpy.restore();\n    t.end();\n  }, 2000);\n  const emitWarningSpy = sinon.spy(process, 'emitWarning');\n  autocannon.track(instance, {\n    outputStream: new Writable({\n      write() {}\n    })\n  });\n});","file":"progressTracker.test.js","skipped":false,"dir":"test"},{"name":"request iterator should create requests with sensible defaults","suites":[],"updatePoint":{"line":7,"column":68,"index":250},"line":7,"code":"test('request iterator should create requests with sensible defaults', t => {\n  t.plan(3);\n  const opts = server.address();\n  let iterator = new RequestIterator(opts);\n  t.same(iterator.currentRequest.requestBuffer, Buffer.from(`GET / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\n\\r\\n`), 'request is okay');\n  opts.requests = [{}];\n  iterator = new RequestIterator(opts);\n  t.same(iterator.currentRequest.requestBuffer, Buffer.from(`GET / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\n\\r\\n`), 'request is okay');\n  opts.requests = [];\n  iterator = new RequestIterator(opts);\n  t.notOk(iterator.currentRequest, 'request doesn\\'t exist');\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"request iterator should create requests with overwritten defaults","suites":[],"updatePoint":{"line":19,"column":71,"index":967},"line":19,"code":"test('request iterator should create requests with overwritten defaults', t => {\n  t.plan(1);\n  const opts = server.address();\n  opts.method = 'POST';\n  const iterator = new RequestIterator(opts);\n  t.same(iterator.currentRequest.requestBuffer, Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\n\\r\\n`), 'request is okay');\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"request iterator should use headers from requests","suites":[],"updatePoint":{"line":26,"column":55,"index":1330},"line":26,"code":"test('request iterator should use headers from requests', t => {\n  t.plan(2);\n  const opts = server.address();\n  opts.requests = [{\n    path: '/',\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json'\n    },\n    body: JSON.stringify({\n      foo: 'bar'\n    })\n  }, {\n    path: '/2',\n    method: 'POST',\n    headers: {\n      'content-type': 'text/html'\n    },\n    body: JSON.stringify({\n      foo: 'bar'\n    })\n  }];\n  const iterator = new RequestIterator(opts);\n  t.same(iterator.currentRequest.headers['content-type'], 'application/json');\n  iterator.nextRequest();\n  t.same(iterator.currentRequest.headers['content-type'], 'text/html');\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"request iterator should create requests with overwritten defaults","suites":[],"updatePoint":{"line":53,"column":71,"index":2010},"line":53,"code":"test('request iterator should create requests with overwritten defaults', t => {\n  t.plan(3);\n  const opts = server.address();\n  opts.method = 'POST';\n  const requests = [{\n    body: 'hello world'\n  }, {\n    method: 'GET',\n    body: 'modified'\n  }];\n  const request1Res = Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 11\\r\\n\\r\\nhello world`);\n  const request2Res = Buffer.from(`GET / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 8\\r\\n\\r\\nmodified`);\n  opts.requests = requests;\n  const iterator = new RequestIterator(opts);\n  t.same(iterator.currentRequest.requestBuffer, request1Res, 'request was okay');\n  iterator.nextRequest();\n  t.same(iterator.currentRequest.requestBuffer, request2Res, 'request was okay');\n  iterator.nextRequest();\n  t.same(iterator.currentRequest.requestBuffer, request1Res, 'request was okay');\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"request iterator should allow for overwriting the requests passed in, but still use overwritten defaults","suites":[],"updatePoint":{"line":73,"column":110,"index":3000},"line":73,"code":"test('request iterator should allow for overwriting the requests passed in, but still use overwritten defaults', t => {\n  t.plan(5);\n  const opts = server.address();\n  opts.method = 'POST';\n  const requests1 = [{\n    body: 'hello world'\n  }, {\n    method: 'GET',\n    body: 'modified'\n  }];\n  const requests2 = [{\n    body: 'hell0 w0rld'\n  }];\n  const request1Res = Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 11\\r\\n\\r\\nhello world`);\n  const request2Res = Buffer.from(`GET / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 8\\r\\n\\r\\nmodified`);\n  const request3Res = Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 11\\r\\n\\r\\nhell0 w0rld`);\n  opts.requests = requests1;\n  const iterator = new RequestIterator(opts);\n  t.same(iterator.currentRequest.requestBuffer, request1Res, 'request was okay');\n  iterator.nextRequest();\n  t.same(iterator.currentRequest.requestBuffer, request2Res, 'request was okay');\n  iterator.nextRequest();\n  t.same(iterator.currentRequest.requestBuffer, request1Res, 'request was okay');\n  iterator.setRequests(requests2);\n  t.same(iterator.currentRequest.requestBuffer, request3Res, 'request was okay');\n  iterator.nextRequest();\n  t.same(iterator.currentRequest.requestBuffer, request3Res, 'request was okay');\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"request iterator should allow for rebuilding the current request","suites":[],"updatePoint":{"line":101,"column":70,"index":4395},"line":101,"code":"test('request iterator should allow for rebuilding the current request', t => {\n  t.plan(6);\n  const opts = server.address();\n  opts.method = 'POST';\n  const requests1 = [{\n    body: 'hello world'\n  }, {\n    method: 'GET',\n    body: 'modified'\n  }];\n  const request1Res = Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 11\\r\\n\\r\\nhello world`);\n  const request2Res = Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 8\\r\\n\\r\\nmodified`);\n  const request3Res = Buffer.from(`GET / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 8\\r\\n\\r\\nmodified`);\n  const request4Res = Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nheader: modifiedHeader\\r\\nContent-Length: 8\\r\\n\\r\\nmodified`);\n  const request5Res = Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nheader: modifiedHeader\\r\\n\\r\\n`);\n  opts.requests = requests1;\n  const iterator = new RequestIterator(opts);\n  t.same(iterator.currentRequest.requestBuffer, request1Res, 'request was okay');\n  iterator.setBody('modified');\n  t.same(iterator.currentRequest.requestBuffer, request2Res, 'request was okay');\n  iterator.nextRequest(); // verify it didn't affect the other request\n  t.same(iterator.currentRequest.requestBuffer, request3Res, 'request was okay');\n  iterator.nextRequest();\n  t.same(iterator.currentRequest.requestBuffer, request2Res, 'request was okay');\n  iterator.setHeaders({\n    header: 'modifiedHeader'\n  });\n  t.same(iterator.currentRequest.requestBuffer, request4Res, 'request was okay');\n  iterator.setRequest(); // this should build default request\n  t.same(iterator.currentRequest.requestBuffer, request5Res, 'request was okay');\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"request iterator should not replace any [<id>] tags with generated IDs when calling move with idReplacement disabled","suites":[],"updatePoint":{"line":132,"column":122,"index":6349},"line":132,"code":"test('request iterator should not replace any [<id>] tags with generated IDs when calling move with idReplacement disabled', t => {\n  t.plan(2);\n  const opts = server.address();\n  opts.method = 'POST';\n  opts.body = '[<id>]';\n  opts.requests = [{}];\n  const iterator = new RequestIterator(opts);\n  const result = iterator.currentRequest.requestBuffer.toString().trim();\n  const contentLength = result.split('Content-Length: ')[1].slice(0, 1);\n  t.equal(contentLength, '6', 'Content-Length was incorrect');\n  const body = result.split('Content-Length: 6')[1].trim();\n  t.equal(body, '[<id>]', '[<id>] should be present in body');\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"request iterator should replace all [<id>] tags with generated IDs when calling move with idReplacement enabled","suites":[],"updatePoint":{"line":145,"column":117,"index":6977},"line":145,"code":"test('request iterator should replace all [<id>] tags with generated IDs when calling move with idReplacement enabled', t => {\n  t.plan(4);\n  const opts = server.address();\n  opts.method = 'POST';\n  opts.body = '[<id>]';\n  opts.requests = [{}];\n  opts.idReplacement = true;\n  const iterator = new RequestIterator(opts);\n  const first = iterator.currentRequest.requestBuffer.toString().trim();\n  t.equal(first.includes('[<id>]'), false, 'One or more [<id>] tags were not replaced');\n  t.equal(first.slice(-1), '0', 'Generated ID should end with request number');\n  iterator.nextRequest();\n  const second = iterator.currentRequest.requestBuffer.toString().trim();\n  t.equal(second.includes('[<id>]'), false, 'One or more [<id>] tags were not replaced');\n  t.equal(second.slice(-1), '1', 'Generated ID should end with a unique request number');\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"request iterator should invoke onResponse callback when set","suites":[],"updatePoint":{"line":161,"column":65,"index":7771},"line":161,"code":"test('request iterator should invoke onResponse callback when set', t => {\n  t.plan(9);\n  const opts = server.address();\n  opts.requests = [{\n    onResponse: (status, body, context) => {\n      t.same(status, 200);\n      t.same(body, 'ok');\n      t.same(context, {});\n    }\n  }, {}, {\n    onResponse: (status, body, context) => {\n      t.same(status, 201);\n      t.same(body, '');\n      t.same(context, {});\n    }\n  }];\n  const iterator = new RequestIterator(opts);\n  iterator.recordBody(iterator.currentRequest, 200, 'ok');\n  iterator.nextRequest();\n  iterator.recordBody(iterator.currentRequest, 500, 'ignored');\n  iterator.nextRequest();\n  iterator.recordBody(iterator.currentRequest, 201, '');\n  // will reset the iterator\n  iterator.nextRequest();\n  iterator.recordBody(iterator.currentRequest, 200, 'ok');\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"request iterator should properly mutate requests if a setupRequest function is located","suites":[],"updatePoint":{"line":187,"column":92,"index":8613},"line":187,"code":"test('request iterator should properly mutate requests if a setupRequest function is located', t => {\n  t.plan(6);\n  const opts = server.address();\n  opts.method = 'POST';\n  let i = 0;\n  opts.requests = [{\n    body: 'hello world',\n    setupRequest: req => {\n      req.body += i++;\n      return req;\n    }\n  }, {\n    method: 'POST',\n    body: 'modified',\n    setupRequest: req => {\n      req.method = 'GET';\n      return req;\n    }\n  }];\n  const request1Res = Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 12\\r\\n\\r\\nhello world0`);\n  const request2Res = Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 9\\r\\n\\r\\nmodified1`);\n  const request3Res = Buffer.from(`GET / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 8\\r\\n\\r\\nmodified`);\n  const request4Res = Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 9\\r\\n\\r\\nmodified2`);\n  const request5Res = Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nheader: modifiedHeader\\r\\nContent-Length: 9\\r\\n\\r\\nmodified3`);\n  const request6Res = Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nheader: modifiedHeader\\r\\n\\r\\n`);\n  const iterator = new RequestIterator(opts);\n  t.same(iterator.currentRequest.requestBuffer, request1Res, 'request was okay');\n  iterator.setBody('modified');\n  t.same(iterator.currentRequest.requestBuffer, request2Res, 'request was okay');\n  iterator.nextRequest(); // verify it didn't affect the other request\n  t.same(iterator.currentRequest.requestBuffer, request3Res, 'request was okay');\n  iterator.nextRequest();\n  t.same(iterator.currentRequest.requestBuffer, request4Res, 'request was okay');\n  iterator.setHeaders({\n    header: 'modifiedHeader'\n  });\n  t.same(iterator.currentRequest.requestBuffer, request5Res, 'request was okay');\n  iterator.setRequest(); // this should build default request\n  t.same(iterator.currentRequest.requestBuffer, request6Res, 'request was okay');\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"request iterator should reset when setupRequest returns nothing","suites":[],"updatePoint":{"line":227,"column":69,"index":10815},"line":227,"code":"test('request iterator should reset when setupRequest returns nothing', t => {\n  t.plan(12);\n  const opts = server.address();\n  opts.method = 'POST';\n  let i = 0;\n  opts.requests = [{\n    method: 'GET'\n  }, {\n    body: 'hello world',\n    setupRequest: req => ++i >= 2 ? null : req\n  }, {\n    method: 'PUT'\n  }];\n  const requestGET = `GET / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\n\\r\\n`;\n  const requestPUT = `PUT / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\n\\r\\n`;\n  const requestPOST = `POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 11\\r\\n\\r\\nhello world`;\n  const iterator = new RequestIterator(opts);\n  t.equal(iterator.resetted, false);\n  // first GET, i is 0\n  t.same(iterator.currentRequest.requestBuffer.toString(), requestGET, 'request 1 was okay');\n  iterator.nextRequest();\n  // first POST, i becomes 1\n  t.equal(iterator.resetted, false);\n  t.same(iterator.currentRequest.requestBuffer.toString(), requestPOST, 'request 2 was okay');\n  iterator.nextRequest();\n  // first PUT, i is 1\n  t.equal(iterator.resetted, false);\n  t.same(iterator.currentRequest.requestBuffer.toString(), requestPUT, 'request 3 was okay');\n  iterator.nextRequest();\n  // second GET, i is 1\n  t.equal(iterator.resetted, false);\n  t.same(iterator.currentRequest.requestBuffer.toString(), requestGET, 'request 4 was okay');\n  iterator.nextRequest();\n  // second POST, i becomes 2, pipeline is reset\n  t.equal(iterator.resetted, true);\n  t.same(iterator.currentRequest.requestBuffer.toString(), requestGET, 'request 5 was okay');\n  iterator.nextRequest();\n  // third POST, i becomes 3, pipeline is reset\n  t.equal(iterator.resetted, true);\n  t.same(iterator.currentRequest.requestBuffer.toString(), requestGET, 'request 6 was okay');\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"request iterator should throw when first setupRequest returns nothing","suites":[],"updatePoint":{"line":268,"column":75,"index":12680},"line":268,"code":"test('request iterator should throw when first setupRequest returns nothing', t => {\n  t.plan(4);\n  const opts = server.address();\n  opts.method = 'POST';\n  let i = 0;\n  opts.requests = [{\n    body: 'hello world',\n    setupRequest: req => ++i > 1 ? null : req\n  }];\n  const requestPOST = `POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 11\\r\\n\\r\\nhello world`;\n  const iterator = new RequestIterator(opts);\n  t.equal(iterator.resetted, false);\n  // first POST, i is 0\n  t.same(iterator.currentRequest.requestBuffer.toString(), requestPOST, 'request 1 was okay');\n  t.throws(() => iterator.nextRequest(), 'First setupRequest() failed did not returned valid request. Stopping');\n  t.equal(iterator.resetted, false);\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"request iterator should maintain context while looping on requests","suites":[],"updatePoint":{"line":285,"column":72,"index":13452},"line":285,"code":"test('request iterator should maintain context while looping on requests', t => {\n  t.plan(4);\n  const opts = server.address();\n  opts.requests = [{\n    setupRequest: (req, context) => {\n      t.same(context, {}, 'context was supposed to be empty for first request');\n      context.num = 1;\n      context.init = true;\n      return req;\n    }\n  }, {\n    setupRequest: (req, context) => {\n      t.same(context, {\n        num: 1,\n        init: true\n      }, 'context was supposed to be initialized for second request');\n      context.num++;\n      return req;\n    }\n  }, {\n    setupRequest: (req, context) => {\n      t.same(context, {\n        num: 2,\n        init: true\n      }, 'context was supposed to be initialized for third request');\n      context.num++;\n      return req;\n    }\n  }];\n  const iterator = new RequestIterator(opts);\n  iterator.nextRequest();\n  iterator.nextRequest();\n  // will reset the iterator\n  iterator.nextRequest();\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"request iterator should return instance of RequestIterator","suites":[],"updatePoint":{"line":320,"column":64,"index":14388},"line":320,"code":"test('request iterator should return instance of RequestIterator', t => {\n  t.plan(1);\n  const caller = {};\n  const opts = server.address();\n  const iterator = RequestIterator.call(caller, opts);\n  t.type(iterator, RequestIterator);\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"request iterator should return next request buffer","suites":[],"updatePoint":{"line":327,"column":56,"index":14617},"line":327,"code":"test('request iterator should return next request buffer', t => {\n  t.plan(1);\n  const opts = server.address();\n  opts.method = 'POST';\n  const requests = [{\n    body: 'hello world'\n  }, {\n    method: 'GET',\n    body: 'modified'\n  }];\n  const request2Res = Buffer.from(`GET / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nContent-Length: 8\\r\\n\\r\\nmodified`);\n  opts.requests = requests;\n  const iterator = new RequestIterator(opts);\n  const buffer = iterator.nextRequestBuffer();\n  t.same(request2Res, buffer, 'request is okay');\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"request iterator should initialize context from options","suites":[],"updatePoint":{"line":343,"column":61,"index":15192},"line":343,"code":"test('request iterator should initialize context from options', t => {\n  t.plan(3);\n  const opts = server.address();\n  opts.initialContext = {\n    foo: 'bar'\n  };\n  opts.requests = [{\n    setupRequest: (req, context) => {\n      t.same(context, {\n        foo: 'bar'\n      }, 'context should be initialized from opts');\n      context.baz = 'qux';\n      return req;\n    }\n  }, {\n    setupRequest: (req, context) => {\n      t.same(context, {\n        foo: 'bar',\n        baz: 'qux'\n      }, 'context should contain updated data');\n      return req;\n    }\n  }];\n  const iterator = new RequestIterator(opts);\n  iterator.nextRequest();\n  // will reset and reinit context\n  iterator.nextRequest();\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"request iterator should use the same headers when set","suites":[],"updatePoint":{"line":371,"column":59,"index":15883},"line":371,"code":"test('request iterator should use the same headers when set', t => {\n  t.plan(6);\n  const opts = server.address();\n  opts.method = 'POST';\n  let i = 0;\n  opts.requests = [{\n    body: 'hello world',\n    setupRequest: req => {\n      req.body += i++;\n      return req;\n    }\n  }, {\n    method: 'POST',\n    body: 'modified',\n    setupRequest: req => {\n      req.method = 'GET';\n      return req;\n    }\n  }];\n  const request1Res = Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nAccess-Control-Allow-Credentials: true\\r\\nContent-Length: 12\\r\\n\\r\\nhello world1`);\n  const request2Res = Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nAccess-Control-Allow-Credentials: true\\r\\nContent-Length: 12\\r\\n\\r\\nhello world1`);\n  const request3Res = Buffer.from(`GET / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nAccess-Control-Allow-Credentials: true\\r\\nContent-Length: 8\\r\\n\\r\\nmodified`);\n  const request4Res = Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nAccess-Control-Allow-Credentials: true\\r\\nContent-Length: 12\\r\\n\\r\\nhello world2`);\n  const request5Res = Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nAccess-Control-Allow-Credentials: true\\r\\nContent-Length: 12\\r\\n\\r\\nhello world2`);\n  const request6Res = Buffer.from(`POST / HTTP/1.1\\r\\nHost: localhost:${server.address().port}\\r\\nConnection: keep-alive\\r\\nAccess-Control-Allow-Credentials: true\\r\\n\\r\\n`);\n  const iterator = new RequestIterator(opts);\n  iterator.setHeaders({\n    'Access-Control-Allow-Credentials': 'true'\n  });\n  t.same(iterator.currentRequest.requestBuffer, request1Res, iterator.currentRequest.requestBuffer.toString());\n  t.same(iterator.currentRequest.requestBuffer, request2Res, iterator.currentRequest.requestBuffer.toString());\n  iterator.nextRequest();\n  t.same(iterator.currentRequest.requestBuffer, request3Res, iterator.currentRequest.requestBuffer.toString());\n  iterator.nextRequest();\n  t.same(iterator.currentRequest.requestBuffer, request4Res, iterator.currentRequest.requestBuffer.toString());\n  t.same(iterator.currentRequest.requestBuffer, request5Res, iterator.currentRequest.requestBuffer.toString());\n  iterator.setRequest();\n  t.same(iterator.currentRequest.requestBuffer, request6Res, iterator.currentRequest.requestBuffer.toString());\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"request iterator should invoke onResponse callback with headers in it","suites":[],"updatePoint":{"line":410,"column":75,"index":18387},"line":410,"code":"test('request iterator should invoke onResponse callback with headers in it', t => {\n  t.plan(4);\n  const opts = server.address();\n  opts.requests = [{\n    onResponse: (status, body, context, headers) => {\n      t.same(status, 200);\n      t.same(body, 'ok');\n      t.same(context, {});\n      t.same(headers, {\n        'set-cookie': 123\n      });\n    }\n  }];\n  const iterator = new RequestIterator(opts);\n  iterator.recordBody(iterator.currentRequest, 200, 'ok', ['set-cookie', 123]);\n  iterator.nextRequest();\n  t.end();\n});","file":"requestIterator.test.js","skipped":false,"dir":"test"},{"name":"init","suites":[],"updatePoint":{"line":10,"column":10,"index":286},"line":10,"code":"test('init', t => {\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 2,\n    duration: 2,\n    title: 'title321'\n  }, function (err, result) {\n    t.error(err);\n    t.ok(result.duration >= 2, 'duration is at least 2s');\n    t.equal(result.title, 'title321', 'title should be what was passed in');\n    t.equal(result.connections, 2, 'connections is the same');\n    t.equal(result.pipelining, 1, 'pipelining is the default');\n    t.ok(result.latency, 'latency exists');\n    t.type(result.latency.average, 'number', 'latency.average exists');\n    t.type(result.latency.stddev, 'number', 'latency.stddev exists');\n    t.ok(result.latency.min >= 0, 'latency.min exists');\n    t.type(result.latency.max, 'number', 'latency.max exists');\n    t.type(result.latency.p2_5, 'number', 'latency.p2_5 (2.5%) exists');\n    t.type(result.latency.p50, 'number', 'latency.p50 (50%) exists');\n    t.type(result.latency.p97_5, 'number', 'latency.p97_5 (97.5%) exists');\n    t.type(result.latency.p99, 'number', 'latency.p99 (99%) exists');\n    t.ok(result.requests, 'requests exists');\n    t.type(result.requests.average, 'number', 'requests.average exists');\n    t.type(result.requests.stddev, 'number', 'requests.stddev exists');\n    t.type(result.requests.min, 'number', 'requests.min exists');\n    t.type(result.requests.max, 'number', 'requests.max exists');\n    t.ok(result.requests.total >= result.requests.average * 2 / 100 * 95, 'requests.total exists');\n    t.type(result.requests.sent, 'number', 'sent exists');\n    t.ok(result.requests.sent >= result.requests.total, 'total requests made should be more than or equal to completed requests total');\n    t.type(result.requests.p1, 'number', 'requests.p1 (1%) exists');\n    t.type(result.requests.p2_5, 'number', 'requests.p2_5 (2.5%) exists');\n    t.type(result.requests.p50, 'number', 'requests.p50 (50%) exists');\n    t.type(result.requests.p97_5, 'number', 'requests.p97_5 (97.5%) exists');\n    t.ok(result.throughput, 'throughput exists');\n    t.type(result.throughput.average, 'number', 'throughput.average exists');\n    t.type(result.throughput.stddev, 'number', 'throughput.stddev exists');\n    t.type(result.throughput.min, 'number', 'throughput.min exists');\n    t.type(result.throughput.max, 'number', 'throughput.max exists');\n    t.ok(result.throughput.total >= result.throughput.average * 2 / 100 * 95, 'throughput.total exists');\n    t.type(result.throughput.p1, 'number', 'throughput.p1 (1%) exists');\n    t.type(result.throughput.p2_5, 'number', 'throughput.p2_5 (2.5%) exists');\n    t.type(result.throughput.p50, 'number', 'throughput.p50 (50%) exists');\n    t.type(result.throughput.p97_5, 'number', 'throughput.p97_5 (97.5%) exists');\n    t.ok(result.start, 'start time exists');\n    t.ok(result.finish, 'finish time exists');\n    t.equal(result.errors, 0, 'no errors');\n    t.equal(result.mismatches, 0, 'no mismatches');\n    t.equal(result.resets, 0, 'no resets');\n    t.equal(result['1xx'], 0, '1xx codes');\n    t.equal(result['2xx'], result.requests.total, '2xx codes');\n    t.equal(result['3xx'], 0, '3xx codes');\n    t.equal(result['4xx'], 0, '4xx codes');\n    t.equal(result['5xx'], 0, '5xx codes');\n    t.equal(result.non2xx, 0, 'non 2xx codes');\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"tracker.stop()","suites":[],"updatePoint":{"line":67,"column":20,"index":3565},"line":67,"code":"test('tracker.stop()', t => {\n  const tracker = initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 2,\n    duration: 2\n  }, function (err, result) {\n    t.error(err);\n    t.ok(result.duration < 5, 'duration is lower because of stop');\n    t.notOk(result.title, 'title should not exist when not passed in');\n    t.equal(result.connections, 2, 'connections is the same');\n    t.equal(result.pipelining, 1, 'pipelining is the default');\n    t.ok(result.latency, 'latency exists');\n    t.type(result.latency.average, 'number', 'latency.average exists');\n    t.type(result.latency.stddev, 'number', 'latency.stddev exists');\n    t.ok(result.latency.min >= 0, 'latency.min exists');\n    t.type(result.latency.max, 'number', 'latency.max exists');\n    t.type(result.latency.p2_5, 'number', 'latency.p2_5 (2.5%) exists');\n    t.type(result.latency.p50, 'number', 'latency.p50 (50%) exists');\n    t.type(result.latency.p97_5, 'number', 'latency.p97_5 (97.5%) exists');\n    t.type(result.latency.p99, 'number', 'latency.p99 (99%) exists');\n    t.ok(result.requests, 'requests exists');\n    t.type(result.requests.average, 'number', 'requests.average exists');\n    t.type(result.requests.stddev, 'number', 'requests.stddev exists');\n    t.type(result.requests.min, 'number', 'requests.min exists');\n    t.type(result.requests.max, 'number', 'requests.max exists');\n    t.ok(result.requests.total >= result.requests.average * 2 / 100 * 95, 'requests.total exists');\n    t.type(result.requests.sent, 'number', 'sent exists');\n    t.ok(result.requests.sent >= result.requests.total, 'total requests made should be more than or equal to completed requests total');\n    t.type(result.requests.p1, 'number', 'requests.p1 (1%) exists');\n    t.type(result.requests.p2_5, 'number', 'requests.p2_5 (2.5%) exists');\n    t.type(result.requests.p50, 'number', 'requests.p50 (50%) exists');\n    t.type(result.requests.p97_5, 'number', 'requests.p97_5 (97.5%) exists');\n    t.ok(result.throughput, 'throughput exists');\n    t.type(result.throughput.average, 'number', 'throughput.average exists');\n    t.type(result.throughput.stddev, 'number', 'throughput.stddev exists');\n    t.type(result.throughput.min, 'number', 'throughput.min exists');\n    t.type(result.throughput.max, 'number', 'throughput.max exists');\n    t.ok(result.throughput.total >= result.throughput.average * 2 / 100 * 95, 'throughput.total exists');\n    t.type(result.throughput.p1, 'number', 'throughput.p1 (1%) exists');\n    t.type(result.throughput.p2_5, 'number', 'throughput.p2_5 (2.5%) exists');\n    t.type(result.throughput.p50, 'number', 'throughput.p50 (50%) exists');\n    t.type(result.throughput.p97_5, 'number', 'throughput.p97_5 (97.5%) exists');\n    t.ok(result.start, 'start time exists');\n    t.ok(result.finish, 'finish time exists');\n    t.equal(result.errors, 0, 'no errors');\n    t.equal(result.mismatches, 0, 'no mismatches');\n    t.equal(result['1xx'], 0, '1xx codes');\n    t.equal(result['2xx'], result.requests.total, '2xx codes');\n    t.equal(result['3xx'], 0, '3xx codes');\n    t.equal(result['4xx'], 0, '4xx codes');\n    t.equal(result['5xx'], 0, '5xx codes');\n    t.equal(result.non2xx, 0, 'non 2xx codes');\n    t.end();\n  });\n  t.ok(tracker.opts, 'opts exist on tracker');\n  setTimeout(() => {\n    tracker.stop();\n  }, 1000);\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"requests.min should be 0 when there are no successful requests","suites":[],"updatePoint":{"line":126,"column":68,"index":6945},"line":126,"code":"test('requests.min should be 0 when there are no successful requests', t => {\n  initJob({\n    url: 'nonexistent',\n    connections: 1,\n    amount: 1\n  }, function (err, result) {\n    t.error(err);\n    t.equal(result.requests.min, 0, 'requests.min should be 0');\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should callback with an error with an invalid connections factor","suites":[],"updatePoint":{"line":137,"column":74,"index":7235},"line":137,"code":"test('run should callback with an error with an invalid connections factor', t => {\n  t.plan(2);\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: -1\n  }, function (err, result) {\n    t.ok(err, 'invalid connections should cause an error');\n    t.notOk(result, 'results should not exist');\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should callback with an error with an invalid pipelining factor","suites":[],"updatePoint":{"line":148,"column":73,"index":7579},"line":148,"code":"test('run should callback with an error with an invalid pipelining factor', t => {\n  t.plan(2);\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    pipelining: -1\n  }, function (err, result) {\n    t.ok(err, 'invalid pipelining should cause an error');\n    t.notOk(result, 'results should not exist');\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should callback with an error with an invalid bailout","suites":[],"updatePoint":{"line":159,"column":63,"index":7911},"line":159,"code":"test('run should callback with an error with an invalid bailout', t => {\n  t.plan(2);\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    bailout: -1\n  }, function (err, result) {\n    t.ok(err, 'invalid bailout should cause an error');\n    t.notOk(result, 'results should not exist');\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should callback with an error with an invalid duration","suites":[],"updatePoint":{"line":170,"column":64,"index":8238},"line":170,"code":"test('run should callback with an error with an invalid duration', t => {\n  t.plan(2);\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    duration: -1\n  }, function (err, result) {\n    t.ok(err, 'invalid duration should cause an error');\n    t.notOk(result, 'results should not exist');\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should callback with an error when no url is passed in","suites":[],"updatePoint":{"line":181,"column":64,"index":8567},"line":181,"code":"test('run should callback with an error when no url is passed in', t => {\n  t.plan(2);\n  initJob({}, function (err, result) {\n    t.ok(err, 'no url should cause an error');\n    t.notOk(result, 'results should not exist');\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should callback with an error after a bailout","suites":[],"updatePoint":{"line":189,"column":55,"index":8803},"line":189,"code":"test('run should callback with an error after a bailout', t => {\n  t.plan(2);\n  initJob({\n    url: 'http://localhost:4',\n    // 4 = first unassigned port: https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers\n    bailout: 1\n  }, function (err, result) {\n    t.error(err);\n    t.ok(result, 'results should not exist');\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should callback with an error using expectBody and requests","suites":[],"updatePoint":{"line":201,"column":69,"index":9167},"line":201,"code":"test('run should callback with an error using expectBody and requests', t => {\n  t.plan(2);\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    requests: [{\n      body: 'something'\n    }],\n    expectBody: 'hello'\n  }, function (err, result) {\n    t.ok(err, 'expectBody used with requests should cause an error');\n    t.notOk(result, 'results should not exist');\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should handle context correctly","suites":[],"updatePoint":{"line":215,"column":41,"index":9542},"line":215,"code":"test('run should handle context correctly', t => {\n  t.plan(1);\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 1,\n    amount: 1,\n    initialContext: {\n      init: 'context'\n    },\n    requests: [{\n      setupRequest: (req, context) => {\n        t.same(context, {\n          init: 'context'\n        }, 'context should be initialized from opts');\n        return req;\n      }\n    }]\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should allow users to enter timestrings to be used for duration","suites":[],"updatePoint":{"line":234,"column":73,"index":9999},"line":234,"code":"test('run should allow users to enter timestrings to be used for duration', t => {\n  t.plan(3);\n  const instance = initJob({\n    url: 'http://localhost:' + server.address().port,\n    duration: '10m'\n  }, function (err, result) {\n    t.error(err);\n    t.ok(result, 'results should exist');\n    t.end();\n  });\n  t.equal(instance.opts.duration, 10 * 60, 'duration should have been parsed to be 600 seconds (10m)');\n  setTimeout(() => {\n    instance.stop();\n  }, 500);\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should recognise valid urls without http at the start","suites":[],"updatePoint":{"line":249,"column":63,"index":10458},"line":249,"code":"test('run should recognise valid urls without http at the start', t => {\n  t.plan(3);\n  initJob({\n    url: 'localhost:' + server.address().port,\n    duration: 1\n  }, (err, res) => {\n    t.error(err);\n    t.ok(res, 'results should exist');\n    t.equal(res.url, 'http://localhost:' + server.address().port, 'url should have http:// added to start');\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should produce count of mismatches with expectBody set","suites":[],"updatePoint":{"line":261,"column":64,"index":10830},"line":261,"code":"test('run should produce count of mismatches with expectBody set', t => {\n  t.plan(2);\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    expectBody: 'body will not be this',\n    maxOverallRequests: 10,\n    timeout: 100\n  }, function (err, result) {\n    t.error(err);\n    t.equal(result.mismatches, 10);\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should produce 0 mismatches with expectBody set and matches","suites":[],"updatePoint":{"line":274,"column":69,"index":11181},"line":274,"code":"test('run should produce 0 mismatches with expectBody set and matches', t => {\n  t.plan(2);\n  const responseBody = 'hello dave';\n  const server = helper.startServer({\n    body: responseBody\n  });\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    expectBody: responseBody,\n    maxOverallRequests: 10\n  }, function (err, result) {\n    t.error(err);\n    t.equal(result.mismatches, 0);\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should produce count of mismatches with verifyBody set","suites":[],"updatePoint":{"line":290,"column":64,"index":11601},"line":290,"code":"test('run should produce count of mismatches with verifyBody set', t => {\n  t.plan(2);\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    verifyBody: function () {\n      return false;\n    },\n    maxOverallRequests: 10,\n    timeout: 100\n  }, function (err, result) {\n    t.error(err);\n    t.equal(result.mismatches, 10);\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should produce 0 mismatches with verifyBody set and return true","suites":[],"updatePoint":{"line":305,"column":73,"index":11972},"line":305,"code":"test('run should produce 0 mismatches with verifyBody set and return true', t => {\n  t.plan(2);\n  const responseBody = 'hello dave';\n  const server = helper.startServer({\n    body: responseBody\n  });\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    verifyBody: function (body) {\n      return body.indexOf('hello') > -1;\n    },\n    maxOverallRequests: 10\n  }, function (err, result) {\n    t.error(err);\n    t.equal(result.mismatches, 0);\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should accept a unix socket/windows pipe","suites":[],"updatePoint":{"line":323,"column":50,"index":12430},"line":323,"code":"test('run should accept a unix socket/windows pipe', t => {\n  t.plan(11);\n  const socketPath = process.platform === 'win32' ? path.join('\\\\\\\\?\\\\pipe', process.cwd(), 'autocannon-' + Date.now()) : path.join(os.tmpdir(), 'autocannon-' + Date.now() + '.sock');\n  helper.startServer({\n    socketPath\n  });\n  initJob({\n    url: 'localhost',\n    socketPath,\n    connections: 2,\n    duration: 2\n  }, (err, result) => {\n    t.error(err);\n    t.ok(result, 'results should exist');\n    t.equal(result.socketPath, socketPath, 'socketPath should be included in result');\n    t.ok(result.requests.total > 0, 'should make at least one request');\n    if (process.platform === 'win32') {\n      // On Windows a few errors are expected. We'll accept a 1% error rate on\n      // the pipe.\n      t.ok(result.errors / result.requests.total < 0.01, `should have less than 1% errors on Windows (had ${result.errors} errors)`);\n    } else {\n      t.equal(result.errors, 0, 'no errors');\n    }\n    t.equal(result['1xx'], 0, '1xx codes');\n    t.equal(result['2xx'], result.requests.total, '2xx codes');\n    t.equal(result['3xx'], 0, '3xx codes');\n    t.equal(result['4xx'], 0, '4xx codes');\n    t.equal(result['5xx'], 0, '5xx codes');\n    t.equal(result.non2xx, 0, 'non 2xx codes');\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should count all xx status codes","suites":[],"updatePoint":{"line":356,"column":48,"index":13739},"line":356,"code":"  test(`run should count all ${i}xx status codes`, t => {\n    const server = helper.startServer({\n      statusCode: i * 100 + 2\n    });\n    initJob({\n      url: `http://localhost:${server.address().port}`,\n      connections: 2,\n      duration: 2\n    }, (err, result) => {\n      t.error(err);\n      t.ok(result[`${i}xx`], `${i}xx status codes recorded`);\n      t.ok(result.latency, 'latency exists');\n      t.ok(!Number.isNaN(result.latency.average), 'latency.average is not NaN');\n      t.type(result.latency.average, 'number', 'latency.average exists');\n      t.type(result.latency.stddev, 'number', 'latency.stddev exists');\n      t.ok(result.latency.min >= 0, 'latency.min exists');\n      t.type(result.latency.max, 'number', 'latency.max exists');\n      t.type(result.latency.p2_5, 'number', 'latency.p2_5 (2.5%) exists');\n      t.type(result.latency.p50, 'number', 'latency.p50 (50%) exists');\n      t.type(result.latency.p97_5, 'number', 'latency.p97_5 (97.5%) exists');\n      t.type(result.latency.p99, 'number', 'latency.p99 (99%) exists');\n      t.ok(result.throughput, 'throughput exists');\n      t.ok(!Number.isNaN(result.throughput.average), 'throughput.average is not NaN');\n      t.type(result.throughput.average, 'number', 'throughput.average exists');\n      t.type(result.throughput.stddev, 'number', 'throughput.stddev exists');\n      t.type(result.throughput.min, 'number', 'throughput.min exists');\n      t.type(result.throughput.max, 'number', 'throughput.max exists');\n      t.ok(result.throughput.total >= result.throughput.average * 2 / 100 * 95, 'throughput.total exists');\n      t.type(result.throughput.p1, 'number', 'throughput.p1 (1%) exists');\n      t.type(result.throughput.p2_5, 'number', 'throughput.p2_5 (2.5%) exists');\n      t.type(result.throughput.p50, 'number', 'throughput.p50 (50%) exists');\n      t.type(result.throughput.p97_5, 'number', 'throughput.p97_5 (97.5%) exists');\n      t.end();\n    });\n  });","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should not modify default options","suites":[],"updatePoint":{"line":392,"column":43,"index":15681},"line":392,"code":"test('run should not modify default options', t => {\n  const origin = Object.assign({}, defaultOptions);\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 2,\n    duration: 2\n  }, function (err, result) {\n    t.error(err);\n    t.same(defaultOptions, origin, 'calling run function does not modify default options');\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run will exclude non 2xx stats from latency and throughput averages if excludeErrorStats is true","suites":[],"updatePoint":{"line":404,"column":102,"index":16110},"line":404,"code":"test('run will exclude non 2xx stats from latency and throughput averages if excludeErrorStats is true', t => {\n  const server = helper.startServer({\n    statusCode: 404\n  });\n  initJob({\n    url: `http://localhost:${server.address().port}`,\n    connections: 2,\n    duration: 2,\n    excludeErrorStats: true\n  }, (err, result) => {\n    t.error(err);\n    t.equal(result['1xx'], 0, '1xx codes');\n    t.equal(result['2xx'], 0, '2xx codes');\n    t.equal(result['3xx'], 0, '3xx codes');\n    t.equal(result['4xx'], result.requests.total, '4xx codes');\n    t.equal(result['5xx'], 0, '5xx codes');\n    t.equal(result.non2xx, result.requests.total, 'non 2xx codes');\n    t.ok(result.latency, 'latency exists');\n    t.equal(result.latency.average, 0, 'latency.average should be 0');\n    t.equal(result.latency.stddev, 0, 'latency.stddev should be 0');\n    t.equal(result.latency.min, 0, 'latency.min should be 0');\n    t.equal(result.latency.max, 0, 'latency.max should be 0');\n    t.equal(result.latency.p1, 0, 'latency.p1 (1%) should be 0');\n    t.equal(result.latency.p2_5, 0, 'latency.p2_5 (2.5%) should be 0');\n    t.equal(result.latency.p50, 0, 'latency.p50 (50%) should be 0');\n    t.equal(result.latency.p97_5, 0, 'latency.p97_5 (97.5%) should be 0');\n    t.equal(result.latency.p99, 0, 'latency.p99 (99%) should be 0');\n    t.ok(result.throughput, 'throughput exists');\n    t.equal(result.throughput.average, 0, 'throughput.average should be 0');\n    t.equal(result.throughput.stddev, 0, 'throughput.stddev should be 0');\n    t.equal(result.throughput.min, 0, 'throughput.min should be 0');\n    t.equal(result.throughput.max, 0, 'throughput.max should be 0');\n    t.equal(result.throughput.total, 0, 'throughput.total should be 0');\n    t.equal(result.throughput.p1, 0, 'throughput.p1 (1%) should be 0');\n    t.equal(result.throughput.p2_5, 0, 'throughput.p2_5 (2.5%) should be 0');\n    t.equal(result.throughput.p50, 0, 'throughput.p50 (50%) should be 0');\n    t.equal(result.throughput.p97_5, 0, 'throughput.p97_5 (97.5%) should be 0');\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"tracker will emit reqError with error message on timeout","suites":[],"updatePoint":{"line":444,"column":62,"index":18130},"line":444,"code":"test('tracker will emit reqError with error message on timeout', t => {\n  t.plan(2);\n  const server = helper.startTimeoutServer();\n  const tracker = initJob({\n    url: `http://localhost:${server.address().port}`,\n    connections: 1,\n    duration: 5,\n    timeout: 2,\n    bailout: 1,\n    excludeErrorStats: true\n  });\n  tracker.once('reqError', err => {\n    t.type(err, Error, 'reqError should pass an Error to listener');\n    t.equal(err.message, 'request timed out', 'error should indicate timeout');\n    tracker.stop();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"tracker will emit reqError with error message on error","suites":[],"updatePoint":{"line":461,"column":60,"index":18659},"line":461,"code":"test('tracker will emit reqError with error message on error', t => {\n  t.plan(2);\n  const server = helper.startSocketDestroyingServer();\n  const tracker = initJob({\n    url: `http://localhost:${server.address().port}`,\n    connections: 10,\n    duration: 15,\n    method: 'POST',\n    body: 'hello',\n    excludeErrorStats: true\n  });\n  tracker.once('reqError', err => {\n    t.type(err, Error, 'reqError should pass an Error to listener');\n    t.ok(err.message, 'err.message should have a value');\n    tracker.stop();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"tracker will emit reqMismatch when body does not match expectBody","suites":[],"updatePoint":{"line":478,"column":71,"index":19195},"line":478,"code":"test('tracker will emit reqMismatch when body does not match expectBody', t => {\n  t.plan(2);\n  const responseBody = 'hello world';\n  const server = helper.startServer({\n    body: responseBody\n  });\n  const expectBody = 'goodbye world';\n  const tracker = initJob({\n    url: `http://localhost:${server.address().port}`,\n    connections: 10,\n    duration: 15,\n    method: 'GET',\n    body: 'hello',\n    expectBody\n  });\n  tracker.once('reqMismatch', bodyStr => {\n    t.equal(bodyStr, responseBody);\n    t.not(bodyStr, expectBody);\n    tracker.stop();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"tracker will emit tick with current counter value","suites":[],"updatePoint":{"line":499,"column":55,"index":19737},"line":499,"code":"test('tracker will emit tick with current counter value', t => {\n  t.plan(1);\n  const server = helper.startSocketDestroyingServer();\n  const tracker = initJob({\n    url: `http://localhost:${server.address().port}`,\n    connections: 10,\n    duration: 10\n  });\n  tracker.once('tick', counter => {\n    t.type(counter, 'object');\n    tracker.stop();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"throw if connections is greater than amount","suites":[],"updatePoint":{"line":512,"column":49,"index":20087},"line":512,"code":"test('throw if connections is greater than amount', t => {\n  t.plan(1);\n  const server = helper.startSocketDestroyingServer();\n  t.throws(function () {\n    initJob({\n      url: `http://localhost:${server.address().port}`,\n      connections: 10,\n      amount: 1,\n      excludeErrorStats: true\n    }, () => {});\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run promise","suites":[],"updatePoint":{"line":524,"column":17,"index":20375},"line":524,"code":"test('run promise', t => {\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 2,\n    duration: 2,\n    title: 'title321'\n  }).then(result => {\n    t.ok(result.duration >= 2, 'duration is at least 2s');\n    t.equal(result.title, 'title321', 'title should be what was passed in');\n    t.equal(result.connections, 2, 'connections is the same');\n    t.equal(result.pipelining, 1, 'pipelining is the default');\n    t.ok(result.latency, 'latency exists');\n    t.type(result.latency.average, 'number', 'latency.average exists');\n    t.type(result.latency.stddev, 'number', 'latency.stddev exists');\n    t.ok(result.latency.min >= 0, 'latency.min exists');\n    t.type(result.latency.max, 'number', 'latency.max exists');\n    t.type(result.latency.p2_5, 'number', 'latency.p2_5 (2.5%) exists');\n    t.type(result.latency.p50, 'number', 'latency.p50 (50%) exists');\n    t.type(result.latency.p97_5, 'number', 'latency.p97_5 (97.5%) exists');\n    t.type(result.latency.p99, 'number', 'latency.p99 (99%) exists');\n    t.ok(result.requests, 'requests exists');\n    t.type(result.requests.average, 'number', 'requests.average exists');\n    t.type(result.requests.stddev, 'number', 'requests.stddev exists');\n    t.type(result.requests.min, 'number', 'requests.min exists');\n    t.type(result.requests.max, 'number', 'requests.max exists');\n    t.ok(result.requests.total >= result.requests.average * 2 / 100 * 95, 'requests.total exists');\n    t.type(result.requests.sent, 'number', 'sent exists');\n    t.ok(result.requests.sent >= result.requests.total, 'total requests made should be more than or equal to completed requests total');\n    t.type(result.requests.p1, 'number', 'requests.p1 (1%) exists');\n    t.type(result.requests.p2_5, 'number', 'requests.p2_5 (2.5%) exists');\n    t.type(result.requests.p50, 'number', 'requests.p50 (50%) exists');\n    t.type(result.requests.p97_5, 'number', 'requests.p97_5 (97.5%) exists');\n    t.ok(result.throughput, 'throughput exists');\n    t.type(result.throughput.average, 'number', 'throughput.average exists');\n    t.type(result.throughput.stddev, 'number', 'throughput.stddev exists');\n    t.type(result.throughput.min, 'number', 'throughput.min exists');\n    t.type(result.throughput.max, 'number', 'throughput.max exists');\n    t.ok(result.throughput.total >= result.throughput.average * 2 / 100 * 95, 'throughput.total exists');\n    t.type(result.throughput.p1, 'number', 'throughput.p1 (1%) exists');\n    t.type(result.throughput.p2_5, 'number', 'throughput.p2_5 (2.5%) exists');\n    t.type(result.throughput.p50, 'number', 'throughput.p50 (50%) exists');\n    t.type(result.throughput.p97_5, 'number', 'throughput.p97_5 (97.5%) exists');\n    t.ok(result.start, 'start time exists');\n    t.ok(result.finish, 'finish time exists');\n    t.equal(result.errors, 0, 'no errors');\n    t.equal(result.resets, 0, 'no resets');\n    t.equal(result['1xx'], 0, '1xx codes');\n    t.equal(result['2xx'], result.requests.total, '2xx codes');\n    t.equal(result['3xx'], 0, '3xx codes');\n    t.equal(result['4xx'], 0, '4xx codes');\n    t.equal(result['5xx'], 0, '5xx codes');\n    t.equal(result.non2xx, 0, 'non 2xx codes');\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"should throw if duration is not a number nor a string","suites":[],"updatePoint":{"line":579,"column":59,"index":23615},"line":579,"code":"test('should throw if duration is not a number nor a string', t => {\n  t.plan(1);\n  const server = helper.startServer();\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 2,\n    duration: ['foobar'],\n    title: 'title321'\n  }).then(result => {\n    t.fail();\n  }).catch(err => {\n    t.equal(err.message, 'duration entered was in an invalid format');\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"should emit error","suites":[],"updatePoint":{"line":593,"column":23,"index":23971},"line":593,"code":"test('should emit error', t => {\n  t.plan(1);\n  const server = helper.startServer();\n  const tracker = initJob({\n    url: `http://unknownhost:${server.address().port}`,\n    connections: 1,\n    timeout: 100,\n    forever: true,\n    form: {\n      param1: {\n        type: 'string',\n        value: null // this will trigger an error\n      }\n    }\n  });\n\n  tracker.once('error', error => {\n    t.equal(error.message, 'A \\'type\\' key with value \\'text\\' or \\'file\\' should be specified');\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"should throw if timeout is less than zero","suites":[],"updatePoint":{"line":614,"column":47,"index":24500},"line":614,"code":"test('should throw if timeout is less than zero', t => {\n  t.plan(1);\n  const server = helper.startServer();\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 2,\n    timeout: -1,\n    title: 'title321'\n  }).then(result => {\n    t.fail();\n  }).catch(err => {\n    t.equal(err.message, 'timeout must be greater than 0');\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"should handle duration in string format","suites":[],"updatePoint":{"line":628,"column":45,"index":24858},"line":628,"code":"test('should handle duration in string format', t => {\n  t.plan(1);\n  const server = helper.startServer();\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 2,\n    duration: '1',\n    title: 'title321'\n  }).then(result => {\n    t.pass();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"should count resets","suites":[],"updatePoint":{"line":640,"column":25,"index":25118},"line":640,"code":"test('should count resets', t => {\n  t.plan(1);\n  const server = helper.startServer();\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 1,\n    amount: 10,\n    requests: [{\n      method: 'GET'\n    }, {\n      method: 'PUT'\n    }, {\n      method: 'POST',\n      // falsey result will reset\n      setupRequest: () => {}\n    }]\n  }).then(result => {\n    t.equal(result.resets, 4);\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"should get onResponse callback invoked even when there is no body","suites":[],"updatePoint":{"line":661,"column":71,"index":25596},"line":661,"code":"test('should get onResponse callback invoked even when there is no body', async t => {\n  t.plan(4);\n  const server = helper.startServer({\n    responses: [{\n      statusCode: 200,\n      body: 'ok'\n    }, {\n      statusCode: 204\n    }]\n  });\n  await initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 1,\n    amount: 2,\n    requests: [{\n      method: 'GET',\n      onResponse(status, body) {\n        t.same(status, 200);\n        t.same(body, 'ok');\n      }\n    }, {\n      method: 'GET',\n      onResponse(status, body) {\n        t.same(status, 204);\n        t.same(body, '');\n      }\n    }]\n  });\n  t.end();\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"should use request from HAR","suites":[],"updatePoint":{"line":691,"column":33,"index":26195},"line":691,"code":"test('should use request from HAR', t => {\n  t.plan(6);\n  const server = helper.startServer();\n  const url = `http://localhost:${server.address().port}`;\n  const har = helper.customizeHAR('./fixtures/httpbin-get.json', 'https://httpbin.org', url);\n  initJob({\n    url,\n    duration: 1,\n    har\n  }, (err, res) => {\n    t.error(err);\n    t.ok(res, 'results should exist');\n    t.equal(res.errors, 0);\n    t.equal(res.timeouts, 0);\n    t.ok(res['2xx'] > 0);\n    t.equal(res.url, url);\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"should use extend headers of HAR requests","suites":[],"updatePoint":{"line":710,"column":47,"index":26715},"line":710,"code":"test('should use extend headers of HAR requests', t => {\n  t.plan(6 + 2); // header check done as many times as sent requests\n  const server = helper.startServer();\n  const url = `http://localhost:${server.address().port}`;\n  const har = helper.customizeHAR('./fixtures/httpbin-simple-get.json', 'https://httpbin.org', url);\n  initJob({\n    url,\n    connections: 1,\n    amount: 2,\n    headers: {\n      'X-CUSTOM': 'my-own-value'\n    },\n    har\n  }, (err, res) => {\n    t.error(err);\n    t.ok(res, 'results should exist');\n    t.equal(res.errors, 0);\n    t.equal(res.timeouts, 0);\n    t.ok(res['2xx'] > 0);\n    t.equal(res.url, url);\n    t.end();\n  }).on('response', client => {\n    t.equal(client.requestIterator.currentRequest.headers['X-CUSTOM'], 'my-own-value', 'X-CUSTOM was not sent to server');\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"should not override method or body of HAR requests","suites":[],"updatePoint":{"line":735,"column":56,"index":27535},"line":735,"code":"test('should not override method or body of HAR requests', t => {\n  t.plan(6 + 4); // method and body checks done as many times as sent requests\n  const server = helper.startServer();\n  const url = `http://localhost:${server.address().port}`;\n  const har = helper.customizeHAR('./fixtures/httpbin-simple-get.json', 'https://httpbin.org', url);\n  initJob({\n    url,\n    connections: 1,\n    amount: 2,\n    method: 'POST',\n    body: 'my-custom-body',\n    har\n  }, (err, res) => {\n    t.error(err);\n    t.ok(res, 'results should exist');\n    t.equal(res.errors, 0);\n    t.equal(res.timeouts, 0);\n    t.ok(res['2xx'] > 0);\n    t.equal(res.url, url);\n    t.end();\n  }).on('response', client => {\n    t.equal(client.requestIterator.currentRequest.method, 'GET', 'Method was not mean to be overidden');\n    t.equal(client.requestIterator.currentRequest.body, undefined, 'Body was not mean to be overidden');\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"should ignore HAR requests targetting a different domain","suites":[],"updatePoint":{"line":760,"column":62,"index":28451},"line":760,"code":"test('should ignore HAR requests targetting a different domain', t => {\n  t.plan(6);\n  const server = helper.startServer();\n  const url = `http://localhost:${server.address().port}`;\n  const har = helper.customizeHAR('./fixtures/multi-domains.json', 'https://httpbin.org', url);\n  initJob({\n    url,\n    connections: 1,\n    amount: 4,\n    har\n  }, (err, res) => {\n    t.error(err);\n    t.ok(res, 'results should exist');\n    t.equal(res.errors, 0);\n    t.equal(res.timeouts, 0);\n    // if the github request is fired, it'll fail with 4xx status\n    t.equal(res['2xx'], 4);\n    t.equal(res.url, url);\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"should throw on invalid HAR","suites":[],"updatePoint":{"line":781,"column":33,"index":29045},"line":781,"code":"test('should throw on invalid HAR', t => {\n  t.plan(1);\n  initJob({\n    url: `http://localhost:${server.address().port}`,\n    connections: 1,\n    amount: 4,\n    har: {\n      log: {\n        version: '1.2',\n        creator: {\n          name: 'Firefox',\n          version: '80.0.1'\n        },\n        pages: [{\n          startedDateTime: '2020-09-28T16:43:28.987+02:00',\n          id: 'page_1',\n          title: 'mcollina/autocannon: fast HTTP/1.1 benchmarking tool written in Node.js',\n          pageTimings: {\n            onContentLoad: 1234,\n            onLoad: 1952\n          }\n        }]\n      }\n    }\n  }, (err, res) => {\n    t.match(err, /Could not parse HAR content: no entries found/);\n    t.end();\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"should run when no callback is passed in","suites":[],"updatePoint":{"line":810,"column":46,"index":29773},"line":810,"code":"test('should run when no callback is passed in', t => {\n  t.plan(1);\n  const tracker = initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 1,\n    duration: 1\n  });\n  t.resolveMatch(tracker, {\n    connections: 1\n  }, 'The main tracker should resolve');\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"Should run a warmup if one is passed in","suites":[],"updatePoint":{"line":821,"column":45,"index":30057},"line":821,"code":"test('Should run a warmup if one is passed in', t => {\n  t.plan(1);\n  const tracker = initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 1,\n    duration: 1,\n    warmup: {\n      connections: 1,\n      duration: 1\n    }\n  });\n  t.resolves(tracker, 'The main tracker should resolve');\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"The warmup should not pollute the main result set","suites":[],"updatePoint":{"line":834,"column":55,"index":30382},"line":834,"code":"test('The warmup should not pollute the main result set', t => {\n  t.plan(3);\n  const tracker = initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 3,\n    duration: 1,\n    warmup: {\n      connections: 4,\n      duration: 2\n    }\n  });\n  tracker.then(result => {\n    t.equal(result.connections, 3, 'connections should equal the main connections and not the warmup connections');\n    t.ok(result.duration >= 1, 'duration should equal the main duration and not the warmup duration');\n    t.type(result.warmup, 'object');\n  });\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"should get headers passed from server onResponse callback","suites":[],"updatePoint":{"line":851,"column":63,"index":30946},"line":851,"code":"test('should get headers passed from server onResponse callback', async t => {\n  t.plan(3);\n  const server = helper.startServer({\n    responses: [{\n      statusCode: 200,\n      body: 'ok',\n      headers: {\n        'set-cookie': 123\n      }\n    }]\n  });\n  await initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 1,\n    amount: 1,\n    requests: [{\n      method: 'GET',\n      onResponse(status, body, context, headers) {\n        t.same(status, 200);\n        t.same(body, 'ok');\n        t.same(headers['set-cookie'], 123);\n      }\n    }]\n  });\n  t.end();\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"should get multi-value headers passed from server onResponse callback","suites":[],"updatePoint":{"line":877,"column":75,"index":31544},"line":877,"code":"test('should get multi-value headers passed from server onResponse callback', async t => {\n  t.plan(3);\n  const server = helper.startServer({\n    responses: [{\n      statusCode: 200,\n      body: 'ok',\n      headers: {\n        'set-cookie': [123, 456, 789]\n      }\n    }]\n  });\n  await initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 1,\n    amount: 1,\n    requests: [{\n      method: 'GET',\n      onResponse(status, body, context, headers) {\n        t.same(status, 200);\n        t.same(body, 'ok');\n        t.same(headers['set-cookie'], [123, 456, 789]);\n      }\n    }]\n  });\n  t.end();\n});","file":"run.test.js","skipped":false,"dir":"test"},{"name":"run should only send the expected number of requests","suites":[],"updatePoint":{"line":8,"column":58,"index":272},"line":8,"code":"test('run should only send the expected number of requests', t => {\n  t.plan(10);\n  let done = false;\n  initJob({\n    url: `http://localhost:${server.address().port}`,\n    duration: 1,\n    connections: 100,\n    amount: 50146\n  }, (err, res) => {\n    t.error(err);\n    t.equal(res.requests.total + res.timeouts, 50146, 'results should match the amount');\n    t.equal(res.requests.sent, 50146, 'totalRequests should match the amount');\n    done = true;\n  });\n  setTimeout(() => {\n    t.notOk(done);\n  }, 1000);\n  initJob({\n    url: `http://localhost:${server.address().port}`,\n    connections: 2,\n    maxConnectionRequests: 10\n  }, (err, res) => {\n    t.error(err);\n    t.equal(res.requests.total, 20, 'results should match max connection requests * connections');\n    t.equal(res.requests.sent, 20, 'totalRequests should match the expected amount');\n  });\n  initJob({\n    url: `http://localhost:${server.address().port}`,\n    connections: 2,\n    maxOverallRequests: 10\n  }, (err, res) => {\n    t.error(err);\n    t.equal(res.requests.total, 10, 'results should match max overall requests');\n    t.equal(res.requests.sent, 10, 'totalRequests should match the expected amount');\n  });\n});","file":"runAmount.test.js","skipped":false,"dir":"test"},{"name":"should shutdown after all amounts timeout","suites":[],"updatePoint":{"line":44,"column":47,"index":1446},"line":44,"code":"test('should shutdown after all amounts timeout', t => {\n  t.plan(5);\n  initJob({\n    url: `http://localhost:${timeoutServer.address().port}`,\n    amount: 10,\n    timeout: 2,\n    connections: 10\n  }, (err, res) => {\n    t.error(err);\n    t.equal(res.errors, 10);\n    t.equal(res.timeouts, 10);\n    t.equal(res.requests.sent, 10, 'totalRequests should match the expected amount');\n    t.equal(res.requests.total, 0, 'total completed requests should be 0');\n  });\n});","file":"runAmount.test.js","skipped":false,"dir":"test"},{"name":"should reconnect twice to the server with a reset rate of 10 for 20 connections","suites":[],"updatePoint":{"line":59,"column":85,"index":1950},"line":59,"code":"test('should reconnect twice to the server with a reset rate of 10 for 20 connections', t => {\n  t.plan(3);\n  const testServer = helper.startServer();\n  initJob({\n    url: 'localhost:' + testServer.address().port,\n    connections: 1,\n    amount: 20,\n    reconnectRate: 2\n  }, (err, res) => {\n    t.error(err);\n    t.equal(res.requests.sent, 20, 'totalRequests should match the expected amount');\n    t.equal(testServer.autocannonConnects, 10, 'should have connected to the server 10 times after dropping the connection every second request');\n    t.end();\n  });\n});","file":"runAmount.test.js","skipped":false,"dir":"test"},{"name":"run should return an error with invalid form options","suites":[],"updatePoint":{"line":22,"column":58,"index":428},"line":22,"code":"test('run should return an error with invalid form options', async t => {\n  const cases = [{\n    name: 'invalid JSON',\n    value: 'u',\n    message: 'Invalid JSON or file where to get form data'\n  }, {\n    name: 'non existing JSON file',\n    value: 'nonexisting.json',\n    message: 'Invalid JSON or file where to get form data'\n  }, {\n    name: 'JSON options missing path key in file type',\n    value: '{ \"image\": { \"type\": \"file\" }}',\n    message: 'Missing key \\'path\\' in form object for key \\'image\\''\n  }, {\n    name: 'JS Object missing path key in file type',\n    value: {\n      image: {\n        type: 'file'\n      }\n    },\n    message: 'Missing key \\'path\\' in form object for key \\'image\\''\n  }, {\n    name: 'JSON options missing value in text type',\n    value: '{ \"image\": { \"type\": \"text\" }}',\n    message: 'Missing key \\'value\\' in form object for key \\'image\\''\n  }, {\n    name: 'JS Object missing value in text type',\n    value: {\n      image: {\n        type: 'text'\n      }\n    },\n    message: 'Missing key \\'value\\' in form object for key \\'image\\''\n  }, {\n    name: 'JSON options with not supported type',\n    value: '{ \"image\": { \"type\": \"random\" }}',\n    message: 'A \\'type\\' key with value \\'text\\' or \\'file\\' should be specified'\n  }, {\n    name: 'JS Object with not supported type',\n    value: {\n      image: {\n        type: 'random'\n      }\n    },\n    message: 'A \\'type\\' key with value \\'text\\' or \\'file\\' should be specified'\n  }];\n  const server = helper.startMultipartServer();\n  t.teardown(() => server.close());\n  for (const c of cases) {\n    t.test(c.name, async t => {\n      const [err] = await new Promise(resolve => {\n        initJob({\n          url: 'http://localhost:' + server.address().port,\n          connections: 1,\n          amount: 1,\n          form: c.value\n        }, (err, res) => {\n          resolve([err, res]);\n        });\n      });\n      await t.test('error', t => {\n        t.not(null, err);\n        t.equal(c.message, err.message, `mismatching error message ${err.message}`);\n        t.end();\n      });\n    });\n  }\n});","file":"runMultipart.test.js","skipped":false,"dir":"test"},{"name":"run should take form options as a JSON string or a JS Object","suites":[],"updatePoint":{"line":90,"column":66,"index":2505},"line":90,"code":"test('run should take form options as a JSON string or a JS Object', async t => {\n  const form = {\n    image: {\n      type: 'file',\n      path: require.resolve('./j5.jpeg')\n    },\n    name: {\n      type: 'text',\n      value: 'j5'\n    }\n  };\n  const string = JSON.stringify(form);\n  const temp = tmpdir();\n  const jsonFile = join(temp, 'multipart.json');\n  await writef(jsonFile, string, 'utf8');\n  const cases = [{\n    name: 'from string',\n    value: string\n  }, {\n    name: 'from json file',\n    value: jsonFile\n  }, {\n    name: 'from JS Object',\n    value: form\n  }];\n  const allCases = [...cases, ...cases.map(c => ({\n    ...c,\n    workers: true\n  }))];\n  for (const c of allCases) {\n    t.test(c.name, {\n      skip: c.workers && !hasWorkerSupport\n    }, async t => {\n      const server = helper.startMultipartServer(null, payload => {\n        t.equal('j5', payload.name);\n        t.equal('j5.jpeg', payload.image.filename);\n      });\n      t.teardown(() => server.close());\n      const [err, res] = await new Promise(resolve => {\n        initJob({\n          url: 'http://localhost:' + server.address().port,\n          connections: 1,\n          amount: 1,\n          form: c.value,\n          workers: c.workers ? 1 : undefined // use only one worker coz we're checking for 1 req\n        }, (err, res) => {\n          resolve([err, res]);\n        });\n      });\n      await t.test('result', t => {\n        t.equal(null, err);\n        t.equal(0, res.errors, 'result should not have errors');\n        t.equal(1, res['2xx'], 'result status code should be 2xx');\n        t.equal(0, res.non2xx, 'result status code should be 2xx');\n        t.end();\n      });\n    });\n  }\n});","file":"runMultipart.test.js","skipped":false,"dir":"test"},{"name":"run should use a custom method if `options.method` is passed","suites":[],"updatePoint":{"line":149,"column":66,"index":4174},"line":149,"code":"test('run should use a custom method if `options.method` is passed', t => {\n  const server = helper.startMultipartServer(null, payload => {\n    t.equal('j5', payload.name);\n    t.equal('j5.jpeg', payload.image.filename);\n  });\n  t.teardown(() => server.close());\n  const form = {\n    image: {\n      type: 'file',\n      path: require.resolve('./j5.jpeg')\n    },\n    name: {\n      type: 'text',\n      value: 'j5'\n    }\n  };\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    method: 'PUT',\n    connections: 1,\n    amount: 1,\n    form\n  }, (err, res) => {\n    t.equal(null, err);\n    t.equal(0, res.errors, 'result should not have errors');\n    t.equal(1, res['2xx'], 'result status code should be 2xx');\n    t.equal(0, res.non2xx, 'result status code should be 2xx');\n    t.end();\n  });\n});","file":"runMultipart.test.js","skipped":false,"dir":"test"},{"name":"run should set filename","suites":[],"updatePoint":{"line":179,"column":29,"index":4945},"line":179,"code":"test('run should set filename', t => {\n  const server = helper.startMultipartServer(null, payload => {\n    t.equal('j5', payload.name);\n    t.equal('j5.jpeg', payload.image.filename);\n  });\n  t.teardown(() => server.close());\n  const form = {\n    image: {\n      type: 'file',\n      path: require.resolve('./j5.jpeg')\n    },\n    name: {\n      type: 'text',\n      value: 'j5'\n    }\n  };\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    method: 'POST',\n    connections: 1,\n    amount: 1,\n    form\n  }, (err, res) => {\n    t.equal(null, err);\n    t.equal(0, res.errors, 'result should not have errors');\n    t.equal(1, res['2xx'], 'result status code should be 2xx');\n    t.equal(0, res.non2xx, 'result status code should be 2xx');\n    t.end();\n  });\n});","file":"runMultipart.test.js","skipped":false,"dir":"test"},{"name":"run should allow overriding filename","suites":[],"updatePoint":{"line":209,"column":42,"index":5730},"line":209,"code":"test('run should allow overriding filename', t => {\n  const server = helper.startMultipartServer(null, payload => {\n    t.equal('j5', payload.name);\n    t.equal('testfilename.jpeg', payload.image.filename);\n  });\n  t.teardown(() => server.close());\n  const form = {\n    image: {\n      type: 'file',\n      path: require.resolve('./j5.jpeg'),\n      options: {\n        filename: 'testfilename.jpeg'\n      }\n    },\n    name: {\n      type: 'text',\n      value: 'j5'\n    }\n  };\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    method: 'POST',\n    connections: 1,\n    amount: 1,\n    form\n  }, (err, res) => {\n    t.equal(null, err);\n    t.equal(0, res.errors, 'result should not have errors');\n    t.equal(1, res['2xx'], 'result status code should be 2xx');\n    t.equal(0, res.non2xx, 'result status code should be 2xx');\n    t.end();\n  });\n});","file":"runMultipart.test.js","skipped":false,"dir":"test"},{"name":"run should allow overriding filename with file path","suites":[],"updatePoint":{"line":242,"column":57,"index":6604},"line":242,"code":"test('run should allow overriding filename with file path', t => {\n  const server = helper.startMultipartServer({\n    preservePath: true\n  }, payload => {\n    t.equal('j5', payload.name);\n    t.equal('some/path/testfilename.jpeg', payload.image.filename);\n  });\n  t.teardown(() => server.close());\n  const form = {\n    image: {\n      type: 'file',\n      path: require.resolve('./j5.jpeg'),\n      options: {\n        filepath: 'some/path/testfilename.jpeg'\n      }\n    },\n    name: {\n      type: 'text',\n      value: 'j5'\n    }\n  };\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    method: 'POST',\n    connections: 1,\n    amount: 1,\n    form\n  }, (err, res) => {\n    t.equal(null, err);\n    t.equal(0, res.errors, 'result should not have errors');\n    t.equal(1, res['2xx'], 'result status code should be 2xx');\n    t.equal(0, res.non2xx, 'result status code should be 2xx');\n    t.end();\n  });\n});","file":"runMultipart.test.js","skipped":false,"dir":"test"},{"name":"should receive the message from different server","suites":[],"updatePoint":{"line":13,"column":54,"index":357},"line":13,"code":"test('should receive the message from different server', t => {\n  t.plan(3);\n  const instance = initJob({\n    url: [server1, server2, server3].map(server => `http://localhost:${server.address().port}`),\n    duration: 1,\n    connections: 3\n  });\n  let receivedServer1 = false;\n  let receivedServer2 = false;\n  let receivedServer3 = false;\n  instance.on('response', client => {\n    if (!receivedServer1 && client.parser.chunk.toString().includes('from server1')) {\n      receivedServer1 = true;\n      t.pass();\n    }\n    if (!receivedServer2 && client.parser.chunk.toString().includes('from server2')) {\n      receivedServer2 = true;\n      t.pass();\n    }\n    if (!receivedServer3 && client.parser.chunk.toString().includes('from server3')) {\n      receivedServer3 = true;\n      t.pass();\n    }\n  });\n});","file":"runMultiServer.test.js","skipped":false,"dir":"test"},{"name":"run should only send the expected number of requests per second - scenario 1","suites":[],"updatePoint":{"line":7,"column":82,"index":245},"line":7,"code":"test('run should only send the expected number of requests per second - scenario 1', t => {\n  t.plan(3);\n  initJob({\n    url: `http://localhost:${server.address().port}`,\n    connections: 2,\n    overallRate: 10,\n    amount: 40,\n    sampleInt: 1000\n  }, (err, res) => {\n    t.error(err);\n    t.equal(Math.floor(res.duration), 4, 'should have take 4 seconds to send 10 requests per seconds');\n    t.equal(res.requests.average, 10, 'should have sent 10 requests per second on average');\n  });\n});","file":"runRate.test.js","skipped":false,"dir":"test"},{"name":"run should only send the expected number of requests per second - scenario 2","suites":[],"updatePoint":{"line":21,"column":82,"index":739},"line":21,"code":"test('run should only send the expected number of requests per second - scenario 2', t => {\n  t.plan(3);\n  initJob({\n    url: `http://localhost:${server.address().port}`,\n    connections: 2,\n    connectionRate: 10,\n    amount: 40,\n    sampleInt: 1000\n  }, (err, res) => {\n    t.error(err);\n    t.equal(Math.floor(res.duration), 2, 'should have taken 2 seconds to send 10 requests per connection with 2 connections');\n    t.equal(res.requests.average, 20, 'should have sent 20 requests per second on average with two connections');\n  });\n});","file":"runRate.test.js","skipped":false,"dir":"test"},{"name":"run should only send the expected number of requests per second - scenario 3","suites":[],"updatePoint":{"line":35,"column":82,"index":1280},"line":35,"code":"test('run should only send the expected number of requests per second - scenario 3', t => {\n  t.plan(3);\n  initJob({\n    url: `http://localhost:${server.address().port}`,\n    connections: 15,\n    overallRate: 10,\n    amount: 40,\n    sampleInt: 1000\n  }, (err, res) => {\n    t.error(err);\n    t.equal(Math.floor(res.duration), 4, 'should have take 4 seconds to send 10 requests per seconds');\n    t.equal(res.requests.average, 10, 'should have sent 10 requests per second on average');\n  });\n});","file":"runRate.test.js","skipped":false,"dir":"test"},{"name":"run should compensate for coordinated omission when the expected number of requests per second is too high","suites":[],"updatePoint":{"line":49,"column":112,"index":1805},"line":49,"code":"test('run should compensate for coordinated omission when the expected number of requests per second is too high', t => {\n  t.plan(2);\n  initJob({\n    url: `http://localhost:${server.address().port}`,\n    connections: 100,\n    connectionRate: 1000,\n    duration: 1\n  }, (err, res) => {\n    t.error(err);\n    t.not(res.latency.totalCount, res.requests.total, 'should have recorded additionnal latencies');\n  });\n});","file":"runRate.test.js","skipped":false,"dir":"test"},{"name":"run should not compensate for coordinated omission when this feature is disabled","suites":[],"updatePoint":{"line":61,"column":86,"index":2194},"line":61,"code":"test('run should not compensate for coordinated omission when this feature is disabled', t => {\n  t.plan(2);\n  initJob({\n    url: `http://localhost:${server.address().port}`,\n    connections: 100,\n    connectionRate: 1000,\n    ignoreCoordinatedOmission: true,\n    duration: 1\n  }, (err, res) => {\n    t.error(err);\n    t.equal(res.latency.totalCount, res.requests.total, 'should not have recorded additionnal latencies');\n  });\n});","file":"runRate.test.js","skipped":false,"dir":"test"},{"name":"validate should return an error","suites":[],"updatePoint":{"line":8,"column":37,"index":287},"line":8,"code":"test('validate should return an error', t => {\n  t.plan(2);\n  const args = {\n    sampleInt: 'hello',\n    url: 'https://github.com/mcollina/autocannon'\n  };\n  const result = validate(args);\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'sample interval entered was in an invalid format');\n});","file":"sampleInt.test.js","skipped":false,"dir":"test"},{"name":"validate should return an error","suites":[],"updatePoint":{"line":18,"column":37,"index":592},"line":18,"code":"test('validate should return an error', t => {\n  t.plan(2);\n  const args = {\n    sampleInt: -1,\n    url: 'https://github.com/mcollina/autocannon'\n  };\n  const result = validate(args);\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'sample interval can not be less than 0');\n});","file":"sampleInt.test.js","skipped":false,"dir":"test"},{"name":"validate should not return an error","suites":[],"updatePoint":{"line":28,"column":41,"index":886},"line":28,"code":"test('validate should not return an error', t => {\n  t.plan(2);\n  const args = {\n    sampleInt: 2,\n    url: 'https://github.com/mcollina/autocannon'\n  };\n  const result = validate(args);\n  t.ok(!(result instanceof Error));\n  t.equal(result.sampleInt, 2);\n});","file":"sampleInt.test.js","skipped":false,"dir":"test"},{"name":"parseArguments should accept value in ms (2000)","suites":[],"updatePoint":{"line":38,"column":53,"index":1157},"line":38,"code":"test('parseArguments should accept value in ms (2000)', t => {\n  t.plan(1);\n  const args = ['-L', 2000, 'https://github.com/mcollina/autocannon'];\n  const result = parseArguments(args);\n  t.equal(result.sampleInt, 2000);\n});","file":"sampleInt.test.js","skipped":false,"dir":"test"},{"name":"run should return sampleInt == 2000 & samples == 3","suites":[],"updatePoint":{"line":44,"column":56,"index":1385},"line":44,"code":"test('run should return sampleInt == 2000 & samples == 3', t => {\n  t.plan(2);\n  initJob({\n    duration: 6,\n    sampleInt: 2000,\n    url: 'https://github.com/mcollina/autocannon'\n  }, (err, res) => {\n    if (err) {\n      console.err(err);\n    }\n    t.equal(res.sampleInt, 2000);\n    t.equal(res.samples, 3);\n  });\n});","file":"sampleInt.test.js","skipped":false,"dir":"test"},{"name":"printResult should print the sample interval (2) & the total samples (3)","suites":[],"updatePoint":{"line":58,"column":78,"index":1725},"line":58,"code":"test('printResult should print the sample interval (2) & the total samples (3)', t => {\n  t.plan(2);\n  const result = {\n    duration: 6,\n    sampleInt: 2000,\n    samples: 3,\n    url: 'https://github.com/mcollina/autocannon',\n    latency: {},\n    requests: {},\n    throughput: {\n      average: 3319,\n      mean: 3319,\n      stddev: 0,\n      min: 3318,\n      max: 3318,\n      total: 3318,\n      p0_001: 3319,\n      p0_01: 3319,\n      p0_1: 3319,\n      p1: 3319,\n      p2_5: 3319,\n      p10: 3319,\n      p25: 3319,\n      p50: 3319,\n      p75: 3319,\n      p90: 3319,\n      p97_5: 3319,\n      p99: 3319,\n      p99_9: 3319,\n      p99_99: 3319,\n      p99_999: 3319\n    }\n  };\n  const output = printResult(result, {});\n  t.ok(output.includes('Req/Bytes counts sampled every 2 seconds.'));\n  t.ok(output.includes('# of samples: 3'));\n});","file":"sampleInt.test.js","skipped":false,"dir":"test"},{"name":"should print error if url.URL is not a function","suites":[],"updatePoint":{"line":13,"column":53,"index":401},"line":13,"code":"test('should print error if url.URL is not a function', t => {\n  t.plan(2);\n  const _error = console.error;\n  const _exit = process.exit;\n  process.exit = code => {\n    t.equal(code, 1);\n    process.exit = _exit;\n    t.end();\n  };\n  console.error = obj => {\n    t.equal(obj, 'autocannon requires the WHATWG URL API, but it is not available. Please upgrade to Node 6.13+.');\n    console.error = _error;\n  };\n  proxyquire('../..', {\n    url: {\n      URL: null\n    }\n  });\n});","file":"serial/autocannon.test.js","skipped":false,"dir":"test"},{"name":"should print version if invoked with --version","suites":[],"updatePoint":{"line":32,"column":52,"index":874},"line":32,"code":"test('should print version if invoked with --version', async t => {\n  t.plan(1);\n  const res = await exec(`node ${baseDir}/autocannon.js --version`);\n  t.ok(res.stdout.match(/autocannon v(\\d+\\.\\d+\\.\\d+)/));\n});","file":"serial/autocannon.test.js","skipped":false,"dir":"test"},{"name":"should print help if invoked with --help","suites":[],"updatePoint":{"line":37,"column":46,"index":1079},"line":37,"code":"test('should print help if invoked with --help', async t => {\n  t.plan(1);\n  const help = fs.readFileSync(path.join(baseDir, 'help.txt'), 'utf8');\n  const res = await exec(`node ${baseDir}/autocannon.js --help`);\n  t.same(res.stderr.trim(), help.trim()); // console.error adds \\n at the end of print\n});","file":"serial/autocannon.test.js","skipped":false,"dir":"test"},{"name":"should print help if no url is provided","suites":[],"updatePoint":{"line":44,"column":45,"index":1383},"line":44,"code":"test('should print help if no url is provided', async t => {\n  t.plan(1);\n  const help = fs.readFileSync(path.join(baseDir, 'help.txt'), 'utf8');\n  const res = await exec(`node ${baseDir}/autocannon.js`);\n  t.same(res.stderr.trim(), help.trim()); // console.error adds \\n at the end of print\n});","file":"serial/autocannon.test.js","skipped":false,"dir":"test"},{"name":"start should console an error when a promise is caught","suites":[],"updatePoint":{"line":51,"column":60,"index":1695},"line":51,"code":"test('start should console an error when a promise is caught', t => {\n  const Autocannon = t.mock('../../autocannon', {\n    '../../lib/init': () => new Promise((resolve, reject) => {\n      reject(new Error('Test Error'));\n    })\n  });\n  t.plan(1);\n  const _error = console.error;\n  console.error = obj => {\n    t.equal(obj, 'Test Error');\n    console.error = _error;\n  };\n  Autocannon.start(Autocannon.parseArguments(['-d', '1', '-c', '1', 'http://localhost/foo/bar']));\n});","file":"serial/autocannon.test.js","skipped":false,"dir":"test"},{"name":"start should console an error when one is thrown without a promise","suites":[],"updatePoint":{"line":65,"column":72,"index":2182},"line":65,"code":"test('start should console an error when one is thrown without a promise', t => {\n  const Autocannon = t.mock('../../autocannon', {\n    '../../lib/init': () => {\n      throw new Error('Test Error');\n    }\n  });\n  t.plan(1);\n  const _error = console.error;\n  console.error = obj => {\n    t.equal(obj, 'Test Error');\n    console.error = _error;\n  };\n  Autocannon.start(Autocannon.parseArguments(['-d', '1', '-c', '1', '--forever', 'http://localhost/foo/bar']));\n});","file":"serial/autocannon.test.js","skipped":false,"dir":"test"},{"name":"start should console an error when --on-port is used without async hooks","suites":[],"updatePoint":{"line":79,"column":78,"index":2652},"line":79,"code":"test('start should console an error when --on-port is used without async hooks', t => {\n  const Autocannon = t.mock('../../autocannon', {\n    'has-async-hooks': () => false,\n    child_process: {\n      spawn: () => {}\n    },\n    '../../lib/init': () => {},\n    net: {\n      createServer: () => ({\n        listen: () => {},\n        on: () => {}\n      })\n    }\n  });\n  t.plan(2);\n  const _exit = process.exit;\n  process.exit = code => {\n    t.equal(code, 1);\n    process.exit = _exit;\n    t.end();\n  };\n  const _error = console.error;\n  console.error = obj => {\n    t.equal(obj, 'The --on-port flag requires the async_hooks builtin module, but it is not available. Please upgrade to Node 8.1+.');\n    console.error = _error;\n  };\n  Autocannon.start(Autocannon.parseArguments(['-d', '1', '-c', '1', '--on-port', 'http://localhost/foo/bar']));\n});","file":"serial/autocannon.test.js","skipped":false,"dir":"test"},{"name":"When there is a port, createChannel should try to unlink the socketPath","suites":[],"updatePoint":{"line":107,"column":77,"index":3494},"line":107,"code":"test('When there is a port, createChannel should try to unlink the socketPath', t => {\n  const Autocannon = t.mock('../../autocannon', {\n    'has-async-hooks': () => true,\n    child_process: {\n      spawn: () => {}\n    },\n    '../../lib/init': () => {},\n    net: {\n      createServer: () => ({\n        listen: () => {},\n        on: (eventName, cb) => {\n          t.equal(eventName, 'close');\n          cb();\n        }\n      })\n    }\n  });\n  t.plan(1);\n  Autocannon.start(Autocannon.parseArguments(['-d', '1', '-c', '1', '--on-port', 'http://localhost/foo/bar']));\n});","file":"serial/autocannon.test.js","skipped":false,"dir":"test"},{"name":"createChannel should try to unlink the socketPath","suites":[],"updatePoint":{"line":127,"column":55,"index":4040},"line":127,"code":"test('createChannel should try to unlink the socketPath', t => {\n  const Autocannon = t.mock('../../autocannon', {\n    'has-async-hooks': () => true,\n    child_process: {\n      spawn: () => {}\n    },\n    '../../lib/init': () => {},\n    net: {\n      createServer: () => ({\n        listen: () => {},\n        on: (_, cb) => {\n          t.equal(_, 'close');\n          cb();\n        }\n      })\n    }\n  });\n  t.plan(1);\n  Autocannon.start(Autocannon.parseArguments(['-d', '1', '-c', '1', '--on-port', 'http://localhost/foo/bar']));\n});","file":"serial/autocannon.test.js","skipped":false,"dir":"test"},{"name":"should log error on connection error","suites":[],"updatePoint":{"line":5,"column":42,"index":135},"line":5,"code":"test('should log error on connection error', t => {\n  t.plan(1);\n  console.error = function (obj) {\n    t.type(obj, Error);\n    console.error = () => {};\n  };\n  initJob({\n    url: 'http://unknownhost',\n    connections: 2,\n    duration: 5,\n    title: 'title321',\n    debug: true\n  });\n});","file":"serial/run.test.js","skipped":false,"dir":"test"},{"name":"should clean up HdrHistogram WASM memory at each run","suites":[],"updatePoint":{"line":6,"column":58,"index":188},"line":6,"code":"test('should clean up HdrHistogram WASM memory at each run', async t => {\n  const server = helper.startServer();\n  const runTwentyTimes = (resolve, reject, numberOfRuns = 0) => {\n    initJob({\n      url: 'http://localhost:' + server.address().port,\n      connections: 1,\n      amount: 1\n    }, result => {\n      // should get error \" url or socketPath option required\"\n      // we can ignore this error, we just want run() to execute\n      // and to instantiate new WASM histograms\n      if (numberOfRuns < 20) {\n        runTwentyTimes(resolve, reject, ++numberOfRuns);\n      } else {\n        resolve();\n      }\n    });\n  };\n  const lotsOfRuns = [];\n  for (let index = 0; index < 50; index++) {\n    lotsOfRuns.push(new Promise(runTwentyTimes));\n  }\n  await Promise.all(lotsOfRuns);\n\n  // if the process has not crashed, we are good \\o/\n  t.end();\n});","file":"serial/wasm.test.js","skipped":false,"dir":"test"},{"name":"generateSubArgAliases Should generate warmup aliases","suites":[],"updatePoint":{"line":5,"column":58,"index":171},"line":5,"code":"test('generateSubArgAliases Should generate warmup aliases', t => {\n  t.plan(4);\n  const args = {\n    connections: 1,\n    duration: 2,\n    warmup: {\n      c: 3,\n      d: 4\n    }\n  };\n  const result = generateSubArgAliases(args);\n  t.equal(result.connections, 1);\n  t.equal(result.duration, 2);\n  t.equal(result.warmup.connections, 3);\n  t.equal(result.warmup.duration, 4);\n});","file":"subargAliases.test.js","skipped":false,"dir":"test"},{"name":"generateSubArgAliases should not process aliases that are not defined in subargAliases.js","suites":[],"updatePoint":{"line":21,"column":95,"index":585},"line":21,"code":"test('generateSubArgAliases should not process aliases that are not defined in subargAliases.js', t => {\n  t.plan(5);\n  const args = {\n    connections: 1,\n    warmup: {\n      c: 3,\n      T: 'A title'\n    }\n  };\n  const result = generateSubArgAliases(args);\n  t.equal(result.connections, 1);\n  t.equal(result.warmup.connections, 3);\n  t.equal(result.warmup.c, 3);\n  t.equal(result.warmup.T, 'A title');\n  t.equal(Object.keys(result.warmup).length, 3);\n});","file":"subargAliases.test.js","skipped":false,"dir":"test"},{"name":"checkURL should return true if a populated string is passed","suites":[],"updatePoint":{"line":9,"column":65,"index":223},"line":9,"code":"test('checkURL should return true if a populated string is passed', t => {\n  t.plan(1);\n  const result = checkURL('foo');\n  t.ok(result);\n});","file":"url.test.js","skipped":false,"dir":"test"},{"name":"checkURL should return false if an empty string is passed","suites":[],"updatePoint":{"line":14,"column":63,"index":363},"line":14,"code":"test('checkURL should return false if an empty string is passed', t => {\n  t.plan(1);\n  const result = checkURL('');\n  t.notOk(result);\n});","file":"url.test.js","skipped":false,"dir":"test"},{"name":"checkURL should return true if a populated array is passed","suites":[],"updatePoint":{"line":19,"column":64,"index":504},"line":19,"code":"test('checkURL should return true if a populated array is passed', t => {\n  t.plan(1);\n  const result = checkURL(['foo']);\n  t.ok(result);\n});","file":"url.test.js","skipped":false,"dir":"test"},{"name":"checkURL should return false if an empty array is passed","suites":[],"updatePoint":{"line":24,"column":62,"index":645},"line":24,"code":"test('checkURL should return false if an empty array is passed', t => {\n  t.plan(1);\n  const result = checkURL([]);\n  t.notOk(result);\n});","file":"url.test.js","skipped":false,"dir":"test"},{"name":"ofUrl should return the array if the passed in url is an array","suites":[],"updatePoint":{"line":29,"column":68,"index":790},"line":29,"code":"test('ofUrl should return the array if the passed in url is an array', t => {\n  t.plan(1);\n  const result = ofURL(['foo', 'bar']);\n  t.same(result, ['foo', 'bar']);\n});","file":"url.test.js","skipped":false,"dir":"test"},{"name":"When ofUrl is passed a string ofUrl should return an object containing a map function that accepts an url","suites":[],"updatePoint":{"line":34,"column":111,"index":1002},"line":34,"code":"test('When ofUrl is passed a string ofUrl should return an object containing a map function that accepts an url', t => {\n  t.plan(1);\n  const result = ofURL('foo', false);\n  const mappedResult = result.map(url => url);\n  t.same(mappedResult, 'foo');\n});","file":"url.test.js","skipped":false,"dir":"test"},{"name":"When ofUrl is passed a string and asArray=true ofUrl should return an object containing a map function that returns an array","suites":[],"updatePoint":{"line":40,"column":130,"index":1275},"line":40,"code":"test('When ofUrl is passed a string and asArray=true ofUrl should return an object containing a map function that returns an array', t => {\n  t.plan(1);\n  const result = ofURL('foo', true);\n  const mappedResult = result.map(url => url);\n  t.same(mappedResult, ['foo']);\n});","file":"url.test.js","skipped":false,"dir":"test"},{"name":"ofUrl Should throw an error when passed an invalid url type","suites":[],"updatePoint":{"line":46,"column":65,"index":1484},"line":46,"code":"test('ofUrl Should throw an error when passed an invalid url type', t => {\n  t.plan(1);\n  t.throws(() => ofURL(123), 'url should only be a string or an array of string');\n});","file":"url.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should not return an error with only an url passed in","suites":[],"updatePoint":{"line":9,"column":72,"index":262},"line":9,"code":"test('validateOpts should not return an error with only an url passed in', t => {\n  t.plan(1);\n  const result = validateOpts({\n    url: 'http://localhost'\n  });\n  t.ok(!(result instanceof Error));\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error when workers option is present and hasWorkerSupport is false","suites":[],"updatePoint":{"line":16,"column":102,"index":493},"line":16,"code":"test('validateOpts should return an error when workers option is present and hasWorkerSupport is false', t => {\n  const validateOpts = t.mock('../lib/validate', {\n    '../lib/util': {\n      hasWorkerSupport: false\n    }\n  });\n  t.plan(2);\n  const result = validateOpts({\n    workers: 1\n  });\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'Please use node >= 11.7.0 for workers support');\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error when bailout is less than 1","suites":[],"updatePoint":{"line":29,"column":69,"index":865},"line":29,"code":"test('validateOpts should return an error when bailout is less than 1', t => {\n  const validateOpts = t.mock('../lib/validate', {\n    '../lib/util': {\n      hasWorkerSupport: false\n    }\n  });\n  t.plan(2);\n  const result = validateOpts({\n    bailout: 0\n  });\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'bailout threshold can not be less than 1');\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error when connectionRate is less than 1","suites":[],"updatePoint":{"line":42,"column":76,"index":1239},"line":42,"code":"test('validateOpts should return an error when connectionRate is less than 1', t => {\n  t.plan(2);\n  const result = validateOpts({\n    connectionRate: 0\n  });\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'connectionRate can not be less than 1');\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error when overallRate is less than 1","suites":[],"updatePoint":{"line":50,"column":73,"index":1500},"line":50,"code":"test('validateOpts should return an error when overallRate is less than 1', t => {\n  t.plan(2);\n  const result = validateOpts({\n    overallRate: 0\n  });\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'bailout overallRate can not be less than 1');\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error when amount is less than 1","suites":[],"updatePoint":{"line":58,"column":68,"index":1758},"line":58,"code":"test('validateOpts should return an error when amount is less than 1', t => {\n  t.plan(2);\n  const result = validateOpts({\n    amount: 0\n  });\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'amount can not be less than 1');\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error when maxConnectionRequests is less than 1","suites":[],"updatePoint":{"line":66,"column":83,"index":2013},"line":66,"code":"test('validateOpts should return an error when maxConnectionRequests is less than 1', t => {\n  t.plan(2);\n  const result = validateOpts({\n    url: 'http://localhost',\n    maxConnectionRequests: 0\n  });\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'maxConnectionRequests can not be less than 1');\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error when maxOverallRequests is less than 1","suites":[],"updatePoint":{"line":75,"column":80,"index":2324},"line":75,"code":"test('validateOpts should return an error when maxOverallRequests is less than 1', t => {\n  t.plan(2);\n  const result = validateOpts({\n    maxOverallRequests: 0\n  });\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'maxOverallRequests can not be less than 1');\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error when requests does not contain a valid setupRequest function","suites":[],"updatePoint":{"line":83,"column":102,"index":2622},"line":83,"code":"test('validateOpts should return an error when requests does not contain a valid setupRequest function', t => {\n  t.plan(2);\n  const result = validateOpts({\n    url: 'http://localhost',\n    requests: [{\n      setupRequest: 123\n    }]\n  });\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'Invalid option setupRequest, please provide a function (or file path when in workers mode)');\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error when requests does not contain a valid onResponse function","suites":[],"updatePoint":{"line":94,"column":100,"index":3018},"line":94,"code":"test('validateOpts should return an error when requests does not contain a valid onResponse function', t => {\n  t.plan(2);\n  const result = validateOpts({\n    url: 'http://localhost',\n    requests: [{\n      onResponse: 123\n    }]\n  });\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'Invalid option onResponse, please provide a function (or file path when in workers mode)');\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error when setupClient is not a valid function","suites":[],"updatePoint":{"line":105,"column":82,"index":3392},"line":105,"code":"test('validateOpts should return an error when setupClient is not a valid function', t => {\n  t.plan(2);\n  const result = validateOpts({\n    url: 'http://localhost',\n    setupClient: 123\n  });\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'Invalid option setupClient, please provide a function (or file path when in workers mode)');\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error if neither url or socket path are provided","suites":[],"updatePoint":{"line":114,"column":84,"index":3744},"line":114,"code":"test('validateOpts should return an error if neither url or socket path are provided', t => {\n  t.plan(2);\n  const result = validateOpts({});\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'url or socketPath option required');\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should convert a duration that is a string representation of a number into a number","suites":[],"updatePoint":{"line":120,"column":102,"index":4005},"line":120,"code":"test('validateOpts should convert a duration that is a string representation of a number into a number', t => {\n  t.plan(1);\n  const result = validateOpts({\n    url: 'http://localhost',\n    duration: '100'\n  });\n  t.equal(result.duration, 100);\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should convert a duration that is a timestring into a number","suites":[],"updatePoint":{"line":128,"column":79,"index":4231},"line":128,"code":"test('validateOpts should convert a duration that is a timestring into a number', t => {\n  t.plan(1);\n  const result = validateOpts({\n    url: 'http://localhost',\n    duration: '2 weeks'\n  });\n  t.equal(result.duration, 1209600);\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error if duration is in an invalid format","suites":[],"updatePoint":{"line":136,"column":77,"index":4463},"line":136,"code":"test('validateOpts should return an error if duration is in an invalid format', t => {\n  t.plan(1);\n  const result = validateOpts({\n    url: 'http://localhost',\n    duration: '2 dsweeks'\n  });\n  t.ok(result instanceof Error);\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error if duration less than 0","suites":[],"updatePoint":{"line":144,"column":65,"index":4681},"line":144,"code":"test('validateOpts should return an error if duration less than 0', t => {\n  t.plan(2);\n  const result = validateOpts({\n    url: 'http://localhost',\n    duration: -1\n  });\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'duration can not be less than 0');\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error if expectBody is used in conjunction with requests","suites":[],"updatePoint":{"line":153,"column":92,"index":4979},"line":153,"code":"test('validateOpts should return an error if expectBody is used in conjunction with requests', t => {\n  t.plan(2);\n  const result = validateOpts({\n    url: 'http://localhost',\n    expectBody: 'foo',\n    requests: []\n  });\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'expectBody cannot be used in conjunction with requests');\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should parse a multipart form correctly","suites":[],"updatePoint":{"line":163,"column":58,"index":5289},"line":163,"code":"test('validateOpts should parse a multipart form correctly', t => {\n  t.plan(1);\n  const result = validateOpts({\n    url: 'http://localhost',\n    form: '{ \"field 1\": { \"type\": \"text\", \"value\": \"a text value\"} }'\n  });\n  t.ok(result.form);\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error if a multipart form is incorrectly formatted","suites":[],"updatePoint":{"line":171,"column":86,"index":5560},"line":171,"code":"test('validateOpts should return an error if a multipart form is incorrectly formatted', t => {\n  t.plan(1);\n  const result = validateOpts({\n    url: 'http://localhost',\n    form: 'invalid form'\n  });\n  t.ok(result instanceof Error);\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should parse a HAR request successfully","suites":[],"updatePoint":{"line":179,"column":58,"index":5770},"line":179,"code":"test('validateOpts should parse a HAR request successfully', t => {\n  t.plan(1);\n  const har = helper.customizeHAR('./fixtures/httpbin-get.json', 'https://httpbin.org', 'http://localhost');\n  const result = validateOpts({\n    url: 'http://localhost',\n    har\n  });\n  t.ok(result.har);\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error if a HAR request is unsuccessful","suites":[],"updatePoint":{"line":188,"column":74,"index":6075},"line":188,"code":"test('validateOpts should return an error if a HAR request is unsuccessful', t => {\n  t.plan(1);\n  const result = validateOpts({\n    url: 'http://localhost',\n    har: 'invalid har'\n  });\n  t.ok(result instanceof Error);\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error when connections is less than 1","suites":[],"updatePoint":{"line":196,"column":73,"index":6298},"line":196,"code":"test('validateOpts should return an error when connections is less than 1', t => {\n  t.plan(2);\n  const result = validateOpts({\n    url: 'http://localhost',\n    connections: 0\n  });\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'connections can not be less than 1');\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error when ignoreCoordinatedOmission used without connectionRate or overallRate","suites":[],"updatePoint":{"line":205,"column":115,"index":6624},"line":205,"code":"test('validateOpts should return an error when ignoreCoordinatedOmission used without connectionRate or overallRate', t => {\n  t.plan(2);\n  const result = validateOpts({\n    url: 'http://localhost',\n    ignoreCoordinatedOmission: true\n  });\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'ignoreCoordinatedOmission makes no sense without connectionRate or overallRate');\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts is successful when ignoreCoordinatedOmission is used with connectionRate","suites":[],"updatePoint":{"line":214,"column":91,"index":6987},"line":214,"code":"test('validateOpts is successful when ignoreCoordinatedOmission is used with connectionRate', t => {\n  t.plan(1);\n  const result = validateOpts({\n    url: 'http://localhost',\n    ignoreCoordinatedOmission: true,\n    connectionRate: 1\n  });\n  t.ok(result.ignoreCoordinatedOmission);\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts is successful when ignoreCoordinatedOmission is used with overallRate","suites":[],"updatePoint":{"line":223,"column":88,"index":7270},"line":223,"code":"test('validateOpts is successful when ignoreCoordinatedOmission is used with overallRate', t => {\n  t.plan(1);\n  const result = validateOpts({\n    url: 'http://localhost',\n    ignoreCoordinatedOmission: true,\n    overallRate: 1\n  });\n  t.ok(result.ignoreCoordinatedOmission);\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error when forever is used with cbPassedIn","suites":[],"updatePoint":{"line":232,"column":78,"index":7540},"line":232,"code":"test('validateOpts should return an error when forever is used with cbPassedIn', t => {\n  t.plan(2);\n  const result = validateOpts({\n    url: 'http://localhost',\n    forever: true\n  }, () => {});\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'should not use the callback parameter when the `forever` option is set to true. Use the `done` event on this event emitter');\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"validateOpts should return an error when forever is used with workers","suites":[],"updatePoint":{"line":241,"column":75,"index":7923},"line":241,"code":"test('validateOpts should return an error when forever is used with workers', {\n  skip: !hasWorkerSupport\n}, t => {\n  t.plan(2);\n  const result = validateOpts({\n    url: 'http://localhost',\n    forever: true,\n    workers: 2\n  });\n  t.ok(result instanceof Error);\n  t.equal(result.message, 'Using `forever` option isn\\'t currently supported with workers');\n});","file":"validate.test.js","skipped":false,"dir":"test"},{"name":"returns error when no worker support was found","suites":[],"updatePoint":{"line":13,"column":52,"index":366},"line":13,"code":"test('returns error when no worker support was found', t => {\n  const server = helper.startServer();\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 3,\n    workers: 3,\n    amount: 6,\n    title: 'with-workers'\n  }, function (err, result) {\n    if (hasWorkerSupport) {\n      t.error(err);\n    } else {\n      t.equal(err.message, 'Please use node >= 11.7.0 for workers support');\n    }\n    t.end();\n  });\n});","file":"workers.test.js","skipped":false,"dir":"test"},{"name":"init with workers","suites":[],"updatePoint":{"line":30,"column":23,"index":778},"line":30,"code":"test('init with workers', {\n  skip: !hasWorkerSupport\n}, t => {\n  const server = helper.startServer();\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 3,\n    workers: 3,\n    amount: 6,\n    title: 'with-workers'\n  }, function (err, result) {\n    t.error(err);\n    t.ok(result.workers === 3, 'correct worker count');\n    t.equal(result.title, 'with-workers', 'title should be what was passed in');\n    t.equal(result.connections, 3, 'connections is the same');\n    t.equal(result.pipelining, 1, 'pipelining is the default');\n    t.ok(result.latency, 'latency exists');\n    t.type(result.latency.average, 'number', 'latency.average exists');\n    t.type(result.latency.stddev, 'number', 'latency.stddev exists');\n    t.ok(result.latency.min >= 0, 'latency.min exists');\n    t.type(result.latency.max, 'number', 'latency.max exists');\n    t.type(result.latency.p2_5, 'number', 'latency.p2_5 (2.5%) exists');\n    t.type(result.latency.p50, 'number', 'latency.p50 (50%) exists');\n    t.type(result.latency.p97_5, 'number', 'latency.p97_5 (97.5%) exists');\n    t.type(result.latency.p99, 'number', 'latency.p99 (99%) exists');\n    t.ok(result.requests, 'requests exists');\n    t.type(result.requests.average, 'number', 'requests.average exists');\n    t.type(result.requests.stddev, 'number', 'requests.stddev exists');\n    t.type(result.requests.min, 'number', 'requests.min exists');\n    t.type(result.requests.max, 'number', 'requests.max exists');\n    t.ok(result.requests.total === 6, 'requests.total exists');\n    t.type(result.requests.sent, 'number', 'sent exists');\n    t.ok(result.requests.sent >= result.requests.total, 'total requests made should be more than or equal to completed requests total');\n    t.type(result.requests.p1, 'number', 'requests.p1 (1%) exists');\n    t.type(result.requests.p2_5, 'number', 'requests.p2_5 (2.5%) exists');\n    t.type(result.requests.p50, 'number', 'requests.p50 (50%) exists');\n    t.type(result.requests.p97_5, 'number', 'requests.p97_5 (97.5%) exists');\n    t.ok(result.throughput, 'throughput exists');\n    t.type(result.throughput.average, 'number', 'throughput.average exists');\n    t.type(result.throughput.stddev, 'number', 'throughput.stddev exists');\n    t.type(result.throughput.min, 'number', 'throughput.min exists');\n    t.type(result.throughput.max, 'number', 'throughput.max exists');\n    t.type(result.throughput.total, 'number', 'throughput.total exists');\n    t.type(result.throughput.p1, 'number', 'throughput.p1 (1%) exists');\n    t.type(result.throughput.p2_5, 'number', 'throughput.p2_5 (2.5%) exists');\n    t.type(result.throughput.p50, 'number', 'throughput.p50 (50%) exists');\n    t.type(result.throughput.p97_5, 'number', 'throughput.p97_5 (97.5%) exists');\n    t.ok(result.start, 'start time exists');\n    t.ok(result.finish, 'finish time exists');\n    t.equal(result.errors, 0, 'no errors');\n    t.equal(result.mismatches, 0, 'no mismatches');\n    t.equal(result.resets, 0, 'no resets');\n    t.equal(result['1xx'], 0, '1xx codes');\n    t.equal(result['2xx'], result.requests.total, '2xx codes');\n    t.equal(result['3xx'], 0, '3xx codes');\n    t.equal(result['4xx'], 0, '4xx codes');\n    t.equal(result['5xx'], 0, '5xx codes');\n    t.equal(result.non2xx, 0, 'non 2xx codes');\n    t.end();\n  });\n});","file":"workers.test.js","skipped":false,"dir":"test"},{"name":"setupRequest and onResponse work with workers","suites":[],"updatePoint":{"line":91,"column":51,"index":4109},"line":91,"code":"test('setupRequest and onResponse work with workers', {\n  skip: !hasWorkerSupport\n}, t => {\n  const server = http.createServer((req, res) => {\n    // it's not easy to assert things within setupRequest and onResponse\n    // when in workers mode. So, we set something in onResponse and use in the\n    // next Request and make sure it exist or we return 404.\n    if (req.method === 'GET' && req.url !== '/test-123?some=thing&bar=baz') {\n      res.statusCode = 404;\n      res.end('NOT OK');\n      return;\n    }\n    res.end('OK');\n  });\n  server.listen(0);\n  server.unref();\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 2,\n    amount: 4,\n    workers: 1,\n    requests: [{\n      method: 'PUT',\n      onResponse: path.join(__dirname, './utils/on-response')\n    }, {\n      method: 'GET',\n      setupRequest: path.join(__dirname, './utils/setup-request')\n    }]\n  }, function (err, result) {\n    t.error(err);\n    t.equal(4, result['2xx'], 'should have 4 ok requests');\n    t.equal(0, result['4xx'], 'should not have any 404s');\n    t.end();\n  });\n});","file":"workers.test.js","skipped":false,"dir":"test"},{"name":"verifyBody work with workers","suites":[],"updatePoint":{"line":126,"column":34,"index":5172},"line":126,"code":"test('verifyBody work with workers', {\n  skip: !hasWorkerSupport\n}, t => {\n  const server = http.createServer((req, res) => {\n    // it's not easy to assert things within setupRequest and onResponse\n    // when in workers mode. So, we set something in onResponse and use in the\n    // next Request and make sure it exist or we return 404.\n    if (req.method === 'GET' && req.url !== '/test-123?some=thing&bar=baz') {\n      res.statusCode = 404;\n      res.end('NOT OK');\n      return;\n    }\n    res.end('OK');\n  });\n  server.listen(0);\n  server.unref();\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 2,\n    amount: 4,\n    workers: 1,\n    verifyBody: path.join(__dirname, './utils/verify-body')\n  }, function (err, result) {\n    t.error(err);\n    t.equal(4, result.mismatches, 'should have 4 mismatches requests');\n    t.end();\n  });\n});","file":"workers.test.js","skipped":false,"dir":"test"},{"name":"setupClient works with workers","suites":[],"updatePoint":{"line":154,"column":36,"index":6047},"line":154,"code":"test('setupClient works with workers', {\n  skip: !hasWorkerSupport\n}, t => {\n  const server = http.createServer((req, res) => {\n    if (req.headers.custom !== 'my-header') {\n      res.statusCode = 404;\n      res.end('NOT OK');\n      return;\n    }\n    res.end('OK');\n  });\n  server.listen(0);\n  server.unref();\n  initJob({\n    url: 'http://localhost:' + server.address().port,\n    connections: 2,\n    amount: 2,\n    workers: 1,\n    setupClient: path.join(__dirname, './utils/setup-client')\n  }, function (err, result) {\n    t.error(err);\n    t.equal(2, result['2xx'], 'should have 2 ok requests');\n    t.equal(0, result['4xx'], 'should not have any 404s');\n    t.end();\n  });\n});","file":"workers.test.js","skipped":false,"dir":"test"},{"name":"tlsOptions using pfx work as intended in workers","suites":[],"updatePoint":{"line":180,"column":54,"index":6744},"line":180,"code":"test('tlsOptions using pfx work as intended in workers', {\n  skip: !hasWorkerSupport\n}, t => {\n  initJob({\n    url: 'https://localhost:' + httpsServer.address().port,\n    connections: 1,\n    amount: 1,\n    workers: 2,\n    tlsOptions: {\n      pfx: fs.readFileSync(path.join(__dirname, '/keystore.pkcs12')),\n      passphrase: 'test'\n    }\n  }, function (err, result) {\n    t.error(err);\n    t.ok(result, 'requests are ok');\n    t.end();\n  });\n});","file":"workers.test.js","skipped":false,"dir":"test"}]}