{"repo":"rrweb-io/rrweb","url":"https://github.com/rrweb-io/rrweb","branch":"master","configs":[{"package":"rrweb-snapshot","lang":"ts","dir":"packages/rrweb-snapshot/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"rrweb","lang":"ts","dir":"packages/rrweb/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should save the filename and source","suites":["css parser"],"updatePoint":{"line":5,"column":41},"line":5,"code":"  it('should save the filename and source', () => {\n    const css = 'booty {\\n  size: large;\\n}\\n';\n    const ast = parse(css, {\n      source: 'booty.css',\n    });\n\n    expect(ast.stylesheet!.source).toEqual('booty.css');\n\n    const position = ast.stylesheet!.rules[0].position!;\n    expect(position.start).toBeTruthy();\n    expect(position.end).toBeTruthy();\n    expect(position.source).toEqual('booty.css');\n    expect(position.content).toEqual(css);\n  });","file":"css.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should throw when a selector is missing","suites":["css parser"],"updatePoint":{"line":20,"column":45},"line":20,"code":"  it('should throw when a selector is missing', () => {\n    expect(() => {\n      parse('{size: large}');\n    }).toThrow();\n\n    expect(() => {\n      parse('b { color: red; }\\n{ color: green; }\\na { color: blue; }');\n    }).toThrow();\n  });","file":"css.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should throw when a broken comment is found","suites":["css parser"],"updatePoint":{"line":30,"column":49},"line":30,"code":"  it('should throw when a broken comment is found', () => {\n    expect(() => {\n      parse('thing { color: red; } /* b { color: blue; }');\n    }).toThrow();\n\n    expect(() => {\n      parse('/*');\n    }).toThrow();\n\n    /* Nested comments should be fine */\n    expect(() => {\n      parse('/* /* */');\n    }).not.toThrow();\n  });","file":"css.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should allow empty property value","suites":["css parser"],"updatePoint":{"line":45,"column":39},"line":45,"code":"  it('should allow empty property value', () => {\n    expect(() => {\n      parse('p { color:; }');\n    }).not.toThrow();\n  });","file":"css.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should not throw with silent option","suites":["css parser"],"updatePoint":{"line":51,"column":41},"line":51,"code":"  it('should not throw with silent option', () => {\n    expect(() => {\n      parse('thing { color: red; } /* b { color: blue; }', { silent: true });\n    }).not.toThrow();\n  });","file":"css.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should list the parsing errors and continue parsing","suites":["css parser"],"updatePoint":{"line":57,"column":57},"line":57,"code":"  it('should list the parsing errors and continue parsing', () => {\n    const result = parse(\n      'foo { color= red; } bar { color: blue; } baz {}} boo { display: none}',\n      {\n        silent: true,\n        source: 'foo.css',\n      },\n    );\n\n    const rules = result.stylesheet!.rules;\n    expect(rules.length).toBeGreaterThan(2);\n\n    const errors = result.stylesheet!.parsingErrors!;\n    expect(errors.length).toEqual(2);\n\n    expect(errors[0]).toHaveProperty('message');\n    expect(errors[0]).toHaveProperty('reason');\n    expect(errors[0]).toHaveProperty('filename');\n    expect(errors[0]).toHaveProperty('line');\n    expect(errors[0]).toHaveProperty('column');\n    expect(errors[0]).toHaveProperty('source');\n    expect(errors[0].filename).toEqual('foo.css');\n  });","file":"css.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should set parent property","suites":["css parser"],"updatePoint":{"line":81,"column":32},"line":81,"code":"  it('should set parent property', () => {\n    const result = parse(\n      'thing { test: value; }\\n' +\n        '@media (min-width: 100px) { thing { test: value; } }',\n    );\n\n    expect(result.parent).toEqual(null);\n\n    const rules = result.stylesheet!.rules;\n    expect(rules.length).toEqual(2);\n\n    let rule = rules[0] as Rule;\n    expect(rule.parent).toEqual(result);\n    expect(rule.declarations!.length).toEqual(1);\n\n    let decl = rule.declarations![0];\n    expect(decl.parent).toEqual(rule);\n\n    const media = rules[1] as Media;\n    expect(media.parent).toEqual(result);\n    expect(media.rules!.length).toEqual(1);\n\n    rule = media.rules![0] as Rule;\n    expect(rule.parent).toEqual(media);\n\n    expect(rule.declarations!.length).toEqual(1);\n    decl = rule.declarations![0];\n    expect(decl.parent).toEqual(rule);\n  });","file":"css.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"parses : in attribute selectors correctly","suites":["css parser"],"updatePoint":{"line":111,"column":47},"line":111,"code":"  it('parses : in attribute selectors correctly', () => {\n    const out1 = validateStringifiedCssRule('[data-foo] { color: red; }');\n    expect(out1).toEqual('[data-foo] { color: red; }');\n\n    const out2 = validateStringifiedCssRule('[data-foo:other] { color: red; }');\n    expect(out2).toEqual('[data-foo\\\\:other] { color: red; }');\n\n    const out3 = validateStringifiedCssRule(\n      '[data-aa\\\\:other] { color: red; }',\n    );\n    expect(out3).toEqual('[data-aa\\\\:other] { color: red; }');\n  });","file":"css.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"correctly triggers backCompat mode and rendering","suites":["integration tests"],"updatePoint":{"line":153,"column":54},"line":153,"code":"  it('correctly triggers backCompat mode and rendering', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    // console for debug\n    page.on('console', (msg) => console.log(msg.text()));\n\n    await page.goto('http://localhost:3030/html/compat-mode.html', {\n      waitUntil: 'load',\n    });\n    const compatMode = await page.evaluate('document.compatMode');\n    assert(\n      compatMode === 'BackCompat',\n      compatMode +\n        ' for compat-mode.html should be BackCompat as DOCTYPE is deliberately omitted',\n    );\n    const renderedHeight = (await page.evaluate(\n      'document.querySelector(\"center\").clientHeight',\n    )) as number;\n    // can remove following assertion if dimensions of page change\n    assert(\n      renderedHeight < 400,\n      `pre-check: images will be rendered ~326px high in BackCompat mode, and ~588px in CSS1Compat mode; getting: ${renderedHeight}px`,\n    );\n    const rebuildRenderedHeight = await page.evaluate(`${code}\nconst snap = rrweb.snapshot(document);\nconst iframe = document.createElement('iframe');\niframe.setAttribute('width', document.body.clientWidth)\niframe.setAttribute('height', document.body.clientHeight)\niframe.style.transform = 'scale(0.3)'; // mini-me\ndocument.body.appendChild(iframe);\n// magic here! rebuild in a new iframe\nconst rebuildNode = rrweb.rebuild(snap, { doc: iframe.contentDocument })[0];\niframe.contentDocument.querySelector('center').clientHeight\n`);\n    const rebuildCompatMode = await page.evaluate(\n      'document.querySelector(\"iframe\").contentDocument.compatMode',\n    );\n    assert(\n      rebuildCompatMode === 'BackCompat',\n      \"rebuilt compatMode should match source compatMode, but doesn't: \" +\n        rebuildCompatMode,\n    );\n    assert(\n      rebuildRenderedHeight === renderedHeight,\n      'rebuilt height (${rebuildRenderedHeight}) should equal original height (${renderedHeight})',\n    );\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"correctly saves images offline","suites":["integration tests"],"updatePoint":{"line":200,"column":36},"line":200,"code":"  it('correctly saves images offline', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n\n    await page.goto('http://localhost:3030/html/picture.html', {\n      waitUntil: 'load',\n    });\n    await page.waitForSelector('img', { timeout: 1000 });\n    await page.evaluate(`${code}var snapshot = rrweb.snapshot(document, {\n        dataURLOptions: { type: \"image/webp\", quality: 0.8 },\n        inlineImages: true,\n        inlineStylesheet: false\n    })`);\n    await waitForRAF(page);\n    const snapshot = (await page.evaluate(\n      'JSON.stringify(snapshot, null, 2);',\n    )) as string;\n    assert(snapshot.includes('\"rr_dataURL\"'));\n    assert(snapshot.includes('data:image/webp;base64,'));\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"correctly saves blob:images offline","suites":["integration tests"],"updatePoint":{"line":220,"column":41},"line":220,"code":"  it('correctly saves blob:images offline', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n\n    await page.goto('http://localhost:3030/html/picture-blob.html', {\n      waitUntil: 'load',\n    });\n    await page.waitForSelector('img', { timeout: 1000 });\n    await page.evaluate(`${code}var snapshot = rrweb.snapshot(document, {\n        dataURLOptions: { type: \"image/webp\", quality: 0.8 },\n        inlineImages: true,\n        inlineStylesheet: false\n    })`);\n    await waitForRAF(page);\n    const snapshot = (await page.evaluate(\n      'JSON.stringify(snapshot, null, 2);',\n    )) as string;\n    assert(snapshot.includes('\"rr_dataURL\"'));\n    assert(snapshot.includes('data:image/webp;base64,'));\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"correctly saves images in iframes offline","suites":["integration tests"],"updatePoint":{"line":240,"column":47},"line":240,"code":"  it('correctly saves images in iframes offline', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n\n    await page.goto('http://localhost:3030/html/picture-in-frame.html', {\n      waitUntil: 'load',\n    });\n    await page.waitForSelector('iframe', { timeout: 1000 });\n    await waitForRAF(page); // wait for page to render\n    await page.evaluate(`${code}\n        rrweb.snapshot(document, {\n        dataURLOptions: { type: \"image/webp\", quality: 0.8 },\n        inlineImages: true,\n        inlineStylesheet: false,\n        onIframeLoad: function(iframe, sn) {\n          window.snapshot = sn;\n        }\n    })`);\n    await waitForRAF(page);\n    const snapshot = (await page.evaluate(\n      'JSON.stringify(window.snapshot, null, 2);',\n    )) as string;\n    assert(snapshot.includes('\"rr_dataURL\"'));\n    assert(snapshot.includes('data:image/webp;base64,'));\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"correctly saves blob:images in iframes offline","suites":["integration tests"],"updatePoint":{"line":265,"column":52},"line":265,"code":"  it('correctly saves blob:images in iframes offline', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n\n    await page.goto('http://localhost:3030/html/picture-blob-in-frame.html', {\n      waitUntil: 'load',\n    });\n    await page.waitForSelector('iframe', { timeout: 1000 });\n    await waitForRAF(page); // wait for page to render\n    await page.evaluate(`${code}\n        rrweb.snapshot(document, {\n        dataURLOptions: { type: \"image/webp\", quality: 0.8 },\n        inlineImages: true,\n        inlineStylesheet: false,\n        onIframeLoad: function(iframe, sn) {\n          window.snapshot = sn;\n        }\n    })`);\n    await waitForRAF(page);\n    const snapshot = (await page.evaluate(\n      'JSON.stringify(window.snapshot, null, 2);',\n    )) as string;\n    assert(snapshot.includes('\"rr_dataURL\"'));\n    assert(snapshot.includes('data:image/webp;base64,'));\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should save background-clip: text; as the more compatible -webkit-background-clip: test;","suites":["integration tests"],"updatePoint":{"line":290,"column":94},"line":290,"code":"  it('should save background-clip: text; as the more compatible -webkit-background-clip: test;', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto(`http://localhost:3030/html/background-clip-text.html`, {\n      waitUntil: 'load',\n    });\n    await waitForRAF(page); // wait for page to render\n    await page.evaluate(`${code}\n        window.snapshot = rrweb.snapshot(document, {\n        inlineStylesheet: true,\n    })`);\n    await waitForRAF(page);\n    const snapshot = (await page.evaluate(\n      'JSON.stringify(window.snapshot, null, 2);',\n    )) as string;\n    assert(snapshot.includes('-webkit-background-clip: text;'));\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"images with inline onload should work","suites":["integration tests"],"updatePoint":{"line":307,"column":43},"line":307,"code":"  it('images with inline onload should work', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n\n    await page.goto(\n      'http://localhost:3030/html/picture-with-inline-onload.html',\n      {\n        waitUntil: 'load',\n      },\n    );\n    await page.waitForSelector('img', { timeout: 1000 });\n    await page.evaluate(`${code}var snapshot = rrweb.snapshot(document, {\n        dataURLOptions: { type: \"image/webp\", quality: 0.8 },\n        inlineImages: true,\n        inlineStylesheet: false\n    })`);\n    await waitForRAF(page);\n    const fnName = (await page.evaluate(\n      'document.querySelector(\"img\").onload.name',\n    )) as string;\n    assert(fnName === 'onload');\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"snapshot async iframes","suites":["iframe integration tests"],"updatePoint":{"line":360,"column":28},"line":360,"code":"  it('snapshot async iframes', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    // console for debug\n    page.on('console', (msg) => console.log(msg.text()));\n    await page.goto(`http://localhost:3030/iframe-html/main.html`, {\n      waitUntil: 'load',\n    });\n    const snapshotResult = JSON.stringify(\n      await page.evaluate(`${code};\n      rrweb.snapshot(document);\n    `),\n      null,\n      2,\n    );\n    expect(snapshotResult).toMatchSnapshot();\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"snapshot shadow DOM","suites":["shadow DOM integration tests"],"updatePoint":{"line":408,"column":25},"line":408,"code":"  it('snapshot shadow DOM', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    // console for debug\n    page.on('console', (msg) => console.log(msg.text()));\n    await page.goto(`http://localhost:3030/html/shadow-dom.html`, {\n      waitUntil: 'load',\n    });\n    const snapshotResult = JSON.stringify(\n      await page.evaluate(`${code};\n      rrweb.snapshot(document);\n    `),\n      null,\n      2,\n    );\n    expect(snapshotResult).toMatchSnapshot();\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should rebuild dataURL","suites":["rebuild","rr_dataURL"],"updatePoint":{"line":25,"column":30},"line":25,"code":"    it('should rebuild dataURL', function () {\n      const dataURI =\n        'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';\n      const node = buildNodeWithSN(\n        {\n          id: 1,\n          tagName: 'img',\n          type: NodeType.Element,\n          attributes: {\n            rr_dataURL: dataURI,\n            src: 'http://example.com/image.png',\n          },\n          childNodes: [],\n        },\n        {\n          doc: document,\n          mirror,\n          hackCss: false,\n          cache,\n        },\n      ) as HTMLImageElement;\n      expect(node?.src).toBe(dataURI);\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"rebuild shadowRoot without siblings","suites":["rebuild","shadowDom"],"updatePoint":{"line":51,"column":43},"line":51,"code":"    it('rebuild shadowRoot without siblings', function () {\n      const node = buildNodeWithSN(\n        {\n          id: 1,\n          tagName: 'div',\n          type: NodeType.Element,\n          attributes: {},\n          childNodes: [\n            {\n              id: 2,\n              tagName: 'div',\n              type: NodeType.Element,\n              attributes: {},\n              childNodes: [],\n              isShadow: true,\n            },\n          ],\n          isShadowHost: true,\n        },\n        {\n          doc: document,\n          mirror,\n          hackCss: false,\n          cache,\n        },\n      ) as HTMLDivElement;\n      expect(node.shadowRoot?.childNodes.length).toBe(1);\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"will do nothing to css text without :hover","suites":["rebuild","add hover class to hover selector related rules"],"updatePoint":{"line":82,"column":50},"line":82,"code":"    it('will do nothing to css text without :hover', () => {\n      const cssText = 'body { color: white }';\n      expect(addHoverClass(cssText, cache)).toEqual(cssText);\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can add hover class to css text","suites":["rebuild","add hover class to hover selector related rules"],"updatePoint":{"line":87,"column":39},"line":87,"code":"    it('can add hover class to css text', () => {\n      const cssText = '.a:hover { color: white }';\n      expect(addHoverClass(cssText, cache)).toEqual(\n        '.a:hover, .a.\\\\:hover { color: white }',\n      );\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can add hover class when there is multi selector","suites":["rebuild","add hover class to hover selector related rules"],"updatePoint":{"line":94,"column":56},"line":94,"code":"    it('can add hover class when there is multi selector', () => {\n      const cssText = '.a, .b:hover, .c { color: white }';\n      expect(addHoverClass(cssText, cache)).toEqual(\n        '.a, .b:hover, .b.\\\\:hover, .c { color: white }',\n      );\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can add hover class when there is a multi selector with the same prefix","suites":["rebuild","add hover class to hover selector related rules"],"updatePoint":{"line":101,"column":79},"line":101,"code":"    it('can add hover class when there is a multi selector with the same prefix', () => {\n      const cssText = '.a:hover, .a:hover::after { color: white }';\n      expect(addHoverClass(cssText, cache)).toEqual(\n        '.a:hover, .a.\\\\:hover, .a:hover::after, .a.\\\\:hover::after { color: white }',\n      );\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can add hover class when :hover is not the end of selector","suites":["rebuild","add hover class to hover selector related rules"],"updatePoint":{"line":108,"column":66},"line":108,"code":"    it('can add hover class when :hover is not the end of selector', () => {\n      const cssText = 'div:hover::after { color: white }';\n      expect(addHoverClass(cssText, cache)).toEqual(\n        'div:hover::after, div.\\\\:hover::after { color: white }',\n      );\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can add hover class when the selector has multi :hover","suites":["rebuild","add hover class to hover selector related rules"],"updatePoint":{"line":115,"column":62},"line":115,"code":"    it('can add hover class when the selector has multi :hover', () => {\n      const cssText = 'a:hover b:hover { color: white }';\n      expect(addHoverClass(cssText, cache)).toEqual(\n        'a:hover b:hover, a.\\\\:hover b.\\\\:hover { color: white }',\n      );\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"will ignore :hover in css value","suites":["rebuild","add hover class to hover selector related rules"],"updatePoint":{"line":122,"column":39},"line":122,"code":"    it('will ignore :hover in css value', () => {\n      const cssText = '.a::after { content: \":hover\" }';\n      expect(addHoverClass(cssText, cache)).toEqual(cssText);\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"benchmark","suites":["rebuild","add hover class to hover selector related rules"],"line":128,"code":"    it.skip('benchmark', () => {","file":"rebuild.test.ts","skipped":true,"dir":"packages/rrweb-snapshot/test"},{"name":"should be a lot faster to add a hover class to a previously processed css string","suites":["rebuild","add hover class to hover selector related rules"],"updatePoint":{"line":140,"column":88},"line":140,"code":"    it('should be a lot faster to add a hover class to a previously processed css string', () => {\n      const factor = 100;\n\n      let cssText = fs.readFileSync(\n        path.resolve(__dirname, './css/benchmark.css'),\n        'utf8',\n      );\n\n      const start = process.hrtime();\n      addHoverClass(cssText, cache);\n      const end = process.hrtime(start);\n\n      const cachedStart = process.hrtime();\n      addHoverClass(cssText, cache);\n      const cachedEnd = process.hrtime(cachedStart);\n\n      expect(getDuration(cachedEnd) * factor).toBeLessThan(getDuration(end));\n    });","file":"rebuild.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle relative path","suites":["absolute url to stylesheet"],"updatePoint":{"line":16,"column":30},"line":16,"code":"  it('can handle relative path', () => {\n    expect(absoluteToStylesheet('url(a.jpg)', href)).toEqual(\n      `url(http://localhost/css/a.jpg)`,\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle same level path","suites":["absolute url to stylesheet"],"updatePoint":{"line":22,"column":32},"line":22,"code":"  it('can handle same level path', () => {\n    expect(absoluteToStylesheet('url(\"./a.jpg\")', href)).toEqual(\n      `url(\"http://localhost/css/a.jpg\")`,\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle parent level path","suites":["absolute url to stylesheet"],"updatePoint":{"line":28,"column":34},"line":28,"code":"  it('can handle parent level path', () => {\n    expect(absoluteToStylesheet('url(\"../a.jpg\")', href)).toEqual(\n      `url(\"http://localhost/a.jpg\")`,\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle absolute path","suites":["absolute url to stylesheet"],"updatePoint":{"line":34,"column":30},"line":34,"code":"  it('can handle absolute path', () => {\n    expect(absoluteToStylesheet('url(\"/a.jpg\")', href)).toEqual(\n      `url(\"http://localhost/a.jpg\")`,\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle external path","suites":["absolute url to stylesheet"],"updatePoint":{"line":40,"column":30},"line":40,"code":"  it('can handle external path', () => {\n    expect(absoluteToStylesheet('url(\"http://localhost/a.jpg\")', href)).toEqual(\n      `url(\"http://localhost/a.jpg\")`,\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle single quote path","suites":["absolute url to stylesheet"],"updatePoint":{"line":46,"column":34},"line":46,"code":"  it('can handle single quote path', () => {\n    expect(absoluteToStylesheet(`url('./a.jpg')`, href)).toEqual(\n      `url('http://localhost/css/a.jpg')`,\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle no quote path","suites":["absolute url to stylesheet"],"updatePoint":{"line":52,"column":30},"line":52,"code":"  it('can handle no quote path', () => {\n    expect(absoluteToStylesheet('url(./a.jpg)', href)).toEqual(\n      `url(http://localhost/css/a.jpg)`,\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle multiple no quote paths","suites":["absolute url to stylesheet"],"updatePoint":{"line":58,"column":40},"line":58,"code":"  it('can handle multiple no quote paths', () => {\n    expect(\n      absoluteToStylesheet(\n        'background-image: url(images/b.jpg);background: #aabbcc url(images/a.jpg) 50% 50% repeat;',\n        href,\n      ),\n    ).toEqual(\n      `background-image: url(http://localhost/css/images/b.jpg);` +\n        `background: #aabbcc url(http://localhost/css/images/a.jpg) 50% 50% repeat;`,\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle data url image","suites":["absolute url to stylesheet"],"updatePoint":{"line":70,"column":31},"line":70,"code":"  it('can handle data url image', () => {\n    expect(\n      absoluteToStylesheet('url(data:image/gif;base64,ABC)', href),\n    ).toEqual('url(data:image/gif;base64,ABC)');\n    expect(\n      absoluteToStylesheet(\n        'url(data:application/font-woff;base64,d09GMgABAAAAAAm)',\n        href,\n      ),\n    ).toEqual('url(data:application/font-woff;base64,d09GMgABAAAAAAm)');\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"preserves quotes around inline svgs with spaces","suites":["absolute url to stylesheet"],"updatePoint":{"line":82,"column":53},"line":82,"code":"  it('preserves quotes around inline svgs with spaces', () => {\n    expect(\n      absoluteToStylesheet(\n        \"url(\\\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3E%3Cpath fill='%2328a745' d='M3'/%3E%3C/svg%3E\\\")\",\n        href,\n      ),\n    ).toEqual(\n      \"url(\\\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3E%3Cpath fill='%2328a745' d='M3'/%3E%3C/svg%3E\\\")\",\n    );\n    expect(\n      absoluteToStylesheet(\n        'url(\\'data:image/svg+xml;utf8,<svg width=\"28\" height=\"32\" viewBox=\"0 0 28 32\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M27 14C28\" fill=\"white\"/></svg>\\')',\n        href,\n      ),\n    ).toEqual(\n      'url(\\'data:image/svg+xml;utf8,<svg width=\"28\" height=\"32\" viewBox=\"0 0 28 32\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M27 14C28\" fill=\"white\"/></svg>\\')',\n    );\n    expect(\n      absoluteToStylesheet(\n        'url(\"data:image/svg+xml;utf8,<svg width=\"28\" height=\"32\" viewBox=\"0 0 28 32\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M27 14C28\" fill=\"white\"/></svg>\")',\n        href,\n      ),\n    ).toEqual(\n      'url(\"data:image/svg+xml;utf8,<svg width=\"28\" height=\"32\" viewBox=\"0 0 28 32\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M27 14C28\" fill=\"white\"/></svg>\")',\n    );\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle empty path","suites":["absolute url to stylesheet"],"updatePoint":{"line":108,"column":27},"line":108,"code":"  it('can handle empty path', () => {\n    expect(absoluteToStylesheet(`url('')`, href)).toEqual(`url('')`);\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"can handle empty elements","suites":["isBlockedElement()"],"updatePoint":{"line":120,"column":31},"line":120,"code":"  it('can handle empty elements', () => {\n    expect(subject('<div />')).toEqual(false);\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"blocks prohibited className","suites":["isBlockedElement()"],"updatePoint":{"line":124,"column":33},"line":124,"code":"  it('blocks prohibited className', () => {\n    expect(subject('<div class=\"foo rr-block bar\" />')).toEqual(true);\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"does not block random data selector","suites":["isBlockedElement()"],"updatePoint":{"line":128,"column":41},"line":128,"code":"  it('does not block random data selector', () => {\n    expect(subject('<div data-rr-block />')).toEqual(false);\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"blocks blocked selector","suites":["isBlockedElement()"],"updatePoint":{"line":132,"column":29},"line":132,"code":"  it('blocks blocked selector', () => {\n    expect(\n      subject('<div data-rr-block />', { blockSelector: '[data-rr-block]' }),\n    ).toEqual(true);\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should serialize all rules of stylesheet when the sheet has a single child node","suites":["style elements"],"updatePoint":{"line":161,"column":85},"line":161,"code":"  it('should serialize all rules of stylesheet when the sheet has a single child node', () => {\n    const styleEl = render(`<style>body { color: red; }</style>`);\n    styleEl.sheet?.insertRule('section { color: blue; }');\n    expect(serializeNode(styleEl.childNodes[0])).toMatchObject({\n      isStyle: true,\n      rootId: undefined,\n      textContent: 'section {color: blue;}body {color: red;}',\n      type: 3,\n    });\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should serialize individual text nodes on stylesheets with multiple child nodes","suites":["style elements"],"updatePoint":{"line":172,"column":85},"line":172,"code":"  it('should serialize individual text nodes on stylesheets with multiple child nodes', () => {\n    const styleEl = render(`<style>body { color: red; }</style>`);\n    styleEl.append(document.createTextNode('section { color: blue; }'));\n    expect(serializeNode(styleEl.childNodes[1])).toMatchObject({\n      isStyle: true,\n      rootId: undefined,\n      textContent: 'section { color: blue; }',\n      type: 3,\n    });\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should serialize scroll positions","suites":["scrollTop/scrollLeft"],"updatePoint":{"line":207,"column":39},"line":207,"code":"  it('should serialize scroll positions', () => {\n    const el = render(`<div stylel='overflow: auto; width: 1px; height: 1px;'>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n    </div>`);\n    el.scrollTop = 10;\n    el.scrollLeft = 20;\n    expect(serializeNode(el)).toMatchObject({\n      attributes: {\n        rr_scrollTop: 10,\n        rr_scrollLeft: 20,\n      },\n    });\n  });","file":"snapshot.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should return false if two nodes have different node types","suites":["utils","isNodeMetaEqual()"],"updatePoint":{"line":71,"column":66},"line":71,"code":"    it('should return false if two nodes have different node types', () => {\n      expect(\n        isNodeMetaEqual(\n          undefined as unknown as serializedNode,\n          null as unknown as serializedNode,\n        ),\n      ).toBeFalsy();\n      expect(isNodeMetaEqual(document1, element1)).toBeFalsy();\n      expect(isNodeMetaEqual(document1, documentType1)).toBeFalsy();\n      expect(isNodeMetaEqual(documentType1, element1)).toBeFalsy();\n      expect(isNodeMetaEqual(text1, comment1)).toBeFalsy();\n      expect(isNodeMetaEqual(text1, element1)).toBeFalsy();\n      expect(isNodeMetaEqual(comment1, element1)).toBeFalsy();\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should compare meta data of two document nodes","suites":["utils","isNodeMetaEqual()"],"updatePoint":{"line":86,"column":54},"line":86,"code":"    it('should compare meta data of two document nodes', () => {\n      expect(\n        isNodeMetaEqual(document1, JSON.parse(JSON.stringify(document1))),\n      ).toBeTruthy();\n      expect(\n        isNodeMetaEqual(JSON.parse(JSON.stringify(document2)), document2),\n      ).toBeTruthy();\n      expect(isNodeMetaEqual(document1, document2)).toBeFalsy();\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should compare meta data of two documentType nodes","suites":["utils","isNodeMetaEqual()"],"updatePoint":{"line":96,"column":58},"line":96,"code":"    it('should compare meta data of two documentType nodes', () => {\n      expect(\n        isNodeMetaEqual(\n          documentType1,\n          JSON.parse(JSON.stringify(documentType1)),\n        ),\n      ).toBeTruthy();\n      expect(\n        isNodeMetaEqual(\n          JSON.parse(JSON.stringify(documentType2)),\n          documentType2,\n        ),\n      ).toBeTruthy();\n      expect(isNodeMetaEqual(documentType1, documentType2)).toBeFalsy();\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should compare meta data of two text nodes","suites":["utils","isNodeMetaEqual()"],"updatePoint":{"line":112,"column":50},"line":112,"code":"    it('should compare meta data of two text nodes', () => {\n      expect(\n        isNodeMetaEqual(text1, JSON.parse(JSON.stringify(text1))),\n      ).toBeTruthy();\n      expect(\n        isNodeMetaEqual(JSON.parse(JSON.stringify(text2)), text2),\n      ).toBeTruthy();\n      expect(isNodeMetaEqual(text1, text2)).toBeFalsy();\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should compare meta data of two comment nodes","suites":["utils","isNodeMetaEqual()"],"updatePoint":{"line":122,"column":53},"line":122,"code":"    it('should compare meta data of two comment nodes', () => {\n      expect(\n        isNodeMetaEqual(comment1, JSON.parse(JSON.stringify(comment1))),\n      ).toBeTruthy();\n      expect(\n        isNodeMetaEqual(JSON.parse(JSON.stringify(comment2)), comment2),\n      ).toBeTruthy();\n      expect(isNodeMetaEqual(comment1, comment2)).toBeFalsy();\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"should compare meta data of two HTML elements","suites":["utils","isNodeMetaEqual()"],"updatePoint":{"line":132,"column":53},"line":132,"code":"    it('should compare meta data of two HTML elements', () => {\n      expect(\n        isNodeMetaEqual(element1, JSON.parse(JSON.stringify(element1))),\n      ).toBeTruthy();\n      expect(\n        isNodeMetaEqual(JSON.parse(JSON.stringify(element2)), element2),\n      ).toBeTruthy();\n      expect(\n        isNodeMetaEqual(element1, {\n          ...element1,\n          childNodes: [comment2 as serializedNodeWithId],\n        }),\n      ).toBeTruthy();\n      expect(isNodeMetaEqual(element1, element2)).toBeFalsy();\n      expect(isNodeMetaEqual(element1, element3)).toBeFalsy();\n      expect(isNodeMetaEqual(element2, element3)).toBeFalsy();\n    });","file":"utils.test.ts","skipped":false,"dir":"packages/rrweb-snapshot/test"},{"name":"will record and replay a webgl square","suites":["e2e webgl"],"updatePoint":{"line":85,"column":43},"line":85,"code":"  it('will record and replay a webgl square', async () => {\n    page = await browser.newPage();\n    await fakeGoto(page, `${serverURL}/html/canvas-webgl-square.html`);\n\n    await page.setContent(\n      getHtml.call(this, 'canvas-webgl-square.html', { recordCanvas: true }),\n    );\n\n    await waitForRAF(page);\n\n    const snapshots: eventWithTime[] = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n\n    page = await browser.newPage();\n\n    await page.goto('about:blank');\n    await page.evaluate(code);\n\n    await hideMouseAnimation(page);\n    await page.evaluate(`let events = ${JSON.stringify(snapshots)}`);\n    await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events, {\n        UNSAFE_replayCanvas: true,\n      });\n      replayer.play(500);\n    `);\n    await waitForRAF(page);\n\n    const frameImage = await page!.screenshot();\n    await waitForRAF(page);\n    expect(frameImage).toMatchImageSnapshot();\n  });","file":"e2e/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will record and replay a webgl image","suites":["e2e webgl"],"updatePoint":{"line":120,"column":42},"line":120,"code":"  it('will record and replay a webgl image', async () => {\n    page = await browser.newPage();\n    await fakeGoto(page, `${serverURL}/html/canvas-webgl-image.html`);\n\n    await page.setContent(\n      getHtml.call(this, 'canvas-webgl-image.html', { recordCanvas: true }),\n    );\n\n    await waitForRAF(page);\n    await page.waitForTimeout(100);\n    const snapshots: eventWithTime[] = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n\n    page = await browser.newPage();\n\n    await page.goto('about:blank');\n    await page.evaluate(code);\n\n    await hideMouseAnimation(page);\n    await page.evaluate(`let events = ${JSON.stringify(snapshots)}`);\n    await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events, {\n        UNSAFE_replayCanvas: true,\n      });\n    `);\n    // wait for iframe to get added and `preloadAllImages` to ge called\n    await page.waitForSelector('iframe');\n    await page.evaluate(`replayer.play(500);`);\n    await waitForRAF(page);\n\n    const frameImage = await page!.screenshot();\n    expect(frameImage).toMatchImageSnapshot();\n  });","file":"e2e/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can record clicks","suites":["record integration tests"],"updatePoint":{"line":66,"column":23},"line":66,"code":"  it('can record clicks', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'link.html'));\n    await page.click('span');\n\n    // also tap on the span\n    const span = await page.waitForSelector('span');\n    const center = await page.evaluate((el) => {\n      const { x, y, width, height } = el!.getBoundingClientRect();\n      return {\n        x: Math.round(x + width / 2),\n        y: Math.round(y + height / 2),\n      };\n    }, span);\n    await page.touchscreen.tap(center.x, center.y);\n\n    await page.click('a');\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can record form interactions","suites":["record integration tests"],"updatePoint":{"line":91,"column":34},"line":91,"code":"  it('can record form interactions', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'form.html'));\n\n    await page.type('input[type=\"text\"]', 'test');\n    await page.click('input[type=\"radio\"]');\n    await page.click('input[type=\"checkbox\"]');\n    await page.type('textarea', 'textarea test');\n    await page.select('select', '1');\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can record childList mutations","suites":["record integration tests"],"updatePoint":{"line":108,"column":36},"line":108,"code":"  it('can record childList mutations', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'mutation-observer.html'));\n\n    await page.evaluate(() => {\n      const li = document.createElement('li');\n      const ul = document.querySelector('ul') as HTMLUListElement;\n      ul.appendChild(li);\n      document.body.removeChild(ul);\n      const p = document.querySelector('p') as HTMLParagraphElement;\n      p.appendChild(document.createElement('span'));\n    });\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can record character data muatations","suites":["record integration tests"],"updatePoint":{"line":128,"column":42},"line":128,"code":"  it('can record character data muatations', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'mutation-observer.html'));\n\n    await page.evaluate(() => {\n      const li = document.createElement('li');\n      const ul = document.querySelector('ul') as HTMLUListElement;\n      ul.appendChild(li);\n      li.innerText = 'new list item';\n      li.innerText = 'new list item edit';\n      document.body.removeChild(ul);\n      const p = document.querySelector('p') as HTMLParagraphElement;\n      p.innerText = 'mutated';\n    });\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can record attribute mutation","suites":["record integration tests"],"updatePoint":{"line":150,"column":35},"line":150,"code":"  it('can record attribute mutation', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'mutation-observer.html'));\n\n    await page.evaluate(() => {\n      const li = document.createElement('li');\n      const ul = document.querySelector('ul') as HTMLUListElement;\n      ul.appendChild(li);\n      li.setAttribute('foo', 'bar');\n      document.body.removeChild(ul);\n      document.body.setAttribute('test', 'true');\n    });\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"handles null attribute values","suites":["record integration tests"],"updatePoint":{"line":170,"column":35},"line":170,"code":"  it('handles null attribute values', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'mutation-observer.html', {}));\n\n    await page.evaluate(() => {\n      const li = document.createElement('li');\n      const ul = document.querySelector('ul') as HTMLUListElement;\n      ul.appendChild(li);\n\n      li.setAttribute('aria-label', 'label');\n      li.setAttribute('id', 'test-li');\n    });\n\n    await new Promise((resolve) => setTimeout(resolve, 100));\n\n    await page.evaluate(() => {\n      const li = document.querySelector('#test-li') as HTMLLIElement;\n      // This triggers the mutation observer with a `null` attribute value\n      li.removeAttribute('aria-label');\n    });\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can record node mutations","suites":["record integration tests"],"updatePoint":{"line":198,"column":31},"line":198,"code":"  it('can record node mutations', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'select2.html'), {\n      waitUntil: 'networkidle0',\n    });\n\n    // toggle the select box\n    await page.click('.select2-container', { clickCount: 2, delay: 100 });\n    // test storage of !important style\n    await page.evaluate(\n      'document.getElementById(\"select2-drop\").setAttribute(\"style\", document.getElementById(\"select2-drop\").style.cssText + \"color:black !important\")',\n    );\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can record style changes compactly and preserve css var() functions","suites":["record integration tests"],"updatePoint":{"line":217,"column":73},"line":217,"code":"  it('can record style changes compactly and preserve css var() functions', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'blank.html'), {\n      waitUntil: 'networkidle0',\n    });\n\n    // goal here is to ensure var(--mystery) ends up in the mutations (CSSOM fails in this case)\n    await page.evaluate(\n      'document.body.setAttribute(\"style\", \"background: var(--mystery)\")',\n    );\n    await waitForRAF(page);\n    // and in this change we can't use the shorter styleObj format either\n    await page.evaluate(\n      'document.body.setAttribute(\"style\", \"background: var(--mystery); background-color: black\")',\n    );\n\n    // reset is always shorter to be recorded as a sting rather than a styleObj\n    await page.evaluate('document.body.setAttribute(\"style\", \"\")');\n    await waitForRAF(page);\n\n    await page.evaluate('document.body.setAttribute(\"style\", \"display:block\")');\n    await waitForRAF(page);\n    // following should be recorded as an update of `{ color: 'var(--mystery-color)' }` without needing to include the display\n    await page.evaluate(\n      'document.body.setAttribute(\"style\", \"color:var(--mystery-color);display:block\")',\n    );\n    await waitForRAF(page);\n    // whereas this case, it's shorter to record the entire string than the longhands for margin\n    await page.evaluate(\n      'document.body.setAttribute(\"style\", \"color:var(--mystery-color);display:block;margin:10px\")',\n    );\n    await waitForRAF(page);\n    // and in this case, it's shorter to record just the change to the longhand margin-left;\n    await page.evaluate(\n      'document.body.setAttribute(\"style\", \"color:var(--mystery-color);display:block;margin:10px 10px 10px 0px;\")',\n    );\n    await waitForRAF(page);\n    // see what happens when we manipulate the style object directly (expecting a compact mutation with just these two changes)\n    await page.evaluate(\n      'document.body.style.marginTop = 0; document.body.style.color = null',\n    );\n    await waitForRAF(page);\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can freeze mutations","suites":["record integration tests"],"updatePoint":{"line":267,"column":26},"line":267,"code":"  it('can freeze mutations', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'mutation-observer.html', { recordCanvas: true }),\n    );\n\n    await page.evaluate(() => {\n      const li = document.createElement('li');\n      const ul = document.querySelector('ul') as HTMLUListElement;\n      ul.appendChild(li);\n      li.setAttribute('foo', 'bar');\n      document.body.setAttribute('test', 'true');\n    });\n    await page.evaluate('rrweb.freezePage()');\n    await page.evaluate(() => {\n      document.body.setAttribute('test', 'bad');\n      const canvas = document.querySelector('canvas') as HTMLCanvasElement;\n      const gl = canvas.getContext('webgl') as WebGLRenderingContext;\n      gl.getExtension('bad');\n      const ul = document.querySelector('ul') as HTMLUListElement;\n      const li = document.createElement('li');\n      li.setAttribute('bad-attr', 'bad');\n      li.innerText = 'bad text';\n      ul.appendChild(li);\n      document.body.removeChild(ul);\n    });\n\n    await waitForRAF(page);\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should not record input events on ignored elements","suites":["record integration tests"],"updatePoint":{"line":303,"column":56},"line":303,"code":"  it('should not record input events on ignored elements', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'ignore.html', {\n        ignoreSelector: '[data-rr-ignore]',\n      }),\n    );\n\n    await page.type('.rr-ignore', 'secret');\n    await page.type('[data-rr-ignore]', 'secret');\n    await page.type('.dont-ignore', 'not secret');\n\n    await assertSnapshot(page);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should not record input values if maskAllInputs is enabled","suites":["record integration tests"],"updatePoint":{"line":319,"column":64},"line":319,"code":"  it('should not record input values if maskAllInputs is enabled', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'form.html', { maskAllInputs: true }),\n    );\n\n    await page.type('input[type=\"text\"]', 'test');\n    await page.click('input[type=\"radio\"]');\n    await page.click('input[type=\"checkbox\"]');\n    await page.type('input[type=\"password\"]', 'password');\n    await page.type('textarea', 'textarea test');\n    await page.select('select', '1');\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can use maskInputOptions to configure which type of inputs should be masked","suites":["record integration tests"],"updatePoint":{"line":339,"column":81},"line":339,"code":"  it('can use maskInputOptions to configure which type of inputs should be masked', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'form.html', {\n        maskInputOptions: {\n          text: false,\n          textarea: false,\n          password: true,\n        },\n      }),\n    );\n\n    await page.type('input[type=\"text\"]', 'test');\n    await page.click('input[type=\"radio\"]');\n    await page.click('input[type=\"checkbox\"]');\n    await page.type('textarea', 'textarea test');\n    await page.type('input[type=\"password\"]', 'password');\n    await page.select('select', '1');\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should mask password value attribute with maskInputOptions","suites":["record integration tests"],"updatePoint":{"line":365,"column":64},"line":365,"code":"  it('should mask password value attribute with maskInputOptions', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'password.html', {\n        maskInputOptions: {\n          password: true,\n        },\n      }),\n    );\n\n    await page.type('#password', 'secr3t');\n\n    // Change type to text (simulate \"show password\")\n    await page.click('#show-password');\n    await page.type('#password', 'XY');\n    await page.click('#show-password');\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should mask inputs via function call","suites":["record integration tests"],"updatePoint":{"line":389,"column":42},"line":389,"code":"  it('should mask inputs via function call', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'form.html', {\n        maskAllInputs: true,\n        maskInputFn: (text: string, element: HTMLElement) => {\n          // If the element has the attribute \"data-unmask-example\", we don't mask it\n          if (element.hasAttribute('data-unmask-example')) {\n            return text;\n          }\n\n          return '*'.repeat(text.length);\n        },\n      }),\n    );\n\n    await page.type('input[type=\"text\"]', 'test');\n    await page.click('input[type=\"radio\"]');\n    await page.click('input[type=\"checkbox\"]');\n    await page.type('input[type=\"password\"]', 'password');\n    await page.type('textarea', 'textarea test');\n    await page.select('select', '1');\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record input userTriggered values if userTriggeredOnInput is enabled","suites":["record integration tests"],"updatePoint":{"line":419,"column":81},"line":419,"code":"  it('should record input userTriggered values if userTriggeredOnInput is enabled', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'form.html', { userTriggeredOnInput: true }),\n    );\n\n    await page.type('input[type=\"text\"]', 'test');\n    await page.click('input[type=\"radio\"]');\n    await page.click('input[type=\"checkbox\"]');\n    await page.type('input[type=\"password\"]', 'password');\n    await page.type('textarea', 'textarea test');\n    await page.select('select', '1');\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should not record blocked elements and its child nodes","suites":["record integration tests"],"updatePoint":{"line":439,"column":60},"line":439,"code":"  it('should not record blocked elements and its child nodes', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'block.html'));\n\n    await page.type('input', 'should not be record');\n    await page.evaluate(`document.getElementById('text').innerText = '1'`);\n    await page.click('#text');\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should not record blocked elements dynamically added","suites":["record integration tests"],"updatePoint":{"line":454,"column":58},"line":454,"code":"  it('should not record blocked elements dynamically added', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'block.html'));\n\n    await page.evaluate(() => {\n      const el = document.createElement('button');\n      el.className = 'rr-block';\n      el.style.width = '100px';\n      el.style.height = '100px';\n      el.innerText = 'Should not be recorded';\n\n      const nextElement = document.querySelector('.rr-block')!;\n      nextElement.parentNode!.insertBefore(el, nextElement);\n    });\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"mutations should work when blocked class is unblocked","suites":["record integration tests"],"updatePoint":{"line":476,"column":59},"line":476,"code":"  it('mutations should work when blocked class is unblocked', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about: blank');\n    await page.setContent(getHtml.call(this, 'blocked-unblocked.html'));\n\n    const elements1 = (await page.$x(\n      '/html/body/div[1]/button',\n    )) as puppeteer.ElementHandle<HTMLButtonElement>[];\n    await elements1[0].click();\n\n    const elements2 = (await page.$x(\n      '/html/body/div[2]/button',\n    )) as puppeteer.ElementHandle<HTMLButtonElement>[];\n    await elements2[0].click();\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record DOM node movement 1","suites":["record integration tests"],"updatePoint":{"line":497,"column":39},"line":497,"code":"  it('should record DOM node movement 1', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'move-node.html'));\n\n    await page.evaluate(() => {\n      const div = document.querySelector('div')!;\n      const p = document.querySelector('p')!;\n      const span = document.querySelector('span')!;\n      document.body.removeChild(span);\n      p.appendChild(span);\n      p.removeChild(span);\n      div.appendChild(span);\n    });\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record DOM node movement 2","suites":["record integration tests"],"updatePoint":{"line":517,"column":39},"line":517,"code":"  it('should record DOM node movement 2', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'move-node.html'));\n\n    await page.evaluate(() => {\n      const div = document.createElement('div');\n      const span = document.querySelector('span')!;\n      document.body.appendChild(div);\n      div.appendChild(span);\n    });\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record dynamic CSS changes","suites":["record integration tests"],"updatePoint":{"line":534,"column":39},"line":534,"code":"  it('should record dynamic CSS changes', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'react-styled-components.html'));\n    await page.click('.toggle');\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record canvas mutations","suites":["record integration tests"],"updatePoint":{"line":545,"column":36},"line":545,"code":"  it('should record canvas mutations', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'canvas.html', {\n        recordCanvas: true,\n      }),\n    );\n    await page.waitForFunction('window.canvasMutationApplied');\n    await waitForRAF(page);\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    for (const event of snapshots) {\n      if (event.type === EventType.FullSnapshot) {\n        visitSnapshot(event.data.node, (n) => {\n          if (n.type === NodeType.Element && n.attributes.rr_dataURL) {\n            n.attributes.rr_dataURL = `LOOKS LIKE WE COULD NOT GET STABLE BASE64 FROM SAME IMAGE.`;\n          }\n        });\n      }\n    }\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should not record input values if dynamically added and maskAllInputs is true","suites":["record integration tests"],"updatePoint":{"line":570,"column":83},"line":570,"code":"  it('should not record input values if dynamically added and maskAllInputs is true', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'empty.html', { maskAllInputs: true }),\n    );\n\n    await page.evaluate(() => {\n      const el = document.createElement('input');\n      el.id = 'input';\n      el.value = 'input should be masked';\n\n      const nextElement = document.querySelector('#one')!;\n      nextElement.parentNode!.insertBefore(el, nextElement);\n    });\n\n    await page.type('#input', 'moo');\n\n    await assertSnapshot(page);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record webgl canvas mutations","suites":["record integration tests"],"updatePoint":{"line":591,"column":42},"line":591,"code":"  it('should record webgl canvas mutations', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'canvas-webgl.html', {\n        recordCanvas: true,\n      }),\n    );\n    await page.waitForTimeout(50);\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can correctly serialize a shader and multiple webgl contexts","suites":["record integration tests"],"updatePoint":{"line":606,"column":66},"line":606,"code":"  it('can correctly serialize a shader and multiple webgl contexts', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'canvas-webgl-shader.html', {\n        recordCanvas: true,\n      }),\n    );\n    await waitForRAF(page);\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will serialize node before record","suites":["record integration tests"],"updatePoint":{"line":621,"column":39},"line":621,"code":"  it('will serialize node before record', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'mutation-observer.html'));\n\n    await page.evaluate(() => {\n      const ul = document.querySelector('ul') as HTMLUListElement;\n      let count = 3;\n      while (count > 0) {\n        count--;\n        const li = document.createElement('li');\n        ul.appendChild(li);\n      }\n    });\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will defer missing next node mutation","suites":["record integration tests"],"updatePoint":{"line":642,"column":43},"line":642,"code":"  it('will defer missing next node mutation', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'shuffle.html'));\n\n    const text = await page.evaluate(() => {\n      const els = Array.prototype.slice.call(document.querySelectorAll('li'));\n      const parent = document.querySelector('ul')!;\n      parent.removeChild(els[3]);\n      parent.removeChild(els[2]);\n      parent.removeChild(els[1]);\n      parent.removeChild(els[0]);\n      parent.insertBefore(els[3], els[4]);\n      parent.insertBefore(els[2], els[4]);\n      parent.insertBefore(els[1], els[4]);\n      parent.insertBefore(els[0], els[4]);\n      return parent.innerText;\n    });\n\n    expect(text).toEqual('4\\n3\\n2\\n1\\n5');\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record console messages","suites":["record integration tests"],"updatePoint":{"line":664,"column":36},"line":664,"code":"  it('should record console messages', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml('log.html', {\n        plugins:\n          '[rrwebConsoleRecord.getRecordConsolePlugin()]' as unknown as RecordPlugin<unknown>[],\n      }),\n    );\n\n    await page.evaluate(() => {\n      console.assert(0 === 0, 'assert');\n      console.count('count');\n      console.countReset('count');\n      console.debug('debug');\n      console.dir('dir');\n      console.dirxml('dirxml');\n      console.group();\n      console.groupCollapsed();\n      console.info('info');\n      console.log('log');\n      console.table('table');\n      console.time();\n      console.timeEnd();\n      console.timeLog();\n      console.trace('trace');\n      console.warn('warn');\n      console.clear();\n      console.log(new TypeError('a message'));\n      const iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n    });\n\n    await waitForRAF(page);\n    await page.frames()[1].evaluate(() => {\n      console.log('from iframe');\n    });\n    await waitForRAF(page);\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should handle recursive console messages","suites":["record integration tests"],"updatePoint":{"line":709,"column":46},"line":709,"code":"  it('should handle recursive console messages', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml('log.html', {\n        plugins:\n          '[rrwebConsoleRecord.getRecordConsolePlugin()]' as unknown as RecordPlugin<unknown>[],\n      }),\n    );\n\n    await page.evaluate(() => {\n      // Some frameworks like Vue.js use proxies to implement reactivity.\n      // This can cause infinite loops when logging objects.\n      let recursiveTarget = { foo: 'bar', proxied: 'i-am', proxy: null };\n      let count = 0;\n\n      const handler = {\n        get(target: any, prop: any, ...args: any[]) {\n          if (prop === 'proxied') {\n            if (count > 9) {\n              return;\n            }\n            count++; // We don't want out test to get into an infinite loop...\n            console.warn(\n              'proxied was accessed so triggering a console.warn',\n              target,\n            );\n          }\n          return Reflect.get(target, prop, ...args);\n        },\n      };\n\n      const proxy = new Proxy(recursiveTarget, handler);\n      recursiveTarget.proxy = proxy;\n\n      console.log('Proxied object:', proxy);\n    });\n\n    await waitForRAF(page);\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    // The snapshots should containe 1 console log, not multiple.\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should nest record iframe","suites":["record integration tests"],"updatePoint":{"line":756,"column":31},"line":756,"code":"  it('should nest record iframe', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto(`${serverURL}/html`);\n    await page.setContent(getHtml.call(this, 'main.html'));\n\n    const frameIdTwo = await waitForIFrameLoad(page, '#two');\n    const frameIdFour = await waitForIFrameLoad(frameIdTwo, '#four');\n    await waitForIFrameLoad(frameIdFour, '#five');\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record images with blob url","suites":["record integration tests"],"updatePoint":{"line":771,"column":40},"line":771,"code":"  it('should record images with blob url', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    page.on('console', (msg) => console.log(msg.text()));\n    await page.goto(`${serverURL}/html`);\n    page.setContent(\n      getHtml.call(this, 'image-blob-url.html', { inlineImages: true }),\n    );\n    await page.waitForResponse(`${serverURL}/html/assets/robot.png`);\n    await page.waitForSelector('img'); // wait for image to get added\n    await waitForRAF(page); // wait for image to be captured\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record images inside iframe with blob url","suites":["record integration tests"],"updatePoint":{"line":788,"column":54},"line":788,"code":"  it('should record images inside iframe with blob url', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    page.on('console', (msg) => console.log(msg.text()));\n    await page.goto(`${serverURL}/html`);\n    await page.setContent(\n      getHtml.call(this, 'frame-image-blob-url.html', { inlineImages: true }),\n    );\n    await page.waitForResponse(`${serverURL}/html/assets/robot.png`);\n    await page.waitForTimeout(50); // wait for image to get added\n    await waitForRAF(page); // wait for image to be captured\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record images inside iframe with blob url after iframe was reloaded","suites":["record integration tests"],"updatePoint":{"line":805,"column":80},"line":805,"code":"  it('should record images inside iframe with blob url after iframe was reloaded', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    page.on('console', (msg) => console.log(msg.text()));\n    await page.goto(`${serverURL}/html`);\n    await page.setContent(\n      getHtml.call(this, 'frame2.html', { inlineImages: true }),\n    );\n    await page.waitForSelector('iframe'); // wait for iframe to get added\n    await waitForRAF(page); // wait for iframe to load\n    page.evaluate(() => {\n      const iframe = document.querySelector('iframe')!;\n      iframe.setAttribute('src', '/html/image-blob-url.html');\n    });\n    await page.waitForResponse(`${serverURL}/html/assets/robot.png`); // wait for image to get loaded\n    await page.waitForTimeout(50); // wait for image to get added\n    await waitForRAF(page); // wait for image to be captured\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record shadow DOM","suites":["record integration tests"],"updatePoint":{"line":828,"column":30},"line":828,"code":"  it('should record shadow DOM', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'shadow-dom.html'));\n\n    await page.evaluate(() => {\n      const sleep = (ms: number) =>\n        new Promise((resolve) => setTimeout(resolve, ms));\n\n      const el = document.querySelector('.my-element') as HTMLDivElement;\n      const shadowRoot = el.shadowRoot as ShadowRoot;\n      shadowRoot.appendChild(document.createElement('span'));\n      shadowRoot.appendChild(document.createElement('p'));\n      sleep(1)\n        .then(() => {\n          shadowRoot.lastChild!.appendChild(document.createElement('p'));\n          return sleep(1);\n        })\n        .then(() => {\n          const firstP = shadowRoot.querySelector('p') as HTMLParagraphElement;\n          shadowRoot.removeChild(firstP);\n          return sleep(1);\n        })\n        .then(() => {\n          (shadowRoot.lastChild!.childNodes[0] as HTMLElement).innerText = 'hi';\n          return sleep(1);\n        })\n        .then(() => {\n          (shadowRoot.lastChild!.childNodes[0] as HTMLElement).innerText =\n            '123';\n          const nestedShadowElement = shadowRoot.lastChild!\n            .childNodes[0] as HTMLElement;\n          nestedShadowElement.attachShadow({\n            mode: 'open',\n          });\n          nestedShadowElement.shadowRoot!.appendChild(\n            document.createElement('span'),\n          );\n          (nestedShadowElement.shadowRoot!.lastChild as HTMLElement).innerText =\n            'nested shadow dom';\n        });\n    });\n    await page.waitForTimeout(50);\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record shadow DOM 2","suites":["record integration tests"],"updatePoint":{"line":878,"column":32},"line":878,"code":"  it('should record shadow DOM 2', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'blank.html'));\n    await page.evaluate(() => {\n      return new Promise((resolve) => {\n        const el = document.createElement('div') as HTMLDivElement;\n        el.attachShadow({ mode: 'open' });\n        (el.shadowRoot as ShadowRoot).appendChild(\n          document.createElement('input'),\n        );\n        setTimeout(() => {\n          document.body.append(el);\n          resolve(null);\n        }, 10);\n      });\n    });\n    await waitForRAF(page);\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record shadow DOM 3","suites":["record integration tests"],"updatePoint":{"line":903,"column":32},"line":903,"code":"  it('should record shadow DOM 3', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'blank.html'));\n\n    await page.evaluate(() => {\n      const el = document.createElement('div') as HTMLDivElement;\n      el.attachShadow({ mode: 'open' });\n      (el.shadowRoot as ShadowRoot).appendChild(\n        document.createElement('input'),\n      );\n      document.body.append(el);\n    });\n    await waitForRAF(page);\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record moved shadow DOM","suites":["record integration tests"],"updatePoint":{"line":924,"column":36},"line":924,"code":"  it('should record moved shadow DOM', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'blank.html'));\n\n    await page.evaluate(() => {\n      return new Promise((resolve) => {\n        const el = document.createElement('div') as HTMLDivElement;\n        el.attachShadow({ mode: 'open' });\n        (el.shadowRoot as ShadowRoot).appendChild(\n          document.createElement('input'),\n        );\n        document.body.append(el);\n        setTimeout(() => {\n          const newEl = document.createElement('div') as HTMLDivElement;\n          document.body.append(newEl);\n          newEl.append(el);\n          resolve(null);\n        }, 50);\n      });\n    });\n    await waitForRAF(page);\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record moved shadow DOM 2","suites":["record integration tests"],"updatePoint":{"line":953,"column":38},"line":953,"code":"  it('should record moved shadow DOM 2', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'blank.html'));\n\n    await page.evaluate(() => {\n      const el = document.createElement('div') as HTMLDivElement;\n      el.id = 'el';\n      el.attachShadow({ mode: 'open' });\n      (el.shadowRoot as ShadowRoot).appendChild(\n        document.createElement('input'),\n      );\n      document.body.append(el);\n      (el.shadowRoot as ShadowRoot).appendChild(document.createElement('span'));\n      (el.shadowRoot as ShadowRoot).appendChild(document.createElement('p'));\n      const newEl = document.createElement('div') as HTMLDivElement;\n      newEl.id = 'newEl';\n      document.body.append(newEl);\n      newEl.append(el);\n      const input = el.shadowRoot?.children[0] as HTMLInputElement;\n      const span = el.shadowRoot?.children[1] as HTMLSpanElement;\n      const p = el.shadowRoot?.children[2] as HTMLParagraphElement;\n      input.remove();\n      span.append(input);\n      p.append(input);\n      span.append(input);\n      setTimeout(() => {\n        p.append(input);\n      }, 0);\n    });\n    await waitForRAF(page);\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record nested iframes and shadow doms","suites":["record integration tests"],"updatePoint":{"line":991,"column":50},"line":991,"code":"  it('should record nested iframes and shadow doms', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'frame2.html'));\n\n    await page.waitForSelector('iframe'); // wait for iframe to get added\n    await waitForRAF(page); // wait till browser loaded contents of frame\n\n    await page.evaluate(() => {\n      // get contentDocument of iframe five\n      const contentDocument1 =\n        document.querySelector('iframe')!.contentDocument!;\n      // create shadow dom #1\n      contentDocument1.body.attachShadow({ mode: 'open' });\n      contentDocument1.body.shadowRoot!.appendChild(\n        document.createElement('div'),\n      );\n      const div = contentDocument1.body.shadowRoot!.childNodes[0];\n      const iframe = contentDocument1.createElement('iframe');\n      // append an iframe to shadow dom #1\n      div.appendChild(iframe);\n    });\n\n    await waitForRAF(page); // wait till browser loaded contents of frame\n\n    page.evaluate(() => {\n      const iframe: HTMLIFrameElement = document\n        .querySelector('iframe')!\n        .contentDocument!.body.shadowRoot!.querySelector('iframe')!;\n\n      const contentDocument2 = iframe.contentDocument!;\n      // create shadow dom #2 in the iframe\n      contentDocument2.body.attachShadow({ mode: 'open' });\n      contentDocument2.body.shadowRoot!.appendChild(\n        document.createElement('span'),\n      );\n    });\n    await waitForRAF(page); // wait till browser sent snapshots\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record mutations in iframes accross pages","suites":["record integration tests"],"updatePoint":{"line":1036,"column":54},"line":1036,"code":"  it('should record mutations in iframes accross pages', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto(`${serverURL}/html`);\n    page.on('console', (msg) => console.log(msg.text()));\n    await page.setContent(getHtml.call(this, 'frame2.html'));\n\n    await page.waitForSelector('iframe'); // wait for iframe to get added\n    await waitForRAF(page); // wait for iframe to load\n\n    page.evaluate((serverURL) => {\n      const iframe = document.querySelector('iframe')!;\n      iframe.setAttribute('src', `${serverURL}/html`); // load new page\n    }, serverURL);\n\n    await page.waitForResponse(`${serverURL}/html`); // wait for iframe to load pt1\n    await waitForRAF(page); // wait for iframe to load pt2\n\n    await page.evaluate(() => {\n      const iframeDocument = document.querySelector('iframe')!.contentDocument!;\n      const div = iframeDocument.createElement('div');\n      iframeDocument.body.appendChild(div);\n    });\n\n    await waitForRAF(page); // wait for snapshot to be updated\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record shadow doms polyfilled by shadydom","suites":["record integration tests"],"updatePoint":{"line":1067,"column":54},"line":1067,"code":"  it('should record shadow doms polyfilled by shadydom', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      // insert shadydom script\n      replaceLast(\n        getHtml.call(this, 'polyfilled-shadowdom-mutation.html'),\n        '<head>',\n        `\n        <head>\n        <script>\n          // To force ShadyDOM to be used even when native ShadowDOM is available, set the ShadyDOM = {force: true} in a script prior to loading the polyfill.\n          window.ShadyDOM = { force: true };\n        </script>\n        <script src=\"https://cdn.jsdelivr.net/npm/@webcomponents/shadydom@1.9.0/shadydom.min.js\"></script>\n    `,\n      ),\n    );\n    await page.evaluate(() => {\n      const target3 = document.querySelector('#target3');\n      target3?.attachShadow({\n        mode: 'open',\n      });\n      target3?.shadowRoot?.appendChild(document.createElement('span'));\n    });\n    await waitForRAF(page); // wait till browser sent snapshots\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record shadow doms polyfilled by synthetic-shadow","suites":["record integration tests"],"updatePoint":{"line":1101,"column":62},"line":1101,"code":"  it('should record shadow doms polyfilled by synthetic-shadow', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      // insert lwc's synthetic-shadow script\n      replaceLast(\n        getHtml.call(this, 'polyfilled-shadowdom-mutation.html'),\n        '<head>',\n        `\n        <head>\n        <script>var process = {env: {NODE_ENV: \"production\"}};</script>\n        <script src=\"https://cdn.jsdelivr.net/npm/@lwc/synthetic-shadow@2.20.3/dist/synthetic-shadow.js\"></script>\n      `,\n      ),\n    );\n    await page.evaluate(() => {\n      const target3 = document.querySelector('#target3');\n      // create a shadow dom with synthetic shadow\n      // https://github.com/salesforce/lwc/blob/v2.20.3/packages/@lwc/synthetic-shadow/src/faux-shadow/element.ts#L81-L87\n      target3?.attachShadow({\n        mode: 'open',\n        '$$lwc-synthetic-mode': true,\n      } as ShadowRootInit);\n      target3?.shadowRoot?.appendChild(document.createElement('span'));\n      const target4 = document.createElement('div');\n      target4.id = 'target4';\n      // create a native shadow dom\n      document.body.appendChild(target4);\n      target4.attachShadow({\n        mode: 'open',\n      });\n      target4.shadowRoot?.appendChild(document.createElement('ul'));\n    });\n    await waitForRAF(page); // wait till browser sent snapshots\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should mask texts","suites":["record integration tests"],"updatePoint":{"line":1142,"column":23},"line":1142,"code":"  it('should mask texts', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'mask-text.html', {\n        maskTextSelector: '[data-masking=\"true\"]',\n      }),\n    );\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should mask texts using maskTextFn","suites":["record integration tests"],"updatePoint":{"line":1157,"column":40},"line":1157,"code":"  it('should mask texts using maskTextFn', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'mask-text.html', {\n        maskTextSelector: '[data-masking=\"true\"]',\n        maskTextFn: (t: string) => t.replace(/[a-z]/g, '*'),\n      }),\n    );\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can mask character data mutations","suites":["record integration tests"],"updatePoint":{"line":1173,"column":39},"line":1173,"code":"  it('can mask character data mutations', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(getHtml.call(this, 'mutation-observer.html'));\n\n    await page.evaluate(() => {\n      const li = document.createElement('li');\n      const ul = document.querySelector('ul') as HTMLUListElement;\n      const p = document.querySelector('p') as HTMLParagraphElement;\n      [li, p].forEach((element) => {\n        element.className = 'rr-mask';\n      });\n      ul.appendChild(li);\n      li.innerText = 'new list item';\n      p.innerText = 'mutated';\n    });\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record after DOMContentLoaded event","suites":["record integration tests"],"updatePoint":{"line":1196,"column":48},"line":1196,"code":"  it('should record after DOMContentLoaded event', async () => {\n    const page: puppeteer.Page = await browser.newPage();\n    await page.goto('about:blank');\n    await page.setContent(\n      getHtml.call(this, 'blank.html', {\n        recordAfter: 'DOMContentLoaded',\n      }),\n    );\n\n    const snapshots = (await page.evaluate(\n      'window.snapshots',\n    )) as eventWithTime[];\n    assertSnapshot(snapshots);\n  });","file":"integration.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will return all the events when there is only one session","suites":["get last session"],"updatePoint":{"line":18,"column":63},"line":18,"code":"  it('will return all the events when there is only one session', () => {\n    expect(discardPriorSnapshots(events, events[0].timestamp)).toEqual(events);\n  });","file":"machine.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will return last session when there is more than one in the events","suites":["get last session"],"updatePoint":{"line":22,"column":72},"line":22,"code":"  it('will return last session when there is more than one in the events', () => {\n    const multiple = events.concat(nextEvents).concat(nextNextEvents);\n    expect(\n      discardPriorSnapshots(\n        multiple,\n        nextNextEvents[nextNextEvents.length - 1].timestamp,\n      ),\n    ).toEqual(nextNextEvents);\n  });","file":"machine.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will return last session when baseline time is future time","suites":["get last session"],"updatePoint":{"line":32,"column":64},"line":32,"code":"  it('will return last session when baseline time is future time', () => {\n    const multiple = events.concat(nextEvents).concat(nextNextEvents);\n    expect(\n      discardPriorSnapshots(\n        multiple,\n        nextNextEvents[nextNextEvents.length - 1].timestamp + 1000,\n      ),\n    ).toEqual(nextNextEvents);\n  });","file":"machine.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will return all sessions when baseline time is prior time","suites":["get last session"],"updatePoint":{"line":42,"column":63},"line":42,"code":"  it('will return all sessions when baseline time is prior time', () => {\n    expect(discardPriorSnapshots(events, events[0].timestamp - 1000)).toEqual(\n      events,\n    );\n  });","file":"machine.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can pack event","suites":["pack"],"updatePoint":{"line":12,"column":20},"line":12,"code":"  it('can pack event', () => {\n    const packedData = pack(event);\n    expect(packedData).toMatchSnapshot();\n  });","file":"packer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"is compatible with unpacked data 1","suites":["unpack"],"updatePoint":{"line":19,"column":40},"line":19,"code":"  it('is compatible with unpacked data 1', () => {\n    const result = unpack(event as unknown as string);\n    expect(result).toEqual(event);\n  });","file":"packer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"is compatible with unpacked data 2","suites":["unpack"],"updatePoint":{"line":24,"column":40},"line":24,"code":"  it('is compatible with unpacked data 2', () => {\n    const result = unpack(JSON.stringify(event));\n    expect(result).toEqual(event);\n  });","file":"packer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"stop on unknown data format","suites":["unpack"],"updatePoint":{"line":29,"column":33},"line":29,"code":"  it('stop on unknown data format', () => {\n    const consoleSpy = jest\n      .spyOn(console, 'error')\n      .mockImplementation(() => {});\n\n    expect(() => unpack('[\"\"]')).toThrow('');\n\n    expect(consoleSpy).toHaveBeenCalled();\n    jest.resetAllMocks();\n  });","file":"packer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can unpack packed data","suites":["unpack"],"updatePoint":{"line":40,"column":28},"line":40,"code":"  it('can unpack packed data', () => {\n    const packedData = pack(event);\n    const result = unpack(packedData);\n    expect(result).toEqual({\n      ...event,\n      v: MARK,\n    });\n  });","file":"packer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will only have one full snapshot without checkout config","suites":["record"],"updatePoint":{"line":98,"column":62},"line":98,"code":"  it('will only have one full snapshot without checkout config', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = (window as unknown as IWindow).rrweb;\n      record({\n        emit: (window as unknown as IWindow).emit,\n      });\n    });\n    let count = 30;\n    while (count--) {\n      await ctx.page.type('input', 'a');\n    }\n    await ctx.page.waitForTimeout(10);\n    expect(ctx.events.length).toEqual(33);\n    expect(\n      ctx.events.filter((event: eventWithTime) => event.type === EventType.Meta)\n        .length,\n    ).toEqual(1);\n    expect(\n      ctx.events.filter(\n        (event: eventWithTime) => event.type === EventType.FullSnapshot,\n      ).length,\n    ).toEqual(1);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can checkout full snapshot by count","suites":["record"],"updatePoint":{"line":122,"column":41},"line":122,"code":"  it('can checkout full snapshot by count', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = (window as unknown as IWindow).rrweb;\n      record({\n        emit: (window as unknown as IWindow).emit,\n        checkoutEveryNth: 10,\n      });\n    });\n    let count = 30;\n    while (count--) {\n      await ctx.page.type('input', 'a');\n    }\n    await ctx.page.waitForTimeout(10);\n    expect(ctx.events.length).toEqual(39);\n    expect(\n      ctx.events.filter((event: eventWithTime) => event.type === EventType.Meta)\n        .length,\n    ).toEqual(4);\n    expect(\n      ctx.events.filter(\n        (event: eventWithTime) => event.type === EventType.FullSnapshot,\n      ).length,\n    ).toEqual(4);\n    expect(ctx.events[1].type).toEqual(EventType.FullSnapshot);\n    expect(ctx.events[13].type).toEqual(EventType.FullSnapshot);\n    expect(ctx.events[25].type).toEqual(EventType.FullSnapshot);\n    expect(ctx.events[37].type).toEqual(EventType.FullSnapshot);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can checkout full snapshot by time","suites":["record"],"updatePoint":{"line":151,"column":40},"line":151,"code":"  it('can checkout full snapshot by time', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = (window as unknown as IWindow).rrweb;\n      record({\n        emit: (window as unknown as IWindow).emit,\n        checkoutEveryNms: 500,\n      });\n    });\n    await ctx.page.type('input', 'a');\n    await ctx.page.waitForTimeout(300);\n    expect(\n      ctx.events.filter((event: eventWithTime) => event.type === EventType.Meta)\n        .length,\n    ).toEqual(1); // before first automatic snapshot\n    expect(\n      ctx.events.filter(\n        (event: eventWithTime) => event.type === EventType.FullSnapshot,\n      ).length,\n    ).toEqual(1); // before first automatic snapshot\n    await ctx.page.waitForTimeout(200);\n    await ctx.page.type('input', 'a');\n    await ctx.page.waitForTimeout(10);\n    expect(\n      ctx.events.filter((event: eventWithTime) => event.type === EventType.Meta)\n        .length,\n    ).toEqual(2);\n    expect(\n      ctx.events.filter(\n        (event: eventWithTime) => event.type === EventType.FullSnapshot,\n      ).length,\n    ).toEqual(2);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"is safe to checkout during async callbacks","suites":["record"],"updatePoint":{"line":184,"column":48},"line":184,"code":"  it('is safe to checkout during async callbacks', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = (window as unknown as IWindow).rrweb;\n      record({\n        emit: (window as unknown as IWindow).emit,\n        checkoutEveryNth: 2,\n      });\n      const p = document.createElement('p');\n      const span = document.createElement('span');\n      setTimeout(() => {\n        document.body.appendChild(p);\n        p.appendChild(span);\n        document.body.removeChild(document.querySelector('input')!);\n      }, 0);\n      setTimeout(() => {\n        span.innerText = 'test';\n      }, 10);\n      setTimeout(() => {\n        p.removeChild(span);\n        document.body.appendChild(span);\n      }, 10);\n    });\n    await ctx.page.waitForTimeout(100);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record scroll position","suites":["record"],"updatePoint":{"line":210,"column":35},"line":210,"code":"  it('should record scroll position', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = (window as unknown as IWindow).rrweb;\n      record({\n        emit: (window as unknown as IWindow).emit,\n      });\n      const p = document.createElement('p');\n      p.innerText = 'testtesttesttesttesttesttesttesttesttest';\n      p.setAttribute('style', 'overflow: auto; height: 1px; width: 1px;');\n      document.body.appendChild(p);\n      p.scrollTop = 10;\n      p.scrollLeft = 10;\n    });\n    await waitForRAF(ctx.page);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record selection event","suites":["record"],"updatePoint":{"line":227,"column":35},"line":227,"code":"  it('should record selection event', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = (window as unknown as IWindow).rrweb;\n      record({\n        emit: (window as unknown as IWindow).emit,\n      });\n      const startNode = document.createElement('p');\n\n      startNode.innerText =\n        'Lorem ipsum dolor sit amet consectetur adipisicing elit.';\n\n      const endNode = document.createElement('span');\n      endNode.innerText =\n        'nihil ipsum officiis pariatur laboriosam quas,corrupti vero vitae minus.';\n\n      document.body.appendChild(startNode);\n      document.body.appendChild(endNode);\n\n      const selection = window.getSelection();\n      const range = new Range();\n\n      range.setStart(startNode!.firstChild!, 10);\n      range.setEnd(endNode!.firstChild!, 2);\n\n      selection?.addRange(range);\n    });\n    await waitForRAF(ctx.page);\n    const selectionData = ctx.events\n      .filter(({ type, data }) => {\n        return (\n          type === EventType.IncrementalSnapshot &&\n          data.source === IncrementalSource.Selection\n        );\n      })\n      .map((ev) => ev.data as selectionData);\n\n    expect(selectionData.length).toEqual(1);\n    expect(selectionData[0].ranges[0].startOffset).toEqual(10);\n    expect(selectionData[0].ranges[0].endOffset).toEqual(2);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can add custom event","suites":["record"],"updatePoint":{"line":268,"column":26},"line":268,"code":"  it('can add custom event', async () => {\n    await ctx.page.evaluate(() => {\n      const { record, addCustomEvent } = (window as unknown as IWindow).rrweb;\n      record({\n        emit: (window as unknown as IWindow).emit,\n      });\n      addCustomEvent<number>('tag1', 1);\n      addCustomEvent<{ a: string }>('tag2', {\n        a: 'b',\n      });\n    });\n    await ctx.page.waitForTimeout(50);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures stylesheet rules","suites":["record"],"updatePoint":{"line":283,"column":31},"line":283,"code":"  it('captures stylesheet rules', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = (window as unknown as IWindow).rrweb;\n\n      record({\n        emit: (window as unknown as IWindow).emit,\n      });\n\n      const styleElement = document.createElement('style');\n      document.head.appendChild(styleElement);\n\n      const styleSheet = <CSSStyleSheet>styleElement.sheet;\n      // begin: pre-serialization\n      const ruleIdx0 = styleSheet.insertRule('body { background: #000; }');\n      const ruleIdx1 = styleSheet.insertRule('body { background: #111; }');\n      styleSheet.deleteRule(ruleIdx1);\n      // end: pre-serialization\n      setTimeout(() => {\n        styleSheet.insertRule('body { color: #fff; }');\n      }, 0);\n      setTimeout(() => {\n        styleSheet.deleteRule(ruleIdx0);\n      }, 5);\n      setTimeout(() => {\n        styleSheet.insertRule('body { color: #ccc; }');\n      }, 10);\n    });\n    await ctx.page.waitForTimeout(50);\n    const styleSheetRuleEvents = ctx.events.filter(\n      (e) =>\n        e.type === EventType.IncrementalSnapshot &&\n        e.data.source === IncrementalSource.StyleSheetRule,\n    );\n    const addRules = styleSheetRuleEvents.filter((e) =>\n      Boolean((e.data as styleSheetRuleData).adds),\n    );\n    const removeRuleCount = styleSheetRuleEvents.filter((e) =>\n      Boolean((e.data as styleSheetRuleData).removes),\n    ).length;\n    // pre-serialization insert/delete should be ignored\n    expect(addRules.length).toEqual(2);\n    expect((addRules[0].data as styleSheetRuleData).adds).toEqual([\n      {\n        rule: 'body { color: #fff; }',\n      },\n    ]);\n    expect(removeRuleCount).toEqual(1);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures nested stylesheet rules","suites":["record"],"updatePoint":{"line":378,"column":38},"line":378,"code":"  it('captures nested stylesheet rules', captureNestedStylesheetRulesTest);","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures nested stylesheet rules","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":391,"column":40},"line":391,"code":"    it('captures nested stylesheet rules', captureNestedStylesheetRulesTest);","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures style property changes","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":394,"column":37},"line":394,"code":"  it('captures style property changes', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = (window as unknown as IWindow).rrweb;\n\n      record({\n        emit: (window as unknown as IWindow).emit,\n        ignoreCSSAttributes: new Set(['color']),\n      });\n\n      const styleElement = document.createElement('style');\n      document.head.appendChild(styleElement);\n\n      const styleSheet = <CSSStyleSheet>styleElement.sheet;\n      styleSheet.insertRule('body { background: #000; }');\n      setTimeout(() => {\n        // should be ignored\n        (styleSheet.cssRules[0] as CSSStyleRule).style.setProperty(\n          'color',\n          'green',\n        );\n\n        // should be captured because we did not block it\n        (styleSheet.cssRules[0] as CSSStyleRule).style.setProperty(\n          'border-color',\n          'green',\n        );\n\n        (styleSheet.cssRules[0] as CSSStyleRule).style.removeProperty(\n          'background',\n        );\n      }, 0);\n    });\n    await ctx.page.waitForTimeout(50);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures inserted style text nodes correctly","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":430,"column":50},"line":430,"code":"  it('captures inserted style text nodes correctly', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = (window as unknown as IWindow).rrweb;\n\n      const styleEl = document.createElement(`style`);\n      styleEl.append(document.createTextNode('div { color: red; }'));\n      styleEl.append(document.createTextNode('section { color: blue; }'));\n      document.head.appendChild(styleEl);\n\n      record({\n        emit: (window as unknown as IWindow).emit,\n      });\n\n      styleEl.append(document.createTextNode('span { color: orange; }'));\n      styleEl.append(document.createTextNode('h1 { color: pink; }'));\n    });\n    await waitForRAF(ctx.page);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures stylesheets with `blob:` url","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":450,"column":43},"line":450,"code":"  it('captures stylesheets with `blob:` url', async () => {\n    await ctx.page.evaluate(() => {\n      const link1 = document.createElement('link');\n      link1.setAttribute('rel', 'stylesheet');\n      link1.setAttribute(\n        'href',\n        URL.createObjectURL(\n          new Blob(['body { color: pink; }'], {\n            type: 'text/css',\n          }),\n        ),\n      );\n      document.head.appendChild(link1);\n    });\n    await waitForRAF(ctx.page);\n    await ctx.page.evaluate(() => {\n      const { record } = (window as unknown as IWindow).rrweb;\n\n      record({\n        inlineStylesheet: true,\n        emit: (window as unknown as IWindow).emit,\n      });\n    });\n    await waitForRAF(ctx.page);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures mutations on adopted stylesheets","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":477,"column":47},"line":477,"code":"  it('captures mutations on adopted stylesheets', async () => {\n    await ctx.page.evaluate(() => {\n      return new Promise((resolve) => {\n        document.body.innerHTML = `\n        <div>div in outermost document</div>\n        <iframe></iframe>\n      `;\n\n        const sheet = new CSSStyleSheet();\n        // Add stylesheet to a document.\n\n        document.adoptedStyleSheets = [sheet];\n\n        const iframe = document.querySelector('iframe');\n        const sheet2 = new (\n          iframe!.contentWindow! as Window & typeof globalThis\n        ).CSSStyleSheet();\n\n        // Add stylesheet to an IFrame document.\n        iframe!.contentDocument!.adoptedStyleSheets = [sheet2];\n        iframe!.contentDocument!.body.innerHTML = '<h1>h1 in iframe</h1>';\n\n        const { rrweb, emit } = window as unknown as IWindow;\n        rrweb.record({\n          emit,\n        });\n\n        setTimeout(() => {\n          sheet.replace!('div { color: yellow; }');\n          sheet2.replace!('h1 { color: blue; }');\n        }, 0);\n\n        setTimeout(() => {\n          sheet.replaceSync!('div { display: inline ; }');\n          sheet2.replaceSync!('h1 { font-size: large; }');\n        }, 5);\n\n        setTimeout(() => {\n          (sheet.cssRules[0] as CSSStyleRule).style.setProperty(\n            'color',\n            'green',\n          );\n          (sheet.cssRules[0] as CSSStyleRule).style.removeProperty('display');\n          (sheet2.cssRules[0] as CSSStyleRule).style.setProperty(\n            'font-size',\n            'medium',\n            'important',\n          );\n          sheet2.insertRule('h2 { color: red; }');\n        }, 10);\n\n        setTimeout(() => {\n          sheet.insertRule('body { border: 2px solid blue; }', 1);\n          sheet2.deleteRule(0);\n        }, 15);\n\n        setTimeout(() => {\n          resolve(undefined);\n        }, 20);\n      });\n    });\n    await waitForRAF(ctx.page);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures adopted stylesheets in nested shadow doms and iframes","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":542,"column":68},"line":542,"code":"  it('captures adopted stylesheets in nested shadow doms and iframes', async () => {\n    await ctx.page.evaluate(() => {\n      document.body.innerHTML = `\n        <div id=\"shadow-host-1\">entry</div>\n      `;\n\n      let shadowHost = document.querySelector('div')!;\n      shadowHost!.attachShadow({ mode: 'open' });\n      let iframeDocument: Document;\n      const NestedDepth = 4;\n      // construct nested shadow doms and iframe elements\n      for (let i = 1; i <= NestedDepth; i++) {\n        const shadowRoot = shadowHost.shadowRoot!;\n        const iframeElement = document.createElement('iframe');\n        shadowRoot.appendChild(iframeElement);\n        iframeElement.id = `iframe-${i}`;\n        iframeDocument = iframeElement.contentDocument!;\n        shadowHost = iframeDocument.createElement('div');\n        shadowHost.id = `shadow-host-${i + 1}`;\n        iframeDocument.body.append(shadowHost);\n        shadowHost!.attachShadow({ mode: 'open' });\n      }\n\n      const iframeWin = iframeDocument!.defaultView!;\n      const sheet1 = new iframeWin.CSSStyleSheet();\n      sheet1.replaceSync!('h1 {color: blue;}');\n      iframeDocument!.adoptedStyleSheets = [sheet1];\n      const sheet2 = new iframeWin.CSSStyleSheet();\n      sheet2.replaceSync!('div {font-size: large;}');\n      shadowHost.shadowRoot!.adoptedStyleSheets = [sheet2];\n\n      const { rrweb, emit } = window as unknown as IWindow;\n      rrweb.record({\n        emit,\n      });\n\n      setTimeout(() => {\n        sheet1.insertRule!('div { display: inline ; }', 1);\n        sheet2.replaceSync!('h1 { font-size: large; }');\n      }, 100);\n\n      setTimeout(() => {\n        const sheet3 = new iframeWin.CSSStyleSheet();\n        sheet3.replaceSync!('span {background-color: red;}');\n        iframeDocument!.adoptedStyleSheets = [sheet3, sheet2];\n        shadowHost.shadowRoot!.adoptedStyleSheets = [sheet1, sheet3];\n      }, 150);\n    });\n    await ctx.page.waitForTimeout(200);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures adopted stylesheets of shadow doms in checkout full snapshot","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":594,"column":75},"line":594,"code":"  it('captures adopted stylesheets of shadow doms in checkout full snapshot', async () => {\n    await ctx.page.evaluate(() => {\n      return new Promise((resolve) => {\n        document.body.innerHTML = `\n            <div id=\"shadow-host-1\">entry</div>\n          `;\n\n        let shadowHost = document.querySelector('div')!;\n        shadowHost!.attachShadow({ mode: 'open' });\n        const sheet = new CSSStyleSheet();\n        sheet.replaceSync!('h1 {color: blue;}');\n        shadowHost.shadowRoot!.adoptedStyleSheets = [sheet];\n\n        const { rrweb, emit } = window as unknown as IWindow;\n        rrweb.record({\n          emit,\n        });\n\n        setTimeout(() => {\n          // When a full snapshot is checked out manually, all adoptedStylesheets should also be captured.\n          rrweb.record.takeFullSnapshot(true);\n          resolve(undefined);\n        }, 10);\n      });\n    });\n    await waitForRAF(ctx.page);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures stylesheets in iframes with `blob:` url","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":623,"column":54},"line":623,"code":"  it('captures stylesheets in iframes with `blob:` url', async () => {\n    await ctx.page.evaluate(() => {\n      const iframe = document.createElement('iframe');\n      iframe.setAttribute('src', 'about:blank');\n      document.body.appendChild(iframe);\n\n      const linkEl = document.createElement('link');\n      linkEl.setAttribute('rel', 'stylesheet');\n      linkEl.setAttribute(\n        'href',\n        URL.createObjectURL(\n          new Blob(['body { color: pink; }'], {\n            type: 'text/css',\n          }),\n        ),\n      );\n      const iframeDoc = iframe.contentDocument!;\n      iframeDoc.head.appendChild(linkEl);\n    });\n    await waitForRAF(ctx.page);\n    await ctx.page.evaluate(() => {\n      const { record } = (window as unknown as IWindow).rrweb;\n\n      record({\n        inlineStylesheet: true,\n        emit: (window as unknown as IWindow).emit,\n      });\n    });\n    await waitForRAF(ctx.page);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"aggregates mutations","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":655,"column":26},"line":655,"code":"  it('aggregates mutations', async () => {\n    await ctx.page.evaluate(() => {\n      return new Promise((resolve) => {\n        const { record, freezePage } = (window as unknown as IWindow).rrweb;\n        record({\n          emit: (window as unknown as IWindow).emit,\n        });\n        freezePage();\n        setTimeout(() => {\n          const div = document.createElement('div');\n          div.setAttribute('id', 'here-and-gone');\n          document.body.appendChild(div);\n        }, 0);\n        setTimeout(() => {\n          const div = document.getElementById('here-and-gone');\n          if (div) {\n            div.setAttribute('data-test', 'x');\n          }\n        }, 10);\n        setTimeout(() => {\n          const div = document.getElementById('here-and-gone');\n          if (div) {\n            div.parentNode?.removeChild(div as HTMLElement);\n          }\n        }, 15);\n        setTimeout(() => {\n          // 'unfreeze' happens upon a user event\n          // however, we expect none of the above mutations to produce any effect\n          document.body.click();\n        }, 20);\n        setTimeout(() => {\n          resolve(null);\n        }, 25);\n      });\n    });\n    await waitForRAF(ctx.page); // wait till events get sent\n\n    const mutationEvents = ctx.events.filter(\n      (e) =>\n        e.type === EventType.IncrementalSnapshot &&\n        e.data.source === IncrementalSource.Mutation,\n    );\n    expect(mutationEvents.length).toEqual(0); // there was no aggregate effect\n\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"no need for attribute mutations on adds","suites":["record","without CSSGroupingRule support"],"updatePoint":{"line":702,"column":45},"line":702,"code":"  it('no need for attribute mutations on adds', async () => {\n    await ctx.page.evaluate(() => {\n      const { record, freezePage } = (window as unknown as IWindow).rrweb;\n      record({\n        emit: (window as unknown as IWindow).emit,\n      });\n      freezePage();\n      setTimeout(() => {\n        const div = document.createElement('div');\n        div.setAttribute('id', 'here');\n        div.innerText = 'as-created';\n        div.setAttribute('data-test', 'as-created');\n        document.body.appendChild(div);\n      }, 0);\n      setTimeout(() => {\n        const div = document.getElementById('here');\n        if (div) {\n          div.setAttribute('data-test', 'x');\n          (div.childNodes[0] as Text).replaceData(0, 'as-created'.length, 'y');\n        }\n      }, 10);\n      setTimeout(() => {\n        // 'unfreeze' happens upon a user event\n        document.body.click();\n      }, 20);\n    });\n    await ctx.page.waitForTimeout(50); // wait till setTimeout is called\n    await waitForRAF(ctx.page); // wait till events get sent\n\n    const mutationEvents = ctx.events.filter(\n      (e) =>\n        e.type === EventType.IncrementalSnapshot &&\n        e.data.source === IncrementalSource.Mutation,\n    );\n    expect(mutationEvents.length).toEqual(1);\n\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures stylesheets that are still loading","suites":["record","loading stylesheets"],"updatePoint":{"line":772,"column":51},"line":772,"code":"    it('captures stylesheets that are still loading', async () => {\n      ctx.page.evaluate((serverURL) => {\n        const { record } = (window as unknown as IWindow).rrweb;\n\n        record({\n          inlineStylesheet: true,\n          emit: (window as unknown as IWindow).emit,\n        });\n\n        const link1 = document.createElement('link');\n        link1.setAttribute('rel', 'stylesheet');\n        link1.setAttribute('href', `${serverURL}/html/assets/style.css`);\n        document.head.appendChild(link1);\n      }, serverURL);\n\n      await ctx.page.waitForResponse(`${serverURL}/html/assets/style.css`);\n      await waitForRAF(ctx.page);\n\n      assertSnapshot(ctx.events);\n    });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures stylesheets in iframes that are still loading","suites":["record","loading stylesheets"],"updatePoint":{"line":793,"column":62},"line":793,"code":"    it('captures stylesheets in iframes that are still loading', async () => {\n      ctx.page.evaluate(() => {\n        const iframe = document.createElement('iframe');\n        iframe.setAttribute('src', `/html/hello-world.html?2`);\n        document.body.appendChild(iframe);\n\n        const { record } = (window as unknown as IWindow).rrweb;\n\n        record({\n          inlineStylesheet: true,\n          emit: (window as unknown as IWindow).emit,\n        });\n      });\n\n      await ctx.page.waitForResponse(`${serverURL}/html/hello-world.html?2`);\n\n      await waitForRAF(ctx.page);\n\n      ctx.page.evaluate(() => {\n        const iframe = document.querySelector('iframe')!;\n        const iframeDoc = iframe.contentDocument!;\n        const linkEl = document.createElement('link');\n        linkEl.setAttribute('rel', 'stylesheet');\n        linkEl.setAttribute('href', `/html/assets/style.css`);\n        iframeDoc.head.appendChild(linkEl);\n      });\n\n      await ctx.page.waitForResponse(`${serverURL}/html/assets/style.css`);\n\n      await waitForRAF(ctx.page);\n\n      assertSnapshot(ctx.events);\n    });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures CORS stylesheets that are still loading","suites":["record","loading stylesheets"],"updatePoint":{"line":828,"column":54},"line":828,"code":"  it('captures CORS stylesheets that are still loading', async () => {\n    const corsStylesheetURL =\n      'https://cdn.jsdelivr.net/npm/pure@2.85.0/index.css';\n\n    // do not `await` the following function, otherwise `waitForResponse` _might_ not be called\n    void ctx.page.evaluate((corsStylesheetURL) => {\n      const { record } = (window as unknown as IWindow).rrweb;\n\n      record({\n        inlineStylesheet: true,\n        emit: (window as unknown as IWindow).emit,\n      });\n\n      const link1 = document.createElement('link');\n      link1.setAttribute('rel', 'stylesheet');\n      link1.setAttribute('href', corsStylesheetURL);\n      document.head.appendChild(link1);\n    }, corsStylesheetURL);\n\n    await ctx.page.waitForResponse(corsStylesheetURL); // wait for stylesheet to be loaded\n    await waitForRAF(ctx.page); // wait for rrweb to emit events\n\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures adopted stylesheets in shadow doms and iframe","suites":["record","loading stylesheets"],"updatePoint":{"line":853,"column":60},"line":853,"code":"  it('captures adopted stylesheets in shadow doms and iframe', async () => {\n    await ctx.page.evaluate(() => {\n      return new Promise((resolve) => {\n        document.body.innerHTML = `\n        <div>div in outermost document</div>\n        <div id=\"shadow-host1\"></div>\n        <div id=\"shadow-host2\"></div>\n        <iframe></iframe>\n      `;\n\n        const sheet = new CSSStyleSheet();\n        sheet.replaceSync!(\n          'div { color: yellow; } h2 { color: orange; } h3 { font-size: larger;}',\n        );\n        // Add stylesheet to a document.\n\n        document.adoptedStyleSheets = [sheet];\n\n        // Add stylesheet to a shadow host.\n        const host = document.querySelector('#shadow-host1');\n        const shadow = host!.attachShadow({ mode: 'open' });\n        shadow.innerHTML =\n          '<div>div in shadow dom 1</div><span>span in shadow dom 1</span>';\n        const sheet2 = new CSSStyleSheet();\n\n        sheet2.replaceSync!('span { color: red; }');\n\n        shadow.adoptedStyleSheets = [sheet, sheet2];\n\n        // Add stylesheet to an IFrame document.\n        const iframe = document.querySelector('iframe');\n        const sheet3 = new (\n          iframe!.contentWindow! as IWindow & typeof globalThis\n        ).CSSStyleSheet();\n        sheet3.replaceSync!('h1 { color: blue; }');\n\n        iframe!.contentDocument!.adoptedStyleSheets = [sheet3];\n\n        const ele = iframe!.contentDocument!.createElement('h1');\n        ele.innerText = 'h1 in iframe';\n        iframe!.contentDocument!.body.appendChild(ele);\n\n        (window as unknown as IWindow).rrweb.record({\n          emit: (window.top as unknown as IWindow).emit,\n        });\n\n        // Make incremental changes to shadow dom.\n        setTimeout(() => {\n          const host = document.querySelector('#shadow-host2');\n          const shadow = host!.attachShadow({ mode: 'open' });\n          shadow.innerHTML =\n            '<div>div in shadow dom 2</div><span>span in shadow dom 2</span>';\n          const sheet4 = new CSSStyleSheet();\n          sheet4.replaceSync!('span { color: green; }');\n          shadow.adoptedStyleSheets = [sheet, sheet4];\n\n          document.adoptedStyleSheets = [sheet4, sheet, sheet2];\n\n          const sheet5 = new (\n            iframe!.contentWindow! as IWindow & typeof globalThis\n          ).CSSStyleSheet();\n          sheet5.replaceSync!('h2 { color: purple; }');\n          iframe!.contentDocument!.adoptedStyleSheets = [sheet5, sheet3];\n        }, 10);\n\n        setTimeout(() => {\n          resolve(null);\n        }, 20);\n      });\n    });\n    await waitForRAF(ctx.page); // wait till events get sent\n\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures iframe content in correct order","suites":["record iframes"],"updatePoint":{"line":944,"column":46},"line":944,"code":"  it('captures iframe content in correct order', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = (window as unknown as IWindow).rrweb;\n      record({\n        emit: (window as unknown as IWindow).emit,\n      });\n    });\n    await waitForRAF(ctx.page);\n    // console.log(JSON.stringify(ctx.events));\n\n    expect(ctx.events.length).toEqual(3);\n    const eventTypes = ctx.events\n      .filter(\n        (e) =>\n          e.type === EventType.IncrementalSnapshot ||\n          e.type === EventType.FullSnapshot,\n      )\n      .map((e) => e.type);\n    expect(eventTypes).toEqual([\n      EventType.FullSnapshot,\n      EventType.IncrementalSnapshot,\n    ]);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures stylesheet mutations in iframes","suites":["record iframes"],"updatePoint":{"line":968,"column":46},"line":968,"code":"  it('captures stylesheet mutations in iframes', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = (window as unknown as IWindow).rrweb;\n      record({\n        // need to reference window.top for when we are in an iframe!\n        emit: (window.top as unknown as IWindow).emit,\n      });\n\n      const iframe = document.querySelector('iframe');\n      // outer timeout is needed to wait for initStyleSheetObserver on iframe to be set up\n      setTimeout(() => {\n        const idoc = (iframe as HTMLIFrameElement).contentDocument!;\n        const styleElement = idoc.createElement('style');\n\n        idoc.head.appendChild(styleElement);\n\n        const styleSheet = <CSSStyleSheet>styleElement.sheet;\n        styleSheet.insertRule('@media {}');\n        const atMediaRule = styleSheet.cssRules[0] as CSSMediaRule;\n        const atRuleIdx0 = atMediaRule.insertRule(\n          'body { background: #000; }',\n          0,\n        );\n        const ruleIdx0 = styleSheet.insertRule('body { background: #000; }'); // inserted before above\n        // pre-serialization insert/delete above should be ignored\n        setTimeout(() => {\n          styleSheet.insertRule('body { color: #fff; }');\n          atMediaRule.insertRule('body { color: #ccc; }', 0);\n        }, 0);\n        setTimeout(() => {\n          styleSheet.deleteRule(ruleIdx0);\n          (styleSheet.cssRules[0] as CSSStyleRule).style.setProperty(\n            'color',\n            'green',\n          );\n        }, 5);\n        setTimeout(() => {\n          atMediaRule.deleteRule(atRuleIdx0);\n        }, 10);\n      }, 10);\n    });\n    await ctx.page.waitForTimeout(50); // wait till setTimeout is called\n    await waitForRAF(ctx.page); // wait till events get sent\n    const styleRelatedEvents = ctx.events.filter(\n      (e) =>\n        e.type === EventType.IncrementalSnapshot &&\n        (e.data.source === IncrementalSource.StyleSheetRule ||\n          e.data.source === IncrementalSource.StyleDeclaration),\n    );\n    const addRuleCount = styleRelatedEvents.filter((e) =>\n      Boolean((e.data as styleSheetRuleData).adds),\n    ).length;\n    const removeRuleCount = styleRelatedEvents.filter((e) =>\n      Boolean((e.data as styleSheetRuleData).removes),\n    ).length;\n    expect(styleRelatedEvents.length).toEqual(5);\n    expect(addRuleCount).toEqual(2);\n    expect(removeRuleCount).toEqual(2);\n    assertSnapshot(ctx.events);\n  });","file":"record.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"won't emit events if it isn't in the top level iframe","suites":["cross origin iframes","form.html"],"updatePoint":{"line":144,"column":61},"line":144,"code":"    it(\"won't emit events if it isn't in the top level iframe\", async () => {\n      const el = (await ctx.page.$(\n        'body > iframe',\n      )) as puppeteer.ElementHandle<Element>;\n\n      const frame = await el.contentFrame();\n      const events = await frame?.evaluate(\n        () => (window as unknown as IWindow).snapshots,\n      );\n      expect(events).toMatchObject([]);\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will emit events if it is in the top level iframe","suites":["cross origin iframes","form.html"],"updatePoint":{"line":156,"column":57},"line":156,"code":"    it('will emit events if it is in the top level iframe', async () => {\n      const events = await ctx.page.evaluate(\n        () => (window as unknown as IWindow).snapshots,\n      );\n      expect(events.length).not.toBe(0);\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should emit contents of iframe","suites":["cross origin iframes","form.html"],"updatePoint":{"line":163,"column":38},"line":163,"code":"    it('should emit contents of iframe', async () => {\n      const events = await ctx.page.evaluate(\n        () => (window as unknown as IWindow).snapshots,\n      );\n      await waitForRAF(ctx.page);\n      // two events (full snapshot + meta) from main frame, and one full snapshot from iframe\n      expect(events.length).toBe(3);\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should emit full snapshot event from iframe as mutation event","suites":["cross origin iframes","form.html"],"updatePoint":{"line":172,"column":69},"line":172,"code":"    it('should emit full snapshot event from iframe as mutation event', async () => {\n      const events = await ctx.page.evaluate(\n        () => (window as unknown as IWindow).snapshots,\n      );\n      await waitForRAF(ctx.page);\n      // two events from main frame, and two from iframe\n      expect(events[events.length - 1]).toMatchObject({\n        type: EventType.IncrementalSnapshot,\n        data: {\n          source: IncrementalSource.Mutation,\n          adds: [\n            {\n              parentId: expect.any(Number),\n              node: {\n                id: expect.any(Number),\n              },\n            },\n          ],\n        },\n      });\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should use unique id for child of iframes","suites":["cross origin iframes","form.html"],"updatePoint":{"line":194,"column":49},"line":194,"code":"    it('should use unique id for child of iframes', async () => {\n      const events: eventWithTime[] = await ctx.page.evaluate(\n        () => (window as unknown as IWindow).snapshots,\n      );\n      await waitForRAF(ctx.page);\n      expect(\n        (events[events.length - 1].data as mutationData).adds[0].node.id,\n      ).not.toBe(1);\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should replace the existing DOM nodes on iframe navigation with `isAttachIframe`","suites":["cross origin iframes","form.html"],"updatePoint":{"line":204,"column":88},"line":204,"code":"    it('should replace the existing DOM nodes on iframe navigation with `isAttachIframe`', async () => {\n      await ctx.page.evaluate((url) => {\n        const iframe = document.querySelector('iframe') as HTMLIFrameElement;\n        iframe.src = `${url}/html/form.html?2`;\n      }, ctx.serverURL);\n      await waitForRAF(ctx.page); // loads iframe\n\n      await injectRecordScript(ctx.page.mainFrame().childFrames()[0]); // injects script into new iframe\n\n      const events: eventWithTime[] = await ctx.page.evaluate(\n        () => (window as unknown as IWindow).snapshots,\n      );\n      expect(\n        (events[events.length - 1].data as mutationData).removes,\n      ).toMatchObject([]);\n      expect(\n        (events[events.length - 1].data as mutationData).isAttachIframe,\n      ).toBeTruthy();\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should map input events correctly","suites":["cross origin iframes","form.html"],"updatePoint":{"line":224,"column":41},"line":224,"code":"    it('should map input events correctly', async () => {\n      const frame = ctx.page.mainFrame().childFrames()[0];\n      await frame.type('input[type=\"text\"]', 'test');\n      await frame.click('input[type=\"radio\"]');\n      await frame.click('input[type=\"checkbox\"]');\n      await frame.type('input[type=\"password\"]', 'password');\n      await frame.type('textarea', 'textarea test');\n      await frame.select('select', '1');\n\n      const snapshots = (await ctx.page.evaluate(\n        'window.snapshots',\n      )) as eventWithTime[];\n      assertSnapshot(snapshots);\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should map scroll events correctly","suites":["cross origin iframes","form.html"],"updatePoint":{"line":239,"column":42},"line":239,"code":"    it('should map scroll events correctly', async () => {\n      // force scrollbars in iframe\n      ctx.page.evaluate(() => {\n        const iframe = document.querySelector('iframe') as HTMLIFrameElement;\n        iframe.style.width = '50px';\n        iframe.style.height = '50px';\n      });\n\n      await waitForRAF(ctx.page);\n      const frame = ctx.page.mainFrame().childFrames()[0];\n\n      // scroll a little\n      frame.evaluate(() => {\n        window.scrollTo(0, 10);\n      });\n      await waitForRAF(ctx.page);\n\n      const snapshots = (await ctx.page.evaluate(\n        'window.snapshots',\n      )) as eventWithTime[];\n      assertSnapshot(snapshots);\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record DOM node movement","suites":["cross origin iframes","move-node.html"],"updatePoint":{"line":276,"column":39},"line":276,"code":"    it('should record DOM node movement', async () => {\n      const frame = ctx.page.mainFrame().childFrames()[0];\n      await frame.evaluate(() => {\n        const div = document.createElement('div');\n        const span = document.querySelector('span')!;\n        document.body.appendChild(div);\n        div.appendChild(span);\n      });\n      const snapshots = (await ctx.page.evaluate(\n        'window.snapshots',\n      )) as eventWithTime[];\n      assertSnapshot(snapshots);\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record DOM node removal","suites":["cross origin iframes","move-node.html"],"updatePoint":{"line":290,"column":38},"line":290,"code":"    it('should record DOM node removal', async () => {\n      const frame = ctx.page.mainFrame().childFrames()[0];\n      await frame.evaluate(() => {\n        const span = document.querySelector('span')!;\n        span.remove();\n      });\n      const snapshots = (await ctx.page.evaluate(\n        'window.snapshots',\n      )) as eventWithTime[];\n      assertSnapshot(snapshots);\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record DOM attribute changes","suites":["cross origin iframes","move-node.html"],"updatePoint":{"line":302,"column":43},"line":302,"code":"    it('should record DOM attribute changes', async () => {\n      const frame = ctx.page.mainFrame().childFrames()[0];\n      await frame.evaluate(() => {\n        const span = document.querySelector('span')!;\n        span.className = 'added-class-name';\n      });\n      const snapshots = (await ctx.page.evaluate(\n        'window.snapshots',\n      )) as eventWithTime[];\n      assertSnapshot(snapshots);\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record DOM text changes","suites":["cross origin iframes","move-node.html"],"updatePoint":{"line":314,"column":38},"line":314,"code":"    it('should record DOM text changes', async () => {\n      const frame = ctx.page.mainFrame().childFrames()[0];\n      await frame.evaluate(() => {\n        const b = document.querySelector('b')!;\n        b.childNodes[0].textContent = 'replaced text';\n      });\n      const snapshots = (await ctx.page.evaluate(\n        'window.snapshots',\n      )) as eventWithTime[];\n      assertSnapshot(snapshots);\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record canvas elements","suites":["cross origin iframes","move-node.html"],"updatePoint":{"line":326,"column":37},"line":326,"code":"    it('should record canvas elements', async () => {\n      const frame = ctx.page.mainFrame().childFrames()[0];\n      await frame.evaluate(() => {\n        var canvas = document.createElement('canvas');\n        var gl = canvas.getContext('webgl')!;\n        var program = gl.createProgram()!;\n        gl.linkProgram(program);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        document.body.appendChild(canvas);\n      });\n      await waitForRAF(ctx.page);\n      const snapshots = (await ctx.page.evaluate(\n        'window.snapshots',\n      )) as eventWithTime[];\n      assertSnapshot(snapshots);\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record custom events","suites":["cross origin iframes","move-node.html"],"updatePoint":{"line":343,"column":35},"line":343,"code":"    it('should record custom events', async () => {\n      const frame = ctx.page.mainFrame().childFrames()[0];\n      await frame.evaluate(() => {\n        (window as unknown as IWindow).rrweb.addCustomEvent('test', {\n          id: 1,\n          parentId: 1,\n          nextId: 2,\n        });\n      });\n      await waitForRAF(ctx.page);\n      const snapshots = (await ctx.page.evaluate(\n        'window.snapshots',\n      )) as eventWithTime[];\n      assertSnapshot(snapshots);\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures mutations on adopted stylesheets","suites":["cross origin iframes","move-node.html"],"updatePoint":{"line":359,"column":49},"line":359,"code":"    it('captures mutations on adopted stylesheets', async () => {\n      const frame = ctx.page.mainFrame().childFrames()[0];\n      await ctx.page.evaluate(() => {\n        const sheet = new CSSStyleSheet();\n        // Add stylesheet to a document.\n        document.adoptedStyleSheets = [sheet];\n      });\n      await frame.evaluate(() => {\n        const sheet = new CSSStyleSheet();\n        // Add stylesheet to a document.\n        document.adoptedStyleSheets = [sheet];\n      });\n      await waitForRAF(ctx.page);\n      await ctx.page.evaluate(() => {\n        document.adoptedStyleSheets![0].replace!('div { color: yellow; }');\n      });\n      await frame.evaluate(() => {\n        document.adoptedStyleSheets![0].replace!('h1 { color: blue; }');\n      });\n      await waitForRAF(ctx.page);\n      await ctx.page.evaluate(() => {\n        document.adoptedStyleSheets![0].replaceSync!(\n          'div { display: inline ; }',\n        );\n      });\n      await frame.evaluate(() => {\n        document.adoptedStyleSheets![0].replaceSync!(\n          'h1 { font-size: large; }',\n        );\n      });\n      await waitForRAF(ctx.page);\n      await ctx.page.evaluate(() => {\n        (\n          document.adoptedStyleSheets![0].cssRules[0] as CSSStyleRule\n        ).style.setProperty('color', 'green');\n        (\n          document.adoptedStyleSheets![0].cssRules[0] as CSSStyleRule\n        ).style.removeProperty('display');\n      });\n      await frame.evaluate(() => {\n        (\n          document.adoptedStyleSheets![0].cssRules[0] as CSSStyleRule\n        ).style.setProperty('font-size', 'medium', 'important');\n        document.adoptedStyleSheets![0].insertRule('h2 { color: red; }');\n      });\n      await waitForRAF(ctx.page);\n      await ctx.page.evaluate(() => {\n        document.adoptedStyleSheets![0].insertRule(\n          'body { border: 2px solid blue; }',\n          1,\n        );\n      });\n      await frame.evaluate(() => {\n        document.adoptedStyleSheets![0].deleteRule(0);\n      });\n      await waitForRAF(ctx.page);\n\n      const snapshots = (await ctx.page.evaluate(\n        'window.snapshots',\n      )) as eventWithTime[];\n      assertSnapshot(snapshots);\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"captures mutations on stylesheets","suites":["cross origin iframes","move-node.html"],"updatePoint":{"line":422,"column":41},"line":422,"code":"    it('captures mutations on stylesheets', async () => {\n      const frame = ctx.page.mainFrame().childFrames()[0];\n      await ctx.page.evaluate(() => {\n        // Add stylesheet to a document.\n        const style = document.createElement('style');\n        document.head.appendChild(style);\n      });\n      await frame.evaluate(() => {\n        // Add stylesheet to a document.\n        const style = document.createElement('style');\n        document.head.appendChild(style);\n      });\n      await waitForRAF(ctx.page);\n      await ctx.page.evaluate(() => {\n        document.styleSheets[0].insertRule('div { color: yellow; }');\n      });\n      await frame.evaluate(() => {\n        document.styleSheets[0].insertRule('h1 { color: blue; }');\n      });\n      await waitForRAF(ctx.page);\n      await ctx.page.evaluate(() => {\n        (document.styleSheets[0].cssRules[0] as CSSStyleRule).style.setProperty(\n          'color',\n          'green',\n        );\n        (\n          document.styleSheets[0].cssRules[0] as CSSStyleRule\n        ).style.removeProperty('display');\n      });\n      await frame.evaluate(() => {\n        (document.styleSheets[0].cssRules[0] as CSSStyleRule).style.setProperty(\n          'font-size',\n          'medium',\n          'important',\n        );\n        document.styleSheets[0].insertRule('h2 { color: red; }');\n      });\n      await waitForRAF(ctx.page);\n      await ctx.page.evaluate(() => {\n        document.styleSheets[0].insertRule(\n          'body { border: 2px solid blue; }',\n          1,\n        );\n      });\n      await frame.evaluate(() => {\n        document.styleSheets[0].deleteRule(0);\n      });\n      await waitForRAF(ctx.page);\n\n      const snapshots = (await ctx.page.evaluate(\n        'window.snapshots',\n      )) as eventWithTime[];\n      assertSnapshot(snapshots);\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should emit contents of iframe once","suites":["cross origin iframes","audio.html"],"updatePoint":{"line":493,"column":43},"line":493,"code":"    it('should emit contents of iframe once', async () => {\n      const frame = ctx.page.mainFrame().childFrames()[0];\n      await frame.evaluate(() => {\n        const el = document.querySelector('audio')!;\n        el.play();\n      });\n      await waitForRAF(ctx.page);\n      const snapshots = (await ctx.page.evaluate(\n        'window.snapshots',\n      )) as eventWithTime[];\n      assertSnapshot(snapshots);\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record same-origin iframe in cross-origin iframe","suites":["cross origin iframes","blank.html"],"updatePoint":{"line":520,"column":63},"line":520,"code":"    it('should record same-origin iframe in cross-origin iframe', async () => {\n      const frame = ctx.page.mainFrame().childFrames()[0];\n      await frame.evaluate(() => {\n        const iframe2 = document.createElement('iframe');\n        // Append a same-origin iframe in a cross-origin iframe.\n        document.body.appendChild(iframe2);\n        iframe2.contentDocument!.body.appendChild(\n          document.createTextNode('Same-origin iframe in cross-origin iframe'),\n        );\n      });\n\n      await waitForRAF(ctx.page);\n      const snapshots = (await ctx.page.evaluate(\n        'window.snapshots',\n      )) as eventWithTime[];\n      assertSnapshot(snapshots);\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should filter out forwarded cross origin rrweb messages","suites":["cross origin iframes","blank.html"],"updatePoint":{"line":538,"column":63},"line":538,"code":"    it('should filter out forwarded cross origin rrweb messages', async () => {\n      const frame = ctx.page.mainFrame().childFrames()[0];\n      const iframe2URL = `${ctx.serverBURL}/html/blank.html`;\n      await frame.evaluate((iframe2URL) => {\n        // Add a message proxy to forward messages from child frames to its parent frame.\n        window.addEventListener('message', (event) => {\n          if (event.source !== window)\n            window.parent.postMessage(event.data, '*');\n        });\n        const iframe2 = document.createElement('iframe');\n        iframe2.src = iframe2URL;\n        document.body.appendChild(iframe2);\n      }, iframe2URL);\n\n      // Wait for iframe2 to load\n      await ctx.page.waitForFrame(iframe2URL);\n      const iframe2 = frame.childFrames()[0];\n      // Record iframe2\n      await injectRecordScript(iframe2);\n\n      await waitForRAF(iframe2);\n      const snapshots = (await ctx.page.evaluate(\n        'window.snapshots',\n      )) as eventWithTime[];\n      assertSnapshot(snapshots);\n    });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"","suites":["cross origin iframes","blank.html","should support packFn option in record()"],"updatePoint":{"line":567,"column":10},"line":567,"code":"      it('', async () => {\n        const frame = ctx.page.mainFrame().childFrames()[0];\n        await waitForRAF(frame);\n        const packedSnapshots = (await ctx.page.evaluate(\n          'window.snapshots',\n        )) as string[];\n        const unpackedSnapshots = packedSnapshots.map((packed) =>\n          unpack(packed),\n        ) as eventWithTime[];\n        assertSnapshot(unpackedSnapshots);\n      });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should emit contents of iframe once","suites":["same origin iframes"],"updatePoint":{"line":597,"column":41},"line":597,"code":"  it('should emit contents of iframe once', async () => {\n    const events = await ctx.page.evaluate(\n      () => (window as unknown as IWindow).snapshots,\n    );\n    await waitForRAF(ctx.page);\n    // two events (full snapshot + meta) from main frame,\n    // and two (full snapshot + mutation) from iframe\n    expect(events.length).toBe(4);\n    assertSnapshot(events);\n  });","file":"record/cross-origin-iframes.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"triggers for errors from insertRule","suites":["error-handler","CSSStyleSheet.prototype"],"updatePoint":{"line":93,"column":43},"line":93,"code":"    it('triggers for errors from insertRule', async () => {\n      await ctx.page.evaluate(() => {\n        // @ts-ignore rewrite this to something buggy\n        window.CSSStyleSheet.prototype.insertRule = function () {\n          // @ts-ignore\n          window.doSomethingWrong();\n        };\n      });\n\n      await ctx.page.evaluate(() => {\n        const { record } = (window as unknown as IWindow).rrweb;\n        record({\n          errorHandler: (error) => {\n            document.getElementById('out')!.innerText = `${error}`;\n          },\n          emit: (window as unknown as IWindow).emit,\n        });\n\n        // Trigger buggy style sheet insert\n        setTimeout(() => {\n          // @ts-ignore\n          document.styleSheets[0].insertRule('body { background: blue; }');\n        }, 50);\n      });\n\n      await ctx.page.waitForTimeout(100);\n\n      const element = await ctx.page.$('#out');\n      const text = await element!.evaluate((el) => el.textContent);\n\n      expect(text).toEqual(\n        'TypeError: window.doSomethingWrong is not a function',\n      );\n    });","file":"record/error-handler.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"triggers for errors from deleteRule","suites":["error-handler","CSSStyleSheet.prototype"],"updatePoint":{"line":128,"column":43},"line":128,"code":"    it('triggers for errors from deleteRule', async () => {\n      await ctx.page.evaluate(() => {\n        // @ts-ignore rewrite this to something buggy\n        window.CSSStyleSheet.prototype.deleteRule = function () {\n          // @ts-ignore\n          window.doSomethingWrong();\n        };\n      });\n\n      await ctx.page.evaluate(() => {\n        const { record } = (window as unknown as IWindow).rrweb;\n        record({\n          errorHandler: (error) => {\n            document.getElementById('out')!.innerText = `${error}`;\n          },\n          emit: (window as unknown as IWindow).emit,\n        });\n\n        // Trigger buggy style sheet delete\n        setTimeout(() => {\n          document.styleSheets[0].deleteRule(0);\n        }, 50);\n      });\n\n      await ctx.page.waitForTimeout(100);\n\n      const element = await ctx.page.$('#out');\n      const text = await element!.evaluate((el) => el.textContent);\n\n      expect(text).toEqual(\n        'TypeError: window.doSomethingWrong is not a function',\n      );\n    });","file":"record/error-handler.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"triggers for errors from replace","suites":["error-handler","CSSStyleSheet.prototype"],"updatePoint":{"line":162,"column":40},"line":162,"code":"    it('triggers for errors from replace', async () => {\n      await ctx.page.evaluate(() => {\n        // @ts-ignore rewrite this to something buggy\n        window.CSSStyleSheet.prototype.replace = function () {\n          // @ts-ignore\n          window.doSomethingWrong();\n        };\n      });\n\n      await ctx.page.evaluate(() => {\n        const { record } = (window as unknown as IWindow).rrweb;\n        record({\n          errorHandler: (error) => {\n            document.getElementById('out')!.innerText = `${error}`;\n          },\n          emit: (window as unknown as IWindow).emit,\n        });\n\n        // Trigger buggy style sheet insert\n        setTimeout(() => {\n          // @ts-ignore\n          document.styleSheets[0].replace('body { background: blue; }');\n        }, 50);\n      });\n\n      await ctx.page.waitForTimeout(100);\n\n      const element = await ctx.page.$('#out');\n      const text = await element!.evaluate((el) => el.textContent);\n\n      expect(text).toEqual(\n        'TypeError: window.doSomethingWrong is not a function',\n      );\n    });","file":"record/error-handler.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"triggers for errors from replaceSync","suites":["error-handler","CSSStyleSheet.prototype"],"updatePoint":{"line":197,"column":44},"line":197,"code":"    it('triggers for errors from replaceSync', async () => {\n      await ctx.page.evaluate(() => {\n        // @ts-ignore rewrite this to something buggy\n        window.CSSStyleSheet.prototype.replaceSync = function () {\n          // @ts-ignore\n          window.doSomethingWrong();\n        };\n      });\n\n      await ctx.page.evaluate(() => {\n        const { record } = (window as unknown as IWindow).rrweb;\n        record({\n          errorHandler: (error) => {\n            document.getElementById('out')!.innerText = `${error}`;\n          },\n          emit: (window as unknown as IWindow).emit,\n        });\n\n        // Trigger buggy style sheet insert\n        setTimeout(() => {\n          // @ts-ignore\n          document.styleSheets[0].replaceSync('body { background: blue; }');\n        }, 50);\n      });\n\n      await ctx.page.waitForTimeout(100);\n\n      const element = await ctx.page.$('#out');\n      const text = await element!.evaluate((el) => el.textContent);\n\n      expect(text).toEqual(\n        'TypeError: window.doSomethingWrong is not a function',\n      );\n    });","file":"record/error-handler.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"triggers for errors from CSSGroupingRule.insertRule","suites":["error-handler","CSSStyleSheet.prototype"],"updatePoint":{"line":232,"column":59},"line":232,"code":"    it('triggers for errors from CSSGroupingRule.insertRule', async () => {\n      await ctx.page.evaluate(() => {\n        // @ts-ignore rewrite this to something buggy\n        window.CSSGroupingRule.prototype.insertRule = function () {\n          // @ts-ignore\n          window.doSomethingWrong();\n        };\n      });\n\n      await ctx.page.evaluate(() => {\n        const { record } = (window as unknown as IWindow).rrweb;\n        record({\n          errorHandler: (error) => {\n            document.getElementById('out')!.innerText = `${error}`;\n          },\n          emit: (window as unknown as IWindow).emit,\n        });\n\n        // Trigger buggy style sheet insert\n        setTimeout(() => {\n          document.styleSheets[0].insertRule('@media {}');\n          const atMediaRule = document.styleSheets[0]\n            .cssRules[0] as CSSMediaRule;\n\n          const ruleIdx0 = atMediaRule.insertRule(\n            'body { background: #000; }',\n            0,\n          );\n        }, 50);\n      });\n\n      await ctx.page.waitForTimeout(100);\n\n      const element = await ctx.page.$('#out');\n      const text = await element!.evaluate((el) => el.textContent);\n\n      expect(text).toEqual(\n        'TypeError: window.doSomethingWrong is not a function',\n      );\n    });","file":"record/error-handler.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"triggers for errors from CSSGroupingRule.deleteRule","suites":["error-handler","CSSStyleSheet.prototype"],"updatePoint":{"line":273,"column":59},"line":273,"code":"    it('triggers for errors from CSSGroupingRule.deleteRule', async () => {\n      await ctx.page.evaluate(() => {\n        // @ts-ignore rewrite this to something buggy\n        window.CSSGroupingRule.prototype.deleteRule = function () {\n          // @ts-ignore\n          window.doSomethingWrong();\n        };\n      });\n\n      await ctx.page.evaluate(() => {\n        const { record } = (window as unknown as IWindow).rrweb;\n        record({\n          errorHandler: (error) => {\n            document.getElementById('out')!.innerText = `${error}`;\n          },\n          emit: (window as unknown as IWindow).emit,\n        });\n\n        // Trigger buggy style sheet delete\n        setTimeout(() => {\n          document.styleSheets[0].insertRule('@media {}');\n          const atMediaRule = document.styleSheets[0]\n            .cssRules[0] as CSSMediaRule;\n\n          const ruleIdx0 = atMediaRule.deleteRule(0);\n        }, 50);\n      });\n\n      await ctx.page.waitForTimeout(100);\n\n      const element = await ctx.page.$('#out');\n      const text = await element!.evaluate((el) => el.textContent);\n\n      expect(text).toEqual(\n        'TypeError: window.doSomethingWrong is not a function',\n      );\n    });","file":"record/error-handler.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"triggers for errors from CSSStyleDeclaration.setProperty","suites":["error-handler","CSSStyleSheet.prototype"],"updatePoint":{"line":311,"column":64},"line":311,"code":"    it('triggers for errors from CSSStyleDeclaration.setProperty', async () => {\n      await ctx.page.evaluate(() => {\n        // @ts-ignore rewrite this to something buggy\n        window.CSSStyleDeclaration.prototype.setProperty = function () {\n          // @ts-ignore\n          window.doSomethingWrong();\n        };\n      });\n\n      await ctx.page.evaluate(() => {\n        const { record } = (window as unknown as IWindow).rrweb;\n        record({\n          errorHandler: (error) => {\n            document.getElementById('out')!.innerText = `${error}`;\n          },\n          emit: (window as unknown as IWindow).emit,\n        });\n\n        // Trigger buggy style sheet insert\n        setTimeout(() => {\n          (\n            document.styleSheets[0].cssRules[0] as unknown as {\n              style: CSSStyleDeclaration;\n            }\n          ).style.setProperty('background', 'blue');\n        }, 50);\n      });\n\n      await ctx.page.waitForTimeout(100);\n\n      const element = await ctx.page.$('#out');\n      const text = await element!.evaluate((el) => el.textContent);\n\n      expect(text).toEqual(\n        'TypeError: window.doSomethingWrong is not a function',\n      );\n    });","file":"record/error-handler.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"triggers for errors from CSSStyleDeclaration.removeProperty","suites":["error-handler","CSSStyleSheet.prototype"],"updatePoint":{"line":349,"column":67},"line":349,"code":"    it('triggers for errors from CSSStyleDeclaration.removeProperty', async () => {\n      await ctx.page.evaluate(() => {\n        // @ts-ignore rewrite this to something buggy\n        window.CSSStyleDeclaration.prototype.removeProperty = function () {\n          // @ts-ignore\n          window.doSomethingWrong();\n        };\n      });\n\n      await ctx.page.evaluate(() => {\n        const { record } = (window as unknown as IWindow).rrweb;\n        record({\n          errorHandler: (error) => {\n            document.getElementById('out')!.innerText = `${error}`;\n          },\n          emit: (window as unknown as IWindow).emit,\n        });\n\n        // Trigger buggy style sheet insert\n        setTimeout(() => {\n          (\n            document.styleSheets[0].cssRules[0] as unknown as {\n              style: CSSStyleDeclaration;\n            }\n          ).style.removeProperty('background');\n        }, 50);\n      });\n\n      await ctx.page.waitForTimeout(100);\n\n      const element = await ctx.page.$('#out');\n      const text = await element!.evaluate((el) => el.textContent);\n\n      expect(text).toEqual(\n        'TypeError: window.doSomethingWrong is not a function',\n      );\n    });","file":"record/error-handler.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"triggers for errors from mutation observer","suites":["error-handler","CSSStyleSheet.prototype"],"updatePoint":{"line":388,"column":48},"line":388,"code":"  it('triggers for errors from mutation observer', async () => {\n    await ctx.page.evaluate(() => {\n      const { record } = (window as unknown as IWindow).rrweb;\n      record({\n        errorHandler: (error) => {\n          document.getElementById('out')!.innerText = `${error}`;\n        },\n        emit: (window as unknown as IWindow).emit,\n      });\n\n      // Trigger buggy mutation observer\n      setTimeout(() => {\n        const el = document.getElementById('in')!;\n\n        // @ts-ignore we want to trigger an error in the mutation observer, which uses this\n        el.getAttribute = undefined;\n\n        el.setAttribute('data-attr', 'new');\n      }, 50);\n    });\n\n    await ctx.page.waitForTimeout(100);\n\n    const element = await ctx.page.$('#out');\n    const text = await element!.evaluate((el) => el.textContent);\n\n    expect(text).toEqual('TypeError: m.target.getAttribute is not a function');\n  });","file":"record/error-handler.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"does not swallow if no errorHandler set","suites":["errorHandler unit"],"updatePoint":{"line":423,"column":45},"line":423,"code":"  it('does not swallow if no errorHandler set', () => {\n    unregisterErrorHandler();\n\n    const wrapped = callbackWrapper(() => {\n      throw new Error('test');\n    });\n\n    expect(() => wrapped()).toThrowError('test');\n  });","file":"record/error-handler.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"does not swallow if errorHandler returns void","suites":["errorHandler unit"],"updatePoint":{"line":433,"column":51},"line":433,"code":"  it('does not swallow if errorHandler returns void', () => {\n    registerErrorHandler(() => {\n      // do nothing\n    });\n\n    const wrapped = callbackWrapper(() => {\n      throw new Error('test');\n    });\n\n    expect(() => wrapped()).toThrowError('test');\n  });","file":"record/error-handler.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"does not swallow if errorHandler returns false","suites":["errorHandler unit"],"updatePoint":{"line":445,"column":52},"line":445,"code":"  it('does not swallow if errorHandler returns false', () => {\n    registerErrorHandler(() => {\n      return false;\n    });\n\n    const wrapped = callbackWrapper(() => {\n      throw new Error('test');\n    });\n\n    expect(() => wrapped()).toThrowError('test');\n  });","file":"record/error-handler.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"swallows if errorHandler returns true","suites":["errorHandler unit"],"updatePoint":{"line":457,"column":43},"line":457,"code":"  it('swallows if errorHandler returns true', () => {\n    registerErrorHandler(() => {\n      return true;\n    });\n\n    const wrapped = callbackWrapper(() => {\n      throw new Error('test');\n    });\n\n    expect(() => wrapped()).not.toThrowError('test');\n  });","file":"record/error-handler.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize Float32Array values","suites":["serializeArg"],"updatePoint":{"line":19,"column":42},"line":19,"code":"  it('should serialize Float32Array values', async () => {\n    const float32Array = new Float32Array([-1, -1, 3, -1, -1, 3]);\n    const expected = {\n      rr_type: 'Float32Array',\n      args: [[-1, -1, 3, -1, -1, 3]],\n    };\n    expect(serializeArg(float32Array, window, context)).toStrictEqual(expected);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize Float64Array values","suites":["serializeArg"],"updatePoint":{"line":28,"column":42},"line":28,"code":"  it('should serialize Float64Array values', async () => {\n    const float64Array = new Float64Array([-1, -1, 3, -1, -1, 3]);\n    const expected = {\n      rr_type: 'Float64Array',\n      args: [[-1, -1, 3, -1, -1, 3]],\n    };\n\n    expect(serializeArg(float64Array, window, context)).toStrictEqual(expected);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize ArrayBuffer values","suites":["serializeArg"],"updatePoint":{"line":38,"column":41},"line":38,"code":"  it('should serialize ArrayBuffer values', async () => {\n    const arrayBuffer = new Uint8Array([1, 2, 0, 4]).buffer;\n    const expected = {\n      rr_type: 'ArrayBuffer',\n      base64: 'AQIABA==',\n    };\n\n    expect(serializeArg(arrayBuffer, window, context)).toStrictEqual(expected);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize Uint8Array values","suites":["serializeArg"],"updatePoint":{"line":48,"column":40},"line":48,"code":"  it('should serialize Uint8Array values', async () => {\n    const object = new Uint8Array([1, 2, 0, 4]);\n    const expected = {\n      rr_type: 'Uint8Array',\n      args: [[1, 2, 0, 4]],\n    };\n\n    expect(serializeArg(object, window, context)).toStrictEqual(expected);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize DataView values","suites":["serializeArg"],"updatePoint":{"line":58,"column":38},"line":58,"code":"  it('should serialize DataView values', async () => {\n    const dataView = new DataView(new ArrayBuffer(16), 0, 16);\n    const expected = {\n      rr_type: 'DataView',\n      args: [\n        {\n          rr_type: 'ArrayBuffer',\n          base64: 'AAAAAAAAAAAAAAAAAAAAAA==',\n        },\n        0,\n        16,\n      ],\n    };\n\n    expect(serializeArg(dataView, window, context)).toStrictEqual(expected);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should leave arrays intact","suites":["serializeArg"],"updatePoint":{"line":75,"column":32},"line":75,"code":"  it('should leave arrays intact', async () => {\n    const array = [1, 2, 3, 4];\n    expect(serializeArg(array, window, context)).toStrictEqual(array);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize complex objects","suites":["serializeArg"],"updatePoint":{"line":80,"column":38},"line":80,"code":"  it('should serialize complex objects', async () => {\n    const dataView = [new DataView(new ArrayBuffer(16), 0, 16), 5, 6];\n    const expected = [\n      {\n        rr_type: 'DataView',\n        args: [\n          {\n            rr_type: 'ArrayBuffer',\n            base64: 'AAAAAAAAAAAAAAAAAAAAAA==',\n          },\n          0,\n          16,\n        ],\n      },\n      5,\n      6,\n    ];\n\n    expect(serializeArg(dataView, window, context)).toStrictEqual(expected);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize arraybuffer contents","suites":["serializeArg"],"updatePoint":{"line":101,"column":43},"line":101,"code":"  it('should serialize arraybuffer contents', async () => {\n    const buffer = new Float32Array([1, 2, 3, 4]).buffer;\n    const expected = {\n      rr_type: 'ArrayBuffer',\n      base64: 'AACAPwAAAEAAAEBAAACAQA==',\n    };\n\n    expect(serializeArg(buffer, window, context)).toStrictEqual(expected);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should leave null as-is","suites":["serializeArg"],"updatePoint":{"line":111,"column":29},"line":111,"code":"  it('should leave null as-is', async () => {\n    expect(serializeArg(null, window, context)).toStrictEqual(null);\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should support indexed variables","suites":["serializeArg"],"updatePoint":{"line":115,"column":38},"line":115,"code":"  it('should support indexed variables', async () => {\n    const webGLProgram = new WebGLProgram();\n    expect(serializeArg(webGLProgram, window, context)).toStrictEqual({\n      rr_type: 'WebGLProgram',\n      index: 0,\n    });\n    const webGLProgram2 = new WebGLProgram();\n    expect(serializeArg(webGLProgram2, window, context)).toStrictEqual({\n      rr_type: 'WebGLProgram',\n      index: 1,\n    });\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should support indexed variables grouped by context","suites":["serializeArg"],"updatePoint":{"line":128,"column":57},"line":128,"code":"  it('should support indexed variables grouped by context', async () => {\n    const context1 = createContext();\n    const webGLProgram1 = new WebGLProgram();\n    expect(serializeArg(webGLProgram1, window, context1)).toStrictEqual({\n      rr_type: 'WebGLProgram',\n      index: 0,\n    });\n    const context2 = createContext();\n    const webGLProgram2 = new WebGLProgram();\n    expect(serializeArg(webGLProgram2, window, context2)).toStrictEqual({\n      rr_type: 'WebGLProgram',\n      index: 0,\n    });\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should support HTMLImageElements","suites":["serializeArg"],"updatePoint":{"line":143,"column":38},"line":143,"code":"  it('should support HTMLImageElements', async () => {\n    const image = new Image();\n    image.src = 'http://example.com/image.png';\n    expect(serializeArg(image, window, context)).toStrictEqual({\n      rr_type: 'HTMLImageElement',\n      src: 'http://example.com/image.png',\n    });\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should support HTMLCanvasElements saved to image","suites":["serializeArg"],"updatePoint":{"line":152,"column":54},"line":152,"code":"  it('should support HTMLCanvasElements saved to image', async () => {\n    const canvas = document.createElement('canvas');\n    // polyfill canvas.toDataURL as it doesn't exist in jsdom\n    canvas.toDataURL = () => 'data:image/png;base64,...';\n    expect(serializeArg(canvas, window, context)).toMatchObject({\n      rr_type: 'HTMLImageElement',\n      src: 'data:image/png;base64,...',\n    });\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize ImageData","suites":["serializeArg"],"updatePoint":{"line":162,"column":32},"line":162,"code":"  it('should serialize ImageData', async () => {\n    const arr = new Uint8ClampedArray(40000);\n\n    // Iterate through every pixel\n    for (let i = 0; i < arr.length; i += 4) {\n      arr[i + 0] = 0; // R value\n      arr[i + 1] = 190; // G value\n      arr[i + 2] = 0; // B value\n      arr[i + 3] = 255; // A value\n    }\n\n    // Initialize a new ImageData object\n    let imageData = new ImageData(arr, 200, 50);\n\n    const contents = Array.from(arr);\n    expect(serializeArg(imageData, window, context)).toStrictEqual({\n      rr_type: 'ImageData',\n      args: [\n        {\n          rr_type: 'Uint8ClampedArray',\n          args: [contents],\n        },\n        200,\n        50,\n      ],\n    });\n  });","file":"record/serialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should serialize a blob","suites":["serializeArg"],"line":191,"code":"  it.skip('should serialize a blob', async () => {","file":"record/serialize-args.test.ts","skipped":true,"dir":"packages/rrweb/test"},{"name":"will record changes to a canvas element","suites":["record webgl"],"updatePoint":{"line":104,"column":45},"line":104,"code":"  it('will record changes to a canvas element', async () => {\n    await ctx.page.evaluate(() => {\n      var canvas = document.getElementById('canvas') as HTMLCanvasElement;\n      var gl = canvas.getContext('webgl')!;\n\n      gl.clear(gl.COLOR_BUFFER_BIT);\n    });\n\n    await ctx.page.waitForTimeout(50);\n\n    const lastEvent = ctx.events[ctx.events.length - 1];\n    expect(lastEvent).toMatchObject({\n      data: {\n        source: IncrementalSource.CanvasMutation,\n        type: CanvasContext.WebGL,\n        commands: [\n          {\n            args: [16384],\n            property: 'clear',\n          },\n        ],\n      },\n    });\n    assertSnapshot(ctx.events);\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will record changes to a webgl2 canvas element","suites":["record webgl"],"updatePoint":{"line":130,"column":52},"line":130,"code":"  it('will record changes to a webgl2 canvas element', async () => {\n    await ctx.page.evaluate(() => {\n      var canvas = document.getElementById('canvas') as HTMLCanvasElement;\n      var gl = canvas.getContext('webgl2')!;\n\n      gl.clear(gl.COLOR_BUFFER_BIT);\n    });\n\n    await ctx.page.waitForTimeout(50);\n\n    const lastEvent = ctx.events[ctx.events.length - 1];\n    expect(lastEvent).toMatchObject({\n      data: {\n        source: IncrementalSource.CanvasMutation,\n        type: CanvasContext.WebGL2,\n        commands: [\n          {\n            args: [16384],\n            property: 'clear',\n          },\n        ],\n      },\n    });\n    assertSnapshot(ctx.events);\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will record changes to a canvas element before the canvas gets added","suites":["record webgl"],"updatePoint":{"line":156,"column":74},"line":156,"code":"  it('will record changes to a canvas element before the canvas gets added', async () => {\n    await ctx.page.evaluate(() => {\n      var canvas = document.createElement('canvas');\n      var gl = canvas.getContext('webgl')!;\n      var program = gl.createProgram()!;\n      gl.linkProgram(program);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      document.body.appendChild(canvas);\n    });\n\n    await waitForRAF(ctx.page);\n\n    assertSnapshot(ctx.events);\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will record changes to a canvas element before the canvas gets added (webgl2)","suites":["record webgl"],"updatePoint":{"line":171,"column":83},"line":171,"code":"  it('will record changes to a canvas element before the canvas gets added (webgl2)', async () => {\n    await ctx.page.evaluate(() => {\n      return new Promise<void>((resolve) => {\n        var canvas = document.createElement('canvas');\n        var gl = canvas.getContext('webgl2')!;\n        var program = gl.createProgram()!;\n        gl.linkProgram(program);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        setTimeout(() => {\n          document.body.appendChild(canvas);\n          resolve();\n        }, 10);\n      });\n    });\n\n    // FIXME: this wait deeply couples the test to the implementation\n    // When `pendingCanvasMutations` isn't run on requestAnimationFrame,\n    // we need to change this\n    await waitForRAF(ctx.page);\n\n    assertSnapshot(ctx.events);\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will record webgl variables","suites":["record webgl"],"updatePoint":{"line":194,"column":33},"line":194,"code":"  it('will record webgl variables', async () => {\n    await ctx.page.evaluate(() => {\n      var canvas = document.getElementById('canvas') as HTMLCanvasElement;\n      var gl = canvas.getContext('webgl')!;\n      var program0 = gl.createProgram()!;\n      gl.linkProgram(program0);\n      var program1 = gl.createProgram()!;\n      gl.linkProgram(program1);\n    });\n\n    await ctx.page.waitForTimeout(50);\n\n    assertSnapshot(ctx.events);\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will record webgl variables in reverse order","suites":["record webgl"],"updatePoint":{"line":209,"column":50},"line":209,"code":"  it('will record webgl variables in reverse order', async () => {\n    await ctx.page.evaluate(() => {\n      var canvas = document.getElementById('canvas') as HTMLCanvasElement;\n      var gl = canvas.getContext('webgl')!;\n      var program0 = gl.createProgram()!;\n      var program1 = gl.createProgram()!;\n      // attach them in reverse order\n      gl.linkProgram(program1);\n      gl.linkProgram(program0);\n    });\n\n    await ctx.page.waitForTimeout(50);\n\n    assertSnapshot(ctx.events);\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"sets _context on canvas.getContext()","suites":["record webgl"],"updatePoint":{"line":225,"column":42},"line":225,"code":"  it('sets _context on canvas.getContext()', async () => {\n    const context = await ctx.page.evaluate(() => {\n      var canvas = document.getElementById('canvas') as HTMLCanvasElement;\n      canvas.getContext('webgl')!;\n      return (canvas as ICanvas).__context;\n    });\n\n    expect(context).toBe('webgl');\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"only sets _context on first canvas.getContext() call","suites":["record webgl"],"updatePoint":{"line":235,"column":58},"line":235,"code":"  it('only sets _context on first canvas.getContext() call', async () => {\n    const context = await ctx.page.evaluate(() => {\n      var canvas = document.getElementById('canvas') as HTMLCanvasElement;\n      canvas.getContext('webgl');\n      canvas.getContext('2d'); // returns null\n      return (canvas as ICanvas).__context;\n    });\n\n    expect(context).toBe('webgl');\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should batch events by RAF","suites":["record webgl"],"updatePoint":{"line":246,"column":32},"line":246,"code":"  it('should batch events by RAF', async () => {\n    await ctx.page.evaluate(() => {\n      return new Promise<void>((resolve) => {\n        const canvas = document.getElementById('canvas') as HTMLCanvasElement;\n        const gl = canvas.getContext('webgl') as WebGLRenderingContext;\n        const program = gl.createProgram()!;\n        gl.linkProgram(program);\n        requestAnimationFrame(() => {\n          const program2 = gl.createProgram()!;\n          gl.linkProgram(program2);\n          gl.clear(gl.COLOR_BUFFER_BIT);\n          requestAnimationFrame(() => {\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            resolve();\n          });\n        });\n      });\n    });\n\n    await ctx.page.waitForTimeout(50);\n\n    assertSnapshot(ctx.events);\n    expect(ctx.events.length).toEqual(5);\n  });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should record snapshots","suites":["record webgl","recordCanvas FPS"],"updatePoint":{"line":289,"column":31},"line":289,"code":"    it('should record snapshots', async () => {\n      await ctx.page.evaluate(() => {\n        const canvas = document.getElementById('canvas') as HTMLCanvasElement;\n        const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true })!;\n        // Set the clear color to darkish green.\n        gl.clearColor(0.0, 0.5, 0.0, 1.0);\n        // Clear the context with the newly set color. This is\n        // the function call that actually does the drawing.\n        gl.clear(gl.COLOR_BUFFER_BIT);\n      });\n\n      await ctx.page.waitForTimeout(200); // give it some time buffer\n\n      await ctx.page.evaluate(() => {\n        const canvas = document.getElementById('canvas') as HTMLCanvasElement;\n        const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true })!;\n        // Set the clear color to darkish blue.\n        gl.clearColor(0.0, 0.0, 0.5, 1.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n      });\n\n      await ctx.page.waitForTimeout(200);\n\n      await waitForRAF(ctx.page);\n\n      // should yield a frame for each change at a max of 60fps\n      assertSnapshot(stripBase64(ctx.events));\n    });","file":"record/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should execute all mutations after args are parsed","suites":["canvas2DMutation"],"updatePoint":{"line":22,"column":56},"line":22,"code":"  it('should execute all mutations after args are parsed', async () => {\n    let resolve: (value: unknown) => void;\n    const promise = new Promise((r) => {\n      resolve = r;\n    });\n    const context = {\n      clearRect: jest.fn(),\n      drawImage: jest.fn(),\n    } as unknown as CanvasRenderingContext2D;\n    jest.spyOn(canvas, 'getContext').mockImplementation(() => {\n      return context;\n    });\n\n    const createImageBitmapMock = jest.fn(() => {\n      return new Promise((r) => {\n        setTimeout(r, 1000);\n      });\n    });\n\n    (global as any).createImageBitmap = createImageBitmapMock;\n\n    const mutation = canvas2DMutation({\n      event: {} as Parameters<Replayer['applyIncremental']>[0],\n      mutations: [\n        {\n          property: 'clearRect',\n          args: [0, 0, 1000, 1000],\n        },\n        {\n          property: 'drawImage',\n          args: [\n            {\n              rr_type: 'ImageBitmap',\n              args: [],\n            },\n            0,\n            0,\n          ],\n        },\n      ],\n      target: canvas,\n      imageMap: new Map(),\n      errorHandler: () => {},\n    });\n\n    await jest.advanceTimersByTimeAsync(100);\n\n    await expect(createImageBitmapMock).toHaveBeenCalled();\n\n    expect(context.clearRect).not.toBeCalled();\n    expect(context.drawImage).not.toBeCalled();\n\n    await jest.advanceTimersByTimeAsync(1000);\n\n    await mutation;\n\n    expect(context.clearRect).toHaveBeenCalledWith(0, 0, 1000, 1000);\n    expect(context.drawImage).toHaveBeenCalled();\n  });","file":"replay/2d-mutation.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should deserialize Float32Array values","suites":["deserializeArg"],"updatePoint":{"line":14,"column":44},"line":14,"code":"  it('should deserialize Float32Array values', async () => {\n    expect(\n      await deserializeArg(\n        new Map(),\n        context,\n      )({\n        rr_type: 'Float32Array',\n        args: [[-1, -1, 3, -1, -1, 3]],\n      }),\n    ).toEqual(new Float32Array([-1, -1, 3, -1, -1, 3]));\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should deserialize Float64Array values","suites":["deserializeArg"],"updatePoint":{"line":26,"column":44},"line":26,"code":"  it('should deserialize Float64Array values', async () => {\n    expect(\n      await deserializeArg(\n        new Map(),\n        context,\n      )({\n        rr_type: 'Float64Array',\n        args: [[-1, -1, 3, -1, -1, 3]],\n      }),\n    ).toEqual(new Float64Array([-1, -1, 3, -1, -1, 3]));\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should deserialize ArrayBuffer values","suites":["deserializeArg"],"updatePoint":{"line":38,"column":43},"line":38,"code":"  it('should deserialize ArrayBuffer values', async () => {\n    const contents = [1, 2, 0, 4];\n    expect(\n      await deserializeArg(\n        new Map(),\n        context,\n      )({\n        rr_type: 'ArrayBuffer',\n        base64: 'AQIABA==',\n      }),\n    ).toStrictEqual(new Uint8Array(contents).buffer);\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should deserialize DataView values","suites":["deserializeArg"],"updatePoint":{"line":51,"column":40},"line":51,"code":"  it('should deserialize DataView values', async () => {\n    expect(\n      await deserializeArg(\n        new Map(),\n        context,\n      )({\n        rr_type: 'DataView',\n        args: [\n          {\n            rr_type: 'ArrayBuffer',\n            base64: 'AAAAAAAAAAAAAAAAAAAAAA==',\n          },\n          0,\n          16,\n        ],\n      }),\n    ).toStrictEqual(new DataView(new ArrayBuffer(16), 0, 16));\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should leave arrays intact","suites":["deserializeArg"],"updatePoint":{"line":70,"column":32},"line":70,"code":"  it('should leave arrays intact', async () => {\n    const array = [1, 2, 3, 4];\n    expect(await deserializeArg(new Map(), context)(array)).toEqual(array);\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should deserialize complex objects","suites":["deserializeArg"],"updatePoint":{"line":75,"column":40},"line":75,"code":"  it('should deserialize complex objects', async () => {\n    const serializedArg = [\n      {\n        rr_type: 'DataView',\n        args: [\n          {\n            rr_type: 'ArrayBuffer',\n            args: [16],\n          },\n          0,\n          16,\n        ],\n      },\n      5,\n      6,\n    ];\n    expect(\n      await deserializeArg(new Map(), context)(serializedArg),\n    ).toStrictEqual([new DataView(new ArrayBuffer(16), 0, 16), 5, 6]);\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should leave null as-is","suites":["deserializeArg"],"updatePoint":{"line":96,"column":29},"line":96,"code":"  it('should leave null as-is', async () => {\n    expect(await deserializeArg(new Map(), context)(null)).toStrictEqual(null);\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should support HTMLImageElements","suites":["deserializeArg"],"updatePoint":{"line":100,"column":38},"line":100,"code":"  it('should support HTMLImageElements', async () => {\n    const image = new Image();\n    image.src = 'http://example.com/image.png';\n    expect(\n      await deserializeArg(\n        new Map(),\n        context,\n      )({\n        rr_type: 'HTMLImageElement',\n        src: 'http://example.com/image.png',\n      }),\n    ).toStrictEqual(image);\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should return image from imageMap for HTMLImageElements","suites":["deserializeArg"],"updatePoint":{"line":114,"column":61},"line":114,"code":"  it('should return image from imageMap for HTMLImageElements', async () => {\n    const image = new Image();\n    image.src = 'http://example.com/image.png';\n    const imageMap = new Map();\n    imageMap.set(image.src, image);\n\n    expect(\n      await deserializeArg(\n        imageMap,\n        context,\n      )({\n        rr_type: 'HTMLImageElement',\n        src: 'http://example.com/image.png',\n      }),\n    ).toBe(image);\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should support blobs","suites":["deserializeArg"],"updatePoint":{"line":131,"column":26},"line":131,"code":"  it('should support blobs', async () => {\n    const arrayBuffer = new Uint8Array([1, 2, 0, 4]).buffer;\n    const expected = new Blob([arrayBuffer], { type: 'image/png' });\n\n    const deserialized = await deserializeArg(\n      new Map(),\n      context,\n    )({\n      rr_type: 'Blob',\n      data: [\n        {\n          rr_type: 'ArrayBuffer',\n          base64: 'AQIABA==',\n        },\n      ],\n      type: 'image/png',\n    });\n\n    // `expect(blob).toEqual(otherBlob)` doesn't really do anything yet\n    // jest hasn't implemented a propper way to compare blobs\n    // more info: https://github.com/facebook/jest/issues/7372\n    // because JSDOM doesn't support most functions needed for comparison:\n    // more info: https://github.com/jsdom/jsdom/issues/2555\n    expect(deserialized).toEqual(expected);\n    // thats why we test size of the blob as well\n    expect(deserialized.size).toEqual(expected.size);\n  });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should set isUnchanged:true when non of the args are changed","suites":["deserializeArg","isUnchanged"],"updatePoint":{"line":160,"column":68},"line":160,"code":"    it('should set isUnchanged:true when non of the args are changed', async () => {\n      const status = {\n        isUnchanged: true,\n      };\n\n      await deserializeArg(new Map(), context, status)(true);\n      expect(status.isUnchanged).toBeTruthy();\n    });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should set isUnchanged: false when args are deserialzed","suites":["deserializeArg","isUnchanged"],"updatePoint":{"line":169,"column":63},"line":169,"code":"    it('should set isUnchanged: false when args are deserialzed', async () => {\n      const status = {\n        isUnchanged: true,\n      };\n\n      await deserializeArg(\n        new Map(),\n        context,\n        status,\n      )({\n        rr_type: 'Float64Array',\n        args: [[-1, -1, 3, -1, -1, 3]],\n      });\n      expect(status.isUnchanged).toBeFalsy();\n    });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should set isUnchanged: false when nested args are deserialzed","suites":["deserializeArg","isUnchanged"],"updatePoint":{"line":185,"column":70},"line":185,"code":"    it('should set isUnchanged: false when nested args are deserialzed', async () => {\n      const status = {\n        isUnchanged: true,\n      };\n\n      await deserializeArg(\n        new Map(),\n        context,\n        status,\n      )([\n        {\n          rr_type: 'Float64Array',\n          args: [[-1, -1, 3, -1, -1, 3]],\n        },\n      ]);\n      expect(status.isUnchanged).toBeFalsy();\n    });","file":"replay/deserialize-args.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should trigger hover on mouseDown","suites":["replayer","hover"],"updatePoint":{"line":58,"column":41},"line":58,"code":"    it('should trigger hover on mouseDown', async () => {\n      await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(110); // mouseDown event is at 100\n    `);\n\n      await waitForRAF(page);\n\n      const image = await page.screenshot();\n      expect(image).toMatchImageSnapshot({\n        failureThreshold: 40,\n      });\n    });","file":"replay/hover.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should preload image","suites":["preloadAllImages"],"updatePoint":{"line":48,"column":26},"line":48,"code":"  it('should preload image', () => {\n    replayer.service.state.context.events = [\n      canvasMutationEventWithArgs([\n        {\n          rr_type: 'HTMLImageElement',\n          src: 'http://example.com',\n        },\n      ]),\n    ];\n\n    (replayer as any).preloadAllImages();\n\n    const expectedImage = new Image();\n    expectedImage.src = 'http://example.com';\n    expect((replayer as any).imageMap.get('http://example.com')).toEqual(\n      expectedImage,\n    );\n  });","file":"replay/preload-all-images.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should preload nested image","suites":["preloadAllImages"],"updatePoint":{"line":67,"column":33},"line":67,"code":"  it('should preload nested image', async () => {\n    replayer.service.state.context.events = [\n      canvasMutationEventWithArgs([\n        {\n          rr_type: 'Array',\n          args: [\n            {\n              rr_type: 'HTMLImageElement',\n              src: 'http://example.com',\n            },\n          ],\n        },\n      ]),\n    ];\n\n    await (replayer as any).preloadAllImages();\n\n    const expectedImage = new Image();\n    expectedImage.src = 'http://example.com';\n\n    expect((replayer as any).imageMap.get('http://example.com')).toEqual(\n      expectedImage,\n    );\n  });","file":"replay/preload-all-images.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should preload multiple images","suites":["preloadAllImages"],"updatePoint":{"line":92,"column":36},"line":92,"code":"  it('should preload multiple images', () => {\n    replayer.service.state.context.events = [\n      canvasMutationEventWithArgs([\n        {\n          rr_type: 'HTMLImageElement',\n          src: 'http://example.com/img1.png',\n        },\n        {\n          rr_type: 'HTMLImageElement',\n          src: 'http://example.com/img2.png',\n        },\n      ]),\n    ];\n\n    (replayer as any).preloadAllImages();\n\n    const expectedImage1 = new Image();\n    expectedImage1.src = 'http://example.com/img1.png';\n\n    expect(\n      (replayer as any).imageMap.get('http://example.com/img1.png'),\n    ).toEqual(expectedImage1);\n\n    const expectedImage2 = new Image();\n    expectedImage1.src = 'http://example.com/img2.png';\n\n    expect(\n      (replayer as any).imageMap.get('http://example.com/img2.png'),\n    ).toEqual(expectedImage1);\n  });","file":"replay/preload-all-images.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should create webgl variables","suites":["webglMutation"],"updatePoint":{"line":21,"column":35},"line":21,"code":"  it('should create webgl variables', async () => {\n    const createShaderMock = jest.fn().mockImplementation(() => {\n      return new WebGLShader();\n    });\n    const context = {\n      createShader: createShaderMock,\n    } as unknown as WebGLRenderingContext;\n    jest.spyOn(canvas, 'getContext').mockImplementation(() => {\n      return context;\n    });\n\n    expect(variableListFor(context, 'WebGLShader')).toHaveLength(0);\n\n    await webglMutation({\n      mutation: {\n        property: 'createShader',\n        args: [35633],\n      },\n      type: CanvasContext.WebGL,\n      target: canvas,\n      imageMap: new Map(),\n      errorHandler: () => {},\n    });\n\n    expect(createShaderMock).toHaveBeenCalledWith(35633);\n    expect(variableListFor(context, 'WebGLShader')).toHaveLength(1);\n  });","file":"replay/webgl-mutation.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should output simple webgl object","suites":["replayer","webgl"],"updatePoint":{"line":53,"column":41},"line":53,"code":"    it('should output simple webgl object', async () => {\n      await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events, {\n        UNSAFE_replayCanvas: true,\n      });\n      replayer.play(2500);\n    `);\n\n      const image = await page.screenshot();\n      expect(image).toMatchImageSnapshot();\n    });","file":"replay/webgl.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can get meta data","suites":["replayer"],"updatePoint":{"line":67,"column":23},"line":67,"code":"  it('can get meta data', async () => {\n    const meta = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.getMetaData();\n    `);\n    expect(meta).toEqual({\n      startTime: events[0].timestamp,\n      endTime: events[events.length - 1].timestamp,\n      totalTime: events[events.length - 1].timestamp - events[0].timestamp,\n    });\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will start actions when play","suites":["replayer"],"updatePoint":{"line":80,"column":34},"line":80,"code":"  it('will start actions when play', async () => {\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.play();\n      replayer['timer']['actions'].length;\n    `);\n    expect(actionLength).toEqual(events.length);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"will clean actions when pause","suites":["replayer"],"updatePoint":{"line":90,"column":35},"line":90,"code":"  it('will clean actions when pause', async () => {\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.play();\n      replayer.pause();\n      replayer['timer']['actions'].length;\n    `);\n    expect(actionLength).toEqual(0);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can play at any time offset","suites":["replayer"],"updatePoint":{"line":101,"column":33},"line":101,"code":"  it('can play at any time offset', async () => {\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.play(1500);\n      replayer['timer']['actions'].length;\n    `);\n    expect(actionLength).toEqual(\n      events.filter((e) => e.timestamp - events[0].timestamp >= 1500).length,\n    );\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can play a second time in the future","suites":["replayer"],"updatePoint":{"line":113,"column":42},"line":113,"code":"  it('can play a second time in the future', async () => {\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.play(500);\n      replayer.play(1500);\n      replayer['timer']['actions'].length;\n    `);\n    expect(actionLength).toEqual(\n      events.filter((e) => e.timestamp - events[0].timestamp >= 1500).length,\n    );\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can play a second time to the past","suites":["replayer"],"updatePoint":{"line":126,"column":40},"line":126,"code":"  it('can play a second time to the past', async () => {\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.play(1500);\n      replayer.play(500);\n      replayer['timer']['actions'].length;\n    `);\n    expect(actionLength).toEqual(\n      events.filter((e) => e.timestamp - events[0].timestamp >= 500).length,\n    );\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can pause at any time offset","suites":["replayer"],"updatePoint":{"line":139,"column":34},"line":139,"code":"  it('can pause at any time offset', async () => {\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(2500);\n      replayer['timer']['actions'].length;\n    `);\n    const currentTime = await page.evaluate(`\n      replayer.getCurrentTime();\n    `);\n    const currentState = await page.evaluate(`\n      replayer['service']['state']['value'];\n    `);\n    expect(actionLength).toEqual(0);\n    expect(currentTime).toEqual(2500);\n    expect(currentState).toEqual('paused');\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can fast forward past StyleSheetRule changes on virtual elements","suites":["replayer"],"updatePoint":{"line":157,"column":70},"line":157,"code":"  it('can fast forward past StyleSheetRule changes on virtual elements', async () => {\n    await page.evaluate(`events = ${JSON.stringify(styleSheetRuleEvents)}`);\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.play(1500);\n      replayer['timer']['actions'].length;\n    `);\n\n    expect(actionLength).toEqual(\n      styleSheetRuleEvents.filter(\n        (e) => e.timestamp - styleSheetRuleEvents[0].timestamp >= 1500,\n      ).length,\n    );\n\n    await assertDomSnapshot(page);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should apply fast forwarded StyleSheetRules that where added","suites":["replayer"],"updatePoint":{"line":175,"column":66},"line":175,"code":"  it('should apply fast forwarded StyleSheetRules that where added', async () => {\n    await page.evaluate(`events = ${JSON.stringify(styleSheetRuleEvents)}`);\n    const result = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(1500);\n      const rules = [...replayer.iframe.contentDocument.styleSheets].map(\n        (sheet) => [...sheet.rules],\n      ).flat();\n      rules.some((x) => x.selectorText === '.css-added-at-1000-deleted-at-2500');\n    `);\n\n    expect(result).toEqual(true);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can handle removing style elements","suites":["replayer"],"updatePoint":{"line":190,"column":40},"line":190,"code":"  it('can handle removing style elements', async () => {\n    await page.evaluate(`events = ${JSON.stringify(stylesheetRemoveEvents)}`);\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.play(2500);\n      replayer['timer']['actions'].length;\n    `);\n    expect(actionLength).toEqual(\n      stylesheetRemoveEvents.filter(\n        (e) => e.timestamp - stylesheetRemoveEvents[0].timestamp >= 2500,\n      ).length,\n    );\n\n    await assertDomSnapshot(page);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can fast forward selection events","suites":["replayer"],"updatePoint":{"line":207,"column":39},"line":207,"code":"  it('can fast forward selection events', async () => {\n    await page.evaluate(`events = ${JSON.stringify(selectionEvents)}`);\n\n    /** check the first selection event */\n    let [startOffset, endOffset] = (await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(360);\n      var range = replayer.iframe.contentDocument.getSelection().getRangeAt(0);\n      [range.startOffset, range.endOffset];\n    `)) as [startOffset: number, endOffset: number];\n\n    expect(startOffset).toEqual(5);\n    expect(endOffset).toEqual(15);\n\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n\n    /** check the second selection event */\n    [startOffset, endOffset] = (await page.evaluate(`      \n      replayer.pause(410);\n      var range = replayer.iframe.contentDocument.getSelection().getRangeAt(0);\n      [range.startOffset, range.endOffset];\n    `)) as [startOffset: number, endOffset: number];\n\n    expect(startOffset).toEqual(11);\n    expect(endOffset).toEqual(6);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can fast forward past StyleSheetRule deletion on virtual elements","suites":["replayer"],"updatePoint":{"line":236,"column":71},"line":236,"code":"  it('can fast forward past StyleSheetRule deletion on virtual elements', async () => {\n    await page.evaluate(`events = ${JSON.stringify(styleSheetRuleEvents)}`);\n\n    const actionLength = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(2600);\n      replayer['timer']['actions'].length;\n    `);\n\n    await assertDomSnapshot(page);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should delete fast forwarded StyleSheetRules that where removed","suites":["replayer"],"updatePoint":{"line":249,"column":69},"line":249,"code":"  it('should delete fast forwarded StyleSheetRules that where removed', async () => {\n    await page.evaluate(`events = ${JSON.stringify(styleSheetRuleEvents)}`);\n    const result = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(3000);\n      const rules = [...replayer.iframe.contentDocument.styleSheets].map(\n        (sheet) => [...sheet.rules],\n      ).flat();\n      rules.some((x) => x.selectorText === '.css-added-at-1000-deleted-at-2500');\n    `);\n\n    expect(result).toEqual(false);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should overwrite all StyleSheetRules by replacing style element's textContent while fast-forwarding","suites":["replayer"],"updatePoint":{"line":264,"column":105},"line":264,"code":"  it(\"should overwrite all StyleSheetRules by replacing style element's textContent while fast-forwarding\", async () => {\n    await page.evaluate(`events = ${JSON.stringify(styleSheetRuleEvents)}`);\n    const result = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(3500);\n      const rules = [...replayer.iframe.contentDocument.styleSheets].map(\n        (sheet) => [...sheet.rules],\n      ).flat();\n      rules.some((x) => x.selectorText === '.css-added-at-200-overwritten-at-3000');\n    `);\n\n    expect(result).toEqual(false);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should apply fast-forwarded StyleSheetRules that came after stylesheet textContent overwrite","suites":["replayer"],"updatePoint":{"line":279,"column":98},"line":279,"code":"  it('should apply fast-forwarded StyleSheetRules that came after stylesheet textContent overwrite', async () => {\n    await page.evaluate(`events = ${JSON.stringify(styleSheetRuleEvents)}`);\n    const result = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(3500);\n      const rules = [...replayer.iframe.contentDocument.styleSheets].map(\n        (sheet) => [...sheet.rules],\n      ).flat();\n      rules.some((x) => x.selectorText === '.css-added-at-3100') &&\n        !rules.some(\n          (x) => x.selectorText === '.css-added-at-500-overwritten-at-3000',\n        );\n    `);\n\n    expect(result).toEqual(true);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should overwrite all StyleSheetRules by appending a text node to stylesheet element while fast-forwarding","suites":["replayer"],"updatePoint":{"line":297,"column":111},"line":297,"code":"  it('should overwrite all StyleSheetRules by appending a text node to stylesheet element while fast-forwarding', async () => {\n    await page.evaluate(`events = ${JSON.stringify(StyleSheetTextMutation)}`);\n    const result = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(1600);\n      const rules = [...replayer.iframe.contentDocument.styleSheets].map(\n        (sheet) => [...sheet.rules],\n      ).flat();\n      rules.some((x) => x.selectorText === '.css-added-at-1000-overwritten-at-1500');\n    `);\n    expect(result).toEqual(false);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should apply fast-forwarded StyleSheetRules that came after appending text node to stylesheet element","suites":["replayer"],"updatePoint":{"line":311,"column":107},"line":311,"code":"  it('should apply fast-forwarded StyleSheetRules that came after appending text node to stylesheet element', async () => {\n    await page.evaluate(`events = ${JSON.stringify(StyleSheetTextMutation)}`);\n    const result = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(2100);\n      const rules = [...replayer.iframe.contentDocument.styleSheets].map(\n        (sheet) => [...sheet.rules],\n      ).flat();\n      rules.some((x) => x.selectorText === '.css-added-at-2000-overwritten-at-2500');\n    `);\n    expect(result).toEqual(true);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should overwrite all StyleSheetRules by removing text node from stylesheet element while fast-forwarding","suites":["replayer"],"updatePoint":{"line":325,"column":110},"line":325,"code":"  it('should overwrite all StyleSheetRules by removing text node from stylesheet element while fast-forwarding', async () => {\n    await page.evaluate(`events = ${JSON.stringify(StyleSheetTextMutation)}`);\n    const result = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(2600);\n      const rules = [...replayer.iframe.contentDocument.styleSheets].map(\n        (sheet) => [...sheet.rules],\n      ).flat();\n      rules.some((x) => x.selectorText === '.css-added-at-2000-overwritten-at-2500');\n    `);\n    expect(result).toEqual(false);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should apply fast-forwarded StyleSheetRules that came after removing text node from stylesheet element","suites":["replayer"],"updatePoint":{"line":339,"column":108},"line":339,"code":"  it('should apply fast-forwarded StyleSheetRules that came after removing text node from stylesheet element', async () => {\n    await page.evaluate(`events = ${JSON.stringify(StyleSheetTextMutation)}`);\n    const result = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(3100);\n      const rules = [...replayer.iframe.contentDocument.styleSheets].map(\n        (sheet) => [...sheet.rules],\n      ).flat();\n      rules.some((x) => x.selectorText === '.css-added-at-3000');\n    `);\n    expect(result).toEqual(true);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can fast forward scroll events","suites":["replayer"],"updatePoint":{"line":353,"column":36},"line":353,"code":"  it('can fast forward scroll events', async () => {\n    await page.evaluate(`\n      events = ${JSON.stringify(scrollEvents)};\n      const { Replayer } = rrweb;\n      var replayer = new Replayer(events,{showDebug:true});\n      replayer.pause(550);\n    `);\n    // add the \"#container\" element at 500\n    const iframe = await page.$('iframe');\n    const contentDocument = await iframe!.contentFrame()!;\n    expect(await contentDocument!.$('#container')).not.toBeNull();\n    expect(await contentDocument!.$('#block')).not.toBeNull();\n    expect(\n      await contentDocument!.$eval(\n        '#container',\n        (element: Element) => element.scrollTop,\n      ),\n    ).toEqual(0);\n\n    // restart the replayer\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n\n    await page.evaluate('replayer.pause(1050);');\n    // scroll the \"#container\" div' at 1000\n    expect(\n      await contentDocument!.$eval(\n        '#container',\n        (element: Element) => element.scrollTop,\n      ),\n    ).toEqual(2500);\n\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(1550);');\n    // scroll the document at 1500\n    expect(\n      await page.$eval(\n        'iframe',\n        (element: Element) =>\n          (element as HTMLIFrameElement)!.contentWindow!.scrollY,\n      ),\n    ).toEqual(250);\n\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(2050);');\n    // remove the \"#container\" element at 2000\n    expect(await contentDocument!.$('#container')).toBeNull();\n    expect(await contentDocument!.$('#block')).toBeNull();\n    expect(\n      await page.$eval(\n        'iframe',\n        (element: Element) =>\n          (element as HTMLIFrameElement)!.contentWindow!.scrollY,\n      ),\n    ).toEqual(0);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can fast forward input events","suites":["replayer"],"updatePoint":{"line":412,"column":35},"line":412,"code":"  it('can fast forward input events', async () => {\n    await page.evaluate(`\n      events = ${JSON.stringify(inputEvents)};\n      const { Replayer } = rrweb;\n      var replayer = new Replayer(events,{showDebug:true});\n      replayer.pause(1050);\n    `);\n    const iframe = await page.$('iframe');\n    const contentDocument = await iframe!.contentFrame()!;\n    expect(await contentDocument!.$('select')).not.toBeNull();\n    expect(\n      await contentDocument!.$eval(\n        'select',\n        (element: Element) => (element as HTMLSelectElement).value,\n      ),\n    ).toEqual('valueB'); // the default value\n\n    // restart the replayer\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n\n    await page.evaluate('replayer.pause(1550);');\n    // the value get changed to 'valueA' at 1500\n    expect(\n      await contentDocument!.$eval(\n        'select',\n        (element: Element) => (element as HTMLSelectElement).value,\n      ),\n    ).toEqual('valueA');\n\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(2050);');\n    // the value get changed to 'valueC' at 2000\n    expect(\n      await contentDocument!.$eval(\n        'select',\n        (element: Element) => (element as HTMLSelectElement).value,\n      ),\n    ).toEqual('valueC');\n\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(2550);');\n    // add a new input element at 2500\n    expect(\n      await contentDocument!.$eval(\n        'input',\n        (element: Element) => (element as HTMLSelectElement).value,\n      ),\n    ).toEqual('');\n\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(3050);');\n    // set the value 'test input' for the input element at 3000\n    expect(\n      await contentDocument!.$eval(\n        'input',\n        (element: Element) => (element as HTMLSelectElement).value,\n      ),\n    ).toEqual('test input');\n\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(3550);');\n    // remove the select element at 3500\n    expect(await contentDocument!.$('select')).toBeNull();\n\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(4050);');\n    // remove the input element at 4000\n    expect(await contentDocument!.$('input')).toBeNull();\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can fast-forward mutation events containing nested iframe elements","suites":["replayer"],"updatePoint":{"line":488,"column":72},"line":488,"code":"  it('can fast-forward mutation events containing nested iframe elements', async () => {\n    await page.evaluate(`\n      events = ${JSON.stringify(iframeEvents)};\n      const { Replayer } = rrweb;\n      var replayer = new Replayer(events,{showDebug:true});\n      replayer.pause(250);\n    `);\n    const iframe = await page.$('iframe');\n    const contentDocument = await iframe!.contentFrame()!;\n    expect(await contentDocument!.$('iframe')).toBeNull();\n\n    // restart the replayer\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(550);'); // add 'iframe one' at 500\n    expect(await contentDocument!.$('iframe')).not.toBeNull();\n    let iframeOneDocument = await (await contentDocument!.$(\n      'iframe',\n    ))!.contentFrame();\n    expect(iframeOneDocument).not.toBeNull();\n    expect(await iframeOneDocument!.$('noscript')).not.toBeNull();\n    // make sure custom style rules are inserted rules\n    expect((await iframeOneDocument!.$$('style')).length).toBe(1);\n    expect(\n      await iframeOneDocument!.$eval(\n        'noscript',\n        (element) => window.getComputedStyle(element).display,\n      ),\n    ).toEqual('none');\n\n    // add 'iframe two' and 'iframe three' at 1000\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(1050);');\n    // check the inserted style of iframe 'one' again\n    iframeOneDocument = await (await contentDocument!.$(\n      'iframe',\n    ))!.contentFrame();\n    expect((await iframeOneDocument!.$$('style')).length).toBe(1);\n\n    expect((await contentDocument!.$$('iframe')).length).toEqual(2);\n    let iframeTwoDocument = await (\n      await contentDocument!.$$('iframe')\n    )[1]!.contentFrame();\n    expect(iframeTwoDocument).not.toBeNull();\n    expect((await iframeTwoDocument!.$$('iframe')).length).toEqual(2);\n    expect((await iframeTwoDocument!.$$('style')).length).toBe(1);\n    let iframeThreeDocument = await (\n      await iframeTwoDocument!.$$('iframe')\n    )[0]!.contentFrame();\n    let iframeFourDocument = await (\n      await iframeTwoDocument!.$$('iframe')\n    )[1]!.contentFrame();\n    expect(iframeThreeDocument).not.toBeNull();\n    expect((await iframeThreeDocument!.$$('style')).length).toBe(1);\n    expect(iframeFourDocument).not.toBeNull();\n\n    // add 'iframe four' at 1500\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(1550);');\n    iframeTwoDocument = await (\n      await contentDocument!.$$('iframe')\n    )[1]!.contentFrame();\n    expect((await iframeTwoDocument!.$$('style')).length).toBe(1);\n    iframeFourDocument = await (\n      await iframeTwoDocument!.$$('iframe')\n    )[1]!.contentFrame();\n    expect(await iframeFourDocument!.$('iframe')).toBeNull();\n    expect((await iframeFourDocument!.$$('style')).length).toBe(1);\n    expect(await iframeFourDocument!.title()).toEqual('iframe 4');\n\n    // add 'iframe five' at 2000\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(2050);');\n    iframeTwoDocument = await (\n      await contentDocument!.$$('iframe')\n    )[1]!.contentFrame();\n    iframeFourDocument = await (\n      await iframeTwoDocument!.$$('iframe')\n    )[1]!.contentFrame();\n    expect((await iframeFourDocument!.$$('style')).length).toBe(1);\n    expect(await iframeFourDocument!.$('iframe')).not.toBeNull();\n    const iframeFiveDocument = await (await iframeFourDocument!.$(\n      'iframe',\n    ))!.contentFrame();\n    expect(iframeFiveDocument).not.toBeNull();\n    expect((await iframeFiveDocument!.$$('style')).length).toBe(1);\n    expect(await iframeFiveDocument!.$('noscript')).not.toBeNull();\n    expect(\n      await iframeFiveDocument!.$eval(\n        'noscript',\n        (element) => window.getComputedStyle(element).display,\n      ),\n    ).toEqual('none');\n\n    // remove the html element of 'iframe four' at 2500\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(2550);');\n    iframeTwoDocument = await (\n      await contentDocument!.$$('iframe')\n    )[1]!.contentFrame();\n    iframeFourDocument = await (\n      await iframeTwoDocument!.$$('iframe')\n    )[1]!.contentFrame();\n    // the html element should be removed\n    expect(await iframeFourDocument!.$('html')).toBeNull();\n    // the doctype should still exist\n    expect(\n      await iframeTwoDocument!.evaluate(\n        (iframe) => (iframe as HTMLIFrameElement)!.contentDocument!.doctype,\n        (\n          await iframeTwoDocument!.$$('iframe')\n        )[1],\n      ),\n    ).not.toBeNull();\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can fast-forward mutation events containing nested shadow doms","suites":["replayer"],"updatePoint":{"line":608,"column":68},"line":608,"code":"  it('can fast-forward mutation events containing nested shadow doms', async () => {\n    await page.evaluate(`\n      events = ${JSON.stringify(shadowDomEvents)};\n      const { Replayer } = rrweb;\n      var replayer = new Replayer(events,{showDebug:true});\n      replayer.pause(550);\n    `);\n    // add shadow dom 'one' at 500\n    const iframe = await page.$('iframe');\n    const contentDocument = await iframe!.contentFrame()!;\n    expect(\n      await contentDocument!.$eval('div', (element) => element.shadowRoot),\n    ).not.toBeNull();\n    expect(\n      await contentDocument!.evaluate(\n        () =>\n          document\n            .querySelector('body > div')!\n            .shadowRoot!.querySelector('span')!.textContent,\n      ),\n    ).toEqual('shadow dom one');\n\n    // add shadow dom 'two' at 1000\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(1050);');\n    expect(\n      await contentDocument!.evaluate(\n        () =>\n          document\n            .querySelector('body > div')!\n            .shadowRoot!.querySelector('div')!.shadowRoot,\n      ),\n    ).not.toBeNull();\n    expect(\n      await contentDocument!.evaluate(\n        () =>\n          document\n            .querySelector('body > div')!\n            .shadowRoot!.querySelector('div')!\n            .shadowRoot!.querySelector('span')!.textContent,\n      ),\n    ).toEqual('shadow dom two');\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can fast-forward mutation events containing painted canvas in iframe","suites":["replayer"],"updatePoint":{"line":653,"column":74},"line":653,"code":"  it('can fast-forward mutation events containing painted canvas in iframe', async () => {\n    await page.evaluate(`\n      events = ${JSON.stringify(canvasInIframe)};\n      const { Replayer } = rrweb;\n      var replayer = new Replayer(events,{showDebug:true});\n      replayer.pause(550);            \n    `);\n    const replayerIframe = await page.$('iframe');\n    const contentDocument = await replayerIframe!.contentFrame()!;\n    const iframe = await contentDocument!.$('iframe');\n    expect(iframe).not.toBeNull();\n    const docInIFrame = await iframe?.contentFrame();\n    expect(docInIFrame).not.toBeNull();\n    const canvasElements = await docInIFrame!.$$('canvas');\n    // The first canvas is a blank one and the second is a painted one.\n    expect(canvasElements.length).toEqual(2);\n\n    const dataUrls = await docInIFrame?.$$eval('canvas', (elements) =>\n      elements.map((element) => (element as HTMLCanvasElement).toDataURL()),\n    );\n    expect(dataUrls?.length).toEqual(2);\n    // The painted canvas's data should not be empty.\n    expect(dataUrls![1]).not.toEqual(dataUrls![0]);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can stream events in live mode","suites":["replayer"],"updatePoint":{"line":678,"column":36},"line":678,"code":"  it('can stream events in live mode', async () => {\n    const status = await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events, {\n        liveMode: true\n      });\n      replayer.startLive();\n      replayer.service.state.value;\n    `);\n    expect(status).toEqual('live');\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"shouldn't trigger ReplayerEvents.Finish in live mode","suites":["replayer"],"updatePoint":{"line":690,"column":58},"line":690,"code":"  it(\"shouldn't trigger ReplayerEvents.Finish in live mode\", async () => {\n    const status = await page.evaluate((FinishState) => {\n      return new Promise((resolve) => {\n        const win = window as IWindow;\n        let triggeredFinish = false;\n        const { Replayer } = win.rrweb;\n        const replayer = new Replayer([], {\n          liveMode: true,\n        });\n        replayer.on(FinishState, () => {\n          triggeredFinish = true;\n        });\n        replayer.startLive();\n        replayer.addEvent(win.events[0]);\n        requestAnimationFrame(() => {\n          resolve(triggeredFinish);\n        });\n      });\n    }, ReplayerEvents.Finish);\n\n    expect(status).toEqual(false);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"replays same timestamp events in correct order","suites":["replayer"],"updatePoint":{"line":713,"column":52},"line":713,"code":"  it('replays same timestamp events in correct order', async () => {\n    await page.evaluate(`events = ${JSON.stringify(orderingEvents)}`);\n    await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.play();\n    `);\n    await page.waitForTimeout(50);\n\n    await assertDomSnapshot(page);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"replays same timestamp events in correct order (with addAction)","suites":["replayer"],"updatePoint":{"line":725,"column":69},"line":725,"code":"  it('replays same timestamp events in correct order (with addAction)', async () => {\n    await page.evaluate(`events = ${JSON.stringify(orderingEvents)}`);\n    await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events.slice(0, events.length-2));\n      replayer.play();\n      replayer.addEvent(events[events.length-2]);\n      replayer.addEvent(events[events.length-1]);\n    `);\n    await page.waitForTimeout(50);\n\n    await assertDomSnapshot(page);\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should destroy the replayer after calling destroy()","suites":["replayer"],"updatePoint":{"line":739,"column":57},"line":739,"code":"  it('should destroy the replayer after calling destroy()', async () => {\n    await page.evaluate(`events = ${JSON.stringify(events)}`);\n    await page.evaluate(`\n      const { Replayer } = rrweb;\n      let replayer = new Replayer(events);\n      replayer.play();      \n    `);\n\n    const replayerWrapperClassName = 'replayer-wrapper';\n    let wrapper = await page.$(`.${replayerWrapperClassName}`);\n    expect(wrapper).not.toBeNull();\n\n    await page.evaluate(`replayer.destroy(); replayer = null;`);\n    wrapper = await page.$(`.${replayerWrapperClassName}`);\n    expect(wrapper).toBeNull();\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can replay adopted stylesheet events","suites":["replayer"],"updatePoint":{"line":756,"column":42},"line":756,"code":"  it('can replay adopted stylesheet events', async () => {\n    await page.evaluate(`\n      events = ${JSON.stringify(adoptedStyleSheet)};\n      const { Replayer } = rrweb;\n      var replayer = new Replayer(events,{showDebug:true});\n      replayer.play();\n    `);\n    await page.waitForTimeout(600);\n    const iframe = await page.$('iframe');\n    const contentDocument = await iframe!.contentFrame()!;\n    const colorRGBMap = {\n      yellow: 'rgb(255, 255, 0)',\n      red: 'rgb(255, 0, 0)',\n      blue: 'rgb(0, 0, 255)',\n      green: 'rgb(0, 128, 0)',\n    };\n    const checkCorrectness = async () => {\n      // check the adopted stylesheet is applied on the outermost document\n      expect(\n        await contentDocument!.$eval(\n          'div',\n          (element) => window.getComputedStyle(element).color,\n        ),\n      ).toEqual(colorRGBMap.yellow);\n\n      // check the adopted stylesheet is applied on the shadow dom #1's root\n      expect(\n        await contentDocument!.evaluate(\n          () =>\n            window.getComputedStyle(\n              document\n                .querySelector('#shadow-host1')!\n                .shadowRoot!.querySelector('span')!,\n            ).color,\n        ),\n      ).toEqual(colorRGBMap.red);\n\n      // check the adopted stylesheet is applied on document of the IFrame element\n      expect(\n        await contentDocument!.$eval(\n          'iframe',\n          (element) =>\n            window.getComputedStyle(\n              (element as HTMLIFrameElement).contentDocument!.querySelector(\n                'h1',\n              )!,\n            ).color,\n        ),\n      ).toEqual(colorRGBMap.blue);\n\n      // check the adopted stylesheet is applied on the shadow dom #2's root\n      expect(\n        await contentDocument!.evaluate(\n          () =>\n            window.getComputedStyle(\n              document\n                .querySelector('#shadow-host2')!\n                .shadowRoot!.querySelector('span')!,\n            ).color,\n        ),\n      ).toEqual(colorRGBMap.green);\n    };\n    await checkCorrectness();\n\n    // To test the correctness of replaying adopted stylesheet events in the fast-forward mode.\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(600);');\n    await checkCorrectness();\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can replay modification events for adoptedStyleSheet","suites":["replayer"],"updatePoint":{"line":827,"column":58},"line":827,"code":"  it('can replay modification events for adoptedStyleSheet', async () => {\n    await page.evaluate(`\n    events = ${JSON.stringify(adoptedStyleSheetModification)};\n    const { Replayer } = rrweb;\n    var replayer = new Replayer(events,{showDebug:true});\n    replayer.pause(0);\n\n    async function playTill(offsetTime) {\n      replayer.play();\n      return new Promise((resolve) => {\n        const checkTime = () => {\n          if (replayer.getCurrentTime() >= offsetTime) {\n            replayer.pause();\n            resolve(undefined);\n          } else {\n            requestAnimationFrame(checkTime);\n          }\n        };\n        checkTime();\n      });\n    }`);\n\n    const iframe = await page.$('iframe');\n    const contentDocument = await iframe!.contentFrame()!;\n\n    // At 250ms, the adopted stylesheet is still empty.\n    const check250ms = async () => {\n      expect(\n        await contentDocument!.evaluate(\n          () =>\n            document.adoptedStyleSheets.length === 1 &&\n            document.adoptedStyleSheets[0].cssRules.length === 0,\n        ),\n      ).toBeTruthy();\n      expect(\n        await contentDocument!.evaluate(\n          () =>\n            document.querySelector('iframe')!.contentDocument!\n              .adoptedStyleSheets.length === 1 &&\n            document.querySelector('iframe')!.contentDocument!\n              .adoptedStyleSheets[0].cssRules.length === 0,\n        ),\n      ).toBeTruthy();\n    };\n\n    // At 300ms, the adopted stylesheet is replaced with new content.\n    const check300ms = async () => {\n      expect(\n        await contentDocument!.evaluate(\n          () =>\n            document.adoptedStyleSheets[0].cssRules.length === 1 &&\n            document.adoptedStyleSheets[0].cssRules[0].cssText ===\n              'div { color: yellow; }',\n        ),\n      ).toBeTruthy();\n      expect(\n        await contentDocument!.evaluate(\n          () =>\n            document.querySelector('iframe')!.contentDocument!\n              .adoptedStyleSheets[0].cssRules.length === 1 &&\n            document.querySelector('iframe')!.contentDocument!\n              .adoptedStyleSheets[0].cssRules[0].cssText ===\n              'h1 { color: blue; }',\n        ),\n      ).toBeTruthy();\n    };\n\n    // At 400ms, check replaceSync API.\n    const check400ms = async () => {\n      expect(\n        await contentDocument!.evaluate(\n          () =>\n            document.adoptedStyleSheets[0].cssRules.length === 1 &&\n            document.adoptedStyleSheets[0].cssRules[0].cssText ===\n              'div { display: inline; }',\n        ),\n      ).toBeTruthy();\n      expect(\n        await contentDocument!.evaluate(\n          () =>\n            document.querySelector('iframe')!.contentDocument!\n              .adoptedStyleSheets[0].cssRules.length === 1 &&\n            document.querySelector('iframe')!.contentDocument!\n              .adoptedStyleSheets[0].cssRules[0].cssText ===\n              'h1 { font-size: large; }',\n        ),\n      ).toBeTruthy();\n    };\n\n    // At 500ms, check CSSStyleDeclaration API.\n    const check500ms = async () => {\n      expect(\n        await contentDocument!.evaluate(\n          () =>\n            document.adoptedStyleSheets[0].cssRules.length === 1 &&\n            document.adoptedStyleSheets[0].cssRules[0].cssText ===\n              'div { color: green; }',\n        ),\n      ).toBeTruthy();\n      expect(\n        await contentDocument!.evaluate(\n          () =>\n            document.querySelector('iframe')!.contentDocument!\n              .adoptedStyleSheets[0].cssRules.length === 2 &&\n            document.querySelector('iframe')!.contentDocument!\n              .adoptedStyleSheets[0].cssRules[0].cssText ===\n              'h2 { color: red; }' &&\n            document.querySelector('iframe')!.contentDocument!\n              .adoptedStyleSheets[0].cssRules[1].cssText ===\n              'h1 { font-size: medium !important; }',\n        ),\n      ).toBeTruthy();\n    };\n\n    // At 600ms, check insertRule and deleteRule API.\n    const check600ms = async () => {\n      expect(\n        await contentDocument!.evaluate(\n          () =>\n            document.adoptedStyleSheets[0].cssRules.length === 2 &&\n            document.adoptedStyleSheets[0].cssRules[0].cssText ===\n              'div { color: green; }' &&\n            document.adoptedStyleSheets[0].cssRules[1].cssText ===\n              'body { border: 2px solid blue; }',\n        ),\n      ).toBeTruthy();\n      expect(\n        await contentDocument!.evaluate(\n          () =>\n            document.querySelector('iframe')!.contentDocument!\n              .adoptedStyleSheets[0].cssRules.length === 1 &&\n            document.querySelector('iframe')!.contentDocument!\n              .adoptedStyleSheets[0].cssRules[0].cssText ===\n              'h1 { font-size: medium !important; }',\n        ),\n      ).toBeTruthy();\n    };\n\n    await page.evaluate(`playTill(250)`);\n    await check250ms();\n\n    await page.evaluate(`playTill(300)`);\n    await check300ms();\n\n    await page.evaluate(`playTill(400)`);\n    await check400ms();\n\n    await page.evaluate(`playTill(500)`);\n    await check500ms();\n\n    await page.evaluate(`playTill(600)`);\n    await check600ms();\n\n    // To test the correctness of replaying adopted stylesheet mutation events in the fast-forward mode.\n    await page.evaluate('replayer.play(0);');\n    await waitForRAF(page);\n    await page.evaluate('replayer.pause(280);');\n    await check250ms();\n\n    await page.evaluate('replayer.pause(330);');\n    await check300ms();\n\n    await page.evaluate('replayer.pause(430);');\n    await check400ms();\n\n    await page.evaluate('replayer.pause(530);');\n    await check500ms();\n\n    await page.evaluate('replayer.pause(630);');\n    await check600ms();\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should replay document replacement events without warnings or errors","suites":["replayer"],"updatePoint":{"line":999,"column":74},"line":999,"code":"  it('should replay document replacement events without warnings or errors', async () => {\n    await page.evaluate(\n      `events = ${JSON.stringify(documentReplacementEvents)}`,\n    );\n    const warningThrown = jest.fn();\n    page.on('console', warningThrown);\n    const errorThrown = jest.fn();\n    page.on('pageerror', errorThrown);\n    await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.play(500);\n    `);\n    await waitForRAF(page);\n\n    // No warnings should be logged.\n    expect(warningThrown).not.toHaveBeenCalled();\n    // No errors should be thrown.\n    expect(errorThrown).not.toHaveBeenCalled();\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should remove outdated hover styles in iframes and shadow doms","suites":["replayer"],"updatePoint":{"line":1020,"column":68},"line":1020,"code":"  it('should remove outdated hover styles in iframes and shadow doms', async () => {\n    await page.evaluate(`events = ${JSON.stringify(hoverInIframeShadowDom)}`);\n\n    await page.evaluate(`\n      const { Replayer } = rrweb;\n      const replayer = new Replayer(events);\n      replayer.pause(550);\n    `);\n    const replayerIframe = await page.$('iframe');\n    const contentDocument = await replayerIframe!.contentFrame()!;\n    const iframe = await contentDocument!.$('iframe');\n    expect(iframe).not.toBeNull();\n    const docInIFrame = await iframe?.contentFrame();\n    expect(docInIFrame).not.toBeNull();\n\n    // hover element in iframe at 500ms\n    expect(\n      await docInIFrame?.evaluate(\n        () => document.querySelector('span')?.className,\n      ),\n    ).toBe(':hover');\n    // At this time, there should be no class name in shadow dom\n    expect(\n      await docInIFrame?.evaluate(() => {\n        const shadowRoot = document.querySelector('div')?.shadowRoot;\n        return (shadowRoot?.childNodes[0] as HTMLElement).className;\n      }),\n    ).toBe('');\n\n    // hover element in shadow dom at 1000ms\n    await page.evaluate('replayer.pause(1050);');\n    // :hover style should be removed from iframe\n    expect(\n      await docInIFrame?.evaluate(\n        () => document.querySelector('span')?.className,\n      ),\n    ).toBe('');\n    expect(\n      await docInIFrame?.evaluate(() => {\n        const shadowRoot = document.querySelector('div')?.shadowRoot;\n        return (shadowRoot?.childNodes[0] as HTMLElement).className;\n      }),\n    ).toBe(':hover');\n\n    // hover element in iframe at 1500ms again\n    await page.evaluate('replayer.pause(1550);');\n    // hover style should be removed from shadow dom\n    expect(\n      await docInIFrame?.evaluate(() => {\n        const shadowRoot = document.querySelector('div')?.shadowRoot;\n        return (shadowRoot?.childNodes[0] as HTMLElement).className;\n      }),\n    ).toBe('');\n    expect(\n      await docInIFrame?.evaluate(\n        () => document.querySelector('span')?.className,\n      ),\n    ).toBe(':hover');\n  });","file":"replayer.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should create a StyleSheetMirror","suites":["Utilities for other modules","StyleSheetMirror"],"updatePoint":{"line":14,"column":40},"line":14,"code":"    it('should create a StyleSheetMirror', () => {\n      const mirror = new StyleSheetMirror();\n      expect(mirror).toBeDefined();\n      expect(mirror.add).toBeDefined();\n      expect(mirror.has).toBeDefined();\n      expect(mirror.reset).toBeDefined();\n      expect(mirror.getId).toBeDefined();\n    });","file":"util.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can add CSSStyleSheet into the mirror without ID parameter","suites":["Utilities for other modules","StyleSheetMirror"],"updatePoint":{"line":23,"column":66},"line":23,"code":"    it('can add CSSStyleSheet into the mirror without ID parameter', () => {\n      const mirror = new StyleSheetMirror();\n      const styleSheet = new CSSStyleSheet();\n      expect(mirror.has(styleSheet)).toBeFalsy();\n      expect(mirror.add(styleSheet)).toEqual(1);\n      expect(mirror.has(styleSheet)).toBeTruthy();\n      // This stylesheet has been added before so just return its assigned id.\n      expect(mirror.add(styleSheet)).toEqual(1);\n\n      for (let i = 0; i < 10; i++) {\n        const styleSheet = new CSSStyleSheet();\n        expect(mirror.has(styleSheet)).toBeFalsy();\n        expect(mirror.add(styleSheet)).toEqual(i + 2);\n        expect(mirror.has(styleSheet)).toBeTruthy();\n      }\n    });","file":"util.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can add CSSStyleSheet into the mirror with ID parameter","suites":["Utilities for other modules","StyleSheetMirror"],"updatePoint":{"line":40,"column":63},"line":40,"code":"    it('can add CSSStyleSheet into the mirror with ID parameter', () => {\n      const mirror = new StyleSheetMirror();\n      for (let i = 0; i < 10; i++) {\n        const styleSheet = new CSSStyleSheet();\n        expect(mirror.has(styleSheet)).toBeFalsy();\n        expect(mirror.add(styleSheet, i)).toEqual(i);\n        expect(mirror.has(styleSheet)).toBeTruthy();\n      }\n    });","file":"util.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can get the id from the mirror","suites":["Utilities for other modules","StyleSheetMirror"],"updatePoint":{"line":50,"column":38},"line":50,"code":"    it('can get the id from the mirror', () => {\n      const mirror = new StyleSheetMirror();\n      for (let i = 0; i < 10; i++) {\n        const styleSheet = new CSSStyleSheet();\n        mirror.add(styleSheet);\n        expect(mirror.getId(styleSheet)).toBe(i + 1);\n      }\n      expect(mirror.getId(new CSSStyleSheet())).toBe(-1);\n    });","file":"util.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can get CSSStyleSheet objects with id","suites":["Utilities for other modules","StyleSheetMirror"],"updatePoint":{"line":60,"column":45},"line":60,"code":"    it('can get CSSStyleSheet objects with id', () => {\n      const mirror = new StyleSheetMirror();\n      for (let i = 0; i < 10; i++) {\n        const styleSheet = new CSSStyleSheet();\n        mirror.add(styleSheet);\n        expect(mirror.getStyle(i + 1)).toBe(styleSheet);\n      }\n    });","file":"util.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"can reset the mirror","suites":["Utilities for other modules","StyleSheetMirror"],"updatePoint":{"line":69,"column":28},"line":69,"code":"    it('can reset the mirror', () => {\n      const mirror = new StyleSheetMirror();\n      const styleList: CSSStyleSheet[] = [];\n      for (let i = 0; i < 10; i++) {\n        const styleSheet = new CSSStyleSheet();\n        mirror.add(styleSheet);\n        expect(mirror.getId(styleSheet)).toBe(i + 1);\n        styleList.push(styleSheet);\n      }\n      expect(mirror.reset()).toBeUndefined();\n      for (let s of styleList) expect(mirror.has(s)).toBeFalsy();\n      for (let i = 0; i < 10; i++) expect(mirror.getStyle(i + 1)).toBeNull();\n      expect(mirror.add(new CSSStyleSheet())).toBe(1);\n    });","file":"util.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should get correct result given nested shadow doms","suites":["Utilities for other modules","inDom()"],"updatePoint":{"line":86,"column":58},"line":86,"code":"    it('should get correct result given nested shadow doms', () => {\n      const shadowHost = document.createElement('div');\n      const shadowRoot = shadowHost.attachShadow({ mode: 'open' });\n      const shadowHost2 = document.createElement('div');\n      const shadowRoot2 = shadowHost2.attachShadow({ mode: 'open' });\n      const div = document.createElement('div');\n      shadowRoot.appendChild(shadowHost2);\n      shadowRoot2.appendChild(div);\n      // Not in Dom yet.\n      expect(getShadowHost(div)).toBe(shadowHost2);\n      expect(getRootShadowHost(div)).toBe(shadowHost);\n      expect(shadowHostInDom(div)).toBeFalsy();\n      expect(inDom(div)).toBeFalsy();\n\n      // Added to the Dom.\n      document.body.appendChild(shadowHost);\n      expect(getShadowHost(div)).toBe(shadowHost2);\n      expect(getRootShadowHost(div)).toBe(shadowHost);\n      expect(shadowHostInDom(div)).toBeTruthy();\n      expect(inDom(div)).toBeTruthy();\n    });","file":"util.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should get correct result given a normal node","suites":["Utilities for other modules","inDom()"],"updatePoint":{"line":108,"column":53},"line":108,"code":"    it('should get correct result given a normal node', () => {\n      const div = document.createElement('div');\n      // Not in Dom yet.\n      expect(getShadowHost(div)).toBeNull();\n      expect(getRootShadowHost(div)).toBe(div);\n      expect(shadowHostInDom(div)).toBeFalsy();\n      expect(inDom(div)).toBeFalsy();\n\n      // Added to the Dom.\n      document.body.appendChild(div);\n      expect(getShadowHost(div)).toBeNull();\n      expect(getRootShadowHost(div)).toBe(div);\n      expect(shadowHostInDom(div)).toBeTruthy();\n      expect(inDom(div)).toBeTruthy();\n    });","file":"util.test.ts","skipped":false,"dir":"packages/rrweb/test"},{"name":"should get correct result given the textNode of a detached HTMLAnchorElement","suites":["Utilities for other modules","inDom()"],"updatePoint":{"line":128,"column":84},"line":128,"code":"    it('should get correct result given the textNode of a detached HTMLAnchorElement', () => {\n      const a = document.createElement('a');\n      a.href = 'example.com';\n      a.textContent = 'something';\n      // Not in Dom yet.\n      expect(getShadowHost(a.childNodes[0])).toBeNull();\n      expect(getRootShadowHost(a.childNodes[0])).toBe(a.childNodes[0]);\n      expect(shadowHostInDom(a.childNodes[0])).toBeFalsy();\n      expect(inDom(a.childNodes[0])).toBeFalsy();\n\n      // Added to the Dom.\n      document.body.appendChild(a);\n      expect(getShadowHost(a.childNodes[0])).toBeNull();\n      expect(getRootShadowHost(a.childNodes[0])).toBe(a.childNodes[0]);\n      expect(shadowHostInDom(a.childNodes[0])).toBeTruthy();\n      expect(inDom(a.childNodes[0])).toBeTruthy();\n    });","file":"util.test.ts","skipped":false,"dir":"packages/rrweb/test"}]}