{
    "repo": "jimhigson/oboe.js",
    "url": "https://github.com/jimhigson/oboe.js",
    "branch": "master",
    "configs": [
        {
            "package": "oboe",
            "lang": "js",
            "dir": "test",
            "framework": "jasmine",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        }
    ],
    "tests": [
        {
            "name": "is not on the global namespace by default",
            "suites": [
                "oboe loaded using require"
            ],
            "line": 2,
            "updatePoint": {
                "line": 2,
                "column": 47
            },
            "code": "  it('is not on the global namespace by default', function () {\n    expect(window.oboe).toBe(undefined);\n  });",
            "file": "specs/amd.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can be loaded using require",
            "suites": [
                "oboe loaded using require"
            ],
            "line": 5,
            "updatePoint": {
                "line": 5,
                "column": 33
            },
            "code": "  it('can be loaded using require', function (done) {\n    require(['oboe'], function (oboe) {\n      expect(oboe).not.toBe(undefined);\n      expect(oboe('foo.json')).not.toBe(undefined);\n      done();\n    });\n  });",
            "file": "specs/amd.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "it not on global after being loaded",
            "suites": [
                "oboe loaded using require"
            ],
            "line": 12,
            "updatePoint": {
                "line": 12,
                "column": 41
            },
            "code": "  it('it not on global after being loaded', function (done) {\n    require(['oboe'], function (oboe) {\n      expect(window.oboe).toBe(undefined);\n      done();\n    });\n  });",
            "file": "specs/amd.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should have the correct event types",
            "suites": [
                "clarinet"
            ],
            "line": 184,
            "updatePoint": {
                "line": 184,
                "column": 45
            },
            "code": "      it('should have the correct event types', function () {\n        expect(blackBoxRecording).toMatchOrder(doc.events);\n      });",
            "file": "specs/clarinet.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "uses no-body, no-headers, GET, withoutCredentials as the default",
            "suites": [
                "default settings"
            ],
            "line": 7,
            "updatePoint": {
                "line": 7,
                "column": 70
            },
            "code": "  it('uses no-body, no-headers, GET, withoutCredentials as the default', function () {\n    var stub = jasmine.createSpy();\n    applyDefaults(stub, 'http://example.com/oboez');\n    expect(stub).toHaveBeenCalledLike('GET', 'http://example.com/oboez', noBody, noHeaders, false);\n  });",
            "file": "specs/defaults.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can make URL uncacheable",
            "suites": [
                "default settings"
            ],
            "line": 12,
            "updatePoint": {
                "line": 12,
                "column": 30
            },
            "code": "  it('can make URL uncacheable', function () {\n    var time = sinon.useFakeTimers(123);\n    var stub = jasmine.createSpy();\n    applyDefaults(stub, 'http://example.com/oboez', undefined, undefined, undefined, undefined, false);\n    expect(stub).toHaveBeenCalledLike('GET', 'http://example.com/oboez?_=123', noBody, noHeaders, false);\n    time.restore();\n  });",
            "file": "specs/defaults.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can disable caching if url already has a query param",
            "suites": [
                "default settings"
            ],
            "line": 19,
            "updatePoint": {
                "line": 19,
                "column": 58
            },
            "code": "  it('can disable caching if url already has a query param', function () {\n    var time = sinon.useFakeTimers(456);\n    var stub = jasmine.createSpy();\n    applyDefaults(stub, 'http://example.com/oboez?foo=bar', undefined, undefined, undefined, undefined, false);\n    expect(stub).toHaveBeenCalledLike('GET', 'http://example.com/oboez?foo=bar&_=456', noBody, noHeaders, false);\n    time.restore();\n  });",
            "file": "specs/defaults.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can explicitly be not uncacheable",
            "suites": [
                "default settings"
            ],
            "line": 26,
            "updatePoint": {
                "line": 26,
                "column": 39
            },
            "code": "  it('can explicitly be not uncacheable', function () {\n    var time = sinon.useFakeTimers(123);\n    var stub = jasmine.createSpy();\n    applyDefaults(stub, 'http://example.com/oboez', undefined, undefined, undefined, undefined, true);\n    expect(stub).toHaveBeenCalledLike('GET', 'http://example.com/oboez', noBody, noHeaders, false);\n    time.restore();\n  });",
            "file": "specs/defaults.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "allows method to be specified",
            "suites": [
                "default settings"
            ],
            "line": 33,
            "updatePoint": {
                "line": 33,
                "column": 35
            },
            "code": "  it('allows method to be specified', function () {\n    var stub = jasmine.createSpy();\n    applyDefaults(stub, 'http://example.com/oboez', 'POST', undefined, undefined, undefined, true);\n    expect(stub).toHaveBeenCalledLike('POST', 'http://example.com/oboez', noBody, noHeaders, false);\n  });",
            "file": "specs/defaults.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "allows withCredentials to be given",
            "suites": [
                "default settings"
            ],
            "line": 38,
            "updatePoint": {
                "line": 38,
                "column": 40
            },
            "code": "  it('allows withCredentials to be given', function () {\n    var stub = jasmine.createSpy();\n    applyDefaults(stub, 'http://example.com/oboez', undefined, undefined, undefined, true);\n    expect(stub).toHaveBeenCalledLike('GET', 'http://example.com/oboez', noBody, noHeaders, true);\n  });",
            "file": "specs/defaults.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "stringifies JSON bodies and sets content-type if not already given",
            "suites": [
                "default settings"
            ],
            "line": 43,
            "updatePoint": {
                "line": 43,
                "column": 72
            },
            "code": "  it('stringifies JSON bodies and sets content-type if not already given', function () {\n    var stub = jasmine.createSpy();\n    applyDefaults(stub, 'http://example.com/oboez', 'POST', {\n      foo: 'bar'\n    }, undefined, undefined, true);\n    expect(stub).toHaveBeenCalledLike('POST', 'http://example.com/oboez', '{\"foo\":\"bar\"}', {\n      'Content-Type': 'application/json',\n      'Content-Length': 13\n    }, false);\n  });",
            "file": "specs/defaults.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "stringifies JSON bodies and leaves content-type as-is if already given",
            "suites": [
                "default settings"
            ],
            "line": 53,
            "updatePoint": {
                "line": 53,
                "column": 76
            },
            "code": "  it('stringifies JSON bodies and leaves content-type as-is if already given', function () {\n    var stub = jasmine.createSpy();\n    applyDefaults(stub, 'http://example.com/oboez', 'POST', {\n      foo: 'bar'\n    }, {\n      'Content-Type': 'application/awesome'\n    }, undefined, true);\n    expect(stub).toHaveBeenCalledLike('POST', 'http://example.com/oboez', '{\"foo\":\"bar\"}', {\n      'Content-Type': 'application/awesome',\n      'Content-Length': 13\n    }, false);\n  });",
            "file": "specs/defaults.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "passed through string bodies and does not set content-type",
            "suites": [
                "default settings"
            ],
            "line": 65,
            "updatePoint": {
                "line": 65,
                "column": 64
            },
            "code": "  it('passed through string bodies and does not set content-type', function () {\n    var stub = jasmine.createSpy();\n    applyDefaults(stub, 'http://example.com/oboez', 'POST', 'body content', undefined, undefined, true);\n    expect(stub).toHaveBeenCalledLike('POST', 'http://example.com/oboez', 'body content', {\n      'Content-Length': 12\n    }, false);\n  });",
            "file": "specs/defaults.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses absolute path only",
            "suites": [
                "url handling",
                "can parse URLs"
            ],
            "line": 34,
            "updatePoint": {
                "line": 34,
                "column": 33
            },
            "code": "    it('parses absolute path only', function () {\n      expect('/foo/barz').toParseTo(noInformationRegardingOrigin);\n    }); //    it( 'parses absolute path with extension', function() {",
            "file": "specs/detectCrossOrigin.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse json if json is given as the body",
            "suites": [
                "error report"
            ],
            "line": 3,
            "updatePoint": {
                "line": 3,
                "column": 52
            },
            "code": "  it('should parse json if json is given as the body', function () {\n    var jsonFromServer = {\n      something: 'went wrong'\n    };\n    var report = errorReport(0, JSON.stringify(jsonFromServer));\n    expect(report.jsonBody).toEqual(jsonFromServer);\n  });",
            "file": "specs/errorReport.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not have jsonBody if no body is given",
            "suites": [
                "error report"
            ],
            "line": 10,
            "updatePoint": {
                "line": 10,
                "column": 50
            },
            "code": "  it('should not have jsonBody if no body is given', function () {\n    var report = errorReport();\n    expect(report.jsonBody).toBeUndefined();\n  });",
            "file": "specs/errorReport.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not have jsonBody if body is given but it is not json",
            "suites": [
                "error report"
            ],
            "line": 14,
            "updatePoint": {
                "line": 14,
                "column": 66
            },
            "code": "  it('should not have jsonBody if body is given but it is not json', function () {\n    var responseFromServer = '<html>blah blah</html>';\n    var report = errorReport(404, responseFromServer);\n    expect(report.jsonBody).toBeUndefined();\n    expect(report.body).toBe(responseFromServer);\n  });",
            "file": "specs/errorReport.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should store status code",
            "suites": [
                "error report"
            ],
            "line": 20,
            "updatePoint": {
                "line": 20,
                "column": 30
            },
            "code": "  it('should store status code', function () {\n    var report = errorReport(404);\n    expect(report.statusCode).toBe(404);\n  });",
            "file": "specs/errorReport.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should store thrown thing",
            "suites": [
                "error report"
            ],
            "line": 24,
            "updatePoint": {
                "line": 24,
                "column": 31
            },
            "code": "  it('should store thrown thing', function () {\n    var thrown = new Error('something bad happened');\n    var report = errorReport(404, '', thrown);\n    expect(report.thrown).toBe(thrown);\n  });",
            "file": "specs/errorReport.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "passes through the first arguments as-is",
            "suites": [
                "functional",
                "varargs",
                "with fixed arguments"
            ],
            "line": 16,
            "updatePoint": {
                "line": 16,
                "column": 50
            },
            "code": "      it('passes through the first arguments as-is', function () {\n        expect(received1).toBe('a');\n        expect(received2).toBe('b');\n      });",
            "file": "specs/functional.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "passes through the rest as an array",
            "suites": [
                "functional",
                "varargs",
                "with fixed arguments"
            ],
            "line": 20,
            "updatePoint": {
                "line": 20,
                "column": 45
            },
            "code": "      it('passes through the rest as an array', function () {\n        expect(receivedRest).toEqual(['c', 'd', 'e', 'f']);\n      });",
            "file": "specs/functional.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "works with no fixed arguments",
            "suites": [
                "functional",
                "varargs",
                "with fixed arguments"
            ],
            "line": 24,
            "updatePoint": {
                "line": 24,
                "column": 37
            },
            "code": "    it('works with no fixed arguments', function () {\n      var received1 = 'not yet set';\n\n      function f(r1) {\n        received1 = r1;\n      }\n\n      var varargsSpy = varArgs(f);\n      varargsSpy('a', 'b', 'c', 'd', 'e', 'f');\n      expect(received1).toEqual(['a', 'b', 'c', 'd', 'e', 'f']);\n    });",
            "file": "specs/functional.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "propagates the return value",
            "suites": [
                "functional",
                "varargs",
                "with fixed arguments"
            ],
            "line": 35,
            "updatePoint": {
                "line": 35,
                "column": 35
            },
            "code": "    it('propagates the return value', function () {\n      var varargsTestFn = varArgs(function () {\n        return 'expected';\n      });\n      expect(varargsTestFn()).toBe('expected');\n    });",
            "file": "specs/functional.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "executes composed functions right-to-left",
            "suites": [
                "functional",
                "compose"
            ],
            "line": 59,
            "updatePoint": {
                "line": 59,
                "column": 49
            },
            "code": "    it('executes composed functions right-to-left', function () {\n      var composed = compose(dub, inc, half); // composed(x) = dub(inc(half(x)))\n\n      expect(composed(2)).toBe(4); // if this gives 2.5 the order is wrong\n    });",
            "file": "specs/functional.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "may have an outermost function taking more than one argument",
            "suites": [
                "functional",
                "compose"
            ],
            "line": 64,
            "updatePoint": {
                "line": 64,
                "column": 68
            },
            "code": "    it('may have an outermost function taking more than one argument', function () {\n      var composed = compose(inc, div); // composed(x, y) = x/y +1\n\n      expect(composed(10, 2)).toBe(6); // 10/2 +1 = 5+1 = 6\n    });",
            "file": "specs/functional.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can compose head to take an item off a list and then use it",
            "suites": [
                "functional",
                "compose"
            ],
            "line": 69,
            "updatePoint": {
                "line": 69,
                "column": 67
            },
            "code": "    it('can compose head to take an item off a list and then use it', function () {\n      var list = cons({\n        a: 1\n      }, emptyList);\n      expect(compose(attr('a'), head)(list)).toBe(1);\n    });",
            "file": "specs/functional.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can compose one function to give just that function",
            "suites": [
                "functional",
                "compose"
            ],
            "line": 75,
            "updatePoint": {
                "line": 75,
                "column": 59
            },
            "code": "    it('can compose one function to give just that function', function () {\n      expect(compose(div)(20, 5)).toBe(4);\n    });",
            "file": "specs/functional.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives an identity function when making a composition of zero functions",
            "suites": [
                "functional",
                "compose"
            ],
            "line": 78,
            "updatePoint": {
                "line": 78,
                "column": 78
            },
            "code": "    it('gives an identity function when making a composition of zero functions', function () {\n      var id = compose();\n      expect(id(2)).toBe(2);\n    });",
            "file": "specs/functional.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "executes composed functions right-to-left",
            "suites": [
                "functional",
                "compose",
                "compose2"
            ],
            "line": 84,
            "updatePoint": {
                "line": 84,
                "column": 51
            },
            "code": "      it('executes composed functions right-to-left', function () {\n        var composed = compose2(dub, inc); // composed(x) = dub(inc(x))\n\n        expect(composed(2)).toBe(6); // if this gives 5 the order is wrong\n      });",
            "file": "specs/functional.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "may have an outermost function taking more than one argument",
            "suites": [
                "functional",
                "compose",
                "compose2"
            ],
            "line": 89,
            "updatePoint": {
                "line": 89,
                "column": 70
            },
            "code": "      it('may have an outermost function taking more than one argument', function () {\n        var composed = compose2(inc, div); // composed(x, y) = x/y +1\n\n        expect(composed(10, 2)).toBe(6); // 10/2 +1 = 5+1 = 6\n      });",
            "file": "specs/functional.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can compose head to take an item off a list and then use it",
            "suites": [
                "functional",
                "compose",
                "compose2"
            ],
            "line": 94,
            "updatePoint": {
                "line": 94,
                "column": 69
            },
            "code": "      it('can compose head to take an item off a list and then use it', function () {\n        var list = cons({\n          a: 1\n        }, emptyList);\n        expect(compose2(attr('a'), head)(list)).toBe(1);\n      });",
            "file": "specs/functional.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "passes scope to both functions",
            "suites": [
                "functional",
                "compose",
                "compose2"
            ],
            "line": 100,
            "updatePoint": {
                "line": 100,
                "column": 40
            },
            "code": "      it('passes scope to both functions', function () {\n        var expectedScope = {};\n\n        function f() {\n          expect(this).toBe(expectedScope);\n        }\n\n        var composed = compose2(f, f); // composed(x, y) = x/y +1\n\n        composed.apply(expectedScope);\n      });",
            "file": "specs/functional.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can get a value from an object at the named key",
            "suites": [
                "functional",
                "attr"
            ],
            "line": 114,
            "updatePoint": {
                "line": 114,
                "column": 55
            },
            "code": "    it('can get a value from an object at the named key', function () {\n      var getA = attr('A');\n      expect(getA({\n        A: 'B'\n      })).toBe('B');\n    });",
            "file": "specs/functional.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can get the length of a string",
            "suites": [
                "functional",
                "attr"
            ],
            "line": 120,
            "updatePoint": {
                "line": 120,
                "column": 38
            },
            "code": "    it('can get the length of a string', function () {\n      var getLength = attr('length');\n      expect(getLength('hello')).toBe(5);\n    });",
            "file": "specs/functional.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can get a numbered array element out",
            "suites": [
                "functional",
                "attr"
            ],
            "line": 124,
            "updatePoint": {
                "line": 124,
                "column": 44
            },
            "code": "    it('can get a numbered array element out', function () {\n      var getLength = attr(0);\n      expect(getLength(['a', 'b', 'c'])).toBe('a');\n    });",
            "file": "specs/functional.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emits correct event",
            "suites": [
                "incremental content builder",
                "when root object opens"
            ],
            "line": 33,
            "updatePoint": {
                "line": 33,
                "column": 27
            },
            "code": "    it('emits correct event', function () {\n      expect(builder).toHaveEmitted(NODE_OPENED, anAscentContaining({\n        key: ROOT_PATH,\n        node: {}\n      }));\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reports correct root",
            "suites": [
                "incremental content builder",
                "when root object opens"
            ],
            "line": 39,
            "updatePoint": {
                "line": 39,
                "column": 28
            },
            "code": "    it('reports correct root', function () {\n      expect(builder).toHaveEmittedRootWhichIsNow({});\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emits correct event",
            "suites": [
                "incremental content builder",
                "after key is found in root object"
            ],
            "line": 46,
            "updatePoint": {
                "line": 46,
                "column": 27
            },
            "code": "    it('emits correct event', function () {\n      expect(builder).toHaveEmitted(NODE_OPENED, anAscentContaining({\n        key: ROOT_PATH,\n        node: {\n          flavour: undefined\n        }\n      }, {\n        key: 'flavour',\n        node: undefined\n      }));\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reports correct root",
            "suites": [
                "incremental content builder",
                "after key is found in root object"
            ],
            "line": 57,
            "updatePoint": {
                "line": 57,
                "column": 28
            },
            "code": "    it('reports correct root', function () {\n      expect(builder).toHaveEmittedRootWhichIsNow({\n        flavour: undefined\n      });\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emits correct event",
            "suites": [
                "incremental content builder",
                "if key is found at same time as root object"
            ],
            "line": 66,
            "updatePoint": {
                "line": 66,
                "column": 27
            },
            "code": "    it('emits correct event', function () {\n      expect(builder).toHaveEmitted(NODE_OPENED, anAscentContaining({\n        key: ROOT_PATH,\n        node: {\n          flavour: undefined\n        }\n      }, {\n        key: 'flavour',\n        node: undefined\n      }));\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reports correct root",
            "suites": [
                "incremental content builder",
                "if key is found at same time as root object"
            ],
            "line": 77,
            "updatePoint": {
                "line": 77,
                "column": 28
            },
            "code": "    it('reports correct root', function () {\n      expect(builder).toHaveEmittedRootWhichIsNow({\n        flavour: undefined\n      });\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emits correct event",
            "suites": [
                "incremental content builder",
                "after value is found for that key"
            ],
            "line": 85,
            "updatePoint": {
                "line": 85,
                "column": 27
            },
            "code": "    it('emits correct event', function () {\n      expect(builder).toHaveEmitted(NODE_CLOSED, anAscentContaining({\n        key: ROOT_PATH,\n        node: {\n          flavour: 'strawberry'\n        }\n      }, {\n        key: 'flavour',\n        node: 'strawberry'\n      }));\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reports correct root",
            "suites": [
                "incremental content builder",
                "after value is found for that key"
            ],
            "line": 96,
            "updatePoint": {
                "line": 96,
                "column": 28
            },
            "code": "    it('reports correct root', function () {\n      expect(builder).toHaveEmittedRootWhichIsNow({\n        flavour: 'strawberry'\n      });\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emits correct event",
            "suites": [
                "incremental content builder",
                "emits node found after root object closes"
            ],
            "line": 104,
            "updatePoint": {
                "line": 104,
                "column": 27
            },
            "code": "    it('emits correct event', function () {\n      expect(builder).toHaveEmitted(NODE_CLOSED, anAscentContaining({\n        key: ROOT_PATH,\n        node: {\n          flavour: 'strawberry'\n        }\n      }));\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reports correct root",
            "suites": [
                "incremental content builder",
                "emits node found after root object closes"
            ],
            "line": 112,
            "updatePoint": {
                "line": 112,
                "column": 28
            },
            "code": "    it('reports correct root', function () {\n      expect(builder).toHaveEmittedRootWhichIsNow({\n        flavour: 'strawberry'\n      });\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emits path event with numeric paths",
            "suites": [
                "incremental content builder",
                "first array element"
            ],
            "line": 120,
            "updatePoint": {
                "line": 120,
                "column": 43
            },
            "code": "    it('emits path event with numeric paths', function () {\n      expect(builder).toHaveEmitted(NODE_OPENED, anAscentContaining({\n        key: ROOT_PATH,\n        node: {\n          alphabet: ['a']\n        }\n      }, {\n        key: 'alphabet',\n        node: ['a']\n      }, {\n        key: 0,\n        node: 'a'\n      }));\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emitted node event",
            "suites": [
                "incremental content builder",
                "first array element"
            ],
            "line": 134,
            "updatePoint": {
                "line": 134,
                "column": 26
            },
            "code": "    it('emitted node event', function () {\n      expect(builder).toHaveEmitted(NODE_CLOSED, anAscentContaining({\n        key: ROOT_PATH,\n        node: {\n          alphabet: ['a']\n        }\n      }, {\n        key: 'alphabet',\n        node: ['a']\n      }, {\n        key: 0,\n        node: 'a'\n      }));\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reports correct root",
            "suites": [
                "incremental content builder",
                "first array element"
            ],
            "line": 148,
            "updatePoint": {
                "line": 148,
                "column": 28
            },
            "code": "    it('reports correct root', function () {\n      expect(builder).toHaveEmittedRootWhichIsNow({\n        alphabet: ['a']\n      });\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emits events with numeric paths",
            "suites": [
                "incremental content builder",
                "second array element"
            ],
            "line": 156,
            "updatePoint": {
                "line": 156,
                "column": 39
            },
            "code": "    it('emits events with numeric paths', function () {\n      expect(builder).toHaveEmitted(NODE_OPENED, anAscentContaining({\n        key: ROOT_PATH,\n        node: {\n          alphabet: ['a', 'b']\n        }\n      }, {\n        key: 'alphabet',\n        node: ['a', 'b']\n      }, {\n        key: 1,\n        node: 'b'\n      }));\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emitted node event",
            "suites": [
                "incremental content builder",
                "second array element"
            ],
            "line": 170,
            "updatePoint": {
                "line": 170,
                "column": 26
            },
            "code": "    it('emitted node event', function () {\n      expect(builder).toHaveEmitted(NODE_CLOSED, anAscentContaining({\n        key: ROOT_PATH,\n        node: {\n          alphabet: ['a', 'b']\n        }\n      }, {\n        key: 'alphabet',\n        node: ['a', 'b']\n      }, {\n        key: 1,\n        node: 'b'\n      }));\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reports correct root",
            "suites": [
                "incremental content builder",
                "second array element"
            ],
            "line": 184,
            "updatePoint": {
                "line": 184,
                "column": 28
            },
            "code": "    it('reports correct root', function () {\n      expect(builder).toHaveEmittedRootWhichIsNow({\n        alphabet: ['a', 'b']\n      });\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emits events with numeric paths",
            "suites": [
                "incremental content builder",
                "array at root"
            ],
            "line": 192,
            "updatePoint": {
                "line": 192,
                "column": 39
            },
            "code": "    it('emits events with numeric paths', function () {\n      expect(builder).toHaveEmitted(NODE_OPENED, anAscentContaining({\n        key: ROOT_PATH,\n        node: ['a', 'b']\n      }, {\n        key: 1,\n        node: 'b'\n      }));\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emitted node event",
            "suites": [
                "incremental content builder",
                "array at root"
            ],
            "line": 201,
            "updatePoint": {
                "line": 201,
                "column": 26
            },
            "code": "    it('emitted node event', function () {\n      expect(builder).toHaveEmitted(NODE_CLOSED, anAscentContaining({\n        key: ROOT_PATH,\n        node: ['a', 'b']\n      }, {\n        key: 1,\n        node: 'b'\n      }));\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reports correct root",
            "suites": [
                "incremental content builder",
                "array at root"
            ],
            "line": 210,
            "updatePoint": {
                "line": 210,
                "column": 28
            },
            "code": "    it('reports correct root', function () {\n      expect(builder).toHaveEmittedRootWhichIsNow(['a', 'b']);\n    });",
            "file": "specs/incrementalContentBuilder.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "has chainable methods that don't explode",
            "suites": [
                "instance api and pattern adaptor composed"
            ],
            "line": 39,
            "updatePoint": {
                "line": 39,
                "column": 47
            },
            "code": "  it('has chainable methods that don\\'t explode', function () {\n    // test that nothing forgot to return 'this':\n    expect(function () {\n      function fn() {}\n\n      api.path('*', fn).node('*', fn).fail(fn) // fails at this point, fail return undefined\n      .path('*', fn).path({\n        '*': fn\n      }).node({\n        '*': fn\n      }).done(fn).path({\n        '*': fn\n      }).start(fn).on('path', '*', fn).on('node', '*', fn).fail(fn).on('path', '*', fn).on('path', {\n        '*': fn\n      }).on('node', {\n        '*': fn\n      }).on('path', {\n        '*': fn\n      }).on('done', fn).on('start', fn);\n    }).not.toThrow();\n  });",
            "file": "specs/instanceApi.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "returns undefined if not available",
            "suites": [
                "instance api and pattern adaptor composed",
                "header method"
            ],
            "line": 61,
            "updatePoint": {
                "line": 61,
                "column": 42
            },
            "code": "    it('returns undefined if not available', function () {\n      expect(api.header()).toBeUndefined();\n    });",
            "file": "specs/instanceApi.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can provide object once available",
            "suites": [
                "instance api and pattern adaptor composed",
                "header method"
            ],
            "line": 64,
            "updatePoint": {
                "line": 64,
                "column": 41
            },
            "code": "    it('can provide object once available', function () {\n      var headers = {\n        'x-remainingRequests': 100\n      };\n      bus(HTTP_START).emit(200, headers);\n      expect(api.header()).toEqual(headers);\n    });",
            "file": "specs/instanceApi.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can provide single header once available",
            "suites": [
                "instance api and pattern adaptor composed",
                "header method"
            ],
            "line": 71,
            "updatePoint": {
                "line": 71,
                "column": 48
            },
            "code": "    it('can provide single header once available', function () {\n      var headers = {\n        'x-remainingRequests': 100\n      };\n      bus(HTTP_START).emit(200, headers);\n      expect(api.header('x-remainingRequests')).toEqual(100);\n    });",
            "file": "specs/instanceApi.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives undefined for non-existent single header",
            "suites": [
                "instance api and pattern adaptor composed",
                "header method"
            ],
            "line": 78,
            "updatePoint": {
                "line": 78,
                "column": 54
            },
            "code": "    it('gives undefined for non-existent single header', function () {\n      var headers = {\n        'x-remainingRequests': 100\n      };\n      bus(HTTP_START).emit(200, headers);\n      expect(api.header('x-remainingBathtubs')).toBeUndefined();\n    });",
            "file": "specs/instanceApi.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "returns undefined if not available",
            "suites": [
                "instance api and pattern adaptor composed",
                "root method"
            ],
            "line": 87,
            "updatePoint": {
                "line": 87,
                "column": 42
            },
            "code": "    it('returns undefined if not available', function () {\n      expect(api.root()).toBeUndefined();\n    });",
            "file": "specs/instanceApi.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can provide object once available",
            "suites": [
                "instance api and pattern adaptor composed",
                "root method"
            ],
            "line": 90,
            "updatePoint": {
                "line": 90,
                "column": 41
            },
            "code": "    it('can provide object once available', function () {\n      var root = {\n        I: 'am',\n        the: 'root'\n      };\n      bus(ROOT_PATH_FOUND).emit(root);\n      expect(api.root()).toEqual(root);\n    });",
            "file": "specs/instanceApi.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "calls node callback on matching node",
            "suites": [
                "instance api and pattern adaptor composed",
                "node and path callbacks"
            ],
            "line": 100,
            "updatePoint": {
                "line": 100,
                "column": 44
            },
            "code": "    it('calls node callback on matching node', function () {\n      var callback = jasmine.createSpy('node callback');\n      var ascent = anAscentMatching('a_pattern');\n      api.on('node', 'a_pattern', callback);\n      expect(callback).not.toHaveBeenCalled();\n      bus(NODE_CLOSED).emit(ascent);\n      expect(callback).toHaveBeenCalled();\n    });",
            "file": "specs/instanceApi.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "calls path callback on matching path",
            "suites": [
                "instance api and pattern adaptor composed",
                "node and path callbacks"
            ],
            "line": 108,
            "updatePoint": {
                "line": 108,
                "column": 44
            },
            "code": "    it('calls path callback on matching path', function () {\n      var callback = jasmine.createSpy();\n      var ascent = anAscentMatching('a_pattern');\n      api.on('path', 'a_pattern', callback);\n      expect(callback).not.toHaveBeenCalled();\n      bus(NODE_OPENED).emit(ascent);\n      expect(callback).toHaveBeenCalled();\n    });",
            "file": "specs/instanceApi.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not call node callback on non-matching node",
            "suites": [
                "instance api and pattern adaptor composed",
                "node and path callbacks"
            ],
            "line": 116,
            "updatePoint": {
                "line": 116,
                "column": 56
            },
            "code": "    it('does not call node callback on non-matching node', function () {\n      var callback = jasmine.createSpy();\n      var ascent = anAscentMatching('a_pattern');\n      api.on('node', 'a_different_pattern', callback);\n      bus(NODE_CLOSED).emit(ascent);\n      expect(callback).not.toHaveBeenCalled();\n    });",
            "file": "specs/instanceApi.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "calls node callback again on second match",
            "suites": [
                "instance api and pattern adaptor composed",
                "node and path callbacks"
            ],
            "line": 123,
            "updatePoint": {
                "line": 123,
                "column": 49
            },
            "code": "    it('calls node callback again on second match', function () {\n      var callback = jasmine.createSpy();\n      var ascent = anAscentMatching('a_pattern');\n      api.on('node', 'a_pattern', callback);\n      bus(NODE_CLOSED).emit(ascent);\n      expect(callback.calls.count()).toBe(1);\n      bus(NODE_CLOSED).emit(ascent);\n      expect(callback.calls.count()).toBe(2);\n    });",
            "file": "specs/instanceApi.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "puts the url on the oboe instance",
            "suites": [
                "instance api"
            ],
            "line": 24,
            "updatePoint": {
                "line": 24,
                "column": 39
            },
            "code": "  it('puts the url on the oboe instance', function () {\n    expect(oboeInstance.source).toBe(sampleUrl);\n  });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "returns undefined if not available",
            "suites": [
                "instance api",
                "header method"
            ],
            "line": 28,
            "updatePoint": {
                "line": 28,
                "column": 42
            },
            "code": "    it('returns undefined if not available', function () {\n      expect(oboeInstance.header()).toBeUndefined();\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can provide object once available",
            "suites": [
                "instance api",
                "header method"
            ],
            "line": 31,
            "updatePoint": {
                "line": 31,
                "column": 41
            },
            "code": "    it('can provide object once available', function () {\n      var headers = {\n        'x-remainingRequests': 100\n      };\n      oboeBus(HTTP_START).emit(200, headers);\n      expect(oboeInstance.header()).toEqual(headers);\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can provide single header once available",
            "suites": [
                "instance api",
                "header method"
            ],
            "line": 38,
            "updatePoint": {
                "line": 38,
                "column": 48
            },
            "code": "    it('can provide single header once available', function () {\n      var headers = {\n        'x-remainingRequests': 100\n      };\n      oboeBus(HTTP_START).emit(200, headers);\n      expect(oboeInstance.header('x-remainingRequests')).toEqual(100);\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives undefined for non-existent single header",
            "suites": [
                "instance api",
                "header method"
            ],
            "line": 45,
            "updatePoint": {
                "line": 45,
                "column": 54
            },
            "code": "    it('gives undefined for non-existent single header', function () {\n      var headers = {\n        'x-remainingRequests': 100\n      };\n      oboeBus(HTTP_START).emit(200, headers);\n      expect(oboeInstance.header('x-remainingBathtubs')).toBeUndefined();\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "returns undefined if not available",
            "suites": [
                "instance api",
                "root method"
            ],
            "line": 54,
            "updatePoint": {
                "line": 54,
                "column": 42
            },
            "code": "    it('returns undefined if not available', function () {\n      expect(oboeInstance.root()).toBeUndefined();\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can provide object once available",
            "suites": [
                "instance api",
                "root method"
            ],
            "line": 57,
            "updatePoint": {
                "line": 57,
                "column": 41
            },
            "code": "    it('can provide object once available', function () {\n      var root = {\n        I: 'am',\n        the: 'root'\n      };\n      oboeBus(ROOT_PATH_FOUND).emit(root);\n      expect(oboeInstance.root()).toEqual(root);\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "calls node callback when notified of matching node",
            "suites": [
                "instance api",
                "node and path callbacks"
            ],
            "line": 67,
            "updatePoint": {
                "line": 67,
                "column": 58
            },
            "code": "    it('calls node callback when notified of matching node', function () {\n      var callback = jasmine.createSpy('node callback');\n      var node = {};\n      var path = [];\n      var ancestors = [];\n      oboeInstance.on('node', 'a_pattern', callback);\n      expect(callback).not.toHaveBeenCalled();\n      oboeBus('node:a_pattern').emit(node, path, ancestors);\n      expect(callback).toHaveBeenCalledWith(node, path, ancestors);\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "calls path callback when notified of matching path",
            "suites": [
                "instance api",
                "node and path callbacks"
            ],
            "line": 77,
            "updatePoint": {
                "line": 77,
                "column": 58
            },
            "code": "    it('calls path callback when notified of matching path', function () {\n      var callback = jasmine.createSpy('path callback');\n      var node = {};\n      var path = [];\n      var ancestors = [];\n      oboeInstance.on('path', 'a_pattern', callback);\n      expect(callback).not.toHaveBeenCalled();\n      oboeBus('path:a_pattern').emit(node, path, ancestors);\n      expect(callback).toHaveBeenCalledWith(node, path, ancestors);\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "allows short-cut node matching",
            "suites": [
                "instance api",
                "node and path callbacks"
            ],
            "line": 87,
            "updatePoint": {
                "line": 87,
                "column": 38
            },
            "code": "    it('allows short-cut node matching', function () {\n      var pattern1Callback = jasmine.createSpy('pattern 1 callback');\n      var pattern2Callback = jasmine.createSpy('pattern 2 callback');\n      oboeInstance.on('node', {\n        pattern1: pattern1Callback,\n        pattern2: pattern2Callback\n      });\n      expect(pattern1Callback).not.toHaveBeenCalled();\n      expect(pattern2Callback).not.toHaveBeenCalled();\n      oboeBus('node:pattern1').emit({}, anAscent());\n      expect(pattern1Callback).toHaveBeenCalled();\n      expect(pattern2Callback).not.toHaveBeenCalled();\n      oboeBus('node:pattern2').emit({}, anAscent());\n      expect(pattern2Callback).toHaveBeenCalled();\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "calls node callback added using 2-arg mode when notified of match to pattern",
            "suites": [
                "instance api",
                "node and path callbacks"
            ],
            "line": 102,
            "updatePoint": {
                "line": 102,
                "column": 84
            },
            "code": "    it('calls node callback added using 2-arg mode when notified of match to pattern', function () {\n      var callback = jasmine.createSpy('node callback');\n      var node = {};\n      var path = [];\n      var ancestors = [];\n      oboeInstance.on('node:a_pattern', callback);\n      expect(callback).not.toHaveBeenCalled();\n      oboeBus('node:a_pattern').emit(node, path, ancestors);\n      expect(callback).toHaveBeenCalledWith(node, path, ancestors);\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "allows adding using addListener method",
            "suites": [
                "instance api",
                "node and path callbacks"
            ],
            "line": 112,
            "updatePoint": {
                "line": 112,
                "column": 46
            },
            "code": "    it('allows adding using addListener method', function () {\n      var callback = jasmine.createSpy('node callback');\n      var node = {};\n      var path = [];\n      var ancestors = [];\n      oboeInstance.addListener('node:a_pattern', callback);\n      expect(callback).not.toHaveBeenCalled();\n      oboeBus('node:a_pattern').emit(node, path, ancestors);\n      expect(callback).toHaveBeenCalledWith(node, path, ancestors);\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "calls path callback added using 2-arg mode when notified of match to pattern",
            "suites": [
                "instance api",
                "node and path callbacks"
            ],
            "line": 122,
            "updatePoint": {
                "line": 122,
                "column": 84
            },
            "code": "    it('calls path callback added using 2-arg mode when notified of match to pattern', function () {\n      var callback = jasmine.createSpy('path callback');\n      var node = {};\n      var path = [];\n      var ancestors = [];\n      oboeInstance.on('path:a_pattern', callback);\n      expect(callback).not.toHaveBeenCalled();\n      oboeBus('path:a_pattern').emit(node, path, ancestors);\n      expect(callback).toHaveBeenCalledWith(node, path, ancestors);\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doesn't call node callback on path found",
            "suites": [
                "instance api",
                "node and path callbacks"
            ],
            "line": 132,
            "updatePoint": {
                "line": 132,
                "column": 49
            },
            "code": "    it('doesn\\'t call node callback on path found', function () {\n      var callback = jasmine.createSpy('node callback');\n      oboeInstance.on('node', 'a_pattern', callback);\n      expect(callback).not.toHaveBeenCalled();\n      oboeBus('path:a_pattern').emit({}, list(namedNode(ROOT_PATH, {})));\n      expect(callback).not.toHaveBeenCalled();\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doesn't call again after forget called from inside callback",
            "suites": [
                "instance api",
                "node and path callbacks"
            ],
            "line": 139,
            "updatePoint": {
                "line": 139,
                "column": 68
            },
            "code": "    it('doesn\\'t call again after forget called from inside callback', function () {\n      var nodeCallback = jasmine.createSpy('node callback').and.callFake(function () {\n        this.forget();\n      });\n      var ascent = list(namedNode('node', {}));\n      oboeInstance.on('node', 'a_pattern', nodeCallback);\n      oboeBus('node:a_pattern').emit({}, ascent);\n      expect(nodeCallback.calls.count()).toBe(1);\n      oboeBus('node:a_pattern').emit({}, ascent);\n      expect(nodeCallback.calls.count()).toBe(1);\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doesn't call node callback",
            "suites": [
                "instance api",
                "node and path callbacks",
                "after callback is removed"
            ],
            "line": 154,
            "updatePoint": {
                "line": 154,
                "column": 37
            },
            "code": "      it('doesn\\'t call node callback', function () {\n        var nodeCallback = jasmine.createSpy('node callback');\n        var ascent = list(namedNode('node', {}));\n        oboeInstance.on('node', 'a_pattern', nodeCallback);\n        oboeInstance.removeListener('node', 'a_pattern', nodeCallback);\n        oboeBus('node:a_pattern').emit({}, ascent);\n        expect(nodeCallback).not.toHaveBeenCalled();\n      });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doesn't call node callback",
            "suites": [
                "instance api",
                "node and path callbacks",
                "after callback is removed",
                "using 2-arg form"
            ],
            "line": 163,
            "updatePoint": {
                "line": 163,
                "column": 39
            },
            "code": "        it('doesn\\'t call node callback', function () {\n          var nodeCallback = jasmine.createSpy('node callback');\n          var ascent = list(namedNode('node', {})); // oboeInstance.on('node', 'a_pattern', nodeCallback);\n\n          oboeInstance.on('node', 'a_pattern', nodeCallback);\n          oboeInstance.removeListener('node:a_pattern', nodeCallback);\n          oboeBus('node:a_pattern').emit({}, ascent);\n          expect(nodeCallback).not.toHaveBeenCalled();\n        });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doesn't call path callback",
            "suites": [
                "instance api",
                "node and path callbacks",
                "after callback is removed",
                "using 2-arg form"
            ],
            "line": 173,
            "updatePoint": {
                "line": 173,
                "column": 37
            },
            "code": "      it('doesn\\'t call path callback', function () {\n        var pathCallback = jasmine.createSpy('path callback');\n        var ascent = list(namedNode('path', {}));\n        oboeInstance.on('path', 'a_pattern', pathCallback);\n        oboeInstance.removeListener('path', 'a_pattern', pathCallback);\n        oboeBus('path:a_pattern').emit({}, ascent);\n        expect(pathCallback).not.toHaveBeenCalled();\n      });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doesn't call path callback after callback is removed using 2-arg form",
            "suites": [
                "instance api",
                "node and path callbacks",
                "after callback is removed",
                "using 2-arg form"
            ],
            "line": 182,
            "updatePoint": {
                "line": 182,
                "column": 78
            },
            "code": "    it('doesn\\'t call path callback after callback is removed using 2-arg form', function () {\n      var pathCallback = jasmine.createSpy('path callback');\n      var ascent = list(namedNode('path', {}));\n      oboeInstance.on('path', 'a_pattern', pathCallback);\n      oboeInstance.removeListener('path:a_pattern', pathCallback);\n      oboeBus('path:a_pattern').emit({}, ascent);\n      expect(pathCallback).not.toHaveBeenCalled();\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doesn't remove callback if wrong pattern is removed",
            "suites": [
                "instance api",
                "node and path callbacks",
                "after callback is removed",
                "using 2-arg form"
            ],
            "line": 190,
            "updatePoint": {
                "line": 190,
                "column": 60
            },
            "code": "    it('doesn\\'t remove callback if wrong pattern is removed', function () {\n      var nodeCallback = jasmine.createSpy('node callback');\n      var ascent = list(namedNode('node', {}));\n      oboeInstance.on('node', 'a_pattern', nodeCallback);\n      oboeInstance.removeListener('node', 'wrong_pattern', nodeCallback);\n      oboeBus('node:a_pattern').emit({}, ascent);\n      expect(nodeCallback).toHaveBeenCalled();\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doesn't remove callback if wrong callback is removed",
            "suites": [
                "instance api",
                "node and path callbacks",
                "after callback is removed",
                "using 2-arg form"
            ],
            "line": 198,
            "updatePoint": {
                "line": 198,
                "column": 61
            },
            "code": "    it('doesn\\'t remove callback if wrong callback is removed', function () {\n      var correctCallback = jasmine.createSpy('correct callback');\n      var wrongCallback = jasmine.createSpy('wrong callback');\n      var ascent = list(namedNode('node', {}));\n      oboeInstance.on('node', 'a_pattern', correctCallback);\n      oboeInstance.removeListener('node', 'a_pattern', wrongCallback);\n      oboeBus('node:a_pattern').emit({}, ascent);\n      expect(correctCallback).toHaveBeenCalled();\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "allows node listeners to be removed in a different style than they were added",
            "suites": [
                "instance api",
                "node and path callbacks",
                "after callback is removed",
                "using 2-arg form"
            ],
            "line": 207,
            "updatePoint": {
                "line": 207,
                "column": 85
            },
            "code": "    it('allows node listeners to be removed in a different style than they were added', function () {\n      var callback1 = jasmine.createSpy('callback 1');\n      var callback2 = jasmine.createSpy('callback 2');\n      var callback3 = jasmine.createSpy('callback 3');\n      var ascent = list(namedNode('node', {}));\n      oboeInstance.node('pattern1', callback1);\n      oboeInstance.on('node', 'pattern2', callback2);\n      oboeInstance.on('node', {\n        pattern3: callback3\n      });\n      oboeInstance.removeListener('node:pattern1', callback1);\n      oboeInstance.removeListener('node:pattern2', callback2);\n      oboeInstance.removeListener('node:pattern3', callback3);\n      oboeBus('node:pattern1').emit({}, ascent);\n      oboeBus('node:pattern2').emit({}, ascent);\n      oboeBus('node:pattern3').emit({}, ascent);\n      expect(callback1).not.toHaveBeenCalled();\n      expect(callback2).not.toHaveBeenCalled();\n      expect(callback3).not.toHaveBeenCalled();\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies .on(start) listener when http response starts",
            "suites": [
                "instance api",
                "start event"
            ],
            "line": 229,
            "updatePoint": {
                "line": 229,
                "column": 62
            },
            "code": "    it('notifies .on(start) listener when http response starts', function () {\n      var startCallback = jasmine.createSpy('start callback');\n      oboeInstance.on('start', startCallback);\n      expect(startCallback).not.toHaveBeenCalled();\n      oboeBus(HTTP_START).emit(200, {\n        a_header: 'foo'\n      });\n      expect(startCallback).toHaveBeenCalledWith(200, {\n        a_header: 'foo'\n      });\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies .start listener when http response starts",
            "suites": [
                "instance api",
                "start event"
            ],
            "line": 240,
            "updatePoint": {
                "line": 240,
                "column": 58
            },
            "code": "    it('notifies .start listener when http response starts', function () {\n      var startCallback = jasmine.createSpy('start callback');\n      oboeInstance.start(startCallback);\n      expect(startCallback).not.toHaveBeenCalled();\n      oboeBus(HTTP_START).emit(200, {\n        a_header: 'foo'\n      });\n      expect(startCallback).toHaveBeenCalledWith(200, {\n        a_header: 'foo'\n      });\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can be de-registered",
            "suites": [
                "instance api",
                "start event"
            ],
            "line": 251,
            "updatePoint": {
                "line": 251,
                "column": 28
            },
            "code": "    it('can be de-registered', function () {\n      var startCallback = jasmine.createSpy('start callback');\n      oboeInstance.on('start', startCallback);\n      oboeInstance.removeListener('start', startCallback);\n      oboeBus(HTTP_START).emit(200, {\n        a_header: 'foo'\n      });\n      expect(startCallback).not.toHaveBeenCalled();\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "calls listener on end of JSON when added using .on(done)",
            "suites": [
                "instance api",
                "done event"
            ],
            "line": 262,
            "updatePoint": {
                "line": 262,
                "column": 64
            },
            "code": "    it('calls listener on end of JSON when added using .on(done)', function () {\n      var doneCallback = jasmine.createSpy('done callback');\n      oboeInstance.on('done', doneCallback);\n      expect(doneCallback).not.toHaveBeenCalled();\n      oboeBus(ROOT_NODE_FOUND).emit({}, anAscent());\n      expect(doneCallback).toHaveBeenCalled();\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "calls listener on end of JSON when added using .done",
            "suites": [
                "instance api",
                "done event"
            ],
            "line": 269,
            "updatePoint": {
                "line": 269,
                "column": 60
            },
            "code": "    it('calls listener on end of JSON when added using .done', function () {\n      var doneCallback = jasmine.createSpy('done callback');\n      oboeInstance.done(doneCallback);\n      expect(doneCallback).not.toHaveBeenCalled();\n      oboeBus(ROOT_NODE_FOUND).emit({}, anAscent());\n      expect(doneCallback).toHaveBeenCalled();\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can be de-registered",
            "suites": [
                "instance api",
                "done event"
            ],
            "line": 276,
            "updatePoint": {
                "line": 276,
                "column": 28
            },
            "code": "    it('can be de-registered', function () {\n      var doneCallback = jasmine.createSpy('done callback');\n      oboeInstance.on('done', doneCallback);\n      oboeInstance.removeListener('done', doneCallback);\n      oboeBus('node:!').emit({}, anAscent());\n      expect(doneCallback).not.toHaveBeenCalled();\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emits ABORTING when .abort() is called",
            "suites": [
                "instance api",
                "done event"
            ],
            "line": 284,
            "updatePoint": {
                "line": 284,
                "column": 44
            },
            "code": "  it('emits ABORTING when .abort() is called', function () {\n    oboeInstance.abort();\n    expect(oboeBus(ABORTING).emit.calls.count()).toEqual(1);\n    expect(oboeBus(ABORTING).emit).toHaveBeenCalled();\n  });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies .on(fail) listener when something fails",
            "suites": [
                "instance api",
                "errors cases",
                "calling fail listener"
            ],
            "line": 291,
            "updatePoint": {
                "line": 291,
                "column": 58
            },
            "code": "      it('notifies .on(fail) listener when something fails', function () {\n        var failCallback = jasmine.createSpy('fail callback');\n        oboeInstance.on('fail', failCallback);\n        expect(failCallback).not.toHaveBeenCalled();\n        oboeBus(FAIL_EVENT).emit('something went wrong');\n        expect(failCallback).toHaveBeenCalledWith('something went wrong');\n      });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies .fail listener when something fails",
            "suites": [
                "instance api",
                "errors cases",
                "calling fail listener"
            ],
            "line": 298,
            "updatePoint": {
                "line": 298,
                "column": 54
            },
            "code": "      it('notifies .fail listener when something fails', function () {\n        var failCallback = jasmine.createSpy('fail callback');\n        oboeInstance.fail(failCallback);\n        expect(failCallback).not.toHaveBeenCalled();\n        oboeBus(FAIL_EVENT).emit('something went wrong');\n        expect(failCallback).toHaveBeenCalledWith('something went wrong');\n      });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can be de-registered",
            "suites": [
                "instance api",
                "errors cases",
                "calling fail listener"
            ],
            "line": 305,
            "updatePoint": {
                "line": 305,
                "column": 30
            },
            "code": "      it('can be de-registered', function () {\n        var failCallback = jasmine.createSpy('fail callback');\n        oboeInstance.on('fail', failCallback);\n        oboeInstance.removeListener('fail', failCallback);\n        oboeBus(FAIL_EVENT).emit('something went wrong');\n        expect(failCallback).not.toHaveBeenCalled();\n      });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is protected from error in node callback",
            "suites": [
                "instance api",
                "errors cases",
                "calling fail listener"
            ],
            "line": 313,
            "updatePoint": {
                "line": 313,
                "column": 48
            },
            "code": "    it('is protected from error in node callback', function () {\n      var e = 'an error';\n      var nodeCallback = jasmine.createSpy('nodeCallback').and.throwError(e);\n      oboeInstance.on('node', 'a_pattern', nodeCallback);\n      spyOn(window, 'setTimeout');\n      expect(function () {\n        oboeBus('node:a_pattern').emit({}, anAscent());\n      }).not.toThrow();\n      expect(nodeCallback).toHaveBeenCalled();\n      expect(window.setTimeout.calls.mostRecent().args[0]).toThrow(new Error(e));\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is protected from error in node callback added via shortcut",
            "suites": [
                "instance api",
                "errors cases",
                "calling fail listener"
            ],
            "line": 324,
            "updatePoint": {
                "line": 324,
                "column": 67
            },
            "code": "    it('is protected from error in node callback added via shortcut', function () {\n      var e = 'an error';\n      var nodeCallback = jasmine.createSpy('node callback').and.throwError(e);\n      oboeInstance.on('node', {\n        a_pattern: nodeCallback\n      });\n      spyOn(window, 'setTimeout');\n      expect(function () {\n        oboeBus('node:a_pattern').emit({}, anAscent());\n      }).not.toThrow();\n      expect(nodeCallback).toHaveBeenCalled();\n      expect(window.setTimeout.calls.mostRecent().args[0]).toThrow(new Error(e));\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is protected from error in path callback",
            "suites": [
                "instance api",
                "errors cases",
                "calling fail listener"
            ],
            "line": 337,
            "updatePoint": {
                "line": 337,
                "column": 48
            },
            "code": "    it('is protected from error in path callback', function () {\n      var e = 'an error';\n      var pathCallback = jasmine.createSpy('path callback').and.throwError(e);\n      oboeInstance.on('path', 'a_pattern', pathCallback);\n      spyOn(window, 'setTimeout');\n      expect(function () {\n        oboeBus('path:a_pattern').emit({}, anAscent());\n      }).not.toThrow();\n      expect(pathCallback).toHaveBeenCalled();\n      expect(window.setTimeout.calls.mostRecent().args[0]).toThrow(new Error(e));\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is protected from error in start callback",
            "suites": [
                "instance api",
                "errors cases",
                "calling fail listener"
            ],
            "line": 348,
            "updatePoint": {
                "line": 348,
                "column": 49
            },
            "code": "    it('is protected from error in start callback', function () {\n      var e = 'an error';\n      var startCallback = jasmine.createSpy('start callback').and.throwError(e);\n      oboeInstance.on('start', startCallback);\n      spyOn(window, 'setTimeout');\n      expect(function () {\n        oboeBus(HTTP_START).emit();\n      }).not.toThrow();\n      expect(startCallback).toHaveBeenCalled();\n      expect(window.setTimeout.calls.mostRecent().args[0]).toThrow(new Error(e));\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is protected from error in done callback",
            "suites": [
                "instance api",
                "errors cases",
                "calling fail listener"
            ],
            "line": 359,
            "updatePoint": {
                "line": 359,
                "column": 48
            },
            "code": "    it('is protected from error in done callback', function () {\n      var e = 'an error';\n      var doneCallback = jasmine.createSpy('done callback').and.throwError(e);\n      oboeInstance.done(doneCallback);\n      spyOn(window, 'setTimeout');\n      expect(function () {\n        oboeBus(ROOT_NODE_FOUND).emit({}, anAscent());\n      }).not.toThrow();\n      expect(doneCallback).toHaveBeenCalled();\n      expect(window.setTimeout.calls.mostRecent().args[0]).toThrow(new Error(e));\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can be added and fired",
            "suites": [
                "instance api",
                "unknown event types"
            ],
            "line": 376,
            "updatePoint": {
                "line": 376,
                "column": 30
            },
            "code": "    it('can be added and fired', function () {\n      var spy1 = jasmine.createSpy('xyzzy callback');\n      var spy2 = jasmine.createSpy('end of universe callback');\n\n      var setUp = function () {\n        oboeInstance.on('xyzzy', spy1).on('end_of_universe', spy2);\n      };\n\n      expect(setUp).not.toThrow();\n      oboeInstance.on('xyzzy', spy1).on('end_of_universe', spy2);\n      oboeInstance.emit('xyzzy', 'hello');\n      oboeInstance.emit('end_of_universe', 'oh no!');\n      expect(spy1).toHaveBeenCalledWith('hello');\n      expect(spy2).toHaveBeenCalledWith('oh no!');\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is allows removal",
            "suites": [
                "instance api",
                "unknown event types"
            ],
            "line": 391,
            "updatePoint": {
                "line": 391,
                "column": 25
            },
            "code": "    it('is allows removal', function () {\n      var spy1 = jasmine.createSpy('xyzzy callback');\n      var spy2 = jasmine.createSpy('end of universe callback');\n      oboeInstance.on('xyzzy', spy1).on('end_of_universe', spy2);\n      oboeInstance.removeListener('xyzzy', spy1);\n      oboeInstance.removeListener('end_of_universe', spy2);\n      oboeInstance.emit('xyzzy', 'hello');\n      oboeInstance.emit('end_of_universe', 'oh no!');\n      expect(spy1).not.toHaveBeenCalled();\n      expect(spy2).not.toHaveBeenCalled();\n    });",
            "file": "specs/instanceApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "compiles a basic pattern without throwing",
            "suites": [
                "jsonPath",
                "compiles valid syntax while rejecting invalid"
            ],
            "line": 7,
            "updatePoint": {
                "line": 7,
                "column": 49
            },
            "code": "    it('compiles a basic pattern without throwing', function () {\n      expect(compiling('!')).not.toThrow();\n    });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "fail on single invalid token",
            "suites": [
                "jsonPath",
                "compiles valid syntax while rejecting invalid",
                "syntactically invalid patterns"
            ],
            "line": 11,
            "updatePoint": {
                "line": 11,
                "column": 38
            },
            "code": "      it('fail on single invalid token', function () {\n        expect(compiling('/')).toThrow();\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "fail on invalid pattern with some valid tokens",
            "suites": [
                "jsonPath",
                "compiles valid syntax while rejecting invalid",
                "syntactically invalid patterns"
            ],
            "line": 14,
            "updatePoint": {
                "line": 14,
                "column": 56
            },
            "code": "      it('fail on invalid pattern with some valid tokens', function () {\n        expect(compiling('foo/')).toThrow();\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "fail on unclosed duck clause",
            "suites": [
                "jsonPath",
                "compiles valid syntax while rejecting invalid",
                "syntactically invalid patterns"
            ],
            "line": 17,
            "updatePoint": {
                "line": 17,
                "column": 38
            },
            "code": "      it('fail on unclosed duck clause', function () {\n        expect(compiling('{foo')).toThrow();\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "fail on token with capture alone",
            "suites": [
                "jsonPath",
                "compiles valid syntax while rejecting invalid",
                "syntactically invalid patterns"
            ],
            "line": 20,
            "updatePoint": {
                "line": 20,
                "column": 42
            },
            "code": "      it('fail on token with capture alone', function () {\n        expect(compiling('foo$')).toThrow();\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should match root",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "when pattern has only bang"
            ],
            "line": 27,
            "updatePoint": {
                "line": 27,
                "column": 27
            },
            "code": "      it('should match root', function () {\n        expect('!').toMatchPath([]);\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should miss non-root",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "when pattern has only bang"
            ],
            "line": 30,
            "updatePoint": {
                "line": 30,
                "column": 30
            },
            "code": "      it('should miss non-root', function () {\n        expect('!').not.toMatchPath(['a']);\n        expect('!').not.toMatchPath(['a', 'b']);\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should match * universally",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "when pattern has only bang"
            ],
            "line": 35,
            "updatePoint": {
                "line": 35,
                "column": 34
            },
            "code": "    it('should match * universally', function () {\n      expect('*').toMatchPath([]);\n      expect('*').toMatchPath(['a']);\n      expect('*').toMatchPath(['a', 2]);\n      expect('*').toMatchPath(['a', 'b']);\n    });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should match empty pattern universally",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "when pattern has only bang"
            ],
            "line": 41,
            "updatePoint": {
                "line": 41,
                "column": 46
            },
            "code": "    it('should match empty pattern universally', function () {\n      expect('').toMatchPath([]);\n      expect('').toMatchPath(['a']);\n      expect('').toMatchPath(['a', 2]);\n      expect('').toMatchPath(['a', 'b']);\n    });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should match !.* against any top-level path node",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "when pattern has only bang"
            ],
            "line": 47,
            "updatePoint": {
                "line": 47,
                "column": 56
            },
            "code": "    it('should match !.* against any top-level path node', function () {\n      expect('!.*').toMatchPath(['foo']);\n      expect('!.*').toMatchPath(['bar']);\n      expect('!.*').not.toMatchPath([]);\n      expect('!.*').not.toMatchPath(['foo', 'bar']);\n    });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should match !..* against anything but the root",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "when pattern has only bang"
            ],
            "line": 53,
            "updatePoint": {
                "line": 53,
                "column": 55
            },
            "code": "    it('should match !..* against anything but the root', function () {\n      expect('!..*').not.toMatchPath([]);\n      expect('!..*').toMatchPath(['a']);\n      expect('!..*').toMatchPath(['a', 'b']);\n    });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should match !.foo against foo node at first level only",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "when pattern has only bang"
            ],
            "line": 63,
            "updatePoint": {
                "line": 63,
                "column": 63
            },
            "code": "    it('should match !.foo against foo node at first level only', function () {\n      expect('!.foo').toMatchPath(['foo']);\n      expect('!.foo').not.toMatchPath([]);\n      expect('!.foo').not.toMatchPath(['foo', 'bar']);\n      expect('!.foo').not.toMatchPath(['bar']);\n    });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should match !.foo.bar against paths with foo as first node and bar as second",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "when pattern has only bang"
            ],
            "line": 69,
            "updatePoint": {
                "line": 69,
                "column": 85
            },
            "code": "    it('should match !.foo.bar against paths with foo as first node and bar as second', function () {\n      expect('!.a.b').toMatchPath(['a', 'b']);\n      expect('!.a.b').not.toMatchPath([]);\n      expect('!.a.b').not.toMatchPath(['a']);\n    });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should match !..foo against any path ending in foo",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "when pattern has only bang"
            ],
            "line": 74,
            "updatePoint": {
                "line": 74,
                "column": 58
            },
            "code": "    it('should match !..foo against any path ending in foo', function () {\n      expect('!..foo').not.toMatchPath([]);\n      expect('!..foo').toMatchPath(['foo']);\n      expect('!..foo').toMatchPath(['a', 'foo']);\n      expect('!..foo').not.toMatchPath(['a', 'foo', 'a']);\n      expect('!..foo').toMatchPath(['a', 'foo', 'foo']);\n      expect('!..foo').toMatchPath(['a', 'a', 'foo']);\n      expect('!..foo').not.toMatchPath(['a', 'a', 'foot']);\n      expect('!..foo').not.toMatchPath(['a', 'foo', 'foo', 'a']);\n    });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should match ..foo like !..foo",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "when pattern has only bang"
            ],
            "line": 84,
            "updatePoint": {
                "line": 84,
                "column": 38
            },
            "code": "    it('should match ..foo like !..foo', function () {\n      expect('..foo').not.toMatchPath([]);\n      expect('..foo').toMatchPath(['foo']);\n      expect('..foo').toMatchPath(['a', 'foo']);\n      expect('..foo').not.toMatchPath(['a', 'foo', 'a']);\n      expect('..foo').toMatchPath(['a', 'foo', 'foo']);\n      expect('..foo').toMatchPath(['a', 'a', 'foo']);\n      expect('..foo').not.toMatchPath(['a', 'a', 'foot']);\n      expect('..foo').not.toMatchPath(['a', 'foo', 'foo', 'a']);\n    });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should match foo like !..foo or ..foo",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "when pattern has only bang"
            ],
            "line": 94,
            "updatePoint": {
                "line": 94,
                "column": 45
            },
            "code": "    it('should match foo like !..foo or ..foo', function () {\n      expect('foo').not.toMatchPath([]);\n      expect('foo').toMatchPath(['foo']);\n      expect('foo').toMatchPath(['a', 'foo']);\n      expect('foo').not.toMatchPath(['a', 'foo', 'a']);\n      expect('foo').toMatchPath(['a', 'foo', 'foo']);\n      expect('foo').toMatchPath(['a', 'a', 'foo']);\n      expect('foo').not.toMatchPath(['a', 'a', 'foot']);\n      expect('foo').not.toMatchPath(['a', 'foo', 'foo', 'a']);\n    });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is not fooled by substrings in path nodes",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "when pattern has only bang"
            ],
            "line": 104,
            "updatePoint": {
                "line": 104,
                "column": 49
            },
            "code": "    it('is not fooled by substrings in path nodes', function () {\n      expect('!.foo').not.toMatchPath(['foot']);\n    });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "matches !..foo.bar against bars which are direct children of a foo anywhere in the document",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "when pattern has only bang"
            ],
            "line": 107,
            "updatePoint": {
                "line": 107,
                "column": 99
            },
            "code": "    it('matches !..foo.bar against bars which are direct children of a foo anywhere in the document', function () {\n      expect('!..foo.bar').not.toMatchPath([]);\n      expect('!..foo.bar').not.toMatchPath(['foo']);\n      expect('!..foo.bar').not.toMatchPath(['a', 'foo']);\n      expect('!..foo.bar').toMatchPath(['a', 'foo', 'bar']);\n      expect('!..foo.bar').not.toMatchPath(['a', 'foo', 'foo']);\n      expect('!..foo.bar').toMatchPath(['a', 'a', 'a', 'foo', 'bar']);\n      expect('!..foo.bar').not.toMatchPath(['a', 'a', 'a', 'foo', 'bar', 'a']);\n    });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "matches foo.bar like !..foo.bar",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "when pattern has only bang"
            ],
            "line": 116,
            "updatePoint": {
                "line": 116,
                "column": 39
            },
            "code": "    it('matches foo.bar like !..foo.bar', function () {\n      expect('foo.bar').not.toMatchPath([]);\n      expect('foo.bar').not.toMatchPath(['foo']);\n      expect('foo.bar').not.toMatchPath(['a', 'foo']);\n      expect('foo.bar').toMatchPath(['a', 'foo', 'bar']);\n      expect('foo.bar').not.toMatchPath(['a', 'foo', 'foo']);\n      expect('foo.bar').toMatchPath(['a', 'a', 'a', 'foo', 'bar']);\n      expect('foo.bar').not.toMatchPath(['a', 'a', 'a', 'foo', 'bar', 'a']);\n    });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "matches !..foo.*.bar only if there is an intermediate node between foo and bar",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "when pattern has only bang"
            ],
            "line": 125,
            "updatePoint": {
                "line": 125,
                "column": 86
            },
            "code": "    it('matches !..foo.*.bar only if there is an intermediate node between foo and bar', function () {\n      expect('!..foo.*.bar').not.toMatchPath([]);\n      expect('!..foo.*.bar').not.toMatchPath(['foo']);\n      expect('!..foo.*.bar').not.toMatchPath(['a', 'foo']);\n      expect('!..foo.*.bar').not.toMatchPath(['a', 'foo', 'bar']);\n      expect('!..foo.*.bar').toMatchPath(['a', 'foo', 'a', 'bar']);\n      expect('!..foo.*.bar').not.toMatchPath(['a', 'foo', 'foo']);\n      expect('!..foo.*.bar').not.toMatchPath(['a', 'a', 'a', 'foo', 'bar']);\n      expect('!..foo.*.bar').toMatchPath(['a', 'a', 'a', 'foo', 'a', 'bar']);\n      expect('!..foo.*.bar').not.toMatchPath(['a', 'a', 'a', 'foo', 'bar', 'a']);\n      expect('!..foo.*.bar').not.toMatchPath(['a', 'a', 'a', 'foo', 'a', 'bar', 'a']);\n    });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should be able to handle numeric nodes in object notation",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "with numeric path nodes in the pattern"
            ],
            "line": 138,
            "updatePoint": {
                "line": 138,
                "column": 67
            },
            "code": "      it('should be able to handle numeric nodes in object notation', function () {\n        expect('!.a.2').toMatchPath(['a', 2]);\n        expect('!.a.2').toMatchPath(['a', '2']);\n        expect('!.a.2').not.toMatchPath([]);\n        expect('!.a.2').not.toMatchPath(['a']);\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should be able to handle numberic nodes in array notation",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "with numeric path nodes in the pattern"
            ],
            "line": 144,
            "updatePoint": {
                "line": 144,
                "column": 67
            },
            "code": "      it('should be able to handle numberic nodes in array notation', function () {\n        expect('!.a[2]').toMatchPath(['a', 2]);\n        expect('!.a[2]').toMatchPath(['a', '2']);\n        expect('!.a[2]').not.toMatchPath([]);\n        expect('!.a[2]').not.toMatchPath(['a']);\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle adjacent array notations",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "with array notation"
            ],
            "line": 152,
            "updatePoint": {
                "line": 152,
                "column": 48
            },
            "code": "      it('should handle adjacent array notations', function () {\n        expect('![\"a\"][2]').toMatchPath(['a', 2]);\n        expect('![\"a\"][2]').toMatchPath(['a', '2']);\n        expect('![\"a\"][2]').not.toMatchPath([]);\n        expect('![\"a\"][2]').not.toMatchPath(['a']);\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should allow to specify child of root",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "with array notation"
            ],
            "line": 158,
            "updatePoint": {
                "line": 158,
                "column": 47
            },
            "code": "      it('should allow to specify child of root', function () {\n        expect('![2]').toMatchPath([2]);\n        expect('![2]').toMatchPath(['2']);\n        expect('![2]').not.toMatchPath([]);\n        expect('![2]').not.toMatchPath(['a']);\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should be allowed to contain a star",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "with array notation"
            ],
            "line": 164,
            "updatePoint": {
                "line": 164,
                "column": 45
            },
            "code": "      it('should be allowed to contain a star', function () {\n        expect('![*]').toMatchPath([2]);\n        expect('![*]').toMatchPath(['2']);\n        expect('![*]').toMatchPath(['a']);\n        expect('![*]').not.toMatchPath([]);\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should be able to handle more than one double dot",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "composition of several tokens into complex patterns"
            ],
            "line": 172,
            "updatePoint": {
                "line": 172,
                "column": 59
            },
            "code": "      it('should be able to handle more than one double dot', function () {\n        expect('!..foods..fr').toMatchPath(['foods', 2, 'name', 'fr']);\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should be able to match ..* or ..[*] as if it were * because .. matches zero nodes",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "composition of several tokens into complex patterns"
            ],
            "line": 175,
            "updatePoint": {
                "line": 175,
                "column": 92
            },
            "code": "      it('should be able to match ..* or ..[*] as if it were * because .. matches zero nodes', function () {\n        expect('!..*.bar').toMatchPath(['anything', 'bar']);\n        expect('!..[*].bar').toMatchPath(['anything', 'bar']);\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "returns deepest node when no css4-style syntax is used",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "using css4-style syntax"
            ],
            "line": 181,
            "updatePoint": {
                "line": 181,
                "column": 64
            },
            "code": "      it('returns deepest node when no css4-style syntax is used', function () {\n        expect(matchOf('l2.*').against(ascentFrom({\n          l1: {\n            l2: {\n              l3: 'leaf'\n            }\n          }\n        }))).toSpecifyNode('leaf');\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "returns correct named node",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "using css4-style syntax"
            ],
            "line": 190,
            "updatePoint": {
                "line": 190,
                "column": 36
            },
            "code": "      it('returns correct named node', function () {\n        expect(matchOf('$l2.*').against(ascentFrom({\n          l1: {\n            l2: {\n              l3: 'leaf'\n            }\n          }\n        }))).toSpecifyNode({\n          l3: 'leaf'\n        });\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "returns correct node when css4-style pattern is followed by double dot",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "using css4-style syntax"
            ],
            "line": 201,
            "updatePoint": {
                "line": 201,
                "column": 80
            },
            "code": "      it('returns correct node when css4-style pattern is followed by double dot', function () {\n        expect(matchOf('!..$foo..bar').against(ascentFrom({\n          l1: {\n            foo: {\n              l3: {\n                bar: 'leaf'\n              }\n            }\n          }\n        }))).toSpecifyNode({\n          l3: {\n            bar: 'leaf'\n          }\n        });\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can match children of root while capturing the root",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "using css4-style syntax"
            ],
            "line": 216,
            "updatePoint": {
                "line": 216,
                "column": 61
            },
            "code": "      it('can match children of root while capturing the root', function () {\n        expect(matchOf('$!.*').against(ascentFrom({\n          l1: 'leaf'\n        }))).toSpecifyNode({\n          l1: 'leaf'\n        });\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "returns captured node with array notation",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "using css4-style syntax"
            ],
            "line": 223,
            "updatePoint": {
                "line": 223,
                "column": 51
            },
            "code": "      it('returns captured node with array notation', function () {\n        expect(matchOf('$[\"l1\"].l2').against(ascentFrom({\n          l1: {\n            l2: 'leaf'\n          }\n        }))).toSpecifyNode({\n          l2: 'leaf'\n        });\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "returns captured node with array numbered notation",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "using css4-style syntax"
            ],
            "line": 232,
            "updatePoint": {
                "line": 232,
                "column": 60
            },
            "code": "      it('returns captured node with array numbered notation', function () {\n        expect(matchOf('$[\"2\"].l2').against(ascentFrom({\n          2: {\n            l2: 'leaf'\n          }\n        }))).toSpecifyNode({\n          l2: 'leaf'\n        });\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "returns captured node with star notation",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "using css4-style syntax"
            ],
            "line": 241,
            "updatePoint": {
                "line": 241,
                "column": 50
            },
            "code": "      it('returns captured node with star notation', function () {\n        expect(matchOf('!..$*.l3').against(ascentFrom({\n          l1: {\n            l2: {\n              l3: 'leaf'\n            }\n          }\n        }))).toSpecifyNode({\n          l3: 'leaf'\n        });\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "returns captured node with array star notation",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "using css4-style syntax"
            ],
            "line": 252,
            "updatePoint": {
                "line": 252,
                "column": 56
            },
            "code": "      it('returns captured node with array star notation', function () {\n        expect(matchOf('!..$[*].l3').against(ascentFrom({\n          l1: {\n            l2: {\n              l3: 'leaf'\n            }\n          }\n        }))).toSpecifyNode({\n          l3: 'leaf'\n        });\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can do basic ducking",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "with duck matching"
            ],
            "line": 265,
            "updatePoint": {
                "line": 265,
                "column": 30
            },
            "code": "      it('can do basic ducking', function () {\n        var rootJson = {\n          people: {\n            jack: {\n              name: 'Jack',\n              email: 'jack@example.com'\n            }\n          }\n        };\n        expect(matchOf('{name email}').against(asAscent(['people', 'jack'], [rootJson, rootJson.people, rootJson.people.jack]))).toSpecifyNode({\n          name: 'Jack',\n          email: 'jack@example.com'\n        });\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can duck on two levels of a path",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "with duck matching"
            ],
            "line": 279,
            "updatePoint": {
                "line": 279,
                "column": 42
            },
            "code": "      it('can duck on two levels of a path', function () {\n        var rootJson = {\n          people: {\n            jack: {\n              name: 'Jack',\n              email: 'jack@example.com'\n            }\n          }\n        };\n        expect(matchOf('{people}.{jack}.{name email}').against(asAscent(['people', 'jack'], [rootJson, rootJson.people, rootJson.people.jack]))).toSpecifyNode({\n          name: 'Jack',\n          email: 'jack@example.com'\n        });\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "fails if one duck is unsatisfied",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "with duck matching"
            ],
            "line": 293,
            "updatePoint": {
                "line": 293,
                "column": 42
            },
            "code": "      it('fails if one duck is unsatisfied', function () {\n        var rootJson = {\n          people: {\n            jack: {\n              name: 'Jack',\n              email: 'jack@example.com'\n            }\n          }\n        };\n        expect(matchOf('{people}.{alberto}.{name email}').against(asAscent(['people', 'jack'], [rootJson, rootJson.people, rootJson.people.jack]))).not.toSpecifyNode({\n          name: 'Jack',\n          email: 'jack@example.com'\n        });\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can construct the root duck type",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "with duck matching"
            ],
            "line": 307,
            "updatePoint": {
                "line": 307,
                "column": 42
            },
            "code": "      it('can construct the root duck type', function () {\n        var rootJson = {\n          people: {\n            jack: {\n              name: 'Jack',\n              email: 'jack@example.com'\n            }\n          }\n        };\n        expect(matchOf('{}').against(asAscent(['people', 'jack'], [rootJson, rootJson.people, rootJson.people.jack]))).toSpecifyNode({\n          name: 'Jack',\n          email: 'jack@example.com'\n        });\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not match if not all fields are there",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "with duck matching"
            ],
            "line": 321,
            "updatePoint": {
                "line": 321,
                "column": 52
            },
            "code": "      it('does not match if not all fields are there', function () {\n        var rootJson = {\n          people: {\n            jack: {\n              // no name here!\n              email: 'jack@example.com'\n            }\n          }\n        };\n        expect(matchOf('{name email}').against(asAscent(['people', 'jack'], [rootJson, rootJson.people, rootJson.people.jack]))).not.toSpecifyNode({\n          name: 'Jack',\n          email: 'jack@example.com'\n        });\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "fails if something upstream fails",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "with duck matching"
            ],
            "line": 335,
            "updatePoint": {
                "line": 335,
                "column": 43
            },
            "code": "      it('fails if something upstream fails', function () {\n        var rootJson = {\n          women: {\n            betty: {\n              name: 'Betty',\n              email: 'betty@example.com'\n            }\n          },\n          men: {// we don't have no menz!\n          }\n        };\n        expect(matchOf('men.{name email}').against(asAscent(['women', 'betty'], [rootJson, rootJson.women, rootJson.women.betty]))).not.toSpecifyNode({\n          name: 'Jack',\n          email: 'jack@example.com'\n        });\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not crash given ascent starting from non-objects",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "with duck matching"
            ],
            "line": 351,
            "updatePoint": {
                "line": 351,
                "column": 63
            },
            "code": "      it('does not crash given ascent starting from non-objects', function () {\n        var rootJson = [1, 2, 3];\n        expect(function () {\n          matchOf('{spin taste}').against(asAscent(['0'], [rootJson, rootJson[0]]));\n        }).not.toThrow();\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not match when given non-object",
            "suites": [
                "jsonPath",
                "patterns match correct paths",
                "with duck matching"
            ],
            "line": 357,
            "updatePoint": {
                "line": 357,
                "column": 46
            },
            "code": "      it('does not match when given non-object', function () {\n        var rootJson = [1, 2, 3];\n        expect(matchOf('{spin taste}').against(asAscent(['0'], [rootJson, rootJson[0]]))).toBeFalsy();\n      });",
            "file": "specs/jsonPath.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses zero-length list",
            "suites": [
                "json path token parser",
                "field list"
            ],
            "line": 5,
            "updatePoint": {
                "line": 5,
                "column": 33
            },
            "code": "      it('parses zero-length list', function () {\n        expect(pathNodeDesc('{}')).toContainMatches({\n          fieldList: ''\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses single field",
            "suites": [
                "json path token parser",
                "field list"
            ],
            "line": 10,
            "updatePoint": {
                "line": 10,
                "column": 29
            },
            "code": "      it('parses single field', function () {\n        expect(pathNodeDesc('{a}')).toContainMatches({\n          fieldList: 'a'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses two fields",
            "suites": [
                "json path token parser",
                "field list"
            ],
            "line": 15,
            "updatePoint": {
                "line": 15,
                "column": 27
            },
            "code": "      it('parses two fields', function () {\n        expect(pathNodeDesc('{r2 d2}')).toContainMatches({\n          fieldList: 'r2 d2'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses numeric fields",
            "suites": [
                "json path token parser",
                "field list"
            ],
            "line": 20,
            "updatePoint": {
                "line": 20,
                "column": 31
            },
            "code": "      it('parses numeric fields', function () {\n        expect(pathNodeDesc('{1 2}')).toContainMatches({\n          fieldList: '1 2'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "ignores whitespace",
            "suites": [
                "json path token parser",
                "field list"
            ],
            "line": 25,
            "updatePoint": {
                "line": 25,
                "column": 28
            },
            "code": "      it('ignores whitespace', function () {\n        expect(pathNodeDesc('{a  b}')).toContainMatches({\n          fieldList: 'a  b'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "ignores more whitespace",
            "suites": [
                "json path token parser",
                "field list"
            ],
            "line": 30,
            "updatePoint": {
                "line": 30,
                "column": 33
            },
            "code": "      it('ignores more whitespace', function () {\n        expect(pathNodeDesc('{a   b}')).toContainMatches({\n          fieldList: 'a   b'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses 3 fields",
            "suites": [
                "json path token parser",
                "field list"
            ],
            "line": 35,
            "updatePoint": {
                "line": 35,
                "column": 25
            },
            "code": "      it('parses 3 fields', function () {\n        expect(pathNodeDesc('{a  b  c}')).toContainMatches({\n          fieldList: 'a  b  c'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "needs a closing brace",
            "suites": [
                "json path token parser",
                "field list"
            ],
            "line": 40,
            "updatePoint": {
                "line": 40,
                "column": 31
            },
            "code": "      it('needs a closing brace', function () {\n        expect(pathNodeDesc('{a')).toNotMatch();\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses a name",
            "suites": [
                "json path token parser",
                "object notation"
            ],
            "line": 45,
            "updatePoint": {
                "line": 45,
                "column": 23
            },
            "code": "      it('parses a name', function () {\n        expect(pathNodeDesc('aaa')).toContainMatches({\n          name: 'aaa'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses a name containing a hyphen",
            "suites": [
                "json path token parser",
                "object notation"
            ],
            "line": 50,
            "updatePoint": {
                "line": 50,
                "column": 43
            },
            "code": "      it('parses a name containing a hyphen', function () {\n        expect(pathNodeDesc('x-security-token')).toContainMatches({\n          name: 'x-security-token'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses a name containing an underscore",
            "suites": [
                "json path token parser",
                "object notation"
            ],
            "line": 55,
            "updatePoint": {
                "line": 55,
                "column": 48
            },
            "code": "      it('parses a name containing an underscore', function () {\n        expect(pathNodeDesc('x_security_token')).toContainMatches({\n          name: 'x_security_token'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses a name and recognises the capturing flag",
            "suites": [
                "json path token parser",
                "object notation"
            ],
            "line": 60,
            "updatePoint": {
                "line": 60,
                "column": 57
            },
            "code": "      it('parses a name and recognises the capturing flag', function () {\n        expect(pathNodeDesc('$aaa')).toContainMatches({\n          name: 'aaa',\n          capturing: true\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses a name and field list",
            "suites": [
                "json path token parser",
                "object notation"
            ],
            "line": 66,
            "updatePoint": {
                "line": 66,
                "column": 38
            },
            "code": "      it('parses a name and field list', function () {\n        expect(pathNodeDesc('aaa{a b c}')).toContainMatches({\n          name: 'aaa',\n          fieldList: 'a b c'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses a name with field list and capturing flag",
            "suites": [
                "json path token parser",
                "object notation"
            ],
            "line": 72,
            "updatePoint": {
                "line": 72,
                "column": 58
            },
            "code": "      it('parses a name with field list and capturing flag', function () {\n        expect(pathNodeDesc('$aaa{a b c}')).toContainMatches({\n          name: 'aaa',\n          capturing: true,\n          fieldList: 'a b c'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "wont parse unless the name is at the start",
            "suites": [
                "json path token parser",
                "object notation"
            ],
            "line": 79,
            "updatePoint": {
                "line": 79,
                "column": 52
            },
            "code": "      it('wont parse unless the name is at the start', function () {\n        expect(pathNodeDesc('.a')).toNotMatch();\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses only the first name",
            "suites": [
                "json path token parser",
                "object notation"
            ],
            "line": 82,
            "updatePoint": {
                "line": 82,
                "column": 36
            },
            "code": "      it('parses only the first name', function () {\n        expect(pathNodeDesc('a.b')).toContainMatches({\n          name: 'a'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "ignores invalid",
            "suites": [
                "json path token parser",
                "object notation"
            ],
            "line": 87,
            "updatePoint": {
                "line": 87,
                "column": 25
            },
            "code": "      it('ignores invalid', function () {\n        expect(pathNodeDesc('$$a')).toNotMatch();\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "needs field list to close",
            "suites": [
                "json path token parser",
                "object notation"
            ],
            "line": 90,
            "updatePoint": {
                "line": 90,
                "column": 35
            },
            "code": "      it('needs field list to close', function () {\n        expect(pathNodeDesc('.a{')).toNotMatch();\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses quoted",
            "suites": [
                "json path token parser",
                "named array notation"
            ],
            "line": 95,
            "updatePoint": {
                "line": 95,
                "column": 23
            },
            "code": "      it('parses quoted', function () {\n        expect(pathNodeDesc('[\"foo\"]')).toContainMatches({\n          name: 'foo'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses quoted and capturing",
            "suites": [
                "json path token parser",
                "named array notation"
            ],
            "line": 100,
            "updatePoint": {
                "line": 100,
                "column": 37
            },
            "code": "      it('parses quoted and capturing', function () {\n        expect(pathNodeDesc('$[\"foo\"]')).toContainMatches({\n          name: 'foo',\n          capturing: true\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses quoted with field list",
            "suites": [
                "json path token parser",
                "named array notation"
            ],
            "line": 106,
            "updatePoint": {
                "line": 106,
                "column": 39
            },
            "code": "      it('parses quoted with field list', function () {\n        expect(pathNodeDesc('[\"foo\"]{a b c}')).toContainMatches({\n          name: 'foo',\n          fieldList: 'a b c'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses quoted with field list and capturing",
            "suites": [
                "json path token parser",
                "named array notation"
            ],
            "line": 112,
            "updatePoint": {
                "line": 112,
                "column": 53
            },
            "code": "      it('parses quoted with field list and capturing', function () {\n        expect(pathNodeDesc('$[\"foo\"]{a b c}')).toContainMatches({\n          name: 'foo',\n          capturing: true,\n          fieldList: 'a b c'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "ignores without a path name",
            "suites": [
                "json path token parser",
                "named array notation"
            ],
            "line": 119,
            "updatePoint": {
                "line": 119,
                "column": 37
            },
            "code": "      it('ignores without a path name', function () {\n        expect(pathNodeDesc('[]')).toNotMatch();\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "fails with too many quotes",
            "suites": [
                "json path token parser",
                "named array notation"
            ],
            "line": 122,
            "updatePoint": {
                "line": 122,
                "column": 36
            },
            "code": "      it('fails with too many quotes', function () {\n        expect(pathNodeDesc('[\"\"\"]')).toNotMatch();\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses unquoted",
            "suites": [
                "json path token parser",
                "named array notation"
            ],
            "line": 125,
            "updatePoint": {
                "line": 125,
                "column": 25
            },
            "code": "      it('parses unquoted', function () {\n        expect(pathNodeDesc('[foo]')).toNotMatch();\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "ignores unnamed because of an empty string",
            "suites": [
                "json path token parser",
                "named array notation"
            ],
            "line": 128,
            "updatePoint": {
                "line": 128,
                "column": 52
            },
            "code": "      it('ignores unnamed because of an empty string', function () {\n        expect(pathNodeDesc('[\"\"]')).toNotMatch();\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses first token only",
            "suites": [
                "json path token parser",
                "named array notation"
            ],
            "line": 131,
            "updatePoint": {
                "line": 131,
                "column": 33
            },
            "code": "      it('parses first token only', function () {\n        expect(pathNodeDesc('[\"foo\"][\"bar\"]')).toContainMatches({\n          name: 'foo'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "allows dot char inside quotes that would otherwise have a special meaning",
            "suites": [
                "json path token parser",
                "named array notation"
            ],
            "line": 136,
            "updatePoint": {
                "line": 136,
                "column": 83
            },
            "code": "      it('allows dot char inside quotes that would otherwise have a special meaning', function () {\n        expect(pathNodeDesc('[\".foo\"]')).toContainMatches({\n          name: '.foo'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "allows star char inside quotes that would otherwise have a special meaning",
            "suites": [
                "json path token parser",
                "named array notation"
            ],
            "line": 141,
            "updatePoint": {
                "line": 141,
                "column": 84
            },
            "code": "      it('allows star char inside quotes that would otherwise have a special meaning', function () {\n        expect(pathNodeDesc('[\"*\"]')).toContainMatches({\n          name: '*'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "allows dollar char inside quotes that would otherwise have a special meaning",
            "suites": [
                "json path token parser",
                "named array notation"
            ],
            "line": 146,
            "updatePoint": {
                "line": 146,
                "column": 86
            },
            "code": "      it('allows dollar char inside quotes that would otherwise have a special meaning', function () {\n        expect(pathNodeDesc('[\"$\"]')).toContainMatches({\n          name: '$'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "allows underscore in quotes",
            "suites": [
                "json path token parser",
                "named array notation"
            ],
            "line": 151,
            "updatePoint": {
                "line": 151,
                "column": 37
            },
            "code": "      it('allows underscore in quotes', function () {\n        expect(pathNodeDesc('[\"foo_bar\"]')).toContainMatches({\n          name: 'foo_bar'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "allows non-ASCII chars in quotes",
            "suites": [
                "json path token parser",
                "named array notation"
            ],
            "line": 156,
            "updatePoint": {
                "line": 156,
                "column": 42
            },
            "code": "      it('allows non-ASCII chars in quotes', function () {\n        expect(pathNodeDesc('[\"你好\"]')).toContainMatches({\n          name: '你好'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses single digit",
            "suites": [
                "json path token parser",
                "numbered array notation"
            ],
            "line": 163,
            "updatePoint": {
                "line": 163,
                "column": 29
            },
            "code": "      it('parses single digit', function () {\n        expect(pathNodeDesc('[2]')).toContainMatches({\n          name: '2'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses multiple digits",
            "suites": [
                "json path token parser",
                "numbered array notation"
            ],
            "line": 168,
            "updatePoint": {
                "line": 168,
                "column": 32
            },
            "code": "      it('parses multiple digits', function () {\n        expect(pathNodeDesc('[123]')).toContainMatches({\n          name: '123'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses with capture flag",
            "suites": [
                "json path token parser",
                "numbered array notation"
            ],
            "line": 173,
            "updatePoint": {
                "line": 173,
                "column": 34
            },
            "code": "      it('parses with capture flag', function () {\n        expect(pathNodeDesc('$[2]')).toContainMatches({\n          name: '2',\n          capturing: true\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses with field list",
            "suites": [
                "json path token parser",
                "numbered array notation"
            ],
            "line": 179,
            "updatePoint": {
                "line": 179,
                "column": 32
            },
            "code": "      it('parses with field list', function () {\n        expect(pathNodeDesc('[2]{a b c}')).toContainMatches({\n          name: '2',\n          fieldList: 'a b c'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parses with field list and capture",
            "suites": [
                "json path token parser",
                "numbered array notation"
            ],
            "line": 185,
            "updatePoint": {
                "line": 185,
                "column": 44
            },
            "code": "      it('parses with field list and capture', function () {\n        expect(pathNodeDesc('$[2]{a b c}')).toContainMatches({\n          name: '2',\n          capturing: true,\n          fieldList: 'a b c'\n        });\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "ignores without a name",
            "suites": [
                "json path token parser",
                "numbered array notation"
            ],
            "line": 192,
            "updatePoint": {
                "line": 192,
                "column": 32
            },
            "code": "      it('ignores without a name', function () {\n        expect(pathNodeDesc('[]')).toNotMatch();\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "ignores empty string as a name",
            "suites": [
                "json path token parser",
                "numbered array notation"
            ],
            "line": 195,
            "updatePoint": {
                "line": 195,
                "column": 40
            },
            "code": "      it('ignores empty string as a name', function () {\n        expect(pathNodeDesc('[\"\"]')).toNotMatch();\n      });",
            "file": "specs/jsonPathTokens.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can use cons, head and tail",
            "suites": [
                "Lists"
            ],
            "line": 8,
            "updatePoint": {
                "line": 8,
                "column": 33
            },
            "code": "  it('can use cons, head and tail', function () {\n    expect(head(listCBA)).toBe('c');\n    expect(head(tail(listCBA))).toBe('b');\n    expect(head(tail(tail(listCBA)))).toBe('a');\n  });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can convert to an array",
            "suites": [
                "Lists"
            ],
            "line": 27,
            "updatePoint": {
                "line": 27,
                "column": 29
            },
            "code": "  it('can convert to an array', function () {\n    var listCBA = cons('c', cons('b', cons('a', emptyList)));\n    expect(listAsArray(listCBA)).toEqual(['c', 'b', 'a']);\n  });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can convert empty list to an array",
            "suites": [
                "Lists"
            ],
            "line": 31,
            "updatePoint": {
                "line": 31,
                "column": 40
            },
            "code": "  it('can convert empty list to an array', function () {\n    expect(listAsArray(emptyList)).toEqual([]);\n  });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can reverse the order of a list",
            "suites": [
                "Lists"
            ],
            "line": 34,
            "updatePoint": {
                "line": 34,
                "column": 37
            },
            "code": "  it('can reverse the order of a list', function () {\n    var listCBA = cons('c', cons('b', cons('a', emptyList)));\n    expect(listAsArray(reverseList(listCBA))).toEqual(['a', 'b', 'c']);\n  });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can map over a list",
            "suites": [
                "Lists"
            ],
            "line": 38,
            "updatePoint": {
                "line": 38,
                "column": 25
            },
            "code": "  it('can map over a list', function () {\n    var naturals = cons(1, cons(2, cons(3, emptyList)));\n    var evens = cons(2, cons(4, cons(6, emptyList)));\n\n    function doubleit(n) {\n      return n * 2;\n    }\n\n    expect(map(doubleit, naturals)).toEqual(evens);\n  });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can remove from the middle of a list",
            "suites": [
                "Lists",
                "without"
            ],
            "line": 55,
            "updatePoint": {
                "line": 55,
                "column": 44
            },
            "code": "    it('can remove from the middle of a list', function () {\n      var naturals = list(1, 2, 3);\n      expect(without(naturals, equalTo(2))).toEqual(list(1, 3));\n    });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can remove from the end of a list",
            "suites": [
                "Lists",
                "without"
            ],
            "line": 59,
            "updatePoint": {
                "line": 59,
                "column": 41
            },
            "code": "    it('can remove from the end of a list', function () {\n      var naturals = list(1, 2, 3);\n      expect(without(naturals, equalTo(3))).toEqual(list(1, 2));\n    });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can not remove",
            "suites": [
                "Lists",
                "without"
            ],
            "line": 63,
            "updatePoint": {
                "line": 63,
                "column": 22
            },
            "code": "    it('can not remove', function () {\n      var naturals = list(1, 2, 3);\n      expect(without(naturals, equalTo(4))).toEqual(list(1, 2, 3));\n    });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "works with the empty list",
            "suites": [
                "Lists",
                "without"
            ],
            "line": 67,
            "updatePoint": {
                "line": 67,
                "column": 33
            },
            "code": "    it('works with the empty list', function () {\n      expect(without(emptyList, equalTo(4))).toEqual(emptyList);\n    });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can give removed item to a callback",
            "suites": [
                "Lists",
                "without"
            ],
            "line": 70,
            "updatePoint": {
                "line": 70,
                "column": 43
            },
            "code": "    it('can give removed item to a callback', function () {\n      var callback = jasmine.createSpy();\n      var naturals = list(1, 2, 3);\n      without(naturals, equalTo(2), callback);\n      expect(callback).toHaveBeenCalledWith(2);\n    });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can convert non empty list to an array",
            "suites": [
                "Lists",
                "without"
            ],
            "line": 77,
            "updatePoint": {
                "line": 77,
                "column": 44
            },
            "code": "  it('can convert non empty list to an array', function () {\n    expect(listAsArray(list('a', 'b', 'c'))).toEqual(['a', 'b', 'c']);\n  });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can convert empty array to list",
            "suites": [
                "Lists",
                "without"
            ],
            "line": 80,
            "updatePoint": {
                "line": 80,
                "column": 37
            },
            "code": "  it('can convert empty array to list', function () {\n    expect(listAsArray(arrayAsList([]))).toEqual([]);\n  });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can assert every xitem in a list holds for a given test",
            "suites": [
                "Lists",
                "without"
            ],
            "line": 83,
            "updatePoint": {
                "line": 83,
                "column": 61
            },
            "code": "  it('can assert every xitem in a list holds for a given test', function () {\n    var l = list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n\n    function isANumber(n) {\n      return typeof n === 'number';\n    }\n\n    function isOdd(n) {\n      return n % 2 === 0;\n    }\n\n    function isLessThanTen(n) {\n      return n < 10;\n    }\n\n    function isLessThanOrEqualToTen(n) {\n      return n <= 10;\n    }\n\n    expect(all(isANumber, l)).toBe(true);\n    expect(all(isOdd, l)).toBe(false);\n    expect(all(isLessThanTen, l)).toBe(false);\n    expect(all(isLessThanOrEqualToTen, l)).toBe(true);\n  });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can fold list where order doesnt matter",
            "suites": [
                "Lists",
                "foldR"
            ],
            "line": 108,
            "updatePoint": {
                "line": 108,
                "column": 47
            },
            "code": "    it('can fold list where order doesnt matter', function () {\n      function add(n, m) {\n        return n + m;\n      }\n\n      var sum = foldR(add, 0, list(1, 2, 3, 4));\n      expect(sum).toEqual(1 + 2 + 3 + 4);\n    });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can fold list where start value matters",
            "suites": [
                "Lists",
                "foldR"
            ],
            "line": 116,
            "updatePoint": {
                "line": 116,
                "column": 47
            },
            "code": "    it('can fold list where start value matters', function () {\n      function divide(n, m) {\n        return n / m;\n      }\n\n      var result = foldR(divide, 100, list(2, 2));\n      expect(result).toBe(25); //   (100/2) / 2  = 25\n    });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can fold list in the correct order",
            "suites": [
                "Lists",
                "foldR"
            ],
            "line": 124,
            "updatePoint": {
                "line": 124,
                "column": 42
            },
            "code": "    it('can fold list in the correct order', function () {\n      function functionString(param, fnName) {\n        return fnName + '(' + param + ')';\n      }\n\n      var functionStringResult = foldR(functionString, 'x', list('a', 'b', 'c')); // if order were wrong, might give c(b(a(x)))\n\n      expect(functionStringResult).toEqual('a(b(c(x)))');\n    });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can fold list where order doesnt matter",
            "suites": [
                "Lists",
                "foldR1"
            ],
            "line": 135,
            "updatePoint": {
                "line": 135,
                "column": 47
            },
            "code": "    it('can fold list where order doesnt matter', function () {\n      function add(n, m) {\n        return n + m;\n      }\n\n      var sum = foldR1(add, list(1, 2, 3, 4));\n      expect(sum).toEqual(1 + 2 + 3 + 4);\n    });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can fold list in the correct order",
            "suites": [
                "Lists",
                "foldR1"
            ],
            "line": 143,
            "updatePoint": {
                "line": 143,
                "column": 42
            },
            "code": "    it('can fold list in the correct order', function () {\n      function functionString(param, fnName) {\n        return fnName + '(' + param + ')';\n      }\n\n      var functionStringResult = foldR1(functionString, list('a', 'b', 'c')); // if order were wrong, might give c(b(a))\n\n      expect(functionStringResult).toEqual('a(b(c))');\n    });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "may apply a function with side effects to each item of a list",
            "suites": [
                "Lists",
                "foldR1"
            ],
            "line": 153,
            "updatePoint": {
                "line": 153,
                "column": 67
            },
            "code": "  it('may apply a function with side effects to each item of a list', function () {\n    var callback1 = jasmine.createSpy();\n    var callback2 = jasmine.createSpy();\n    var callback3 = jasmine.createSpy();\n    var callback4 = jasmine.createSpy();\n    var functions = list(callback1, callback2, callback3, callback4);\n    applyEach(functions, ['a', 'b', 'c', 'd']);\n    expect(callback1).toHaveBeenCalledWith('a', 'b', 'c', 'd');\n    expect(callback2).toHaveBeenCalledWith('a', 'b', 'c', 'd');\n    expect(callback3).toHaveBeenCalledWith('a', 'b', 'c', 'd');\n    expect(callback4).toHaveBeenCalledWith('a', 'b', 'c', 'd');\n  });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "may apply a list of zero functions with side effects",
            "suites": [
                "Lists",
                "foldR1"
            ],
            "line": 165,
            "updatePoint": {
                "line": 165,
                "column": 58
            },
            "code": "  it('may apply a list of zero functions with side effects', function () {\n    expect(function () {\n      applyEach(list(), ['a', 'b', 'c', 'd']);\n    }).not.toThrow();\n  });",
            "file": "specs/lists.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles empty object detected with bang",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 37,
            "updatePoint": {
                "line": 37,
                "column": 47
            },
            "code": "    it('handles empty object detected with bang', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!').whenGivenInput('{}').thenTheInstance(matched({}).atRootOfJson(), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles empty object detected with bang when explicitly selected",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 40,
            "updatePoint": {
                "line": 40,
                "column": 72
            },
            "code": "    it('handles empty object detected with bang when explicitly selected', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('$!').whenGivenInput('{}').thenTheInstance(matched({}).atRootOfJson(), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives the oboe instance as context",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 43,
            "updatePoint": {
                "line": 43,
                "column": 42
            },
            "code": "    it('gives the oboe instance as context', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!').whenGivenInput('{}').thenTheInstance(wasGivenTheOboeAsContext());\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "find only emits when has whole object",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 46,
            "updatePoint": {
                "line": 46,
                "column": 45
            },
            "code": "    it('find only emits when has whole object', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!').whenGivenInputPart('{').thenTheInstance(foundNoMatches).whenGivenInput('}').thenTheInstance(matched({}).atRootOfJson(), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emits path to listener when root object starts",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 49,
            "updatePoint": {
                "line": 49,
                "column": 54
            },
            "code": "    it('emits path to listener when root object starts', function () {\n      // clarinet doesn't notify of matches to objects (SAX_OPEN_OBJECT) until the\n      // first key is found, that is why we don't just give '{' here as the partial\n      // input.\n      givenAnOboeInstance().andWeAreListeningForPaths('!').whenGivenInputPart('{\"foo\":').thenTheInstance(foundNMatches(1), matched({}).atRootOfJson());\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emits path to listener when root array starts",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 55,
            "updatePoint": {
                "line": 55,
                "column": 53
            },
            "code": "    it('emits path to listener when root array starts', function () {\n      // clarinet doesn't notify of matches to objects (SAX_OPEN_OBJECT) until the\n      // first key is found, that is why we don't just give '{' here as the partial\n      // input.\n      givenAnOboeInstance().andWeAreListeningForPaths('!').whenGivenInputPart('[1') // the minimum string required for clarinet\n      // to emit SAX_OPEN_ARRAY. Won't emit with '['.\n      .thenTheInstance(foundNMatches(1), matched([]).atRootOfJson());\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emits empty object node detected with single star",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 63,
            "updatePoint": {
                "line": 63,
                "column": 57
            },
            "code": "    it('emits empty object node detected with single star', function () {\n      // *\n      givenAnOboeInstance().andWeAreListeningForNodes('*').whenGivenInput('{}').thenTheInstance(matched({}).atRootOfJson(), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doesnt detect spurious path off empty object",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 67,
            "updatePoint": {
                "line": 67,
                "column": 52
            },
            "code": "    it('doesnt detect spurious path off empty object', function () {\n      givenAnOboeInstance().andWeAreListeningForPaths('!.foo.*').whenGivenInput({\n        foo: {}\n      }).thenTheInstance(foundNoMatches);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles empty object detected with double dot",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 72,
            "updatePoint": {
                "line": 72,
                "column": 53
            },
            "code": "    it('handles empty object detected with double dot', function () {\n      // *\n      givenAnOboeInstance().andWeAreListeningForNodes('*').whenGivenInput('{}').thenTheInstance(matched({}).atRootOfJson(), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of strings when listened to",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 76,
            "updatePoint": {
                "line": 76,
                "column": 44
            },
            "code": "    it('notifies of strings when listened to', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!.string').whenGivenInput('{\"string\":\"s\"}').thenTheInstance(matched('s'), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can detect nodes with hyphen in the name",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 79,
            "updatePoint": {
                "line": 79,
                "column": 48
            },
            "code": "    it('can detect nodes with hyphen in the name', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!.a-string').whenGivenInput({\n        'a-string': 's'\n      }).thenTheInstance(matched('s'), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can detect nodes with underscore in the name",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 84,
            "updatePoint": {
                "line": 84,
                "column": 52
            },
            "code": "    it('can detect nodes with underscore in the name', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!.a_string').whenGivenInput({\n        a_string: 's'\n      }).thenTheInstance(matched('s'), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can detect nodes with quoted hyphen in the name",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 89,
            "updatePoint": {
                "line": 89,
                "column": 55
            },
            "code": "    it('can detect nodes with quoted hyphen in the name', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('![\"a-string\"]').whenGivenInput({\n        'a-string': 's'\n      }).thenTheInstance(matched('s'), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can detect nodes with quoted underscore in the name",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 94,
            "updatePoint": {
                "line": 94,
                "column": 59
            },
            "code": "    it('can detect nodes with quoted underscore in the name', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('![\"a_string\"]').whenGivenInput({\n        a_string: 's'\n      }).thenTheInstance(matched('s'), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can detect nodes with quoted unusual ascii chars in the name",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 99,
            "updatePoint": {
                "line": 99,
                "column": 68
            },
            "code": "    it('can detect nodes with quoted unusual ascii chars in the name', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('![\"£@$%^\"]').whenGivenInput({\n        '£@$%^': 's'\n      }) // ridiculous JSON!\n      .thenTheInstance(matched('s'), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can detect nodes with non-ascii keys",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 105,
            "updatePoint": {
                "line": 105,
                "column": 44
            },
            "code": "    it('can detect nodes with non-ascii keys', function () {\n      // pinyin: Wǒ tǎoyàn IE liúlǎn qì!\n      givenAnOboeInstance().andWeAreListeningForNodes('![\"我讨厌IE浏览器！\"]').whenGivenInput({\n        '我讨厌IE浏览器！': 'indeed!'\n      }) // ridiculous JSON!\n      .thenTheInstance(matched('indeed!'), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can detect nodes with non-ascii keys and values",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 112,
            "updatePoint": {
                "line": 112,
                "column": 55
            },
            "code": "    it('can detect nodes with non-ascii keys and values', function () {\n      // hope you have a good unicode font!\n      givenAnOboeInstance().andWeAreListeningForNodes('![\"☂\"]').whenGivenInput({\n        '☂': '☁'\n      }) // ridiculous JSON!\n      .thenTheInstance(matched('☁'), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of path before given the json value for a property",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 119,
            "updatePoint": {
                "line": 119,
                "column": 67
            },
            "code": "    it('notifies of path before given the json value for a property', function () {\n      givenAnOboeInstance().andWeAreListeningForPaths('!.string').whenGivenInputPart('{\"string\":').thenTheInstance(foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of second property name with incomplete json",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 122,
            "updatePoint": {
                "line": 122,
                "column": 61
            },
            "code": "    it('notifies of second property name with incomplete json', function () {\n      givenAnOboeInstance().andWeAreListeningForPaths('!.pencils').whenGivenInputPart('{\"pens\":4, \"pencils\":').thenTheInstance( // undefined because the parser hasn't been given the value yet.\n      // can't be null because that is an allowed value\n      matched(undefined).atPath(['pencils']), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is able to notify of null",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 127,
            "updatePoint": {
                "line": 127,
                "column": 33
            },
            "code": "    it('is able to notify of null', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!.pencils').whenGivenInput('{\"pens\":4, \"pencils\":null}').thenTheInstance( // undefined because the parser hasn't been given the value yet.\n      // can't be null because that is an allowed value\n      matched(null).atPath(['pencils']), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is able to notify of boolean true",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 132,
            "updatePoint": {
                "line": 132,
                "column": 41
            },
            "code": "    it('is able to notify of boolean true', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!.pencils').whenGivenInput('{\"pens\":false, \"pencils\":true}').thenTheInstance( // undefined because the parser hasn't been given the value yet.\n      // can't be null because that is an allowed value\n      matched(true).atPath(['pencils']), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is able to notify of boolean false",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 137,
            "updatePoint": {
                "line": 137,
                "column": 42
            },
            "code": "    it('is able to notify of boolean false', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!.pens').whenGivenInput('{\"pens\":false, \"pencils\":true}').thenTheInstance( // undefined because the parser hasn't been given the value yet.\n      // can't be null because that is an allowed value\n      matched(false).atPath(['pens']), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of multiple children of root",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 142,
            "updatePoint": {
                "line": 142,
                "column": 45
            },
            "code": "    it('notifies of multiple children of root', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!.*').whenGivenInput('{\"a\":\"A\",\"b\":\"B\",\"c\":\"C\"}').thenTheInstance(matched('A').atPath(['a']), matched('B').atPath(['b']), matched('C').atPath(['c']), foundNMatches(3));\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of multiple children of root when selecting the root",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 145,
            "updatePoint": {
                "line": 145,
                "column": 69
            },
            "code": "    it('notifies of multiple children of root when selecting the root', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('$!.*').whenGivenInput({\n        a: 'A',\n        b: 'B',\n        c: 'C'\n      }).thenTheInstance( // rather than getting the fully formed objects, we should now see the root object\n      // being grown step by step:\n      matched({\n        a: 'A'\n      }), matched({\n        a: 'A',\n        b: 'B'\n      }), matched({\n        a: 'A',\n        b: 'B',\n        c: 'C'\n      }), foundNMatches(3));\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not notify spuriously of descendant of roots when key is actually in another object",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 163,
            "updatePoint": {
                "line": 163,
                "column": 96
            },
            "code": "    it('does not notify spuriously of descendant of roots when key is actually in another object', function () {\n      givenAnOboeInstance().andWeAreListeningForPaths('!.a').whenGivenInput([{\n        a: 'a'\n      }]).thenTheInstance(foundNoMatches);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not notify spuriously of found child of root when ndoe is not child of root",
            "suites": [
                "oboe component (no http, content fed in externally)"
            ],
            "line": 168,
            "updatePoint": {
                "line": 168,
                "column": 88
            },
            "code": "    it('does not notify spuriously of found child of root when ndoe is not child of root', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!.a').whenGivenInput([{\n        a: 'a'\n      }]).thenTheInstance(foundNoMatches);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives no notification on seeing just the key",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving notification of multiple properties of an object without waiting for entire object"
            ],
            "line": 175,
            "updatePoint": {
                "line": 175,
                "column": 56
            },
            "code": "        it('gives no notification on seeing just the key', function () {\n          givenAnOboeInstance().andWeAreListeningForNodes('!.*').whenGivenInputPart('{\"a\":').thenTheInstance(foundNoMatches);\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives one notification on seeing just the first value",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving notification of multiple properties of an object without waiting for entire object"
            ],
            "line": 178,
            "updatePoint": {
                "line": 178,
                "column": 65
            },
            "code": "        it('gives one notification on seeing just the first value', function () {\n          givenAnOboeInstance().andWeAreListeningForNodes('!.*').whenGivenInputPart('{\"a\":\"A\",').thenTheInstance(matched('A').atPath(['a']), foundOneMatch);\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives another notification on seeing just the second key/value",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving notification of multiple properties of an object without waiting for entire object"
            ],
            "line": 181,
            "updatePoint": {
                "line": 181,
                "column": 74
            },
            "code": "        it('gives another notification on seeing just the second key/value', function () {\n          givenAnOboeInstance().andWeAreListeningForNodes('!.*').whenGivenInput('{\"a\":\"A\",\"b\":\"B\"}').thenTheInstance(matched('B').atPath(['b']), foundNMatches(2));\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can supply root after seeing first key with undefined value",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving root progressively as root json object is built up"
            ],
            "line": 186,
            "updatePoint": {
                "line": 186,
                "column": 71
            },
            "code": "        it('can supply root after seeing first key with undefined value', function () {\n          givenAnOboeInstance().whenGivenInputPart('{\"a\":').thenTheInstance(hasRootJson({\n            a: undefined\n          }));\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can supply root after seeing first key/value with defined value",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving root progressively as root json object is built up"
            ],
            "line": 191,
            "updatePoint": {
                "line": 191,
                "column": 75
            },
            "code": "        it('can supply root after seeing first key/value with defined value', function () {\n          givenAnOboeInstance().whenGivenInputPart('{\"a\":\"A\",').thenTheInstance(hasRootJson({\n            a: 'A'\n          }));\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives second key with undefined value",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving root progressively as root json object is built up"
            ],
            "line": 196,
            "updatePoint": {
                "line": 196,
                "column": 49
            },
            "code": "        it('gives second key with undefined value', function () {\n          givenAnOboeInstance().whenGivenInputPart('{\"a\":\"A\",\"b\":').thenTheInstance(hasRootJson({\n            a: 'A',\n            b: undefined\n          }));\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives second key with defined value",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving root progressively as root json object is built up"
            ],
            "line": 202,
            "updatePoint": {
                "line": 202,
                "column": 47
            },
            "code": "        it('gives second key with defined value', function () {\n          givenAnOboeInstance().whenGivenInput('{\"a\":\"A\",\"b\":\"B\"}').thenTheInstance(hasRootJson({\n            a: 'A',\n            b: 'B'\n          }));\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives final callback when done",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving root progressively as root json object is built up"
            ],
            "line": 208,
            "updatePoint": {
                "line": 208,
                "column": 42
            },
            "code": "        it('gives final callback when done', function () {\n          givenAnOboeInstance().whenGivenInput('{\"a\":\"A\",\"b\":\"B\"}').whenInputFinishes().thenTheInstance(gaveFinalCallbackWithRootJson({\n            a: 'A',\n            b: 'B'\n          }));\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "has nothing on array open",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving root progressively as root json array is built up"
            ],
            "line": 217,
            "updatePoint": {
                "line": 217,
                "column": 37
            },
            "code": "        it('has nothing on array open', function () {\n          givenAnOboeInstance().whenGivenInputPart('[').thenTheInstance( // I would like this to be [] but clarinet doesn't emit array found until it has seen\n          // the first element\n          hasRootJson(undefined));\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "has empty array soon afterwards",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving root progressively as root json array is built up"
            ],
            "line": 222,
            "updatePoint": {
                "line": 222,
                "column": 43
            },
            "code": "        it('has empty array soon afterwards', function () {\n          givenAnOboeInstance().whenGivenInputPart('[1').thenTheInstance( // since we haven't seen a comma yet, the 1 could be the start of a multi-digit number\n          // so nothing can be added to the root json\n          hasRootJson([]));\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "has the first element on seeing the comma",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving root progressively as root json array is built up"
            ],
            "line": 227,
            "updatePoint": {
                "line": 227,
                "column": 53
            },
            "code": "        it('has the first element on seeing the comma', function () {\n          givenAnOboeInstance().whenGivenInputPart('[11,').thenTheInstance(hasRootJson([11]));\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "has no more on seeing the start of the next element",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving root progressively as root json array is built up"
            ],
            "line": 230,
            "updatePoint": {
                "line": 230,
                "column": 63
            },
            "code": "        it('has no more on seeing the start of the next element', function () {\n          givenAnOboeInstance().whenGivenInputPart('[11,2').thenTheInstance(hasRootJson([11]));\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "has everything when the array closes",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving root progressively as root json array is built up"
            ],
            "line": 233,
            "updatePoint": {
                "line": 233,
                "column": 48
            },
            "code": "        it('has everything when the array closes', function () {\n          givenAnOboeInstance().whenGivenInput('[11,22]').thenTheInstance(hasRootJson([11, 22]));\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notified correctly of the final root",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving root progressively as root json array is built up"
            ],
            "line": 236,
            "updatePoint": {
                "line": 236,
                "column": 48
            },
            "code": "        it('notified correctly of the final root', function () {\n          givenAnOboeInstance().whenGivenInput('[11,22]').whenInputFinishes().thenTheInstance(gaveFinalCallbackWithRootJson([11, 22]));\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of named child of root",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving root progressively as root json array is built up"
            ],
            "line": 241,
            "updatePoint": {
                "line": 241,
                "column": 39
            },
            "code": "    it('notifies of named child of root', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!.b').whenGivenInput('{\"a\":\"A\",\"b\":\"B\",\"c\":\"C\"}').thenTheInstance(matched('B').atPath(['b']), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of array elements",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving root progressively as root json array is built up"
            ],
            "line": 244,
            "updatePoint": {
                "line": 244,
                "column": 34
            },
            "code": "    it('notifies of array elements', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!.testArray.*').whenGivenInput('{\"testArray\":[\"a\",\"b\",\"c\"]}').thenTheInstance(matched('a').atPath(['testArray', 0]), matched('b').atPath(['testArray', 1]), matched('c').atPath(['testArray', 2]), foundNMatches(3));\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of path match when array starts",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving root progressively as root json array is built up"
            ],
            "line": 247,
            "updatePoint": {
                "line": 247,
                "column": 48
            },
            "code": "    it('notifies of path match when array starts', function () {\n      givenAnOboeInstance().andWeAreListeningForPaths('!.testArray').whenGivenInputPart('{\"testArray\":[\"a\"').thenTheInstance(foundNMatches(1), matched(undefined) // when path is matched, it is not known yet\n      // that it contains an array. Null should not\n      // be used here because that is an allowed\n      // value in json\n      );\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of path match when second array starts",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving root progressively as root json array is built up"
            ],
            "line": 254,
            "updatePoint": {
                "line": 254,
                "column": 55
            },
            "code": "    it('notifies of path match when second array starts', function () {\n      givenAnOboeInstance().andWeAreListeningForPaths('!.array2').whenGivenInputPart('{\"array1\":[\"a\",\"b\"], \"array2\":[\"a\"').thenTheInstance(foundNMatches(1), matched(undefined) // when path is matched, it is not known yet\n      // that it contains an array. Null should not\n      // be used here because that is an allowed\n      // value in json\n      );\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of paths inside arrays",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "progressive output",
                "giving root progressively as root json array is built up"
            ],
            "line": 261,
            "updatePoint": {
                "line": 261,
                "column": 39
            },
            "code": "    it('notifies of paths inside arrays', function () {\n      givenAnOboeInstance().andWeAreListeningForPaths('![*]').whenGivenInput([{}, 'b', 2, []]).thenTheInstance(foundNMatches(4));\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "when finding objects in array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "correctly give index inside arrays"
            ],
            "line": 265,
            "updatePoint": {
                "line": 265,
                "column": 39
            },
            "code": "      it('when finding objects in array', function () {\n        givenAnOboeInstance().andWeAreListeningForPaths('![2]').whenGivenInput([{}, {}, 'this_one']).thenTheInstance(foundNMatches(1));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "when finding arrays inside array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "correctly give index inside arrays"
            ],
            "line": 268,
            "updatePoint": {
                "line": 268,
                "column": 42
            },
            "code": "      it('when finding arrays inside array', function () {\n        givenAnOboeInstance().andWeAreListeningForPaths('![2]').whenGivenInput([[], [], 'this_one']).thenTheInstance(foundNMatches(1));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "when finding arrays inside arrays etc",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "correctly give index inside arrays"
            ],
            "line": 271,
            "updatePoint": {
                "line": 271,
                "column": 47
            },
            "code": "      it('when finding arrays inside arrays etc', function () {\n        givenAnOboeInstance().andWeAreListeningForPaths('![2][2]').whenGivenInput([[], [], [[], [], ['this_array']]]).thenTheInstance(foundNMatches(1));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "when finding strings inside array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "correctly give index inside arrays"
            ],
            "line": 274,
            "updatePoint": {
                "line": 274,
                "column": 43
            },
            "code": "      it('when finding strings inside array', function () {\n        givenAnOboeInstance().andWeAreListeningForPaths('![2]').whenGivenInput(['', '', 'this_one']).thenTheInstance(foundNMatches(1));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "when finding numbers inside array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "correctly give index inside arrays"
            ],
            "line": 277,
            "updatePoint": {
                "line": 277,
                "column": 43
            },
            "code": "      it('when finding numbers inside array', function () {\n        givenAnOboeInstance().andWeAreListeningForPaths('![2]').whenGivenInput([1, 1, 'this_one']).thenTheInstance(foundNMatches(1));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "when finding nulls inside array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "correctly give index inside arrays"
            ],
            "line": 280,
            "updatePoint": {
                "line": 280,
                "column": 41
            },
            "code": "      it('when finding nulls inside array', function () {\n        givenAnOboeInstance().andWeAreListeningForPaths('![2]').whenGivenInput([null, null, 'this_one']).thenTheInstance(foundNMatches(1));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of paths inside objects",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "correctly give index inside arrays"
            ],
            "line": 284,
            "updatePoint": {
                "line": 284,
                "column": 40
            },
            "code": "    it('notifies of paths inside objects', function () {\n      givenAnOboeInstance().andWeAreListeningForPaths('![*]').whenGivenInput({\n        a: {},\n        b: 'b',\n        c: 2,\n        d: []\n      }).thenTheInstance(foundNMatches(4));\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of array elements",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "selecting by index"
            ],
            "line": 293,
            "updatePoint": {
                "line": 293,
                "column": 36
            },
            "code": "      it('notifies of array elements', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('!.testArray[2]').whenGivenInput('{\"testArray\":[\"a\",\"b\",\"this_one\"]}').thenTheInstance(matched('this_one').atPath(['testArray', 2]), foundOneMatch);\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies nested array elements",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "selecting by index"
            ],
            "line": 296,
            "updatePoint": {
                "line": 296,
                "column": 40
            },
            "code": "      it('notifies nested array elements', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('!.testArray[2][2]').whenGivenInput({\n          testArray: ['a', 'b', ['x', 'y', 'this_one']]\n        }).thenTheInstance(matched('this_one').atPath(['testArray', 2, 2]).withParent(['x', 'y', 'this_one']).withGrandparent(['a', 'b', ['x', 'y', 'this_one']]), foundOneMatch);\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can notify nested array elements by passing the root array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "selecting by index"
            ],
            "line": 301,
            "updatePoint": {
                "line": 301,
                "column": 68
            },
            "code": "      it('can notify nested array elements by passing the root array', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('!.$testArray[2][2]').whenGivenInput({\n          testArray: ['a', 'b', ['x', 'y', 'this_one']]\n        }).thenTheInstance(matched(['a', 'b', ['x', 'y', 'this_one']]), foundOneMatch);\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies with star pattern",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "deeply nested objects"
            ],
            "line": 308,
            "updatePoint": {
                "line": 308,
                "column": 36
            },
            "code": "      it('notifies with star pattern', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('*').whenGivenInput({\n          a: {\n            b: {\n              c: {\n                d: 'e'\n              }\n            }\n          }\n        }).thenTheInstance(matched('e').atPath(['a', 'b', 'c', 'd']).withParent({\n          d: 'e'\n        }), matched({\n          d: 'e'\n        }).atPath(['a', 'b', 'c']), matched({\n          c: {\n            d: 'e'\n          }\n        }).atPath(['a', 'b']), matched({\n          b: {\n            c: {\n              d: 'e'\n            }\n          }\n        }).atPath(['a']), matched({\n          a: {\n            b: {\n              c: {\n                d: 'e'\n              }\n            }\n          }\n        }).atRootOfJson(), foundNMatches(5));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of with double dot pattern",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "deeply nested objects"
            ],
            "line": 341,
            "updatePoint": {
                "line": 341,
                "column": 45
            },
            "code": "      it('notifies of with double dot pattern', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('..').whenGivenInput({\n          a: {\n            b: {\n              c: {\n                d: 'e'\n              }\n            }\n          }\n        }).thenTheInstance(matched('e').atPath(['a', 'b', 'c', 'd']).withParent({\n          d: 'e'\n        }), matched({\n          d: 'e'\n        }).atPath(['a', 'b', 'c']), matched({\n          c: {\n            d: 'e'\n          }\n        }).atPath(['a', 'b']), matched({\n          b: {\n            c: {\n              d: 'e'\n            }\n          }\n        }).atPath(['a']), matched({\n          a: {\n            b: {\n              c: {\n                d: 'e'\n              }\n            }\n          }\n        }).atRootOfJson(), foundNMatches(5));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of objects with double dot star pattern",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "deeply nested objects"
            ],
            "line": 374,
            "updatePoint": {
                "line": 374,
                "column": 58
            },
            "code": "      it('notifies of objects with double dot star pattern', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('..*').whenGivenInput({\n          a: {\n            b: {\n              c: {\n                d: 'e'\n              }\n            }\n          }\n        }).thenTheInstance(matched('e').atPath(['a', 'b', 'c', 'd']).withParent({\n          d: 'e'\n        }), matched({\n          d: 'e'\n        }).atPath(['a', 'b', 'c']), matched({\n          c: {\n            d: 'e'\n          }\n        }).atPath(['a', 'b']), matched({\n          b: {\n            c: {\n              d: 'e'\n            }\n          }\n        }).atPath(['a']), matched({\n          a: {\n            b: {\n              c: {\n                d: 'e'\n              }\n            }\n          }\n        }).atRootOfJson(), foundNMatches(5));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can express all but root as a pattern",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "deeply nested objects"
            ],
            "line": 408,
            "updatePoint": {
                "line": 408,
                "column": 45
            },
            "code": "    it('can express all but root as a pattern', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('*..*').whenGivenInput({\n        a: {\n          b: {\n            c: {\n              d: 'e'\n            }\n          }\n        }\n      }).thenTheInstance(matched('e').atPath(['a', 'b', 'c', 'd']).withParent({\n        d: 'e'\n      }), matched({\n        d: 'e'\n      }).atPath(['a', 'b', 'c']), matched({\n        c: {\n          d: 'e'\n        }\n      }).atPath(['a', 'b']), matched({\n        b: {\n          c: {\n            d: 'e'\n          }\n        }\n      }).atPath(['a']), foundNMatches(4));\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can detect similar ancestors",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "deeply nested objects"
            ],
            "line": 433,
            "updatePoint": {
                "line": 433,
                "column": 36
            },
            "code": "    it('can detect similar ancestors', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('foo..foo').whenGivenInput({\n        foo: {\n          foo: {\n            foo: {\n              foo: 'foo'\n            }\n          }\n        }\n      }).thenTheInstance(matched('foo'), matched({\n        foo: 'foo'\n      }), matched({\n        foo: {\n          foo: 'foo'\n        }\n      }), matched({\n        foo: {\n          foo: {\n            foo: 'foo'\n          }\n        }\n      }), foundNMatches(4));\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can detect inside the second object element of an array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "deeply nested objects"
            ],
            "line": 456,
            "updatePoint": {
                "line": 456,
                "column": 63
            },
            "code": "    it('can detect inside the second object element of an array', function () {\n      // this fails in incrementalJsonBuilder if we don't set the curKey to the\n      // length of the array when we detect an object and and the parent of the\n      // object that ended was an array\n      givenAnOboeInstance().andWeAreListeningForNodes('!..find').whenGivenInput({\n        array: [{\n          a: 'A'\n        }, {\n          find: 'should_find_this'\n        }]\n      }).thenTheInstance(matched('should_find_this').atPath(['array', 1, 'find']));\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "ignores keys if only start matches",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "deeply nested objects"
            ],
            "line": 468,
            "updatePoint": {
                "line": 468,
                "column": 42
            },
            "code": "    it('ignores keys if only start matches', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!..a').whenGivenInput({\n        ab: 'should_not_find_this',\n        a0: 'nor this',\n        a: 'but_should_find_this'\n      }).thenTheInstance(matched('but_should_find_this'), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "ignores keys if only end of pattern matches",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "deeply nested objects"
            ],
            "line": 475,
            "updatePoint": {
                "line": 475,
                "column": 51
            },
            "code": "    it('ignores keys if only end of pattern matches', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!..a').whenGivenInput({\n        aa: 'should_not_find_this',\n        ba: 'nor this',\n        a: 'but_should_find_this'\n      }).thenTheInstance(matched('but_should_find_this'), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "ignores partial path matches in array indices",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "deeply nested objects"
            ],
            "line": 482,
            "updatePoint": {
                "line": 482,
                "column": 53
            },
            "code": "    it('ignores partial path matches in array indices', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!..[1]').whenGivenInput({\n        array: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n      }).thenTheInstance(matched(1).withParent([0, 1]), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can give an array back when just partially done",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "deeply nested objects"
            ],
            "line": 487,
            "updatePoint": {
                "line": 487,
                "column": 55
            },
            "code": "    it('can give an array back when just partially done', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('$![5]').whenGivenInput([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]).thenTheInstance(matched([0, 1, 2, 3, 4, 5]), foundOneMatch);\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives parent and grandparent for every item of an array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 491,
            "updatePoint": {
                "line": 491,
                "column": 65
            },
            "code": "      it('gives parent and grandparent for every item of an array', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('!.array.*').whenGivenInput({\n          array: ['a', 'b', 'c']\n        }).thenTheInstance(matched('a').withParent(['a']).withGrandparent({\n          array: ['a']\n        }), matched('b').withParent(['a', 'b']).withGrandparent({\n          array: ['a', 'b']\n        }), matched('c').withParent(['a', 'b', 'c']).withGrandparent({\n          array: ['a', 'b', 'c']\n        }));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is correct for array of objects",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 502,
            "updatePoint": {
                "line": 502,
                "column": 41
            },
            "code": "      it('is correct for array of objects', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('!.array.*').whenGivenInput({\n          array: [{\n            a: 1\n          }, {\n            b: 2\n          }, {\n            c: 3\n          }]\n        }).thenTheInstance(matched({\n          a: 1\n        }).withParent([{\n          a: 1\n        }]), matched({\n          b: 2\n        }).withParent([{\n          a: 1\n        }, {\n          b: 2\n        }]), matched({\n          c: 3\n        }).withParent([{\n          a: 1\n        }, {\n          b: 2\n        }, {\n          c: 3\n        }]));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is correct for object in a mixed array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 531,
            "updatePoint": {
                "line": 531,
                "column": 48
            },
            "code": "      it('is correct for object in a mixed array', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('!.array.*').whenGivenInput({\n          array: [{\n            a: 1\n          }, 'b', {\n            c: 3\n          }, {}, ['d'], 'e']\n        }).thenTheInstance(matched({\n          a: 1\n        }).withParent([{\n          a: 1\n        }]));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "has correct parent for string in mixed array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 544,
            "updatePoint": {
                "line": 544,
                "column": 54
            },
            "code": "      it('has correct parent for string in mixed array', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('!.array.*').whenGivenInput({\n          array: [{\n            a: 1\n          }, 'b', {\n            c: 3\n          }, {}, ['d'], 'e']\n        }).thenTheInstance(matched('b').withParent([{\n          a: 1\n        }, 'b']));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "has correct parent for second object in mixed array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 555,
            "updatePoint": {
                "line": 555,
                "column": 61
            },
            "code": "      it('has correct parent for second object in mixed array', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('!.array.*').whenGivenInput({\n          array: [{\n            a: 1\n          }, 'b', {\n            c: 3\n          }, {}, ['d'], 'e']\n        }).thenTheInstance(matched({\n          c: 3\n        }).withParent([{\n          a: 1\n        }, 'b', {\n          c: 3\n        }]));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "has correct parent for empty object in mixed array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 570,
            "updatePoint": {
                "line": 570,
                "column": 60
            },
            "code": "      it('has correct parent for empty object in mixed array', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('!.array.*').whenGivenInput({\n          array: [{\n            a: 1\n          }, 'b', {\n            c: 3\n          }, {}, ['d'], 'e']\n        }).thenTheInstance(matched({}).withParent([{\n          a: 1\n        }, 'b', {\n          c: 3\n        }, {}]));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "has correct parent for singleton string array in mixed array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 583,
            "updatePoint": {
                "line": 583,
                "column": 70
            },
            "code": "      it('has correct parent for singleton string array in mixed array', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('!.array.*').whenGivenInput({\n          array: [{\n            a: 1\n          }, 'b', {\n            c: 3\n          }, {}, ['d'], 'e']\n        }).thenTheInstance(matched(['d']).withParent([{\n          a: 1\n        }, 'b', {\n          c: 3\n        }, {}, ['d']]));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives correct parent for singleton string array in singleton array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 596,
            "updatePoint": {
                "line": 596,
                "column": 76
            },
            "code": "      it('gives correct parent for singleton string array in singleton array', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('!.array.*').whenGivenInput({\n          array: [['d']]\n        }).thenTheInstance(matched(['d']).withParent([['d']]));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives correct parent for last string in a mixed array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 601,
            "updatePoint": {
                "line": 601,
                "column": 63
            },
            "code": "      it('gives correct parent for last string in a mixed array', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('!.array.*').whenGivenInput({\n          array: [{\n            a: 1\n          }, 'b', {\n            c: 3\n          }, {}, ['d'], 'e']\n        }).thenTheInstance(matched('e').withParent([{\n          a: 1\n        }, 'b', {\n          c: 3\n        }, {}, ['d'], 'e']));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives correct parent for opening object in a mixed array at root of json",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 614,
            "updatePoint": {
                "line": 614,
                "column": 82
            },
            "code": "      it('gives correct parent for opening object in a mixed array at root of json', function () {\n        // same test as above but without the object wrapper around the array:\n        givenAnOboeInstance().andWeAreListeningForNodes('!.*').whenGivenInput([{\n          a: 1\n        }, 'b', {\n          c: 3\n        }, {}, ['d'], 'e']).thenTheInstance(matched({\n          a: 1\n        }).withParent([{\n          a: 1\n        }]));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives correct parent for string in a mixed array at root of json",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 626,
            "updatePoint": {
                "line": 626,
                "column": 74
            },
            "code": "      it('gives correct parent for string in a mixed array at root of json', function () {\n        // same test as above but without the object wrapper around the array:\n        givenAnOboeInstance().andWeAreListeningForNodes('!.*').whenGivenInput([{\n          a: 1\n        }, 'b', {\n          c: 3\n        }, {}, ['d'], 'e']).thenTheInstance(matched('b').withParent([{\n          a: 1\n        }, 'b']));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives correct parent for second object in a mixed array at root of json",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 636,
            "updatePoint": {
                "line": 636,
                "column": 81
            },
            "code": "      it('gives correct parent for second object in a mixed array at root of json', function () {\n        // same test as above but without the object wrapper around the array:\n        givenAnOboeInstance().andWeAreListeningForNodes('!.*').whenGivenInput([{\n          a: 1\n        }, 'b', {\n          c: 3\n        }, {}, ['d'], 'e']).thenTheInstance(matched({\n          c: 3\n        }).withParent([{\n          a: 1\n        }, 'b', {\n          c: 3\n        }]));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives correct parent for empty object in a mixed array at root of json",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 650,
            "updatePoint": {
                "line": 650,
                "column": 80
            },
            "code": "      it('gives correct parent for empty object in a mixed array at root of json', function () {\n        // same test as above but without the object wrapper around the array:\n        givenAnOboeInstance().andWeAreListeningForNodes('!.*').whenGivenInput([{\n          a: 1\n        }, 'b', {\n          c: 3\n        }, {}, ['d'], 'e']).thenTheInstance(matched({}).withParent([{\n          a: 1\n        }, 'b', {\n          c: 3\n        }, {}]));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives correct parent for singleton string array in a mixed array at root of json",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 662,
            "updatePoint": {
                "line": 662,
                "column": 90
            },
            "code": "      it('gives correct parent for singleton string array in a mixed array at root of json', function () {\n        // same test as above but without the object wrapper around the array:\n        givenAnOboeInstance().andWeAreListeningForNodes('!.*').whenGivenInput([{\n          a: 1\n        }, 'b', {\n          c: 3\n        }, {}, ['d'], 'e']).thenTheInstance(matched(['d']).withParent([{\n          a: 1\n        }, 'b', {\n          c: 3\n        }, {}, ['d']]));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives correct parent for singleton string array in a singleton array at root of json",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 674,
            "updatePoint": {
                "line": 674,
                "column": 94
            },
            "code": "      it('gives correct parent for singleton string array in a singleton array at root of json', function () {\n        // non-mixed array, easier version:\n        givenAnOboeInstance().andWeAreListeningForNodes('!.*').whenGivenInput([['d']]).thenTheInstance(matched(['d']).withParent([['d']]));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives correct parent for final string in a mixed array at root of json",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 678,
            "updatePoint": {
                "line": 678,
                "column": 80
            },
            "code": "      it('gives correct parent for final string in a mixed array at root of json', function () {\n        // same test as above but without the object wrapper around the array:\n        givenAnOboeInstance().andWeAreListeningForNodes('!.*').whenGivenInput([{\n          a: 1\n        }, 'b', {\n          c: 3\n        }, {}, ['d'], 'e']).thenTheInstance(matched('e').withParent([{\n          a: 1\n        }, 'b', {\n          c: 3\n        }, {}, ['d'], 'e']));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can detect at multiple depths using double dot",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 691,
            "updatePoint": {
                "line": 691,
                "column": 54
            },
            "code": "    it('can detect at multiple depths using double dot', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!..find').whenGivenInput({\n        array: [{\n          find: 'first_find'\n        }, {\n          padding: {\n            find: 'second_find'\n          },\n          find: 'third_find'\n        }],\n        find: {\n          find: 'fourth_find'\n        }\n      }).thenTheInstance(matched('first_find').atPath(['array', 0, 'find']), matched('second_find').atPath(['array', 1, 'padding', 'find']), matched('third_find').atPath(['array', 1, 'find']), matched('fourth_find').atPath(['find', 'find']), matched({\n        find: 'fourth_find'\n      }).atPath(['find']), foundNMatches(5));\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "passes ancestors of found object correctly",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 708,
            "updatePoint": {
                "line": 708,
                "column": 50
            },
            "code": "    it('passes ancestors of found object correctly', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!..find').whenGivenInput({\n        array: [{\n          find: 'first_find'\n        }, {\n          padding: {\n            find: 'second_find'\n          },\n          find: 'third_find'\n        }],\n        find: {\n          find: 'fourth_find'\n        }\n      }).thenTheInstance(matched('first_find').withParent({\n        find: 'first_find'\n      }).withGrandparent([{\n        find: 'first_find'\n      }]), matched('second_find').withParent({\n        find: 'second_find'\n      }).withGrandparent({\n        padding: {\n          find: 'second_find'\n        }\n      }), matched('third_find').withParent({\n        padding: {\n          find: 'second_find'\n        },\n        find: 'third_find'\n      }).withGrandparent([{\n        find: 'first_find'\n      }, {\n        padding: {\n          find: 'second_find'\n        },\n        find: 'third_find'\n      }]));\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can detect at multiple depths using implied ancestor of root relationship",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 745,
            "updatePoint": {
                "line": 745,
                "column": 81
            },
            "code": "    it('can detect at multiple depths using implied ancestor of root relationship', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('find').whenGivenInput({\n        array: [{\n          find: 'first_find'\n        }, {\n          padding: {\n            find: 'second_find'\n          },\n          find: 'third_find'\n        }],\n        find: {\n          find: 'fourth_find'\n        }\n      }).thenTheInstance(matched('first_find').atPath(['array', 0, 'find']), matched('second_find').atPath(['array', 1, 'padding', 'find']), matched('third_find').atPath(['array', 1, 'find']), matched('fourth_find').atPath(['find', 'find']), matched({\n        find: 'fourth_find'\n      }).atPath(['find']), foundNMatches(5));\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "matches nested adjacent selector",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 762,
            "updatePoint": {
                "line": 762,
                "column": 40
            },
            "code": "    it('matches nested adjacent selector', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!..[0].colour').whenGivenInput({\n        foods: [{\n          name: 'aubergine',\n          colour: 'purple' // match this\n\n        }, {\n          name: 'apple',\n          colour: 'red'\n        }, {\n          name: 'nuts',\n          colour: 'brown'\n        }],\n        non_foods: [{\n          name: 'brick',\n          colour: 'red' // and this\n\n        }, {\n          name: 'poison',\n          colour: 'pink'\n        }, {\n          name: 'broken_glass',\n          colour: 'green'\n        }]\n      }).thenTheInstance(matched('purple'), matched('red'), foundNMatches(2));\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "matches nested selector separated by a single star selector",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 788,
            "updatePoint": {
                "line": 788,
                "column": 67
            },
            "code": "    it('matches nested selector separated by a single star selector', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('!..foods.*.name').whenGivenInput({\n        foods: [{\n          name: 'aubergine',\n          colour: 'purple'\n        }, {\n          name: 'apple',\n          colour: 'red'\n        }, {\n          name: 'nuts',\n          colour: 'brown'\n        }],\n        non_foods: [{\n          name: 'brick',\n          colour: 'red'\n        }, {\n          name: 'poison',\n          colour: 'pink'\n        }, {\n          name: 'broken_glass',\n          colour: 'green'\n        }]\n      }).thenTheInstance(matched('aubergine'), matched('apple'), matched('nuts'), foundNMatches(3));\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gets all simple objects from an array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 812,
            "updatePoint": {
                "line": 812,
                "column": 45
            },
            "code": "    it('gets all simple objects from an array', function () {\n      // this test is similar to the following one, except it does not use ! in the pattern\n      givenAnOboeInstance().andWeAreListeningForNodes('foods.*').whenGivenInput({\n        foods: [{\n          name: 'aubergine'\n        }, {\n          name: 'apple'\n        }, {\n          name: 'nuts'\n        }]\n      }).thenTheInstance(foundNMatches(3), matched({\n        name: 'aubergine'\n      }), matched({\n        name: 'apple'\n      }), matched({\n        name: 'nuts'\n      }));\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gets same object repeatedly using css4 syntax",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 830,
            "updatePoint": {
                "line": 830,
                "column": 53
            },
            "code": "    it('gets same object repeatedly using css4 syntax', function () {\n      givenAnOboeInstance().andWeAreListeningForNodes('$foods.*').whenGivenInput({\n        foods: [{\n          name: 'aubergine'\n        }, {\n          name: 'apple'\n        }, {\n          name: 'nuts'\n        }]\n      }) // essentially, the parser should have been called three times with the same object, but each time\n      // an additional item should have been added\n      .thenTheInstance(foundNMatches(3), matched([{\n        name: 'aubergine'\n      }]), matched([{\n        name: 'aubergine'\n      }, {\n        name: 'apple'\n      }]), matched([{\n        name: 'aubergine'\n      }, {\n        name: 'apple'\n      }, {\n        name: 'nuts'\n      }]));\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "matches nested selector separated by double dot",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "json arrays give correct parent and grandparent"
            ],
            "line": 855,
            "updatePoint": {
                "line": 855,
                "column": 55
            },
            "code": "    it('matches nested selector separated by double dot', function () {\n      givenAnOboeInstance() // we just want the French names of foods:\n      .andWeAreListeningForNodes('!..foods..fr').whenGivenInput({\n        foods: [{\n          name: {\n            en: 'aubergine',\n            fr: 'aubergine'\n          },\n          colour: 'purple'\n        }, {\n          name: {\n            en: 'apple',\n            fr: 'pomme'\n          },\n          colour: 'red'\n        }, {\n          name: {\n            en: 'nuts',\n            fr: 'noix'\n          },\n          colour: 'brown'\n        }],\n        non_foods: [{\n          name: {\n            en: 'brick'\n          },\n          colour: 'red'\n        }, {\n          name: {\n            en: 'poison'\n          },\n          colour: 'pink'\n        }, {\n          name: {\n            en: 'broken_glass'\n          },\n          colour: 'green'\n        }]\n      }).thenTheInstance(matched('aubergine'), matched('pomme'), matched('noix'), foundNMatches(3));\n    });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can detect",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "duck types"
            ],
            "line": 897,
            "updatePoint": {
                "line": 897,
                "column": 20
            },
            "code": "      it('can detect', function () {\n        givenAnOboeInstance() // we want the bi-lingual objects\n        .andWeAreListeningForNodes('{en fr}').whenGivenInput({\n          foods: [{\n            name: {\n              en: 'aubergine',\n              fr: 'aubergine'\n            },\n            colour: 'purple'\n          }, {\n            name: {\n              en: 'apple',\n              fr: 'pomme'\n            },\n            colour: 'red'\n          }, {\n            name: {\n              en: 'nuts',\n              fr: 'noix'\n            },\n            colour: 'brown'\n          }],\n          non_foods: [{\n            name: {\n              en: 'brick'\n            },\n            colour: 'red'\n          }, {\n            name: {\n              en: 'poison'\n            },\n            colour: 'pink'\n          }, {\n            name: {\n              en: 'broken_glass'\n            },\n            colour: 'green'\n          }]\n        }).thenTheInstance(matched({\n          en: 'aubergine',\n          fr: 'aubergine'\n        }), matched({\n          en: 'apple',\n          fr: 'pomme'\n        }), matched({\n          en: 'nuts',\n          fr: 'noix'\n        }), foundNMatches(3));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can detect by matches with additional keys",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "duck types"
            ],
            "line": 946,
            "updatePoint": {
                "line": 946,
                "column": 52
            },
            "code": "      it('can detect by matches with additional keys', function () {\n        givenAnOboeInstance() // we want the bi-lingual English and German words, but we still want the ones that have\n        // French as well\n        .andWeAreListeningForNodes('{en de}').whenGivenInput({\n          foods: [{\n            name: {\n              en: 'aubergine',\n              fr: 'aubergine',\n              de: 'aubergine'\n            },\n            colour: 'purple'\n          }, {\n            name: {\n              en: 'apple',\n              fr: 'pomme',\n              de: 'apfel'\n            },\n            colour: 'red'\n          }, {\n            name: {\n              en: 'nuts',\n              de: 'eier'\n            },\n            colour: 'brown'\n          }],\n          non_foods: [{\n            name: {\n              en: 'brick'\n            },\n            colour: 'red'\n          }, {\n            name: {\n              en: 'poison'\n            },\n            colour: 'pink'\n          }, {\n            name: {\n              en: 'broken_glass'\n            },\n            colour: 'green'\n          }]\n        }).thenTheInstance(matched({\n          en: 'aubergine',\n          fr: 'aubergine',\n          de: 'aubergine'\n        }), matched({\n          en: 'apple',\n          fr: 'pomme',\n          de: 'apfel'\n        }), matched({\n          en: 'nuts',\n          de: 'eier'\n        }), foundNMatches(3));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "fed in as a lump",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "error cases:",
                "errors on unquoted keys"
            ],
            "line": 1007,
            "updatePoint": {
                "line": 1007,
                "column": 28
            },
            "code": "        it('fed in as a lump', function () {\n          givenAnOboeInstance().andWeAreExpectingSomeErrors().whenGivenInputPart(invalidJson).thenTheInstance(calledCallbackOnce, wasPassedAnErrorObject);\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "fed a char at a time",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "error cases:",
                "errors on unquoted keys"
            ],
            "line": 1010,
            "updatePoint": {
                "line": 1010,
                "column": 32
            },
            "code": "        it('fed a char at a time', function () {\n          givenAnOboeInstance().andWeAreExpectingSomeErrors().whenGivenInputOneCharAtATime(invalidJson).thenTheInstance(calledCallbackOnce, wasPassedAnErrorObject);\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "works as a lump",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "error cases:",
                "errors on malformed json"
            ],
            "line": 1017,
            "updatePoint": {
                "line": 1017,
                "column": 27
            },
            "code": "        it('works as a lump', function () {\n          givenAnOboeInstance().andWeAreExpectingSomeErrors().whenGivenInputPart(malformedJson).thenTheInstance(calledCallbackOnce, wasPassedAnErrorObject);\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "works as chars",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "error cases:",
                "errors on malformed json"
            ],
            "line": 1020,
            "updatePoint": {
                "line": 1020,
                "column": 26
            },
            "code": "        it('works as chars', function () {\n          givenAnOboeInstance().andWeAreExpectingSomeErrors().whenGivenInputOneCharAtATime(malformedJson) // invalid!\n          .thenTheInstance(calledCallbackOnce, wasPassedAnErrorObject);\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detects error when stream halts early between children of root",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "error cases:",
                "errors on malformed json"
            ],
            "line": 1025,
            "updatePoint": {
                "line": 1025,
                "column": 72
            },
            "code": "      it('detects error when stream halts early between children of root', function () {\n        givenAnOboeInstance().andWeAreExpectingSomeErrors().whenGivenInputPart('[[1,2,3],[4,5').whenInputFinishes().thenTheInstance(calledCallbackOnce, wasPassedAnErrorObject);\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detects error when stream halts early between children of root fed in a char at a time",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "error cases:",
                "errors on malformed json"
            ],
            "line": 1028,
            "updatePoint": {
                "line": 1028,
                "column": 96
            },
            "code": "      it('detects error when stream halts early between children of root fed in a char at a time', function () {\n        givenAnOboeInstance().andWeAreExpectingSomeErrors().whenGivenInputOneCharAtATime('[[1,2,3],[4,5').whenInputFinishes().thenTheInstance(calledCallbackOnce, wasPassedAnErrorObject);\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detects error when stream halts early between children of root",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "error cases:",
                "errors on malformed json"
            ],
            "line": 1031,
            "updatePoint": {
                "line": 1031,
                "column": 72
            },
            "code": "      it('detects error when stream halts early between children of root', function () {\n        // currently failing: clarinet is not detecting the error\n        givenAnOboeInstance().andWeAreExpectingSomeErrors().whenGivenInputPart('[[1,2,3],').whenInputFinishes().thenTheInstance(calledCallbackOnce, wasPassedAnErrorObject);\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detects error when stream halts early inside mid-tree node",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "error cases:",
                "errors on malformed json"
            ],
            "line": 1035,
            "updatePoint": {
                "line": 1035,
                "column": 68
            },
            "code": "      it('detects error when stream halts early inside mid-tree node', function () {\n        givenAnOboeInstance().andWeAreExpectingSomeErrors().whenGivenInputPart('[[1,2,3').whenInputFinishes().thenTheInstance(calledCallbackOnce, wasPassedAnErrorObject);\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "calls error listener if an error is thrown in the callback",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "error cases:",
                "errors on malformed json"
            ],
            "line": 1038,
            "updatePoint": {
                "line": 1038,
                "column": 68
            },
            "code": "      it('calls error listener if an error is thrown in the callback', function () {\n        spyOn(globalContext, 'setTimeout');\n        givenAnOboeInstance().andWeHaveAFaultyCallbackListeningFor('!') // just want the root object\n        .whenGivenInputPart('{}') // valid json, should provide callback\n        .thenTheInstance({\n          testAgainst: function () {\n            // console.log(globalContext.setTimeout.calls.mostRecent())\n            expect(globalContext.setTimeout.calls.argsFor(0)[0]).toThrow();\n          }\n        });\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not throw an error",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "aborting a request"
            ],
            "line": 1051,
            "updatePoint": {
                "line": 1051,
                "column": 33
            },
            "code": "      it('does not throw an error', function () {\n        expect(function () {\n          givenAnOboeInstance().andWeAreListeningForPaths('*').whenGivenInputPart('[1').andWeAbortTheRequest();\n        }).not.toThrow();\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can abort once some data has been found in response",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "aborting a request"
            ],
            "line": 1056,
            "updatePoint": {
                "line": 1056,
                "column": 61
            },
            "code": "      it('can abort once some data has been found in response', function () {\n        // we should be able to abort even when given all the content at once\n        var asserter = givenAnOboeInstance();\n        asserter.andWeAreListeningForNodes('![5]', function () {\n          asserter.andWeAbortTheRequest();\n        }).whenGivenInput([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]).thenTheInstance( // because the request was aborted on index array 5, we got 6 numbers (inc zero)\n        // not the whole ten.\n        hasRootJson([0, 1, 2, 3, 4, 5]));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "drops from an array leaving holes",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "dropping nodes"
            ],
            "line": 1067,
            "updatePoint": {
                "line": 1067,
                "column": 43
            },
            "code": "      it('drops from an array leaving holes', function () {\n        function isEven(n) {\n          return n % 2 === 0;\n        }\n\n        givenAnOboeInstance().andWeAreListeningForNodes('!.*', function (number) {\n          if (isEven(number)) {\n            return oboe.drop;\n          }\n        }).whenGivenInput([1, 2, 3, 4, 5, 6, 7]).thenTheInstance( // note holes in array!\n        hasRootJson([1,, 3,, 5,, 7]) // eslint-disable-line no-sparse-arrays\n        );\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can drop from an object",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "dropping nodes"
            ],
            "line": 1080,
            "updatePoint": {
                "line": 1080,
                "column": 33
            },
            "code": "      it('can drop from an object', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('!.*', function notDrinking(course) {\n          if (course === 'wine') {\n            return oboe.drop;\n          }\n        }).whenGivenInput({\n          starter: 'soup',\n          main: 'fish',\n          desert: 'fresh cheesecake',\n          drink: 'wine'\n        }).thenTheInstance(hasRootJson({\n          starter: 'soup',\n          main: 'fish',\n          desert: 'fresh cheesecake'\n        }));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can drop from an object using short-form",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "dropping nodes"
            ],
            "line": 1096,
            "updatePoint": {
                "line": 1096,
                "column": 50
            },
            "code": "      it('can drop from an object using short-form', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('starter', oboe.drop).whenGivenInput({\n          starter: 'soup',\n          main: 'fish',\n          desert: 'fresh cheesecake',\n          drink: 'wine'\n        }).thenTheInstance(hasRootJson({\n          main: 'fish',\n          desert: 'fresh cheesecake',\n          drink: 'wine'\n        }));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "drops from an array leaving holes",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "dropping nodes",
                "when using \"on\""
            ],
            "line": 1109,
            "updatePoint": {
                "line": 1109,
                "column": 45
            },
            "code": "        it('drops from an array leaving holes', function () {\n          function isEven(n) {\n            return n % 2 === 0;\n          }\n\n          givenAnOboeInstance().andWeAreListeningForANodeUsingOn('!.*', function (number) {\n            if (isEven(number)) {\n              return oboe.drop;\n            }\n          }).whenGivenInput([1, 2, 3, 4, 5, 6, 7]).thenTheInstance( // note holes in array!\n          hasRootJson([1,, 3,, 5,, 7]) // eslint-disable-line no-sparse-arrays\n          );\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can drop from an object",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "dropping nodes",
                "when using \"on\""
            ],
            "line": 1122,
            "updatePoint": {
                "line": 1122,
                "column": 35
            },
            "code": "        it('can drop from an object', function () {\n          givenAnOboeInstance().andWeAreListeningForANodeUsingOn('!.*', function notDrinking(course) {\n            if (course === 'wine') {\n              return oboe.drop;\n            }\n          }).whenGivenInput({\n            starter: 'soup',\n            main: 'fish',\n            desert: 'fresh cheesecake',\n            drink: 'wine'\n          }).thenTheInstance(hasRootJson({\n            starter: 'soup',\n            main: 'fish',\n            desert: 'fresh cheesecake'\n          }));\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can drop from an object using short-form",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "dropping nodes",
                "when using \"on\""
            ],
            "line": 1138,
            "updatePoint": {
                "line": 1138,
                "column": 52
            },
            "code": "        it('can drop from an object using short-form', function () {\n          givenAnOboeInstance().andWeAreListeningForANodeUsingOn('starter', oboe.drop).whenGivenInput({\n            starter: 'soup',\n            main: 'fish',\n            desert: 'fresh cheesecake',\n            drink: 'wine'\n          }).thenTheInstance(hasRootJson({\n            main: 'fish',\n            desert: 'fresh cheesecake',\n            drink: 'wine'\n          }));\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can selectively drop objects from an array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "swapping out nodes"
            ],
            "line": 1153,
            "updatePoint": {
                "line": 1153,
                "column": 52
            },
            "code": "      it('can selectively drop objects from an array', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('!.*', function (obj) {\n          if (obj.nullfily) {\n            return null;\n          }\n        }).whenGivenInput([{\n          nullfily: true\n        }, {\n          keep: true\n        }, {\n          nullfily: true\n        }]).thenTheInstance( // because the request was aborted on index array 5, we got 6 numbers (inc zero)\n        // not the whole ten.\n        hasRootJson([null, {\n          keep: true\n        }, null]));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can replace objects found in an object",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "swapping out nodes"
            ],
            "line": 1170,
            "updatePoint": {
                "line": 1170,
                "column": 48
            },
            "code": "      it('can replace objects found in an object', function () {\n        givenAnOboeInstance().andWeAreListeningForNodes('{replace}', function (obj) {\n          return {\n            replaced: true\n          };\n        }).whenGivenInput({\n          a: {\n            replace: true\n          },\n          b: {\n            keep: true\n          },\n          c: {\n            replace: true\n          }\n        }).thenTheInstance( // because the request was aborted on index array 5, we got 6 numbers (inc zero)\n        // not the whole ten.\n        hasRootJson({\n          a: {\n            replaced: true\n          },\n          b: {\n            keep: true\n          },\n          c: {\n            replaced: true\n          }\n        }));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can transform scalar values",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "swapping out nodes"
            ],
            "line": 1218,
            "updatePoint": {
                "line": 1218,
                "column": 37
            },
            "code": "      it('can transform scalar values', function () {\n        function isEven(n) {\n          return n % 2 === 0;\n        }\n\n        givenAnOboeInstance().andWeAreListeningForNodes('*', function (number) {\n          if (isEven(number)) {\n            return number * 2;\n          }\n        }).whenGivenInput([1, 2, 3, 4, 5]).thenTheInstance( // because the request was aborted on index array 5, we got 6 numbers (inc zero)\n        // not the whole ten.\n        hasRootJson([1, 4, 3, 8, 5]));\n      });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can selectively drop objects from an array",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "swapping out nodes",
                "when using \"on\""
            ],
            "line": 1232,
            "updatePoint": {
                "line": 1232,
                "column": 54
            },
            "code": "        it('can selectively drop objects from an array', function () {\n          givenAnOboeInstance().andWeAreListeningForANodeUsingOn('!.*', function (obj) {\n            if (obj.nullfily) {\n              return null;\n            }\n          }).whenGivenInput([{\n            nullfily: true\n          }, {\n            keep: true\n          }, {\n            nullfily: true\n          }]).thenTheInstance( // because the request was aborted on index array 5, we got 6 numbers (inc zero)\n          // not the whole ten.\n          hasRootJson([null, {\n            keep: true\n          }, null]));\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can replace objects found in an object",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "swapping out nodes",
                "when using \"on\""
            ],
            "line": 1249,
            "updatePoint": {
                "line": 1249,
                "column": 50
            },
            "code": "        it('can replace objects found in an object', function () {\n          givenAnOboeInstance().andWeAreListeningForANodeUsingOn('{replace}', function (obj) {\n            return {\n              replaced: true\n            };\n          }).whenGivenInput({\n            a: {\n              replace: true\n            },\n            b: {\n              keep: true\n            },\n            c: {\n              replace: true\n            }\n          }).thenTheInstance( // because the request was aborted on index array 5, we got 6 numbers (inc zero)\n          // not the whole ten.\n          hasRootJson({\n            a: {\n              replaced: true\n            },\n            b: {\n              keep: true\n            },\n            c: {\n              replaced: true\n            }\n          }));\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can transform scalar values",
            "suites": [
                "oboe component (no http, content fed in externally)",
                "swapping out nodes",
                "when using \"on\""
            ],
            "line": 1278,
            "updatePoint": {
                "line": 1278,
                "column": 39
            },
            "code": "        it('can transform scalar values', function () {\n          function isEven(n) {\n            return n % 2 === 0;\n          }\n\n          givenAnOboeInstance().andWeAreListeningForANodeUsingOn('*', function (number) {\n            if (isEven(number)) {\n              return number * 2;\n            }\n          }).whenGivenInput([1, 2, 3, 4, 5]).thenTheInstance( // because the request was aborted on index array 5, we got 6 numbers (inc zero)\n          // not the whole ten.\n          hasRootJson([1, 4, 3, 8, 5]));\n        });",
            "file": "specs/oboe.component.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not grow memory by more than expected",
            "suites": [
                "oboe integration (real http)",
                "heap tests"
            ],
            "line": 9,
            "updatePoint": {
                "line": 9,
                "column": 54
            },
            "code": "      it('should not grow memory by more than expected', function (done) {\n        var startHeap = window.performance.memory.usedJSHeapSize;\n        var nodes = [];\n        oboe({\n          url: testUrl('largeResponse?limit=10000')\n        }).node('!.*', function (node) {\n          nodes.push(node);\n          return oboe.drop;\n        }).fail(function (error) {\n          console.error(error.thrown);\n          done(error.thrown);\n        }).done(function (fullResponse) {\n          expect(fullResponse.length).toBe(10000);\n          var endHeap = window.performance.memory.usedJSHeapSize;\n          console.log('Start Heap: ', startHeap);\n          console.log('End Heap: ', endHeap); // when this fails this is by a factor in the hundreds\n\n          expect((endHeap - startHeap) / startHeap).toBeLessThan(15);\n          done();\n        });\n      }, 30000);",
            "file": "specs/oboe.heap.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "works after instatiation",
            "suites": [
                "oboe integration (real http)",
                "advertising the url on the Oboe instance"
            ],
            "line": 28,
            "updatePoint": {
                "line": 28,
                "column": 34
            },
            "code": "      it('works after instatiation', function () {\n        var instance = oboe({\n          url: exampleUrl\n        });\n        expect(instance.source).toBe(exampleUrl);\n      });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "works from callbacks",
            "suites": [
                "oboe integration (real http)",
                "advertising the url on the Oboe instance"
            ],
            "line": 34,
            "updatePoint": {
                "line": 34,
                "column": 30
            },
            "code": "      it('works from callbacks', function (done) {\n        var urlOnDone;\n        oboe({\n          url: exampleUrl\n        }).done(function () {\n          urlOnDone = this.source;\n          expect(urlOnDone).toBe(exampleUrl);\n          done();\n        });\n      });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can read from a stream that is passed in",
            "suites": [
                "oboe integration (real http)",
                "when running under node"
            ],
            "line": 52,
            "updatePoint": {
                "line": 52,
                "column": 50
            },
            "code": "      it('can read from a stream that is passed in', function (done) {\n        var callbackSpy = jasmine.createSpy('callbackSpy');\n        http.request('http://localhost:4567/tenSlowNumbers').on('response', function (res) {\n          oboe(res).node('![*]', callbackSpy).done(function () {\n            expect(callbackSpy.calls.count()).toBe(10);\n            done();\n          });\n        }).end();\n      });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can read from a stream from Request - https://github.com/jimhigson/oboe.js/issues/65",
            "suites": [
                "oboe integration (real http)",
                "when running under node"
            ],
            "line": 61,
            "updatePoint": {
                "line": 61,
                "column": 94
            },
            "code": "      it('can read from a stream from Request - https://github.com/jimhigson/oboe.js/issues/65', function (done) {\n        var callbackSpy = jasmine.createSpy('callbackSpy');\n        oboe(request('http://localhost:4567/tenSlowNumbers')).node('![*]', callbackSpy).done(function () {\n          expect(callbackSpy.calls.count()).toBe(10);\n          done();\n        });\n      });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can read from a local file",
            "suites": [
                "oboe integration (real http)",
                "when running under node"
            ],
            "line": 68,
            "updatePoint": {
                "line": 68,
                "column": 36
            },
            "code": "      it('can read from a local file', function (done) {\n        var callbackSpy = jasmine.createSpy('callbackSpy');\n        var fileStream = fs.createReadStream('test/json/firstTenNaturalNumbers.json');\n        oboe(fileStream).node('![*]', callbackSpy).done(function () {\n          expect(callbackSpy.calls.count()).toBe(10);\n          done();\n        });\n      });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can read an empty key",
            "suites": [
                "oboe integration (real http)",
                "when running under node"
            ],
            "line": 76,
            "updatePoint": {
                "line": 76,
                "column": 31
            },
            "code": "      it('can read an empty key', function (done) {\n        var callbackSpy = jasmine.createSpy('callbackSpy');\n        var fileStream = fs.createReadStream('test/json/emptyKey.json');\n        oboe(fileStream).node('!.*', callbackSpy).done(function () {\n          expect(callbackSpy.calls.count()).toBe(2);\n          done();\n        });\n      });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doesnt get confused if a stream has a \"url\" property",
            "suites": [
                "oboe integration (real http)",
                "when running under node"
            ],
            "line": 84,
            "updatePoint": {
                "line": 84,
                "column": 62
            },
            "code": "      it('doesnt get confused if a stream has a \"url\" property', function (done) {\n        var fileStream = fs.createReadStream('test/json/firstTenNaturalNumbers.json');\n        fileStream.url = 'http://howodd.com';\n        oboe(fileStream).done(done);\n      }); // Tests that depend on network connections can be brittle. Skip for now.",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can read from https",
            "suites": [
                "oboe integration (real http)",
                "when running under node"
            ],
            "line": 90,
            "updatePoint": {
                "line": 90,
                "column": 29
            },
            "code": "      it('can read from https', function (done) {\n        var callbackSpy = jasmine.createSpy('callbackSpy'); // rather than set up a https server in the tests\n        // let's just use npm since this is an integration test\n        // by confirming the Oboe.js homepage...\n\n        oboe({\n          url: 'https://registry.npmjs.org/oboe'\n        }).node('!.homepage', callbackSpy).done(function (obj) {\n          var oboeHomepage = 'http://oboejs.com';\n          expect(callbackSpy.calls.mostRecent().args[0]).toEqual(oboeHomepage);\n          done();\n        });\n      });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "complains if given a non-http(s) url",
            "suites": [
                "oboe integration (real http)",
                "when running under node"
            ],
            "line": 103,
            "updatePoint": {
                "line": 103,
                "column": 46
            },
            "code": "      it('complains if given a non-http(s) url', function () {\n        expect(function () {\n          oboe('ftp://ftp.mozilla.org/pub/mozilla.org/');\n        }).toThrow();\n        expect(function () {\n          oboe('http://registry.npmjs.org/oboe');\n        }).not.toThrow();\n      });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not send cookies cross-domain by default",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 113,
            "updatePoint": {
                "line": 113,
                "column": 55
            },
            "code": "      it('does not send cookies cross-domain by default', function (done) {\n        document.cookie = 'oboeIntegrationDontSend=123; path=/';\n        oboe({\n          url: crossDomainUrl('/echoBackHeadersAsBodyJson')\n        }).done(function () {\n          expect(this.root().cookie).toBeUndefined();\n          done();\n        });\n      });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can send cookies cross-domain",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 122,
            "updatePoint": {
                "line": 122,
                "column": 39
            },
            "code": "      it('can send cookies cross-domain', function (done) {\n        document.cookie = 'oboeIntegrationSend=123; path=/';\n        oboe({\n          url: crossDomainUrl('/echoBackHeadersAsBodyJson'),\n          withCredentials: true\n        }).done(function (obj) {\n          expect(this.root().cookie).toMatch('oboeIntegrationSend=123');\n          done();\n        });\n      });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "adds X-Requested-With to cross-domain by default on cross-domain",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 132,
            "updatePoint": {
                "line": 132,
                "column": 74
            },
            "code": "      it('adds X-Requested-With to cross-domain by default on cross-domain', function (done) {\n        oboe({\n          url: testUrl('echoBackHeadersAsBodyJson')\n        }).done(function (obj) {\n          expect(this.root()['x-requested-with']).toEqual('XMLHttpRequest');\n          done();\n        });\n      });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not add X-Requested-With to cross-domain by default on cross-domain",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 140,
            "updatePoint": {
                "line": 140,
                "column": 82
            },
            "code": "      it('does not add X-Requested-With to cross-domain by default on cross-domain', function (done) {\n        oboe({\n          url: crossDomainUrl('/echoBackHeadersAsBodyJson')\n        }).done(function (obj) {\n          expect(this.root()['x-requested-with']).toBeUndefined();\n          done();\n        });\n      });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gets all expected callbacks by time request finishes",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 149,
            "updatePoint": {
                "line": 149,
                "column": 60
            },
            "code": "    it('gets all expected callbacks by time request finishes', function (done) {\n      var callbackSpy = jasmine.createSpy('callbackSpy');\n      oboe(testUrl('tenSlowNumbers')).node('![*]', callbackSpy).done(function (fullResponse) {\n        expect(callbackSpy).toHaveBeenCalledWith(0, [0], [fullResponse, 0]);\n        expect(callbackSpy).toHaveBeenCalledWith(1, [1], [fullResponse, 1]);\n        expect(callbackSpy).toHaveBeenCalledWith(2, [2], [fullResponse, 2]);\n        expect(callbackSpy).toHaveBeenCalledWith(3, [3], [fullResponse, 3]);\n        expect(callbackSpy).toHaveBeenCalledWith(4, [4], [fullResponse, 4]);\n        expect(callbackSpy).toHaveBeenCalledWith(5, [5], [fullResponse, 5]);\n        expect(callbackSpy).toHaveBeenCalledWith(6, [6], [fullResponse, 6]);\n        expect(callbackSpy).toHaveBeenCalledWith(7, [7], [fullResponse, 7]);\n        expect(callbackSpy).toHaveBeenCalledWith(8, [8], [fullResponse, 8]);\n        expect(callbackSpy).toHaveBeenCalledWith(9, [9], [fullResponse, 9]);\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can make nested requests from arrays",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 165,
            "updatePoint": {
                "line": 165,
                "column": 44
            },
            "code": "    it('can make nested requests from arrays', function (done) {\n      var callbackSpy = jasmine.createSpy('callbackSpy');\n      oboe(testUrl('tenSlowNumbers')).node('![*]', function (outerNumber) {\n        oboe(testUrl('tenSlowNumbers')).node('![*]', function (innerNumber) {\n          callbackSpy();\n        });\n      }); // makes a lot of requests so give it a while to complete\n\n      waitsForAndRuns(function () {\n        // console.log('callbackSpy.calls.count()', callbackSpy.calls.count())\n        return callbackSpy.calls.count() === 100;\n      }, done, 40 * 1000);\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "continues to parse after a callback throws an exception",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 178,
            "updatePoint": {
                "line": 178,
                "column": 63
            },
            "code": "    it('continues to parse after a callback throws an exception', function (done) {\n      var callbackSpy = jasmine.createSpy('callbackSpy');\n      oboe(testUrl('static/json/tenRecords.json')).node('{id name}', function () {\n        callbackSpy();\n        throw new Error('uh oh!');\n      });\n      waitsForAndRuns(function () {\n        return callbackSpy.calls.count() === 10;\n      }, function () {\n        expect(globalContext.setTimeout.calls.count()).toEqual(10);\n\n        for (var i = 0; i < 10; i++) {\n          expect(globalContext.setTimeout.calls.argsFor(i)[0]).toThrowError('uh oh!');\n        }\n\n        done();\n      }, ASYNC_TEST_TIMEOUT); // delay spy until after waitsForAndRuns as it calls setTimeout\n\n      spyOn(globalContext, 'setTimeout');\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can abort once some data has been found in streamed response",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 198,
            "updatePoint": {
                "line": 198,
                "column": 68
            },
            "code": "    it('can abort once some data has been found in streamed response', function (done) {\n      var aborted;\n      var req = oboe(testUrl('tenSlowNumbers')).node('![5]', function () {\n        this.abort();\n        aborted = true;\n      });\n      waitsForAndRuns(function () {\n        return aborted;\n      }, function () {\n        expect(req.root()).toEqual([0, 1, 2, 3, 4, 5]);\n        done();\n      }, ASYNC_TEST_TIMEOUT);\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can deregister from inside the callback",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 211,
            "updatePoint": {
                "line": 211,
                "column": 47
            },
            "code": "    it('can deregister from inside the callback', function (done) {\n      var callbackSpy = jasmine.createSpy('callbackSpy');\n      oboe(testUrl('tenSlowNumbers')).node('![*]', function () {\n        callbackSpy();\n\n        if (callbackSpy.calls.count() === 5) {\n          this.forget();\n        }\n      }).done(function (obj) {\n        expect(callbackSpy.calls.count()).toBe(5);\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can still gets the whole resource after deregistering the callback",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 224,
            "updatePoint": {
                "line": 224,
                "column": 74
            },
            "code": "    it('can still gets the whole resource after deregistering the callback', function (done) {\n      var callbackSpy = jasmine.createSpy('callbackSpy');\n      oboe(testUrl('tenSlowNumbers')).node('![*]', function () {\n        callbackSpy();\n\n        if (callbackSpy.calls.count() === 5) {\n          this.forget();\n        }\n      }).done(function (fullResponse) {\n        expect(fullResponse).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can send query params",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 237,
            "updatePoint": {
                "line": 237,
                "column": 29
            },
            "code": "    it('can send query params', function (done) {\n      oboe(testUrl('echoBackQueryParamsAsBodyJson?apiKey=123')).node('apiKey', function (keyArg) {\n        expect(keyArg).toBe('123');\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can abort once some data has been found in not very streamed response",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 243,
            "updatePoint": {
                "line": 243,
                "column": 77
            },
            "code": "    it('can abort once some data has been found in not very streamed response', function (done) {\n      // like above but we're getting a static file not the streamed numbers. This means\n      // we'll almost certainly read in the whole response as one onprogress it is on localhost\n      // and the json is very small\n      var aborted;\n      var req = oboe(testUrl('static/json/firstTenNaturalNumbers.json')).node('![5]', function () {\n        this.abort();\n        aborted = true;\n      });\n      waitsForAndRuns(function () {\n        return aborted;\n      }, function () {\n        expect(req.root()).toEqual([0, 1, 2, 3, 4, 5]);\n        done();\n      }, ASYNC_TEST_TIMEOUT);\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives full json to callback when request finishes",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 259,
            "updatePoint": {
                "line": 259,
                "column": 57
            },
            "code": "    it('gives full json to callback when request finishes', function (done) {\n      oboe(testUrl('static/json/firstTenNaturalNumbers.json')).done(function (json) {\n        expect(json).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives content type as JSON when provided with an Object body",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 265,
            "updatePoint": {
                "line": 265,
                "column": 68
            },
            "code": "    it('gives content type as JSON when provided with an Object body', function (done) {\n      oboe({\n        method: 'PUT',\n        url: testUrl('echoBackHeadersAsBodyJson'),\n        body: {\n          potatoes: 3,\n          cabbages: 4\n        }\n      }).done(function (json) {\n        var contentType = json['content-type'].split(';')[0];\n        expect(contentType).toBe('application/json');\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives allows content type to be overridden when provided with an Object body",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 279,
            "updatePoint": {
                "line": 279,
                "column": 84
            },
            "code": "    it('gives allows content type to be overridden when provided with an Object body', function (done) {\n      oboe({\n        method: 'PUT',\n        url: testUrl('echoBackHeadersAsBodyJson'),\n        body: {\n          potatoes: 3,\n          cabbages: 4\n        },\n        headers: {\n          'Content-Type': 'application/vegetableDiffThing'\n        }\n      }).done(function (json) {\n        var contentType = json['content-type'].split(';')[0];\n        expect(contentType).toBe('application/vegetableDiffThing');\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives header to server side",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 296,
            "updatePoint": {
                "line": 296,
                "column": 35
            },
            "code": "    it('gives header to server side', function (done) {\n      var countGotBack = 0;\n      oboe({\n        url: testUrl('echoBackHeadersAsBodyJson'),\n        headers: {\n          'x-snarfu': 'SNARF',\n          'x-foo': 'BAR'\n        }\n      }).node('x-snarfu', function (headerValue) {\n        expect(headerValue).toBe('SNARF');\n        countGotBack++;\n      }).node('x-foo', function (headerValue) {\n        expect(headerValue).toBe('BAR');\n        countGotBack++;\n      }).done(function () {\n        expect(countGotBack).toBe(2);\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can read response headers",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 315,
            "updatePoint": {
                "line": 315,
                "column": 33
            },
            "code": "    it('can read response headers', function (done) {\n      oboe({\n        url: testUrl('echoBackHeadersAsHeaders'),\n        headers: {\n          'x-sso': 'sso',\n          'x-sso2': 'sso2'\n        }\n      }).done(function () {\n        expect(this.header('x-sso')).toEqual('sso');\n        expect(this.header('x-sso2')).toEqual('sso2');\n        expect(this.header()['x-sso']).toEqual('sso');\n        expect(this.header()['x-sso2']).toEqual('sso2');\n        expect(this.header()['x-sso3']).toBeUndefined();\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives undefined for headers before they are ready",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 331,
            "updatePoint": {
                "line": 331,
                "column": 57
            },
            "code": "    it('gives undefined for headers before they are ready', function (done) {\n      var res = oboe({\n        url: testUrl('echoBackHeadersAsHeaders'),\n        headers: {\n          'x-sso': 'sso',\n          'x-sso2': 'sso2'\n        }\n      });\n      expect(res.header()).toBeUndefined();\n      expect(res.header('x-sso')).toBeUndefined();\n      expect(res.header('x-sso2')).toBeUndefined();\n      done();\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of response starting by giving status code and headers to callback",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 344,
            "updatePoint": {
                "line": 344,
                "column": 83
            },
            "code": "    it('notifies of response starting by giving status code and headers to callback', function (done) {\n      var functionCalled;\n      var eventCalled;\n      oboe({\n        url: testUrl('echoBackHeadersAsHeaders'),\n        headers: {\n          'x-a': 'A',\n          'x-b': 'B'\n        }\n      }).start(function (statusCode, headers) {\n        expect(statusCode).toBe(200);\n        expect(headers['x-a']).toBe('A');\n        functionCalled = true;\n      }).on('start', function (statusCode, headers) {\n        expect(statusCode).toBe(200);\n        expect(headers['x-b']).toBe('B');\n        eventCalled = true;\n      }).done(function () {\n        expect(functionCalled).toBe(true);\n        expect(eventCalled).toBe(true);\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can listen for nodes nodejs style",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 367,
            "updatePoint": {
                "line": 367,
                "column": 41
            },
            "code": "    it('can listen for nodes nodejs style', function (done) {\n      var countGotBack = 0;\n      oboe(testUrl('static/json/firstTenNaturalNumbers.json')).on('node', '!.*', function () {\n        countGotBack++;\n      }).done(function () {\n        expect(countGotBack).toBe(10);\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can listen for paths nodejs style",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 376,
            "updatePoint": {
                "line": 376,
                "column": 41
            },
            "code": "    it('can listen for paths nodejs style', function (done) {\n      var countGotBack = 0;\n      oboe(testUrl('static/json/firstTenNaturalNumbers.json')).on('path', '!.*', function (number) {\n        countGotBack++;\n      }).done(function () {\n        expect(countGotBack).toBe(10);\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can listen for done nodejs style",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 385,
            "updatePoint": {
                "line": 385,
                "column": 40
            },
            "code": "    it('can listen for done nodejs style', function (done) {\n      oboe(testUrl('static/json/firstTenNaturalNumbers.json')).on('done', done);\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gets all callbacks and they are in correct order",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 388,
            "updatePoint": {
                "line": 388,
                "column": 56
            },
            "code": "    it('gets all callbacks and they are in correct order', function (done) {\n      var order = [];\n      oboe({\n        method: 'POST',\n        url: testUrl('echoBackBody'),\n        body: {\n          a: 'A',\n          b: 'B',\n          c: 'C'\n        }\n      }).path('!', function () {\n        order.push(1);\n      }).path('a', function () {\n        order.push(2);\n      }).node('a', function () {\n        order.push(3);\n      }).path('b', function () {\n        order.push(4);\n      }).node('b', function () {\n        order.push(5);\n      }).path('c', function () {\n        order.push(6);\n      }).node('c', function () {\n        order.push(7);\n      }).done(function () {\n        order.push(8);\n        expect(order).toEqual([1, 2, 3, 4, 5, 6, 7, 8]);\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emits error on 404",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 418,
            "updatePoint": {
                "line": 418,
                "column": 26
            },
            "code": "    it('emits error on 404', function (done) {\n      oboe(testUrl('404json')).fail(function (err) {\n        expect(err.statusCode).toBe(404);\n        expect(err.jsonBody).toEqual({\n          found: 'false',\n          errorMessage: 'was not found'\n        });\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emits error on 404 in nodejs style too",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 428,
            "updatePoint": {
                "line": 428,
                "column": 46
            },
            "code": "    it('emits error on 404 in nodejs style too', function (done) {\n      oboe(testUrl('404json')).on('fail', function (err) {\n        expect(err.statusCode).toBe(404);\n        expect(err.jsonBody).toEqual({\n          found: 'false',\n          errorMessage: 'was not found'\n        });\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "throws node callback errors in a separate event loop",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 453,
            "updatePoint": {
                "line": 453,
                "column": 60
            },
            "code": "    it('throws node callback errors in a separate event loop', function (done) {\n      var callbackError = new Error('I am a bad callback');\n      spyOn(globalContext, 'setTimeout');\n      oboe(testUrl('static/json/firstTenNaturalNumbers.json')).node('!.*', function () {\n        throw new Error('I am a bad callback');\n      }).done(function () {\n        expect(globalContext.setTimeout.calls.mostRecent().args[0]).toThrow(callbackError);\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "throws done callback errors in a separate event loop",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 463,
            "updatePoint": {
                "line": 463,
                "column": 60
            },
            "code": "    it('throws done callback errors in a separate event loop', function (done) {\n      var callbackError = jasmine.createSpy().and.throwError('I am a bad callback');\n      oboe(testUrl('static/json/firstTenNaturalNumbers.json')).done(callbackError);\n      waitsForAndRuns(function () {\n        return globalContext.setTimeout.calls.count() > 0;\n      }, function () {\n        expect(globalContext.setTimeout.calls.mostRecent().args[0]).toThrowError('I am a bad callback');\n        done();\n      }, ASYNC_TEST_TIMEOUT);\n      spyOn(globalContext, 'setTimeout');\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can load an empty response with 204 status code",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 474,
            "updatePoint": {
                "line": 474,
                "column": 55
            },
            "code": "    it('can load an empty response with 204 status code', function (done) {\n      oboe({\n        url: testUrl('204noData')\n      }).start(function (status) {\n        expect(status).toEqual(204);\n      }).done(function (fullResponse) {\n        expect(fullResponse).toEqual({});\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "emits error with incomplete json",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 484,
            "updatePoint": {
                "line": 484,
                "column": 40
            },
            "code": "    it('emits error with incomplete json', function (done) {\n      oboe(testUrl('static/json/incomplete.json')).fail(function (err) {\n        expect(err.thrown.message).toMatch('Unexpected end');\n        done();\n      });\n    });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "hasn't put clarinet in the global namespace",
            "suites": [
                "oboe integration (real http)",
                "running under a browser"
            ],
            "line": 493,
            "updatePoint": {
                "line": 493,
                "column": 53
            },
            "code": "      it(\"hasn't put clarinet in the global namespace\", function () {\n        expect(window.clarinet).toBeUndefined();\n      });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should only call \"fail\"",
            "suites": [
                "oboe integration (real http)",
                "when receiving a error response with payload"
            ],
            "line": 499,
            "updatePoint": {
                "line": 499,
                "column": 33
            },
            "code": "      it('should only call \"fail\"', function (done) {\n        var doneCallback = jasmine.createSpy('done');\n        oboe(testUrl('401withData')).fail(function () {\n          expect(doneCallback).not.toHaveBeenCalled();\n          done();\n        }).done(doneCallback);\n      });",
            "file": "specs/oboe.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is benchmarked with a complex jsonpath",
            "suites": [
                "oboe performance (real http)"
            ],
            "line": 24,
            "updatePoint": {
                "line": 24,
                "column": 46
            },
            "code": "    it('is benchmarked with a complex jsonpath', function (done) {\n      var callCount = 0;\n      var startTime = now();\n      oboe(url('static/json/oneHundredRecords.json')).node('!.$result..{age name company}', function () {\n        callCount++;\n      }).done(function () {\n        var timeDiff = now() - startTime;\n        expect(callCount).toBe(100);\n        console.log('took ' + timeDiff + 'ms to evaluate a complex ' + 'expression many times, finding 100 matches');\n        done();\n      });\n    });",
            "file": "specs/oboe.performance.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is benchmarked with a simple jsonpath",
            "suites": [
                "oboe performance (real http)"
            ],
            "line": 36,
            "updatePoint": {
                "line": 36,
                "column": 45
            },
            "code": "    it('is benchmarked with a simple jsonpath', function (done) {\n      var callCount = 0;\n      var startTime = now();\n      oboe(url('static/json/oneHundredRecords.json')).node('name', function () {\n        callCount++;\n      }).done(function () {\n        var timeDiff = now() - startTime;\n        expect(callCount).toBe(100);\n        console.log('took ' + timeDiff + 'ms to evaluate a complex ' + 'expression many times, finding 100 matches');\n        done();\n      });\n    });",
            "file": "specs/oboe.performance.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can parse an empty string",
            "suites": [
                "parsing response headers"
            ],
            "line": 5,
            "updatePoint": {
                "line": 5,
                "column": 31
            },
            "code": "  it('can parse an empty string', function () {\n    var parsed = parseResponseHeaders('');\n    expect(parsed).toEqual({});\n  });",
            "file": "specs/parseResponseHeaders.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can parse a single header",
            "suites": [
                "parsing response headers"
            ],
            "line": 9,
            "updatePoint": {
                "line": 9,
                "column": 31
            },
            "code": "  it('can parse a single header', function () {\n    var parsed = parseResponseHeaders('x-powered-by: Express');\n    expect(parsed).toEqual({\n      'x-powered-by': 'Express'\n    });\n  });",
            "file": "specs/parseResponseHeaders.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can parse a value containing \": \"",
            "suites": [
                "parsing response headers"
            ],
            "line": 15,
            "updatePoint": {
                "line": 15,
                "column": 39
            },
            "code": "  it('can parse a value containing \": \"', function () {\n    var parsed = parseResponseHeaders('x-title: Episode 2: Another episode');\n    expect(parsed).toEqual({\n      'x-title': 'Episode 2: Another episode'\n    });\n  });",
            "file": "specs/parseResponseHeaders.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can parse a value containing lots of colons \": \"",
            "suites": [
                "parsing response headers"
            ],
            "line": 21,
            "updatePoint": {
                "line": 21,
                "column": 54
            },
            "code": "  it('can parse a value containing lots of colons \": \"', function () {\n    var parsed = parseResponseHeaders('x-title: Episode 2: Another episode: Remastered');\n    expect(parsed).toEqual({\n      'x-title': 'Episode 2: Another episode: Remastered'\n    });\n  });",
            "file": "specs/parseResponseHeaders.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can parse two values containing lots of colons \": \"",
            "suites": [
                "parsing response headers"
            ],
            "line": 27,
            "updatePoint": {
                "line": 27,
                "column": 57
            },
            "code": "  it('can parse two values containing lots of colons \": \"', function () {\n    var parsed = parseResponseHeaders('x-title: Episode 2: Another episode: Remastered' + lfcr + 'x-subtitle: This file has: a long title');\n    expect(parsed).toEqual({\n      'x-title': 'Episode 2: Another episode: Remastered',\n      'x-subtitle': 'This file has: a long title'\n    });\n  });",
            "file": "specs/parseResponseHeaders.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can parse several headers",
            "suites": [
                "parsing response headers"
            ],
            "line": 34,
            "updatePoint": {
                "line": 34,
                "column": 31
            },
            "code": "  it('can parse several headers', function () {\n    var subject = 'x-powered-by: Express' + lfcr + 'Transfer-Encoding: Identity' + lfcr + 'Connection: keep-alive';\n    var parsed = parseResponseHeaders(subject);\n    expect(parsed).toEqual({\n      'x-powered-by': 'Express',\n      'Transfer-Encoding': 'Identity',\n      Connection: 'keep-alive'\n    });\n  });",
            "file": "specs/parseResponseHeaders.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "compiles the correct pattern when patterns are listened to",
            "suites": [
                "patternAdapter"
            ],
            "line": 9,
            "updatePoint": {
                "line": 9,
                "column": 64
            },
            "code": "  it('compiles the correct pattern when patterns are listened to', function () {\n    bus('newListener').emit('node:test_pattern');\n    expect(jsonPathCompiler).toHaveBeenCalledWith('test_pattern');\n  });",
            "file": "specs/patternAdaptor.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "listens for NODE_CLOSED events when node:pattern is added",
            "suites": [
                "patternAdapter"
            ],
            "line": 13,
            "updatePoint": {
                "line": 13,
                "column": 63
            },
            "code": "  it('listens for NODE_CLOSED events when node:pattern is added', function () {\n    bus('newListener').emit('node:test_pattern');\n    expect(bus(NODE_CLOSED).on).toHaveBeenCalledWith(jasmine.any(Function), 'node:test_pattern');\n  });",
            "file": "specs/patternAdaptor.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not listen for NODE_CLOSED events second time same node:pattern is added",
            "suites": [
                "patternAdapter"
            ],
            "line": 17,
            "updatePoint": {
                "line": 17,
                "column": 83
            },
            "code": "  it('does not listen for NODE_CLOSED events second time same node:pattern is added', function () {\n    bus('newListener').emit('node:test_pattern');\n    bus('newListener').emit('node:test_pattern');\n    expect(bus(NODE_CLOSED).on.calls.count()).toBe(1);\n  });",
            "file": "specs/patternAdaptor.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "stops listening for node events when node:pattern is removed again",
            "suites": [
                "patternAdapter"
            ],
            "line": 22,
            "updatePoint": {
                "line": 22,
                "column": 72
            },
            "code": "  it('stops listening for node events when node:pattern is removed again', function () {\n    bus('node:test_pattern').on(noop);\n    bus('node:test_pattern').un(noop);\n    expect(bus(NODE_CLOSED).un).toHaveBeenCalledWith('node:test_pattern');\n  });",
            "file": "specs/patternAdaptor.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "starts listening again for node events when node:pattern is added, removed and added again",
            "suites": [
                "patternAdapter"
            ],
            "line": 27,
            "updatePoint": {
                "line": 27,
                "column": 96
            },
            "code": "  it('starts listening again for node events when node:pattern is added, removed and added again', function () {\n    bus('node:test_pattern').on(noop);\n    expect(bus(NODE_CLOSED).on.calls.count()).toBe(1);\n    bus('node:test_pattern').on(noop);\n    expect(bus(NODE_CLOSED).on.calls.count()).toBe(1);\n    bus('node:test_pattern').un(noop);\n    expect(bus(NODE_CLOSED).un.calls.count()).toBe(0);\n    bus('node:test_pattern').un(noop);\n    expect(bus(NODE_CLOSED).un.calls.count()).toBe(1);\n    bus('node:test_pattern').on(noop);\n    expect(bus(NODE_CLOSED).on.calls.count()).toBe(2);\n  });",
            "file": "specs/patternAdaptor.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doesn't stop listening is there are still other node:pattern listeners",
            "suites": [
                "patternAdapter"
            ],
            "line": 39,
            "updatePoint": {
                "line": 39,
                "column": 77
            },
            "code": "  it('doesn\\'t stop listening is there are still other node:pattern listeners', function () {\n    bus('node:test_pattern').on(noop);\n    bus('node:test_pattern').on(noop);\n    bus('node:test_pattern').un(noop);\n    expect(bus(NODE_CLOSED).un).not.toHaveBeenCalledWith('node:test_pattern');\n  });",
            "file": "specs/patternAdaptor.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doesn't stop listening if a different pattern is unsubscribed from",
            "suites": [
                "patternAdapter"
            ],
            "line": 45,
            "updatePoint": {
                "line": 45,
                "column": 73
            },
            "code": "  it('doesn\\'t stop listening if a different pattern is unsubscribed from', function () {\n    bus('node:test_pattern').on(noop);\n    bus('node:other_test_pattern').on(noop);\n    bus('node:other_test_pattern').un(noop);\n    expect(bus(NODE_CLOSED).un).not.toHaveBeenCalledWith('node:test_pattern');\n  });",
            "file": "specs/patternAdaptor.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doesn't stop listening if wrong event type is unsubscribed",
            "suites": [
                "patternAdapter"
            ],
            "line": 51,
            "updatePoint": {
                "line": 51,
                "column": 65
            },
            "code": "  it('doesn\\'t stop listening if wrong event type is unsubscribed', function () {\n    bus('node:test_pattern').on(noop);\n    bus('path:test_pattern').on(noop);\n    bus('path:test_pattern').un(noop);\n    expect(bus(NODE_CLOSED).un).not.toHaveBeenCalledWith('node:test_pattern');\n  });",
            "file": "specs/patternAdaptor.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "only listens once to NODE_CLOSED when same pattern is added twice",
            "suites": [
                "patternAdapter"
            ],
            "line": 57,
            "updatePoint": {
                "line": 57,
                "column": 71
            },
            "code": "  it('only listens once to NODE_CLOSED when same pattern is added twice', function () {\n    bus('node:test_pattern').on(noop);\n    bus('node:test_pattern').on(noop);\n    expect(listAsArray(bus(NODE_CLOSED).listeners).length).toBe(1);\n  });",
            "file": "specs/patternAdaptor.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "listens to NODE_CLOSED and NODE_OPENED when given node: and path: listeners",
            "suites": [
                "patternAdapter"
            ],
            "line": 62,
            "updatePoint": {
                "line": 62,
                "column": 81
            },
            "code": "  it('listens to NODE_CLOSED and NODE_OPENED when given node: and path: listeners', function () {\n    bus('node:test_pattern').on(noop);\n    bus('path:test_pattern').on(noop);\n    expect(bus(NODE_CLOSED).on).toHaveBeenCalledWith(jasmine.any(Function), 'node:test_pattern');\n    expect(bus(NODE_OPENED).on).toHaveBeenCalledWith(jasmine.any(Function), 'path:test_pattern');\n  });",
            "file": "specs/patternAdaptor.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "fires node:pattern events when match is found",
            "suites": [
                "patternAdapter"
            ],
            "line": 68,
            "updatePoint": {
                "line": 68,
                "column": 51
            },
            "code": "  it('fires node:pattern events when match is found', function () {\n    var ascent = anAscentMatching('test_pattern');\n    bus('node:test_pattern').on(noop);\n    bus(NODE_CLOSED).emit(ascent);\n    expect(bus('node:test_pattern').emit).toHaveBeenCalled();\n  });",
            "file": "specs/patternAdaptor.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "exports a usable function for GETs",
            "suites": [
                "public api",
                "propagates through to wiring function"
            ],
            "line": 14,
            "updatePoint": {
                "line": 14,
                "column": 42
            },
            "code": "    it('exports a usable function for GETs', function () {\n      oboe('http://example.com/oboez');\n      expect(applyDefaults).toHaveBeenCalledLike(wire, 'http://example.com/oboez');\n    });",
            "file": "specs/publicApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can create a no-ajax instance",
            "suites": [
                "public api",
                "propagates through to wiring function"
            ],
            "line": 18,
            "updatePoint": {
                "line": 18,
                "column": 37
            },
            "code": "    it('can create a no-ajax instance', function () {\n      oboe();\n      expect(wire).toHaveBeenCalledLike();\n    });",
            "file": "specs/publicApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "works via arguments",
            "suites": [
                "public api",
                "propagates through to wiring function",
                "GET"
            ],
            "line": 23,
            "updatePoint": {
                "line": 23,
                "column": 29
            },
            "code": "      it('works via arguments', function () {\n        oboe('http://example.com/oboez');\n        expect(applyDefaults).toHaveBeenCalledLike(wire, 'http://example.com/oboez');\n      });",
            "file": "specs/publicApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "works via options object",
            "suites": [
                "public api",
                "propagates through to wiring function",
                "GET"
            ],
            "line": 27,
            "updatePoint": {
                "line": 27,
                "column": 34
            },
            "code": "      it('works via options object', function () {\n        oboe({\n          url: 'http://example.com/oboez'\n        });\n        expect(applyDefaults).toHaveBeenCalledLike(wire, 'http://example.com/oboez');\n      });",
            "file": "specs/publicApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can disable caching",
            "suites": [
                "public api",
                "propagates through to wiring function",
                "GET"
            ],
            "line": 33,
            "updatePoint": {
                "line": 33,
                "column": 29
            },
            "code": "      it('can disable caching', function () {\n        oboe({\n          url: 'http://example.com/oboez',\n          cached: false\n        });\n        expect(applyDefaults).toHaveBeenCalledLike(wire, 'http://example.com/oboez', undefined, undefined, undefined, undefined, false);\n      });",
            "file": "specs/publicApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can explicitly not disable caching",
            "suites": [
                "public api",
                "propagates through to wiring function",
                "GET"
            ],
            "line": 40,
            "updatePoint": {
                "line": 40,
                "column": 44
            },
            "code": "      it('can explicitly not disable caching', function () {\n        oboe({\n          url: 'http://example.com/oboez',\n          cached: true\n        });\n        expect(applyDefaults).toHaveBeenCalledLike(wire, 'http://example.com/oboez', undefined, undefined, undefined, undefined, true);\n      });",
            "file": "specs/publicApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "propogates headers",
            "suites": [
                "public api",
                "propagates through to wiring function",
                "GET"
            ],
            "line": 47,
            "updatePoint": {
                "line": 47,
                "column": 28
            },
            "code": "      it('propogates headers', function () {\n        var headers = {\n          'X-HEADER-1': 'value1',\n          'X-HEADER-2': 'value2'\n        };\n        oboe({\n          url: 'http://example.com/oboez',\n          method: 'GET',\n          headers: headers\n        });\n        expect(applyDefaults).toHaveBeenCalledLike(wire, 'http://example.com/oboez', 'GET', undefined, headers);\n      });",
            "file": "specs/publicApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "works via options object",
            "suites": [
                "public api",
                "propagates through to wiring function",
                "delete"
            ],
            "line": 61,
            "updatePoint": {
                "line": 61,
                "column": 34
            },
            "code": "      it('works via options object', function () {\n        oboe({\n          url: 'http://example.com/oboez',\n          method: 'DELETE'\n        });\n        expect(applyDefaults).toHaveBeenCalledLike(wire, 'http://example.com/oboez', 'DELETE');\n      });",
            "file": "specs/publicApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can post an object",
            "suites": [
                "public api",
                "propagates through to wiring function",
                "post"
            ],
            "line": 70,
            "updatePoint": {
                "line": 70,
                "column": 28
            },
            "code": "      it('can post an object', function () {\n        oboe({\n          method: 'POST',\n          url: 'http://example.com/oboez',\n          body: [1, 2, 3, 4, 5]\n        });\n        expect(applyDefaults).toHaveBeenCalledLike(wire, 'http://example.com/oboez', 'POST', [1, 2, 3, 4, 5]);\n      });",
            "file": "specs/publicApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can post a string",
            "suites": [
                "public api",
                "propagates through to wiring function",
                "post"
            ],
            "line": 78,
            "updatePoint": {
                "line": 78,
                "column": 27
            },
            "code": "      it('can post a string', function () {\n        oboe({\n          method: 'POST',\n          url: 'http://example.com/oboez',\n          body: 'my_data'\n        });\n        expect(applyDefaults).toHaveBeenCalledLike(wire, 'http://example.com/oboez', 'POST', 'my_data');\n      });",
            "file": "specs/publicApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can put a string",
            "suites": [
                "public api",
                "propagates through to wiring function",
                "put"
            ],
            "line": 88,
            "updatePoint": {
                "line": 88,
                "column": 26
            },
            "code": "      it('can put a string', function () {\n        oboe({\n          method: 'PUT',\n          url: 'http://example.com/oboez',\n          body: 'my_data'\n        });\n        expect(applyDefaults).toHaveBeenCalledLike(wire, 'http://example.com/oboez', 'PUT', 'my_data');\n      });",
            "file": "specs/publicApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can patch a string",
            "suites": [
                "public api",
                "propagates through to wiring function",
                "patch"
            ],
            "line": 98,
            "updatePoint": {
                "line": 98,
                "column": 28
            },
            "code": "      it('can patch a string', function () {\n        oboe({\n          url: 'http://example.com/oboez',\n          body: 'my_data',\n          method: 'PATCH'\n        });\n        expect(applyDefaults).toHaveBeenCalledLike(wire, 'http://example.com/oboez', 'PATCH', 'my_data');\n      });",
            "file": "specs/publicApi.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is able to provide a single event pubsub",
            "suites": [
                "pub sub"
            ],
            "line": 4,
            "updatePoint": {
                "line": 4,
                "column": 46
            },
            "code": "  it('is able to provide a single event pubsub', function () {\n    var events = pubSub();\n    expect(events('somethingHappening').on).not.toBeUndefined();\n  });",
            "file": "specs/pubsub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is provides the same single when asked twice",
            "suites": [
                "pub sub"
            ],
            "line": 8,
            "updatePoint": {
                "line": 8,
                "column": 50
            },
            "code": "  it('is provides the same single when asked twice', function () {\n    var events = pubSub();\n    expect(events('somethingHappening')).toBe(events('somethingHappening'));\n  });",
            "file": "specs/pubsub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "numeric event names are treated as equal",
            "suites": [
                "pub sub"
            ],
            "line": 12,
            "updatePoint": {
                "line": 12,
                "column": 46
            },
            "code": "  it('numeric event names are treated as equal', function () {\n    var events = pubSub();\n    expect(events(1)).toBe(events(1));\n  });",
            "file": "specs/pubsub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "different numeric event names are treated as equal",
            "suites": [
                "pub sub"
            ],
            "line": 16,
            "updatePoint": {
                "line": 16,
                "column": 56
            },
            "code": "  it('different numeric event names are treated as equal', function () {\n    var events = pubSub();\n    expect(events(1)).not.toBe(events(2));\n  });",
            "file": "specs/pubsub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is provides different singles for different event names",
            "suites": [
                "pub sub"
            ],
            "line": 20,
            "updatePoint": {
                "line": 20,
                "column": 61
            },
            "code": "  it('is provides different singles for different event names', function () {\n    var events = pubSub();\n    expect(events('somethingHappening')).not.toBe(events('somethingElseHappening'));\n  });",
            "file": "specs/pubsub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doesn't notify a newListener listener of its own addition",
            "suites": [
                "pub sub"
            ],
            "line": 24,
            "updatePoint": {
                "line": 24,
                "column": 64
            },
            "code": "  it('doesn\\'t notify a newListener listener of its own addition', function () {\n    var events = pubSub();\n    var listenerListener = jasmine.createSpy('listenerListener');\n    events('newListener').on(listenerListener);\n    expect(listenerListener).not.toHaveBeenCalled();\n  });",
            "file": "specs/pubsub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of new listeners when added without an id",
            "suites": [
                "pub sub"
            ],
            "line": 30,
            "updatePoint": {
                "line": 30,
                "column": 56
            },
            "code": "  it('notifies of new listeners when added without an id', function () {\n    var events = pubSub();\n    var listenerListener = jasmine.createSpy('listenerListener');\n    events('newListener').on(listenerListener);\n    events('foo').on(noop);\n    expect(listenerListener).toHaveBeenCalledWith('foo', noop, noop);\n  });",
            "file": "specs/pubsub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should which multiple events notify of the right one",
            "suites": [
                "pub sub"
            ],
            "line": 37,
            "updatePoint": {
                "line": 37,
                "column": 58
            },
            "code": "  it('should which multiple events notify of the right one', function () {\n    var events = pubSub();\n    var listenerA = jasmine.createSpy('listenerA');\n    var listenerB = jasmine.createSpy('listenerB');\n    events('eventA').on(listenerA);\n    events('eventB').on(listenerB);\n    events('eventA').emit();\n    expect(listenerA).toHaveBeenCalled();\n    expect(listenerB).not.toHaveBeenCalled();\n    events('eventB').emit();\n    expect(listenerB).toHaveBeenCalled();\n  });",
            "file": "specs/pubsub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not fire removeListener if nothing is removed",
            "suites": [
                "pub sub"
            ],
            "line": 49,
            "updatePoint": {
                "line": 49,
                "column": 56
            },
            "code": "  it('does not fire removeListener if nothing is removed', function () {\n    var events = pubSub();\n    var removeListenerListener = jasmine.createSpy('removeListenerListener');\n    var fooListener = jasmine.createSpy('fooListener');\n    events('removeListener').on(removeListenerListener);\n    events('foo').on(fooListener);\n    events('foo').un('wrong_item');\n    expect(removeListenerListener).not.toHaveBeenCalled();\n  });",
            "file": "specs/pubsub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "fires removeListener when a listener is removed",
            "suites": [
                "pub sub"
            ],
            "line": 58,
            "updatePoint": {
                "line": 58,
                "column": 53
            },
            "code": "  it('fires removeListener when a listener is removed', function () {\n    var events = pubSub();\n    var removeListenerListener = jasmine.createSpy('removeListenerListener');\n    events('removeListener').on(removeListenerListener);\n    events('foo').on(noop);\n    events('foo').un(noop);\n    expect(removeListenerListener).toHaveBeenCalledWith('foo', noop, noop);\n  });",
            "file": "specs/pubsub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "has .emit",
            "suites": [
                "pub sub",
                "short-cut methods"
            ],
            "line": 67,
            "updatePoint": {
                "line": 67,
                "column": 17
            },
            "code": "    it('has .emit', function () {\n      var events = pubSub();\n      var callback = jasmine.createSpy('something happening callback');\n      events('somethingHappened').on(callback);\n      events.emit('somethingHappened', 'it was', 'definitely something');\n      expect(callback).toHaveBeenCalledWith('it was', 'definitely something');\n    });",
            "file": "specs/pubsub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "has .on",
            "suites": [
                "pub sub",
                "short-cut methods"
            ],
            "line": 74,
            "updatePoint": {
                "line": 74,
                "column": 15
            },
            "code": "    it('has .on', function () {\n      var events = pubSub();\n      var callback = jasmine.createSpy('something happening callback');\n      events.on('somethingHappened', callback);\n      events('somethingHappened').emit('it was', 'definitely something');\n      expect(callback).toHaveBeenCalledWith('it was', 'definitely something');\n    });",
            "file": "specs/pubsub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "has .un",
            "suites": [
                "pub sub",
                "short-cut methods"
            ],
            "line": 81,
            "updatePoint": {
                "line": 81,
                "column": 15
            },
            "code": "    it('has .un', function () {\n      var events = pubSub();\n      var callback = jasmine.createSpy('something happening callback');\n      events('somethingHappened').on(callback);\n      events.un('somethingHappened', callback);\n      events('somethingHappened').emit('it was', 'definitely something');\n      expect(callback).not.toHaveBeenCalled();\n    });",
            "file": "specs/pubsub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "has .un that works with listener id",
            "suites": [
                "pub sub",
                "short-cut methods"
            ],
            "line": 89,
            "updatePoint": {
                "line": 89,
                "column": 43
            },
            "code": "    it('has .un that works with listener id', function () {\n      var events = pubSub();\n      var callback = jasmine.createSpy('something happening callback');\n      events('somethingHappened').on(callback, 'id');\n      events.un('somethingHappened', 'id');\n      events('somethingHappened').emit('it was', 'definitely something');\n      expect(callback).not.toHaveBeenCalled();\n    });",
            "file": "specs/pubsub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is able to subscribe",
            "suites": [
                "single event pub sub"
            ],
            "line": 38,
            "updatePoint": {
                "line": 38,
                "column": 26
            },
            "code": "  it('is able to subscribe', function () {\n    var events = singleEventPubSub('someEventName');\n    expect(function () {\n      events.on(function () {});\n    }).not.toThrow();\n  });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is able to notify a subscribed function without an event object",
            "suites": [
                "single event pub sub"
            ],
            "line": 44,
            "updatePoint": {
                "line": 44,
                "column": 69
            },
            "code": "  it('is able to notify a subscribed function without an event object', function () {\n    var events = singleEventPubSub('someEventName');\n    var listener = jasmine.createSpy('listener');\n    events.on(listener);\n    events.emit();\n    expect(listener).toHaveBeenCalled();\n  });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "is able to notify a subscribed function with a event parameter",
            "suites": [
                "single event pub sub"
            ],
            "line": 51,
            "updatePoint": {
                "line": 51,
                "column": 68
            },
            "code": "  it('is able to notify a subscribed function with a event parameter', function () {\n    var events = singleEventPubSub('someEventName');\n    var listener = jasmine.createSpy('listener');\n    events.on(listener);\n    events.emit('somethingFunky');\n    expect(listener).toHaveBeenCalledWith('somethingFunky');\n  });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of new listeners when added without an id",
            "suites": [
                "single event pub sub"
            ],
            "line": 58,
            "updatePoint": {
                "line": 58,
                "column": 56
            },
            "code": "  it('notifies of new listeners when added without an id', function () {\n    var newListener = singleEventPubSub('newListener');\n    var someEventName = singleEventPubSub('someEventName', newListener);\n    var listenerListener = jasmine.createSpy('listenerListener');\n    newListener.on(listenerListener);\n    someEventName.on(noop);\n    expect(listenerListener).toHaveBeenCalledWith('someEventName', noop, noop);\n  });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies of new listeners when added with an id",
            "suites": [
                "single event pub sub"
            ],
            "line": 66,
            "updatePoint": {
                "line": 66,
                "column": 53
            },
            "code": "  it('notifies of new listeners when added with an id', function () {\n    var newListener = singleEventPubSub('newListener');\n    var someEventName = singleEventPubSub('someEventName', newListener);\n    var listenerListener = jasmine.createSpy('listenerListener');\n    newListener.on(listenerListener);\n    someEventName.on(noop, 'id1');\n    expect(listenerListener).toHaveBeenCalledWith('someEventName', noop, 'id1');\n  });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "notifies multiple listeners of the same event",
            "suites": [
                "single event pub sub"
            ],
            "line": 74,
            "updatePoint": {
                "line": 74,
                "column": 51
            },
            "code": "  it('notifies multiple listeners of the same event', function () {\n    var events = singleEventPubSub('someEventName');\n    var listenerA = jasmine.createSpy('listenerA');\n    var listenerA2 = jasmine.createSpy('listenerA2');\n    events.on(listenerA);\n    events.on(listenerA2);\n    events.emit();\n    expect(listenerA).toHaveBeenCalled();\n    expect(listenerA2).toHaveBeenCalled();\n  });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can pass through multiple parameters",
            "suites": [
                "single event pub sub"
            ],
            "line": 84,
            "updatePoint": {
                "line": 84,
                "column": 42
            },
            "code": "  it('can pass through multiple parameters', function () {\n    var events = singleEventPubSub('someEventName');\n    var listener = jasmine.createSpy('listener');\n    events.on(listener);\n    events.emit('a', 'b', 'c');\n    expect(listener).toHaveBeenCalledWith('a', 'b', 'c');\n  });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can pass multiple parameters to multiple listeners",
            "suites": [
                "single event pub sub"
            ],
            "line": 91,
            "updatePoint": {
                "line": 91,
                "column": 56
            },
            "code": "  it('can pass multiple parameters to multiple listeners', function () {\n    var events = singleEventPubSub('someEventName');\n    var listener = jasmine.createSpy('listener');\n    var listener2 = jasmine.createSpy('listener2');\n    events.on(listener);\n    events.on(listener2);\n    events.emit('a', 'b', 'c');\n    expect(listener).toHaveBeenCalledWith('a', 'b', 'c');\n    expect(listener2).toHaveBeenCalledWith('a', 'b', 'c');\n  });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "allows many listeners to be registered for an event",
            "suites": [
                "single event pub sub"
            ],
            "line": 101,
            "updatePoint": {
                "line": 101,
                "column": 57
            },
            "code": "  it('allows many listeners to be registered for an event', function () {\n    var events = singleEventPubSub('someEventName');\n    var listenerA = jasmine.createSpy('listenerA');\n\n    for (var i = 0; i < 10; i++) {\n      // listen ten times\n      events.on(listenerA);\n    }\n\n    for (var j = 0; j < 3; j++) {\n      // emit 3 times\n      events.emit();\n    }\n\n    expect(listenerA.calls.count()).toBe(30);\n  });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "has a chainable on function",
            "suites": [
                "single event pub sub"
            ],
            "line": 117,
            "updatePoint": {
                "line": 117,
                "column": 33
            },
            "code": "  it('has a chainable on function', function () {\n    var events = singleEventPubSub('someEventName');\n    var listenerA = jasmine.createSpy('listenerA');\n    var listenerB = jasmine.createSpy('listenerB');\n    events.on(listenerA).on(listenerB).emit();\n    expect(listenerA).toHaveBeenCalled();\n    expect(listenerB).toHaveBeenCalled();\n  });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "allows an event to be removed",
            "suites": [
                "single event pub sub"
            ],
            "line": 125,
            "updatePoint": {
                "line": 125,
                "column": 35
            },
            "code": "  it('allows an event to be removed', function () {\n    var events = singleEventPubSub('someEventName');\n    var listener1 = jasmine.createSpy('listener1');\n    var listener2 = jasmine.createSpy('listener2');\n    events.on(listener1);\n    events.on(listener2);\n    events.emit();\n    expect(listener1.calls.count()).toBe(1);\n    events.un(listener1);\n    events.emit();\n    expect(listener1.calls.count()).toBe(1);\n    expect(listener2.calls.count()).toBe(2);\n  });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "allows an event to be removed by an id",
            "suites": [
                "single event pub sub"
            ],
            "line": 138,
            "updatePoint": {
                "line": 138,
                "column": 44
            },
            "code": "  it('allows an event to be removed by an id', function () {\n    var events = singleEventPubSub('someEventName');\n    var listener1 = jasmine.createSpy('listener1');\n    var listener2 = jasmine.createSpy('listener2');\n    events.on(listener1, 'FOO_ID');\n    events.on(listener2, 'BAR_ID');\n    events.emit();\n    expect(listener1.calls.count()).toBe(1);\n    events.un('FOO_ID');\n    events.emit();\n    expect(listener1.calls.count()).toBe(1);\n    expect(listener2.calls.count()).toBe(2);\n    events.un('BAR_ID');\n    events.emit();\n    expect(listener2.calls.count()).toBe(2);\n  });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not fire removeListener if nothing is removed",
            "suites": [
                "single event pub sub"
            ],
            "line": 154,
            "updatePoint": {
                "line": 154,
                "column": 56
            },
            "code": "  it('does not fire removeListener if nothing is removed', function () {\n    var newListener = singleEventPubSub('newListener');\n    var removeListener = singleEventPubSub('removeListener');\n    var events = singleEventPubSub('someEventName', newListener, removeListener);\n    var removeListenerListener = jasmine.createSpy('removeListenerListener');\n    var fooListener = jasmine.createSpy('fooListener');\n    removeListener.on(removeListenerListener);\n    events.on(fooListener);\n    events.un('wrong_item');\n    expect(removeListenerListener).not.toHaveBeenCalled();\n  });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "fires removeListener when a listener is removed",
            "suites": [
                "single event pub sub"
            ],
            "line": 165,
            "updatePoint": {
                "line": 165,
                "column": 53
            },
            "code": "  it('fires removeListener when a listener is removed', function () {\n    var newListener = singleEventPubSub('newListener');\n    var removeListener = singleEventPubSub('removeListener');\n    var events = singleEventPubSub('someEventName', newListener, removeListener);\n    var removeListenerListener = jasmine.createSpy('removeListenerListener');\n    var fooListener = jasmine.createSpy('fooListener');\n    removeListener.on(removeListenerListener);\n    events.on(fooListener);\n    events.un(fooListener);\n    expect(removeListenerListener).toHaveBeenCalled();\n  });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not crash if asked to emit without listeners",
            "suites": [
                "single event pub sub"
            ],
            "line": 176,
            "updatePoint": {
                "line": 176,
                "column": 55
            },
            "code": "  it('does not crash if asked to emit without listeners', function () {\n    var events = singleEventPubSub('someEventName');\n    expect(function () {\n      events.emit('unknown event');\n    }).not.toThrow();\n  });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can return listeners when there haven't been any",
            "suites": [
                "single event pub sub",
                "listeners method"
            ],
            "line": 183,
            "updatePoint": {
                "line": 183,
                "column": 57
            },
            "code": "    it('can return listeners when there haven\\'t been any', function () {\n      var events = singleEventPubSub('someEventName');\n      expect(events.listeners('testEventType')).toBeFalsy();\n    });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can return listeners when one has been added",
            "suites": [
                "single event pub sub",
                "listeners method"
            ],
            "line": 187,
            "updatePoint": {
                "line": 187,
                "column": 52
            },
            "code": "    it('can return listeners when one has been added', function () {\n      var events = singleEventPubSub('someEventName');\n      events.on(noop);\n      expect(events.listeners('testEventType')).toBeList([noop, undefined]);\n    });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can return listeners when second is added",
            "suites": [
                "single event pub sub",
                "listeners method"
            ],
            "line": 192,
            "updatePoint": {
                "line": 192,
                "column": 49
            },
            "code": "    it('can return listeners when second is added', function () {\n      var events = singleEventPubSub('someEventName');\n      events.on(noop);\n      events.on(noop);\n      expect(events.listeners('testEventType')).toBeList(list(noop, noop));\n    });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can return listeners when one is removed",
            "suites": [
                "single event pub sub",
                "listeners method"
            ],
            "line": 198,
            "updatePoint": {
                "line": 198,
                "column": 48
            },
            "code": "    it('can return listeners when one is removed', function () {\n      var events = singleEventPubSub('someEventName');\n      events.on(noop);\n      events.on(noop);\n      events.un(noop);\n      expect(events.listeners('testEventType')).toBeList([noop, undefined]);\n    });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can return listeners when all are removed",
            "suites": [
                "single event pub sub",
                "listeners method"
            ],
            "line": 205,
            "updatePoint": {
                "line": 205,
                "column": 49
            },
            "code": "    it('can return listeners when all are removed', function () {\n      var events = singleEventPubSub('someEventName');\n      events.on(noop);\n      events.on(noop);\n      events.un(noop);\n      events.un(noop);\n      expect(events.listeners('testEventType')).toBeFalsy();\n    });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "returns false when there are no listeners",
            "suites": [
                "single event pub sub",
                "hasListener method"
            ],
            "line": 215,
            "updatePoint": {
                "line": 215,
                "column": 49
            },
            "code": "    it('returns false when there are no listeners', function () {\n      var event = singleEventPubSub('someEventName');\n      expect(event.hasListener()).toBeFalsy();\n    });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "returns false for an id when there are no listeners",
            "suites": [
                "single event pub sub",
                "hasListener method"
            ],
            "line": 219,
            "updatePoint": {
                "line": 219,
                "column": 59
            },
            "code": "    it('returns false for an id when there are no listeners', function () {\n      var event = singleEventPubSub('someEventName');\n      expect(event.hasListener('some_id')).toBeFalsy();\n    });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "returns true for a listener specified as the function",
            "suites": [
                "single event pub sub",
                "hasListener method"
            ],
            "line": 223,
            "updatePoint": {
                "line": 223,
                "column": 61
            },
            "code": "    it('returns true for a listener specified as the function', function () {\n      function exampleListener() {}\n\n      var event = singleEventPubSub('someEventName');\n      event.on(exampleListener);\n      expect(event.hasListener(exampleListener)).toBeTruthy();\n    });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "returns true for a listener specified using an id",
            "suites": [
                "single event pub sub",
                "hasListener method"
            ],
            "line": 230,
            "updatePoint": {
                "line": 230,
                "column": 57
            },
            "code": "    it('returns true for a listener specified using an id', function () {\n      function exampleListener() {}\n\n      var event = singleEventPubSub('someEventName');\n      event.on(exampleListener, 'exampleId');\n      expect(event.hasListener('exampleId')).toBeTruthy();\n    });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "returns false given the wrong id",
            "suites": [
                "single event pub sub",
                "hasListener method"
            ],
            "line": 237,
            "updatePoint": {
                "line": 237,
                "column": 40
            },
            "code": "    it('returns false given the wrong id', function () {\n      function exampleListener() {}\n\n      var event = singleEventPubSub('someEventName');\n      event.on(exampleListener, 'exampleId');\n      expect(event.hasListener('wrongId')).toBeFalsy();\n    });",
            "file": "specs/singleEventPubSub.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "completes",
            "suites": [
                "streaming xhr integration (real http)"
            ],
            "line": 63,
            "updatePoint": {
                "line": 63,
                "column": 15
            },
            "code": "  it('completes', function (done) {\n    // in practice, since we're running on an internal network and this is a small file,\n    // we'll probably only get one callback\n    var oboeBus = fakePubSub(emittedEvents);\n    streamingHttp(oboeBus, httpTransport(), 'GET', '/testServer/static/json/smallestPossible.json', null // this is a GET, no data to send\n    );\n    waitUntil(STREAM_END).isFiredOn(oboeBus, done);\n  });",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can ajax in a small known file",
            "suites": [
                "streaming xhr integration (real http)"
            ],
            "line": 71,
            "updatePoint": {
                "line": 71,
                "column": 36
            },
            "code": "  it('can ajax in a small known file', function (done) {\n    // in practice, since we're running on an internal network and this is a small file,\n    // we'll probably only get one callback\n    var oboeBus = fakePubSub(emittedEvents);\n    streamingHttp(oboeBus, httpTransport(), 'GET', '/testServer/static/json/smallestPossible.json', null // this is a GET, no data to send\n    );\n    waitUntil(STREAM_END).isFiredOn(oboeBus, function () {\n      expect(oboeBus).toHaveGivenStreamEventsInCorrectOrder();\n      expect(streamedContentPassedTo(oboeBus)).toParseTo({});\n      done();\n    });\n  });",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "fires HTTP_START with status and headers",
            "suites": [
                "streaming xhr integration (real http)"
            ],
            "line": 83,
            "updatePoint": {
                "line": 83,
                "column": 46
            },
            "code": "  it('fires HTTP_START with status and headers', function (done) {\n    var oboeBus = fakePubSub(emittedEvents);\n    streamingHttp(oboeBus, httpTransport(), 'GET', '/testServer/echoBackHeadersAsHeaders', null, // this is a GET, no data to send\n    {\n      specialheader: 'specialValue'\n    });\n    waitUntil(STREAM_END).isFiredOn(oboeBus, function () {\n      expect(oboeBus(HTTP_START).emit).toHaveBeenCalledWith(200, jasmine.objectContaining({\n        specialheader: 'specialValue'\n      }));\n      done();\n    });\n  });",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives XHR header so server knows this is an xhr request",
            "suites": [
                "streaming xhr integration (real http)"
            ],
            "line": 96,
            "updatePoint": {
                "line": 96,
                "column": 61
            },
            "code": "  it('gives XHR header so server knows this is an xhr request', function (done) {\n    var oboeBus = fakePubSub(emittedEvents);\n    streamingHttp(oboeBus, httpTransport(), 'GET', '/testServer/echoBackHeadersAsHeaders');\n    waitUntil(STREAM_END).isFiredOn(oboeBus, function () {\n      expect(oboeBus(HTTP_START).emit).toHaveBeenCalledWith(200, jasmine.objectContaining({\n        'x-requested-with': 'XMLHttpRequest'\n      }));\n      done();\n    });\n  });",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "fires HTTP_START, STREAM_DATA and STREAM_END in correct order",
            "suites": [
                "streaming xhr integration (real http)"
            ],
            "line": 106,
            "updatePoint": {
                "line": 106,
                "column": 67
            },
            "code": "  it('fires HTTP_START, STREAM_DATA and STREAM_END in correct order', function (done) {\n    // in practice, since we're running on an internal network and this is a small file,\n    // we'll probably only get one callback\n    var oboeBus = fakePubSub(emittedEvents);\n    streamingHttp(oboeBus, httpTransport(), 'GET', '/testServer/echoBackHeadersAsHeaders', null, // this is a GET, no data to send\n    {\n      specialheader: 'specialValue'\n    });\n    waitUntil(STREAM_END).isFiredOn(oboeBus, function () {\n      expect(oboeBus).toHaveGivenStreamEventsInCorrectOrder();\n      done();\n    });\n  });",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "fires FAIL_EVENT if url does not exist",
            "suites": [
                "streaming xhr integration (real http)"
            ],
            "line": 119,
            "updatePoint": {
                "line": 119,
                "column": 44
            },
            "code": "  it('fires FAIL_EVENT if url does not exist', function (done) {\n    var oboeBus = fakePubSub(emittedEvents);\n    streamingHttp(oboeBus, httpTransport(), 'GET', '/testServer/noSuchUrl', null);\n    waitUntil(FAIL_EVENT).isFiredOn(oboeBus, done);\n  });",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can ajax in a very large file without missing any",
            "suites": [
                "streaming xhr integration (real http)"
            ],
            "line": 124,
            "updatePoint": {
                "line": 124,
                "column": 55
            },
            "code": "  it('can ajax in a very large file without missing any', function (done) {\n    // in practice, since we're running on an internal network and this is a small file,\n    // we'll probably only get one callback\n    var oboeBus = fakePubSub(emittedEvents);\n    streamingHttp(oboeBus, httpTransport(), 'GET', '/testServer/static/json/twentyThousandRecords.json', null // this is a GET, no data to send\n    );\n    waitUntil(STREAM_END).isFiredOn(oboeBus, function () {\n      var runFunction = function () {\n        return JSON.parse(streamedContentPassedTo(oboeBus));\n      };\n\n      expect(runFunction).not.toThrow();\n      var parsedResult = runFunction(); // as per the name, should have 20,000 records in that file:\n\n      expect(parsedResult.result.length).toEqual(20000);\n      done();\n    });\n  });",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can ajax in a streaming file without missing any",
            "suites": [
                "streaming xhr integration (real http)"
            ],
            "line": 142,
            "updatePoint": {
                "line": 142,
                "column": 54
            },
            "code": "  it('can ajax in a streaming file without missing any', function (done) {\n    // in practice, since we're running on an internal network and this is a small file,\n    // we'll probably only get one callback\n    var oboeBus = fakePubSub(emittedEvents);\n    streamingHttp(oboeBus, httpTransport(), 'GET', '/testServer/tenSlowNumbers?withoutMissingAny', null // this is a GET, no data to send\n    );\n    waitUntil(STREAM_END).isFiredOn(oboeBus, function () {\n      // as per the name, should have ten numbers in that file:\n      expect(streamedContentPassedTo(oboeBus)).toParseTo([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n      expect(oboeBus).toHaveGivenStreamEventsInCorrectOrder();\n      done();\n    });\n  });",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "sends cookies by default",
            "suites": [
                "streaming xhr integration (real http)"
            ],
            "line": 155,
            "updatePoint": {
                "line": 155,
                "column": 30
            },
            "code": "  it('sends cookies by default', function (done) {\n    document.cookie = 'token=123456; path=/'; // in practice, since we're running on an internal network and this is a small file,\n    // we'll probably only get one callback\n\n    var oboeBus = fakePubSub(emittedEvents);\n    streamingHttp(oboeBus, httpTransport(), 'GET', '/testServer/echoBackHeadersAsBodyJson', null);\n    waitUntil(STREAM_END).isFiredOn(oboeBus, function () {\n      var parsedResult = JSON.parse(streamedContentPassedTo(oboeBus));\n      expect(parsedResult.cookie).toMatch('token=123456');\n      done();\n    });\n  });",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not send cookies by default to cross-domain requests",
            "suites": [
                "streaming xhr integration (real http)"
            ],
            "line": 167,
            "updatePoint": {
                "line": 167,
                "column": 63
            },
            "code": "  it('does not send cookies by default to cross-domain requests', function (done) {\n    document.cookie = 'deniedToken=123456; path=/'; // in practice, since we're running on an internal network and this is a small file,\n    // we'll probably only get one callback\n\n    var oboeBus = fakePubSub(emittedEvents);\n    streamingHttp(oboeBus, httpTransport(), 'GET', window.crossDomainUrl('/echoBackHeadersAsBodyJson'), null);\n    waitUntil(STREAM_END).isFiredOn(oboeBus, function () {\n      var parsedResult = JSON.parse(streamedContentPassedTo(oboeBus));\n      expect(parsedResult.cookie).not.toMatch('deniedToken=123456');\n      done();\n    });\n  });",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "sends cookies to cross-domain requests if withCredentials is true",
            "suites": [
                "streaming xhr integration (real http)"
            ],
            "line": 179,
            "updatePoint": {
                "line": 179,
                "column": 71
            },
            "code": "  it('sends cookies to cross-domain requests if withCredentials is true', function (done) {\n    document.cookie = 'corsToken=123456; path=/'; // in practice, since we're running on an internal network and this is a small file,\n    // we'll probably only get one callback\n\n    var oboeBus = fakePubSub(emittedEvents);\n    streamingHttp(oboeBus, httpTransport(), 'GET', window.crossDomainUrl('/echoBackHeadersAsBodyJson'), null, // data\n    null, // headers\n    true // withCredentials\n    );\n    waitUntil(STREAM_END).isFiredOn(oboeBus, function () {\n      var parsedResult = JSON.parse(streamedContentPassedTo(oboeBus));\n      expect(parsedResult.cookie).toMatch('corsToken=123456');\n      done();\n    });\n  });",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can make a post request",
            "suites": [
                "streaming xhr integration (real http)"
            ],
            "line": 194,
            "updatePoint": {
                "line": 194,
                "column": 29
            },
            "code": "  it('can make a post request', function (done) {\n    var payload = {\n      thisWill: 'bePosted',\n      andShould: 'be',\n      echoed: 'back'\n    }; // in practice, since we're running on an internal network and this is a small file,\n    // we'll probably only get one callback\n\n    var oboeBus = fakePubSub(emittedEvents);\n    streamingHttp(oboeBus, httpTransport(), 'POST', '/testServer/echoBackBody', JSON.stringify(payload));\n    waitUntil(STREAM_END).isFiredOn(oboeBus, function () {\n      expect(streamedContentPassedTo(oboeBus)).toParseTo(payload);\n      expect(oboeBus).toHaveGivenStreamEventsInCorrectOrder();\n      done();\n    });\n  });",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can make a put request",
            "suites": [
                "streaming xhr integration (real http)"
            ],
            "line": 210,
            "updatePoint": {
                "line": 210,
                "column": 28
            },
            "code": "  it('can make a put request', function (done) {\n    var payload = {\n      thisWill: 'bePut',\n      andShould: 'be',\n      echoed: 'back'\n    }; // in practice, since we're running on an internal network and this is a small file,\n    // we'll probably only get one callback\n\n    var oboeBus = fakePubSub(emittedEvents);\n    streamingHttp(oboeBus, httpTransport(), 'PUT', '/testServer/echoBackBody', JSON.stringify(payload));\n    waitUntil(STREAM_END).isFiredOn(oboeBus, function () {\n      expect(streamedContentPassedTo(oboeBus)).toParseTo(payload);\n      expect(oboeBus).toHaveGivenStreamEventsInCorrectOrder();\n      done();\n    });\n  });",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "can make a patch request",
            "suites": [
                "streaming xhr integration (real http)"
            ],
            "line": 226,
            "updatePoint": {
                "line": 226,
                "column": 30
            },
            "code": "  it('can make a patch request', function (done) {\n    if (Platform.isInternetExplorer) {\n      console.warn('PATCH requests don\\'t work well under IE. Skipping PATCH integration test');\n      return;\n    }\n\n    var payload = {\n      thisWill: 'bePatched',\n      andShould: 'be',\n      echoed: 'back'\n    }; // in practice, since we're running on an internal network and this is a small file,\n    // we'll probably only get one callback\n\n    var oboeBus = fakePubSub(emittedEvents);\n    streamingHttp(oboeBus, httpTransport(), 'PATCH', '/testServer/echoBackBody', JSON.stringify(payload));\n    waitUntil(STREAM_END).isFiredOn(oboeBus, function () {\n      if (streamedContentPassedTo(oboeBus) === '' && Platform.isPhantom) {\n        console.warn('this user agent seems not to support giving content' + ' back for of PATCH requests.' + ' This happens on PhantomJS');\n      } else {\n        expect(streamedContentPassedTo(oboeBus)).toParseTo(payload);\n        expect(oboeBus).toHaveGivenStreamEventsInCorrectOrder();\n      }\n\n      done();\n    });\n  }); // this test is only activated for non-IE browsers and IE 10 or newer.",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives multiple callbacks when loading a streaming resource",
            "suites": [
                "streaming xhr integration (real http)"
            ],
            "line": 257,
            "updatePoint": {
                "line": 257,
                "column": 66
            },
            "code": "    it('gives multiple callbacks when loading a streaming resource', function (done) {\n      var oboeBus = fakePubSub(emittedEvents);\n      streamingHttp(oboeBus, httpTransport(), 'GET', '/testServer/tenSlowNumbers', null // this is a get: no data to send\n      );\n      waitUntil(STREAM_END).isFiredOn(oboeBus, function () {\n        // realistically, should have had 10 or 20, but this isn't deterministic so\n        // 3 is enough to indicate the results didn't all arrive in one big blob.\n        expect(oboeBus.callCount[STREAM_DATA]).toBeGreaterThan(3);\n        expect(oboeBus).toHaveGivenStreamEventsInCorrectOrder();\n        done();\n      });\n    });",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives multiple callbacks when loading a gzipped streaming resource",
            "suites": [
                "streaming xhr integration (real http)"
            ],
            "line": 269,
            "updatePoint": {
                "line": 269,
                "column": 74
            },
            "code": "    it('gives multiple callbacks when loading a gzipped streaming resource', function (done) {\n      var oboeBus = fakePubSub(emittedEvents);\n      streamingHttp(oboeBus, httpTransport(), 'GET', '/testServer/gzippedTwoHundredItems', null // this is a get: no data to send\n      );\n      waitUntil(STREAM_END).isFiredOn(oboeBus, function () {\n        // some platforms can't help but not work here so warn but don't\n        // fail the test:\n        if (oboeBus.callCount[STREAM_DATA] === 1 && (Platform.isInternetExplorer || Platform.isPhantom)) {\n          console.warn('This user agent seems to give gzipped responses' + 'as a single event, not progressively. This happens on ' + 'PhantomJS and IE < 9');\n        } else {\n          expect(oboeBus.callCount[STREAM_DATA]).toBeGreaterThan(1);\n        }\n\n        expect(oboeBus).toHaveGivenStreamEventsInCorrectOrder();\n        done();\n      });\n    }, 10000);",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not call back with zero-length bites",
            "suites": [
                "streaming xhr integration (real http)"
            ],
            "line": 288,
            "updatePoint": {
                "line": 288,
                "column": 47
            },
            "code": "  it('does not call back with zero-length bites', function (done) {\n    // since this is a large file, even serving locally we're going to get multiple callbacks:\n    var oboeBus = fakePubSub(emittedEvents);\n    streamingHttp(oboeBus, httpTransport(), 'GET', '/testServer/static/json/oneHundredRecords.json', null // this is a GET: no data to send\n    );\n    waitUntil(STREAM_END).isFiredOn(oboeBus, function () {\n      var dripsReceived = oboeBus.eventTypesEmitted[STREAM_DATA].map(function (args) {\n        return args[0];\n      });\n      expect(dripsReceived.length).toBeGreaterThan(0);\n      dripsReceived.forEach(function (drip) {\n        expect(drip.length).not.toEqual(0);\n      });\n      done();\n    });\n  });",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not process the stream",
            "suites": [
                "streaming xhr integration (real http)",
                "when the request is unsuccessful"
            ],
            "line": 305,
            "updatePoint": {
                "line": 305,
                "column": 37
            },
            "code": "    it('should not process the stream', function (done) {\n      var oboeBus = fakePubSub(emittedEvents);\n      streamingHttp(oboeBus, httpTransport(), 'GET', '/testServer/401withData', null // this is a GET: no data to send\n      );\n      waitUntil(FAIL_EVENT).isFiredOn(oboeBus, function () {\n        expect(oboeBus.callCount[STREAM_DATA]).toBe(0);\n        done();\n      });\n    });",
            "file": "specs/streamingHttp.integration.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "raises an event for first bit of content",
            "suites": [
                "streaming http in a browser"
            ],
            "line": 17,
            "updatePoint": {
                "line": 17,
                "column": 46
            },
            "code": "  it('raises an event for first bit of content', function () {\n    var fakeBus = fakeBusWithEventsForStreamingHttp();\n    var fakeXhr = fakeXhr2();\n    var responseBody = '[1,2,3,4,5,6,7,8,9,10]';\n    streamingHttp(fakeBus, fakeXhr, 'GET', 'http://example.com', null, {}, false);\n    fakeXhr.respond(200, {}, responseBody); // fakeXhr.setResponseBody('here is a response body');\n  });",
            "file": "specs/streamingHttp.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives xhr null when body is null",
            "suites": [
                "streamingHttp",
                "calls through to browser xhr"
            ],
            "line": 19,
            "updatePoint": {
                "line": 19,
                "column": 40
            },
            "code": "    it('gives xhr null when body is null', function () {\n      streamingHttp(eventBus, xhr, 'GET', 'http://example.com', null);\n      expect(xhr.send).toHaveBeenCalledWith(null);\n    });",
            "file": "specs/streamingXhr.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "give xhr string request body",
            "suites": [
                "streamingHttp",
                "calls through to browser xhr"
            ],
            "line": 23,
            "updatePoint": {
                "line": 23,
                "column": 36
            },
            "code": "    it('give xhr string request body', function () {\n      streamingHttp(eventBus, xhr, 'GET', 'http://example.com', 'my_data');\n      expect(xhr.send).toHaveBeenCalledWith('my_data');\n    });",
            "file": "specs/streamingXhr.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "gives xhr the request headers",
            "suites": [
                "streamingHttp",
                "calls through to browser xhr"
            ],
            "line": 27,
            "updatePoint": {
                "line": 27,
                "column": 37
            },
            "code": "    it('gives xhr the request headers', function () {\n      var headers = {\n        'X-FROODINESS': 'frood',\n        'X-HOOPINESS': 'hoopy'\n      };\n      streamingHttp(eventBus, xhr, 'GET', 'http://example.com', undefined, headers);\n      expect(xhr.setRequestHeader).toHaveBeenCalledWith('X-FROODINESS', 'frood');\n      expect(xhr.setRequestHeader).toHaveBeenCalledWith('X-HOOPINESS', 'hoopy');\n    });",
            "file": "specs/streamingXhr.unit.spec.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should be able to abort an xhr once started",
            "suites": [
                "streamingHttp",
                "calls through to browser xhr"
            ],
            "line": 36,
            "updatePoint": {
                "line": 36,
                "column": 51
            },
            "code": "    it('should be able to abort an xhr once started', function () {\n      streamingHttp(eventBus, xhr, 'GET', 'http://example.com', 'my_data');\n      eventBus(ABORTING).emit();\n      expect(xhr.abort).toHaveBeenCalled();\n    });",
            "file": "specs/streamingXhr.unit.spec.js",
            "skipped": false,
            "dir": "test"
        }
    ],
    "badge": "jimhigson__oboe_js.svg"
}