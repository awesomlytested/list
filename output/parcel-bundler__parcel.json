{"repo":"parcel-bundler/parcel","url":"https://github.com/parcel-bundler/parcel","branch":"v2","configs":[{"package":"@parcel/config-default","lang":"js","dir":"packages/configs/default/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/codeframe","lang":"js","dir":"packages/core/codeframe/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/core","lang":"js","dir":"packages/core/core/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/diagnostic","lang":"js","dir":"packages/core/diagnostic/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/graph","lang":"js","dir":"packages/core/graph/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/integration-tests","lang":"js","dir":"packages/core/integration-tests/test","framework":"mocha","pattern":"**/*.{js,ts}"},{"package":"resolver-alternative-relative-test","lang":"js","dir":"packages/core/integration-tests/test/integration/resolver-alternative-relative/test","framework":"mocha","pattern":"**/*.{js,ts}"},{"package":"@parcel/logger","lang":"js","dir":"packages/core/logger/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/markdown-ansi","lang":"js","dir":"packages/core/markdown-ansi/test","framework":"mocha","pattern":"**/*.{js,ts}"},{"package":"@parcel/package-manager","lang":"js","dir":"packages/core/package-manager/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/utils","lang":"js","dir":"packages/core/utils/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/workers","lang":"js","dir":"packages/core/workers/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/eslint-plugin","lang":"js","dir":"packages/dev/eslint-plugin/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/reporter-cli","lang":"js","dir":"packages/reporters/cli/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/babel-ast-utils","lang":"js","dir":"packages/shared/babel-ast-utils/test","framework":"mocha","pattern":"**/*.{js,ts}"},{"package":"@parcel/transformer-svg","lang":"js","dir":"packages/transformers/svg/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/babel-plugin-transform-runtime","lang":"js","dir":"packages/utils/babel-plugin-transform-runtime/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/babel-preset-env","lang":"js","dir":"packages/utils/babel-preset-env/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/events","lang":"js","dir":"packages/utils/events/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/fs-write-stream-atomic","lang":"js","dir":"packages/utils/fs-write-stream-atomic/test","framework":"mocha","pattern":"**/*.{js,ts}"},{"package":"@parcel/node-resolver-core","lang":"js","dir":"packages/utils/node-resolver-core/test","framework":"mocha","pattern":"**/*.{js,ts}"}],"tests":[{"name":"includes every package referenced in the config","suites":["@parcel/config-default","package.json"],"updatePoint":{"line":12,"column":55,"index":536},"line":12,"code":"    it('includes every package referenced in the config', () => {\n      let missingReferences = [];\n      for (let reference of configPackageReferences) {\n        if (!packageJsonDependencyNames.has(reference)) {\n          missingReferences.push(reference);\n        }\n      }\n\n      // Assert with deepEqual rather than e.g. missingReferences.size as the\n      // assertion message with deepEqual enumerates the differences nicely\n      assert.deepEqual(missingReferences, []);\n    });","file":"config.test.js","skipped":false,"dir":"packages/configs/default/test"},{"name":"does not include packages not referenced in the config","suites":["@parcel/config-default","package.json"],"updatePoint":{"line":24,"column":62,"index":1029},"line":24,"code":"    it('does not include packages not referenced in the config', () => {\n      let unnecessaryDependencies = [];\n      for (let dependency of packageJsonDependencyNames) {\n        if (!configPackageReferences.has(dependency)) {\n          unnecessaryDependencies.push(dependency);\n        }\n      }\n      assert.deepEqual(unnecessaryDependencies, []);\n    });","file":"config.test.js","skipped":false,"dir":"packages/configs/default/test"},{"name":"should create a codeframe","suites":["codeframe"],"updatePoint":{"line":7,"column":31,"index":232},"line":7,"code":"  it('should create a codeframe', () => {\n    let codeframeString = codeframe('hello world', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 1,\n        line: 1\n      }\n    }, {\n      start: {\n        column: 3,\n        line: 1\n      },\n      end: {\n        column: 5,\n        line: 1\n      }\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^ ^^^');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should create a codeframe with multiple lines","suites":["codeframe"],"updatePoint":{"line":33,"column":51,"index":774},"line":33,"code":"  it('should create a codeframe with multiple lines', () => {\n    let codeframeString = codeframe('hello world\\nEnjoy this nice codeframe', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 1,\n        line: 1\n      }\n    }, {\n      start: {\n        column: 7,\n        line: 1\n      },\n      end: {\n        column: 10,\n        line: 2\n      }\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^     ^^^^^');\n    assert.equal(lines[2], '> 2 | Enjoy this nice codeframe');\n    assert.equal(lines[3], '>   | ^^^^^^^^^^');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should handle unordered overlapping highlights properly","suites":["codeframe"],"updatePoint":{"line":61,"column":61,"index":1471},"line":61,"code":"  it('should handle unordered overlapping highlights properly', () => {\n    let codeframeString = codeframe('hello world\\nEnjoy this nice codeframe', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 1,\n        line: 1\n      }\n    }, {\n      start: {\n        column: 7,\n        line: 1\n      },\n      end: {\n        column: 10,\n        line: 2\n      }\n    }, {\n      start: {\n        column: 4,\n        line: 2\n      },\n      end: {\n        column: 7,\n        line: 2\n      }\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^     ^^^^^');\n    assert.equal(lines[2], '> 2 | Enjoy this nice codeframe');\n    assert.equal(lines[3], '>   | ^^^^^^^^^^');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should handle partial overlapping highlights properly","suites":["codeframe"],"updatePoint":{"line":98,"column":59,"index":2290},"line":98,"code":"  it('should handle partial overlapping highlights properly', () => {\n    let codeframeString = codeframe('hello world\\nEnjoy this nice codeframe', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 1,\n        line: 1\n      }\n    }, {\n      start: {\n        column: 7,\n        line: 1\n      },\n      end: {\n        column: 10,\n        line: 2\n      }\n    }, {\n      start: {\n        column: 4,\n        line: 2\n      },\n      end: {\n        column: 12,\n        line: 2\n      }\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^     ^^^^^');\n    assert.equal(lines[2], '> 2 | Enjoy this nice codeframe');\n    assert.equal(lines[3], '>   | ^^^^^^^^^^^^');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should be able to render inline messages","suites":["codeframe"],"updatePoint":{"line":135,"column":46,"index":3099},"line":135,"code":"  it('should be able to render inline messages', () => {\n    let codeframeString = codeframe('hello world\\nEnjoy this nice codeframe', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 6,\n        line: 1\n      },\n      message: 'test'\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^^^^^^ test');\n    assert.equal(lines[2], '  2 | Enjoy this nice codeframe');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should only render last inline message of a column","suites":["codeframe"],"updatePoint":{"line":154,"column":56,"index":3641},"line":154,"code":"  it('should only render last inline message of a column', () => {\n    let codeframeString = codeframe('hello world\\nEnjoy this nice codeframe', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 3,\n        line: 1\n      },\n      message: 'test'\n    }, {\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 6,\n        line: 1\n      },\n      message: 'this should be printed'\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^^^^^^ this should be printed');\n    assert.equal(lines[2], '  2 | Enjoy this nice codeframe');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should only render last inline message of a column with space","suites":["codeframe"],"updatePoint":{"line":183,"column":67,"index":4377},"line":183,"code":"  it('should only render last inline message of a column with space', () => {\n    let codeframeString = codeframe('hello world\\nEnjoy this nice codeframe', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 1,\n        line: 1\n      },\n      message: 'test'\n    }, {\n      start: {\n        column: 3,\n        line: 1\n      },\n      end: {\n        column: 7,\n        line: 1\n      },\n      message: 'this should be printed'\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^ ^^^^^ this should be printed');\n    assert.equal(lines[2], '  2 | Enjoy this nice codeframe');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should only render last inline message of a column with multiple lines and space","suites":["codeframe"],"updatePoint":{"line":212,"column":86,"index":5133},"line":212,"code":"  it('should only render last inline message of a column with multiple lines and space', () => {\n    let codeframeString = codeframe('hello world\\nEnjoy this nice codeframe\\nThis is another line', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 1,\n        line: 1\n      },\n      message: 'test'\n    }, {\n      start: {\n        column: 3,\n        line: 1\n      },\n      end: {\n        column: 7,\n        line: 1\n      },\n      message: 'this should be printed'\n    }, {\n      start: {\n        column: 3,\n        line: 2\n      },\n      end: {\n        column: 7,\n        line: 3\n      },\n      message: 'message line 2'\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^ ^^^^^ this should be printed');\n    assert.equal(lines[2], '> 2 | Enjoy this nice codeframe');\n    assert.equal(lines[3], '>   |   ^^^^^^^^^^^^^^^^^^^^^^^');\n    assert.equal(lines[4], '> 3 | This is another line');\n    assert.equal(lines[5], '>   | ^^^^^^^ message line 2');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should only render last inline message of a column with multiple lines and space","suites":["codeframe"],"updatePoint":{"line":254,"column":86,"index":6249},"line":254,"code":"  it('should only render last inline message of a column with multiple lines and space', () => {\n    let codeframeString = codeframe('hello world\\nEnjoy this nice codeframe\\nThis is another line', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 1,\n        line: 1\n      },\n      message: 'test'\n    }, {\n      start: {\n        column: 3,\n        line: 1\n      },\n      end: {\n        column: 7,\n        line: 1\n      },\n      message: 'this should be printed'\n    }, {\n      start: {\n        column: 3,\n        line: 2\n      },\n      end: {\n        column: 7,\n        line: 3\n      },\n      message: 'message line 2'\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^ ^^^^^ this should be printed');\n    assert.equal(lines[2], '> 2 | Enjoy this nice codeframe');\n    assert.equal(lines[3], '>   |   ^^^^^^^^^^^^^^^^^^^^^^^');\n    assert.equal(lines[4], '> 3 | This is another line');\n    assert.equal(lines[5], '>   | ^^^^^^^ message line 2');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should properly use padding","suites":["codeframe"],"updatePoint":{"line":296,"column":33,"index":7312},"line":296,"code":"  it('should properly use padding', () => {\n    let codeframeString = codeframe('test\\n'.repeat(100), [{\n      start: {\n        column: 2,\n        line: 5\n      },\n      end: {\n        column: 2,\n        line: 5\n      },\n      message: 'test'\n    }], {\n      useColor: false,\n      padding: {\n        before: 2,\n        after: 4\n      }\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 8);\n    assert.equal(lines[0], '  3 | test');\n    assert.equal(lines[2], '> 5 | test');\n    assert.equal(lines[3], '>   |  ^ test');\n    assert.equal(lines[7], '  9 | test');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should properly pad numbers for large files","suites":["codeframe"],"updatePoint":{"line":321,"column":49,"index":7934},"line":321,"code":"  it('should properly pad numbers for large files', () => {\n    let codeframeString = codeframe('test\\n'.repeat(1000), [{\n      start: {\n        column: 2,\n        line: 99\n      },\n      end: {\n        column: 2,\n        line: 99\n      },\n      message: 'test'\n    }, {\n      start: {\n        column: 2,\n        line: 100\n      },\n      end: {\n        column: 2,\n        line: 100\n      },\n      message: 'test 2'\n    }]);\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 7);\n    assert.equal(lines[0], '   98 | test');\n    assert.equal(lines[1], '>  99 | test');\n    assert.equal(lines[2], '>     |  ^ test');\n    assert.equal(lines[3], '> 100 | test');\n    assert.equal(lines[4], '>     |  ^ test 2');\n    assert.equal(lines[5], '  101 | test');\n    assert.equal(lines[6], '  102 | test');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should properly pad numbers for short files","suites":["codeframe"],"updatePoint":{"line":353,"column":49,"index":8764},"line":353,"code":"  it('should properly pad numbers for short files', () => {\n    let codeframeString = codeframe('test\\n'.repeat(1000), [{\n      start: {\n        column: 2,\n        line: 7\n      },\n      end: {\n        column: 2,\n        line: 7\n      },\n      message: 'test'\n    }, {\n      start: {\n        column: 2,\n        line: 12\n      },\n      end: {\n        column: 2,\n        line: 12\n      },\n      message: 'test'\n    }]);\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 11);\n    assert.equal(lines[0], '   6 | test');\n    assert.equal(lines[4], '   9 | test');\n    assert.equal(lines[5], '  10 | test');\n    assert.equal(lines[6], '  11 | test');\n    assert.equal(lines[10], '  14 | test');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should properly use maxLines","suites":["codeframe"],"updatePoint":{"line":383,"column":34,"index":9474},"line":383,"code":"  it('should properly use maxLines', () => {\n    let line = 'test '.repeat(100);\n    let codeframeString = codeframe(`${line}\\n`.repeat(100), [{\n      start: {\n        column: 2,\n        line: 5\n      },\n      end: {\n        column: 2,\n        line: 5\n      },\n      message: 'test'\n    }, {\n      start: {\n        column: 2,\n        line: 12\n      },\n      end: {\n        column: 2,\n        line: 20\n      },\n      message: 'test'\n    }], {\n      useColor: false,\n      maxLines: 10,\n      terminalWidth: 5\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 13);\n    assert.equal(lines[0], '   4 | test test ');\n    assert.equal(lines[7], '  10 | test test ');\n    assert.equal(lines[11], '> 13 | test test ');\n    assert.equal(lines[12], '>    | ^^^^^^^^^^');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should be able to handle tabs","suites":["codeframe"],"updatePoint":{"line":417,"column":35,"index":10280},"line":417,"code":"  it('should be able to handle tabs', () => {\n    let codeframeString = codeframe('hel\\tlo wor\\tld\\nEnjoy thi\\ts nice cod\\teframe', [{\n      start: {\n        column: 5,\n        line: 1\n      },\n      end: {\n        column: 8,\n        line: 1\n      },\n      message: 'test'\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hel  lo wor  ld');\n    assert.equal(lines[1], '>   |      ^^^^ test');\n    assert.equal(lines[2], '  2 | Enjoy thi  s nice cod  eframe');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should be able to handle tabs with multiple highlights","suites":["codeframe"],"updatePoint":{"line":436,"column":60,"index":10845},"line":436,"code":"  it('should be able to handle tabs with multiple highlights', () => {\n    let codeframeString = codeframe('hel\\tlo wor\\tld\\nEnjoy thi\\ts nice cod\\teframe', [{\n      start: {\n        column: 3,\n        line: 1\n      },\n      end: {\n        column: 5,\n        line: 1\n      },\n      message: 'test'\n    }, {\n      start: {\n        column: 7,\n        line: 1\n      },\n      end: {\n        column: 8,\n        line: 1\n      },\n      message: 'test'\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hel  lo wor  ld');\n    assert.equal(lines[1], '>   |   ^^^^ ^^ test');\n    assert.equal(lines[2], '  2 | Enjoy thi  s nice cod  eframe');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"multiline highlights with tabs","suites":["codeframe"],"updatePoint":{"line":465,"column":36,"index":11533},"line":465,"code":"  it('multiline highlights with tabs', () => {\n    let codeframeString = codeframe('hel\\tlo wor\\tld\\nEnjoy thi\\ts nice cod\\teframe\\ntest', [{\n      start: {\n        column: 3,\n        line: 1\n      },\n      end: {\n        column: 2,\n        line: 3\n      },\n      message: 'test'\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hel  lo wor  ld');\n    assert.equal(lines[1], '>   |   ^^^^^^^^^^^^^');\n    assert.equal(lines[2], '> 2 | Enjoy thi  s nice cod  eframe');\n    assert.equal(lines[3], '>   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^');\n    assert.equal(lines[4], '> 3 | test');\n    assert.equal(lines[5], '>   | ^^ test');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"Should truncate long lines and print message","suites":["codeframe"],"updatePoint":{"line":487,"column":50,"index":12249},"line":487,"code":"  it('Should truncate long lines and print message', () => {\n    let originalLine = 'hello world '.repeat(1000);\n    let codeframeString = codeframe(originalLine, [{\n      start: {\n        column: 1000,\n        line: 1\n      },\n      end: {\n        column: 1200,\n        line: 1\n      },\n      message: 'This is a message'\n    }], {\n      useColor: false,\n      terminalWidth: 25\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 2);\n    assert.equal(lines[0], '> 1 | d hello world hello');\n    assert.equal(lines[1], '>   |      ^^^^^^^^^^^^^^ This is a message');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"Truncation across multiple lines","suites":["codeframe"],"updatePoint":{"line":508,"column":38,"index":12847},"line":508,"code":"  it('Truncation across multiple lines', () => {\n    let originalLine = 'hello world '.repeat(100) + '\\n' + 'new line '.repeat(100);\n    let codeframeString = codeframe(originalLine, [{\n      start: {\n        column: 15,\n        line: 1\n      },\n      end: {\n        column: 400,\n        line: 1\n      },\n      message: 'This is the first line'\n    }, {\n      start: {\n        column: 2,\n        line: 2\n      },\n      end: {\n        column: 100,\n        line: 2\n      },\n      message: 'This is the second line'\n    }], {\n      useColor: false,\n      terminalWidth: 25\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 4);\n    assert.equal(lines[0], '> 1 | ld hello world hell');\n    assert.equal(lines[1], '>   |      ^^^^^^^^^^^^^^ This is the first line');\n    assert.equal(lines[2], '> 2 | new line new line n');\n    assert.equal(lines[3], '>   |  ^^^^^^^^^^^^^^^^^^ This is the second line');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"Truncation across various types and positions of highlights","suites":["codeframe"],"updatePoint":{"line":541,"column":65,"index":13817},"line":541,"code":"  it('Truncation across various types and positions of highlights', () => {\n    let originalLine = 'hello world '.repeat(100) + '\\n' + 'new line '.repeat(100);\n    let codeframeString = codeframe(originalLine, [{\n      start: {\n        column: 2,\n        line: 1\n      },\n      end: {\n        column: 5,\n        line: 1\n      }\n    }, {\n      start: {\n        column: 6,\n        line: 1\n      },\n      end: {\n        column: 10,\n        line: 1\n      },\n      message: 'I have a message'\n    }, {\n      start: {\n        column: 15,\n        line: 1\n      },\n      end: {\n        column: 25,\n        line: 1\n      },\n      message: 'I also have a message'\n    }, {\n      start: {\n        column: 2,\n        line: 2\n      },\n      end: {\n        column: 5,\n        line: 2\n      },\n      message: 'This is the second line'\n    }], {\n      useColor: false,\n      terminalWidth: 25\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 4);\n    assert.equal(lines[0], '> 1 | hello world hello w');\n    assert.equal(lines[1], '>   |  ^^^^^^^^^    ^^^^^ I also have a message');\n    assert.equal(lines[2], '> 2 | new line new line n');\n    assert.equal(lines[3], '>   |  ^^^^ This is the second line');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"Multi-line highlight w/ truncation","suites":["codeframe"],"updatePoint":{"line":593,"column":40,"index":15027},"line":593,"code":"  it('Multi-line highlight w/ truncation', () => {\n    let originalLine = 'hello world '.repeat(100) + '\\n' + 'new line '.repeat(100);\n    let codeframeString = codeframe(originalLine, [{\n      start: {\n        column: 2,\n        line: 1\n      },\n      end: {\n        column: 151,\n        line: 2\n      },\n      message: 'I have a message'\n    }], {\n      useColor: false,\n      terminalWidth: 25\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 4);\n    assert.equal(lines[0], '> 1 | hello world hello w');\n    assert.equal(lines[1], '>   |  ^^^^^^^^^^^^^^^^^^');\n    assert.equal(lines[2], '> 2 | ew line new line ne');\n    assert.equal(lines[3], '>   | ^^^^^^ I have a message');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"Should pad properly, T-650","suites":["codeframe"],"updatePoint":{"line":616,"column":32,"index":15746},"line":616,"code":"  it('Should pad properly, T-650', () => {\n    let fileContent = readFileSync(joinPath(__dirname, './fixtures/a.js'), 'utf8');\n    let codeframeString = codeframe(fileContent, [{\n      start: {\n        line: 8,\n        column: 10\n      },\n      end: {\n        line: 8,\n        column: 48\n      }\n    }], {\n      useColor: false,\n      syntaxHighlighting: false,\n      language: 'js',\n      terminalWidth: 100\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 5);\n    assert.equal(lines[0], `   7 | import Tooltip from '../tooltip';`);\n    assert.equal(lines[1], `>  8 | import VisuallyHidden from '../visually-hidden';`);\n    assert.equal(lines[2], '>    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^');\n    assert.equal(lines[3], '   9 | ');\n    assert.equal(lines[4], '  10 | /**');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"initialization should create one root node with edges to entry_specifier nodes for each entry","suites":["AssetGraph"],"updatePoint":{"line":23,"column":99,"index":858},"line":23,"code":"  it('initialization should create one root node with edges to entry_specifier nodes for each entry', () => {\n    let graph = new AssetGraph();\n    graph.setRootConnections({\n      entries: [toProjectPath('/path/to/index1'), toProjectPath('/path/to/index2')]\n    });\n    assert(graph.hasNode(nullthrows(graph.rootNodeId)));\n    assert(graph.hasContentKey('entry_specifier:path/to/index1'));\n    assert(graph.hasContentKey('entry_specifier:path/to/index2'));\n  });","file":"AssetGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolveEntry should connect an entry_specifier node to entry_file nodes","suites":["AssetGraph"],"updatePoint":{"line":32,"column":77,"index":1300},"line":32,"code":"  it('resolveEntry should connect an entry_specifier node to entry_file nodes', () => {\n    let graph = new AssetGraph();\n    graph.setRootConnections({\n      entries: [toProjectPath('/path/to/index1'), toProjectPath('/path/to/index2')]\n    });\n    graph.resolveEntry(toProjectPath('/path/to/index1'), [{\n      filePath: toProjectPath('/path/to/index1/src/main.js'),\n      packagePath: toProjectPath('/path/to/index1')\n    }], '123');\n    assert(graph.hasContentKey(nodeFromEntryFile({\n      filePath: toProjectPath('/path/to/index1/src/main.js'),\n      packagePath: toProjectPath('/path/to/index1')\n    }).id));\n    assert(graph.hasEdge(graph.getNodeIdByContentKey('entry_specifier:path/to/index1'), graph.getNodeIdByContentKey(nodeFromEntryFile({\n      filePath: toProjectPath('/path/to/index1/src/main.js'),\n      packagePath: toProjectPath('/path/to/index1')\n    }).id)));\n  });","file":"AssetGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolveTargets should connect an entry_file node to dependencies for each target","suites":["AssetGraph"],"updatePoint":{"line":50,"column":86,"index":2192},"line":50,"code":"  it('resolveTargets should connect an entry_file node to dependencies for each target', () => {\n    let graph = new AssetGraph();\n    graph.setRootConnections({\n      entries: [toProjectPath('/path/to/index1'), toProjectPath('/path/to/index2')]\n    });\n    graph.resolveEntry(toProjectPath('/path/to/index1'), [{\n      filePath: toProjectPath('/path/to/index1/src/main.js'),\n      packagePath: toProjectPath('/path/to/index1')\n    }], '1');\n    graph.resolveEntry(toProjectPath('/path/to/index2'), [{\n      filePath: toProjectPath('/path/to/index2/src/main.js'),\n      packagePath: toProjectPath('/path/to/index2')\n    }], '2');\n    graph.resolveTargets({\n      filePath: toProjectPath('/path/to/index1/src/main.js'),\n      packagePath: toProjectPath('/path/to/index1')\n    }, DEFAULT_TARGETS, '3');\n    graph.resolveTargets({\n      filePath: toProjectPath('/path/to/index2/src/main.js'),\n      packagePath: toProjectPath('/path/to/index2')\n    }, DEFAULT_TARGETS, '4');\n    assert(graph.hasContentKey(createDependency({\n      specifier: 'path/to/index1/src/main.js',\n      specifierType: 'esm',\n      target: DEFAULT_TARGETS[0],\n      env: DEFAULT_ENV\n    }).id));\n    assert(graph.hasContentKey(createDependency({\n      specifier: 'path/to/index2/src/main.js',\n      specifierType: 'esm',\n      target: DEFAULT_TARGETS[0],\n      env: DEFAULT_ENV\n    }).id));\n    assert.deepEqual(Array.from(graph.getAllEdges()), [{\n      from: graph.rootNodeId,\n      to: graph.getNodeIdByContentKey('entry_specifier:path/to/index1'),\n      type: 1\n    }, {\n      from: graph.rootNodeId,\n      to: graph.getNodeIdByContentKey('entry_specifier:path/to/index2'),\n      type: 1\n    }, {\n      from: graph.getNodeIdByContentKey('entry_specifier:path/to/index1'),\n      to: graph.getNodeIdByContentKey(nodeFromEntryFile({\n        filePath: toProjectPath('/path/to/index1/src/main.js'),\n        packagePath: toProjectPath('/path/to/index1')\n      }).id),\n      type: 1\n    }, {\n      from: graph.getNodeIdByContentKey('entry_specifier:path/to/index2'),\n      to: graph.getNodeIdByContentKey(nodeFromEntryFile({\n        filePath: toProjectPath('/path/to/index2/src/main.js'),\n        packagePath: toProjectPath('/path/to/index2')\n      }).id),\n      type: 1\n    }, {\n      from: graph.getNodeIdByContentKey(nodeFromEntryFile({\n        filePath: toProjectPath('/path/to/index1/src/main.js'),\n        packagePath: toProjectPath('/path/to/index1')\n      }).id),\n      to: graph.getNodeIdByContentKey(createDependency({\n        specifier: 'path/to/index1/src/main.js',\n        specifierType: 'esm',\n        target: DEFAULT_TARGETS[0],\n        env: DEFAULT_ENV\n      }).id),\n      type: 1\n    }, {\n      from: graph.getNodeIdByContentKey(nodeFromEntryFile({\n        filePath: toProjectPath('/path/to/index2/src/main.js'),\n        packagePath: toProjectPath('/path/to/index2')\n      }).id),\n      to: graph.getNodeIdByContentKey(createDependency({\n        specifier: 'path/to/index2/src/main.js',\n        specifierType: 'esm',\n        target: DEFAULT_TARGETS[0],\n        env: DEFAULT_ENV\n      }).id),\n      type: 1\n    }]);\n  });","file":"AssetGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolveDependency should update the file a dependency is connected to","suites":["AssetGraph"],"updatePoint":{"line":131,"column":75,"index":5286},"line":131,"code":"  it('resolveDependency should update the file a dependency is connected to', () => {\n    let graph = new AssetGraph();\n    graph.setRootConnections({\n      targets: DEFAULT_TARGETS,\n      entries: [toProjectPath('/path/to/index')]\n    });\n    graph.resolveEntry(toProjectPath('/path/to/index'), [{\n      filePath: toProjectPath('/path/to/index/src/main.js'),\n      packagePath: toProjectPath('/path/to/index')\n    }], '1');\n    graph.resolveTargets({\n      filePath: toProjectPath('/path/to/index/src/main.js'),\n      packagePath: toProjectPath('/path/to/index')\n    }, DEFAULT_TARGETS, '2');\n    let dep = createDependency({\n      specifier: 'path/to/index/src/main.js',\n      specifierType: 'esm',\n      target: DEFAULT_TARGETS[0],\n      env: DEFAULT_ENV\n    });\n    let req = {\n      filePath: toProjectPath('/index.js'),\n      env: DEFAULT_ENV\n    };\n    graph.resolveDependency(dep, req, '3');\n    let assetGroupNodeId = graph.getNodeIdByContentKey(nodeFromAssetGroup(req).id);\n    let dependencyNodeId = graph.getNodeIdByContentKey(dep.id);\n    assert(graph.nodes.has(assetGroupNodeId));\n    assert(graph.hasEdge(dependencyNodeId, assetGroupNodeId));\n    let req2 = {\n      filePath: toProjectPath('/index.jsx'),\n      env: DEFAULT_ENV\n    };\n    graph.resolveDependency(dep, req2, '4');\n    let assetGroupNodeId2 = graph.getNodeIdByContentKey(nodeFromAssetGroup(req2).id);\n    assert(!graph.nodes.has(assetGroupNodeId));\n    assert(graph.nodes.has(assetGroupNodeId2));\n    assert(graph.hasEdge(dependencyNodeId, assetGroupNodeId2));\n    assert(!graph.hasEdge(dependencyNodeId, assetGroupNodeId));\n    graph.resolveDependency(dep, req2, '5');\n    assert(graph.nodes.has(assetGroupNodeId2));\n    assert(graph.hasEdge(dependencyNodeId, assetGroupNodeId2));\n  });","file":"AssetGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolveAssetGroup should update the asset and dep nodes a file is connected to","suites":["AssetGraph"],"updatePoint":{"line":174,"column":84,"index":7063},"line":174,"code":"  it('resolveAssetGroup should update the asset and dep nodes a file is connected to', () => {\n    let graph = new AssetGraph();\n    graph.setRootConnections({\n      targets: DEFAULT_TARGETS,\n      entries: [toProjectPath('/path/to/index')]\n    });\n    graph.resolveEntry(toProjectPath('/path/to/index'), [{\n      filePath: toProjectPath('/path/to/index/src/main.js'),\n      packagePath: toProjectPath('/path/to/index')\n    }], '1');\n    graph.resolveTargets({\n      filePath: toProjectPath('/path/to/index/src/main.js'),\n      packagePath: toProjectPath('/path/to/index')\n    }, DEFAULT_TARGETS, '2');\n    let dep = createDependency({\n      specifier: 'path/to/index/src/main.js',\n      specifierType: 'esm',\n      target: DEFAULT_TARGETS[0],\n      env: DEFAULT_ENV,\n      sourcePath: ''\n    });\n    let sourcePath = '/index.js';\n    let filePath = toProjectPath(sourcePath);\n    let req = {\n      filePath,\n      env: DEFAULT_ENV\n    };\n    graph.resolveDependency(dep, req, '3');\n    let assets = [createAsset({\n      id: '1',\n      filePath,\n      type: 'js',\n      isSource: true,\n      hash: '#1',\n      stats,\n      dependencies: new Map([['utils', createDependency({\n        specifier: './utils',\n        specifierType: 'esm',\n        env: DEFAULT_ENV,\n        sourcePath\n      })]]),\n      env: DEFAULT_ENV\n    }), createAsset({\n      id: '2',\n      filePath,\n      type: 'js',\n      isSource: true,\n      hash: '#2',\n      stats,\n      dependencies: new Map([['styles', createDependency({\n        specifier: './styles',\n        specifierType: 'esm',\n        env: DEFAULT_ENV,\n        sourcePath\n      })]]),\n      env: DEFAULT_ENV\n    }), createAsset({\n      id: '3',\n      filePath,\n      type: 'js',\n      isSource: true,\n      hash: '#3',\n      dependencies: new Map(),\n      env: DEFAULT_ENV,\n      stats\n    })];\n    graph.resolveAssetGroup(req, assets, '4');\n    let nodeId1 = graph.getNodeIdByContentKey('1');\n    let nodeId2 = graph.getNodeIdByContentKey('2');\n    let nodeId3 = graph.getNodeIdByContentKey('3');\n    let assetGroupNode = graph.getNodeIdByContentKey(nodeFromAssetGroup(req).id);\n    let dependencyNodeId1 = graph.getNodeIdByContentKey([...assets[0].dependencies.values()][0].id);\n    let dependencyNodeId2 = graph.getNodeIdByContentKey([...assets[1].dependencies.values()][0].id);\n    assert(graph.nodes.has(nodeId1));\n    assert(graph.nodes.has(nodeId2));\n    assert(graph.nodes.has(nodeId3));\n    assert(graph.nodes.has(dependencyNodeId1));\n    assert(graph.nodes.has(dependencyNodeId2));\n    assert(graph.hasEdge(assetGroupNode, nodeId1));\n    assert(graph.hasEdge(assetGroupNode, nodeId2));\n    assert(graph.hasEdge(assetGroupNode, nodeId3));\n    assert(graph.hasEdge(nodeId1, dependencyNodeId1));\n    assert(graph.hasEdge(nodeId2, dependencyNodeId2));\n    let assets2 = [createAsset({\n      id: '1',\n      filePath,\n      type: 'js',\n      isSource: true,\n      hash: '#1',\n      stats,\n      dependencies: new Map([['utils', createDependency({\n        specifier: './utils',\n        specifierType: 'esm',\n        env: DEFAULT_ENV,\n        sourcePath\n      })]]),\n      env: DEFAULT_ENV\n    }), createAsset({\n      id: '2',\n      filePath,\n      type: 'js',\n      isSource: true,\n      hash: '#2',\n      stats,\n      dependencies: new Map(),\n      env: DEFAULT_ENV\n    })];\n    graph.resolveAssetGroup(req, assets2, '5');\n    assert(graph.nodes.has(nodeId1));\n    assert(graph.nodes.has(nodeId2));\n    assert(!graph.nodes.has(nodeId3));\n    assert(graph.nodes.has(dependencyNodeId1));\n    assert(!graph.nodes.has(dependencyNodeId2));\n    assert(graph.hasEdge(assetGroupNode, nodeId1));\n    assert(graph.hasEdge(assetGroupNode, nodeId2));\n    assert(!graph.hasEdge(assetGroupNode, nodeId3));\n    assert(graph.hasEdge(nodeId1, dependencyNodeId1));\n    assert(!graph.hasEdge(nodeId2, dependencyNodeId2));\n  });","file":"AssetGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolveAssetGroup should handle dependent assets in asset groups","suites":["AssetGraph"],"updatePoint":{"line":297,"column":70,"index":11163},"line":297,"code":"  it('resolveAssetGroup should handle dependent assets in asset groups', () => {\n    let graph = new AssetGraph();\n    graph.setRootConnections({\n      targets: DEFAULT_TARGETS,\n      entries: [toProjectPath('/index')]\n    });\n    graph.resolveEntry(toProjectPath('/index'), [{\n      filePath: toProjectPath('/path/to/index/src/main.js'),\n      packagePath: toProjectPath('/path/to/index')\n    }], '1');\n    graph.resolveTargets({\n      filePath: toProjectPath('/path/to/index/src/main.js'),\n      packagePath: toProjectPath('/path/to/index')\n    }, DEFAULT_TARGETS, '2');\n    let dep = createDependency({\n      specifier: 'path/to/index/src/main.js',\n      specifierType: 'esm',\n      env: DEFAULT_ENV,\n      target: DEFAULT_TARGETS[0]\n    });\n    let sourcePath = '/index.js';\n    let filePath = toProjectPath(sourcePath);\n    let req = {\n      filePath,\n      env: DEFAULT_ENV\n    };\n    graph.resolveDependency(dep, req, '123');\n    let dep1 = createDependency({\n      specifier: 'dependent-asset-1',\n      specifierType: 'esm',\n      env: DEFAULT_ENV,\n      sourcePath\n    });\n    let dep2 = createDependency({\n      specifier: 'dependent-asset-2',\n      specifierType: 'esm',\n      env: DEFAULT_ENV,\n      sourcePath\n    });\n    let assets = [createAsset({\n      id: '1',\n      filePath,\n      type: 'js',\n      isSource: true,\n      hash: '#1',\n      stats,\n      dependencies: new Map([['dep1', dep1]]),\n      env: DEFAULT_ENV\n    }), createAsset({\n      id: '2',\n      uniqueKey: 'dependent-asset-1',\n      filePath,\n      type: 'js',\n      isSource: true,\n      hash: '#1',\n      stats,\n      dependencies: new Map([['dep2', dep2]]),\n      env: DEFAULT_ENV\n    }), createAsset({\n      id: '3',\n      uniqueKey: 'dependent-asset-2',\n      filePath,\n      type: 'js',\n      isSource: true,\n      hash: '#1',\n      stats,\n      env: DEFAULT_ENV\n    })];\n    graph.resolveAssetGroup(req, assets, '3');\n    let nodeId1 = graph.getNodeIdByContentKey('1');\n    let nodeId2 = graph.getNodeIdByContentKey('2');\n    let nodeId3 = graph.getNodeIdByContentKey('3');\n    let assetGroupNodeId = graph.getNodeIdByContentKey(nodeFromAssetGroup(req).id);\n    let depNodeId1 = graph.getNodeIdByContentKey(nodeFromDep(dep1).id);\n    let depNodeId2 = graph.getNodeIdByContentKey(nodeFromDep(dep2).id);\n    assert(nodeId1);\n    assert(nodeId2);\n    assert(nodeId3);\n    assert(graph.hasEdge(assetGroupNodeId, nodeId1));\n    assert(!graph.hasEdge(assetGroupNodeId, nodeId2));\n    assert(!graph.hasEdge(assetGroupNodeId, nodeId3));\n    assert(graph.hasEdge(nodeId1, depNodeId1));\n    assert(graph.hasEdge(depNodeId1, nodeId2));\n    assert(graph.hasEdge(nodeId2, depNodeId2));\n    assert(graph.hasEdge(depNodeId2, nodeId3));\n  });","file":"AssetGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should support marking and unmarking all parents with hasDeferred","suites":["AssetGraph"],"updatePoint":{"line":383,"column":71,"index":13881},"line":383,"code":"  it('should support marking and unmarking all parents with hasDeferred', () => {\n    let graph = new AssetGraph();\n\n    // index\n    let indexAssetGroup = {\n      filePath: toProjectPath('/index.js'),\n      env: DEFAULT_ENV\n    };\n    graph.setRootConnections({\n      assetGroups: [indexAssetGroup]\n    });\n    let indexFooDep = createDependency({\n      specifier: './foo',\n      specifierType: 'esm',\n      env: DEFAULT_ENV,\n      sourcePath: '/index.js'\n    });\n    let indexBarDep = createDependency({\n      specifier: './bar',\n      specifierType: 'esm',\n      env: DEFAULT_ENV,\n      sourcePath: '/index.js'\n    });\n    let indexAsset = createAsset({\n      id: 'assetIndex',\n      filePath: toProjectPath('/index.js'),\n      type: 'js',\n      isSource: true,\n      hash: '#4',\n      stats,\n      dependencies: new Map([['./foo', indexFooDep], ['./bar', indexBarDep]]),\n      env: DEFAULT_ENV\n    });\n    graph.resolveAssetGroup(indexAssetGroup, [indexAsset], '0');\n\n    // index imports foo\n    let fooAssetGroup = {\n      filePath: toProjectPath('/foo.js'),\n      env: DEFAULT_ENV\n    };\n    graph.resolveDependency(indexFooDep, fooAssetGroup, '0');\n    let fooAssetGroupNode = nodeFromAssetGroup(fooAssetGroup);\n    let fooUtilsDep = createDependency({\n      specifier: './utils',\n      specifierType: 'esm',\n      env: DEFAULT_ENV,\n      sourcePath: '/foo.js'\n    });\n    let fooUtilsDepNode = nodeFromDep(fooUtilsDep);\n    let fooAsset = createAsset({\n      id: 'assetFoo',\n      filePath: toProjectPath('/foo.js'),\n      type: 'js',\n      isSource: true,\n      hash: '#1',\n      stats,\n      dependencies: new Map([['./utils', fooUtilsDep]]),\n      env: DEFAULT_ENV\n    });\n    let fooAssetNode = nodeFromAsset(fooAsset);\n    graph.resolveAssetGroup(fooAssetGroup, [fooAsset], '0');\n    let utilsAssetGroup = {\n      filePath: toProjectPath('/utils.js'),\n      env: DEFAULT_ENV\n    };\n    let utilsAssetGroupNode = nodeFromAssetGroup(utilsAssetGroup);\n    graph.resolveDependency(fooUtilsDep, utilsAssetGroup, '0');\n\n    // foo's dependency is deferred\n    graph.markParentsWithHasDeferred(graph.getNodeIdByContentKey(fooUtilsDepNode.id));\n    let node = nullthrows(graph.getNodeByContentKey(fooAssetNode.id));\n    invariant(node.type === 'asset');\n    assert(node.hasDeferred);\n    node = nullthrows(graph.getNodeByContentKey(fooAssetGroupNode.id));\n    invariant(node.type === 'asset_group');\n    assert(node.hasDeferred);\n\n    // index also imports bar\n    let barAssetGroup = {\n      filePath: toProjectPath('/bar.js'),\n      env: DEFAULT_ENV\n    };\n    graph.resolveDependency(indexBarDep, barAssetGroup, '0');\n    let barAssetGroupNode = nodeFromAssetGroup(barAssetGroup);\n    let barUtilsDep = createDependency({\n      specifier: './utils',\n      specifierType: 'esm',\n      env: DEFAULT_ENV,\n      sourcePath: '/bar.js'\n    });\n    let barAsset = createAsset({\n      id: 'assetBar',\n      filePath: toProjectPath('/bar.js'),\n      type: 'js',\n      isSource: true,\n      hash: '#2',\n      stats,\n      dependencies: new Map([['./utils', barUtilsDep]]),\n      env: DEFAULT_ENV\n    });\n    let barAssetNode = nodeFromAsset(barAsset);\n    graph.resolveAssetGroup(barAssetGroup, [barAsset], '3');\n    graph.resolveDependency(barUtilsDep, utilsAssetGroup, '4');\n\n    // bar undeferres utils\n    graph.unmarkParentsWithHasDeferred(graph.getNodeIdByContentKey(utilsAssetGroupNode.id));\n    node = nullthrows(graph.getNodeByContentKey(fooUtilsDep.id));\n    invariant(node.type === 'dependency');\n    assert(!node.hasDeferred);\n    node = nullthrows(graph.getNodeByContentKey(fooAssetNode.id));\n    invariant(node.type === 'asset');\n    assert(!node.hasDeferred);\n    node = nullthrows(graph.getNodeByContentKey(fooAssetGroupNode.id));\n    invariant(node.type === 'asset_group');\n    assert(!node.hasDeferred);\n    node = nullthrows(graph.getNodeByContentKey(barUtilsDep.id));\n    invariant(node.type === 'dependency');\n    assert(!node.hasDeferred);\n    node = nullthrows(graph.getNodeByContentKey(barAssetNode.id));\n    invariant(node.type === 'asset');\n    assert(!node.hasDeferred);\n    node = nullthrows(graph.getNodeByContentKey(barAssetGroupNode.id));\n    invariant(node.type === 'asset_group');\n    assert(!node.hasDeferred);\n  });","file":"AssetGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"assigns publicIds to assets","suites":["BundleGraph"],"updatePoint":{"line":17,"column":33,"index":698},"line":17,"code":"  it('assigns publicIds to assets', () => {\n    let bundleGraph = BundleGraph.fromAssetGraph(createMockAssetGraph([id1, id2]), false);\n    assert.deepEqual(getAssets(bundleGraph).map(a => bundleGraph.getAssetPublicId(a)), ['296TI', '4DGUq']);\n  });","file":"BundleGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"uses a longer publicId if there is a collision","suites":["BundleGraph"],"updatePoint":{"line":21,"column":52,"index":966},"line":21,"code":"  it('uses a longer publicId if there is a collision', () => {\n    let bundleGraph = BundleGraph.fromAssetGraph(createMockAssetGraph([id1, id1.slice(0, 16) + '7' + id1.slice(17)]), false);\n    assert.deepEqual(getAssets(bundleGraph).map(a => bundleGraph.getAssetPublicId(a)), ['296TI', '296TII']);\n  });","file":"BundleGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects missing source in package.json","suites":["EntryResolver"],"updatePoint":{"line":22,"column":44,"index":1018},"line":22,"code":"  it('rejects missing source in package.json', async function () {\n    this.timeout(10000);\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => entryResolver.resolveEntry(INVALID_SOURCE_MISSING_FIXTURE_PATH), {\n      diagnostics: [{\n        origin: '@parcel/core',\n        message: md`${path.join(path.relative(fs.cwd(), INVALID_SOURCE_MISSING_FIXTURE_PATH), 'missing.js')} does not exist.`,\n        codeFrames: [{\n          filePath: path.join(INVALID_SOURCE_MISSING_FIXTURE_PATH, 'package.json'),\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 4,\n              column: 13\n            },\n            end: {\n              line: 4,\n              column: 24\n            }\n          }]\n        }],\n        hints: []\n      }]\n    });\n  });","file":"EntryRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects non-file source in package.json","suites":["EntryResolver"],"updatePoint":{"line":47,"column":45,"index":1834},"line":47,"code":"  it('rejects non-file source in package.json', async function () {\n    this.timeout(10000);\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => entryResolver.resolveEntry(INVALID_SOURCE_NOT_FILE_FIXTURE_PATH), {\n      diagnostics: [{\n        origin: '@parcel/core',\n        message: md`${path.join(path.relative(fs.cwd(), INVALID_SOURCE_NOT_FILE_FIXTURE_PATH), 'src')} is not a file.`,\n        codeFrames: [{\n          filePath: path.join(INVALID_SOURCE_NOT_FILE_FIXTURE_PATH, 'package.json'),\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 4,\n              column: 13\n            },\n            end: {\n              line: 4,\n              column: 17\n            }\n          }]\n        }]\n      }]\n    });\n  });","file":"EntryRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects missing target source in package.json","suites":["EntryResolver"],"updatePoint":{"line":71,"column":51,"index":2632},"line":71,"code":"  it('rejects missing target source in package.json', async function () {\n    this.timeout(10000);\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => entryResolver.resolveEntry(INVALID_TARGET_SOURCE_MISSING_FIXTURE_PATH), {\n      diagnostics: [{\n        origin: '@parcel/core',\n        message: md`${path.join(path.relative(fs.cwd(), INVALID_TARGET_SOURCE_MISSING_FIXTURE_PATH), 'missing.js')} does not exist.`,\n        codeFrames: [{\n          filePath: path.join(INVALID_TARGET_SOURCE_MISSING_FIXTURE_PATH, 'package.json'),\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 6,\n              column: 17\n            },\n            end: {\n              line: 6,\n              column: 28\n            }\n          }]\n        }],\n        hints: []\n      }]\n    });\n  });","file":"EntryRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects non-file target source in package.json","suites":["EntryResolver"],"updatePoint":{"line":96,"column":52,"index":3476},"line":96,"code":"  it('rejects non-file target source in package.json', async function () {\n    this.timeout(10000);\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => entryResolver.resolveEntry(INVALID_TARGET_SOURCE_NOT_FILE_FIXTURE_PATH), {\n      diagnostics: [{\n        origin: '@parcel/core',\n        message: md`${path.join(path.relative(fs.cwd(), INVALID_TARGET_SOURCE_NOT_FILE_FIXTURE_PATH), 'src')} is not a file.`,\n        codeFrames: [{\n          filePath: path.join(INVALID_TARGET_SOURCE_NOT_FILE_FIXTURE_PATH, 'package.json'),\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 6,\n              column: 17\n            },\n            end: {\n              line: 6,\n              column: 21\n            }\n          }]\n        }]\n      }]\n    });\n  });","file":"EntryRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"assigns a default environment with nothing passed","suites":["Environment"],"updatePoint":{"line":4,"column":55,"index":173},"line":4,"code":"  it('assigns a default environment with nothing passed', () => {\n    assert.deepEqual(createEnvironment(), {\n      id: 'c242f987e3544367',\n      context: 'browser',\n      engines: {\n        browsers: ['> 0.25%']\n      },\n      includeNodeModules: true,\n      outputFormat: 'global',\n      isLibrary: false,\n      shouldOptimize: false,\n      shouldScopeHoist: false,\n      sourceMap: undefined,\n      loc: undefined,\n      sourceType: 'module'\n    });\n  });","file":"Environment.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"assigns a node context if a node engine is given","suites":["Environment"],"updatePoint":{"line":21,"column":54,"index":631},"line":21,"code":"  it('assigns a node context if a node engine is given', () => {\n    assert.deepEqual(createEnvironment({\n      engines: {\n        node: '>= 10.0.0'\n      }\n    }), {\n      id: '69e0ab7220ee8f7a',\n      context: 'node',\n      engines: {\n        node: '>= 10.0.0'\n      },\n      includeNodeModules: false,\n      outputFormat: 'commonjs',\n      isLibrary: false,\n      shouldOptimize: false,\n      shouldScopeHoist: false,\n      sourceMap: undefined,\n      loc: undefined,\n      sourceType: 'module'\n    });\n  });","file":"Environment.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"assigns a browser context if browser engines are given","suites":["Environment"],"updatePoint":{"line":42,"column":60,"index":1149},"line":42,"code":"  it('assigns a browser context if browser engines are given', () => {\n    assert.deepEqual(createEnvironment({\n      engines: {\n        browsers: ['last 1 version']\n      }\n    }), {\n      id: '4b5c9005af8c5b19',\n      context: 'browser',\n      engines: {\n        browsers: ['last 1 version']\n      },\n      includeNodeModules: true,\n      outputFormat: 'global',\n      isLibrary: false,\n      shouldOptimize: false,\n      shouldScopeHoist: false,\n      sourceMap: undefined,\n      loc: undefined,\n      sourceType: 'module'\n    });\n  });","file":"Environment.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"assigns default engines for node","suites":["Environment"],"updatePoint":{"line":63,"column":38,"index":1667},"line":63,"code":"  it('assigns default engines for node', () => {\n    assert.deepEqual(createEnvironment({\n      context: 'node'\n    }), {\n      id: 'f7c9644283a8698f',\n      context: 'node',\n      engines: {\n        node: '>= 8.0.0'\n      },\n      includeNodeModules: false,\n      outputFormat: 'commonjs',\n      isLibrary: false,\n      shouldOptimize: false,\n      shouldScopeHoist: false,\n      sourceMap: undefined,\n      loc: undefined,\n      sourceType: 'module'\n    });\n  });","file":"Environment.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"assigns default engines for browsers","suites":["Environment"],"updatePoint":{"line":82,"column":42,"index":2137},"line":82,"code":"  it('assigns default engines for browsers', () => {\n    assert.deepEqual(createEnvironment({\n      context: 'browser'\n    }), {\n      id: 'c242f987e3544367',\n      context: 'browser',\n      engines: {\n        browsers: ['> 0.25%']\n      },\n      includeNodeModules: true,\n      outputFormat: 'global',\n      isLibrary: false,\n      shouldOptimize: false,\n      shouldScopeHoist: false,\n      sourceMap: undefined,\n      loc: undefined,\n      sourceType: 'module'\n    });\n  });","file":"Environment.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"only includes connected files once per filePath","suites":["InternalAsset"],"updatePoint":{"line":15,"column":53,"index":499},"line":15,"code":"  it('only includes connected files once per filePath', () => {\n    let asset = new UncommittedAsset({\n      value: createAsset({\n        filePath: toProjectPath('/', '/foo/asset.js'),\n        env: createEnvironment(),\n        stats,\n        type: 'js',\n        isSource: true\n      }),\n      options: DEFAULT_OPTIONS\n    });\n    asset.invalidateOnFileChange(toProjectPath('/', '/foo/file'));\n    asset.invalidateOnFileChange(toProjectPath('/', '/foo/file'));\n    assert.deepEqual(asset.getInvalidations(), [{\n      type: 'file',\n      filePath: 'foo/file'\n    }]);\n  });","file":"InternalAsset.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"only includes dependencies once per id","suites":["InternalAsset"],"updatePoint":{"line":33,"column":44,"index":1062},"line":33,"code":"  it('only includes dependencies once per id', () => {\n    let asset = new UncommittedAsset({\n      value: createAsset({\n        filePath: toProjectPath('/', '/foo/asset.js'),\n        env: createEnvironment(),\n        stats,\n        type: 'js',\n        isSource: true\n      }),\n      options: DEFAULT_OPTIONS\n    });\n    asset.addDependency({\n      specifier: './foo',\n      specifierType: 'esm'\n    });\n    asset.addDependency({\n      specifier: './foo',\n      specifierType: 'esm'\n    });\n    let dependencies = asset.getDependencies();\n    assert(dependencies.length === 1);\n    assert(dependencies[0].specifier === './foo');\n  });","file":"InternalAsset.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"includes different dependencies if their id differs","suites":["InternalAsset"],"updatePoint":{"line":56,"column":57,"index":1710},"line":56,"code":"  it('includes different dependencies if their id differs', () => {\n    let asset = new UncommittedAsset({\n      value: createAsset({\n        filePath: toProjectPath('/', '/foo/asset.js'),\n        env: createEnvironment(),\n        stats,\n        type: 'js',\n        isSource: true\n      }),\n      options: DEFAULT_OPTIONS\n    });\n    asset.addDependency({\n      specifier: './foo',\n      specifierType: 'esm'\n    });\n    asset.addDependency({\n      specifier: './foo',\n      specifierType: 'esm',\n      env: {\n        context: 'web-worker',\n        engines: {}\n      }\n    });\n    let dependencies = asset.getDependencies();\n    assert(dependencies.length === 2);\n  });","file":"InternalAsset.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"does not initialize when passed an ending farm","suites":["Parcel"],"updatePoint":{"line":14,"column":52,"index":442},"line":14,"code":"  it('does not initialize when passed an ending farm', async () => {\n    workerFarm.ending = true;\n    let parcel = createParcel({\n      workerFarm\n    });\n\n    // $FlowFixMe\n    await assert.rejects(() => parcel.run(), {\n      name: 'Error',\n      message: 'Supplied WorkerFarm is ending'\n    });\n    workerFarm.ending = false;\n  });","file":"Parcel.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"ends any WorkerFarm it creates","suites":["Parcel","parcel.end()"],"updatePoint":{"line":35,"column":38,"index":954},"line":35,"code":"    it('ends any WorkerFarm it creates', async () => {\n      let parcel = createParcel();\n      await parcel.run();\n      assert.equal(endSpy.callCount, 1);\n    });","file":"Parcel.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"runs and constructs another farm for subsequent builds","suites":["Parcel","parcel.end()"],"updatePoint":{"line":40,"column":62,"index":1143},"line":40,"code":"    it('runs and constructs another farm for subsequent builds', async () => {\n      let parcel = createParcel();\n      await parcel.run();\n      await parcel.run();\n      assert.equal(endSpy.callCount, 2);\n    });","file":"Parcel.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"does not end passed WorkerFarms","suites":["Parcel","parcel.end()"],"updatePoint":{"line":46,"column":39,"index":1335},"line":46,"code":"    it('does not end passed WorkerFarms', async () => {\n      let parcel = createParcel({\n        workerFarm\n      });\n      await parcel.run();\n      assert.equal(endSpy.callCount, 0);\n      await workerFarm.end();\n    });","file":"Parcel.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"removes shared references it creates","suites":["Parcel","parcel.end()"],"updatePoint":{"line":54,"column":44,"index":1564},"line":54,"code":"    it('removes shared references it creates', async () => {\n      let parcel = createParcel({\n        workerFarm\n      });\n      await parcel.run();\n      assert.equal(workerFarm.sharedReferences.size, 0);\n      assert.equal(workerFarm.sharedReferencesByValue.size, 0);\n      await workerFarm.end();\n    });","file":"Parcel.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return null array if no glob matches","suites":["ParcelConfig","matchGlobMap"],"updatePoint":{"line":29,"column":51,"index":1010},"line":29,"code":"    it('should return null array if no glob matches', () => {\n      let result = config.matchGlobMap(toProjectPath('/', '/foo.wasm'), config.packagers);\n      assert.deepEqual(result, null);\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return a matching pipeline","suites":["ParcelConfig","matchGlobMap"],"updatePoint":{"line":33,"column":41,"index":1199},"line":33,"code":"    it('should return a matching pipeline', () => {\n      let result = config.matchGlobMap(toProjectPath('/', '/foo.js'), config.packagers);\n      assert.deepEqual(result, {\n        packageName: 'parcel-packager-js',\n        resolveFrom: PARCELRC_PATH,\n        keyPath: '/packagers/*.js'\n      });\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return an empty array if no pipeline matches","suites":["ParcelConfig","matchGlobMapPipelines"],"updatePoint":{"line":59,"column":59,"index":2056},"line":59,"code":"    it('should return an empty array if no pipeline matches', () => {\n      let pipeline = config.matchGlobMapPipelines(toProjectPath('/', '/foo.css'), config.transformers);\n      assert.deepEqual(pipeline, []);\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return a matching pipeline","suites":["ParcelConfig","matchGlobMapPipelines"],"updatePoint":{"line":63,"column":41,"index":2258},"line":63,"code":"    it('should return a matching pipeline', () => {\n      let pipeline = config.matchGlobMapPipelines(toProjectPath('/', '/foo.js'), config.transformers);\n      assert.deepEqual(pipeline, [{\n        packageName: 'parcel-transform-js',\n        resolveFrom: PARCELRC_PATH,\n        keyPath: '/transformers/*.{js,jsx}/0'\n      }]);\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should merge pipelines with spread elements","suites":["ParcelConfig","matchGlobMapPipelines"],"updatePoint":{"line":71,"column":51,"index":2604},"line":71,"code":"    it('should merge pipelines with spread elements', () => {\n      let pipeline = config.matchGlobMapPipelines(toProjectPath('/', '/foo.jsx'), config.transformers);\n      assert.deepEqual(pipeline, [{\n        packageName: 'parcel-transform-jsx',\n        resolveFrom: PARCELRC_PATH,\n        keyPath: '/transformers/*.jsx/0'\n      }, {\n        packageName: 'parcel-transform-js',\n        resolveFrom: PARCELRC_PATH,\n        keyPath: '/transformers/*.{js,jsx}/0'\n      }]);\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should warn if a plugin needs to specify an engines.parcel field in package.json","suites":["ParcelConfig","loadPlugin"],"updatePoint":{"line":85,"column":88,"index":3160},"line":85,"code":"    it('should warn if a plugin needs to specify an engines.parcel field in package.json', async () => {\n      let projectRoot = path.join(__dirname, 'fixtures', 'plugins');\n      let configFilePath = toProjectPath(projectRoot, path.join(__dirname, 'fixtures', 'plugins', '.parcelrc'));\n      let config = new ParcelConfig({\n        filePath: configFilePath,\n        bundler: undefined,\n        transformers: {\n          '*.js': [{\n            packageName: 'parcel-transformer-no-engines',\n            resolveFrom: configFilePath,\n            keyPath: '/transformers/*.js/0'\n          }]\n        }\n      }, {\n        ...DEFAULT_OPTIONS,\n        projectRoot\n      });\n      let warnStub = sinon.stub(logger, 'warn');\n      let {\n        plugin\n      } = await config.loadPlugin({\n        packageName: 'parcel-transformer-no-engines',\n        resolveFrom: configFilePath,\n        keyPath: '/transformers/*.js/0'\n      });\n      assert(plugin);\n      assert.equal(typeof plugin.transform, 'function');\n      assert(warnStub.calledOnce);\n      assert.deepEqual(warnStub.getCall(0).args[0], {\n        origin: '@parcel/core',\n        message: 'The plugin \"parcel-transformer-no-engines\" needs to specify a `package.json#engines.parcel` field with the supported Parcel version range.'\n      });\n      warnStub.restore();\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should error if a plugin specifies an invalid engines.parcel field in package.json","suites":["ParcelConfig","loadPlugin"],"updatePoint":{"line":119,"column":90,"index":4484},"line":119,"code":"    it('should error if a plugin specifies an invalid engines.parcel field in package.json', async () => {\n      let projectRoot = path.join(__dirname, 'fixtures', 'plugins');\n      let configFilePath = toProjectPath(projectRoot, path.join(__dirname, 'fixtures', 'plugins', '.parcelrc'));\n      let config = new ParcelConfig({\n        filePath: configFilePath,\n        bundler: undefined,\n        transformers: {\n          '*.js': [{\n            packageName: 'parcel-transformer-not-found',\n            resolveFrom: configFilePath,\n            keyPath: '/transformers/*.js/0'\n          }]\n        }\n      }, {\n        ...DEFAULT_OPTIONS,\n        projectRoot\n      });\n      // $FlowFixMe[untyped-import]\n      let parcelVersion = require('../package.json').version;\n      let pkgJSON = path.join(__dirname, 'fixtures', 'plugins', 'node_modules', 'parcel-transformer-bad-engines', 'package.json');\n      let code = inputFS.readFileSync(pkgJSON, 'utf8');\n\n      // $FlowFixMe\n      await assert.rejects(() => config.loadPlugin({\n        packageName: 'parcel-transformer-bad-engines',\n        resolveFrom: configFilePath,\n        keyPath: '/transformers/*.js/0'\n      }), {\n        name: 'Error',\n        diagnostics: [{\n          message: `The plugin \"parcel-transformer-bad-engines\" is not compatible with the current version of Parcel. Requires \"5.x\" but the current version is \"${parcelVersion}\".`,\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: pkgJSON,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              start: {\n                line: 5,\n                column: 5\n              },\n              end: {\n                line: 5,\n                column: 19\n              },\n              message: undefined\n            }]\n          }]\n        }]\n      });\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should error with a codeframe if a plugin is not resolved","suites":["ParcelConfig","loadPlugin"],"updatePoint":{"line":170,"column":65,"index":6300},"line":170,"code":"    it('should error with a codeframe if a plugin is not resolved', async () => {\n      let configFilePath = path.join(__dirname, 'fixtures', 'config-plugin-not-found', '.parcelrc');\n      let code = await DEFAULT_OPTIONS.inputFS.readFile(configFilePath, 'utf8');\n      let {\n        config\n      } = await parseAndProcessConfig(configFilePath, code, DEFAULT_OPTIONS);\n      let parcelConfig = new ParcelConfig(config, DEFAULT_OPTIONS);\n\n      // $FlowFixMe\n      await assert.rejects(() => parcelConfig.getTransformers('test.js'), {\n        name: 'Error',\n        diagnostics: [{\n          message: 'Cannot find Parcel plugin \"@parcel/transformer-jj\"',\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: configFilePath,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              start: {\n                line: 4,\n                column: 14\n              },\n              end: {\n                line: 4,\n                column: 37\n              },\n              message: `Cannot find module \"@parcel/transformer-jj\", did you mean \"@parcel/transformer-js\"?`\n            }]\n          }]\n        }]\n      });\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should error when using a reserved pipeline name \"node:*\"","suites":["ParcelConfig","loadPlugin"],"updatePoint":{"line":203,"column":65,"index":7479},"line":203,"code":"    it('should error when using a reserved pipeline name \"node:*\"', async () => {\n      let configFilePath = path.join(__dirname, 'fixtures', 'config-node-pipeline', '.parcelrc');\n      let code = await DEFAULT_OPTIONS.inputFS.readFile(configFilePath, 'utf8');\n\n      // $FlowFixMe\n      await assert.rejects(() => parseAndProcessConfig(configFilePath, code, DEFAULT_OPTIONS), {\n        name: 'Error',\n        diagnostics: [{\n          message: \"Named pipeline 'node:' is reserved.\",\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: configFilePath,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              message: undefined,\n              start: {\n                line: 4,\n                column: 5\n              },\n              end: {\n                line: 4,\n                column: 15\n              }\n            }]\n          }],\n          documentationURL: 'https://parceljs.org/features/dependency-resolution/#url-schemes'\n        }]\n      });\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should error on an invalid official package","suites":["ParcelConfigRequest","validatePackageName"],"updatePoint":{"line":11,"column":51,"index":639},"line":11,"code":"    it('should error on an invalid official package', () => {\n      assert.throws(() => {\n        validatePackageName('@parcel/foo-bar', 'transform', 'transformers');\n      }, /Official parcel transform packages must be named according to \"@parcel\\/transform-{name}\"/);\n      assert.throws(() => {\n        validatePackageName('@parcel/transformer', 'transform', 'transformers');\n      }, /Official parcel transform packages must be named according to \"@parcel\\/transform-{name}\"/);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should succeed on a valid official package","suites":["ParcelConfigRequest","validatePackageName"],"updatePoint":{"line":19,"column":50,"index":1128},"line":19,"code":"    it('should succeed on a valid official package', () => {\n      validatePackageName('@parcel/transform-bar', 'transform', 'transformers');\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should error on an invalid community package","suites":["ParcelConfigRequest","validatePackageName"],"updatePoint":{"line":22,"column":52,"index":1280},"line":22,"code":"    it('should error on an invalid community package', () => {\n      assert.throws(() => {\n        validatePackageName('foo-bar', 'transform', 'transformers');\n      }, /Parcel transform packages must be named according to \"parcel-transform-{name}\"/);\n      assert.throws(() => {\n        validatePackageName('parcel-foo-bar', 'transform', 'transformers');\n      }, /Parcel transform packages must be named according to \"parcel-transform-{name}\"/);\n      assert.throws(() => {\n        validatePackageName('parcel-transform', 'transform', 'transformers');\n      }, /Parcel transform packages must be named according to \"parcel-transform-{name}\"/);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should succeed on a valid community package","suites":["ParcelConfigRequest","validatePackageName"],"updatePoint":{"line":33,"column":51,"index":1933},"line":33,"code":"    it('should succeed on a valid community package', () => {\n      validatePackageName('parcel-transform-bar', 'transform', 'transformers');\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should error on an invalid scoped package","suites":["ParcelConfigRequest","validatePackageName"],"updatePoint":{"line":36,"column":49,"index":2081},"line":36,"code":"    it('should error on an invalid scoped package', () => {\n      assert.throws(() => {\n        validatePackageName('@test/foo-bar', 'transform', 'transformers');\n      }, /Scoped parcel transform packages must be named according to \"@test\\/parcel-transform\\[-{name}\\]\"/);\n      assert.throws(() => {\n        validatePackageName('@test/parcel-foo-bar', 'transform', 'transformers');\n      }, /Scoped parcel transform packages must be named according to \"@test\\/parcel-transform\\[-{name}\\]\"/);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should succeed on a valid scoped package","suites":["ParcelConfigRequest","validatePackageName"],"updatePoint":{"line":44,"column":48,"index":2581},"line":44,"code":"    it('should succeed on a valid scoped package', () => {\n      validatePackageName('@test/parcel-transform-bar', 'transform', 'transformers');\n      validatePackageName('@test/parcel-transform', 'transform', 'transformers');\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should throw on invalid config","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":50,"column":38,"index":2853},"line":50,"code":"    it('should throw on invalid config', () => {\n      assert.throws(() => {\n        validateConfigFile({\n          filePath: '.parcelrc',\n          extends: 'parcel-config-foo',\n          transformers: {\n            '*.js': ['parcel-invalid-plugin']\n          }\n        }, '.parcelrc');\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should require pipeline to be an array","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":61,"column":46,"index":3167},"line":61,"code":"    it('should require pipeline to be an array', () => {\n      assert.throws(() => {\n        validateConfigFile(\n        // $FlowExpectedError[incompatible-call]\n        {\n          filePath: '.parcelrc',\n          resolvers: '123'\n        }, '.parcelrc');\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should require pipeline elements to be strings","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":71,"column":54,"index":3450},"line":71,"code":"    it('should require pipeline elements to be strings', () => {\n      assert.throws(() => {\n        validateConfigFile({\n          filePath: '.parcelrc',\n          // $FlowExpectedError[incompatible-call]\n          resolvers: [1, '123', 5]\n        }, '.parcelrc');\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should require package names to be valid","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":80,"column":48,"index":3728},"line":80,"code":"    it('should require package names to be valid', () => {\n      assert.throws(() => {\n        validateConfigFile({\n          filePath: '.parcelrc',\n          resolvers: ['parcel-foo-bar']\n        }, '.parcelrc');\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should succeed with an array of valid package names","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":88,"column":59,"index":3971},"line":88,"code":"    it('should succeed with an array of valid package names', () => {\n      validateConfigFile({\n        filePath: '.parcelrc',\n        resolvers: ['parcel-resolver-test']\n      }, '.parcelrc');\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should support spread elements","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":94,"column":38,"index":4153},"line":94,"code":"    it('should support spread elements', () => {\n      validateConfigFile({\n        filePath: '.parcelrc',\n        resolvers: ['parcel-resolver-test', '...']\n      }, '.parcelrc');\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should require glob map to be an object","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":100,"column":47,"index":4351},"line":100,"code":"    it('should require glob map to be an object', () => {\n      assert.throws(() => {\n        validateConfigFile({\n          filePath: '.parcelrc',\n          // $FlowExpectedError[incompatible-call]\n          transformers: ['parcel-transformer-test', '...']\n        }, '.parcelrc');\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should trigger the validator function for each key","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":109,"column":58,"index":4663},"line":109,"code":"    it('should trigger the validator function for each key', () => {\n      assert.throws(() => {\n        validateConfigFile({\n          filePath: '.parcelrc',\n          transformers: {\n            'types:*.{ts,tsx}': ['@parcel/transformer-typescript-types'],\n            'bundle-text:*': ['-inline-string', '...']\n          }\n        }, '.parcelrc');\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should require extends to be a string or array of strings","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":120,"column":65,"index":5039},"line":120,"code":"    it('should require extends to be a string or array of strings', () => {\n      assert.throws(() => {\n        validateConfigFile(\n        // $FlowExpectedError[incompatible-call]\n        {\n          filePath: '.parcelrc',\n          extends: 2\n        }, '.parcelrc');\n      });\n      assert.throws(() => {\n        validateConfigFile({\n          filePath: '.parcelrc',\n          // $FlowExpectedError[incompatible-call]\n          extends: [2, 7]\n        }, '.parcelrc');\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should support relative paths","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":137,"column":37,"index":5501},"line":137,"code":"    it('should support relative paths', () => {\n      validateConfigFile({\n        filePath: '.parcelrc',\n        extends: './foo'\n      }, '.parcelrc');\n      validateConfigFile({\n        filePath: '.parcelrc',\n        extends: ['./foo', './bar']\n      }, '.parcelrc');\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should validate package names","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":147,"column":37,"index":5780},"line":147,"code":"    it('should validate package names', () => {\n      assert.throws(() => {\n        validateConfigFile({\n          filePath: '.parcelrc',\n          extends: 'foo'\n        }, '.parcelrc');\n      });\n      assert.throws(() => {\n        validateConfigFile({\n          filePath: '.parcelrc',\n          extends: ['foo', 'bar']\n        }, '.parcelrc');\n      });\n      validateConfigFile({\n        filePath: '.parcelrc',\n        extends: 'parcel-config-foo'\n      }, '.parcelrc');\n      validateConfigFile({\n        filePath: '.parcelrc',\n        extends: ['parcel-config-foo', 'parcel-config-bar']\n      }, '.parcelrc');\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should throw for invalid top level keys","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":169,"column":47,"index":6414},"line":169,"code":"    it('should throw for invalid top level keys', () => {\n      assert.throws(() => {\n        validateConfigFile(\n        // $FlowExpectedError\n        {\n          extends: '@parcel/config-default',\n          '@parcel/transformer-js': {\n            inlineEnvironment: false\n          }\n        }, '.parcelrc');\n      }, e => {\n        assert.strictEqual(e.diagnostics[0].codeFrames[0].codeHighlights[0].message, `Did you mean \"transformers\"?`);\n        return true;\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should succeed on valid config","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":184,"column":38,"index":6889},"line":184,"code":"    it('should succeed on valid config', () => {\n      validateConfigFile({\n        filePath: '.parcelrc',\n        extends: 'parcel-config-foo',\n        transformers: {\n          '*.js': ['parcel-transformer-foo']\n        }\n      }, '.parcelrc');\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should throw error on empty config file","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":193,"column":47,"index":7153},"line":193,"code":"    it('should throw error on empty config file', () => {\n      assert.throws(() => {\n        validateConfigFile({}, '.parcelrc');\n      }, /.parcelrc can't be empty/);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return an empty array if base and extension are null","suites":["ParcelConfigRequest","mergePipelines"],"updatePoint":{"line":200,"column":67,"index":7393},"line":200,"code":"    it('should return an empty array if base and extension are null', () => {\n      assert.deepEqual(mergePipelines(null, null), []);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return base if extension is null","suites":["ParcelConfigRequest","mergePipelines"],"updatePoint":{"line":203,"column":47,"index":7515},"line":203,"code":"    it('should return base if extension is null', () => {\n      assert.deepEqual(mergePipelines([{\n        packageName: 'parcel-transform-foo',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/0'\n      }], null), [{\n        packageName: 'parcel-transform-foo',\n        resolveFrom: '.parcelrc',\n        keyPath: '/transformers/*.js/0'\n      }]);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return extension if base is null","suites":["ParcelConfigRequest","mergePipelines"],"updatePoint":{"line":214,"column":47,"index":7912},"line":214,"code":"    it('should return extension if base is null', () => {\n      assert.deepEqual(mergePipelines(null, [{\n        packageName: 'parcel-transform-bar',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/0'\n      }]), [{\n        packageName: 'parcel-transform-bar',\n        resolveFrom: '.parcelrc',\n        keyPath: '/transformers/*.js/0'\n      }]);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return extension if there are no spread elements","suites":["ParcelConfigRequest","mergePipelines"],"updatePoint":{"line":225,"column":63,"index":8325},"line":225,"code":"    it('should return extension if there are no spread elements', () => {\n      assert.deepEqual(mergePipelines([{\n        packageName: 'parcel-transform-foo',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/0'\n      }], [{\n        packageName: 'parcel-transform-bar',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/0'\n      }]), [{\n        packageName: 'parcel-transform-bar',\n        resolveFrom: '.parcelrc',\n        keyPath: '/transformers/*.js/0'\n      }]);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return merge base into extension if there are spread elements","suites":["ParcelConfigRequest","mergePipelines"],"updatePoint":{"line":240,"column":76,"index":8898},"line":240,"code":"    it('should return merge base into extension if there are spread elements', () => {\n      assert.deepEqual(mergePipelines([{\n        packageName: 'parcel-transform-foo',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/0'\n      }], [{\n        packageName: 'parcel-transform-bar',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/0'\n      }, '...', {\n        packageName: 'parcel-transform-baz',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/2'\n      }]), [{\n        packageName: 'parcel-transform-bar',\n        resolveFrom: '.parcelrc',\n        keyPath: '/transformers/*.js/0'\n      }, {\n        packageName: 'parcel-transform-foo',\n        resolveFrom: '.parcelrc',\n        keyPath: '/transformers/*.js/0'\n      }, {\n        packageName: 'parcel-transform-baz',\n        resolveFrom: '.parcelrc',\n        keyPath: '/transformers/*.js/2'\n      }]);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should throw if more than one spread element is in a pipeline","suites":["ParcelConfigRequest","mergePipelines"],"updatePoint":{"line":267,"column":69,"index":9882},"line":267,"code":"    it('should throw if more than one spread element is in a pipeline', () => {\n      assert.throws(() => {\n        mergePipelines([{\n          packageName: 'parcel-transform-foo',\n          resolveFrom: toProjectPath('/', '/.parcelrc'),\n          keyPath: '/transformers/*.js/0'\n        }], [{\n          packageName: 'parcel-transform-bar',\n          resolveFrom: toProjectPath('/', '/.parcelrc'),\n          keyPath: '/transformers/*.js/0'\n        }, '...', {\n          packageName: 'parcel-transform-baz',\n          resolveFrom: toProjectPath('/', '/.parcelrc'),\n          keyPath: '/transformers/*.js/2'\n        }, '...']);\n      }, /Only one spread element can be included in a config pipeline/);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should remove spread element even without a base map","suites":["ParcelConfigRequest","mergePipelines"],"updatePoint":{"line":284,"column":60,"index":10582},"line":284,"code":"    it('should remove spread element even without a base map', () => {\n      assert.deepEqual(mergePipelines(null, [{\n        packageName: 'parcel-transform-bar',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/0'\n      }, '...', {\n        packageName: 'parcel-transform-baz',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/2'\n      }]), [{\n        packageName: 'parcel-transform-bar',\n        resolveFrom: '.parcelrc',\n        keyPath: '/transformers/*.js/0'\n      }, {\n        packageName: 'parcel-transform-baz',\n        resolveFrom: '.parcelrc',\n        keyPath: '/transformers/*.js/2'\n      }]);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should throw if more than one spread element is in a pipeline even without a base map","suites":["ParcelConfigRequest","mergePipelines"],"updatePoint":{"line":303,"column":93,"index":11313},"line":303,"code":"    it('should throw if more than one spread element is in a pipeline even without a base map', () => {\n      assert.throws(() => {\n        mergePipelines(null, [{\n          packageName: 'parcel-transform-bar',\n          resolveFrom: toProjectPath('/', '/.parcelrc'),\n          keyPath: '/transformers/*.js/0'\n        }, '...', {\n          packageName: 'parcel-transform-baz',\n          resolveFrom: toProjectPath('/', '/.parcelrc'),\n          keyPath: '/transformers/*.js/2'\n        }, '...']);\n      }, /Only one spread element can be included in a config pipeline/);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return an empty object if base and extension are null","suites":["ParcelConfigRequest","mergeMaps"],"updatePoint":{"line":318,"column":68,"index":11904},"line":318,"code":"    it('should return an empty object if base and extension are null', () => {\n      assert.deepEqual(mergeMaps(null, null), {});\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return base if extension is null","suites":["ParcelConfigRequest","mergeMaps"],"updatePoint":{"line":321,"column":47,"index":12021},"line":321,"code":"    it('should return base if extension is null', () => {\n      assert.deepEqual(mergeMaps({\n        '*.js': 'foo'\n      }, null), {\n        '*.js': 'foo'\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return extension if base is null","suites":["ParcelConfigRequest","mergeMaps"],"updatePoint":{"line":328,"column":47,"index":12194},"line":328,"code":"    it('should return extension if base is null', () => {\n      assert.deepEqual(mergeMaps(null, {\n        '*.js': 'foo'\n      }), {\n        '*.js': 'foo'\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should merge the objects","suites":["ParcelConfigRequest","mergeMaps"],"updatePoint":{"line":335,"column":32,"index":12352},"line":335,"code":"    it('should merge the objects', () => {\n      assert.deepEqual(mergeMaps({\n        '*.css': 'css',\n        '*.js': 'base-js'\n      }, {\n        '*.js': 'ext-js'\n      }), {\n        '*.js': 'ext-js',\n        '*.css': 'css'\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should ensure that extension properties have a higher precedence than base properties","suites":["ParcelConfigRequest","mergeMaps"],"updatePoint":{"line":346,"column":93,"index":12656},"line":346,"code":"    it('should ensure that extension properties have a higher precedence than base properties', () => {\n      let merged = mergeMaps({\n        '*.{js,jsx}': 'base-js'\n      }, {\n        '*.js': 'ext-js'\n      });\n      assert.deepEqual(merged, {\n        '*.js': 'ext-js',\n        '*.{js,jsx}': 'base-js'\n      });\n      assert.deepEqual(Object.keys(merged), ['*.js', '*.{js,jsx}']);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should call a merger function if provided","suites":["ParcelConfigRequest","mergeMaps"],"updatePoint":{"line":358,"column":49,"index":13003},"line":358,"code":"    it('should call a merger function if provided', () => {\n      let merger = (a, b) => [a, b];\n      assert.deepEqual(mergeMaps({\n        '*.js': 'base-js'\n      }, {\n        '*.js': 'ext-js'\n      }, merger), {\n        '*.js': ['base-js', 'ext-js']\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should merge configs","suites":["ParcelConfigRequest","mergeConfigs"],"updatePoint":{"line":370,"column":28,"index":13293},"line":370,"code":"    it('should merge configs', () => {\n      let base = new ParcelConfig({\n        filePath: toProjectPath('/', '/.parcelrc'),\n        resolvers: [{\n          packageName: 'parcel-resolver-base',\n          resolveFrom: toProjectPath('/', '/.parcelrc'),\n          keyPath: '/resolvers/0'\n        }],\n        transformers: {\n          '*.js': [{\n            packageName: 'parcel-transform-base',\n            resolveFrom: toProjectPath('/', '/.parcelrc'),\n            keyPath: '/transformers/*.js/0'\n          }],\n          '*.css': [{\n            packageName: 'parcel-transform-css',\n            resolveFrom: toProjectPath('/', '/.parcelrc'),\n            keyPath: '/transformers/*.css/0'\n          }]\n        },\n        bundler: {\n          packageName: 'parcel-bundler-base',\n          resolveFrom: toProjectPath('/', '/.parcelrc'),\n          keyPath: '/bundler'\n        }\n      }, DEFAULT_OPTIONS);\n      let ext = {\n        filePath: '.parcelrc',\n        resolvers: [{\n          packageName: 'parcel-resolver-ext',\n          resolveFrom: '.parcelrc',\n          keyPath: '/resolvers/0'\n        }, '...'],\n        transformers: {\n          '*.js': [{\n            packageName: 'parcel-transform-ext',\n            resolveFrom: '.parcelrc',\n            keyPath: '/transformers/*.js/0'\n          }, '...']\n        }\n      };\n      let merged = {\n        filePath: '.parcelrc',\n        resolvers: [{\n          packageName: 'parcel-resolver-ext',\n          resolveFrom: '.parcelrc',\n          keyPath: '/resolvers/0'\n        }, {\n          packageName: 'parcel-resolver-base',\n          resolveFrom: '.parcelrc',\n          keyPath: '/resolvers/0'\n        }],\n        transformers: {\n          '*.js': [{\n            packageName: 'parcel-transform-ext',\n            resolveFrom: '.parcelrc',\n            keyPath: '/transformers/*.js/0'\n          }, {\n            packageName: 'parcel-transform-base',\n            resolveFrom: '.parcelrc',\n            keyPath: '/transformers/*.js/0'\n          }],\n          '*.css': [{\n            packageName: 'parcel-transform-css',\n            resolveFrom: '.parcelrc',\n            keyPath: '/transformers/*.css/0'\n          }]\n        },\n        bundler: {\n          packageName: 'parcel-bundler-base',\n          resolveFrom: '.parcelrc',\n          keyPath: '/bundler'\n        },\n        runtimes: [],\n        namers: [],\n        optimizers: {},\n        compressors: {},\n        packagers: {},\n        reporters: [],\n        validators: {}\n      };\n\n      // $FlowFixMe\n      assert.deepEqual(mergeConfigs(base, ext), merged);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should resolve a relative path","suites":["ParcelConfigRequest","resolveExtends"],"updatePoint":{"line":457,"column":38,"index":15910},"line":457,"code":"    it('should resolve a relative path', async () => {\n      let resolved = await resolveExtends('../.parcelrc', path.join(__dirname, 'fixtures', 'config', 'subfolder', '.parcelrc'), '/extends', DEFAULT_OPTIONS);\n      assert.equal(resolved, path.join(__dirname, 'fixtures', 'config', '.parcelrc'));\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should resolve a package name","suites":["ParcelConfigRequest","resolveExtends"],"updatePoint":{"line":461,"column":37,"index":16217},"line":461,"code":"    it('should resolve a package name', async () => {\n      let resolved = await resolveExtends('@parcel/config-default', path.join(__dirname, 'fixtures', 'config', 'subfolder', '.parcelrc'), '/extends', DEFAULT_OPTIONS);\n      assert.equal(resolved, require.resolve('@parcel/config-default'));\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should load and merge configs","suites":["ParcelConfigRequest","parseAndProcessConfig"],"updatePoint":{"line":467,"column":37,"index":16570},"line":467,"code":"    it('should load and merge configs', async () => {\n      let defaultConfigPath = require.resolve('@parcel/config-default');\n      let defaultConfig = await processConfig({\n        ...require('@parcel/config-default'),\n        filePath: defaultConfigPath\n      }, DEFAULT_OPTIONS);\n      let configFilePath = path.join(__dirname, 'fixtures', 'config', '.parcelrc');\n      let subConfigFilePath = path.join(__dirname, 'fixtures', 'config', 'subfolder', '.parcelrc');\n      let {\n        config\n      } = await parseAndProcessConfig(subConfigFilePath, DEFAULT_OPTIONS.inputFS.readFileSync(subConfigFilePath, 'utf8'), DEFAULT_OPTIONS);\n      let transformers = nullthrows(config.transformers);\n      assert.deepEqual(transformers['*.js'], [{\n        packageName: 'parcel-transformer-sub',\n        resolveFrom: relative(subConfigFilePath),\n        keyPath: '/transformers/*.js/0'\n      }, {\n        packageName: 'parcel-transformer-base',\n        resolveFrom: relative(configFilePath),\n        keyPath: '/transformers/*.js/0'\n      }, '...']);\n      assert(Object.keys(transformers).length > 1);\n      assert.deepEqual(config.resolvers, defaultConfig.resolvers);\n      assert.deepEqual(config.bundler, defaultConfig.bundler);\n      assert.deepEqual(config.namers, defaultConfig.namers || []);\n      assert.deepEqual(config.packagers, defaultConfig.packagers || {});\n      assert.deepEqual(config.optimizers, defaultConfig.optimizers || {});\n      assert.deepEqual(config.reporters, defaultConfig.reporters || []);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should emit a codeframe.codeHighlights when a malformed .parcelrc was found","suites":["ParcelConfigRequest","parseAndProcessConfig"],"updatePoint":{"line":496,"column":83,"index":18136},"line":496,"code":"    it('should emit a codeframe.codeHighlights when a malformed .parcelrc was found', async () => {\n      let configFilePath = path.join(__dirname, 'fixtures', 'config-malformed', '.parcelrc');\n      let code = await DEFAULT_OPTIONS.inputFS.readFile(configFilePath, 'utf8');\n      let pos = {\n        line: 2,\n        column: 14\n      };\n\n      // $FlowFixMe[prop-missing]\n      await assert.rejects(() => parseAndProcessConfig(configFilePath, code, DEFAULT_OPTIONS), {\n        name: 'Error',\n        diagnostics: [{\n          message: 'Failed to parse .parcelrc',\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: configFilePath,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              message: \"JSON5: invalid character 'b' at 2:14\",\n              start: pos,\n              end: pos\n            }]\n          }]\n        }]\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should emit a codeframe when an extended parcel config file is not found","suites":["ParcelConfigRequest","parseAndProcessConfig"],"updatePoint":{"line":523,"column":80,"index":19044},"line":523,"code":"    it('should emit a codeframe when an extended parcel config file is not found', async () => {\n      let configFilePath = path.join(__dirname, 'fixtures', 'config-extends-not-found', '.parcelrc');\n      let code = await DEFAULT_OPTIONS.inputFS.readFile(configFilePath, 'utf8');\n\n      // $FlowFixMe[prop-missing]\n      await assert.rejects(() => parseAndProcessConfig(configFilePath, code, DEFAULT_OPTIONS), {\n        name: 'Error',\n        diagnostics: [{\n          message: 'Cannot find extended parcel config',\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: configFilePath,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              message: '\"./.parclrc-node-modules\" does not exist, did you mean \"./.parcelrc-node-modules\"?',\n              start: {\n                line: 2,\n                column: 14\n              },\n              end: {\n                line: 2,\n                column: 38\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should emit a codeframe when an extended parcel config file is not found in JSON5","suites":["ParcelConfigRequest","parseAndProcessConfig"],"updatePoint":{"line":552,"column":89,"index":20093},"line":552,"code":"    it('should emit a codeframe when an extended parcel config file is not found in JSON5', async () => {\n      let configFilePath = path.join(__dirname, 'fixtures', 'config-extends-not-found', '.parcelrc-json5');\n      let code = await DEFAULT_OPTIONS.inputFS.readFile(configFilePath, 'utf8');\n\n      // $FlowFixMe[prop-missing]\n      await assert.rejects(() => parseAndProcessConfig(configFilePath, code, DEFAULT_OPTIONS), {\n        name: 'Error',\n        diagnostics: [{\n          message: 'Cannot find extended parcel config',\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: configFilePath,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              message: '\"./.parclrc-node-modules\" does not exist, did you mean \"./.parcelrc-node-modules\"?',\n              start: {\n                line: 2,\n                column: 12\n              },\n              end: {\n                line: 2,\n                column: 36\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should emit a codeframe when an extended parcel config node module is not found","suites":["ParcelConfigRequest","parseAndProcessConfig"],"updatePoint":{"line":581,"column":87,"index":21146},"line":581,"code":"    it('should emit a codeframe when an extended parcel config node module is not found', async () => {\n      let configFilePath = path.join(__dirname, 'fixtures', 'config-extends-not-found', '.parcelrc-node-modules');\n      let code = await DEFAULT_OPTIONS.inputFS.readFile(configFilePath, 'utf8');\n\n      // $FlowFixMe[prop-missing]\n      await assert.rejects(() => parseAndProcessConfig(configFilePath, code, DEFAULT_OPTIONS), {\n        name: 'Error',\n        diagnostics: [{\n          message: 'Cannot find extended parcel config',\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: configFilePath,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              message: 'Cannot find module \"@parcel/config-deflt\", did you mean \"@parcel/config-default\"?',\n              start: {\n                line: 2,\n                column: 14\n              },\n              end: {\n                line: 2,\n                column: 35\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should emit multiple codeframes when multiple extended configs are not found","suites":["ParcelConfigRequest","parseAndProcessConfig"],"updatePoint":{"line":610,"column":84,"index":22202},"line":610,"code":"    it('should emit multiple codeframes when multiple extended configs are not found', async () => {\n      let configFilePath = path.join(__dirname, 'fixtures', 'config-extends-not-found', '.parcelrc-multiple');\n      let code = await DEFAULT_OPTIONS.inputFS.readFile(configFilePath, 'utf8');\n\n      // $FlowFixMe[prop-missing]\n      await assert.rejects(() => parseAndProcessConfig(configFilePath, code, DEFAULT_OPTIONS), {\n        name: 'Error',\n        diagnostics: [{\n          message: 'Cannot find extended parcel config',\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: configFilePath,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              message: 'Cannot find module \"@parcel/config-deflt\", did you mean \"@parcel/config-default\"?',\n              start: {\n                line: 2,\n                column: 15\n              },\n              end: {\n                line: 2,\n                column: 36\n              }\n            }]\n          }]\n        }, {\n          message: 'Cannot find extended parcel config',\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: configFilePath,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              message: '\"./.parclrc\" does not exist, did you mean \"./.parcelrc\"?',\n              start: {\n                line: 2,\n                column: 39\n              },\n              end: {\n                line: 2,\n                column: 50\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return null if there is no .parcelrc file found","suites":["ParcelConfigRequest","resolve"],"updatePoint":{"line":660,"column":62,"index":23807},"line":660,"code":"    it('should return null if there is no .parcelrc file found', async () => {\n      let resolved = await resolveParcelConfig(DEFAULT_OPTIONS);\n      assert.equal(resolved, null);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should resolve a config if a .parcelrc file is found","suites":["ParcelConfigRequest","resolve"],"updatePoint":{"line":664,"column":60,"index":23993},"line":664,"code":"    it('should resolve a config if a .parcelrc file is found', async () => {\n      let resolved = await resolveParcelConfig({\n        ...DEFAULT_OPTIONS,\n        projectRoot: path.join(__dirname, 'fixtures', 'config', 'subfolder')\n      });\n      assert(resolved !== null);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"returns the same public Asset given an internal asset","suites":["Public Asset"],"updatePoint":{"line":28,"column":59,"index":891},"line":28,"code":"  it('returns the same public Asset given an internal asset', () => {\n    assert.equal(new Asset(internalAsset), new Asset(internalAsset));\n  });","file":"PublicAsset.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"returns the same public MutableAsset given an internal asset","suites":["Public Asset"],"updatePoint":{"line":31,"column":66,"index":1044},"line":31,"code":"  it('returns the same public MutableAsset given an internal asset', () => {\n    assert.equal(new MutableAsset(internalAsset), new MutableAsset(internalAsset));\n  });","file":"PublicAsset.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"returns the same public Bundle given an internal bundle","suites":["Public Bundle"],"updatePoint":{"line":41,"column":61,"index":1197},"line":41,"code":"  it('returns the same public Bundle given an internal bundle', () => {\n    assert.equal(Bundle.get(internalBundle, bundleGraph, DEFAULT_OPTIONS), Bundle.get(internalBundle, bundleGraph, DEFAULT_OPTIONS));\n  });","file":"PublicBundle.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"returns the same public NamedBundle given an internal bundle","suites":["Public Bundle"],"updatePoint":{"line":44,"column":66,"index":1414},"line":44,"code":"  it('returns the same public NamedBundle given an internal bundle', () => {\n    assert.equal(NamedBundle.get(internalBundle, bundleGraph, DEFAULT_OPTIONS), NamedBundle.get(internalBundle, bundleGraph, DEFAULT_OPTIONS));\n  });","file":"PublicBundle.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"returns the same public PackagedBundle given an internal bundle","suites":["Public Bundle"],"updatePoint":{"line":47,"column":69,"index":1644},"line":47,"code":"  it('returns the same public PackagedBundle given an internal bundle', () => {\n    assert.equal(PackagedBundle.get(internalBundle, bundleGraph, DEFAULT_OPTIONS), PackagedBundle.get(internalBundle, bundleGraph, DEFAULT_OPTIONS));\n  });","file":"PublicBundle.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"returns the same public Dependency given an internal dependency","suites":["Public Dependency"],"updatePoint":{"line":7,"column":69,"index":346},"line":7,"code":"  it('returns the same public Dependency given an internal dependency', () => {\n    let internalDependency = createDependency('/', {\n      specifier: 'foo',\n      specifierType: 'esm',\n      env: createEnvironment({})\n    });\n    assert.equal(new Dependency(internalDependency, DEFAULT_OPTIONS), new Dependency(internalDependency, DEFAULT_OPTIONS));\n  });","file":"PublicDependency.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"has correct support data for ChromeAndroid","suites":["Public Environment"],"updatePoint":{"line":6,"column":48,"index":280},"line":6,"code":"  it('has correct support data for ChromeAndroid', () => {\n    let env = new PublicEnvironment(createEnvironment({\n      context: 'browser',\n      engines: {\n        browsers: ['last 1 Chrome version', 'last 1 ChromeAndroid version']\n      },\n      outputFormat: 'esmodule'\n    }), DEFAULT_OPTIONS);\n    assert(env.supports('esmodules'));\n    assert(env.supports('dynamic-import'));\n    assert(env.supports('worker-module'));\n    assert(env.supports('import-meta-url'));\n    assert(env.supports('arrow-functions'));\n  });","file":"PublicEnvironment.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"creates publicIds for bundles","suites":["PublicMutableBundleGraph"],"updatePoint":{"line":20,"column":35,"index":874},"line":20,"code":"  it('creates publicIds for bundles', () => {\n    let internalBundleGraph = InternalBundleGraph.fromAssetGraph(createMockAssetGraph(), false);\n    let mutableBundleGraph = new MutableBundleGraph(internalBundleGraph, DEFAULT_OPTIONS);\n    mutableBundleGraph.traverse(node => {\n      if (node.type === 'dependency' && mutableBundleGraph.getResolvedAsset(node.value)) {\n        let target = nullthrows(node.value.target);\n        let group = mutableBundleGraph.createBundleGroup(node.value, target);\n        let resolved = mutableBundleGraph.getResolvedAsset(node.value);\n        if (resolved != null) {\n          mutableBundleGraph.addBundleToBundleGroup(mutableBundleGraph.createBundle({\n            entryAsset: resolved,\n            target\n          }), group);\n        }\n      }\n    });\n    assert.deepEqual(internalBundleGraph.getBundles().map(b => b.publicId), ['8LVYC', 'd7Pd5']);\n  });","file":"PublicMutableBundleGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"is safe to add a bundle to a bundleGroup multiple times","suites":["PublicMutableBundleGraph"],"updatePoint":{"line":38,"column":61,"index":1791},"line":38,"code":"  it('is safe to add a bundle to a bundleGroup multiple times', () => {\n    let internalBundleGraph = InternalBundleGraph.fromAssetGraph(createMockAssetGraph(), false);\n    let mutableBundleGraph = new MutableBundleGraph(internalBundleGraph, DEFAULT_OPTIONS);\n    let dependency;\n    mutableBundleGraph.traverse((node, _, actions) => {\n      if (node.type === 'dependency') {\n        dependency = node.value;\n        actions.stop();\n      }\n    });\n    invariant(dependency != null);\n    let target = nullthrows(dependency.target);\n    let bundleGroup = mutableBundleGraph.createBundleGroup(dependency, target);\n    let bundle = mutableBundleGraph.createBundle({\n      entryAsset: nullthrows(mutableBundleGraph.getResolvedAsset(dependency)),\n      target\n    });\n    mutableBundleGraph.addBundleToBundleGroup(bundle, bundleGroup);\n    mutableBundleGraph.addBundleToBundleGroup(bundle, bundleGroup);\n  });","file":"PublicMutableBundleGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should not run requests that have not been invalidated","suites":["RequestTracker"],"updatePoint":{"line":13,"column":60,"index":528},"line":13,"code":"  it('should not run requests that have not been invalidated', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: () => {},\n      input: null\n    });\n    let called = false;\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: () => {\n        called = true;\n      },\n      input: null\n    });\n    assert(called === false);\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should rerun requests that have been invalidated","suites":["RequestTracker"],"updatePoint":{"line":35,"column":54,"index":1008},"line":35,"code":"  it('should rerun requests that have been invalidated', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: () => {},\n      input: null\n    });\n    tracker.graph.invalidateNode(tracker.graph.getNodeIdByContentKey('abc'), INITIAL_BUILD);\n    let called = false;\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: () => {\n        called = true;\n      },\n      input: null\n    });\n    assert(called === true);\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should invalidate requests with invalidated subrequests","suites":["RequestTracker"],"updatePoint":{"line":58,"column":61,"index":1587},"line":58,"code":"  it('should invalidate requests with invalidated subrequests', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async ({\n        api\n      }) => {\n        await api.runRequest({\n          id: 'xyz',\n          type: 'mock_request',\n          run: () => {},\n          input: null\n        });\n      },\n      input: null\n    });\n    tracker.graph.invalidateNode(tracker.graph.getNodeIdByContentKey('xyz'), INITIAL_BUILD);\n    assert(tracker.getInvalidRequests().map(req => req.id).includes('abc'));\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should invalidate requests that failed","suites":["RequestTracker"],"updatePoint":{"line":81,"column":44,"index":2197},"line":81,"code":"  it('should invalidate requests that failed', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async () => {\n        await Promise.resolve();\n        throw new Error('woops');\n      },\n      input: null\n    }).then(null, () => {\n      /* do nothing */\n    });\n    assert(tracker.getInvalidRequests().map(req => req.id).includes('abc'));\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should remove subrequests that are no longer called within a request","suites":["RequestTracker"],"updatePoint":{"line":99,"column":74,"index":2696},"line":99,"code":"  it('should remove subrequests that are no longer called within a request', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async ({\n        api\n      }) => {\n        await api.runRequest({\n          id: 'xyz',\n          type: 'mock_request',\n          run: () => {},\n          input: null\n        });\n      },\n      input: null\n    });\n    let nodeId = nullthrows(tracker.graph.getNodeIdByContentKey('abc'));\n    tracker.graph.invalidateNode(nodeId, INITIAL_BUILD);\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async ({\n        api\n      }) => {\n        await api.runRequest({\n          id: '123',\n          type: 'mock_request',\n          run: () => {},\n          input: null\n        });\n      },\n      input: null\n    });\n    assert(!tracker.graph.hasContentKey('xyz'));\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return a cached result if it was stored","suites":["RequestTracker"],"updatePoint":{"line":138,"column":52,"index":3623},"line":138,"code":"  it('should return a cached result if it was stored', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async ({\n        api\n      }) => {\n        let result = await Promise.resolve('hello');\n        api.storeResult(result);\n      },\n      input: null\n    });\n    let result = await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async () => {},\n      input: null\n    });\n    assert(result === 'hello');\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should reject all in progress requests when the abort controller aborts","suites":["RequestTracker"],"updatePoint":{"line":162,"column":77,"index":4213},"line":162,"code":"  it('should reject all in progress requests when the abort controller aborts', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    let p = tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async () => {\n        await Promise.resolve('hello');\n      },\n      input: null\n    }).then(null, () => {\n      /* do nothing */\n    });\n    // $FlowFixMe\n    tracker.setSignal({\n      aborted: true\n    });\n    await p;\n    assert(tracker.getInvalidRequests().map(req => req.id).includes('abc'));\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should not requeue requests if the previous request is still running","suites":["RequestTracker"],"updatePoint":{"line":184,"column":74,"index":4770},"line":184,"code":"  it('should not requeue requests if the previous request is still running', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    let lockA = makeDeferredWithPromise();\n    let lockB = makeDeferredWithPromise();\n    let requestA = tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async ({\n        api\n      }) => {\n        await lockA.promise;\n        api.storeResult('a');\n        return 'a';\n      },\n      input: null\n    });\n    let calledB = false;\n    let requestB = tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async ({\n        api\n      }) => {\n        calledB = true;\n        await lockB.promise;\n        api.storeResult('b');\n        return 'b';\n      },\n      input: null\n    });\n    lockA.deferred.resolve();\n    lockB.deferred.resolve();\n    let resultA = await requestA;\n    let resultB = await requestB;\n    assert.strictEqual(resultA, 'a');\n    assert.strictEqual(resultB, 'a');\n    assert.strictEqual(calledB, false);\n    let cachedResult = await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: () => {},\n      input: null\n    });\n    assert.strictEqual(cachedResult, 'a');\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should requeue requests if the previous request is still running but failed","suites":["RequestTracker"],"updatePoint":{"line":232,"column":81,"index":6001},"line":232,"code":"  it('should requeue requests if the previous request is still running but failed', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    let lockA = makeDeferredWithPromise();\n    let lockB = makeDeferredWithPromise();\n    let requestA = tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async () => {\n        await lockA.promise;\n        throw new Error('whoops');\n      },\n      input: null\n    }).catch(() => {\n      // ignore\n    });\n    let requestB = tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async ({\n        api\n      }) => {\n        await lockB.promise;\n        api.storeResult('b');\n      },\n      input: null\n    });\n    lockA.deferred.resolve();\n    lockB.deferred.resolve();\n    await requestA;\n    await requestB;\n    let called = false;\n    let cachedResult = await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: () => {\n        called = true;\n      },\n      input: null\n    });\n    assert.strictEqual(cachedResult, 'b');\n    assert.strictEqual(called, false);\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a basic object","suites":["serializer"],"updatePoint":{"line":5,"column":37,"index":241},"line":5,"code":"  it('should serialize a basic object', () => {\n    let serialized = serialize({\n      foo: 2,\n      bar: 3\n    });\n    assert(Buffer.isBuffer(serialized));\n    let deserialized = deserialize(serialized);\n    assert.equal(typeof deserialized, 'object');\n    assert.deepEqual(deserialized, {\n      foo: 2,\n      bar: 3\n    });\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize an object with multiple references","suites":["serializer"],"updatePoint":{"line":18,"column":57,"index":593},"line":18,"code":"  it('should serialize an object with multiple references', () => {\n    let a = {\n      foo: 2\n    };\n    let b = {\n      bar: a,\n      baz: a\n    };\n    let res = deserialize(serialize(b));\n    assert.deepEqual(res, b);\n    assert.equal(res.bar, res.baz);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a cyclic object","suites":["serializer"],"updatePoint":{"line":30,"column":38,"index":837},"line":30,"code":"  it('should serialize a cyclic object', () => {\n    let a = {\n      foo: 2,\n      bar: {}\n    };\n    a.bar = a;\n    let res = deserialize(serialize(a));\n    assert.deepEqual(res, a);\n    assert.equal(res.bar, res);\n    assert.equal(a.bar, a);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a Map","suites":["serializer"],"updatePoint":{"line":41,"column":28,"index":1077},"line":41,"code":"  it('should serialize a Map', () => {\n    let a = new Map([[2, 3]]);\n    let res = deserialize(serialize(a));\n    assert(res instanceof Map);\n    assert.equal(res.get(2), 3);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a Set","suites":["serializer"],"updatePoint":{"line":47,"column":28,"index":1259},"line":47,"code":"  it('should serialize a Set', () => {\n    let a = new Set([2, 3]);\n    let res = deserialize(serialize(a));\n    assert(res instanceof Set);\n    assert(res.has(2));\n    assert(res.has(3));\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a class","suites":["serializer"],"updatePoint":{"line":54,"column":30,"index":1456},"line":54,"code":"  it('should serialize a class', () => {\n    class Test {\n      constructor(x) {\n        this.x = x;\n      }\n    }\n    registerSerializableClass('Test', Test);\n    let x = new Test(2);\n    let res = deserialize(serialize(x));\n    assert(res instanceof Test);\n    assert.equal(res.x, x.x);\n    unregisterSerializableClass('Test', Test);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a class with a custom serialize method","suites":["serializer"],"updatePoint":{"line":67,"column":61,"index":1829},"line":67,"code":"  it('should serialize a class with a custom serialize method', () => {\n    class Test {\n      constructor(x) {\n        this.x = x;\n      }\n      serialize() {\n        return {\n          x: this.x,\n          serialized: true\n        };\n      }\n    }\n    registerSerializableClass('Test', Test);\n    let x = new Test(2);\n    let res = deserialize(serialize(x));\n    assert(res instanceof Test);\n    assert.equal(res.x, x.x);\n    assert.equal(res.serialized, true);\n    unregisterSerializableClass('Test', Test);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a class with a custom deserialize method","suites":["serializer"],"updatePoint":{"line":87,"column":63,"index":2348},"line":87,"code":"  it('should serialize a class with a custom deserialize method', () => {\n    class Test {\n      constructor(x) {\n        this.x = x;\n      }\n      static deserialize(x) {\n        return {\n          deserialized: true,\n          value: x\n        };\n      }\n    }\n    registerSerializableClass('Test', Test);\n    let x = new Test(2);\n    let res = deserialize(serialize(x));\n    assert(!(res instanceof Test));\n    assert.equal(res.value.x, x.x);\n    assert.equal(res.deserialized, true);\n    unregisterSerializableClass('Test', Test);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a class recursively","suites":["serializer"],"updatePoint":{"line":107,"column":42,"index":2868},"line":107,"code":"  it('should serialize a class recursively', () => {\n    class Foo {\n      constructor(x) {\n        this.x = x;\n      }\n    }\n    class Bar {\n      constructor(foo) {\n        this.foo = foo;\n      }\n    }\n    registerSerializableClass('Foo', Foo);\n    registerSerializableClass('Bar', Bar);\n    let x = new Bar(new Foo(2));\n    let res = deserialize(serialize(x));\n    assert(res instanceof Bar);\n    assert(res.foo instanceof Foo);\n    assert.equal(res.foo.x, 2);\n    unregisterSerializableClass('Foo', Foo);\n    unregisterSerializableClass('Bar', Bar);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a cyclic class","suites":["serializer"],"updatePoint":{"line":128,"column":37,"index":3424},"line":128,"code":"  it('should serialize a cyclic class', () => {\n    class Foo {\n      constructor(x) {\n        this.x = x;\n      }\n    }\n    registerSerializableClass('Foo', Foo);\n    let x = new Foo();\n    x.x = x;\n    let res = deserialize(serialize(x));\n    assert(res instanceof Foo);\n    assert(res.x instanceof Foo);\n    assert.equal(res.x, res);\n    assert.equal(x.x, x);\n    unregisterSerializableClass('Foo', Foo);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should copy on write","suites":["serializer"],"updatePoint":{"line":144,"column":26,"index":3827},"line":144,"code":"  it('should copy on write', () => {\n    class Foo {\n      constructor(x) {\n        this.x = x;\n      }\n    }\n    registerSerializableClass('Foo', Foo);\n    let x = {\n      y: {\n        foo: new Foo(2)\n      }\n    };\n    let res = deserialize(serialize(x));\n    assert(res.y.foo instanceof Foo);\n    assert(x.y.foo instanceof Foo);\n    unregisterSerializableClass('Foo', Foo);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a cyclic class and copy on write","suites":["serializer"],"updatePoint":{"line":161,"column":55,"index":4239},"line":161,"code":"  it('should serialize a cyclic class and copy on write', () => {\n    class Foo {\n      constructor(x) {\n        this.x = x;\n      }\n    }\n    registerSerializableClass('Foo', Foo);\n    let x = new Foo();\n    x.x = x;\n    let y = {\n      x: {\n        y: x\n      }\n    };\n    let res = deserialize(serialize(y));\n    assert(res.x.y instanceof Foo);\n    assert(res.x.y.x instanceof Foo);\n    assert(y.x.y instanceof Foo);\n    assert(y.x.y.x instanceof Foo);\n    assert.equal(res.x.y.x, res.x.y);\n    assert.equal(x.x, x);\n    unregisterSerializableClass('Foo', Foo);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a class inside a Map","suites":["serializer"],"updatePoint":{"line":184,"column":43,"index":4798},"line":184,"code":"  it('should serialize a class inside a Map', () => {\n    class Test {\n      constructor(x) {\n        this.x = x;\n      }\n    }\n    registerSerializableClass('Test', Test);\n    let x = new Map([[2, new Test(2)]]);\n    let res = deserialize(serialize(x));\n    assert(res instanceof Map);\n    assert(res.get(2) instanceof Test);\n    unregisterSerializableClass('Test', Test);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a class inside a Set","suites":["serializer"],"updatePoint":{"line":197,"column":43,"index":5178},"line":197,"code":"  it('should serialize a class inside a Set', () => {\n    class Test {\n      constructor(x) {\n        this.x = x;\n      }\n    }\n    registerSerializableClass('Test', Test);\n    let x = new Set([new Test(2)]);\n    let res = deserialize(serialize(x));\n    assert(res instanceof Set);\n    assert(res.values().next().value instanceof Test);\n    unregisterSerializableClass('Test', Test);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should not recursively serialize raw values","suites":["serializer","raw values"],"updatePoint":{"line":236,"column":51,"index":6179},"line":236,"code":"    it('should not recursively serialize raw values', () => {\n      let res = deserialize(serialize(new Outer(new Inner(42))));\n      assert(res instanceof Outer);\n      assert(!(res.inner instanceof Inner));\n      assert.equal(res.inner.x, 42);\n    });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should not recursively deserialize raw values","suites":["serializer","raw values"],"updatePoint":{"line":242,"column":53,"index":6435},"line":242,"code":"    it('should not recursively deserialize raw values', () => {\n      deserialize(serialize(new Outer(new Inner(42))));\n      assert(Inner.deserialize.notCalled);\n    });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"basic tree","suites":["SymbolPropagation"],"updatePoint":{"line":208,"column":16,"index":8659},"line":208,"code":"  it('basic tree', async () => {\n    // prettier-ignore\n    await testPropagation([['/index.js', [], true, []], ['/lib.js', [['f', {\n      local: 'lib1$foo'\n    }], ['b', {\n      local: 'lib2$bar'\n    }]], false, []], ['/lib1.js', [['foo', {\n      local: 'v'\n    }]], false, ['foo']], ['/lib2.js', [['bar', {\n      local: 'v'\n    }]], false, []]], [['/index.js', '/lib.js', [['f', {\n      local: 'f',\n      isWeak: false\n    }]], [['f', ['/lib1.js', 'foo']]]], ['/lib.js', '/lib1.js', [['foo', {\n      local: 'lib1$foo',\n      isWeak: true\n    }]], [['foo']]], ['/lib.js', '/lib2.js', [['bar', {\n      local: 'lib2$bar',\n      isWeak: true\n    }]], null]]);\n  });","file":"SymbolPropagation.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"basic tree - dependency symbol change export","suites":["SymbolPropagation"],"updatePoint":{"line":229,"column":50,"index":9357},"line":229,"code":"  it('basic tree - dependency symbol change export', async () => {\n    // prettier-ignore\n    let graph = await testPropagation([['/index.js', [], true, []], ['/lib.js', [['f', {\n      local: 'f'\n    }], ['b', {\n      local: 'b'\n    }]], true, ['f']]], [['/index.js', '/lib.js', [['f', {\n      local: 'f',\n      isWeak: false\n    }]], [['f']]]]);\n    let changedAssets = [...changeDependency(graph, 'index.js', '/lib.js', symbols => {\n      symbols.set('b', {\n        local: 'b',\n        isWeak: false,\n        loc: undefined\n      });\n    })];\n    propagateSymbols({\n      options: DEFAULT_OPTIONS,\n      assetGraph: graph,\n      changedAssetsPropagation: new Set(new Map(changedAssets).keys()),\n      assetGroupsWithRemovedParents: new Set()\n    });\n\n    // prettier-ignore\n    assertUsedSymbols(graph, [['/index.js', []], ['/lib.js', ['f', 'b']]], [['/index.js', '/lib.js', [['f'], ['b']]]]);\n  });","file":"SymbolPropagation.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"basic tree - dependency symbol change import and error","suites":["SymbolPropagation"],"updatePoint":{"line":256,"column":60,"index":10269},"line":256,"code":"  it('basic tree - dependency symbol change import and error', async () => {\n    // prettier-ignore\n    let graph = await testPropagation([['/index.js', [], true, []], ['/lib.js', [['f', {\n      local: 'f'\n    }]], true, ['f']]], [['/index.js', '/lib.js', [['f', {\n      local: 'f',\n      isWeak: false\n    }]], [['f']]]]);\n    let changedAssets = [...changeDependency(graph, 'index.js', '/lib.js', symbols => {\n      symbols.delete('f');\n      symbols.set('f2', {\n        local: 'f2',\n        isWeak: false,\n        loc: undefined\n      });\n    })];\n    let errors = propagateSymbols({\n      options: DEFAULT_OPTIONS,\n      assetGraph: graph,\n      changedAssetsPropagation: new Set(new Map(changedAssets).keys()),\n      assetGroupsWithRemovedParents: new Set()\n    });\n    assertPropagationErrors(graph, errors, [['lib.js', [{\n      message: \"lib.js does not export 'f2'\",\n      origin: '@parcel/core',\n      codeFrames: undefined\n    }]]]);\n  });","file":"SymbolPropagation.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"basic tree - asset symbol change export and error","suites":["SymbolPropagation"],"updatePoint":{"line":284,"column":55,"index":11214},"line":284,"code":"  it('basic tree - asset symbol change export and error', async () => {\n    // prettier-ignore\n    let graph = await testPropagation([['/index.js', [], true, []], ['/lib.js', [['f', {\n      local: 'f'\n    }]], true, ['f']]], [['/index.js', '/lib.js', [['f', {\n      local: 'f',\n      isWeak: false\n    }]], [['f']]]]);\n    let changedAssets = [...changeAsset(graph, 'lib.js', symbols => {\n      symbols.delete('f');\n      symbols.set('f2', {\n        local: 'f2',\n        loc: undefined\n      });\n    })];\n    let errors = propagateSymbols({\n      options: DEFAULT_OPTIONS,\n      assetGraph: graph,\n      changedAssetsPropagation: new Set(new Map(changedAssets).keys()),\n      assetGroupsWithRemovedParents: new Set()\n    });\n    assertPropagationErrors(graph, errors, [['lib.js', [{\n      message: \"lib.js does not export 'f'\",\n      origin: '@parcel/core',\n      codeFrames: undefined\n    }]]]);\n  });","file":"SymbolPropagation.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"basic tree - dependency symbol change reexport","suites":["SymbolPropagation"],"updatePoint":{"line":311,"column":52,"index":12114},"line":311,"code":"  it('basic tree - dependency symbol change reexport', async () => {\n    // prettier-ignore\n    let graph = await testPropagation([['/index.js', [], true, []], ['/lib.js', [['f', {\n      local: 'lib1$foo'\n    }], ['b', {\n      local: 'lib2$bar'\n    }]], true, []], ['/lib1.js', [['foo', {\n      local: 'v'\n    }]], true, ['foo']], ['/lib2.js', [['bar', {\n      local: 'v'\n    }]], true, []]], [['/index.js', '/lib.js', [['f', {\n      local: 'f',\n      isWeak: false\n    }]], [['f']]], ['/lib.js', '/lib1.js', [['foo', {\n      local: 'lib1$foo',\n      isWeak: true\n    }]], [['foo']]], ['/lib.js', '/lib2.js', [['bar', {\n      local: 'lib2$bar',\n      isWeak: true\n    }]], []]]);\n    let changedAssets = [...changeDependency(graph, 'index.js', '/lib.js', symbols => {\n      symbols.set('b', {\n        local: 'b',\n        isWeak: false,\n        loc: undefined\n      });\n    })];\n    propagateSymbols({\n      options: DEFAULT_OPTIONS,\n      assetGraph: graph,\n      changedAssetsPropagation: new Set(new Map(changedAssets).keys()),\n      assetGroupsWithRemovedParents: new Set()\n    });\n\n    // prettier-ignore\n    assertUsedSymbols(graph, [['/index.js', []], ['/lib.js', []], ['/lib1.js', ['foo']], ['/lib2.js', ['bar']]], [['/index.js', '/lib.js', [['f'], ['b']]], ['/lib.js', '/lib1.js', [['foo']]], ['/lib.js', '/lib2.js', [['bar']]]]);\n  });","file":"SymbolPropagation.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"basic tree with reexport-all","suites":["SymbolPropagation"],"updatePoint":{"line":348,"column":34,"index":13441},"line":348,"code":"  it('basic tree with reexport-all', async () => {\n    // prettier-ignore\n    await testPropagation([['/index.js', [], true, []], ['/lib.js', [], false, []], ['/lib1.js', [['foo', {\n      local: 'v'\n    }]], false, ['foo']], ['/lib2.js', [['bar', {\n      local: 'v'\n    }]], false, []]], [['/index.js', '/lib.js', [['foo', {\n      local: 'foo',\n      isWeak: false\n    }]], [['foo', ['/lib1.js', 'foo']]]], ['/lib.js', '/lib1.js', [['*', {\n      local: '*',\n      isWeak: true\n    }]], [['foo']]], ['/lib.js', '/lib2.js', [['*', {\n      local: '*',\n      isWeak: true\n    }]], null]]);\n  });","file":"SymbolPropagation.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"dependency with * imports everything","suites":["SymbolPropagation"],"updatePoint":{"line":365,"column":42,"index":14041},"line":365,"code":"  it('dependency with * imports everything', async () => {\n    // prettier-ignore\n    await testPropagation([['/index.js', [], true, []], ['/lib.js', [['a', {\n      local: 'lib1$foo'\n    }], ['b', {\n      local: 'lib1$b'\n    }]], true, ['*']], ['/lib1.js', [['b', {\n      local: 'v'\n    }]], true, ['b']], ['/lib2.js', [['c', {\n      local: 'v'\n    }]], true, ['*']]], [['/index.js', '/lib.js', [['*', {\n      local: 'lib',\n      isWeak: false\n    }]], [['*']]], ['/lib.js', '/lib1.js', [['b', {\n      local: 'lib1$foo',\n      isWeak: true\n    }]], [['b']]],\n    // TODO should usedSymbolsUp actually list the individual symbols instead of '*'?\n    ['/lib.js', '/lib2.js', [['*', {\n      local: '*',\n      isWeak: true\n    }]], [['*']]]]);\n  });","file":"SymbolPropagation.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"dependency with cleared symbols imports side-effect-full parts","suites":["SymbolPropagation"],"updatePoint":{"line":388,"column":68,"index":14813},"line":388,"code":"  it('dependency with cleared symbols imports side-effect-full parts', async () => {\n    // prettier-ignore\n    await testPropagation([['/index.js', [], true, []], ['/lib.js', [['a', {\n      local: 'lib1$foo'\n    }], ['b', {\n      local: 'lib$b'\n    }]], true, ['b']], ['/lib1.js', [['b', {\n      local: 'v'\n    }]], true, ['b']], ['/lib2.js', [['c', {\n      local: 'v'\n    }]], false, ['*']]], [['/index.js', '/lib.js', null, []], ['/lib.js', '/lib1.js', [['b', {\n      local: 'lib1$foo',\n      isWeak: true\n    }]], [['b']]], ['/lib.js', '/lib2.js', [['*', {\n      local: '*',\n      isWeak: true\n    }]], [['*']]]]);\n  });","file":"SymbolPropagation.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"dependency with cleared symbols imports side-effect-free package","suites":["SymbolPropagation"],"updatePoint":{"line":406,"column":70,"index":15440},"line":406,"code":"  it('dependency with cleared symbols imports side-effect-free package', async () => {\n    // prettier-ignore\n    await testPropagation([['/index.js', [], true, []], ['/lib.js', [['a', {\n      local: 'lib$a'\n    }], ['b', {\n      local: 'lib1$b'\n    }], ['c', {\n      local: 'lib2$c'\n    }]], false, ['a']], ['/lib1.js', [['b', {\n      local: 'v'\n    }]], false, ['b']], ['/lib2.js', [['c', {\n      local: 'v'\n    }]], false, ['c']], ['/lib3.js', [['d', {\n      local: 'v'\n    }]], false, ['*']]], [['/index.js', '/lib.js', null, []], ['/lib.js', '/lib1.js', [['b', {\n      local: 'lib1$b',\n      isWeak: true\n    }]], [['b']]], ['/lib.js', '/lib2.js', [['c', {\n      local: 'lib2$c',\n      isWeak: true\n    }]], [['c']]], ['/lib.js', '/lib3.js', [['*', {\n      local: '*',\n      isWeak: true\n    }]], [['*']]]]);\n  });","file":"SymbolPropagation.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"library build with entry dependency","suites":["SymbolPropagation"],"updatePoint":{"line":431,"column":41,"index":16231},"line":431,"code":"  it('library build with entry dependency', async () => {\n    // prettier-ignore\n    await testPropagation([['/index.js', [[\"foo\", {\n      local: \"foo\"\n    }], ['b', {\n      local: 'b$b'\n    }]], true, ['*']]], [], true);\n  });","file":"SymbolPropagation.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"library build with entry dependency and reexport","suites":["SymbolPropagation"],"updatePoint":{"line":439,"column":54,"index":16472},"line":439,"code":"  it('library build with entry dependency and reexport', async () => {\n    // prettier-ignore\n    await testPropagation([['/index.js', [[\"foo\", {\n      local: \"foo\"\n    }], ['b', {\n      local: 'b$b'\n    }]], true, ['*']], ['/b.js', [['b', {\n      local: 'b'\n    }]], true, ['b']]], [['/index.js', '/b.js', [['b', {\n      local: 'b$b',\n      isWeak: false\n    }]], [['b']]]], true);\n  });","file":"SymbolPropagation.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"cyclic dependency","suites":["SymbolPropagation"],"updatePoint":{"line":452,"column":23,"index":16830},"line":452,"code":"  it('cyclic dependency', async () => {\n    // prettier-ignore\n    await testPropagation([['/index.js', [], true, []], ['/a.js', [['a', {\n      local: 'b$b'\n    }], ['real', {\n      local: 'real'\n    }]], true, ['real']], ['/b.js', [['b', {\n      local: 'c$c'\n    }]], true, []], ['/c.js', [['c', {\n      local: 'a$real'\n    }]], true, []]], [['/index.js', '/a.js', [['a', {\n      local: 'a',\n      isWeak: false\n    }]], [['a']]], ['/a.js', '/b.js', [['b', {\n      local: 'b$b',\n      isWeak: true\n    }]], [['b']]], ['/b.js', '/c.js', [['c', {\n      local: 'c$c',\n      isWeak: true\n    }]], [['c']]], ['/c.js', '/a.js', [['real', {\n      local: 'a$real',\n      isWeak: true\n    }]], [['real']]]]);\n  });","file":"SymbolPropagation.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolves exactly specified targets","suites":["TargetResolver"],"updatePoint":{"line":64,"column":40,"index":2275},"line":64,"code":"  it('resolves exactly specified targets', async () => {\n    let targetResolver = new TargetResolver(api, {\n      ...DEFAULT_OPTIONS,\n      targets: {\n        customA: {\n          context: 'browser',\n          distDir: 'customA'\n        },\n        customB: {\n          distDir: 'customB',\n          distEntry: 'b.js',\n          engines: {\n            node: '>= 8.0.0'\n          }\n        }\n      }\n    });\n    assert.deepEqual(await targetResolver.resolve(COMMON_TARGETS_FIXTURE_PATH), [{\n      name: 'customA',\n      publicUrl: '/',\n      distDir: normalizeSeparators(path.resolve('customA')),\n      env: {\n        id: '1d40417b63734b32',\n        context: 'browser',\n        includeNodeModules: true,\n        engines: {\n          browsers: ['> 0.25%']\n        },\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      }\n    }, {\n      name: 'customB',\n      publicUrl: '/',\n      distEntry: 'b.js',\n      distDir: normalizeSeparators(path.resolve('customB')),\n      env: {\n        id: '928f0d1c941b2e57',\n        context: 'node',\n        includeNodeModules: false,\n        engines: {\n          node: '>= 8.0.0'\n        },\n        outputFormat: 'commonjs',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolves common targets from package.json","suites":["TargetResolver"],"updatePoint":{"line":122,"column":47,"index":3777},"line":122,"code":"  it('resolves common targets from package.json', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    assert.deepEqual(await targetResolver.resolve(COMMON_TARGETS_FIXTURE_PATH), [{\n      name: 'main',\n      distDir: 'fixtures/common-targets/dist/main',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: 'b552bd32da37fa8b',\n        context: 'node',\n        engines: {\n          node: '>= 8.0.0'\n        },\n        includeNodeModules: false,\n        outputFormat: 'commonjs',\n        isLibrary: true,\n        shouldOptimize: false,\n        shouldScopeHoist: true,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(COMMON_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 11,\n          line: 2\n        },\n        end: {\n          column: 30,\n          line: 2\n        }\n      }\n    }, {\n      name: 'module',\n      distDir: 'fixtures/common-targets/dist/module',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: '8804e4eb97e2703e',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 version']\n        },\n        includeNodeModules: false,\n        outputFormat: 'esmodule',\n        isLibrary: true,\n        shouldOptimize: false,\n        shouldScopeHoist: true,\n        sourceMap: {\n          inlineSources: true\n        },\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(COMMON_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 13,\n          line: 3\n        },\n        end: {\n          column: 34,\n          line: 3\n        }\n      }\n    }, {\n      name: 'browser',\n      distDir: 'fixtures/common-targets/dist/browser',\n      distEntry: 'index.js',\n      publicUrl: '/assets',\n      env: {\n        id: 'a7ed3e73c53f1923',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 version']\n        },\n        includeNodeModules: false,\n        outputFormat: 'commonjs',\n        isLibrary: true,\n        shouldOptimize: false,\n        shouldScopeHoist: true,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(COMMON_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 14,\n          line: 4\n        },\n        end: {\n          column: 36,\n          line: 4\n        }\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"allows ignoring common targets from package.json","suites":["TargetResolver"],"updatePoint":{"line":221,"column":54,"index":6306},"line":221,"code":"  it('allows ignoring common targets from package.json', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    assert.deepEqual(await targetResolver.resolve(COMMON_TARGETS_IGNORE_FIXTURE_PATH), [{\n      name: 'app',\n      distDir: relative(path.join(COMMON_TARGETS_IGNORE_FIXTURE_PATH, 'dist')),\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: 'f7c9644283a8698f',\n        context: 'node',\n        engines: {\n          node: '>= 8.0.0'\n        },\n        includeNodeModules: false,\n        outputFormat: 'commonjs',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: undefined,\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(COMMON_TARGETS_IGNORE_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 10,\n          line: 3\n        },\n        end: {\n          column: 24,\n          line: 3\n        }\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolves custom targets from package.json","suites":["TargetResolver"],"updatePoint":{"line":256,"column":47,"index":7315},"line":256,"code":"  it('resolves custom targets from package.json', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    assert.deepEqual(await targetResolver.resolve(CUSTOM_TARGETS_FIXTURE_PATH), [{\n      name: 'main',\n      distDir: 'fixtures/custom-targets/dist/main',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: 'b552bd32da37fa8b',\n        context: 'node',\n        engines: {\n          node: '>= 8.0.0'\n        },\n        includeNodeModules: false,\n        outputFormat: 'commonjs',\n        isLibrary: true,\n        shouldOptimize: false,\n        shouldScopeHoist: true,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(CUSTOM_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 11,\n          line: 2\n        },\n        end: {\n          column: 30,\n          line: 2\n        }\n      }\n    }, {\n      name: 'browserModern',\n      distDir: 'fixtures/custom-targets/dist/browserModern',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: '1f28e9ceaf633d83',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 version']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(CUSTOM_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 20,\n          line: 3\n        },\n        end: {\n          column: 48,\n          line: 3\n        }\n      }\n    }, {\n      name: 'browserLegacy',\n      distDir: 'fixtures/custom-targets/dist/browserLegacy',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: '767bf6e6b675c4f3',\n        context: 'browser',\n        engines: {\n          browsers: ['ie11']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(CUSTOM_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 20,\n          line: 4\n        },\n        end: {\n          column: 48,\n          line: 4\n        }\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should not optimize libraries by default","suites":["TargetResolver"],"updatePoint":{"line":353,"column":46,"index":9805},"line":353,"code":"  it('should not optimize libraries by default', async () => {\n    let targetResolver = new TargetResolver(api, {\n      ...DEFAULT_OPTIONS,\n      mode: 'production',\n      defaultTargetOptions: {\n        ...DEFAULT_OPTIONS.defaultTargetOptions,\n        shouldOptimize: true\n      }\n    });\n    assert.deepEqual(await targetResolver.resolve(CUSTOM_TARGETS_FIXTURE_PATH), [{\n      name: 'main',\n      distDir: 'fixtures/custom-targets/dist/main',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: 'b552bd32da37fa8b',\n        context: 'node',\n        engines: {\n          node: '>= 8.0.0'\n        },\n        includeNodeModules: false,\n        outputFormat: 'commonjs',\n        isLibrary: true,\n        shouldOptimize: false,\n        shouldScopeHoist: true,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(CUSTOM_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 11,\n          line: 2\n        },\n        end: {\n          column: 30,\n          line: 2\n        }\n      }\n    }, {\n      name: 'browserModern',\n      distDir: 'fixtures/custom-targets/dist/browserModern',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: 'ed7c0e65adee71c9',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 version']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: true,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(CUSTOM_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 20,\n          line: 3\n        },\n        end: {\n          column: 48,\n          line: 3\n        }\n      }\n    }, {\n      name: 'browserLegacy',\n      distDir: 'fixtures/custom-targets/dist/browserLegacy',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: 'f7692543e59e4c0a',\n        context: 'browser',\n        engines: {\n          browsers: ['ie11']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: true,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(CUSTOM_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 20,\n          line: 4\n        },\n        end: {\n          column: 48,\n          line: 4\n        }\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolves explicit distDir for custom targets from package.json","suites":["TargetResolver"],"updatePoint":{"line":457,"column":68,"index":12475},"line":457,"code":"  it('resolves explicit distDir for custom targets from package.json', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    assert.deepEqual(await targetResolver.resolve(CUSTOM_TARGETS_DISTDIR_FIXTURE_PATH), [{\n      name: 'app',\n      distDir: 'fixtures/custom-targets-distdir/www',\n      distEntry: undefined,\n      publicUrl: 'www',\n      env: {\n        id: 'ddb6ac7c9a3a9178',\n        context: 'browser',\n        engines: {\n          browsers: '> 0.25%'\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: undefined\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"skips targets with custom entry source for default entry","suites":["TargetResolver"],"updatePoint":{"line":482,"column":62,"index":13247},"line":482,"code":"  it('skips targets with custom entry source for default entry', async () => {\n    let targetResolver = new TargetResolver(api, {\n      ...DEFAULT_OPTIONS,\n      targets: {\n        customA: {\n          context: 'browser',\n          distDir: 'customA',\n          source: 'customA/index.js'\n        },\n        customB: {\n          distDir: 'customB'\n        }\n      }\n    });\n    assert.deepEqual(await targetResolver.resolve(COMMON_TARGETS_FIXTURE_PATH), [{\n      name: 'customB',\n      distDir: normalizeSeparators(path.resolve('customB')),\n      publicUrl: '/',\n      env: {\n        id: '1d40417b63734b32',\n        context: 'browser',\n        engines: {\n          browsers: ['> 0.25%']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"skips other targets with custom entry","suites":["TargetResolver"],"updatePoint":{"line":517,"column":43,"index":14181},"line":517,"code":"  it('skips other targets with custom entry', async () => {\n    let targetResolver = new TargetResolver(api, {\n      ...DEFAULT_OPTIONS,\n      targets: {\n        customA: {\n          context: 'browser',\n          distDir: 'customA',\n          source: 'customA/index.js'\n        },\n        customB: {\n          distDir: 'customB'\n        }\n      }\n    });\n    assert.deepEqual(await targetResolver.resolve(COMMON_TARGETS_FIXTURE_PATH, 'customA'), [{\n      name: 'customA',\n      distDir: normalizeSeparators(path.resolve('customA')),\n      publicUrl: '/',\n      env: {\n        id: '1d40417b63734b32',\n        context: 'browser',\n        engines: {\n          browsers: ['> 0.25%']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      source: 'customA/index.js'\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolves main target with context from package.json","suites":["TargetResolver"],"updatePoint":{"line":553,"column":57,"index":15174},"line":553,"code":"  it('resolves main target with context from package.json', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    assert.deepEqual(await targetResolver.resolve(CONTEXT_FIXTURE_PATH), [{\n      name: 'main',\n      distDir: 'fixtures/context/dist/main',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: '6aafdb9eaa4a3812',\n        context: 'node',\n        engines: {\n          browsers: ['last 1 Chrome version', 'last 1 Safari version', 'last 1 Firefox version', 'last 1 Edge version']\n        },\n        includeNodeModules: false,\n        isLibrary: true,\n        outputFormat: 'commonjs',\n        shouldOptimize: false,\n        shouldScopeHoist: true,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(CONTEXT_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 11,\n          line: 2\n        },\n        end: {\n          column: 30,\n          line: 2\n        }\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"errors when the main target contains a non-js extension","suites":["TargetResolver"],"updatePoint":{"line":588,"column":61,"index":16219},"line":588,"code":"  it('errors when the main target contains a non-js extension', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/application-targets');\n    let code = await fs.readFile(path.join(fixture, 'package.json'), 'utf8');\n\n    // $FlowFixMe\n    await assert.rejects(() => targetResolver.resolve(fixture), {\n      diagnostics: [{\n        message: 'Unexpected output file type .html in target \"main\"',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(fixture, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            end: {\n              column: 27,\n              line: 2\n            },\n            message: 'File extension must be .js, .mjs, or .cjs',\n            start: {\n              column: 11,\n              line: 2\n            }\n          }]\n        }],\n        hints: ['The \"main\" field is meant for libraries. If you meant to output a .html file, either remove the \"main\" field or choose a different target name.'],\n        documentationURL: 'https://parceljs.org/features/targets/#library-targets'\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"errors when the main target uses the global output format","suites":["TargetResolver"],"updatePoint":{"line":619,"column":63,"index":17404},"line":619,"code":"  it('errors when the main target uses the global output format', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/main-global');\n    let code = await fs.readFile(path.join(fixture, 'package.json'), 'utf8');\n\n    // $FlowFixMe\n    await assert.rejects(() => targetResolver.resolve(fixture), {\n      diagnostics: [{\n        message: 'The \"global\" output format is not supported in the \"main\" target.',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(fixture, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            message: undefined,\n            end: {\n              column: 30,\n              line: 5\n            },\n            start: {\n              column: 23,\n              line: 5\n            }\n          }]\n        }],\n        hints: ['The \"main\" field is meant for libraries. The outputFormat must be either \"commonjs\" or \"esmodule\". Either change or remove the declared outputFormat.'],\n        documentationURL: 'https://parceljs.org/features/targets/#library-targets'\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"errors when the main target uses the esmodule output format without a .mjs extension or \"type\": \"module\" field","suites":["TargetResolver"],"updatePoint":{"line":650,"column":116,"index":18621},"line":650,"code":"  it('errors when the main target uses the esmodule output format without a .mjs extension or \"type\": \"module\" field', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/main-mjs');\n    let code = await fs.readFile(path.join(fixture, 'package.json'), 'utf8');\n\n    // $FlowFixMe\n    await assert.rejects(() => targetResolver.resolve(fixture), {\n      diagnostics: [{\n        message: 'Output format \"esmodule\" cannot be used in the \"main\" target without a .mjs extension or \"type\": \"module\" field.',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(fixture, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            message: 'Declared output format defined here',\n            end: {\n              column: 32,\n              line: 5\n            },\n            start: {\n              column: 23,\n              line: 5\n            }\n          }, {\n            message: 'Inferred output format defined here',\n            end: {\n              column: 25,\n              line: 2\n            },\n            start: {\n              column: 11,\n              line: 2\n            }\n          }]\n        }],\n        hints: ['Either change the output file extension to .mjs, add \"type\": \"module\" to package.json, or remove the declared outputFormat.'],\n        documentationURL: 'https://parceljs.org/features/targets/#library-targets'\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"errors when the inferred output format does not match the declared one in common targets","suites":["TargetResolver"],"updatePoint":{"line":691,"column":94,"index":20102},"line":691,"code":"  it('errors when the inferred output format does not match the declared one in common targets', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/main-format-mismatch');\n    let code = await fs.readFile(path.join(fixture, 'package.json'), 'utf8');\n\n    // $FlowFixMe\n    await assert.rejects(() => targetResolver.resolve(fixture), {\n      diagnostics: [{\n        message: 'Declared output format \"esmodule\" does not match expected output format \"commonjs\".',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(fixture, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            message: 'Declared output format defined here',\n            end: {\n              column: 32,\n              line: 5\n            },\n            start: {\n              column: 23,\n              line: 5\n            }\n          }, {\n            message: 'Inferred output format defined here',\n            end: {\n              column: 26,\n              line: 2\n            },\n            start: {\n              column: 11,\n              line: 2\n            }\n          }]\n        }],\n        hints: ['Either remove the target\\'s declared \"outputFormat\" or change the extension to .mjs or .js.'],\n        documentationURL: 'https://parceljs.org/features/targets/#library-targets'\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"errors when the inferred output format does not match the declared one in custom targets","suites":["TargetResolver"],"updatePoint":{"line":732,"column":94,"index":21534},"line":732,"code":"  it('errors when the inferred output format does not match the declared one in custom targets', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/custom-format-mismatch');\n    let code = await fs.readFile(path.join(fixture, 'package.json'), 'utf8');\n\n    // $FlowFixMe\n    await assert.rejects(() => targetResolver.resolve(fixture), {\n      diagnostics: [{\n        message: 'Declared output format \"commonjs\" does not match expected output format \"esmodule\".',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(fixture, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            message: 'Declared output format defined here',\n            end: {\n              column: 32,\n              line: 5\n            },\n            start: {\n              column: 23,\n              line: 5\n            }\n          }, {\n            message: 'Inferred output format defined here',\n            end: {\n              column: 26,\n              line: 2\n            },\n            start: {\n              column: 11,\n              line: 2\n            }\n          }]\n        }],\n        hints: ['Either remove the target\\'s declared \"outputFormat\" or change the extension to .cjs or .js.'],\n        documentationURL: 'https://parceljs.org/features/targets/#library-targets'\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"errors when a common library target turns scope hoisting off","suites":["TargetResolver"],"updatePoint":{"line":773,"column":66,"index":22940},"line":773,"code":"  it('errors when a common library target turns scope hoisting off', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/library-scopehoist');\n    let code = await fs.readFile(path.join(fixture, 'package.json'), 'utf8');\n\n    // $FlowFixMe\n    await assert.rejects(() => targetResolver.resolve(fixture), {\n      diagnostics: [{\n        message: 'Scope hoisting cannot be disabled for library targets.',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(fixture, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            message: undefined,\n            end: {\n              column: 25,\n              line: 5\n            },\n            start: {\n              column: 21,\n              line: 5\n            }\n          }]\n        }],\n        hints: ['The \"main\" target is meant for libraries. Either remove the \"scopeHoist\" option, or use a different target name.'],\n        documentationURL: 'https://parceljs.org/features/targets/#library-targets'\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"errors when a custom library target turns scope hoisting off","suites":["TargetResolver"],"updatePoint":{"line":804,"column":66,"index":24066},"line":804,"code":"  it('errors when a custom library target turns scope hoisting off', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/library-custom-scopehoist');\n    let code = await fs.readFile(path.join(fixture, 'package.json'), 'utf8');\n\n    // $FlowFixMe\n    await assert.rejects(() => targetResolver.resolve(fixture), {\n      diagnostics: [{\n        message: 'Scope hoisting cannot be disabled for library targets.',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(fixture, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            message: undefined,\n            end: {\n              column: 25,\n              line: 6\n            },\n            start: {\n              column: 21,\n              line: 6\n            }\n          }, {\n            message: undefined,\n            end: {\n              column: 23,\n              line: 5\n            },\n            start: {\n              column: 20,\n              line: 5\n            }\n          }]\n        }],\n        hints: ['Either remove the \"scopeHoist\" or \"isLibrary\" option.'],\n        documentationURL: 'https://parceljs.org/features/targets/#library-targets'\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should infer output format for custom targets by extension","suites":["TargetResolver"],"updatePoint":{"line":845,"column":64,"index":25350},"line":845,"code":"  it('should infer output format for custom targets by extension', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/custom-format-infer-ext');\n    assert.deepEqual(await targetResolver.resolve(fixture), [{\n      name: 'test',\n      distDir: relative(path.join(fixture, 'dist')),\n      distEntry: 'index.mjs',\n      publicUrl: '/',\n      env: {\n        id: '439701173a9199ea',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 Chrome version', 'last 1 Safari version', 'last 1 Firefox version', 'last 1 Edge version']\n        },\n        includeNodeModules: true,\n        outputFormat: 'esmodule',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(fixture, 'package.json')),\n        start: {\n          column: 11,\n          line: 2\n        },\n        end: {\n          column: 26,\n          line: 2\n        }\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should infer output format for custom targets by \"type\": \"module\" field","suites":["TargetResolver"],"updatePoint":{"line":881,"column":77,"index":26474},"line":881,"code":"  it('should infer output format for custom targets by \"type\": \"module\" field', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/custom-format-infer-type');\n    assert.deepEqual(await targetResolver.resolve(fixture), [{\n      name: 'test',\n      distDir: relative(path.join(fixture, 'dist')),\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: '439701173a9199ea',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 Chrome version', 'last 1 Safari version', 'last 1 Firefox version', 'last 1 Edge version']\n        },\n        includeNodeModules: true,\n        outputFormat: 'esmodule',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(fixture, 'package.json')),\n        start: {\n          column: 11,\n          line: 3\n        },\n        end: {\n          column: 25,\n          line: 3\n        }\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolves a subset of package.json targets when given a list of names","suites":["TargetResolver"],"updatePoint":{"line":917,"column":74,"index":27595},"line":917,"code":"  it('resolves a subset of package.json targets when given a list of names', async () => {\n    let targetResolver = new TargetResolver(api, {\n      ...DEFAULT_OPTIONS,\n      targets: ['main', 'browser']\n    });\n    assert.deepEqual(await targetResolver.resolve(COMMON_TARGETS_FIXTURE_PATH), [{\n      name: 'main',\n      distDir: 'fixtures/common-targets/dist/main',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: 'b552bd32da37fa8b',\n        context: 'node',\n        engines: {\n          node: '>= 8.0.0'\n        },\n        includeNodeModules: false,\n        outputFormat: 'commonjs',\n        isLibrary: true,\n        shouldOptimize: false,\n        shouldScopeHoist: true,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(COMMON_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 11,\n          line: 2\n        },\n        end: {\n          column: 30,\n          line: 2\n        }\n      }\n    }, {\n      name: 'browser',\n      distDir: 'fixtures/common-targets/dist/browser',\n      distEntry: 'index.js',\n      publicUrl: '/assets',\n      env: {\n        id: 'a7ed3e73c53f1923',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 version']\n        },\n        includeNodeModules: false,\n        outputFormat: 'commonjs',\n        isLibrary: true,\n        shouldOptimize: false,\n        shouldScopeHoist: true,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(COMMON_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 14,\n          line: 4\n        },\n        end: {\n          column: 36,\n          line: 4\n        }\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"generates a default target in serve mode","suites":["TargetResolver"],"updatePoint":{"line":986,"column":46,"index":29372},"line":986,"code":"  it('generates a default target in serve mode', async () => {\n    let serveDistDir = path.join(DEFAULT_OPTIONS.cacheDir, 'dist');\n    let targetResolver = new TargetResolver(api, {\n      ...DEFAULT_OPTIONS,\n      serveOptions: {\n        distDir: serveDistDir,\n        port: 1234\n      }\n    });\n    assert.deepEqual(await targetResolver.resolve(COMMON_TARGETS_FIXTURE_PATH), [{\n      name: 'default',\n      distDir: '.parcel-cache/dist',\n      publicUrl: '/',\n      env: {\n        id: 'd6ea1d42532a7575',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 Chrome version', 'last 1 Safari version', 'last 1 Firefox version', 'last 1 Edge version']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"generates the correct distDir with no explicit targets","suites":["TargetResolver"],"updatePoint":{"line":1016,"column":60,"index":30325},"line":1016,"code":"  it('generates the correct distDir with no explicit targets', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    assert.deepEqual(await targetResolver.resolve(DEFAULT_DISTPATH_FIXTURE_PATHS.none), [{\n      name: 'default',\n      distDir: relative(path.join(DEFAULT_DISTPATH_FIXTURE_PATHS.none, 'dist')),\n      publicUrl: '/',\n      env: {\n        id: 'a9c07d094d038c73',\n        context: 'browser',\n        engines: {\n          browsers: ['Chrome 80']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"generates the correct distDir with one explicit target","suites":["TargetResolver"],"updatePoint":{"line":1039,"column":60,"index":31078},"line":1039,"code":"  it('generates the correct distDir with one explicit target', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    assert.deepEqual(await targetResolver.resolve(DEFAULT_DISTPATH_FIXTURE_PATHS.one), [{\n      name: 'browserModern',\n      distDir: relative(path.join(DEFAULT_DISTPATH_FIXTURE_PATHS.one, 'dist')),\n      distEntry: undefined,\n      publicUrl: '/',\n      env: {\n        id: 'a9c07d094d038c73',\n        context: 'browser',\n        engines: {\n          browsers: ['Chrome 80']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: undefined\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"generates the correct distDirs with two explicit targets","suites":["TargetResolver"],"updatePoint":{"line":1064,"column":62,"index":31887},"line":1064,"code":"  it('generates the correct distDirs with two explicit targets', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    assert.deepEqual(await targetResolver.resolve(DEFAULT_DISTPATH_FIXTURE_PATHS.two), [{\n      name: 'browserModern',\n      distDir: relative(path.join(DEFAULT_DISTPATH_FIXTURE_PATHS.two, 'dist', 'browserModern')),\n      distEntry: undefined,\n      publicUrl: '/',\n      env: {\n        id: '1f28e9ceaf633d83',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 version']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: undefined\n    }, {\n      name: 'browserLegacy',\n      distDir: relative(path.join(DEFAULT_DISTPATH_FIXTURE_PATHS.two, 'dist', 'browserLegacy')),\n      distEntry: undefined,\n      publicUrl: '/',\n      env: {\n        id: '824e113c03cab3c8',\n        context: 'browser',\n        engines: {\n          browsers: ['IE 11']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: undefined\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects invalid or unknown fields","suites":["TargetResolver"],"updatePoint":{"line":1110,"column":39,"index":33275},"line":1110,"code":"  it('rejects invalid or unknown fields', async () => {\n    let code = '{\\n' + '\\t\"targets\": {\\n' + '\\t\\t\"main\": {\\n' + '\\t\\t\\t\"includeNodeModules\": [\\n' + '\\t\\t\\t\\t\"react\",\\n' + '\\t\\t\\t\\ttrue\\n' + '\\t\\t\\t],\\n' + '\\t\\t\\t\"context\": \"nodes\",\\n' + '\\t\\t\\t\"outputFormat\": \"module\",\\n' + '\\t\\t\\t\"sourceMap\": {\\n' + '\\t\\t\\t\\t\"sourceRoot\": \"asd\",\\n' + '\\t\\t\\t\\t\"inline\": \"false\",\\n' + '\\t\\t\\t\\t\"verbose\": true\\n' + '\\t\\t\\t},\\n' + '\\t\\t\\t\"engines\": {\\n' + '\\t\\t\\t\\t\"node\": \"12\",\\n' + '\\t\\t\\t\\t\"browser\": \"Chrome 70\"\\n' + '\\t\\t\\t}\\n' + '\\t\\t}\\n' + '\\t}\\n' + '}';\n    let targetResolver = new TargetResolver(api, {\n      ...DEFAULT_OPTIONS,\n      ...JSON.parse(code)\n    });\n\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => targetResolver.resolve(COMMON_TARGETS_FIXTURE_PATH), {\n      message: 'Invalid target descriptor for target \"main\"',\n      diagnostics: [{\n        message: 'Invalid target descriptor for target \"main\"',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: undefined,\n          language: 'json',\n          code,\n          codeHighlights: [{\n            start: {\n              line: 6,\n              column: 5\n            },\n            end: {\n              line: 6,\n              column: 8\n            },\n            message: 'Expected a wildcard or filepath'\n          }, {\n            start: {\n              line: 8,\n              column: 15\n            },\n            end: {\n              line: 8,\n              column: 21\n            },\n            message: 'Did you mean \"node\"?'\n          }, {\n            start: {\n              line: 9,\n              column: 20\n            },\n            end: {\n              line: 9,\n              column: 27\n            },\n            message: 'Did you mean \"esmodule\"?'\n          }, {\n            start: {\n              line: 12,\n              column: 15\n            },\n            end: {\n              line: 12,\n              column: 21\n            },\n            message: 'Expected type boolean'\n          }, {\n            start: {\n              line: 13,\n              column: 5\n            },\n            end: {\n              line: 13,\n              column: 13\n            },\n            message: 'Possible values: \"inlineSources\"'\n          }, {\n            start: {\n              line: 17,\n              column: 5\n            },\n            end: {\n              line: 17,\n              column: 13\n            },\n            message: 'Did you mean \"browsers\"?'\n          }]\n        }]\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects invalid or unknown fields in package.json","suites":["TargetResolver"],"updatePoint":{"line":1192,"column":55,"index":35811},"line":1192,"code":"  it('rejects invalid or unknown fields in package.json', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let code = await fs.readFileSync(path.join(INVALID_TARGETS_FIXTURE_PATH, 'package.json'), 'utf8');\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => targetResolver.resolve(INVALID_TARGETS_FIXTURE_PATH), {\n      diagnostics: [{\n        message: 'Invalid target descriptor for target \"module\"',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(INVALID_TARGETS_FIXTURE_PATH, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            start: {\n              line: 9,\n              column: 29\n            },\n            end: {\n              line: 9,\n              column: 35\n            },\n            message: 'Expected type boolean'\n          }, {\n            start: {\n              line: 11,\n              column: 7\n            },\n            end: {\n              line: 11,\n              column: 17\n            },\n            message: 'Did you mean \"publicUrl\"?'\n          }]\n        }]\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects invalid engines in package.json","suites":["TargetResolver"],"updatePoint":{"line":1229,"column":45,"index":36957},"line":1229,"code":"  it('rejects invalid engines in package.json', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let code = await fs.readFileSync(path.join(INVALID_ENGINES_FIXTURE_PATH, 'package.json'), 'utf8');\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => targetResolver.resolve(INVALID_ENGINES_FIXTURE_PATH), {\n      diagnostics: [{\n        message: 'Invalid engines in package.json',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(INVALID_ENGINES_FIXTURE_PATH, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            end: {\n              column: 13,\n              line: 8\n            },\n            message: 'Did you mean \"browsers\"?',\n            start: {\n              column: 5,\n              line: 8\n            }\n          }, {\n            end: {\n              column: 5,\n              line: 7\n            },\n            message: 'Expected type string',\n            start: {\n              column: 13,\n              line: 5\n            }\n          }]\n        }]\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects target distpath in package.json","suites":["TargetResolver"],"updatePoint":{"line":1266,"column":45,"index":38084},"line":1266,"code":"  it('rejects target distpath in package.json', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let code = await fs.readFileSync(path.join(INVALID_DISTPATH_FIXTURE_PATH, 'package.json'), 'utf8');\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => targetResolver.resolve(INVALID_DISTPATH_FIXTURE_PATH), {\n      diagnostics: [{\n        message: 'Invalid distPath for target \"legacy\"',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(INVALID_DISTPATH_FIXTURE_PATH, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            end: {\n              column: 13,\n              line: 2\n            },\n            message: 'Expected type string',\n            start: {\n              column: 13,\n              line: 2\n            }\n          }]\n        }]\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects duplicate target paths","suites":["TargetResolver"],"updatePoint":{"line":1293,"column":36,"index":38983},"line":1293,"code":"  it('rejects duplicate target paths', async () => {\n    let fixture = path.join(__dirname, 'fixtures/duplicate-targets');\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let code = await fs.readFileSync(path.join(fixture, 'package.json'), 'utf8');\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => targetResolver.resolve(fixture), {\n      diagnostics: [{\n        message: md`Multiple targets have the same destination path \"${path.normalize('dist/index.js')}\"`,\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(fixture, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            end: {\n              column: 25,\n              line: 2\n            },\n            message: undefined,\n            start: {\n              column: 11,\n              line: 2\n            }\n          }, {\n            end: {\n              column: 27,\n              line: 3\n            },\n            message: undefined,\n            start: {\n              column: 13,\n              line: 3\n            }\n          }]\n        }],\n        hints: ['Try removing the duplicate targets, or changing the destination paths.']\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"only accepts 32-character hexadecimal strings","suites":["getPublicId"],"updatePoint":{"line":6,"column":51,"index":250},"line":6,"code":"  it('only accepts 32-character hexadecimal strings', () => {\n    assert.throws(() => {\n      getPublicId('abc', () => false);\n    });\n    let notHexadecimal = 'abcdefghiklmnopqrstuvwxyz1234567';\n    assert.equal(notHexadecimal.length, 32);\n    assert.throws(() => {\n      getPublicId(notHexadecimal, () => false);\n    });\n  });","file":"utils.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"if no collisions, returns the first 5 base62 characters of value represented by the input","suites":["getPublicId"],"updatePoint":{"line":16,"column":95,"index":623},"line":16,"code":"  it('if no collisions, returns the first 5 base62 characters of value represented by the input', () => {\n    assert.equal(getPublicId(id, () => false), fullPublicId.slice(0, 5));\n  });","file":"utils.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"uses more characters if there is a collision","suites":["getPublicId"],"updatePoint":{"line":19,"column":50,"index":764},"line":19,"code":"  it('uses more characters if there is a collision', () => {\n    assert.equal(getPublicId(id, publicId => [fullPublicId.slice(0, 5), fullPublicId.slice(0, 6)].includes(publicId)), fullPublicId.slice(0, 7));\n  });","file":"utils.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"fails if all characters collide","suites":["getPublicId"],"updatePoint":{"line":22,"column":37,"index":964},"line":22,"code":"  it('fails if all characters collide', () => {\n    assert.throws(() => {\n      getPublicId(id, () => true);\n    });\n  });","file":"utils.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"returns an escaped string 01","suites":["escapeMarkdown"],"updatePoint":{"line":4,"column":34,"index":155},"line":4,"code":"  it('returns an escaped string 01', () => {\n    assert.strictEqual('\\\\*test\\\\*', escapeMarkdown('*test*'));\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"returns an escaped string 02","suites":["escapeMarkdown"],"updatePoint":{"line":7,"column":34,"index":270},"line":7,"code":"  it('returns an escaped string 02', () => {\n    assert.strictEqual('\\\\_test\\\\_', escapeMarkdown('_test_'));\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"returns an escaped string 03","suites":["escapeMarkdown"],"updatePoint":{"line":10,"column":34,"index":385},"line":10,"code":"  it('returns an escaped string 03', () => {\n    assert.strictEqual('\\\\~test\\\\~', escapeMarkdown('~test~'));\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"returns an escaped string 04","suites":["escapeMarkdown"],"updatePoint":{"line":13,"column":34,"index":500},"line":13,"code":"  it('returns an escaped string 04', () => {\n    assert.strictEqual('\\\\*\\\\_\\\\~test\\\\~\\\\_\\\\*', escapeMarkdown('*_~test~_*'));\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"returns an escaped string with backslash 01","suites":["escapeMarkdown"],"updatePoint":{"line":16,"column":49,"index":646},"line":16,"code":"  it('returns an escaped string with backslash 01', () => {\n    assert.strictEqual('\\\\\\\\test\\\\\\\\', escapeMarkdown('\\\\test\\\\'));\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"returns an escaped string with backslash 02","suites":["escapeMarkdown"],"updatePoint":{"line":19,"column":49,"index":780},"line":19,"code":"  it('returns an escaped string with backslash 02', () => {\n    assert.strictEqual('\\\\\\\\\\\\*test\\\\*\\\\\\\\', escapeMarkdown('\\\\*test*\\\\'));\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"bold placeholder","suites":["md tagged template literal"],"updatePoint":{"line":24,"column":22,"index":946},"line":24,"code":"  it('bold placeholder', () => {\n    assert.strictEqual('*Test*: **\\\\_abc\\\\_**', md`*Test*: ${md.bold('_abc_')}`);\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"italic placeholder","suites":["md tagged template literal"],"updatePoint":{"line":27,"column":24,"index":1069},"line":27,"code":"  it('italic placeholder', () => {\n    assert.strictEqual('*Test*: _\\\\_abc\\\\__', md`*Test*: ${md.italic('_abc_')}`);\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"underline placeholder","suites":["md tagged template literal"],"updatePoint":{"line":30,"column":27,"index":1195},"line":30,"code":"  it('underline placeholder', () => {\n    assert.strictEqual('*Test*: __\\\\_abc\\\\___', md`*Test*: ${md.underline('_abc_')}`);\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"strikethrough placeholder","suites":["md tagged template literal"],"updatePoint":{"line":33,"column":31,"index":1330},"line":33,"code":"  it('strikethrough placeholder', () => {\n    assert.strictEqual('*Test*: ~~\\\\_abc\\\\_~~', md`*Test*: ${md.strikethrough('_abc_')}`);\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"escapes only placeholders","suites":["md tagged template literal"],"updatePoint":{"line":36,"column":31,"index":1469},"line":36,"code":"  it('escapes only placeholders', () => {\n    assert.strictEqual('*Test*: \\\\_abc\\\\_', md`*Test*: ${'_abc_'}`);\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"behaves like native template literal","suites":["md tagged template literal"],"updatePoint":{"line":39,"column":42,"index":1597},"line":39,"code":"  it('behaves like native template literal', () => {\n    let v = {\n      toString() {\n        return 'a';\n      },\n      // $FlowFixMe[invalid-computed-prop]\n      [Symbol.toPrimitive]() {\n        return 'b';\n      }\n    };\n    assert.strictEqual('Test: b', md`Test: ${v}`);\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"supports null and undefined","suites":["md tagged template literal"],"updatePoint":{"line":51,"column":33,"index":1869},"line":51,"code":"  it('supports null and undefined', () => {\n    assert.strictEqual('Test: undefined null', md`Test: ${undefined} ${null}`);\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"constructor should initialize an empty graph","suites":["AdjacencyList"],"updatePoint":{"line":7,"column":50,"index":301},"line":7,"code":"  it('constructor should initialize an empty graph', () => {\n    let stats = new AdjacencyList().stats;\n    assert(stats.nodes === 0);\n    assert(stats.edges === 0);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addNode should add a node to the graph","suites":["AdjacencyList"],"updatePoint":{"line":12,"column":44,"index":467},"line":12,"code":"  it('addNode should add a node to the graph', () => {\n    let graph = new AdjacencyList();\n    let id = graph.addNode();\n    assert.equal(id, 0);\n    assert.equal(graph.stats.nodes, 1);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addNode should resize nodes array when necessary","suites":["AdjacencyList"],"updatePoint":{"line":18,"column":54,"index":670},"line":18,"code":"  it('addNode should resize nodes array when necessary', () => {\n    let graph = new AdjacencyList();\n    let size = graph.serialize().nodes.byteLength;\n    let a = graph.addNode();\n    let b = graph.addNode();\n    assert(size < (size = graph.serialize().nodes.byteLength));\n    graph.addEdge(a, b, 1);\n    graph.addEdge(a, b, 2);\n    graph.addEdge(a, b, 3);\n    graph.addEdge(a, b, 4);\n    assert(size < graph.serialize().nodes.byteLength);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"removeEdge should remove an edge from the graph","suites":["AdjacencyList"],"updatePoint":{"line":30,"column":53,"index":1117},"line":30,"code":"  it('removeEdge should remove an edge from the graph', () => {\n    let graph = new AdjacencyList();\n    let node0 = graph.addNode();\n    let node1 = graph.addNode();\n    let node2 = graph.addNode();\n    let node3 = graph.addNode();\n    let node4 = graph.addNode();\n    let node5 = graph.addNode();\n    let node6 = graph.addNode();\n    graph.addEdge(node0, node1);\n    graph.addEdge(node2, node1);\n    // this will get removed\n    graph.addEdge(node3, node1);\n    graph.addEdge(node4, node1);\n    graph.addEdge(node5, node1);\n    graph.addEdge(node6, node1);\n    assert.deepEqual(graph.getNodeIdsConnectedTo(node1), [0, 2, 3, 4, 5, 6]);\n    graph.removeEdge(node3, node1);\n    assert.deepEqual(graph.getNodeIdsConnectedTo(node1), [0, 2, 4, 5, 6]);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"getNodeIdsConnectedTo and getNodeIdsConnectedFrom should remove duplicate values","suites":["AdjacencyList"],"updatePoint":{"line":50,"column":86,"index":1904},"line":50,"code":"  it('getNodeIdsConnectedTo and getNodeIdsConnectedFrom should remove duplicate values', () => {\n    let graph = new AdjacencyList();\n    let a = graph.addNode();\n    let b = graph.addNode();\n    let c = graph.addNode();\n    graph.addEdge(a, b);\n    graph.addEdge(a, c);\n    graph.addEdge(a, b, 2);\n    assert.deepEqual(graph.getNodeIdsConnectedFrom(a, -1), [b, c]);\n    assert.deepEqual(graph.getNodeIdsConnectedTo(b, -1), [a]);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"removeEdge should remove an edge of a specific type from the graph","suites":["AdjacencyList"],"updatePoint":{"line":61,"column":72,"index":2326},"line":61,"code":"  it('removeEdge should remove an edge of a specific type from the graph', () => {\n    let graph = new AdjacencyList();\n    let a = graph.addNode();\n    let b = graph.addNode();\n    let c = graph.addNode();\n    let d = graph.addNode();\n    graph.addEdge(a, b);\n    graph.addEdge(a, b, 2);\n    graph.addEdge(a, b, 3);\n    graph.addEdge(a, c);\n    graph.addEdge(a, d, 3);\n    assert.equal(graph.stats.edges, 5);\n    assert.ok(graph.hasEdge(a, b));\n    assert.ok(graph.hasEdge(a, b, 2));\n    assert.ok(graph.hasEdge(a, b, 3));\n    assert.ok(graph.hasEdge(a, c));\n    assert.ok(graph.hasEdge(a, d, 3));\n    assert.deepEqual(Array.from(graph.getAllEdges()), [{\n      from: a,\n      to: b,\n      type: 1\n    }, {\n      from: a,\n      to: b,\n      type: 2\n    }, {\n      from: a,\n      to: b,\n      type: 3\n    }, {\n      from: a,\n      to: c,\n      type: 1\n    }, {\n      from: a,\n      to: d,\n      type: 3\n    }]);\n    graph.removeEdge(a, b, 2);\n    assert.equal(graph.stats.edges, 4);\n    assert.ok(graph.hasEdge(a, b));\n    assert.equal(graph.hasEdge(a, b, 2), false);\n    assert.ok(graph.hasEdge(a, b, 3));\n    assert.ok(graph.hasEdge(a, c));\n    assert.ok(graph.hasEdge(a, d, 3));\n    assert.deepEqual(Array.from(graph.getAllEdges()), [{\n      from: a,\n      to: b,\n      type: 1\n    }, {\n      from: a,\n      to: b,\n      type: 3\n    }, {\n      from: a,\n      to: c,\n      type: 1\n    }, {\n      from: a,\n      to: d,\n      type: 3\n    }]);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should add an edge to the graph","suites":["AdjacencyList"],"updatePoint":{"line":124,"column":45,"index":3747},"line":124,"code":"  it('addEdge should add an edge to the graph', () => {\n    let graph = new AdjacencyList();\n    let a = graph.addNode();\n    let b = graph.addNode();\n    graph.addEdge(a, b);\n    assert.equal(graph.stats.nodes, 2);\n    assert.equal(graph.stats.edges, 1);\n    assert.ok(graph.hasEdge(a, b));\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should add multiple edges from a node in order","suites":["AdjacencyList"],"updatePoint":{"line":133,"column":60,"index":4060},"line":133,"code":"  it('addEdge should add multiple edges from a node in order', () => {\n    let graph = new AdjacencyList();\n    let a = graph.addNode();\n    let b = graph.addNode();\n    let c = graph.addNode();\n    let d = graph.addNode();\n    graph.addEdge(a, b);\n    graph.addEdge(a, d);\n    graph.addEdge(a, c);\n    assert.deepEqual(graph.getNodeIdsConnectedFrom(a), [b, d, c]);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should add multiple edges to a node in order","suites":["AdjacencyList"],"updatePoint":{"line":144,"column":58,"index":4430},"line":144,"code":"  it('addEdge should add multiple edges to a node in order', () => {\n    let graph = new AdjacencyList();\n    let a = graph.addNode();\n    let b = graph.addNode();\n    let c = graph.addNode();\n    let d = graph.addNode();\n    graph.addEdge(a, b);\n    graph.addEdge(d, b);\n    graph.addEdge(a, d);\n    graph.addEdge(c, b);\n    assert.deepEqual(graph.getNodeIdsConnectedTo(b), [a, d, c]);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should add multiple edges of different types in order","suites":["AdjacencyList"],"updatePoint":{"line":156,"column":67,"index":4832},"line":156,"code":"  it('addEdge should add multiple edges of different types in order', () => {\n    let graph = new AdjacencyList();\n    let a = graph.addNode();\n    let b = graph.addNode();\n    graph.addEdge(a, b);\n    graph.addEdge(a, b, 1);\n    graph.addEdge(a, b, 4);\n    graph.addEdge(a, b, 3);\n    assert.deepEqual(graph.getNodeIdsConnectedFrom(a), [b]);\n    assert.deepEqual(Array.from(graph.getAllEdges()), [{\n      from: a,\n      to: b,\n      type: 1\n    }, {\n      from: a,\n      to: b,\n      type: 4\n    }, {\n      from: a,\n      to: b,\n      type: 3\n    }]);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should return false if an edge is already added","suites":["AdjacencyList"],"updatePoint":{"line":179,"column":61,"index":5385},"line":179,"code":"  it('addEdge should return false if an edge is already added', () => {\n    let graph = new AdjacencyList();\n    let a = graph.addNode();\n    let b = graph.addNode();\n    assert.equal(graph.addEdge(a, b), true);\n    assert.equal(graph.addEdge(a, b), false);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should resize edges array when necessary","suites":["AdjacencyList"],"updatePoint":{"line":186,"column":54,"index":5642},"line":186,"code":"  it('addEdge should resize edges array when necessary', () => {\n    let graph = new AdjacencyList();\n    let size = graph.serialize().edges.byteLength;\n    let a = graph.addNode();\n    let b = graph.addNode();\n    graph.addEdge(a, b, 1);\n    graph.addEdge(a, b, 2);\n    graph.addEdge(a, b, 3);\n    assert(size < graph.serialize().edges.byteLength);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should error when a node has not been added to the graph","suites":["AdjacencyList"],"updatePoint":{"line":196,"column":70,"index":6014},"line":196,"code":"  it('addEdge should error when a node has not been added to the graph', () => {\n    let graph = new AdjacencyList();\n    assert.throws(() => graph.addEdge(toNodeId(0), toNodeId(1)));\n    graph.addNode();\n    assert.throws(() => graph.addEdge(toNodeId(0), toNodeId(1)));\n    graph.addNode();\n    assert.doesNotThrow(() => graph.addEdge(toNodeId(0), toNodeId(1)));\n    assert.throws(() => graph.addEdge(toNodeId(0), toNodeId(2)));\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should error when an unsupported edge type is provided","suites":["AdjacencyList"],"updatePoint":{"line":205,"column":68,"index":6448},"line":205,"code":"  it('addEdge should error when an unsupported edge type is provided', () => {\n    let graph = new AdjacencyList();\n    let a = graph.addNode();\n    let b = graph.addNode();\n    assert.throws(() => graph.addEdge(a, b, 0));\n    assert.throws(() => graph.addEdge(a, b, -1));\n    assert.doesNotThrow(() => graph.addEdge(a, b, 1));\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should not replace a deleted edge if the edge was already added","suites":["AdjacencyList"],"updatePoint":{"line":213,"column":77,"index":6791},"line":213,"code":"  it('addEdge should not replace a deleted edge if the edge was already added', () => {\n    // Mock hash fn to generate collisions\n    // $FlowFixMe[prop-missing]\n    let originalHash = AdjacencyList.prototype.hash;\n    // $FlowFixMe[prop-missing]\n    AdjacencyList.prototype.hash = () => 1;\n    let graph = new AdjacencyList();\n    let n0 = graph.addNode();\n    let n1 = graph.addNode();\n    let n2 = graph.addNode();\n    graph.addEdge(n0, n1, 1);\n    graph.addEdge(n1, n2, 1);\n    graph.removeEdge(n1, n2, 1);\n    assert(graph.addEdge(n0, n1, 1) === false);\n    assert(graph.stats.edges === 1);\n\n    // $FlowFixMe[prop-missing]\n    AdjacencyList.prototype.hash = originalHash;\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should replace a deleted edge","suites":["AdjacencyList"],"updatePoint":{"line":232,"column":43,"index":7442},"line":232,"code":"  it('addEdge should replace a deleted edge', () => {\n    // Mock hash fn to generate collisions\n    // $FlowFixMe[prop-missing]\n    let originalHash = AdjacencyList.prototype.hash;\n    // $FlowFixMe[prop-missing]\n    AdjacencyList.prototype.hash = () => 1;\n    let graph = new AdjacencyList();\n    let n0 = graph.addNode();\n    let n1 = graph.addNode();\n    graph.addEdge(n0, n1, 2);\n    graph.removeEdge(n0, n1, 2);\n    assert(graph.addEdge(n0, n1, 2));\n    assert(graph.stats.edges === 1);\n    assert(graph.stats.deleted === 1);\n    // Resize to reclaim deleted edge space.\n    graph.resizeEdges(4);\n    assert(graph.stats.edges === 1);\n    assert(graph.stats.deleted === 0);\n\n    // $FlowFixMe[prop-missing]\n    AdjacencyList.prototype.hash = originalHash;\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"hasEdge should accept an array of edge types","suites":["AdjacencyList"],"updatePoint":{"line":254,"column":50,"index":8216},"line":254,"code":"  it('hasEdge should accept an array of edge types', () => {\n    let graph = new AdjacencyList();\n    let a = graph.addNode();\n    let b = graph.addNode();\n    let c = graph.addNode();\n    graph.addEdge(a, b, 1);\n    graph.addEdge(b, c, 2);\n    assert.ok(!graph.hasEdge(a, b, [2, 3]));\n    assert.ok(graph.hasEdge(a, b, [1, 2]));\n    assert.ok(!graph.hasEdge(b, c, [1, 3]));\n    assert.ok(graph.hasEdge(b, c, [2, 3]));\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"should share the underlying data across worker threads","suites":["AdjacencyList","deserialize"],"updatePoint":{"line":268,"column":62,"index":8718},"line":268,"code":"    it('should share the underlying data across worker threads', async () => {\n      let graph = new AdjacencyList();\n      let n0 = graph.addNode();\n      let n1 = graph.addNode();\n      graph.addEdge(n0, n1, 1);\n      graph.addEdge(n0, n1, 2);\n      let worker = new Worker(path.join(__dirname, 'integration/adjacency-list-shared-array.js'));\n      let originalSerialized = graph.serialize();\n      let originalNodes = [...originalSerialized.nodes];\n      let originalEdges = [...originalSerialized.edges];\n      let work = new Promise(resolve => worker.on('message', resolve));\n      worker.postMessage(originalSerialized);\n      let received = AdjacencyList.deserialize(await work);\n      await worker.terminate();\n      assert.deepEqual(received.serialize().nodes, graph.serialize().nodes);\n      assert.deepEqual(received.serialize().edges, graph.serialize().edges);\n      originalNodes.forEach((v, i) => {\n        if (i < NodeTypeMap.HEADER_SIZE) {\n          assert.equal(v, received.serialize().nodes[i]);\n          assert.equal(v, graph.serialize().nodes[i]);\n        } else {\n          assert.equal(v * 2, received.serialize().nodes[i]);\n          assert.equal(v * 2, graph.serialize().nodes[i]);\n        }\n      });\n      originalEdges.forEach((v, i) => {\n        if (i < EdgeTypeMap.HEADER_SIZE) {\n          assert.equal(v, received.serialize().edges[i]);\n          assert.equal(v, graph.serialize().edges[i]);\n        } else {\n          assert.equal(v * 2, received.serialize().edges[i]);\n          assert.equal(v * 2, graph.serialize().edges[i]);\n        }\n      });\n    });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"should addNodeByContentKey if no node exists with the content key","suites":["ContentGraph"],"updatePoint":{"line":4,"column":71,"index":182},"line":4,"code":"  it('should addNodeByContentKey if no node exists with the content key', () => {\n    let graph = new ContentGraph();\n    const node = {};\n    const nodeId1 = graph.addNodeByContentKey('contentKey', node);\n    assert.deepEqual(graph.getNode(nodeId1), node);\n    assert(graph.hasContentKey('contentKey'));\n    assert.deepEqual(graph.getNodeByContentKey('contentKey'), node);\n  });","file":"ContentGraph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"should throw if a node with the content key already exists","suites":["ContentGraph"],"updatePoint":{"line":12,"column":64,"index":555},"line":12,"code":"  it('should throw if a node with the content key already exists', () => {\n    let graph = new ContentGraph();\n    graph.addNodeByContentKey('contentKey', {});\n    assert.throws(() => {\n      graph.addNodeByContentKey('contentKey', {});\n    }, /already has content key/);\n  });","file":"ContentGraph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"should remove the content key from graph when node is removed","suites":["ContentGraph"],"updatePoint":{"line":19,"column":67,"index":836},"line":19,"code":"  it('should remove the content key from graph when node is removed', () => {\n    let graph = new ContentGraph();\n    const node1 = {};\n    const nodeId1 = graph.addNodeByContentKey('contentKey', node1);\n    assert.equal(graph.getNode(nodeId1), node1);\n    assert(graph.hasContentKey('contentKey'));\n    graph.removeNode(nodeId1);\n    assert(!graph.hasContentKey('contentKey'));\n  });","file":"ContentGraph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"constructor should initialize an empty graph","suites":["Graph"],"updatePoint":{"line":6,"column":50,"index":208},"line":6,"code":"  it('constructor should initialize an empty graph', () => {\n    let graph = new Graph();\n    assert.deepEqual(graph.nodes, new Map());\n    assert.deepEqual([...graph.getAllEdges()], []);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addNode should add a node to the graph","suites":["Graph"],"updatePoint":{"line":11,"column":44,"index":396},"line":11,"code":"  it('addNode should add a node to the graph', () => {\n    let graph = new Graph();\n    let node = {};\n    let id = graph.addNode(node);\n    assert.equal(graph.nodes.get(id), node);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"errors when traversing a graph with no root","suites":["Graph"],"updatePoint":{"line":17,"column":49,"index":589},"line":17,"code":"  it('errors when traversing a graph with no root', () => {\n    let graph = new Graph();\n    assert.throws(() => {\n      graph.traverse(() => {});\n    }, /A start node is required to traverse/);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"errors when traversing a graph with a startNode that doesn't belong","suites":["Graph"],"updatePoint":{"line":23,"column":73,"index":814},"line":23,"code":"  it(\"errors when traversing a graph with a startNode that doesn't belong\", () => {\n    let graph = new Graph();\n    assert.throws(() => {\n      graph.traverse(() => {}, toNodeId(-1));\n    }, /Does not have node/);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"errors if replaceNodeIdsConnectedTo is called with a node that doesn't belong","suites":["Graph"],"updatePoint":{"line":29,"column":83,"index":1045},"line":29,"code":"  it(\"errors if replaceNodeIdsConnectedTo is called with a node that doesn't belong\", () => {\n    let graph = new Graph();\n    assert.throws(() => {\n      graph.replaceNodeIdsConnectedTo(toNodeId(-1), []);\n    }, /Does not have node/);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"errors when adding an edge to a node that doesn't exist","suites":["Graph"],"updatePoint":{"line":35,"column":61,"index":1265},"line":35,"code":"  it(\"errors when adding an edge to a node that doesn't exist\", () => {\n    let graph = new Graph();\n    let node = graph.addNode({});\n    assert.throws(() => {\n      graph.addEdge(node, toNodeId(-1));\n    }, /\"to\" node '-1' not found/);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"errors when adding an edge from a node that doesn't exist","suites":["Graph"],"updatePoint":{"line":42,"column":63,"index":1511},"line":42,"code":"  it(\"errors when adding an edge from a node that doesn't exist\", () => {\n    let graph = new Graph();\n    let node = graph.addNode({});\n    assert.throws(() => {\n      graph.addEdge(toNodeId(-1), node);\n    }, /\"from\" node '-1' not found/);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"hasNode should return a boolean based on whether the node exists in the graph","suites":["Graph"],"updatePoint":{"line":49,"column":83,"index":1779},"line":49,"code":"  it('hasNode should return a boolean based on whether the node exists in the graph', () => {\n    let graph = new Graph();\n    let node = graph.addNode({});\n    assert(graph.hasNode(node));\n    assert(!graph.hasNode(toNodeId(-1)));\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should add an edge to the graph","suites":["Graph"],"updatePoint":{"line":55,"column":45,"index":1979},"line":55,"code":"  it('addEdge should add an edge to the graph', () => {\n    let graph = new Graph();\n    let nodeA = graph.addNode('a');\n    let nodeB = graph.addNode('b');\n    graph.addEdge(nodeA, nodeB);\n    assert(graph.hasEdge(nodeA, nodeB));\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"isOrphanedNode should return true or false if the node is orphaned or not","suites":["Graph"],"updatePoint":{"line":62,"column":79,"index":2250},"line":62,"code":"  it('isOrphanedNode should return true or false if the node is orphaned or not', () => {\n    let graph = new Graph();\n    let rootNode = graph.addNode('root');\n    graph.setRootNodeId(rootNode);\n    let nodeA = graph.addNode('a');\n    let nodeB = graph.addNode('b');\n    let nodeC = graph.addNode('c');\n    graph.addEdge(rootNode, nodeB);\n    graph.addEdge(nodeB, nodeC, 1);\n    assert(graph.isOrphanedNode(nodeA));\n    assert(!graph.isOrphanedNode(nodeB));\n    assert(!graph.isOrphanedNode(nodeC));\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"removeEdge should throw if the edge doesn't exist","suites":["Graph"],"updatePoint":{"line":75,"column":55,"index":2733},"line":75,"code":"  it(\"removeEdge should throw if the edge doesn't exist\", () => {\n    let graph = new Graph();\n    let nodeA = graph.addNode('a');\n    let nodeB = graph.addNode('b');\n    assert.throws(() => {\n      graph.removeEdge(nodeA, nodeB);\n    }, /Edge from 0 to 1 not found!/);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"removeEdge should prune the graph at that edge","suites":["Graph"],"updatePoint":{"line":83,"column":52,"index":3006},"line":83,"code":"  it('removeEdge should prune the graph at that edge', () => {\n    //         a\n    //        / \\\n    //       b - d\n    //      /\n    //     c\n    let graph = new Graph();\n    let nodeA = graph.addNode('a');\n    graph.setRootNodeId(nodeA);\n    let nodeB = graph.addNode('b');\n    let nodeC = graph.addNode('c');\n    let nodeD = graph.addNode('d');\n    graph.addEdge(nodeA, nodeB);\n    graph.addEdge(nodeA, nodeD);\n    graph.addEdge(nodeB, nodeC);\n    graph.addEdge(nodeB, nodeD);\n    graph.removeEdge(nodeA, nodeB);\n    assert(graph.nodes.has(nodeA));\n    assert(graph.nodes.has(nodeD));\n    assert(!graph.nodes.has(nodeB));\n    assert(!graph.nodes.has(nodeC));\n    assert.deepEqual([...graph.getAllEdges()], [{\n      from: nodeA,\n      to: nodeD,\n      type: 1\n    }]);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"removing a node recursively deletes orphaned nodes","suites":["Graph"],"updatePoint":{"line":110,"column":56,"index":3788},"line":110,"code":"  it('removing a node recursively deletes orphaned nodes', () => {\n    // before:\n    //       a\n    //      / \\\n    //     b   c\n    //    / \\    \\\n    //   d   e    f\n    //  /\n    // g\n    //\n\n    // after:\n    //      a\n    //       \\\n    //        c\n    //         \\\n    //          f\n\n    let graph = new Graph();\n    let nodeA = graph.addNode('a');\n    graph.setRootNodeId(nodeA);\n    let nodeB = graph.addNode('b');\n    let nodeC = graph.addNode('c');\n    let nodeD = graph.addNode('d');\n    let nodeE = graph.addNode('e');\n    let nodeF = graph.addNode('f');\n    let nodeG = graph.addNode('g');\n    graph.addEdge(nodeA, nodeB);\n    graph.addEdge(nodeA, nodeC);\n    graph.addEdge(nodeB, nodeD);\n    graph.addEdge(nodeB, nodeE);\n    graph.addEdge(nodeC, nodeF);\n    graph.addEdge(nodeD, nodeG);\n    graph.removeNode(nodeB);\n    assert.deepEqual([...graph.nodes.keys()], [nodeA, nodeC, nodeF]);\n    assert.deepEqual(Array.from(graph.getAllEdges()), [{\n      from: nodeA,\n      to: nodeC,\n      type: 1\n    }, {\n      from: nodeC,\n      to: nodeF,\n      type: 1\n    }]);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"removing a node recursively deletes orphaned nodes if there is no path to the root","suites":["Graph"],"updatePoint":{"line":155,"column":88,"index":4902},"line":155,"code":"  it('removing a node recursively deletes orphaned nodes if there is no path to the root', () => {\n    // before:\n    //       a\n    //      / \\\n    //     b   c\n    //    / \\    \\\n    // |-d   e    f\n    // |/\n    // g\n    //\n\n    // after:\n    //      a\n    //       \\\n    //        c\n    //         \\\n    //          f\n\n    let graph = new Graph();\n    let nodeA = graph.addNode('a');\n    let nodeB = graph.addNode('b');\n    let nodeC = graph.addNode('c');\n    let nodeD = graph.addNode('d');\n    let nodeE = graph.addNode('e');\n    let nodeF = graph.addNode('f');\n    let nodeG = graph.addNode('g');\n    graph.setRootNodeId(nodeA);\n    graph.addEdge(nodeA, nodeB);\n    graph.addEdge(nodeA, nodeC);\n    graph.addEdge(nodeB, nodeD);\n    graph.addEdge(nodeG, nodeD);\n    graph.addEdge(nodeB, nodeE);\n    graph.addEdge(nodeC, nodeF);\n    graph.addEdge(nodeD, nodeG);\n    graph.removeNode(nodeB);\n    assert.deepEqual([...graph.nodes.keys()], [nodeA, nodeC, nodeF]);\n    assert.deepEqual(Array.from(graph.getAllEdges()), [{\n      from: nodeA,\n      to: nodeC,\n      type: 1\n    }, {\n      from: nodeC,\n      to: nodeF,\n      type: 1\n    }]);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"removing an edge to a node that cycles does not remove it if there is a path to the root","suites":["Graph"],"updatePoint":{"line":201,"column":94,"index":6055},"line":201,"code":"  it('removing an edge to a node that cycles does not remove it if there is a path to the root', () => {\n    //        a\n    //        |\n    //        b <----\n    //       / \\    |\n    //      c   d   |\n    //       \\ /    |\n    //        e -----\n    let graph = new Graph();\n    let nodeA = graph.addNode('a');\n    let nodeB = graph.addNode('b');\n    let nodeC = graph.addNode('c');\n    let nodeD = graph.addNode('d');\n    let nodeE = graph.addNode('e');\n    graph.setRootNodeId(nodeA);\n    graph.addEdge(nodeA, nodeB);\n    graph.addEdge(nodeB, nodeC);\n    graph.addEdge(nodeB, nodeD);\n    graph.addEdge(nodeC, nodeE);\n    graph.addEdge(nodeD, nodeE);\n    graph.addEdge(nodeE, nodeB);\n    const getNodeIds = () => [...graph.nodes.keys()];\n    let nodesBefore = getNodeIds();\n    graph.removeEdge(nodeC, nodeE);\n    assert.deepEqual(nodesBefore, getNodeIds());\n    assert.deepEqual(Array.from(graph.getAllEdges()), [{\n      from: nodeA,\n      to: nodeB,\n      type: 1\n    }, {\n      from: nodeB,\n      to: nodeC,\n      type: 1\n    }, {\n      from: nodeB,\n      to: nodeD,\n      type: 1\n    }, {\n      from: nodeD,\n      to: nodeE,\n      type: 1\n    }, {\n      from: nodeE,\n      to: nodeB,\n      type: 1\n    }]);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"removing a node with only one inbound edge does not cause it to be removed as an orphan","suites":["Graph"],"updatePoint":{"line":248,"column":93,"index":7273},"line":248,"code":"  it('removing a node with only one inbound edge does not cause it to be removed as an orphan', () => {\n    let graph = new Graph();\n    let nodeA = graph.addNode('a');\n    let nodeB = graph.addNode('b');\n    graph.setRootNodeId(nodeA);\n    graph.addEdge(nodeA, nodeB);\n    let spy = sinon.spy(graph, 'removeNode');\n    try {\n      graph.removeNode(nodeB);\n      assert(spy.calledOnceWithExactly(nodeB));\n    } finally {\n      spy.restore();\n    }\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"replaceNodeIdsConnectedTo should update a node's downstream nodes","suites":["Graph"],"updatePoint":{"line":262,"column":71,"index":7705},"line":262,"code":"  it(\"replaceNodeIdsConnectedTo should update a node's downstream nodes\", () => {\n    let graph = new Graph();\n    let nodeA = graph.addNode('a');\n    graph.setRootNodeId(nodeA);\n    let nodeB = graph.addNode('b');\n    let nodeC = graph.addNode('c');\n    graph.addEdge(nodeA, nodeB);\n    graph.addEdge(nodeA, nodeC);\n    let nodeD = graph.addNode('d');\n    graph.replaceNodeIdsConnectedTo(nodeA, [nodeB, nodeD]);\n    assert(graph.hasNode(nodeA));\n    assert(graph.hasNode(nodeB));\n    assert(!graph.hasNode(nodeC));\n    assert(graph.hasNode(nodeD));\n    assert.deepEqual(Array.from(graph.getAllEdges()), [{\n      from: nodeA,\n      to: nodeB,\n      type: 1\n    }, {\n      from: nodeA,\n      to: nodeD,\n      type: 1\n    }]);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"traverses along edge types if a filter is given","suites":["Graph"],"updatePoint":{"line":286,"column":53,"index":8418},"line":286,"code":"  it('traverses along edge types if a filter is given', () => {\n    let graph = new Graph();\n    let nodeA = graph.addNode('a');\n    let nodeB = graph.addNode('b');\n    let nodeC = graph.addNode('c');\n    let nodeD = graph.addNode('d');\n    graph.addEdge(nodeA, nodeB, 2);\n    graph.addEdge(nodeA, nodeD);\n    graph.addEdge(nodeB, nodeC);\n    graph.addEdge(nodeB, nodeD, 2);\n    graph.setRootNodeId(nodeA);\n    let visited = [];\n    graph.traverse(nodeId => {\n      visited.push(nodeId);\n    }, null,\n    // use root as startNode\n    2);\n    assert.deepEqual(visited, [nodeA, nodeB, nodeD]);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"correctly removes non-tree subgraphs","suites":["Graph"],"updatePoint":{"line":305,"column":42,"index":9005},"line":305,"code":"  it('correctly removes non-tree subgraphs', () => {\n    let graph = new Graph();\n    let nodeRoot = graph.addNode('root');\n    let node1 = graph.addNode('1');\n    let node2 = graph.addNode('2');\n    let node3 = graph.addNode('3');\n    graph.addEdge(nodeRoot, node1);\n    graph.addEdge(node1, node2);\n    graph.addEdge(node1, node3);\n    graph.addEdge(node2, node3);\n    graph.setRootNodeId(nodeRoot);\n    graph.removeNode(node1);\n    assert.strictEqual(graph.nodes.size, 1);\n    assert.deepStrictEqual(Array.from(graph.getAllEdges()), []);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"should respect distEntry","suites":["JS API"],"updatePoint":{"line":5,"column":30,"index":197},"line":5,"code":"  it('should respect distEntry', async function () {\n    const NAME = 'custom-name.js';\n    let b = await bundle(path.join(__dirname, '/integration/js-comment/index.js'), {\n      targets: {\n        default: {\n          distDir,\n          distEntry: NAME\n        }\n      }\n    });\n    assertBundles(b, [{\n      name: NAME,\n      type: 'js',\n      assets: ['index.js']\n    }]);\n    assert(await outputFS.exists(path.join(distDir, NAME)));\n  });","file":"api.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should run additional reports from the options","suites":["JS API"],"updatePoint":{"line":22,"column":52,"index":662},"line":22,"code":"  it('should run additional reports from the options', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/js-comment/index.js'), {\n      additionalReporters: [{\n        packageName: '@parcel/reporter-bundle-buddy',\n        resolveFrom: __dirname\n      }]\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.js']\n    }]);\n    assert(await outputFS.exists(path.join(distDir, 'bundle-buddy.json')));\n  });","file":"api.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should auto install @babel/core v7","suites":["babel"],"line":27,"code":"  it.skip('should auto install @babel/core v7', async function () {","file":"babel.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should auto install babel plugins","suites":["babel"],"line":38,"code":"  it.skip('should auto install babel plugins', async function () {","file":"babel.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling with babel using .babelrc config","suites":["babel"],"updatePoint":{"line":50,"column":63,"index":2400},"line":50,"code":"  it('should support compiling with babel using .babelrc config', async function () {\n    await bundle(path.join(__dirname, '/integration/babelrc-custom/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!file.includes('REPLACE_ME'));\n    assert(file.includes('hello there'));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling with babel using babel.config.json config without warnings","suites":["babel"],"updatePoint":{"line":56,"column":89,"index":2762},"line":56,"code":"  it('should support compiling with babel using babel.config.json config without warnings', async function () {\n    let messages = [];\n    let loggerDisposable = Logger.onLog(message => {\n      messages.push(message);\n    });\n    await bundle(path.join(__dirname, '/integration/babel-config-json-custom/index.js'), {\n      logLevel: 'verbose'\n    });\n    loggerDisposable.dispose();\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!file.includes('REPLACE_ME'));\n    assert(file.includes('hello there'));\n    assert.deepEqual(messages, []);\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling with babel using browserslist for different environments","suites":["babel"],"line":70,"code":"  it.skip('should support compiling with babel using browserslist for different environments', async function () {","file":"babel.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should compile node_modules with browserslist to app target","suites":["babel"],"line":95,"code":"  it.skip('should compile node_modules with browserslist to app target', async function () {","file":"babel.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should strip away flow types","suites":["babel"],"updatePoint":{"line":101,"column":34,"index":4990},"line":101,"code":"  it('should strip away flow types', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/babel-strip-flow-types/index.js'));\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 'hello world');\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!file.includes('OptionsType'));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling with babel using babel.config.js config","suites":["babel"],"updatePoint":{"line":109,"column":70,"index":5427},"line":109,"code":"  it('should support compiling with babel using babel.config.js config', async function () {\n    await bundle(path.join(__dirname, '/integration/babel-config-js/src/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!file.includes('REPLACE_ME'));\n    assert(file.match(/return \\d+;/));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling with babel using babel.config.js config with a require in it","suites":["babel"],"updatePoint":{"line":115,"column":91,"index":5793},"line":115,"code":"  it('should support compiling with babel using babel.config.js config with a require in it', async function () {\n    await bundle(path.join(__dirname, '/integration/babel-config-js-require/src/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!file.includes('REPLACE_ME'));\n    assert(file.match(/return \\d+;/));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support multitarget builds using a custom babel config with @parcel/babel-preset-env","suites":["babel"],"updatePoint":{"line":121,"column":97,"index":6173},"line":121,"code":"  it('should support multitarget builds using a custom babel config with @parcel/babel-preset-env', async function () {\n    let fixtureDir = path.join(__dirname, '/integration/babel-config-js-multitarget');\n    await bundle(path.join(fixtureDir, 'src/index.js'));\n    let [modern, legacy] = await Promise.all([outputFS.readFile(path.join(fixtureDir, 'dist/modern/index.js'), 'utf8'), outputFS.readFile(path.join(fixtureDir, 'dist/legacy/index.js'), 'utf8')]);\n    assert(modern.includes('class Foo'));\n    assert(modern.includes('this.x ** 2'));\n    assert(!legacy.includes('class Foo'));\n    assert(!legacy.includes('this.x ** 2'));\n    await outputFS.rimraf(path.join(fixtureDir, 'dist'));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support multitarget builds using a custom babel config with @parcel/babel-plugin-transform-runtime","suites":["babel"],"updatePoint":{"line":131,"column":111,"index":6885},"line":131,"code":"  it('should support multitarget builds using a custom babel config with @parcel/babel-plugin-transform-runtime', async function () {\n    let fixtureDir = path.join(__dirname, '/integration/babel-config-js-multitarget-transform-runtime');\n    await bundle(path.join(fixtureDir, 'src/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    let [main, esmodule] = await Promise.all([outputFS.readFile(path.join(fixtureDir, 'dist/main.js'), 'utf8'), outputFS.readFile(path.join(fixtureDir, 'dist/module.js'), 'utf8')]);\n    assert(main.includes('\"@babel/runtime/helpers/objectSpread2\"'));\n    assert(esmodule.includes('\"@babel/runtime/helpers/esm/objectSpread2\"'));\n    await outputFS.rimraf(path.join(fixtureDir, 'dist'));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support building with custom babel config when running parcel globally","suites":["babel"],"updatePoint":{"line":144,"column":83,"index":7648},"line":144,"code":"  it('should support building with custom babel config when running parcel globally', async function () {\n    let tmpDir = tempy.directory();\n    let distDir = path.join(tmpDir, 'dist');\n    await fs.ncp(path.join(__dirname, '/integration/babelrc-custom'), path.join(tmpDir, '/input'));\n    await bundle(path.join(tmpDir, '/input/index.js'), {\n      targets: {\n        modern: {\n          engines: {\n            node: '^4.0.0'\n          },\n          distDir\n        }\n      },\n      shouldAutoInstall: true\n    });\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!file.includes('REPLACE_ME'));\n    assert(file.includes('hello there'));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support merging .babelrc and babel.config.json in a monorepo","suites":["babel"],"updatePoint":{"line":163,"column":73,"index":8323},"line":163,"code":"  it('should support merging .babelrc and babel.config.json in a monorepo', async function () {\n    await bundle(path.join(__dirname, '/integration/babel-config-monorepo/packages/pkg-a/src/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!file.includes('REPLACE_ME'));\n    assert(file.includes('string from a plugin in babel.config.json'));\n    assert(!file.includes('ANOTHER_THING_TO_REPLACE'));\n    assert(file.includes('string from a plugin in .babelrc'));\n    assert(file.includes('SOMETHING ELSE'));\n    assert(!file.includes('string from a plugin from a different sub-package'));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should prefer BABEL_ENV to NODE_ENV","suites":["babel","Babel envName"],"updatePoint":{"line":174,"column":43,"index":8976},"line":174,"code":"    it('should prefer BABEL_ENV to NODE_ENV', async () => {\n      await bundle(path.join(__dirname, '/integration/babel-env-name/index.js'), {\n        targets: {\n          main: {\n            distDir,\n            engines: {\n              browsers: ['ie 11']\n            }\n          }\n        },\n        env: {\n          BABEL_ENV: 'production',\n          NODE_ENV: 'development'\n        }\n      });\n      let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(!file.includes('class Foo'));\n    });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when BABEL_ENV changes","suites":["babel","Babel envName"],"updatePoint":{"line":192,"column":48,"index":9513},"line":192,"code":"    it('should invalidate when BABEL_ENV changes', async () => {\n      await bundle(path.join(__dirname, '/integration/babel-env-name/index.js'), {\n        targets: {\n          main: {\n            distDir,\n            engines: {}\n          }\n        },\n        shouldDisableCache: false\n      });\n      let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(file.includes('class Foo'));\n      await bundle(path.join(__dirname, '/integration/babel-env-name/index.js'), {\n        shouldDisableCache: false,\n        env: {\n          BABEL_ENV: 'production'\n        }\n      });\n      file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(!file.includes('class Foo'));\n    });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when NODE_ENV changes from BABEL_ENV","suites":["babel","Babel envName"],"updatePoint":{"line":213,"column":62,"index":10264},"line":213,"code":"    it('should invalidate when NODE_ENV changes from BABEL_ENV', async () => {\n      await bundle(path.join(__dirname, '/integration/babel-env-name/index.js'), {\n        targets: {\n          main: {\n            distDir,\n            engines: {}\n          }\n        },\n        shouldDisableCache: false,\n        env: {\n          NODE_ENV: 'production'\n        }\n      });\n      let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(!file.includes('class Foo'));\n      await bundle(path.join(__dirname, '/integration/babel-env-name/index.js'), {\n        targets: {\n          main: {\n            distDir,\n            engines: {}\n          }\n        },\n        shouldDisableCache: false,\n        env: {\n          BABEL_ENV: 'development'\n        }\n      });\n      file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(file.includes('class Foo'));\n    });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should be \"production\" if Parcel is run in production mode","suites":["babel","Babel envName"],"updatePoint":{"line":243,"column":66,"index":11184},"line":243,"code":"    it('should be \"production\" if Parcel is run in production mode', async () => {\n      await bundle(path.join(__dirname, '/integration/babel-env-name/index.js'), {\n        targets: {\n          main: {\n            distDir,\n            engines: {\n              browsers: ['ie 11']\n            }\n          }\n        },\n        mode: 'production'\n      });\n      let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(!file.includes('class Foo'));\n    });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should rebuild when .babelrc changes","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":270,"column":44,"index":11921},"line":270,"code":"    it('should rebuild when .babelrc changes', async function () {\n      if (process.platform !== 'linux') {\n        // This test is flaky outside of Linux. Skip it for now.\n        return;\n      }\n      let inputDir = tempy.directory();\n      let differentPath = path.join(inputDir, 'differentConfig');\n      let configPath = path.join(inputDir, '.babelrc');\n      await fs.ncp(path.join(__dirname, 'integration/babelrc-custom'), inputDir);\n      let b = bundler(path.join(inputDir, 'index.js'), {\n        outputFS: fs,\n        shouldAutoInstall: true\n      });\n      subscription = await b.watch();\n      await getNextBuild(b);\n      let distFile = await fs.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(distFile.includes('hello there'));\n      await fs.copyFile(differentPath, configPath);\n      await new Promise(resolve => setTimeout(resolve, 100));\n      // On Windows only, `fs.utimes` arguments must be instances of `Date`,\n      // otherwise it fails. For Mac instances on Azure CI, using a Date instance\n      // does not update the utime correctly, so for all other platforms, use a\n      // number.\n      // https://github.com/nodejs/node/issues/5561\n      let now = os.platform() === 'win32' ? new Date() : Date.now();\n      // fs.copyFile does not reliably update mtime, which babel uses to invalidate cached file contents\n      await fs.utimes(configPath, now, now);\n      await getNextBuild(b);\n      distFile = await fs.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(!distFile.includes('hello there'));\n      assert(distFile.includes('something different'));\n    });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should rebuild when declared external dependencies change","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":302,"column":65,"index":13559},"line":302,"code":"    it('should rebuild when declared external dependencies change', async function () {\n      let inputDir = tempy.directory();\n      let filepathMain = path.join(inputDir, 'main.txt');\n      let filepathFallback = path.join(inputDir, 'fallback.txt');\n      await fs.ncp(path.join(__dirname, 'integration/babel-external-deps'), inputDir);\n      let b = bundler(path.join(inputDir, 'index.js'), {\n        outputFS: fs,\n        shouldAutoInstall: true\n      });\n      subscription = await b.watch();\n      async function step(f, positive, negative) {\n        if (f != null) {\n          await fs.writeFile(f, positive);\n        }\n        let build = await getNextBuild(b);\n        invariant(build.type === 'buildSuccess');\n        let distFile = await fs.readFile(build.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(distFile.includes(positive));\n        if (negative != null) {\n          assert(!distFile.includes(negative));\n        }\n      }\n      await step(null, 'foo1', null);\n      await step(filepathFallback, 'foo2', 'foo1');\n      await step(filepathMain, 'foo3', 'foo2');\n      await step(filepathMain, 'foo4', 'foo3');\n    });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate babel.config.js across runs","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":329,"column":53,"index":14698},"line":329,"code":"    it('should invalidate babel.config.js across runs', async function () {\n      let dateRe = /return (\\d+);/;\n      let fixtureDir = path.join(__dirname, '/integration/babel-config-js');\n      let distDir = path.resolve(fixtureDir, './dist');\n      let cacheDir = path.resolve(fixtureDir, '.parcel-cache');\n      await fs.rimraf(distDir);\n      await fs.rimraf(cacheDir);\n      await fs.rimraf(path.resolve(fixtureDir, './node_modules/.cache'));\n      let build = () => spawnSync('node', [parcelCli, 'build', 'src/index.js', '--no-optimize', '--no-scope-hoist'], {\n        cwd: fixtureDir,\n        env: {\n          ...process.env,\n          PARCEL_WORKERS: '0'\n        }\n      });\n      build();\n      let file = await fs.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(!file.includes('REPLACE_ME'));\n      let firstMatch = file.match(dateRe);\n      assert(firstMatch != null);\n      let firstDatestamp = firstMatch[1];\n      build();\n      file = await fs.readFile(path.join(distDir, 'index.js'), 'utf8');\n      let secondMatch = file.match(dateRe);\n      assert(secondMatch != null);\n      let secondDatestamp = secondMatch[1];\n      assert.notEqual(firstDatestamp, secondDatestamp);\n    });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when babel plugins are upgraded across runs","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":357,"column":69,"index":15925},"line":357,"code":"    it('should invalidate when babel plugins are upgraded across runs', async function () {\n      let fixtureDir = path.join(__dirname, '/integration/babel-plugin-upgrade');\n      await fs.ncp(path.join(fixtureDir), inputDir);\n      await fs.rimraf(path.join(__dirname, '.parcel-cache'));\n      let build = () => spawnSync('node', [parcelCli, 'build', 'index.js', '--no-optimize', '--no-scope-hoist'], {\n        cwd: inputDir,\n        env: {\n          ...process.env,\n          PARCEL_WORKERS: '0'\n        }\n      });\n      build();\n      let file = await fs.readFile(path.join(inputDir, 'dist', 'index.js'), 'utf8');\n      assert(!file.includes('REPLACE_ME'));\n      assert(file.includes('hello there'));\n      await fs.writeFile(path.join(inputDir, 'node_modules/babel-plugin-dummy/message.js'), 'module.exports = \"something different\"');\n      await fs.writeFile(path.join(inputDir, 'node_modules/babel-plugin-dummy/package.json'), JSON.stringify({\n        name: 'babel-plugin-dummy',\n        version: '1.1.0'\n      }));\n      await fs.writeFile(path.join(inputDir, 'yarn.lock'), '# yarn.lock has been updated');\n      build();\n      file = await fs.readFile(path.join(inputDir, 'dist', 'index.js'), 'utf8');\n      assert(!file.includes('REPLACE_ME'));\n      assert(!file.includes('hello there'));\n      assert(file.includes('something different'));\n    });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should enable shippedProposals with @parcel/babel-preset-env in custom babelrc","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":385,"column":84,"index":17307},"line":385,"code":"  it('should enable shippedProposals with @parcel/babel-preset-env in custom babelrc', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/babel-preset-env-shippedProposals/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!file.includes('#priv'));\n    let output = await run(b);\n    assert.strictEqual(typeof output, 'object');\n    assert.strictEqual(output.default, 123);\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile with custom babel plugin plus default transforms","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":393,"column":69,"index":17750},"line":393,"code":"  it('should compile with custom babel plugin plus default transforms', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/babel-custom/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!file.includes('class Test'));\n    assert(!file.includes('REPLACE_ME'));\n    assert(!file.includes('#private'));\n    let output = await run(b);\n    assert.strictEqual(typeof output, 'object');\n    assert.strictEqual(output.default, 'hello');\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile with custom babel plugin and jsx","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":403,"column":53,"index":18247},"line":403,"code":"  it('should compile with custom babel plugin and jsx', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/babel-custom/jsx.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!file.includes('REPLACE_ME'));\n    assert(file.includes('React.createElement'));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile with custom babel plugin and typescript","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":409,"column":60,"index":18588},"line":409,"code":"  it('should compile with custom babel plugin and typescript', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/babel-custom/ts.ts'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!file.includes('class Test'));\n    assert(!file.includes('REPLACE_ME'));\n    assert(!file.includes('#private'));\n    assert(!file.includes('interface'));\n    let output = await run(b);\n    assert.strictEqual(typeof output, 'object');\n    assert.strictEqual(output.default, 'hello');\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile with custom babel plugin and tsx","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":420,"column":53,"index":19123},"line":420,"code":"  it('should compile with custom babel plugin and tsx', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/babel-custom/tsx.tsx'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!file.includes('REPLACE_ME'));\n    assert(!file.includes('interface'));\n    assert(file.includes('React.createElement'));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should warn when a babel config contains only redundant plugins","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":427,"column":69,"index":19515},"line":427,"code":"  it('should warn when a babel config contains only redundant plugins', async function () {\n    let messages = [];\n    let loggerDisposable = Logger.onLog(message => {\n      messages.push(message);\n    });\n    let filePath = path.join(__dirname, '/integration/babel-warn-all/index.js');\n    await bundle(filePath);\n    loggerDisposable.dispose();\n    let babelrcPath = path.resolve(path.dirname(filePath), '.babelrc');\n    assert.deepEqual(messages, [{\n      type: 'log',\n      level: 'warn',\n      diagnostics: [{\n        origin: '@parcel/transformer-babel',\n        message: md`Parcel includes transpilation by default. Babel config __${path.relative(process.cwd(), babelrcPath)}__ contains only redundant presets. Deleting it may significantly improve build performance.`,\n        codeFrames: [{\n          filePath: babelrcPath,\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 2,\n              column: 15\n            },\n            end: {\n              line: 2,\n              column: 33\n            }\n          }]\n        }],\n        hints: [md`Delete __${path.relative(process.cwd(), babelrcPath)}__`],\n        documentationURL: 'https://parceljs.org/languages/javascript/#default-presets'\n      }, {\n        origin: '@parcel/transformer-babel',\n        message: \"@babel/preset-env does not support Parcel's targets, which will likely result in unnecessary transpilation and larger bundle sizes.\",\n        codeFrames: [{\n          filePath: path.resolve(path.dirname(filePath), '.babelrc'),\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 2,\n              column: 15\n            },\n            end: {\n              line: 2,\n              column: 33\n            }\n          }]\n        }],\n        hints: [\"Either remove __@babel/preset-env__ to use Parcel's builtin transpilation, or replace with __@parcel/babel-preset-env__\"],\n        documentationURL: 'https://parceljs.org/languages/javascript/#custom-plugins'\n      }]\n    }]);\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should warn when a babel config contains redundant plugins","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":480,"column":64,"index":21560},"line":480,"code":"  it('should warn when a babel config contains redundant plugins', async function () {\n    let messages = [];\n    let loggerDisposable = Logger.onLog(message => {\n      messages.push(message);\n    });\n    let filePath = path.join(__dirname, '/integration/babel-warn-some/index.js');\n    await bundle(filePath);\n    loggerDisposable.dispose();\n    let babelrcPath = path.resolve(path.dirname(filePath), '.babelrc');\n    assert.deepEqual(messages, [{\n      type: 'log',\n      level: 'warn',\n      diagnostics: [{\n        origin: '@parcel/transformer-babel',\n        message: md`Parcel includes transpilation by default. Babel config __${path.relative(process.cwd(), babelrcPath)}__ includes the following redundant presets: __@parcel/babel-preset-env__. Removing these may improve build performance.`,\n        codeFrames: [{\n          filePath: babelrcPath,\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 2,\n              column: 15\n            },\n            end: {\n              line: 2,\n              column: 40\n            }\n          }]\n        }],\n        hints: [md`Remove the above presets from __${path.relative(process.cwd(), babelrcPath)}__`],\n        documentationURL: 'https://parceljs.org/languages/javascript/#default-presets'\n      }]\n    }]);\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should warn when a JSON5 babel config contains redundant plugins","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":514,"column":70,"index":22885},"line":514,"code":"  it('should warn when a JSON5 babel config contains redundant plugins', async function () {\n    let messages = [];\n    let loggerDisposable = Logger.onLog(message => {\n      messages.push(message);\n    });\n    let filePath = path.join(__dirname, '/integration/babel-warn-some-json5/index.js');\n    await bundle(filePath);\n    loggerDisposable.dispose();\n    let babelrcPath = path.resolve(path.dirname(filePath), '.babelrc');\n    assert.deepEqual(messages, [{\n      type: 'log',\n      level: 'warn',\n      diagnostics: [{\n        origin: '@parcel/transformer-babel',\n        message: md`Parcel includes transpilation by default. Babel config __${path.relative(process.cwd(), babelrcPath)}__ includes the following redundant presets: __@parcel/babel-preset-env__. Removing these may improve build performance.`,\n        codeFrames: [{\n          filePath: babelrcPath,\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 2,\n              column: 13\n            },\n            end: {\n              line: 2,\n              column: 38\n            }\n          }]\n        }],\n        hints: [md`Remove the above presets from __${path.relative(process.cwd(), babelrcPath)}__`],\n        documentationURL: 'https://parceljs.org/languages/javascript/#default-presets'\n      }]\n    }]);\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline compiled content as a blob url with `blob-url:*` imports","suites":["blob urls"],"updatePoint":{"line":16,"column":76,"index":449},"line":16,"code":"  it('should inline compiled content as a blob url with `blob-url:*` imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/blob-url/index.js'));\n    class Worker {\n      constructor(src) {\n        created.push(src);\n      }\n      postMessage() {}\n    }\n    let created = [];\n    await run(b, {\n      Worker,\n      Blob,\n      URL\n    });\n    assert.equal(created.length, 1);\n    assert(created[0].startsWith('data:application/javascript,'));\n    let bundleContent = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(bundleContent.includes('new Worker(require('));\n    assert(bundleContent.includes('module.exports = URL.createObjectURL(new Blob([\"// modules are defined as an array\\\\n'));\n    assert(bundleContent.includes('self.postMessage(\\\\\"this should appear in the bundle\\\\\\\\n\\\\\")'));\n  });","file":"blob-url.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline minified content as a blob url with `blob-url:*` imports","suites":["blob urls"],"updatePoint":{"line":37,"column":76,"index":1301},"line":37,"code":"  it('should inline minified content as a blob url with `blob-url:*` imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/blob-url/index.js'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    class Worker {\n      constructor(src) {\n        created.push(src);\n      }\n      postMessage() {}\n    }\n    let created = [];\n    await run(b, {\n      Worker,\n      Blob,\n      URL\n    });\n    assert.equal(created.length, 1);\n    assert(created[0].startsWith('data:application/javascript,'));\n    let bundleContent = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(bundleContent.includes('new Worker('));\n    assert(bundleContent.includes(\".exports=URL.createObjectURL(new Blob(['!function(\"));\n    assert(bundleContent.includes('self.postMessage(\"this should appear in the bundle\\\\\\\\n\")'));\n  });","file":"blob-url.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can traverse assets across bundles and contexts","suites":["BundleGraph"],"updatePoint":{"line":5,"column":53,"index":185},"line":5,"code":"  it('can traverse assets across bundles and contexts', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/worker-shared/index.js'));\n    let assets = [];\n    b.traverse(node => {\n      if (node.type === 'asset') {\n        assets.push({\n          type: node.type,\n          value: path.basename(node.value.filePath.replace(/runtime-[0-9a-f]*/g, 'runtime'))\n        });\n      }\n    });\n    assert.deepEqual(assets, [{\n      type: 'asset',\n      value: 'index.js'\n    }, {\n      type: 'asset',\n      value: 'lodash.js'\n    }, {\n      type: 'asset',\n      value: 'worker-a.js'\n    }, {\n      type: 'asset',\n      value: 'lodash.js'\n    }, {\n      type: 'asset',\n      value: 'worker-b.js'\n    }, {\n      type: 'asset',\n      value: 'esmodule-helpers.js'\n    }, {\n      type: 'asset',\n      value: 'runtime.js'\n    }, {\n      type: 'asset',\n      value: 'get-worker-url.js'\n    }, {\n      type: 'asset',\n      value: 'bundle-url.js'\n    }, {\n      type: 'asset',\n      value: 'runtime.js'\n    }, {\n      type: 'asset',\n      value: 'get-worker-url.js'\n    }, {\n      type: 'asset',\n      value: 'bundle-url.js'\n    }, {\n      type: 'asset',\n      value: 'esmodule-helpers.js'\n    }]);\n  });","file":"BundleGraph.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not create a shared bundle from an asset if that asset is shared by less than minBundles bundles","suites":["bundler"],"updatePoint":{"line":5,"column":109,"index":269},"line":5,"code":"  it('should not create a shared bundle from an asset if that asset is shared by less than minBundles bundles', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/min-bundles/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'css-loader.js', 'esmodule-helpers.js', 'js-loader.js', 'bundle-manifest.js']\n    }, {\n      // a and b are shared between only 2 bundles so they are kept in each bundle\n      assets: ['bar.js', 'a.js', 'b.js']\n    }, {\n      assets: ['buzz.js']\n    }, {\n      assets: ['a.js', 'b.js', 'foo.js']\n    }, {\n      // c is shared between 3 different bundles, so it stays\n      assets: ['c.js']\n    }, {\n      assets: ['styles.css']\n    }, {\n      assets: ['local.html']\n    }]);\n  });","file":"bundler.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove reused bundle (over shared bundles based on size) if the bundlegroup hit the parallel request limit","suites":["bundler"],"updatePoint":{"line":31,"column":119,"index":1191},"line":31,"code":"  it('should remove reused bundle (over shared bundles based on size) if the bundlegroup hit the parallel request limit', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/shared-bundle-reused-bundle-remove-reuse/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'css-loader.js', 'esmodule-helpers.js', 'js-loader.js', 'bundle-manifest.js']\n    }, {\n      assets: ['bar.js', 'foo.js', 'a.js', 'b.js']\n    }, {\n      assets: ['buzz.js']\n    }, {\n      assets: ['c.js']\n    }, {\n      assets: ['a.js', 'b.js', 'foo.js']\n    }, {\n      assets: ['styles.css']\n    }, {\n      assets: ['local.html']\n    }]);\n  });","file":"bundler.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove shared bundle (over reused bundles based on size) if the bundlegroup hit the parallel request limit","suites":["bundler"],"updatePoint":{"line":57,"column":119,"index":2106},"line":57,"code":"  it('should remove shared bundle (over reused bundles based on size) if the bundlegroup hit the parallel request limit', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/shared-bundle-reused-bundle-remove-shared/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'css-loader.js', 'esmodule-helpers.js', 'js-loader.js', 'bundle-manifest.js']\n    }, {\n      assets: ['bar.js', 'c.js']\n    }, {\n      // A consequence of our shared bundle 'c'  being removed for the bundleGroup bar\n      // is that it must also be removed for buzz, even though the buzz bundleGroup does not\n      // hit the parallel request limit. This is because the shared bundle is no longer sharing\n      // it is only attached to one bundle and thus should be removed.\n      assets: ['buzz.js', 'c.js']\n    }, {\n      assets: ['a.js', 'b.js', 'foo.js']\n    }, {\n      assets: ['styles.css']\n    }, {\n      assets: ['local.html']\n    }]);\n  });","file":"bundler.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not remove shared bundle from graph if one bundlegroup hits the parallel request limit, and at least 2 other bundleGroups that need it do not","suites":["bundler"],"updatePoint":{"line":83,"column":154,"index":3263},"line":83,"code":"  it('should not remove shared bundle from graph if one bundlegroup hits the parallel request limit, and at least 2 other bundleGroups that need it do not', async function () {\n    //The shared bundle should only be 'put back' for the bundlegroups which hit the parallel request limit\n    // But if there are at least two other bundlegroups using this shared bundle that do not hit the max limit\n    // the shared bundle should not be removed from the graph\n    let b = await bundle(path.join(__dirname, 'integration/shared-bundle-remove-from-one-group-only/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'css-loader.js', 'esmodule-helpers.js', 'js-loader.js', 'bundle-manifest.js']\n    }, {\n      assets: ['bar.js', 'c.js'] // shared bundle merged back\n    }, {\n      assets: ['buzz.js']\n    }, {\n      assets: ['c.js'] // shared bundle\n    }, {\n      assets: ['foo.js']\n    }, {\n      assets: ['styles.css']\n    }, {\n      assets: ['local.html']\n    }]);\n  });","file":"bundler.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not remove shared bundle from graph if its parent (a reused bundle) is removed by parallel request limit","suites":["bundler"],"updatePoint":{"line":110,"column":117,"index":4370},"line":110,"code":"  it('should not remove shared bundle from graph if its parent (a reused bundle) is removed by parallel request limit', async function () {\n    //The shared bundle should only be 'put back' for the bundlegroups which hit the parallel request limit\n    // But if there are at least two other bundlegroups using this shared bundle that do not hit the max limit\n    // the shared bundle should not be removed from the graph\n    let b = await bundle(path.join(__dirname, 'integration/shared-bundle-between-reused-bundle-removal/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'css-loader.js', 'esmodule-helpers.js', 'js-loader.js', 'bundle-manifest.js']\n    }, {\n      assets: ['bar.js', 'foo.js', 'a.js', 'b.js'] // shared bundle merged back\n    }, {\n      assets: ['buzz.js']\n    }, {\n      assets: ['c.js'] // shared bundle\n    }, {\n      assets: ['foo.js', 'a.js', 'b.js']\n    }, {\n      assets: ['styles.css']\n    }, {\n      assets: ['local.html']\n    }]);\n    assert(b.getReferencedBundles(b.getBundlesWithAsset(findAsset(b, 'bar.js'))[0]).includes(b.getBundlesWithAsset(findAsset(b, 'c.js'))[0]));\n  });","file":"bundler.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should split manifest bundle","suites":["bundler"],"updatePoint":{"line":138,"column":34,"index":5574},"line":138,"code":"  it('should split manifest bundle', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/split-manifest-bundle/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['bundle-manifest.js']\n    }, {\n      assets: ['a.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['b.js', 'esmodule-helpers.js']\n    }]);\n  });","file":"bundler.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not split manifest bundle for stable entries","suites":["bundler"],"updatePoint":{"line":158,"column":57,"index":6192},"line":158,"code":"  it('should not split manifest bundle for stable entries', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/split-manifest-bundle/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'bundle-manifest.js']\n    }, {\n      assets: ['a.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['b.js', 'esmodule-helpers.js']\n    }]);\n  });","file":"bundler.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating a JS file","suites":["cache"],"updatePoint":{"line":63,"column":39,"index":2423},"line":63,"code":"  it('should support updating a JS file', async function () {\n    let b = await testCache(async b => {\n      assert.equal(await run(b.bundleGraph), 4);\n      await overlayFS.writeFile(path.join(inputDir, 'src/nested/test.js'), 'export default 4');\n    });\n    assert.equal(await run(b.bundleGraph), 6);\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a dependency","suites":["cache"],"updatePoint":{"line":70,"column":40,"index":2733},"line":70,"code":"  it('should support adding a dependency', async function () {\n    let b = await testCache(async b => {\n      assert.equal(await run(b.bundleGraph), 4);\n      await overlayFS.writeFile(path.join(inputDir, 'src/nested/foo.js'), 'export default 6');\n      await overlayFS.writeFile(path.join(inputDir, 'src/nested/test.js'), 'export {default} from \"./foo\";');\n    });\n    assert.equal(await run(b.bundleGraph), 8);\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a dependency which changes the referenced bundles of a parent bundle","suites":["cache"],"updatePoint":{"line":78,"column":96,"index":3208},"line":78,"code":"  it('should support adding a dependency which changes the referenced bundles of a parent bundle', async function () {\n    async function exec(bundleGraph, bundle) {\n      let calls = [];\n      await runSingleBundle(bundleGraph, nullthrows(bundle), {\n        call(v) {\n          calls.push(v);\n        }\n      });\n      return calls;\n    }\n    let b = await testCache({\n      entries: ['a.html', 'b.html'],\n      mode: 'production',\n      update: async b => {\n        let html = b.bundleGraph.getBundles().filter(b => b.type === 'html');\n        assert.deepEqual(await exec(b.bundleGraph, html[0]), ['a']);\n        assert.deepEqual(await exec(b.bundleGraph, html[1]), ['b']);\n        await overlayFS.writeFile(path.join(inputDir, 'a.js'), 'import \"./c.js\"; call(\"a\");');\n        await overlayFS.writeFile(path.join(inputDir, 'b.js'), 'import \"./c.js\"; call(\"b\");');\n      }\n    }, 'cache-add-dep-referenced');\n    let html = b.bundleGraph.getBundles().filter(b => b.type === 'html');\n    assert.deepEqual(await exec(b.bundleGraph, html[0]), ['c', 'a']);\n    assert.deepEqual(await exec(b.bundleGraph, html[1]), ['c', 'b']);\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when deleting a file","suites":["cache"],"updatePoint":{"line":103,"column":39,"index":4281},"line":103,"code":"  it('should error when deleting a file', async function () {\n    // $FlowFixMe\n    await assert.rejects(async () => {\n      await testCache(async () => {\n        await overlayFS.unlink(path.join(inputDir, 'src/nested/test.js'));\n      });\n    }, {\n      message: \"Failed to resolve './nested/test' from './src/index.js'\"\n    });\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when starting parcel from a broken state with no changes","suites":["cache"],"updatePoint":{"line":113,"column":75,"index":4653},"line":113,"code":"  it('should error when starting parcel from a broken state with no changes', async function () {\n    // $FlowFixMe\n    await assert.rejects(async () => {\n      await testCache(async () => {\n        await overlayFS.unlink(path.join(inputDir, 'src/nested/test.js'));\n      });\n    });\n\n    // Do a third build from a failed state with no changes\n    // $FlowFixMe\n    await assert.rejects(async () => {\n      await runBundle();\n    }, {\n      message: \"Failed to resolve './nested/test' from './src/index.js'\"\n    });\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a ","suites":["cache","babel"],"updatePoint":{"line":180,"column":43,"index":6674},"line":180,"code":"        it(`should support adding a ${name}`, async function () {\n          let b = await testCache({\n            // Babel's config loader only works with the node filesystem\n            inputFS,\n            outputFS: inputFS,\n            async setup() {\n              await inputFS.mkdirp(inputDir);\n              await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n            },\n            async update(b) {\n              assert.equal(await run(b.bundleGraph), 4);\n              let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n              assert(contents.includes('class Test'), 'class should not be transpiled');\n              await inputFS.writeFile(path.join(inputDir, name), formatter({\n                presets: ['@babel/preset-env']\n              }));\n              await sleep(100);\n            }\n          });\n          assert.equal(await run(b.bundleGraph), 4);\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('class Test'), 'class should be transpiled');\n        });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating a ","suites":["cache","babel"],"updatePoint":{"line":203,"column":45,"index":7807},"line":203,"code":"        it(`should support updating a ${name}`, async function () {\n          let b = await testCache({\n            // Babel's config loader only works with the node filesystem\n            inputFS,\n            outputFS: inputFS,\n            async setup() {\n              await inputFS.mkdirp(inputDir);\n              await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n              await inputFS.writeFile(path.join(inputDir, name), formatter({\n                presets: [['@babel/preset-env', {\n                  targets: {\n                    esmodules: true\n                  }\n                }]]\n              }));\n            },\n            async update(b) {\n              let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n              assert(contents.includes('class Test'), 'class should not be transpiled');\n              await inputFS.writeFile(path.join(inputDir, name), formatter({\n                presets: ['@babel/preset-env']\n              }));\n              await sleep(100);\n            }\n          });\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('class Test'), 'class should be transpiled');\n        });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deleting a ","suites":["cache","babel"],"updatePoint":{"line":231,"column":45,"index":9081},"line":231,"code":"        it(`should support deleting a ${name}`, async function () {\n          let b = await testCache({\n            // Babel's config loader only works with the node filesystem\n            inputFS,\n            outputFS: inputFS,\n            async setup() {\n              await inputFS.mkdirp(inputDir);\n              await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n              await inputFS.writeFile(path.join(inputDir, name), formatter({\n                presets: ['@babel/preset-env']\n              }));\n            },\n            async update(b) {\n              let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n              assert(!contents.includes('class Test'), 'class should be transpiled');\n              await inputFS.unlink(path.join(inputDir, name));\n              await sleep(100);\n            }\n          });\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('class Test'), 'class should not be transpiled');\n        });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating an extended ","suites":["cache","babel"],"updatePoint":{"line":253,"column":55,"index":10177},"line":253,"code":"        it(`should support updating an extended ${name}`, async function () {\n          let extendedName = '.babelrc-extended' + path.extname(name);\n          let b = await testCache({\n            // Babel's config loader only works with the node filesystem\n            inputFS,\n            outputFS: inputFS,\n            async setup() {\n              await inputFS.mkdirp(inputDir);\n              await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n              await inputFS.writeFile(path.join(inputDir, extendedName), formatter({\n                presets: [['@babel/preset-env', {\n                  targets: {\n                    esmodules: true\n                  }\n                }]]\n              }));\n              await inputFS.writeFile(path.join(inputDir, name), formatter({\n                extends: `./${extendedName}`\n              }));\n            },\n            async update(b) {\n              let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n              assert(contents.includes('class Test'), 'class should not be transpiled');\n              await inputFS.writeFile(path.join(inputDir, extendedName), formatter({\n                presets: ['@babel/preset-env']\n              }));\n              await sleep(100);\n            }\n          });\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('class Test'), 'class should be transpiled');\n        });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a nested ","suites":["cache","babel"],"updatePoint":{"line":286,"column":52,"index":11709},"line":286,"code":"          it(`should support adding a nested ${name}`, async function () {\n            let b = await testCache({\n              // Babel's config loader only works with the node filesystem\n              inputFS,\n              outputFS: inputFS,\n              async setup() {\n                await inputFS.mkdirp(inputDir);\n                await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n              },\n              async update(b) {\n                assert.equal(await run(b.bundleGraph), 4);\n                let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n                assert(contents.includes('class Test'), 'class should not be transpiled');\n                assert(contents.includes('class Result'), 'class should not be transpiled');\n                await inputFS.writeFile(path.join(inputDir, `src/nested/${name}`), formatter({\n                  presets: ['@babel/preset-env']\n                }));\n                await sleep(100);\n              }\n            });\n            assert.equal(await run(b.bundleGraph), 4);\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(!contents.includes('class Test'), 'class should be transpiled');\n            assert(contents.includes('class Result'), 'class should not be transpiled');\n          });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating a nested ","suites":["cache","babel"],"updatePoint":{"line":311,"column":54,"index":13093},"line":311,"code":"          it(`should support updating a nested ${name}`, async function () {\n            let b = await testCache({\n              // Babel's config loader only works with the node filesystem\n              inputFS,\n              outputFS: inputFS,\n              async setup() {\n                await inputFS.mkdirp(inputDir);\n                await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n                await inputFS.writeFile(path.join(inputDir, `src/nested/${name}`), formatter({\n                  presets: [['@babel/preset-env', {\n                    targets: {\n                      esmodules: true\n                    }\n                  }]]\n                }));\n              },\n              async update(b) {\n                let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n                assert(contents.includes('class Test'), 'class should not be transpiled');\n                assert(contents.includes('class Result'), 'class should not be transpiled');\n                await inputFS.writeFile(path.join(inputDir, `src/nested/${name}`), formatter({\n                  presets: ['@babel/preset-env']\n                }));\n                await sleep(100);\n              }\n            });\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(!contents.includes('class Test'), 'class should be transpiled');\n            assert(contents.includes('class Result'), 'class should not be transpiled');\n          });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deleting a nested ","suites":["cache","babel"],"updatePoint":{"line":341,"column":54,"index":14644},"line":341,"code":"          it(`should support deleting a nested ${name}`, async function () {\n            let b = await testCache({\n              // Babel's config loader only works with the node filesystem\n              inputFS,\n              outputFS: inputFS,\n              async setup() {\n                await inputFS.mkdirp(inputDir);\n                await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n                await inputFS.writeFile(path.join(inputDir, `src/nested/${name}`), formatter({\n                  presets: ['@babel/preset-env']\n                }));\n              },\n              async update(b) {\n                let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n                assert(!contents.includes('class Test'), 'class should be transpiled');\n                assert(contents.includes('class Result'), 'class should not be transpiled');\n                await inputFS.unlink(path.join(inputDir, `src/nested/${name}`));\n                await sleep(100);\n              }\n            });\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(contents.includes('class Test'), 'class should not be transpiled');\n            assert(contents.includes('class Result'), 'class should not be transpiled');\n          });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a .babelignore","suites":["cache","babel",".babelignore"],"updatePoint":{"line":369,"column":46,"index":16056},"line":369,"code":"      it('should support adding a .babelignore', async function () {\n        let b = await testCache({\n          // Babel's config loader only works with the node filesystem\n          inputFS,\n          outputFS: inputFS,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n            await inputFS.writeFile(path.join(inputDir, '.babelrc'), JSON.stringify({\n              presets: ['@babel/preset-env']\n            }));\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(!contents.includes('class Test'), 'class should be transpiled');\n            assert(!contents.includes('class Result'), 'class should be transpiled');\n            await inputFS.writeFile(path.join(inputDir, '.babelignore'), 'src/nested');\n            await sleep(100);\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(contents.includes('class Test'), 'class should not be transpiled');\n        assert(!contents.includes('class Result'), 'class should be transpiled');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating a .babelignore","suites":["cache","babel",".babelignore"],"updatePoint":{"line":393,"column":48,"index":17309},"line":393,"code":"      it('should support updating a .babelignore', async function () {\n        let b = await testCache({\n          // Babel's config loader only works with the node filesystem\n          inputFS,\n          outputFS: inputFS,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n            await inputFS.writeFile(path.join(inputDir, '.babelrc'), JSON.stringify({\n              presets: ['@babel/preset-env']\n            }));\n            await inputFS.writeFile(path.join(inputDir, '.babelignore'), 'src/nested');\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(contents.includes('class Test'), 'class should not be transpiled');\n            assert(!contents.includes('class Result'), 'class should be transpiled');\n            await inputFS.writeFile(path.join(inputDir, '.babelignore'), 'src');\n            await sleep(100);\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(contents.includes('class Test'), 'class should not be transpiled');\n        assert(contents.includes('class Result'), 'class should not be transpiled');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deleting a .babelignore","suites":["cache","babel",".babelignore"],"updatePoint":{"line":418,"column":48,"index":18649},"line":418,"code":"      it('should support deleting a .babelignore', async function () {\n        let b = await testCache({\n          // Babel's config loader only works with the node filesystem\n          inputFS,\n          outputFS: inputFS,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n            await inputFS.writeFile(path.join(inputDir, '.babelrc'), JSON.stringify({\n              presets: ['@babel/preset-env']\n            }));\n            await inputFS.writeFile(path.join(inputDir, '.babelignore'), 'src/nested');\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(contents.includes('class Test'), 'class should not be transpiled');\n            assert(!contents.includes('class Result'), 'class should be transpiled');\n            await inputFS.unlink(path.join(inputDir, '.babelignore'));\n            await sleep(100);\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(!contents.includes('class Test'), 'class should be transpiled');\n        assert(!contents.includes('class Result'), 'class should be transpiled');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when plugins are updated","suites":["cache","babel","plugins"],"updatePoint":{"line":445,"column":52,"index":20023},"line":445,"code":"      it('should invalidate when plugins are updated', async function () {\n        let b = await testCache({\n          // Babel's config loader only works with the node filesystem\n          inputFS,\n          outputFS: inputFS,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n            await inputFS.mkdirp(path.join(inputDir, 'node_modules/babel-plugin-dummy'));\n            await inputFS.writeFile(path.join(inputDir, '/node_modules/babel-plugin-dummy/package.json'), JSON.stringify({\n              name: 'babel-plugin-dummy',\n              version: '1.0.0'\n            }));\n            await inputFS.copyFile(path.join(__dirname, '/integration/babelrc-custom/babel-plugin-dummy.js'), path.join(inputDir, '/node_modules/babel-plugin-dummy/index.js'));\n            await inputFS.writeFile(path.join(inputDir, '.babelrc'), JSON.stringify({\n              plugins: ['babel-plugin-dummy']\n            }));\n            await inputFS.writeFile(path.join(inputDir, 'src/index.js'), 'console.log(\"REPLACE_ME\")');\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(contents.includes('hello there'), 'string should be replaced');\n            let plugin = path.join(inputDir, 'node_modules/babel-plugin-dummy/index.js');\n            let source = await inputFS.readFile(plugin, 'utf8');\n            await inputFS.writeFile(plugin, source.replace('hello there', 'replaced'));\n            await sleep(100);\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(contents.includes('replaced'), 'string should be replaced');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when there are relative plugins","suites":["cache","babel","plugins"],"updatePoint":{"line":476,"column":59,"index":21850},"line":476,"code":"      it('should invalidate when there are relative plugins', async function () {\n        let b = await testCache({\n          // Babel's config loader only works with the node filesystem\n          inputFS,\n          outputFS: inputFS,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n            await inputFS.copyFile(path.join(__dirname, '/integration/babelrc-custom/babel-plugin-dummy.js'), path.join(inputDir, 'babel-plugin-dummy.js'));\n            await inputFS.writeFile(path.join(inputDir, '.babelrc'), JSON.stringify({\n              plugins: ['./babel-plugin-dummy']\n            }));\n            await inputFS.writeFile(path.join(inputDir, 'src/index.js'), 'console.log(\"REPLACE_ME\")');\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(contents.includes('hello there'), 'string should be replaced');\n            let plugin = path.join(inputDir, 'babel-plugin-dummy.js');\n            let source = await inputFS.readFile(plugin, 'utf8');\n            await inputFS.writeFile(plugin, source.replace('hello there', 'replaced'));\n            await sleep(100);\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(contents.includes('replaced'), 'string should be replaced');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when there are symlinked plugins","suites":["cache","babel","plugins"],"updatePoint":{"line":502,"column":60,"index":23338},"line":502,"code":"      it('should invalidate when there are symlinked plugins', async function () {\n        // Symlinks don't work consistently on windows. Skip this test.\n        if (process.platform === 'win32') {\n          this.skip();\n          return;\n        }\n        let b = await testCache({\n          // Babel's config loader only works with the node filesystem\n          inputFS,\n          outputFS: inputFS,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n            await inputFS.mkdirp(path.join(inputDir, 'packages/babel-plugin-dummy'));\n            await inputFS.mkdirp(path.join(inputDir, 'node_modules'));\n            fs.symlinkSync(path.join(inputDir, 'packages/babel-plugin-dummy'), path.join(inputDir, 'node_modules/babel-plugin-dummy'));\n            await inputFS.writeFile(path.join(inputDir, 'packages/babel-plugin-dummy/package.json'), JSON.stringify({\n              name: 'babel-plugin-dummy',\n              version: '1.0.0'\n            }));\n            await inputFS.copyFile(path.join(__dirname, '/integration/babelrc-custom/babel-plugin-dummy.js'), path.join(inputDir, 'packages/babel-plugin-dummy/index.js'));\n            await inputFS.writeFile(path.join(inputDir, '.babelrc'), JSON.stringify({\n              plugins: ['babel-plugin-dummy']\n            }));\n            await inputFS.writeFile(path.join(inputDir, 'src/index.js'), 'console.log(\"REPLACE_ME\")');\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(contents.includes('hello there'), 'string should be replaced');\n            let plugin = path.join(inputDir, 'packages/babel-plugin-dummy/index.js');\n            let source = await inputFS.readFile(plugin, 'utf8');\n            await inputFS.writeFile(plugin, source.replace('hello there', 'replaced'));\n            await sleep(100);\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(contents.includes('replaced'), 'string should be replaced');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a .parcelrc","suites":["cache","parcel config"],"updatePoint":{"line":543,"column":41,"index":25559},"line":543,"code":"    it('should support adding a .parcelrc', async function () {\n      let b = await testCache(async b => {\n        assert.equal(await run(b.bundleGraph), 4);\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(!contents.includes('TRANSFORMED CODE'));\n        await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n          extends: '@parcel/config-default',\n          transformers: {\n            '*.js': ['parcel-transformer-mock']\n          }\n        }));\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('TRANSFORMED CODE'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating a .parcelrc","suites":["cache","parcel config"],"updatePoint":{"line":558,"column":43,"index":26267},"line":558,"code":"    it('should support updating a .parcelrc', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('TRANSFORMED CODE'));\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default'\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('TRANSFORMED CODE'));\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating an extended .parcelrc","suites":["cache","parcel config"],"updatePoint":{"line":580,"column":53,"index":27207},"line":580,"code":"    it('should support updating an extended .parcelrc', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc-extended'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: './.parcelrc-extended'\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('TRANSFORMED CODE'));\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc-extended'), JSON.stringify({\n            extends: '@parcel/config-default'\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('TRANSFORMED CODE'));\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when deleting an extended parcelrc","suites":["cache","parcel config"],"updatePoint":{"line":605,"column":55,"index":28313},"line":605,"code":"    it('should error when deleting an extended parcelrc', async function () {\n      // $FlowFixMe\n      await assert.rejects(async () => {\n        await testCache({\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, '.parcelrc-extended'), JSON.stringify({\n              extends: '@parcel/config-default',\n              transformers: {\n                '*.js': ['parcel-transformer-mock']\n              }\n            }));\n            await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n              extends: './.parcelrc-extended'\n            }));\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(contents.includes('TRANSFORMED CODE'));\n            await overlayFS.unlink(path.join(inputDir, '.parcelrc-extended'));\n          }\n        });\n      }, {\n        message: 'Cannot find extended parcel config'\n      });\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deleting a .parcelrc","suites":["cache","parcel config"],"updatePoint":{"line":630,"column":43,"index":29293},"line":630,"code":"    it('should support deleting a .parcelrc', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('TRANSFORMED CODE'));\n          await overlayFS.unlink(path.join(inputDir, '.parcelrc'));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('TRANSFORMED CODE'));\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when included files changes","suites":["cache","transformations"],"updatePoint":{"line":652,"column":53,"index":30203},"line":652,"code":"    it('should invalidate when included files changes', async function () {\n      let b = await testCache({\n        // TODO: update when the fs transform supports the MemoryFS\n        inputFS,\n        outputFS: inputFS,\n        async setup() {\n          await inputFS.mkdirp(inputDir);\n          await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n          await inputFS.writeFile(path.join(inputDir, 'src/test.txt'), 'hi');\n          await inputFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"fs\").readFileSync(__dirname + \"/test.txt\", \"utf8\")');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 'hi');\n          await inputFS.writeFile(path.join(inputDir, 'src/test.txt'), 'updated');\n          await sleep(100);\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not invalidate when a set environment variable does not change","suites":["cache","transformations"],"updatePoint":{"line":671,"column":77,"index":31115},"line":671,"code":"    it('should not invalidate when a set environment variable does not change', async () => {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.env'), 'TEST=hi');\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = process.env.TEST');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 'hi');\n          await overlayFS.writeFile(path.join(inputDir, '.env'), 'TEST=hi');\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 'hi');\n      assert.equal(b.changedAssets.size, 0);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not invalidate when an environment variable remains unset","suites":["cache","transformations"],"updatePoint":{"line":685,"column":72,"index":31743},"line":685,"code":"    it('should not invalidate when an environment variable remains unset', async () => {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = process.env.TEST');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), undefined);\n        }\n      });\n      assert.equal(await run(b.bundleGraph), undefined);\n      assert.equal(b.changedAssets.size, 0);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when an environment variable becomes set","suites":["cache","transformations"],"updatePoint":{"line":697,"column":66,"index":32221},"line":697,"code":"    it('should invalidate when an environment variable becomes set', async () => {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = process.env.TEST');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), undefined);\n          await overlayFS.writeFile(path.join(inputDir, '.env'), 'TEST=hi');\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 'hi');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when an environment variable becomes unset","suites":["cache","transformations"],"updatePoint":{"line":709,"column":68,"index":32728},"line":709,"code":"    it('should invalidate when an environment variable becomes unset', async () => {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = process.env.TEST');\n          await overlayFS.writeFile(path.join(inputDir, '.env'), 'TEST=hi');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 'hi');\n          await overlayFS.writeFile(path.join(inputDir, '.env'), '');\n        }\n      });\n      assert.equal(await run(b.bundleGraph), undefined);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when environment variables change","suites":["cache","transformations"],"updatePoint":{"line":722,"column":59,"index":33296},"line":722,"code":"    it('should invalidate when environment variables change', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.env'), 'TEST=hi');\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = process.env.TEST');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 'hi');\n          await overlayFS.writeFile(path.join(inputDir, '.env'), 'TEST=updated');\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding an entry that matches a glob","suites":["cache","entries"],"updatePoint":{"line":737,"column":58,"index":33923},"line":737,"code":"    it('should support adding an entry that matches a glob', async function () {\n      let b = await testCache({\n        entries: ['src/entries/*.js'],\n        async update(b) {\n          assertBundles(b.bundleGraph, [{\n            name: 'a.js',\n            assets: ['a.js', 'esmodule-helpers.js']\n          }, {\n            name: 'b.js',\n            assets: ['b.js', 'esmodule-helpers.js']\n          }]);\n          await overlayFS.writeFile(path.join(inputDir, 'src/entries/c.js'), 'export let c = \"c\";');\n        }\n      });\n      assertBundles(b.bundleGraph, [{\n        name: 'a.js',\n        assets: ['a.js', 'esmodule-helpers.js']\n      }, {\n        name: 'b.js',\n        assets: ['b.js', 'esmodule-helpers.js']\n      }, {\n        name: 'c.js',\n        assets: ['c.js', 'esmodule-helpers.js']\n      }]);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deleting an entry that matches a glob","suites":["cache","entries"],"updatePoint":{"line":762,"column":60,"index":34741},"line":762,"code":"    it('should support deleting an entry that matches a glob', async function () {\n      let b = await testCache({\n        entries: ['src/entries/*.js'],\n        async update(b) {\n          assertBundles(b.bundleGraph, [{\n            name: 'a.js',\n            assets: ['a.js', 'esmodule-helpers.js']\n          }, {\n            name: 'b.js',\n            assets: ['b.js', 'esmodule-helpers.js']\n          }]);\n          await overlayFS.unlink(path.join(inputDir, 'src/entries/b.js'));\n        }\n      });\n      assertBundles(b.bundleGraph, [{\n        name: 'a.js',\n        assets: ['a.js', 'esmodule-helpers.js']\n      }]);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when deleting a file entry","suites":["cache","entries"],"updatePoint":{"line":781,"column":47,"index":35358},"line":781,"code":"    it('should error when deleting a file entry', async function () {\n      // $FlowFixMe\n      await assert.rejects(async () => {\n        await testCache(async () => {\n          await overlayFS.unlink(path.join(inputDir, 'src/index.js'));\n        });\n      }, {\n        message: md`Entry ${path.join(inputDir, 'src/index.js')} does not exist`\n      });\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should recover from errors when adding a missing entry","suites":["cache","entries"],"updatePoint":{"line":791,"column":62,"index":35735},"line":791,"code":"    it('should recover from errors when adding a missing entry', async function () {\n      // $FlowFixMe\n      await assert.rejects(async () => {\n        await testCache(async () => {\n          await overlayFS.unlink(path.join(inputDir, 'src/index.js'));\n        });\n      }, {\n        message: md`Entry ${path.join(inputDir, 'src/index.js')} does not exist`\n      });\n      await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = \"hi\"');\n      let b = await runBundle();\n      assert.equal(await run(b.bundleGraph), 'hi');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a target config","suites":["cache","target config"],"updatePoint":{"line":806,"column":45,"index":36323},"line":806,"code":"    it('should support adding a target config', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('export '), 'should not include export');\n          let pkgFile = path.join(inputDir, 'package.json');\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              esmodule: {\n                outputFormat: 'esmodule',\n                isLibrary: true\n              }\n            }\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('export '), 'should include export');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a second target","suites":["cache","target config"],"updatePoint":{"line":830,"column":45,"index":37272},"line":830,"code":"    it('should support adding a second target', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                engines: {\n                  browsers: 'last 1 Chrome version'\n                }\n              }\n            }\n          }));\n        },\n        async update(b) {\n          assertBundles(b.bundleGraph, [{\n            name: 'index.js',\n            assets: ['index.js', 'test.js', 'foo.js']\n          }]);\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                engines: {\n                  browsers: 'last 1 Chrome version'\n                }\n              },\n              legacy: {\n                engines: {\n                  browsers: 'IE 11'\n                }\n              }\n            }\n          }));\n        }\n      });\n      assertBundles(b.bundleGraph, [{\n        name: 'index.js',\n        assets: ['index.js', 'test.js', 'foo.js']\n      }, {\n        name: 'index.js',\n        assets: ['index.js', 'test.js', 'foo.js']\n      }]);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support changing target output location","suites":["cache","target config"],"updatePoint":{"line":880,"column":54,"index":38754},"line":880,"code":"    it('should support changing target output location', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            modern: 'modern/index.js',\n            legacy: 'legacy/index.js',\n            targets: {\n              modern: {\n                engines: {\n                  browsers: 'last 1 Chrome version'\n                }\n              },\n              legacy: {\n                engines: {\n                  browsers: 'IE 11'\n                }\n              }\n            }\n          }));\n        },\n        async update() {\n          assert(await overlayFS.exists(path.join(inputDir, 'modern/index.js')));\n          assert(await overlayFS.exists(path.join(inputDir, 'legacy/index.js')));\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            modern: 'dist/modern/index.js',\n            legacy: 'dist/legacy/index.js',\n            targets: {\n              modern: {\n                engines: {\n                  browsers: 'last 1 Chrome version'\n                }\n              },\n              legacy: {\n                engines: {\n                  browsers: 'IE 11'\n                }\n              }\n            }\n          }));\n        }\n      });\n      assert(await overlayFS.exists(path.join(inputDir, 'dist/modern/index.js')));\n      assert(await overlayFS.exists(path.join(inputDir, 'dist/legacy/index.js')));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating target config options","suites":["cache","target config"],"updatePoint":{"line":932,"column":53,"index":40491},"line":932,"code":"    it('should support updating target config options', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              esmodule: {\n                outputFormat: 'esmodule',\n                isLibrary: true\n              }\n            }\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('export '), 'should include export');\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              esmodule: {\n                outputFormat: 'commonjs'\n              }\n            }\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('module.exports ='), 'should include module.exports =');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deleting a target","suites":["cache","target config"],"updatePoint":{"line":967,"column":40,"index":41764},"line":967,"code":"    it('should support deleting a target', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                engines: {\n                  browsers: 'last 1 Chrome version'\n                }\n              },\n              legacy: {\n                engines: {\n                  browsers: 'IE 11'\n                }\n              }\n            }\n          }));\n        },\n        async update(b) {\n          assertBundles(b.bundleGraph, [{\n            name: 'index.js',\n            assets: ['index.js', 'test.js', 'foo.js']\n          }, {\n            name: 'index.js',\n            assets: ['index.js', 'test.js', 'foo.js']\n          }]);\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                engines: {\n                  browsers: 'last 1 Chrome version'\n                }\n              }\n            }\n          }));\n        }\n      });\n      assertBundles(b.bundleGraph, [{\n        name: 'index.js',\n        assets: ['index.js', 'test.js', 'foo.js']\n      }]);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deleting all targets","suites":["cache","target config"],"updatePoint":{"line":1017,"column":43,"index":43247},"line":1017,"code":"    it('should support deleting all targets', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                outputFormat: 'esmodule',\n                isLibrary: true\n              },\n              legacy: {\n                outputFormat: 'commonjs'\n              }\n            }\n          }));\n        },\n        async update(b) {\n          assertBundles(b.bundleGraph, [{\n            name: 'index.js',\n            assets: ['index.js', 'test.js', 'foo.js']\n          }, {\n            name: 'index.js',\n            assets: ['index.js', 'test.js', 'foo.js']\n          }]);\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('export '), 'should include export');\n          contents = await overlayFS.readFile(b.bundleGraph.getBundles()[1].filePath, 'utf8');\n          assert(contents.includes('module.exports ='), 'should include module.exports');\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: undefined\n          }));\n        }\n      });\n      assertBundles(b.bundleGraph, [{\n        name: 'index.js',\n        assets: ['index.js', 'test.js', 'foo.js']\n      }]);\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('export '), 'should not include export');\n      assert(!contents.includes('module.exports ='), 'should not include module.exports');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when sourcemap options change","suites":["cache","target config"],"updatePoint":{"line":1065,"column":51,"index":45149},"line":1065,"code":"    it('should update when sourcemap options change', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                sourceMap: true\n              }\n            }\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('sourceMappingURL=index.js.map'), 'should include sourceMappingURL');\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                sourceMap: {\n                  inline: true\n                }\n              }\n            }\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('sourceMappingURL=data:application/json'), 'should include inline sourceMappingURL');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when publicUrl changes","suites":["cache","target config"],"updatePoint":{"line":1101,"column":44,"index":46478},"line":1101,"code":"    it('should update when publicUrl changes', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      let b = await testCache({\n        entries: ['src/index.html'],\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                publicUrl: 'http://example.com/'\n              }\n            }\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('<script type=\"module\" src=\"http://example.com'), 'should include example.com');\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                publicUrl: 'http://mygreatwebsite.com/'\n              }\n            }\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('<script type=\"module\" src=\"http://mygreatwebsite.com'), 'should include example.com');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when a package.json is created","suites":["cache","target config"],"updatePoint":{"line":1136,"column":52,"index":47860},"line":1136,"code":"    it('should update when a package.json is created', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      let pkg;\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.unlink(pkgFile);\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('export '), 'does not include export');\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                outputFormat: 'esmodule',\n                isLibrary: true\n              }\n            }\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('export '), 'should include export');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when a package.json is deleted","suites":["cache","target config"],"updatePoint":{"line":1164,"column":52,"index":48897},"line":1164,"code":"    it('should update when a package.json is deleted', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                outputFormat: 'esmodule',\n                isLibrary: true\n              }\n            }\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('export '), 'should include export');\n          await overlayFS.unlink(pkgFile);\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('export '), 'does not include export');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when a browserslist file is added","suites":["cache","target config","browserslist"],"updatePoint":{"line":1192,"column":57,"index":49971},"line":1192,"code":"      it('should update when a browserslist file is added', async function () {\n        let b = await testCache({\n          defaultTargetOptions: {\n            shouldScopeHoist: true\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should include class');\n            await overlayFS.writeFile(path.join(inputDir, 'browserslist'), 'IE >= 11');\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(!/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'does not include class');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when a .browserslistrc file is added","suites":["cache","target config","browserslist"],"updatePoint":{"line":1206,"column":60,"index":50699},"line":1206,"code":"      it('should update when a .browserslistrc file is added', async function () {\n        let b = await testCache({\n          defaultTargetOptions: {\n            shouldScopeHoist: true\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should include class');\n            await overlayFS.writeFile(path.join(inputDir, '.browserslistrc'), 'IE >= 11');\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(!/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'does not include class');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when a browserslist is updated","suites":["cache","target config","browserslist"],"updatePoint":{"line":1220,"column":54,"index":51424},"line":1220,"code":"      it('should update when a browserslist is updated', async function () {\n        let b = await testCache({\n          defaultTargetOptions: {\n            shouldScopeHoist: true\n          },\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, 'browserslist'), 'IE >= 11');\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(!/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'does not include class');\n            await overlayFS.writeFile(path.join(inputDir, 'browserslist'), 'last 1 Chrome version');\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should include class');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when a browserslist is deleted","suites":["cache","target config","browserslist"],"updatePoint":{"line":1237,"column":54,"index":52286},"line":1237,"code":"      it('should update when a browserslist is deleted', async function () {\n        let b = await testCache({\n          defaultTargetOptions: {\n            shouldScopeHoist: true\n          },\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, 'browserslist'), 'IE >= 11');\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(!/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'does not include class');\n            await overlayFS.unlink(path.join(inputDir, 'browserslist'));\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should include class');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when BROWSERSLIST_ENV changes","suites":["cache","target config","browserslist"],"updatePoint":{"line":1254,"column":53,"index":53119},"line":1254,"code":"      it('should update when BROWSERSLIST_ENV changes', async function () {\n        let b = await testCache({\n          defaultTargetOptions: {\n            shouldScopeHoist: true\n          },\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, 'browserslist'), `\n            [production]\n            IE >= 11\n\n            [development]\n            last 1 Chrome version\n            `);\n            process.env.BROWSERSLIST_ENV = 'production';\n          },\n          async update(b) {\n            // \"production\" is the default environment for browserslist\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(!/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'does not include class');\n            process.env.BROWSERSLIST_ENV = 'development';\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should include class');\n        delete process.env.BROWSERSLIST_ENV;\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when NODE_ENV changes","suites":["cache","target config","browserslist"],"updatePoint":{"line":1280,"column":45,"index":54215},"line":1280,"code":"      it('should update when NODE_ENV changes', async function () {\n        let env = process.env.NODE_ENV;\n        let b = await testCache({\n          defaultTargetOptions: {\n            shouldScopeHoist: true\n          },\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, 'browserslist'), `\n            [production]\n            IE >= 11\n\n            [development]\n            last 1 Chrome version\n            `);\n            process.env.NODE_ENV = 'production';\n          },\n          async update(b) {\n            // \"production\" is the default environment for browserslist\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(!/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'does not include class');\n            process.env.NODE_ENV = 'development';\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should include class');\n        process.env.NODE_ENV = env;\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when publicUrl changes","suites":["cache","options"],"updatePoint":{"line":1310,"column":44,"index":55375},"line":1310,"code":"    it('should update when publicUrl changes', async function () {\n      let b = await testCache({\n        entries: ['src/index.html'],\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          publicUrl: 'http://example.com/'\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('<script type=\"module\" src=\"http://example.com'), 'should include example.com');\n          return {\n            defaultTargetOptions: {\n              publicUrl: 'http://mygreatwebsite.com/'\n            }\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('<script type=\"module\" src=\"http://mygreatwebsite.com'), 'should include example.com');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when minify changes","suites":["cache","options"],"updatePoint":{"line":1330,"column":41,"index":56247},"line":1330,"code":"    it('should update when minify changes', async function () {\n      let b = await testCache({\n        entries: ['src/index.html'],\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          shouldOptimize: false\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[1].filePath, 'utf8');\n          assert(contents.includes('Test'), 'should include Test');\n          return {\n            defaultTargetOptions: {\n              shouldScopeHoist: true,\n              shouldOptimize: true\n            }\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[1].filePath, 'utf8');\n      assert(!contents.includes('Test'), 'should not include Test');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when scopeHoist changes","suites":["cache","options"],"updatePoint":{"line":1351,"column":45,"index":57033},"line":1351,"code":"    it('should update when scopeHoist changes', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: false\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('parcelRequire'), 'should include parcelRequire');\n          return {\n            defaultTargetOptions: {\n              shouldScopeHoist: true\n            }\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('parcelRequire'), 'should not include Test');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when sourceMaps changes","suites":["cache","options"],"updatePoint":{"line":1369,"column":45,"index":57741},"line":1369,"code":"    it('should update when sourceMaps changes', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          sourceMaps: false\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('sourceMappingURL=index.js.map'), 'should not include sourceMappingURL');\n          return {\n            defaultTargetOptions: {\n              sourceMaps: true\n            }\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('sourceMappingURL=index.js.map'), 'should include sourceMappingURL');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when distDir changes","suites":["cache","options"],"updatePoint":{"line":1387,"column":42,"index":58481},"line":1387,"code":"    it('should update when distDir changes', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        update(b) {\n          assert(/dist[/\\\\]index.js$/.test(b.bundleGraph.getBundles()[0].filePath), 'should end with dist/index.js');\n          return {\n            defaultTargetOptions: {\n              distDir: path.join(__dirname, 'integration/cache/dist/test')\n            }\n          };\n        }\n      });\n      assert(/dist[/\\\\]test[/\\\\]index.js$/.test(b.bundleGraph.getBundles()[0].filePath), 'should end with dist/test/index.js');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when targets changes","suites":["cache","options"],"updatePoint":{"line":1403,"column":42,"index":59105},"line":1403,"code":"    it('should update when targets changes', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        targets: ['legacy'],\n        async setup() {\n          let pkgFile = path.join(inputDir, 'package.json');\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                engines: {\n                  browsers: 'last 1 Chrome version'\n                }\n              },\n              legacy: {\n                engines: {\n                  browsers: 'IE 11'\n                }\n              }\n            }\n          }));\n        },\n        async update(b) {\n          assertBundles(b.bundleGraph, [{\n            name: 'index.js',\n            assets: ['index.js', 'test.js', 'foo.js']\n          }]);\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should not include class');\n          return {\n            targets: ['modern']\n          };\n        }\n      });\n      assertBundles(b.bundleGraph, [{\n        name: 'index.js',\n        assets: ['index.js', 'test.js', 'foo.js']\n      }]);\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should include class');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when defaultEngines changes","suites":["cache","options"],"updatePoint":{"line":1447,"column":49,"index":60627},"line":1447,"code":"    it('should update when defaultEngines changes', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          engines: {\n            browsers: 'last 1 Chrome version'\n          }\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should include class');\n          return {\n            defaultTargetOptions: {\n              shouldScopeHoist: true,\n              engines: {\n                browsers: 'IE 11'\n              }\n            }\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should not include class');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when shouldContentHash changes","suites":["cache","options"],"updatePoint":{"line":1471,"column":52,"index":61512},"line":1471,"code":"    it('should update when shouldContentHash changes', async function () {\n      let b = await testCache({\n        entries: ['src/index.html'],\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        shouldContentHash: true,\n        update(b) {\n          let bundle = b.bundleGraph.getBundles()[1];\n          assert(!bundle.filePath.includes(bundle.id.slice(-8)));\n          return {\n            shouldContentHash: false\n          };\n        }\n      });\n      let bundle = b.bundleGraph.getBundles()[1];\n      assert(bundle.filePath.includes(bundle.id.slice(-8)));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when hmr options change","suites":["cache","options"],"updatePoint":{"line":1489,"column":45,"index":62106},"line":1489,"code":"    it('should update when hmr options change', async function () {\n      let b = await testCache({\n        hmrOptions: {\n          host: 'localhost',\n          port: 4321\n        },\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              // Remove react-refresh transformer so we test whether the runtime updates\n              '*.js': ['@parcel/transformer-js']\n            }\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('HMR_HOST = \"localhost\"'), 'should include HMR_HOST = \"localhost\"');\n          assert(contents.includes('HMR_PORT = 4321'), 'should include HMR_PORT = 4321');\n          return {\n            hmrOptions: {\n              host: 'example.com',\n              port: 5678\n            }\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('HMR_HOST = \"example.com\"'), 'should include HMR_HOST = \"example.com\"');\n      assert(contents.includes('HMR_PORT = 5678'), 'should include HMR_PORT = 5678');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate react refresh hot options change","suites":["cache","options"],"updatePoint":{"line":1520,"column":58,"index":63430},"line":1520,"code":"    it('should invalidate react refresh hot options change', async function () {\n      let b = await testCache({\n        async setup() {\n          let pkgFile = path.join(inputDir, 'package.json');\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            dependencies: {\n              react: '*'\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), `import React from 'react';\n\n            export function Component() {\n              return <h1>Hello world</h1>;\n            }`);\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('getRefreshBoundarySignature'), 'should not include getRefreshBoundarySignature');\n          return {\n            hmrOptions: {\n              host: 'example.com',\n              port: 5678\n            }\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('getRefreshBoundarySignature'), 'should include getRefreshBoundarySignature');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when the config option changes","suites":["cache","options"],"updatePoint":{"line":1551,"column":52,"index":64677},"line":1551,"code":"    it('should update when the config option changes', async function () {\n      let b = await testCache({\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('TRANSFORMED CODE'));\n          await overlayFS.writeFile(path.join(inputDir, 'some-config'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n          return {\n            config: path.join(inputDir, 'some-config')\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('TRANSFORMED CODE'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when the defaultConfig option changes","suites":["cache","options"],"updatePoint":{"line":1570,"column":59,"index":65480},"line":1570,"code":"    it('should update when the defaultConfig option changes', async function () {\n      let b = await testCache({\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('TRANSFORMED CODE'));\n          await overlayFS.writeFile(path.join(inputDir, 'some-config'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n          return {\n            defaultConfig: path.join(inputDir, 'some-config')\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('TRANSFORMED CODE'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update env browserslist in package.json when mode changes","suites":["cache","options"],"updatePoint":{"line":1589,"column":72,"index":66303},"line":1589,"code":"    it('should update env browserslist in package.json when mode changes', async function () {\n      let env = process.env.NODE_ENV;\n      delete process.env.NODE_ENV;\n      try {\n        let b = await testCache({\n          defaultTargetOptions: {\n            shouldScopeHoist: false,\n            shouldOptimize: false\n          },\n          mode: 'development',\n          async setup() {\n            let pkg = JSON.parse(await overlayFS.readFile(path.join(inputDir, 'package.json'), 'utf8'));\n            pkg.browserslist = {\n              production: ['ie 11'],\n              development: ['Chrome 80']\n            };\n            await overlayFS.writeFile(path.join(inputDir, 'package.json'), JSON.stringify(pkg, null, 2));\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(/class Test/.test(contents), 'should include class');\n            return {\n              mode: 'production'\n            };\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(!/class Test/.test(contents), 'does not include class');\n      } finally {\n        process.env.NODE_ENV = env;\n      }\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating a package.json#main field","suites":["cache","resolver"],"updatePoint":{"line":1623,"column":57,"index":67604},"line":1623,"code":"    it('should support updating a package.json#main field', async function () {\n      let b = await testCache(async b => {\n        assert.equal(await run(b.bundleGraph), 4);\n        await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/test.js'), 'module.exports = 4;');\n        await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/package.json'), JSON.stringify({\n          main: 'test.js'\n        }));\n      });\n      assert.equal(await run(b.bundleGraph), 8);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding an alias","suites":["cache","resolver"],"updatePoint":{"line":1633,"column":38,"index":68077},"line":1633,"code":"    it('should support adding an alias', async function () {\n      let b = await testCache(async b => {\n        assert.equal(await run(b.bundleGraph), 4);\n        await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/test.js'), 'module.exports = 4;');\n        await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/package.json'), JSON.stringify({\n          main: 'foo.js',\n          alias: {\n            './foo.js': './test.js'\n          }\n        }));\n      });\n      assert.equal(await run(b.bundleGraph), 8);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating an alias","suites":["cache","resolver"],"updatePoint":{"line":1646,"column":40,"index":68619},"line":1646,"code":"    it('should support updating an alias', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/test.js'), 'module.exports = 4;');\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/package.json'), JSON.stringify({\n            main: 'foo.js',\n            alias: {\n              './foo.js': './test.js'\n            }\n          }));\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 8);\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/baz.js'), 'module.exports = 6;');\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/package.json'), JSON.stringify({\n            main: 'foo.js',\n            alias: {\n              './foo.js': './baz.js'\n            }\n          }));\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 12);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deleting an alias","suites":["cache","resolver"],"updatePoint":{"line":1670,"column":40,"index":69568},"line":1670,"code":"    it('should support deleting an alias', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/test.js'), 'module.exports = 4;');\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/package.json'), JSON.stringify({\n            main: 'foo.js',\n            alias: {\n              './foo.js': './test.js'\n            }\n          }));\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 8);\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/package.json'), JSON.stringify({\n            main: 'foo.js'\n          }));\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding an alias in a closer package.json","suites":["cache","resolver"],"updatePoint":{"line":1690,"column":63,"index":70358},"line":1690,"code":"    it('should support adding an alias in a closer package.json', async function () {\n      let b = await testCache(async b => {\n        assert.equal(await run(b.bundleGraph), 4);\n        await overlayFS.writeFile(path.join(inputDir, 'src/nested/foo.js'), 'module.exports = 4;');\n        await overlayFS.writeFile(path.join(inputDir, 'src/nested/package.json'), JSON.stringify({\n          alias: {\n            './test.js': './foo.js'\n          }\n        }));\n      });\n      assert.equal(await run(b.bundleGraph), 6);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a file with a higher priority extension","suites":["cache","resolver"],"updatePoint":{"line":1702,"column":69,"index":70890},"line":1702,"code":"    it('should support adding a file with a higher priority extension', async function () {\n      let b = await testCache({\n        async setup() {\n          // Start out pointing to a .ts file from a .js file\n          let contents = await overlayFS.readFile(path.join(inputDir, 'src/index.js'), 'utf8');\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), contents.replace('nested/test', 'nested/foo'));\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/foo.ts'), 'module.exports = 4;');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 6);\n\n          // Adding a .js file should be higher priority\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/foo.js'), 'module.exports = 2;');\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support renaming a file to a different extension","suites":["cache","resolver"],"updatePoint":{"line":1719,"column":63,"index":71740},"line":1719,"code":"    it('should support renaming a file to a different extension', async function () {\n      let b = await testCache({\n        async setup() {\n          // Start out pointing to a .js file\n          let contents = await overlayFS.readFile(path.join(inputDir, 'src/index.js'), 'utf8');\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), contents.replace('nested/test', 'nested/foo'));\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/foo.js'), 'module.exports = 4;');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 6);\n\n          // Rename to .ts\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/foo.ts'), 'module.exports = 2;');\n          await overlayFS.unlink(path.join(inputDir, 'src/nested/foo.js'));\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve to a file over a directory with an index.js","suites":["cache","resolver"],"updatePoint":{"line":1737,"column":66,"index":72623},"line":1737,"code":"    it('should resolve to a file over a directory with an index.js', async function () {\n      let b = await testCache({\n        async setup() {\n          let contents = await overlayFS.readFile(path.join(inputDir, 'src/index.js'), 'utf8');\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), contents.replace('nested/test', 'nested'));\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/index.js'), 'module.exports = 4;');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 6);\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested.js'), 'module.exports = 2;');\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve to package.json#main over an index.js","suites":["cache","resolver"],"updatePoint":{"line":1751,"column":60,"index":73344},"line":1751,"code":"    it('should resolve to package.json#main over an index.js', async function () {\n      let b = await testCache({\n        async setup() {\n          let contents = await overlayFS.readFile(path.join(inputDir, 'src/index.js'), 'utf8');\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), contents.replace('nested/test', 'nested'));\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/index.js'), 'module.exports = 4;');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 6);\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/package.json'), JSON.stringify({\n            main: 'test.js'\n          }));\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should recover from errors when adding a missing dependency","suites":["cache","resolver"],"updatePoint":{"line":1767,"column":67,"index":74118},"line":1767,"code":"    it('should recover from errors when adding a missing dependency', async function () {\n      // $FlowFixMe\n      await assert.rejects(async () => {\n        await testCache({\n          async setup() {\n            await overlayFS.unlink(path.join(inputDir, 'src/nested/test.js'));\n          },\n          async update() {}\n        });\n      }, {\n        message: \"Failed to resolve './nested/test' from './src/index.js'\"\n      });\n      await overlayFS.writeFile(path.join(inputDir, 'src/nested/test.js'), 'module.exports = 4;');\n      let b = await runBundle();\n      assert.equal(await run(b.bundleGraph), 6);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should recover from a missing package.json#main","suites":["cache","resolver"],"updatePoint":{"line":1783,"column":55,"index":74726},"line":1783,"code":"    it('should recover from a missing package.json#main', async function () {\n      let b = await testCache({\n        async setup() {\n          let contents = await overlayFS.readFile(path.join(inputDir, 'src/index.js'), 'utf8');\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), contents.replace('nested/test', 'nested'));\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/package.json'), JSON.stringify({\n            main: 'tmp.js'\n          }));\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/index.js'), 'module.exports = 4;');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 6);\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/tmp.js'), 'module.exports = 8;');\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 10);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should recover from an invalid package.json","suites":["cache","resolver"],"updatePoint":{"line":1800,"column":51,"index":75586},"line":1800,"code":"    it('should recover from an invalid package.json', async function () {\n      // $FlowFixMe\n      await assert.rejects(async () => {\n        await testCache({\n          async setup() {\n            let contents = await overlayFS.readFile(path.join(inputDir, 'src/index.js'), 'utf8');\n            await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), contents.replace('nested/test', 'nested'));\n            await overlayFS.writeFile(path.join(inputDir, 'src/nested/package.json'), 'invalid');\n            await overlayFS.writeFile(path.join(inputDir, 'src/nested/index.js'), 'module.exports = 10;');\n          },\n          async update() {}\n        });\n      });\n      await overlayFS.writeFile(path.join(inputDir, 'src/nested/package.json'), JSON.stringify({\n        main: 'test.js'\n      }));\n      let b = await runBundle();\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a deeper node_modules folder","suites":["cache","resolver"],"updatePoint":{"line":1819,"column":58,"index":76487},"line":1819,"code":"    it('should support adding a deeper node_modules folder', async function () {\n      let b = await testCache({\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 4);\n          await overlayFS.mkdirp(path.join(inputDir, 'src/nested/node_modules/foo'));\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/node_modules/foo/index.js'), 'module.exports = 4;');\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 6);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when switching to a different resolver plugin","suites":["cache","resolver"],"updatePoint":{"line":1829,"column":71,"index":76976},"line":1829,"code":"    it('should invalidate when switching to a different resolver plugin', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), `import \"foo\";`);\n          await overlayFS.writeFile(path.join(inputDir, 'src/foo.js'), `export default \"FOO\";`);\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!res.includes('FOO'));\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            resolvers: ['parcel-resolver-test']\n          }));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(res.includes('FOO'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a resolver is updated","suites":["cache","resolver"],"updatePoint":{"line":1850,"column":52,"index":77892},"line":1850,"code":"    it('should invalidate when a resolver is updated', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), `import \"foo\";`);\n          await overlayFS.writeFile(path.join(inputDir, 'src/foo.js'), `export default \"FOO\";`);\n          await overlayFS.writeFile(path.join(inputDir, 'src/foo.ts'), `export default \"BAR\";`);\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            resolvers: ['parcel-resolver-test']\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(res.includes('FOO'));\n          assert(!res.includes('BAR'));\n          let resolver = path.join(inputDir, 'node_modules', 'parcel-resolver-test', 'index.js');\n          await overlayFS.writeFile(resolver, (await overlayFS.readFile(resolver, 'utf8')).replace(/\\.js/g, '.ts'));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!res.includes('FOO'));\n      assert(res.includes('BAR'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when adding resolver config","suites":["cache","resolver"],"updatePoint":{"line":1876,"column":53,"index":79196},"line":1876,"code":"    it('should invalidate when adding resolver config', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), `import \"foo\";`);\n          await overlayFS.writeFile(path.join(inputDir, 'src/foo.js'), `export default \"FOO\";`);\n          await overlayFS.writeFile(path.join(inputDir, 'src/bar.js'), `export default \"BAR\";`);\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            resolvers: ['parcel-resolver-test']\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(res.includes('FOO'));\n          assert(!res.includes('BAR'));\n          await overlayFS.writeFile(path.join(inputDir, '.resolverrc'), JSON.stringify({\n            foo: 'bar.js'\n          }));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!res.includes('FOO'));\n      assert(res.includes('BAR'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when updating resolver config","suites":["cache","resolver"],"updatePoint":{"line":1903,"column":55,"index":80417},"line":1903,"code":"    it('should invalidate when updating resolver config', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), `import \"foo\";`);\n          await overlayFS.writeFile(path.join(inputDir, 'src/foo.js'), `export default \"FOO\";`);\n          await overlayFS.writeFile(path.join(inputDir, 'src/bar.js'), `export default \"BAR\";`);\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            resolvers: ['parcel-resolver-test']\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.resolverrc'), JSON.stringify({\n            foo: 'bar.js'\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!res.includes('FOO'));\n          assert(res.includes('BAR'));\n          await overlayFS.writeFile(path.join(inputDir, '.resolverrc'), JSON.stringify({\n            foo: 'foo.js'\n          }));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(res.includes('FOO'));\n      assert(!res.includes('BAR'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when removing resolver config","suites":["cache","resolver"],"updatePoint":{"line":1933,"column":55,"index":81768},"line":1933,"code":"    it('should invalidate when removing resolver config', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), `import \"foo\";`);\n          await overlayFS.writeFile(path.join(inputDir, 'src/foo.js'), `export default \"FOO\";`);\n          await overlayFS.writeFile(path.join(inputDir, 'src/bar.js'), `export default \"BAR\";`);\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            resolvers: ['parcel-resolver-test']\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.resolverrc'), JSON.stringify({\n            foo: 'bar.js'\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!res.includes('FOO'));\n          assert(res.includes('BAR'));\n          await overlayFS.unlink(path.join(inputDir, '.resolverrc'));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(res.includes('FOO'));\n      assert(!res.includes('BAR'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when the .pnp.js file changes","suites":["cache","resolver","pnp"],"updatePoint":{"line":1962,"column":57,"index":83095},"line":1962,"code":"      it('should invalidate when the .pnp.js file changes', async function () {\n        let Module = require('module');\n        let origPnpVersion = process.versions.pnp;\n        // $FlowFixMe[prop-missing]\n        let origModuleResolveFilename = Module._resolveFilename;\n        try {\n          let b = await testCache({\n            entries: ['index.js'],\n            inputFS,\n            async setup() {\n              await inputFS.mkdirp(inputDir);\n              await inputFS.ncp(path.join(__dirname, '/integration/pnp-require'), inputDir);\n\n              // $FlowFixMe[incompatible-type]\n              process.versions.pnp = 42;\n\n              // $FlowFixMe[prop-missing]\n              Module.findPnpApi = () =>\n              // $FlowFixMe\n              require(path.join(inputDir, '.pnp.js'));\n              let pnp = await inputFS.readFile(path.join(inputDir, '.pnp.js'), 'utf8');\n              await inputFS.writeFile(path.join(inputDir, '.pnp.js'), pnp.replace(\"'zipfs',\", ''));\n              await inputFS.mkdirp(path.join(inputDir, 'pnp/testmodule2'));\n              await inputFS.writeFile(path.join(inputDir, 'pnp/testmodule2/index.js'), 'exports.a = 4;');\n            },\n            async update(b) {\n              let output = await run(b.bundleGraph);\n              assert.equal(output(), 3);\n              let pnp = await inputFS.readFile(path.join(inputDir, '.pnp.js'), 'utf8');\n              await inputFS.writeFile(path.join(inputDir, '.pnp.js'), pnp.replace(\"'pnp', 'testmodule'\", \"'pnp', 'testmodule2'\"));\n              delete require.cache[path.join(inputDir, '.pnp.js')];\n              await sleep(100);\n            }\n          }, 'pnp-require');\n          let output = await run(b.bundleGraph);\n          assert.equal(output(), 6);\n        } finally {\n          // $FlowFixMe[incompatible-type]\n          process.versions.pnp = origPnpVersion;\n          // $FlowFixMe[prop-missing]\n          Module._resolveFilename = origModuleResolveFilename;\n        }\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support resolver inside stylus file","suites":["cache","resolver","stylus"],"updatePoint":{"line":2007,"column":52,"index":85125},"line":2007,"code":"      it('should support resolver inside stylus file', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, 'index.styl'), `\n            @import \"./b\";\n            .a\n              background: red\n            `);\n            await overlayFS.mkdirp(path.join(inputDir, 'b'));\n            await overlayFS.writeFile(path.join(inputDir, 'b/index.styl'), `\n            .b\n              background: blue\n            `);\n          },\n          async update(b) {\n            let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n            assert(css.includes('.a {'));\n            assert(css.includes('.b {'));\n            assert(!css.includes('.c {'));\n            await overlayFS.writeFile(path.join(inputDir, 'b.styl'), `\n            .c\n              background: blue\n            `);\n          }\n        }, 'stylus');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(css.includes('.a {'));\n        assert(!css.includes('.b {'));\n        assert(css.includes('.c {'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support stylus default resolver","suites":["cache","resolver","stylus"],"updatePoint":{"line":2038,"column":48,"index":86353},"line":2038,"code":"      it('should support stylus default resolver', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, '.stylusrc'), JSON.stringify({\n              paths: ['deps']\n            }));\n          },\n          async update(b) {\n            let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n            assert(css.includes('.a {'));\n            assert(!css.includes('.b {'));\n            await overlayFS.writeFile(path.join(inputDir, 'a.styl'), `\n            .b\n              background: blue\n            `);\n          }\n        }, 'stylus-deps');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(!css.includes('.a {'));\n        assert(css.includes('.b {'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support glob imports in stylus files","suites":["cache","resolver","stylus"],"updatePoint":{"line":2060,"column":53,"index":87283},"line":2060,"code":"      it('should support glob imports in stylus files', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          async update(b) {\n            let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n            assert(css.includes('.index'));\n            assert(css.includes('.main'));\n            assert(css.includes('.foo'));\n            assert(css.includes('.bar'));\n            await overlayFS.writeFile(path.join(inputDir, 'subdir/test.styl'), `\n            .test\n              background: blue\n            `);\n            await overlayFS.writeFile(path.join(inputDir, 'subdir/foo/test.styl'), `\n            .foo-test\n              background: blue\n            `);\n          }\n        }, 'stylus-glob-import');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(css.includes('.index'));\n        assert(css.includes('.main'));\n        assert(css.includes('.foo'));\n        assert(css.includes('.bar'));\n        assert(css.includes('.test'));\n        assert(css.includes('.foo-test'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support glob imports under stylus paths","suites":["cache","resolver","stylus"],"updatePoint":{"line":2087,"column":56,"index":88461},"line":2087,"code":"      it('should support glob imports under stylus paths', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, '.stylusrc'), JSON.stringify({\n              paths: ['subdir']\n            }));\n            await overlayFS.writeFile(path.join(inputDir, 'index.styl'), `\n            @require 'foo/*'\n\n            .index\n              color: red\n            `);\n          },\n          async update(b) {\n            let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n            assert(css.includes('.index'));\n            assert(!css.includes('.main'));\n            assert(css.includes('.foo'));\n            assert(!css.includes('.bar'));\n            await overlayFS.writeFile(path.join(inputDir, 'subdir/test.styl'), `\n            .test\n              background: blue\n            `);\n            await overlayFS.writeFile(path.join(inputDir, 'subdir/foo/test.styl'), `\n            .foo-test\n              background: blue\n            `);\n          }\n        }, 'stylus-glob-import');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(css.includes('.index'));\n        assert(!css.includes('.main'));\n        assert(css.includes('.foo'));\n        assert(!css.includes('.bar'));\n        assert(!css.includes('.test'));\n        assert(css.includes('.foo-test'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding higher priority less include paths","suites":["cache","resolver","less"],"updatePoint":{"line":2127,"column":66,"index":90039},"line":2127,"code":"      it('should support adding higher priority less include paths', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, '.lessrc'), JSON.stringify({\n              paths: ['include-path', 'node_modules/library']\n            }));\n          },\n          async update(b) {\n            let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n            assert(css.includes('.a'));\n            assert(css.includes('.b'));\n            await overlayFS.writeFile(path.join(inputDir, 'a.less'), `.c {\n                  background: blue\n                }`);\n            await overlayFS.writeFile(path.join(inputDir, 'include-path/b.less'), `.d {\n                  background: blue\n                }`);\n          }\n        }, 'less-include-paths');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(!css.includes('.a'));\n        assert(!css.includes('.b'));\n        assert(css.includes('.c'));\n        assert(css.includes('.d'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should recover from missing import errors","suites":["cache","resolver","less"],"updatePoint":{"line":2153,"column":51,"index":91210},"line":2153,"code":"      it('should recover from missing import errors', async function () {\n        // $FlowFixMe\n        await assert.rejects(async () => {\n          await testCache({\n            entries: ['index.js'],\n            async setup() {\n              await overlayFS.writeFile(path.join(inputDir, '.lessrc'), JSON.stringify({\n                paths: ['include-path', 'node_modules/library']\n              }));\n              await overlayFS.writeFile(path.join(inputDir, 'yarn.lock'), '');\n              await overlayFS.unlink(path.join(inputDir, 'include-path/a.less'));\n            },\n            async update() {}\n          }, 'less-include-paths');\n        }, {\n          message: \"Failed to resolve 'a.less' from './index.less'\"\n        });\n        await overlayFS.writeFile(path.join(inputDir, 'include-path/a.less'), `.d {\n            background: blue\n          }`);\n        let b = await runBundle('index.js');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(css.includes('.d'));\n        assert(css.includes('.b'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding higher priority sass include paths","suites":["cache","resolver","sass"],"updatePoint":{"line":2180,"column":66,"index":92378},"line":2180,"code":"      it('should support adding higher priority sass include paths', async function () {\n        let b = await testCache({\n          entries: ['index.sass'],\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, '.sassrc'), JSON.stringify({\n              includePaths: ['include-path']\n            }));\n          },\n          async update(b) {\n            let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n            assert(css.includes('.included'));\n            await overlayFS.writeFile(path.join(inputDir, 'style.sass'), `.test\n                  background: blue\n                `);\n          }\n        }, 'sass-include-paths-import');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(!css.includes('.included'));\n        assert(css.includes('.test'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should the SASS_PATH environment variable","suites":["cache","resolver","sass"],"updatePoint":{"line":2200,"column":51,"index":93305},"line":2200,"code":"      it('should the SASS_PATH environment variable', async function () {\n        let b = await testCache({\n          entries: ['index.sass'],\n          env: {\n            SASS_PATH: 'include-path'\n          },\n          async setup() {\n            await overlayFS.mkdirp(path.join(inputDir, 'include2'));\n            await overlayFS.writeFile(path.join(inputDir, 'include2/style.sass'), `.test\n                  background: blue\n                `);\n          },\n          async update(b) {\n            let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n            assert(css.includes('.included'));\n            return {\n              env: {\n                SASS_PATH: 'include2'\n              }\n            };\n          }\n        }, 'sass-include-paths-import');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(!css.includes('.included'));\n        assert(css.includes('.test'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should recover from missing import errors","suites":["cache","resolver","sass"],"updatePoint":{"line":2226,"column":51,"index":94340},"line":2226,"code":"      it('should recover from missing import errors', async function () {\n        // $FlowFixMe\n        await assert.rejects(async () => {\n          await testCache({\n            entries: ['index.sass'],\n            async setup() {\n              await overlayFS.writeFile(path.join(inputDir, '.sassrc'), JSON.stringify({\n                includePaths: ['include-path']\n              }));\n              await overlayFS.writeFile(path.join(inputDir, 'yarn.lock'), '');\n              await overlayFS.unlink(path.join(inputDir, 'include-path/style.sass'));\n            },\n            async update() {}\n          }, 'sass-include-paths-import');\n        });\n        await overlayFS.writeFile(path.join(inputDir, 'include-path/style.sass'), `.d\n            background: blue\n          `);\n        let b = await runBundle('index.sass');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(css.includes('.d'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when updating a parcel transformer plugin","suites":["cache","dev deps"],"updatePoint":{"line":2251,"column":67,"index":95399},"line":2251,"code":"    it('should invalidate when updating a parcel transformer plugin', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n        },\n        async update(b) {\n          let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(output.includes('TRANSFORMED CODE'));\n          let transformerDir = path.join(inputDir, 'node_modules', 'parcel-transformer-mock');\n          await overlayFS.writeFile(path.join(transformerDir, 'constants.js'), 'exports.message = \"UPDATED\"');\n        }\n      });\n      let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(output.includes('UPDATED'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when updating a file required via options.packageManager.require","suites":["cache","dev deps"],"updatePoint":{"line":2271,"column":90,"index":96367},"line":2271,"code":"    it('should invalidate when updating a file required via options.packageManager.require', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n          let transformer = path.join(inputDir, 'node_modules', 'parcel-transformer-mock', 'index.js');\n          let contents = await overlayFS.readFile(transformer, 'utf8');\n          await overlayFS.writeFile(transformer, contents.replace('transform({asset}) {', 'async transform({asset, options}) {').replace(\"const {message} = require('./constants');\", \"const message = 'FOO: ' + await options.packageManager.require('foo', asset.filePath);\"));\n        },\n        async update(b) {\n          let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(output.includes('FOO: 2'));\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules', 'foo', 'foo.js'), 'module.exports = 3;');\n        }\n      });\n      let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(output.includes('FOO: 3'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve to package.json#main over an index.js","suites":["cache","dev deps"],"updatePoint":{"line":2293,"column":60,"index":97652},"line":2293,"code":"    it('should resolve to package.json#main over an index.js', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n        },\n        async update(b) {\n          let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(output.includes('TRANSFORMED CODE'));\n          let transformerDir = path.join(inputDir, 'node_modules', 'parcel-transformer-mock');\n          await overlayFS.writeFile(path.join(transformerDir, 'MockTransformer.js'), `\n            const Transformer = require('@parcel/plugin').Transformer;\n            module.exports = new Transformer({\n              transform({asset}) {\n                return [\n                  {\n                    type: 'js',\n                    content: 'UPDATED',\n                  },\n                ];\n              }\n            });\n            `);\n          await overlayFS.writeFile(path.join(transformerDir, 'package.json'), JSON.stringify({\n            main: 'MockTransformer.js'\n          }));\n        }\n      });\n      let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(output.includes('UPDATED'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve to a file over a directory with an index.js","suites":["cache","dev deps"],"updatePoint":{"line":2328,"column":66,"index":99080},"line":2328,"code":"    it('should resolve to a file over a directory with an index.js', async function () {\n      let transformerDir = path.join(inputDir, 'node_modules', 'parcel-transformer-mock');\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n          await overlayFS.unlink(path.join(transformerDir, 'constants.js'));\n          await overlayFS.mkdirp(path.join(transformerDir, 'constants'));\n          await overlayFS.writeFile(path.join(transformerDir, 'constants', 'index.js'), 'exports.message = \"TRANSFORMED\"');\n        },\n        async update(b) {\n          let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(output.includes('TRANSFORMED'));\n          await overlayFS.writeFile(path.join(transformerDir, 'constants.js'), 'exports.message = \"UPDATED\"');\n        }\n      });\n      let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(output.includes('UPDATED'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a deeper node_modules folder","suites":["cache","dev deps"],"updatePoint":{"line":2351,"column":58,"index":100282},"line":2351,"code":"    it('should support adding a deeper node_modules folder', async function () {});","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support yarn pnp","suites":["cache","dev deps"],"updatePoint":{"line":2352,"column":31,"index":100339},"line":2352,"code":"    it('should support yarn pnp', async function () {\n      let Module = require('module');\n      // $FlowFixMe[incompatible-type]\n      let origPnpVersion = process.versions.pnp;\n      // $FlowFixMe[prop-missing]\n      let origModuleResolveFilename = Module._resolveFilename;\n\n      // We must create a worker farm that only uses a single thread because our process.versions.pnp\n      // mock won't be available in the workers of the existing farm.\n      let workerFarm = createWorkerFarm({\n        maxConcurrentWorkers: 0\n      });\n      try {\n        let b = await testCache({\n          inputFS,\n          outputFS: inputFS,\n          workerFarm,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n\n            // $FlowFixMe\n            process.versions.pnp = 42;\n            fs.renameSync(path.join(inputDir, 'node_modules'), path.join(inputDir, 'pnp'));\n            await inputFS.ncp(path.join(inputDir, 'pnp'), path.join(inputDir, 'pnp2'));\n            await inputFS.writeFile(path.join(inputDir, 'pnp', 'parcel-transformer-mock', 'index.js'), `\n                const Transformer = require('@parcel/plugin').Transformer;\n                module.exports = new Transformer({\n                  transform({asset}) {\n                    return [\n                      {\n                        type: 'js',\n                        content: 'TRANSFORMED CODE',\n                      },\n                    ];\n                  }\n                });\n                `);\n            await inputFS.writeFile(path.join(inputDir, 'pnp2', 'parcel-transformer-mock', 'index.js'), `\n                const Transformer = require('@parcel/plugin').Transformer;\n                module.exports = new Transformer({\n                  transform({asset}) {\n                    return [\n                      {\n                        type: 'js',\n                        content: 'UPDATED',\n                      },\n                    ];\n                  }\n                });\n                `);\n            await inputFS.writeFile(path.join(inputDir, '.pnp.js'), `\n                const path = require('path');\n                const resolve = request => {\n                  if (request === 'parcel-transformer-mock/' || request === 'foo/') {\n                    return path.join(__dirname, 'pnp', request);\n                  } else if (request === 'pnpapi') {\n                    return __filename;\n                  } else if (request.startsWith('@parcel/')) {\n                    // Use node_modules path for parcel packages so source field is used.\n                    return path.join(__dirname, '../../../../../../node_modules/', request);\n                  } else if (/^((@[^/]+\\\\/[^/]+)|[^/]+)\\\\/?$/.test(request)) {\n                    return path.dirname(require.resolve(path.join(request, 'package.json')));\n                  } else {\n                    return require.resolve(request);\n                  }\n                };\n\n                module.exports = {resolveToUnqualified: resolve, resolveRequest: resolve};\n                `);\n\n            // $FlowFixMe[prop-missing]\n            Module.findPnpApi = () =>\n            // $FlowFixMe\n            require(path.join(inputDir, '.pnp.js'));\n            await inputFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n              extends: '@parcel/config-default',\n              transformers: {\n                '*.js': ['parcel-transformer-mock']\n              }\n            }));\n          },\n          async update(b) {\n            let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(output.includes('TRANSFORMED CODE'));\n            await inputFS.writeFile(path.join(inputDir, '.pnp.js'), `\n                const path = require('path');\n                const resolve = request => {\n                  if (request === 'parcel-transformer-mock/' || request === 'foo/') {\n                    return path.join(__dirname, 'pnp2', request);\n                  } else if (request === 'pnpapi') {\n                    return __filename;\n                  } else if (request.startsWith('@parcel/')) {\n                    // Use node_modules path for parcel packages so source field is used.\n                    return path.join(__dirname, '../../../../../../node_modules/', request);\n                  } else if (/^((@[^/]+\\\\/[^/]+)|[^/]+)\\\\/?$/.test(request)) {\n                    return path.dirname(require.resolve(path.join(request, 'package.json')));\n                  } else {\n                    return require.resolve(request);\n                  }\n                };\n\n                module.exports = {resolveToUnqualified: resolve, resolveRequest: resolve};\n                `);\n            delete require.cache[path.join(inputDir, '.pnp.js')];\n            await sleep(100);\n          }\n        });\n        let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(output.includes('UPDATED'));\n      } finally {\n        process.versions.pnp = origPnpVersion;\n        // $FlowFixMe[prop-missing]\n        Module._resolveFilename = origModuleResolveFilename;\n        await workerFarm.end();\n      }\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a postcss plugin changes","suites":["cache","dev deps","postcss"],"updatePoint":{"line":2470,"column":57,"index":105670},"line":2470,"code":"      it('should invalidate when a postcss plugin changes', async function () {\n        let b = await testCache({\n          entries: ['index.css'],\n          async setup() {\n            await overlayFS.mkdirp(path.join(inputDir, 'node_modules'));\n            await ncp(path.join(path.join(__dirname, 'integration', 'postcss-autoinstall', 'postcss-test')), path.join(inputDir, 'node_modules', 'postcss-test'));\n          },\n          async update(b) {\n            let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(output.includes('background: green'));\n            let plugin = path.join(inputDir, 'node_modules', 'postcss-test', 'index.js');\n            let pluginContents = await overlayFS.readFile(plugin, 'utf8');\n            await overlayFS.writeFile(plugin, pluginContents.replace('green', 'red'));\n          }\n        }, 'postcss-autoinstall/npm');\n        let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(output.includes('background: red'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a JS postcss config changes","suites":["cache","dev deps","postcss"],"updatePoint":{"line":2488,"column":60,"index":106741},"line":2488,"code":"      it('should invalidate when a JS postcss config changes', async function () {\n        let b = await testCache({\n          entries: ['style.css'],\n          inputFS,\n          outputFS: inputFS,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/postcss-js-config-7'), inputDir);\n          },\n          async update(b) {\n            let output = await inputFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(output.includes('background-color: red;'));\n            let config = path.join(inputDir, 'postcss.config.js');\n            let configContents = await inputFS.readFile(config, 'utf8');\n            await inputFS.writeFile(config, configContents.replace('red', 'green'));\n            await sleep(100);\n          }\n        }, 'postcss-js-config-7');\n        let output = await inputFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(output.includes('background-color: green'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a JSON postcss config changes","suites":["cache","dev deps","postcss"],"updatePoint":{"line":2509,"column":62,"index":107777},"line":2509,"code":"      it('should invalidate when a JSON postcss config changes', async function () {\n        let b = await testCache({\n          entries: ['nested/index.css'],\n          async update(b) {\n            let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(output.includes('background-color: green;'));\n            let configContents = await overlayFS.readFile(path.join(inputDir, '.postcssrc'), 'utf8');\n            await overlayFS.writeFile(path.join(inputDir, '.postcssrc'), configContents.replace('green', 'red'));\n          }\n        }, 'postcss-import');\n        let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(output.includes('background-color: red'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a closer postcss config is added","suites":["cache","dev deps","postcss"],"updatePoint":{"line":2522,"column":65,"index":108553},"line":2522,"code":"      it('should invalidate when a closer postcss config is added', async function () {\n        let b = await testCache({\n          entries: ['nested/index.css'],\n          async update(b) {\n            let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(output.includes('background-color: green;'));\n            let configContents = await overlayFS.readFile(path.join(inputDir, '.postcssrc'), 'utf8');\n            await overlayFS.writeFile(path.join(inputDir, 'nested', '.postcssrc'), configContents.replace('green', 'red'));\n          }\n        }, 'postcss-import');\n        let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(output.includes('background-color: red'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a posthtml plugin changes","suites":["cache","dev deps","posthtml"],"updatePoint":{"line":2537,"column":58,"index":109379},"line":2537,"code":"      it('should invalidate when a posthtml plugin changes', async function () {\n        let b = await testCache({\n          entries: ['index.html'],\n          async setup() {\n            await overlayFS.mkdirp(path.join(inputDir, 'node_modules'));\n            await ncp(path.join(path.join(__dirname, 'integration', 'posthtml-autoinstall', 'posthtml-test')), path.join(inputDir, 'node_modules', 'posthtml-test'));\n          },\n          async update(b) {\n            let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(output.includes('<span id=\"test\">Test</span>'));\n            let plugin = path.join(inputDir, 'node_modules', 'posthtml-test', 'index.js');\n            let pluginContents = await overlayFS.readFile(plugin, 'utf8');\n            await overlayFS.writeFile(plugin, pluginContents.replace('span', 'section'));\n          }\n        }, 'posthtml-autoinstall');\n        let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(output.includes('<section id=\"test\">Test</section>'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a JS postcss config changes","suites":["cache","dev deps","posthtml"],"updatePoint":{"line":2555,"column":60,"index":110483},"line":2555,"code":"      it('should invalidate when a JS postcss config changes', async function () {\n        let b = await testCache({\n          entries: ['index.html'],\n          inputFS,\n          outputFS: inputFS,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/posthtml'), inputDir);\n            await inputFS.mkdirp(path.join(inputDir, 'include'));\n            await inputFS.writeFile(path.join(inputDir, 'include', 'other.html'), '<h1>Another great page</h1>');\n          },\n          async update(b) {\n            let output = await inputFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(output.includes('<h1>Other page</h1>'));\n            let config = path.join(inputDir, '.posthtmlrc.js');\n            let configContents = await inputFS.readFile(config, 'utf8');\n            await inputFS.writeFile(config, configContents.replace('__dirname', '__dirname + \"/include\"'));\n            await sleep(100);\n          }\n        }, 'posthtml');\n        let output = await inputFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(output.includes('<h1>Another great page</h1>'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when switching to a different bundler plugin","suites":["cache","bundling"],"updatePoint":{"line":2581,"column":70,"index":111758},"line":2581,"code":"    it('should invalidate when switching to a different bundler plugin', async function () {\n      let b = await testCache({\n        async update(b) {\n          assert.equal(b.bundleGraph.getBundles().length, 1);\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            bundler: 'parcel-bundler-test'\n          }));\n        }\n      });\n      assert.equal(b.bundleGraph.getBundles().length, 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a bundler plugin is updated","suites":["cache","bundling"],"updatePoint":{"line":2593,"column":58,"index":112237},"line":2593,"code":"    it('should invalidate when a bundler plugin is updated', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            bundler: 'parcel-bundler-test'\n          }));\n        },\n        async update(b) {\n          assert.equal(b.bundleGraph.getBundles().length, 4);\n          assert.equal(b.bundleGraph.getBundles()[0].name, 'index.js');\n          let bundler = path.join(inputDir, 'node_modules', 'parcel-bundler-test', 'index.js');\n          await overlayFS.writeFile(bundler, (await overlayFS.readFile(bundler, 'utf8')).replace('Boolean(dependency.isEntry)', 'false'));\n        }\n      });\n      assert.equal(b.bundleGraph.getBundles().length, 4);\n      assert(b.bundleGraph.getBundles()[0].name.includes('HASH_REF'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when adding a namer plugin","suites":["cache","bundling"],"updatePoint":{"line":2611,"column":52,"index":113123},"line":2611,"code":"    it('should invalidate when adding a namer plugin', async function () {\n      let b = await testCache({\n        async update(b) {\n          let bundles = b.bundleGraph.getBundles().map(b => b.name);\n          assert.deepEqual(bundles, ['index.js']);\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            namers: ['parcel-namer-test']\n          }));\n        }\n      });\n      let bundles = b.bundleGraph.getBundles();\n      assert.deepEqual(bundles.map(b => b.name), bundles.map(b => `${b.id}.${b.type}`));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a namer plugin is updated","suites":["cache","bundling"],"updatePoint":{"line":2625,"column":56,"index":113736},"line":2625,"code":"    it('should invalidate when a namer plugin is updated', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            namers: ['parcel-namer-test']\n          }));\n        },\n        async update(b) {\n          let bundles = b.bundleGraph.getBundles();\n          assert.deepEqual(bundles.map(b => b.name), bundles.map(b => `${b.id}.${b.type}`));\n          let namer = path.join(inputDir, 'node_modules', 'parcel-namer-test', 'index.js');\n          await overlayFS.writeFile(namer, (await overlayFS.readFile(namer, 'utf8')).replace('bundle.id', 'bundle.id.slice(-8)'));\n        }\n      });\n      let bundles = b.bundleGraph.getBundles();\n      assert.deepEqual(bundles.map(b => b.name), bundles.map(b => `${b.id.slice(-8)}.${b.type}`));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when adding a runtime plugin","suites":["cache","bundling"],"updatePoint":{"line":2643,"column":54,"index":114640},"line":2643,"code":"    it('should invalidate when adding a runtime plugin', async function () {\n      let b = await testCache({\n        async update(b) {\n          let res = await run(b.bundleGraph, null, {\n            require: false\n          });\n          assert.equal(res.runtime_test, undefined);\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            runtimes: ['parcel-runtime-test']\n          }));\n        }\n      });\n      let res = await run(b.bundleGraph, null, {\n        require: false\n      });\n      assert.equal(res.runtime_test, true);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a runtime is updated","suites":["cache","bundling"],"updatePoint":{"line":2661,"column":51,"index":115268},"line":2661,"code":"    it('should invalidate when a runtime is updated', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            runtimes: ['parcel-runtime-test']\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph, null, {\n            require: false\n          });\n          assert.equal(res.runtime_test, true);\n          assert.equal(res.test_runtime, undefined);\n          let namer = path.join(inputDir, 'node_modules', 'parcel-runtime-test', 'index.js');\n          await overlayFS.writeFile(namer, (await overlayFS.readFile(namer, 'utf8')).replace('runtime_test', 'test_runtime'));\n        }\n      });\n      let res = await run(b.bundleGraph, null, {\n        require: false\n      });\n      assert.equal(res.runtime_test, undefined);\n      assert.equal(res.test_runtime, true);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding bundler config","suites":["cache","bundling","bundler config"],"updatePoint":{"line":2686,"column":46,"index":116289},"line":2686,"code":"      it('should support adding bundler config', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          mode: 'production',\n          async setup() {\n            let pkgFile = path.join(inputDir, 'package.json');\n            let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n            await overlayFS.writeFile(pkgFile, JSON.stringify({\n              ...pkg,\n              '@parcel/bundler-default': undefined\n            }));\n          },\n          async update(b) {\n            assertBundles(b.bundleGraph, [{\n              assets: ['a.js']\n            }, {\n              assets: ['b.js']\n            }, {\n              name: 'index.js',\n              assets: ['index.js', 'c.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'bundle-manifest.js']\n            }, {\n              assets: ['common.js', 'lodash.js']\n            }]);\n            let pkgFile = path.join(inputDir, 'package.json');\n            let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n            await overlayFS.writeFile(pkgFile, JSON.stringify({\n              ...pkg,\n              '@parcel/bundler-default': {\n                minBundleSize: 9000000\n              }\n            }));\n          }\n        }, 'dynamic-common-large');\n        assertBundles(b.bundleGraph, [{\n          assets: ['a.js', 'common.js', 'lodash.js']\n        }, {\n          assets: ['b.js', 'common.js', 'lodash.js']\n        }, {\n          name: 'index.js',\n          assets: ['index.js', 'c.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'bundle-manifest.js']\n        }]);\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding bundler config for parallel request limits","suites":["cache","bundling","bundler config"],"updatePoint":{"line":2728,"column":74,"index":117923},"line":2728,"code":"      it('should support adding bundler config for parallel request limits', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          mode: 'production',\n          async setup() {\n            let pkgFile = path.join(inputDir, 'package.json');\n            let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n            await overlayFS.writeFile(pkgFile, JSON.stringify({\n              ...pkg,\n              '@parcel/bundler-default': undefined\n            }));\n          },\n          async update(b) {\n            assert.deepEqual(b.bundleGraph.getBundles().length, 7);\n            let pkgFile = path.join(inputDir, 'package.json');\n            let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n            await overlayFS.writeFile(pkgFile, JSON.stringify({\n              ...pkg,\n              '@parcel/bundler-default': {\n                maxParallelRequests: 0\n              }\n            }));\n          }\n        }, 'large-bundlegroup');\n        assert.deepEqual(b.bundleGraph.getBundles().length, 5);\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating bundler config","suites":["cache","bundling","bundler config"],"updatePoint":{"line":2754,"column":48,"index":118964},"line":2754,"code":"      it('should support updating bundler config', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          mode: 'production',\n          async setup() {\n            let pkgFile = path.join(inputDir, 'package.json');\n            let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n            await overlayFS.writeFile(pkgFile, JSON.stringify({\n              ...pkg,\n              '@parcel/bundler-default': {\n                minBundleSize: 8000\n              }\n            }));\n          },\n          async update(b) {\n            assertBundles(b.bundleGraph, [{\n              assets: ['a.js']\n            }, {\n              assets: ['b.js']\n            }, {\n              name: 'index.js',\n              assets: ['index.js', 'c.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'bundle-manifest.js']\n            }, {\n              assets: ['common.js', 'lodash.js']\n            }]);\n            let pkgFile = path.join(inputDir, 'package.json');\n            let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n            await overlayFS.writeFile(pkgFile, JSON.stringify({\n              ...pkg,\n              '@parcel/bundler-default': {\n                minBundleSize: 9000000\n              }\n            }));\n          }\n        }, 'dynamic-common-large');\n        assertBundles(b.bundleGraph, [{\n          assets: ['a.js', 'common.js', 'lodash.js']\n        }, {\n          assets: ['b.js', 'common.js', 'lodash.js']\n        }, {\n          name: 'index.js',\n          assets: ['index.js', 'c.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'bundle-manifest.js']\n        }]);\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support removing bundler config","suites":["cache","bundling","bundler config"],"updatePoint":{"line":2798,"column":48,"index":120616},"line":2798,"code":"      it('should support removing bundler config', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          mode: 'production',\n          async setup() {\n            let pkgFile = path.join(inputDir, 'package.json');\n            let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n            await overlayFS.writeFile(pkgFile, JSON.stringify({\n              ...pkg,\n              '@parcel/bundler-default': {\n                minBundleSize: 9000000\n              }\n            }));\n          },\n          async update(b) {\n            assertBundles(b.bundleGraph, [{\n              assets: ['a.js', 'common.js', 'lodash.js']\n            }, {\n              assets: ['b.js', 'common.js', 'lodash.js']\n            }, {\n              name: 'index.js',\n              assets: ['index.js', 'c.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'bundle-manifest.js']\n            }]);\n            let pkgFile = path.join(inputDir, 'package.json');\n            let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n            await overlayFS.writeFile(pkgFile, JSON.stringify({\n              ...pkg,\n              '@parcel/bundler-default': undefined\n            }));\n          }\n        }, 'dynamic-common-large');\n        assertBundles(b.bundleGraph, [{\n          assets: ['a.js']\n        }, {\n          assets: ['b.js']\n        }, {\n          name: 'index.js',\n          assets: ['index.js', 'c.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'bundle-manifest.js']\n        }, {\n          assets: ['common.js', 'lodash.js']\n        }]);\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when switching to a different packager plugin","suites":["cache","packaging"],"updatePoint":{"line":2843,"column":71,"index":122291},"line":2843,"code":"    it('should invalidate when switching to a different packager plugin', async function () {\n      let b = await testCache({\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.notEqual(res, 'packaged');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.js': 'parcel-packager-test'\n            }\n          }));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'packaged');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a packager is updated","suites":["cache","packaging"],"updatePoint":{"line":2859,"column":52,"index":122950},"line":2859,"code":"    it('should invalidate when a packager is updated', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.js': 'parcel-packager-test'\n            }\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'packaged');\n          let packager = path.join(inputDir, 'node_modules', 'parcel-packager-test', 'index.js');\n          await overlayFS.writeFile(packager, (await overlayFS.readFile(packager, 'utf8')).replace('packaged', 'updated'));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when adding packager config","suites":["cache","packaging"],"updatePoint":{"line":2879,"column":53,"index":123863},"line":2879,"code":"    it('should invalidate when adding packager config', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.js': 'parcel-packager-test'\n            }\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'packaged');\n          await overlayFS.writeFile(path.join(inputDir, '.packagerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'test');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when updating packager config","suites":["cache","packaging"],"updatePoint":{"line":2900,"column":55,"index":124683},"line":2900,"code":"    it('should invalidate when updating packager config', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.js': 'parcel-packager-test'\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.packagerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.packagerrc'), JSON.stringify({\n            value: 'updated'\n          }));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when removing packager config","suites":["cache","packaging"],"updatePoint":{"line":2924,"column":55,"index":125635},"line":2924,"code":"    it('should invalidate when removing packager config', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.js': 'parcel-packager-test'\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.packagerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'test');\n          await overlayFS.unlink(path.join(inputDir, '.packagerrc'));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'packaged');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when adding an optimizer plugin","suites":["cache","packaging"],"updatePoint":{"line":2946,"column":57,"index":126527},"line":2946,"code":"    it('should invalidate when adding an optimizer plugin', async function () {\n      let b = await testCache({\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.notEqual(res, 'optimized');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.js': ['parcel-optimizer-test']\n            }\n          }));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'optimized');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when removing an optimizer plugin","suites":["cache","packaging"],"updatePoint":{"line":2962,"column":59,"index":127199},"line":2962,"code":"    it('should invalidate when removing an optimizer plugin', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.js': ['parcel-optimizer-test']\n            }\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'optimized');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.js': []\n            }\n          }));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.notEqual(res, 'optimized');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when an optimizer is updated","suites":["cache","packaging"],"updatePoint":{"line":2986,"column":54,"index":128115},"line":2986,"code":"    it('should invalidate when an optimizer is updated', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.js': ['parcel-optimizer-test']\n            }\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'optimized');\n          let optimizer = path.join(inputDir, 'node_modules', 'parcel-optimizer-test', 'index.js');\n          await overlayFS.writeFile(optimizer, (await overlayFS.readFile(optimizer, 'utf8')).replace('optimized', 'updated'));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when adding optimizer config","suites":["cache","packaging"],"updatePoint":{"line":3006,"column":54,"index":129039},"line":3006,"code":"    it('should invalidate when adding optimizer config', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.js': ['parcel-optimizer-test']\n            }\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'optimized');\n          await overlayFS.writeFile(path.join(inputDir, '.optimizerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'test');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when updating packager config","suites":["cache","packaging"],"updatePoint":{"line":3027,"column":55,"index":129865},"line":3027,"code":"    it('should invalidate when updating packager config', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.js': ['parcel-optimizer-test']\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.optimizerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.optimizerrc'), JSON.stringify({\n            value: 'updated'\n          }));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when removing packager config","suites":["cache","packaging"],"updatePoint":{"line":3051,"column":55,"index":130823},"line":3051,"code":"    it('should invalidate when removing packager config', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.js': ['parcel-optimizer-test']\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.optimizerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'test');\n          await overlayFS.unlink(path.join(inputDir, '.optimizerrc'));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'optimized');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when an asset content changes","suites":["cache","packaging"],"updatePoint":{"line":3073,"column":55,"index":131720},"line":3073,"code":"    it('should invalidate when an asset content changes', async function () {\n      let b = await testCache({\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 4);\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/foo.js'), 'module.exports = 3');\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 6);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when an inline bundle changes","suites":["cache","packaging"],"updatePoint":{"line":3084,"column":55,"index":132139},"line":3084,"code":"    it('should invalidate when an inline bundle changes', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./entries/a.js\");');\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert(res.includes(`let a = \"a\"`));\n          await overlayFS.writeFile(path.join(inputDir, 'src/entries/a.js'), `export let a = \"b\";`);\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert(res.includes(`let a = \"b\"`));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when switching to a different packager for an inline bundle","suites":["cache","packaging"],"updatePoint":{"line":3098,"column":85,"index":132780},"line":3098,"code":"    it('should invalidate when switching to a different packager for an inline bundle', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.notEqual(res, 'packaged');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.txt': 'parcel-packager-test'\n            }\n          }));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'packaged');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a packager for an inline bundle is updated","suites":["cache","packaging"],"updatePoint":{"line":3118,"column":73,"index":133611},"line":3118,"code":"    it('should invalidate when a packager for an inline bundle is updated', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.txt': 'parcel-packager-test'\n            }\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 'packaged');\n          let packager = path.join(inputDir, 'node_modules', 'parcel-packager-test', 'index.js');\n          await overlayFS.writeFile(packager, (await overlayFS.readFile(packager, 'utf8')).replace('packaged', 'updated'));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when adding packager config for an inline bundle","suites":["cache","packaging"],"updatePoint":{"line":3140,"column":74,"index":134661},"line":3140,"code":"    it('should invalidate when adding packager config for an inline bundle', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.txt': 'parcel-packager-test'\n            }\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 'packaged');\n          await overlayFS.writeFile(path.join(inputDir, '.packagerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'test');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when updating packager config for an inline bundle","suites":["cache","packaging"],"updatePoint":{"line":3163,"column":76,"index":135618},"line":3163,"code":"    it('should invalidate when updating packager config for an inline bundle', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.txt': 'parcel-packager-test'\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.packagerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.packagerrc'), JSON.stringify({\n            value: 'updated'\n          }));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when removing packager config for an inline bundle","suites":["cache","packaging"],"updatePoint":{"line":3189,"column":76,"index":136707},"line":3189,"code":"    it('should invalidate when removing packager config for an inline bundle', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.txt': 'parcel-packager-test'\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.packagerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 'test');\n          await overlayFS.unlink(path.join(inputDir, '.packagerrc'));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'packaged');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when adding an optimizer for an inline bundle","suites":["cache","packaging"],"updatePoint":{"line":3213,"column":71,"index":137729},"line":3213,"code":"    it('should invalidate when adding an optimizer for an inline bundle', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.notEqual(res, 'packaged');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.txt': ['parcel-optimizer-test']\n            }\n          }));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'optimized');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when an optimizer for an inline bundle is updated","suites":["cache","packaging"],"updatePoint":{"line":3233,"column":75,"index":138567},"line":3233,"code":"    it('should invalidate when an optimizer for an inline bundle is updated', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.txt': ['parcel-optimizer-test']\n            }\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 'optimized');\n          let optimizer = path.join(inputDir, 'node_modules', 'parcel-optimizer-test', 'index.js');\n          await overlayFS.writeFile(optimizer, (await overlayFS.readFile(optimizer, 'utf8')).replace('optimized', 'updated'));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when adding optimizer config for an inline bundle","suites":["cache","packaging"],"updatePoint":{"line":3255,"column":75,"index":139628},"line":3255,"code":"    it('should invalidate when adding optimizer config for an inline bundle', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.txt': ['parcel-optimizer-test']\n            }\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 'optimized');\n          await overlayFS.writeFile(path.join(inputDir, '.optimizerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'test');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when updating optimizer config for an inline bundle","suites":["cache","packaging"],"updatePoint":{"line":3278,"column":77,"index":140592},"line":3278,"code":"    it('should invalidate when updating optimizer config for an inline bundle', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.txt': ['parcel-optimizer-test']\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.optimizerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.optimizerrc'), JSON.stringify({\n            value: 'updated'\n          }));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when removing optimizer config for an inline bundle","suites":["cache","packaging"],"updatePoint":{"line":3304,"column":77,"index":141688},"line":3304,"code":"    it('should invalidate when removing optimizer config for an inline bundle', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.txt': ['parcel-optimizer-test']\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.optimizerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 'test');\n          await overlayFS.unlink(path.join(inputDir, '.optimizerrc'));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'optimized');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when deleting a dist file","suites":["cache","packaging"],"updatePoint":{"line":3328,"column":51,"index":142697},"line":3328,"code":"    it('should invalidate when deleting a dist file', async function () {\n      let b = await testCache({\n        async update(b) {\n          assert(await overlayFS.exists(path.join(distDir, 'index.js')));\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 4);\n          await overlayFS.unlink(path.join(distDir, 'index.js'));\n        }\n      });\n      assert(await overlayFS.exists(path.join(distDir, 'index.js')));\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when deleting a source map","suites":["cache","packaging"],"updatePoint":{"line":3341,"column":52,"index":143216},"line":3341,"code":"    it('should invalidate when deleting a source map', async function () {\n      await testCache({\n        async update() {\n          assert(await overlayFS.exists(path.join(distDir, 'index.js.map')));\n          await overlayFS.unlink(path.join(distDir, 'index.js.map'));\n        }\n      });\n      assert(await overlayFS.exists(path.join(distDir, 'index.js.map')));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when the dist directory","suites":["cache","packaging"],"updatePoint":{"line":3350,"column":49,"index":143587},"line":3350,"code":"    it('should invalidate when the dist directory', async function () {\n      await testCache({\n        async update() {\n          assert(await overlayFS.exists(path.join(distDir, 'index.js')));\n          assert(await overlayFS.exists(path.join(distDir, 'index.js.map')));\n          await overlayFS.rimraf(distDir);\n        }\n      });\n      assert(await overlayFS.exists(path.join(distDir, 'index.js')));\n      assert(await overlayFS.exists(path.join(distDir, 'index.js.map')));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should hit the cache when there are no changes","suites":["cache","packaging"],"updatePoint":{"line":3361,"column":54,"index":144080},"line":3361,"code":"    it('should hit the cache when there are no changes', async function () {\n      let b = await testCache({\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 4);\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a terser config is modified","suites":["cache","packaging"],"updatePoint":{"line":3371,"column":58,"index":144395},"line":3371,"code":"    it('should invalidate when a terser config is modified', async function () {\n      let b = await testCache({\n        mode: 'production',\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.terserrc'), JSON.stringify({\n            mangle: false\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('$parcel$interopDefault'));\n          await overlayFS.writeFile(path.join(inputDir, '.terserrc'), JSON.stringify({\n            mangle: true\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('$parcel$interopDefault'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when an htmlnano config is modified","suites":["cache","packaging"],"updatePoint":{"line":3390,"column":61,"index":145200},"line":3390,"code":"    it('should invalidate when an htmlnano config is modified', async function () {\n      let b = await testCache({\n        mode: 'production',\n        entries: ['src/index.html'],\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.htmlnanorc.json'), JSON.stringify({\n            removeAttributeQuotes: true\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('type=module'));\n          await overlayFS.writeFile(path.join(inputDir, '.htmlnanorc.json'), JSON.stringify({\n            removeAttributeQuotes: false\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('type=\"module\"'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invaldate when adding a compressor plugin","suites":["cache","compression"],"updatePoint":{"line":3412,"column":56,"index":146106},"line":3412,"code":"    it('should invaldate when adding a compressor plugin', async function () {\n      await testCache({\n        async update() {\n          let files = await outputFS.readdir(distDir);\n          assert.deepEqual(files.sort(), ['index.js', 'index.js.map']);\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            compressors: {\n              '*.js': ['...', '@parcel/compressor-gzip']\n            }\n          }));\n        },\n        mode: 'production'\n      });\n      let files = await outputFS.readdir(distDir);\n      assert.deepEqual(files.sort(), ['index.js', 'index.js.gz', 'index.js.map']);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when updating a compressor plugin","suites":["cache","compression"],"updatePoint":{"line":3429,"column":59,"index":146801},"line":3429,"code":"    it('should invalidate when updating a compressor plugin', async function () {\n      await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            compressors: {\n              '*.js': ['...', 'parcel-compressor-test']\n            }\n          }));\n        },\n        async update() {\n          let files = await outputFS.readdir(distDir);\n          assert.deepEqual(files.sort(), ['index.js', 'index.js.abc', 'index.js.map']);\n          let compressor = path.join(inputDir, 'node_modules', 'parcel-compressor-test', 'index.js');\n          await overlayFS.writeFile(compressor, (await overlayFS.readFile(compressor, 'utf8')).replace('abc', 'def'));\n        }\n      });\n      let files = await outputFS.readdir(distDir);\n      assert.deepEqual(files.sort(), ['index.js', 'index.js.abc', 'index.js.def', 'index.js.map']);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding sideEffects config","suites":["cache","scope hoisting"],"updatePoint":{"line":3451,"column":48,"index":147794},"line":3451,"code":"    it('should support adding sideEffects config', function () {});","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating sideEffects config","suites":["cache","scope hoisting"],"updatePoint":{"line":3452,"column":50,"index":147864},"line":3452,"code":"    it('should support updating sideEffects config', function () {});","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support removing sideEffects config","suites":["cache","scope hoisting"],"updatePoint":{"line":3453,"column":50,"index":147934},"line":3453,"code":"    it('should support removing sideEffects config', function () {});","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should wrap modules when they become conditional","suites":["cache","scope hoisting"],"updatePoint":{"line":3454,"column":56,"index":148010},"line":3454,"code":"    it('should wrap modules when they become conditional', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        entries: ['a.js'],\n        async setup() {\n          let contents = await overlayFS.readFile(path.join(inputDir, 'a.js'), 'utf8');\n          await overlayFS.writeFile(path.join(inputDir, 'a.js'), contents.replace(/if \\(b\\) \\{((?:.|\\n)+)\\}/, '$1'));\n        },\n        async update(b) {\n          let out = [];\n          await run(b.bundleGraph, {\n            b: false,\n            output(o) {\n              out.push(o);\n            }\n          });\n          assert.deepEqual(out, ['a', 'b', 'c', 'd']);\n          let contents = await overlayFS.readFile(path.join(__dirname, 'integration/scope-hoisting/commonjs/require-conditional/a.js'), 'utf8');\n          await overlayFS.writeFile(path.join(inputDir, 'a.js'), contents);\n        }\n      }, 'scope-hoisting/commonjs/require-conditional');\n      let out = [];\n      await run(b.bundleGraph, {\n        b: false,\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, ['a', 'd']);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating files added by runtimes","suites":["cache","runtime"],"updatePoint":{"line":3488,"column":55,"index":149214},"line":3488,"code":"    it('should support updating files added by runtimes', async function () {\n      let b = await testCache(async b => {\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(contents.includes('INITIAL CODE'));\n        await overlayFS.writeFile(path.join(inputDir, 'dynamic-runtime.js'), \"module.exports = 'UPDATED CODE'\");\n      }, 'runtime-update');\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('UPDATED CODE'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should create additional assets if multiple query parameter combinations are used","suites":["cache","Query Parameters"],"updatePoint":{"line":3499,"column":89,"index":149855},"line":3499,"code":"    it('Should create additional assets if multiple query parameter combinations are used', async function () {\n      let b = await testCache({\n        entries: ['reformat.html'],\n        update: async b => {\n          let bundles = b.bundleGraph.getBundles();\n          let contents = await overlayFS.readFile(bundles[0].filePath, 'utf8');\n          assert(contents.includes('.webp\" alt=\"test image\">'));\n          assert.equal(bundles.length, 2);\n          await overlayFS.writeFile(path.join(inputDir, 'reformat.html'), `<picture>\n              <source src=\"url:./image.jpg?as=webp&width=400\" type=\"image/webp\" />\n              <source src=\"url:./image.jpg?as=jpg&width=400\" type=\"image/jpeg\" />\n              <img src=\"url:./image.jpg?as=jpg&width=800\" alt=\"test image\" />\n            </picture>`);\n        }\n      }, 'image');\n      let bundles = b.bundleGraph.getBundles();\n      let contents = await overlayFS.readFile(bundles[0].filePath, 'utf8');\n      assert(contents.includes('.webp\" type=\"image/webp\">'));\n      assert(contents.includes('.jpeg\" type=\"image/jpeg\">'));\n      assert(contents.includes('.jpeg\" alt=\"test image\">'));\n      assert.equal(bundles.length, 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly read additional child assets from cache","suites":["cache","Query Parameters"],"updatePoint":{"line":3522,"column":62,"index":151022},"line":3522,"code":"  it('should correctly read additional child assets from cache', async function () {\n    await ncp(path.join(__dirname, '/integration/postcss-modules-cjs'), path.join(inputDir));\n    let entries = 'index.js';\n    let b = await runBundle(entries, {\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    let result1 = (await run(b.bundleGraph))();\n    b = await runBundle(entries, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    let result2 = (await run(b.bundleGraph))();\n    b = await runBundle(entries, {\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    let result3 = (await run(b.bundleGraph))();\n    assert(typeof result1 === 'string' && result1.includes('foo'));\n    assert.strictEqual(result1, result2);\n    assert.strictEqual(result1, result3);\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly read additional child assets from cache 2","suites":["cache","Query Parameters"],"updatePoint":{"line":3547,"column":64,"index":151871},"line":3547,"code":"  it('should correctly read additional child assets from cache 2', async function () {\n    await ncp(path.join(__dirname, '/integration/postcss-modules-cjs'), path.join(inputDir));\n    let entries = 'index.js';\n    await overlayFS.writeFile(path.join(inputDir, 'foo.module.css'), `.foo {\n  color: red;\n}`);\n    let b = await runBundle(entries);\n    let result1 = (await run(b.bundleGraph))();\n    await overlayFS.writeFile(path.join(inputDir, 'foo.module.css'), `.foo {\n  color: blue;\n}`);\n    b = await runBundle(entries);\n    let result2 = (await run(b.bundleGraph))();\n    await overlayFS.writeFile(path.join(inputDir, 'foo.module.css'), `.foo {\n  color: red;\n}`);\n    b = await runBundle(entries);\n    let result3 = (await run(b.bundleGraph))();\n    assert(typeof result1 === 'string' && result1.includes('foo'));\n    assert.strictEqual(result1, result2);\n    assert.strictEqual(result1, result3);\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly reuse intermediate pipeline results when transforming","suites":["cache","Query Parameters"],"updatePoint":{"line":3569,"column":76,"index":152791},"line":3569,"code":"  it('should correctly reuse intermediate pipeline results when transforming', async function () {\n    await ncp(path.join(__dirname, '/integration/json'), path.join(inputDir));\n    let entry = path.join(inputDir, 'index.js');\n    let original = await overlayFS.readFile(entry, 'utf8');\n    let b = await runBundle(entry);\n    let result1 = (await run(b.bundleGraph))();\n    await overlayFS.writeFile(entry, 'module.exports = function(){ return 10; }');\n    b = await runBundle(entry);\n    let result2 = (await run(b.bundleGraph))();\n    await overlayFS.writeFile(entry, original);\n    b = await runBundle(entry);\n    let result3 = (await run(b.bundleGraph))();\n    assert.strictEqual(result1, 3);\n    assert.strictEqual(result2, 10);\n    assert.strictEqual(result3, 3);\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"properly watches included files even after resaving them without changes","suites":["cache","Query Parameters"],"updatePoint":{"line":3585,"column":78,"index":153570},"line":3585,"code":"  it('properly watches included files even after resaving them without changes', async function () {\n    this.timeout(15000);\n    let subscription;\n    let fixture = path.join(__dirname, '/integration/included-file');\n    try {\n      let b = bundler(path.join(fixture, 'index.txt'), {\n        inputFS: overlayFS,\n        shouldDisableCache: false\n      });\n      await overlayFS.mkdirp(fixture);\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'a');\n      subscription = await b.watch();\n      let event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output1 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output1, 'a');\n\n      // Change included file\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'b');\n      event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output2 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output2, 'b');\n\n      // Rewrite included file without change\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'b');\n      event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output3 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output3, 'b');\n\n      // Change included file\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'c');\n      event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output4 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output4, 'c');\n    } finally {\n      if (subscription) {\n        await subscription.unsubscribe();\n        subscription = null;\n      }\n    }\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"properly handles included files even after when changing back to a cached state","suites":["cache","Query Parameters"],"updatePoint":{"line":3629,"column":85,"index":155445},"line":3629,"code":"  it('properly handles included files even after when changing back to a cached state', async function () {\n    this.timeout(15000);\n    let subscription;\n    let fixture = path.join(__dirname, '/integration/included-file');\n    try {\n      let b = bundler(path.join(fixture, 'index.txt'), {\n        inputFS: overlayFS,\n        shouldDisableCache: false\n      });\n      await overlayFS.mkdirp(fixture);\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'a');\n      subscription = await b.watch();\n      let event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output1 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output1, 'a');\n\n      // Change included file\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'b');\n      event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output2 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output2, 'b');\n\n      // Change included file back\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'a');\n      event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output3 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output3, 'a');\n    } finally {\n      if (subscription) {\n        await subscription.unsubscribe();\n        subscription = null;\n      }\n    }\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"properly watches included files after a transformer error","suites":["cache","Query Parameters"],"updatePoint":{"line":3666,"column":63,"index":156959},"line":3666,"code":"  it('properly watches included files after a transformer error', async function () {\n    this.timeout(15000);\n    let subscription;\n    let fixture = path.join(__dirname, '/integration/included-file');\n    try {\n      let b = bundler(path.join(fixture, 'index.txt'), {\n        inputFS: overlayFS,\n        shouldDisableCache: false\n      });\n      await overlayFS.mkdirp(fixture);\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'a');\n      subscription = await b.watch();\n      let event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output1 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output1, 'a');\n\n      // Change included file\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'ERROR');\n      event = await getNextBuild(b);\n      invariant(event.type === 'buildFailure');\n      assert.strictEqual(event.diagnostics[0].message, 'Custom error');\n\n      // Clear transformer error\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'b');\n      event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output3 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output3, 'b');\n    } finally {\n      if (subscription) {\n        await subscription.unsubscribe();\n        subscription = null;\n      }\n    }\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support moving the project root","suites":["cache","Query Parameters"],"updatePoint":{"line":3702,"column":44,"index":158390},"line":3702,"code":"  it('should support moving the project root', async function () {\n    // This test relies on the real filesystem because the memory fs doesn't support renames.\n    // But renameSync is broken on windows in CI with EPERM errors. Just skip this test for now.\n    if (process.platform === 'win32') {\n      return;\n    }\n    let b = await testCache({\n      inputFS,\n      outputFS: inputFS,\n      async setup() {\n        await inputFS.mkdirp(inputDir);\n        await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n      },\n      update: async b => {\n        assert.equal(await run(b.bundleGraph), 4);\n        await inputFS.writeFile(path.join(inputDir, 'src/nested/test.js'), 'export default 4');\n        fs.renameSync(inputDir, inputDir += '_2');\n        await sleep(100);\n      }\n    });\n    assert.equal(await run(b.bundleGraph), 6);\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports multiple empty JS assets","suites":["cache","Query Parameters"],"updatePoint":{"line":3724,"column":39,"index":159245},"line":3724,"code":"  it('supports multiple empty JS assets', async function () {\n    // Try to store multiple empty assets using LMDB\n    let build = await runBundle(path.join(__dirname, 'integration/multiple-empty-js-assets/index.js'), {\n      inputFS,\n      outputFS: inputFS\n    });\n    let a = nullthrows(findAsset(build.bundleGraph, 'a.js'));\n    let b = nullthrows(findAsset(build.bundleGraph, 'a.js'));\n    assert.strictEqual((await a.getBuffer()).length, 0);\n    assert.strictEqual((await b.getBuffer()).length, 0);\n    let res = await run(build.bundleGraph);\n    assert.deepEqual(res, {\n      default: 'foo'\n    });\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not compress output with gzip and brotli in development","suites":["compressors"],"updatePoint":{"line":6,"column":68,"index":250},"line":6,"code":"  it('should not compress output with gzip and brotli in development', async function () {\n    await bundle(path.join(__dirname, 'integration/compressors/index.js'));\n    let output = await outputFS.readdir(distDir);\n    assert.deepEqual(output.sort(), ['index.js', 'index.js.map']);\n  });","file":"compressors.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compress output with gzip and brotli","suites":["compressors"],"updatePoint":{"line":11,"column":49,"index":521},"line":11,"code":"  it('should compress output with gzip and brotli', async function () {\n    await bundle(path.join(__dirname, 'integration/compressors/index.js'), {\n      mode: 'production'\n    });\n    let output = await outputFS.readdir(distDir);\n    assert.deepEqual(output.sort(), ['index.js', 'index.js.br', 'index.js.gz', 'index.js.map', 'index.js.map.br', 'index.js.map.gz']);\n    let raw = await outputFS.readFile(path.join(distDir, 'index.js'));\n    let gz = await outputFS.readFile(path.join(distDir, 'index.js.gz'));\n    let br = await outputFS.readFile(path.join(distDir, 'index.js.br'));\n    assert(zlib.gunzipSync(gz).equals(raw));\n    assert(zlib.brotliDecompressSync(br).equals(raw));\n  });","file":"compressors.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should be able to disable raw output","suites":["compressors"],"updatePoint":{"line":23,"column":42,"index":1204},"line":23,"code":"  it('should be able to disable raw output', async function () {\n    await bundle(path.join(__dirname, 'integration/compressors-disable-default/index.js'), {\n      mode: 'production'\n    });\n    let output = await outputFS.readdir(distDir);\n    assert.deepEqual(output.sort(), ['index.js.br', 'index.js.map.br']);\n  });","file":"compressors.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should merge incomplete config packages","suites":["config merging"],"updatePoint":{"line":5,"column":45,"index":201},"line":5,"code":"  it('should merge incomplete config packages', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/config-merging/index.js'));\n    let content = (await outputFS.readFile(path.join(__dirname, '/integration/config-merging/dist/index.js'))).toString();\n    assert(content.includes('runtime injected'));\n    assert.equal((await run(b)).default, 'Hello world!');\n  });","file":"config-merging.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update content hash when content changes","suites":["content hashing"],"updatePoint":{"line":18,"column":53,"index":532},"line":18,"code":"  it('should update content hash when content changes', async function () {\n    await ncp(path.join(__dirname, '/integration/html-css'), path.join(__dirname, '/input'));\n    let bundleHtml = () => bundle(path.join(__dirname, '/input/index.html'));\n    await bundleHtml();\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    let filename = html.match(/<link rel=\"stylesheet\" href=\"[/\\\\]{1}(index\\.[a-f0-9]+\\.css)\">/)[1];\n    assert(await outputFS.exists(path.join(distDir, filename)));\n    await outputFS.writeFile(path.join(__dirname, '/input/index.css'), 'body { background: green }');\n    await bundleHtml();\n    html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    let newFilename = html.match(/<link rel=\"stylesheet\" href=\"[/\\\\]{1}(index\\.[a-f0-9]+\\.css)\">/)[1];\n    assert(await outputFS.exists(path.join(distDir, newFilename)));\n    assert.notEqual(filename, newFilename);\n  });","file":"contentHashing.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update content hash when raw asset changes","suites":["content hashing"],"updatePoint":{"line":32,"column":55,"index":1478},"line":32,"code":"  it('should update content hash when raw asset changes', async function () {\n    await ncp(path.join(__dirname, '/integration/import-raw'), path.join(__dirname, '/input'));\n    let bundleJs = () => bundle(path.join(__dirname, '/input/index.js'));\n    await bundleJs();\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    let filename = js.match(/(test\\.[0-9a-f]+\\.txt)/)[1];\n    assert(await outputFS.exists(path.join(distDir, filename)));\n    await outputFS.writeFile(path.join(__dirname, '/input/test.txt'), 'hello world');\n    await bundleJs();\n    js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    let newFilename = js.match(/(test\\.[0-9a-f]+\\.txt)/)[1];\n    assert(await outputFS.exists(path.join(distDir, newFilename)));\n    assert.notEqual(filename, newFilename);\n  });","file":"contentHashing.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should consider bundles with identical contents coming from different filepaths unique","suites":["content hashing"],"updatePoint":{"line":46,"column":92,"index":2347},"line":46,"code":"  it('should consider bundles with identical contents coming from different filepaths unique', async () => {\n    await _bundle(path.join(__dirname, 'integration/same-contents-different-filepaths/index.js'));\n  });","file":"contentHashing.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate the same hash for the same distDir inside separate projects","suites":["content hashing"],"updatePoint":{"line":49,"column":81,"index":2550},"line":49,"code":"  it('should generate the same hash for the same distDir inside separate projects', async () => {\n    let a = await _bundle(path.join(__dirname, 'integration/hash-distDir/a/index.html'), {\n      sourceMaps: true\n    });\n    let b = await _bundle(path.join(__dirname, 'integration/hash-distDir/b/index.html'), {\n      sourceMaps: true\n    });\n    let aBundles = a.getBundles();\n    let bBundles = b.getBundles();\n    assert.equal(aBundles.length, 2);\n    assert.equal(bBundles.length, 2);\n    let aJS = aBundles.find(bundle => bundle.type === 'js');\n    let bJS = bBundles.find(bundle => bundle.type === 'js');\n    assert(/index\\.[a-f0-9]*\\.js/.test(path.basename(aJS.filePath)));\n    assert.equal(aJS.name, bJS.name);\n  });","file":"contentHashing.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming css modules (require)","suites":["css modules"],"updatePoint":{"line":6,"column":55,"index":268},"line":6,"code":"  it('should support transforming css modules (require)', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-modules-cjs/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'foo.module.css']\n    }, {\n      name: 'index.css',\n      assets: ['index.css', 'foo.module.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let value = output();\n    assert(/[_0-9a-zA-Z]+_foo/.test(value));\n    let cssClass = value.match(/([_0-9a-zA-Z]+_foo)/)[1];\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes(`.${cssClass}`));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming css modules (import default)","suites":["css modules"],"updatePoint":{"line":23,"column":62,"index":955},"line":23,"code":"  it('should support transforming css modules (import default)', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-modules-import-default/index.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'style.module.css']\n    }, {\n      name: 'index.css',\n      assets: ['style.module.css']\n    }]);\n    let output = await run(b);\n    assert(/[_0-9a-zA-Z]+_b-2/.test(output));\n    let css = await outputFS.readFile(b.getBundles().find(b => b.type === 'css').filePath, 'utf8');\n    let includedRules = new Set();\n    postcss.parse(css).walkRules(rule => {\n      includedRules.add(rule.selector);\n    });\n    assert(includedRules.has('.page'));\n    assert(includedRules.has(`.${output}`));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should tree shake unused css modules classes with a namespace import","suites":["css modules"],"updatePoint":{"line":44,"column":74,"index":1751},"line":44,"code":"  it('should tree shake unused css modules classes with a namespace import', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-modules-import-namespace/index.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'style.module.css']\n    }, {\n      name: 'index.css',\n      assets: ['global.css', 'style.module.css']\n    }]);\n    let js = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n    assert(!js.includes('unused'));\n    let output = await run(b);\n    assert(/[_0-9a-zA-Z]+_b-2/.test(output));\n    let css = await outputFS.readFile(b.getBundles().find(b => b.type === 'css').filePath, 'utf8');\n    let includedRules = new Set();\n    postcss.parse(css).walkRules(rule => {\n      includedRules.add(rule.selector);\n    });\n    assert.deepStrictEqual(includedRules, new Set(['body', `.${output}`, '.page']));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce correct css without symbol propagation for css modules classes with a namespace import","suites":["css modules"],"updatePoint":{"line":66,"column":107,"index":2730},"line":66,"code":"  it('should produce correct css without symbol propagation for css modules classes with a namespace import', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-modules-import-namespace/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'style.module.css']\n    }, {\n      name: 'index.css',\n      assets: ['global.css', 'style.module.css']\n    }]);\n    let {\n      output\n    } = await run(b, null, {\n      require: false\n    });\n    assert(/[_0-9a-zA-Z]+_b-2/.test(output));\n    let css = await outputFS.readFile(b.getBundles().find(b => b.type === 'css').filePath, 'utf8');\n    let includedRules = new Set();\n    postcss.parse(css).walkRules(rule => {\n      includedRules.add(rule.selector);\n    });\n    assert(includedRules.has('body'));\n    assert(includedRules.has(`.${output}`));\n    assert(includedRules.has('.page'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing css modules with a non-static namespace import","suites":["css modules"],"updatePoint":{"line":95,"column":77,"index":3705},"line":95,"code":"  it('should support importing css modules with a non-static namespace import', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-modules-import-namespace-whole/index.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'style.module.css']\n    }, {\n      name: 'index.css',\n      assets: ['global.css', 'style.module.css']\n    }]);\n    let js = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n    assert(js.includes('unused'));\n    let output = await run(b);\n    assert(/[_0-9a-zA-Z]+_b-2/.test(output['b-2']));\n    assert(/[_0-9a-zA-Z]+_unused/.test(output['unused']));\n    let css = await outputFS.readFile(b.getBundles().find(b => b.type === 'css').filePath, 'utf8');\n    let includedRules = new Set();\n    postcss.parse(css).walkRules(rule => {\n      includedRules.add(rule.selector);\n    });\n    assert.deepStrictEqual(includedRules, new Set(['body', `.${output['b-2']}`, `.${output['unused']}`, '.page']));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support css modules composes imports","suites":["css modules"],"updatePoint":{"line":118,"column":49,"index":4728},"line":118,"code":"  it('should support css modules composes imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-composes/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'composes-1.module.css', 'composes-2.module.css', 'mixins.module.css']\n    }, {\n      name: 'index.css',\n      assets: ['composes-1.module.css', 'composes-2.module.css', 'mixins.module.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let value = output();\n    const composes1Classes = value.composes1.split(' ');\n    const composes2Classes = value.composes2.split(' ');\n    assert(composes1Classes[0].endsWith('_composes1'));\n    assert(composes1Classes[1].endsWith('_test'));\n    assert(composes2Classes[0].endsWith('_composes2'));\n    assert(composes2Classes[1].endsWith('_test'));\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    let cssClass1 = value.composes1.match(/([_0-9a-zA-Z]+_composes1)/)[1];\n    assert(css.includes(`.${cssClass1}`));\n    let cssClass2 = value.composes2.match(/([_0-9a-zA-Z]+_composes2)/)[1];\n    assert(css.includes(`.${cssClass2}`));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not include css twice for composes imports","suites":["css modules"],"updatePoint":{"line":142,"column":55,"index":5917},"line":142,"code":"  it('should not include css twice for composes imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-composes/index.js'));\n    await run(b);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert.equal(css.indexOf('height: 100px;'), css.lastIndexOf('height: 100px;'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support composes imports for sass","suites":["css modules"],"updatePoint":{"line":148,"column":46,"index":6258},"line":148,"code":"  it('should support composes imports for sass', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-composes/index2.js'));\n    assertBundles(b, [{\n      name: 'index2.js',\n      assets: ['index2.js', 'composes-3.module.css', 'mixins.module.scss']\n    }, {\n      name: 'index2.css',\n      assets: ['composes-3.module.css', 'mixins.module.scss']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let value = output();\n    const composes3Classes = value.composes3.split(' ');\n    assert(composes3Classes[0].endsWith('_composes3'));\n    assert(composes3Classes[1].endsWith('_test'));\n    let css = await outputFS.readFile(path.join(distDir, 'index2.css'), 'utf8');\n    assert(css.includes('height: 200px;'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support composes imports with custom path names","suites":["css modules"],"updatePoint":{"line":166,"column":60,"index":7053},"line":166,"code":"  it('should support composes imports with custom path names', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-composes/index3.js'));\n    assertBundles(b, [{\n      name: 'index3.js',\n      assets: ['index3.js', 'composes-4.module.css', 'mixins.module.css']\n    }, {\n      name: 'index3.css',\n      assets: ['composes-4.module.css', 'mixins.module.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let value = output();\n    const composes4Classes = value.composes4.split(' ');\n    assert(composes4Classes[0].endsWith('_composes4'));\n    assert(composes4Classes[1].endsWith('_test'));\n    let css = await outputFS.readFile(path.join(distDir, 'index3.css'), 'utf8');\n    assert(css.includes('height: 100px;'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deep nested composes imports","suites":["css modules"],"updatePoint":{"line":184,"column":49,"index":7835},"line":184,"code":"  it('should support deep nested composes imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-composes/index4.js'));\n    assertBundles(b, [{\n      name: 'index4.js',\n      assets: ['index4.js', 'composes-5.module.css', 'mixins-intermediate.module.css', 'mixins.module.css']\n    }, {\n      name: 'index4.css',\n      assets: ['composes-5.module.css', 'mixins-intermediate.module.css', 'mixins.module.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let value = output();\n    const composes5Classes = value.composes5.split(' ');\n    assert(composes5Classes[0].endsWith('_composes5'));\n    assert(composes5Classes[1].endsWith('_intermediate'));\n    assert(composes5Classes[2].endsWith('_test'));\n    let css = await outputFS.readFile(path.join(distDir, 'index4.css'), 'utf8');\n    assert(css.includes('height: 100px;'));\n    assert(css.includes('height: 300px;'));\n    assert(css.indexOf('_test') < css.indexOf('_intermediate'));\n    assert(css.indexOf('_intermediate') < css.indexOf('_composes5'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support composes imports for multiple selectors","suites":["css modules"],"updatePoint":{"line":206,"column":60,"index":8934},"line":206,"code":"  it('should support composes imports for multiple selectors', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-composes/index5.js'));\n    assertBundles(b, [{\n      name: 'index5.js',\n      assets: ['index5.js', 'composes-6.module.css', 'mixins.module.css']\n    }, {\n      name: 'index5.css',\n      assets: ['composes-6.module.css', 'mixins.module.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let value = output();\n    const composes6Classes = value.composes6.split(' ');\n    assert(composes6Classes[0].endsWith('_composes6'));\n    assert(composes6Classes[1].endsWith('_test'));\n    assert(composes6Classes[2].endsWith('_test-2'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw an error when importing a missing class","suites":["css modules"],"updatePoint":{"line":223,"column":58,"index":9653},"line":223,"code":"  it('should throw an error when importing a missing class', async function () {\n    await assert.rejects(() => bundle(path.join(__dirname, '/integration/no-export-error-with-correct-filetype/src/App.jsx'), {\n      shouldDisableCache: true,\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/no-export-error-with-correct-filetype/src/App.jsx'),\n          language: 'js',\n          codeHighlights: [{\n            end: {\n              column: 45,\n              line: 7\n            },\n            start: {\n              column: 28,\n              line: 7\n            }\n          }]\n        }],\n        message: \"integration/no-export-error-with-correct-filetype/src/app.module.css does not export 'notExisting'\",\n        origin: '@parcel/core'\n      }]\n    });\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should fall back to postcss for legacy css modules","suites":["css modules"],"updatePoint":{"line":251,"column":56,"index":10568},"line":251,"code":"  it('should fall back to postcss for legacy css modules', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-modules-legacy/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'index.css',\n      assets: ['index.module.css']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('color: red'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should fall back to postcss for legacy css modules with :export","suites":["css modules"],"updatePoint":{"line":263,"column":69,"index":11051},"line":263,"code":"  it('should fall back to postcss for legacy css modules with :export', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-modules-legacy/b.js'));\n    assertBundles(b, [{\n      name: 'b.js',\n      assets: ['b.js', 'b.module.css']\n    }, {\n      name: 'b.css',\n      assets: ['b.module.css']\n    }]);\n    let res = await run(b);\n    assert.deepEqual(res, {\n      color: 'red'\n    });\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should optimize away unused @keyframes","suites":["css modules"],"updatePoint":{"line":277,"column":44,"index":11448},"line":277,"code":"  it('should optimize away unused @keyframes', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-modules-keyframes/index.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'index.css',\n      assets: ['index.module.css']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(/@keyframes _[_0-9a-zA-Z]+_test/.test(css));\n    assert(!css.includes('unused'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not double optimize css modules processed with postcss","suites":["css modules"],"updatePoint":{"line":292,"column":67,"index":12019},"line":292,"code":"  it('should not double optimize css modules processed with postcss', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-modules-optimize/index.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'index.css']\n    }, {\n      name: 'index.css',\n      assets: ['index.css']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('@keyframes test'));\n    assert(css.includes('@keyframes unused'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile css modules for multiple targets","suites":["css modules"],"updatePoint":{"line":307,"column":53,"index":12564},"line":307,"code":"  it('should compile css modules for multiple targets', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-modules-targets/index.html'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js', 'foo.module.css']\n    }, {\n      type: 'js',\n      assets: ['index.js', 'foo.module.css']\n    }, {\n      type: 'css',\n      assets: ['foo.module.css']\n    }]);\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle @import in css modules","suites":["css modules"],"updatePoint":{"line":326,"column":42,"index":13179},"line":326,"code":"  it('should handle @import in css modules', async function () {\n    let b = await bundle([path.join(__dirname, '/integration/css-modules-import/page1.html'), path.join(__dirname, '/integration/css-modules-import/page2.html')], {\n      mode: 'production'\n    });\n    let res = [];\n    await runBundle(b, b.getBundles().find(b => b.name === 'page1.html'), {\n      sideEffect: s => res.push(s)\n    });\n    assert.deepEqual(res, [['page1', '_1ZEqVW_a']]);\n    res = [];\n    await runBundle(b, b.getBundles().find(b => b.name === 'page2.html'), {\n      sideEffect: s => res.push(s)\n    });\n    assert.deepEqual(res, [['page2', '_4fY2uG_foo _1ZEqVW_foo j1UkRG_foo']]);\n    assertBundles(b, [{\n      name: 'page1.html',\n      assets: ['page1.html']\n    }, {\n      name: 'page2.html',\n      assets: ['page2.html']\n    }, {\n      type: 'js',\n      assets: ['page1.js', 'index.module.css', 'a.module.css', 'b.module.css']\n    }, {\n      type: 'js',\n      assets: ['page2.js', 'index.module.css', 'a.module.css', 'b.module.css']\n    }, {\n      type: 'css',\n      assets: ['a.module.css', 'b.module.css']\n    }, {\n      type: 'css',\n      assets: ['index.module.css']\n    }]);\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not process inline <style> elements as a CSS module","suites":["css modules"],"updatePoint":{"line":360,"column":64,"index":14373},"line":360,"code":"  it('should not process inline <style> elements as a CSS module', async function () {\n    await bundle(path.join(__dirname, '/integration/css-modules-style/index.html'));\n    let contents = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(contents.includes('.index {'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support global css modules via boolean config","suites":["css modules"],"updatePoint":{"line":365,"column":58,"index":14674},"line":365,"code":"  it('should support global css modules via boolean config', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-modules-global/a/index.js'), {\n      mode: 'production'\n    });\n    let res = await run(b);\n    assert.deepEqual(res, 'C-gzXq_foo');\n    let contents = await outputFS.readFile(b.getBundles().find(b => b.type === 'css').filePath, 'utf8');\n    assert(contents.includes('.C-gzXq_foo'));\n    assert(contents.includes('.x'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support global css modules via object config","suites":["css modules"],"updatePoint":{"line":375,"column":57,"index":15145},"line":375,"code":"  it('should support global css modules via object config', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-modules-global/b/index.js'), {\n      mode: 'production'\n    });\n    let res = await run(b);\n    assert.deepEqual(res, 'C-gzXq_foo');\n    let contents = await outputFS.readFile(b.getBundles().find(b => b.type === 'css').filePath, 'utf8');\n    assert(contents.includes('.C-gzXq_foo'));\n    assert(contents.includes('.x'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should optimize away unused variables when dashedIdents option is used","suites":["css modules"],"updatePoint":{"line":385,"column":76,"index":15635},"line":385,"code":"  it('should optimize away unused variables when dashedIdents option is used', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-modules-vars/index.js'), {\n      mode: 'production'\n    });\n    let contents = await outputFS.readFile(b.getBundles().find(b => b.type === 'css').filePath, 'utf8');\n    assert.equal(contents.split('\\n')[0], ':root{--wGsoEa_color:red;--wGsoEa_font:Helvetica;--wGsoEa_theme-sizes-1\\\\/12:2;--wGsoEa_from-js:purple}body{font:var(--wGsoEa_font)}._4fY2uG_foo{color:var(--wGsoEa_color);width:var(--wGsoEa_theme-sizes-1\\\\/12);height:var(--height)}');\n    let res = await run(b);\n    assert.deepEqual(res, ['_4fY2uG_foo', '--wGsoEa_from-js']);\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should group together css and css modules into one bundle","suites":["css modules"],"updatePoint":{"line":394,"column":63,"index":16326},"line":394,"code":"  it('should group together css and css modules into one bundle', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-module-css-siblings/index.html'));\n    let res = [];\n    await runBundle(b, b.getBundles().find(b => b.name === 'index.html'), {\n      sideEffect: s => res.push(s)\n    });\n    assert.deepEqual(res, [['mainJs', '_1ZEqVW_myClass', 'j1UkRG_myOtherClass']]);\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bundle css modules siblings together and their JS assets","suites":["css modules"],"updatePoint":{"line":402,"column":69,"index":16743},"line":402,"code":"  it('should bundle css modules siblings together and their JS assets', async function () {\n    // This issue was first documented here\n    // https://github.com/parcel-bundler/parcel/issues/8716\n    let b = await bundle(path.join(__dirname, '/integration/css-modules-merging-siblings/index.html'));\n    let res = [];\n    await runBundle(b, b.getBundles().find(b => b.name === 'index.html'), {\n      sideEffect: s => res.push(s)\n    });\n    // Result is  [ 'mainJs', 'SX8vmq_container YpGmra_-expand' ]\n    assert.deepEqual(res[0][0], 'mainJs');\n    assert(res[0][1].includes('container') && res[0][1].includes('expand'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce two bundles when importing a CSS file","suites":["css"],"updatePoint":{"line":8,"column":58,"index":316},"line":8,"code":"  it('should produce two bundles when importing a CSS file', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/css/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'local.js', 'c.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.css', 'local.css', 'c.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert.ok(css.indexOf('.c {') < css.indexOf('.local {'));\n    assert.ok(css.indexOf('.local {') < css.indexOf('.index {'));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bundle css dependencies in the correct, postorder traversal order","suites":["css"],"updatePoint":{"line":24,"column":78,"index":997},"line":24,"code":"  it('should bundle css dependencies in the correct, postorder traversal order', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/css-order/a.css'));\n\n    // Given a tree of css with imports:\n    //      A\n    //    /   \\\n    //   B     E\n    //  / \\\n    // C   D\n    //\n    // (A imports B (which imports C and D) and E)\n    //\n    // ...styles should be applied in the order C, D, B, E, A\n\n    assertBundles(b, [{\n      name: 'a.css',\n      assets: ['a.css', 'b.css', 'c.css', 'd.css', 'e.css']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'a.css'), 'utf8');\n    assert.ok(css.indexOf('.c {') < css.indexOf('.d {') && css.indexOf('.d {') < css.indexOf('.b {') && css.indexOf('.b {') < css.indexOf('.e {') && css.indexOf('.e {') < css.indexOf('.a {'));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support loading a CSS bundle along side dynamic imports","suites":["css"],"updatePoint":{"line":45,"column":68,"index":1793},"line":45,"code":"  it('should support loading a CSS bundle along side dynamic imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-css/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['bundle-url.js', 'cacheLoader.js', 'css-loader.js', 'index.js', 'js-loader.js']\n    }, {\n      name: /local\\.[0-9a-f]{8}\\.js/,\n      assets: ['local.js']\n    }, {\n      name: /local\\.[0-9a-f]{8}\\.css/,\n      assets: ['local.css']\n    }, {\n      name: 'index.css',\n      assets: ['index.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 3);\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing CSS from a CSS file","suites":["css"],"updatePoint":{"line":64,"column":50,"index":2428},"line":64,"code":"  it('should support importing CSS from a CSS file', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-import/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.css', 'other.css', 'local.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, '/index.css'), 'utf8');\n    assert(css.includes('.local'));\n    assert(css.includes('.other'));\n    assert(/@media print {\\s*.other/.test(css));\n    assert(css.includes('.index'));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support linking to assets with url() from CSS","suites":["css"],"updatePoint":{"line":82,"column":58,"index":3116},"line":82,"code":"  it('should support linking to assets with url() from CSS', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.css']\n    }, {\n      type: 'woff2',\n      assets: ['test.woff2']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(/url\\(\"test\\.[0-9a-f]+\\.woff2\"\\)/.test(css));\n    assert(css.includes('url(\"http://google.com\")'));\n    assert(css.includes('.index'));\n    assert(css.includes('url(\"data:image/gif;base64,quotes\")'));\n    assert(css.includes('.quotes'));\n    assert(css.includes('url(\"data:image/gif;base64,no-quote\")'));\n    assert(css.includes('.no-quote'));\n    assert(await outputFS.exists(path.join(distDir, css.match(/url\\(\"(test\\.[0-9a-f]+\\.woff2)\"\\)/)[1])));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support linking to assets with url() from CSS in production","suites":["css"],"updatePoint":{"line":107,"column":72,"index":4151},"line":107,"code":"  it('should support linking to assets with url() from CSS in production', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-url/index.js'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.css']\n    }, {\n      type: 'woff2',\n      assets: ['test.woff2']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(/url\\(test\\.[0-9a-f]+\\.woff2\\)/.test(css), 'woff ext found in css');\n    assert(css.includes('url(http://google.com)'), 'url() found');\n    assert(css.includes('.index'), '.index found');\n    assert(/url\\(\"?data:image\\/gif;base64,quotes\"?\\)/.test(css));\n    assert(css.includes('.quotes'));\n    assert(/url\\(\"?data:image\\/gif;base64,no-quote\"?\\)/.test(css));\n    assert(css.includes('.no-quote'));\n    assert(await outputFS.exists(path.join(distDir, css.match(/url\\((test\\.[0-9a-f]+\\.woff2)\\)/)[1])));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support linking to assets in parent folders with url() from CSS","suites":["css"],"updatePoint":{"line":136,"column":76,"index":5318},"line":136,"code":"  it('should support linking to assets in parent folders with url() from CSS', async function () {\n    let b = await bundle([path.join(__dirname, '/integration/css-url-relative/src/a/style1.css'), path.join(__dirname, '/integration/css-url-relative/src/b/style2.css')], {\n      defaultTargetOptions: {\n        shouldOptimize: true,\n        sourceMaps: false\n      }\n    });\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['style1.css']\n    }, {\n      type: 'css',\n      assets: ['style2.css']\n    }, {\n      type: 'png',\n      assets: ['foo.png']\n    }]);\n    let cssPath = path.join(distDir, 'a', 'style1.css');\n    let css = await outputFS.readFile(cssPath, 'utf8');\n    assert(css.includes('background-image'), 'includes `background-image`');\n    assert(/url\\([^)]*\\)/.test(css), 'includes url()');\n    assert(await outputFS.exists(path.resolve(path.dirname(cssPath), css.match(/url\\(([^)]*)\\)/)[1])), 'path specified in url() exists');\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle quote in CSS URL correctly","suites":["css"],"updatePoint":{"line":159,"column":46,"index":6244},"line":159,"code":"  it('should handle quote in CSS URL correctly', async function () {\n    await bundle(path.join(__dirname, '/integration/css-url-quote/index.css'));\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('url(\"data:image/svg+xml;utf8,with quote \\\\\" and escape \\\\\\\\\");'));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore url() with IE behavior specifiers","suites":["css"],"updatePoint":{"line":164,"column":53,"index":6578},"line":164,"code":"  it('should ignore url() with IE behavior specifiers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-url-behavior/index.css'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.css']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('url(\"#default#VML\")'));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw a diagnostic for relative url() dependencies in custom properties","suites":["css"],"updatePoint":{"line":173,"column":84,"index":6997},"line":173,"code":"  it('should throw a diagnostic for relative url() dependencies in custom properties', async function () {\n    let fixture = path.join(__dirname, 'integration/css-url-custom-property/index.css');\n    let code = await inputFS.readFileSync(fixture, 'utf8');\n    // $FlowFixMe\n    await assert.rejects(() => bundle(fixture, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: \"Ambiguous url('foo.png') in custom property. Relative paths are resolved from the location the var() is used, not where the custom property is defined. Use an absolute URL instead\",\n        origin: '@parcel/transformer-css',\n        name: 'SyntaxError',\n        stack: undefined,\n        codeFrames: [{\n          filePath: fixture,\n          code,\n          codeHighlights: [{\n            start: {\n              line: 2,\n              column: 11\n            },\n            end: {\n              line: 2,\n              column: 11\n            }\n          }]\n        }],\n        hints: ['Replace with: url(/integration/css-url-custom-property/foo.png)'],\n        documentationURL: 'https://parceljs.org/languages/css/#url()'\n      }]\n    });\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify CSS when minify is set","suites":["css"],"updatePoint":{"line":207,"column":42,"index":8165},"line":207,"code":"  it('should minify CSS when minify is set', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/cssnano/index.js'), {\n      defaultTargetOptions: {\n        shouldOptimize: true,\n        sourceMaps: false\n      }\n    });\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.local'));\n    assert(css.includes('.index'));\n    assert.equal(css.split('\\n').length, 1);\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a sourcemap when sourceMaps are used","suites":["css"],"updatePoint":{"line":222,"column":57,"index":8739},"line":222,"code":"  it('should produce a sourcemap when sourceMaps are used', async function () {\n    await bundle(path.join(__dirname, '/integration/cssnano/index.js'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.local'));\n    assert(css.includes('.index'));\n    let lines = css.trim().split('\\n');\n    assert.equal(lines.length, 2);\n    assert.equal(lines[1], '/*# sourceMappingURL=index.css.map */');\n    let map = JSON.parse(await outputFS.readFile(path.join(distDir, 'index.css.map'), 'utf8'));\n    assert.equal(map.file, 'index.css.map');\n    assert(map.sources.includes('integration/cssnano/local.css'));\n    assert(map.sources.includes('integration/cssnano/index.css'));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline data-urls for text-encoded files","suites":["css"],"updatePoint":{"line":239,"column":52,"index":9540},"line":239,"code":"  it('should inline data-urls for text-encoded files', async () => {\n    await bundle(path.join(__dirname, '/integration/data-url/text.css'), {\n      defaultTargetOptions: {\n        sourceMaps: false\n      }\n    });\n    let css = await outputFS.readFile(path.join(distDir, 'text.css'), 'utf8');\n    assert.equal(css.trim(), `.svg-img {\n  background-image: url(\"data:image/svg+xml,%3Csvg%20width%3D%22120%22%20height%3D%22120%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%20%20%3Cfilter%20id%3D%22blur-_.%21~%2a%22%3E%0A%20%20%20%20%3CfeGaussianBlur%20stdDeviation%3D%225%22%3E%3C%2FfeGaussianBlur%3E%0A%20%20%3C%2Ffilter%3E%0A%20%20%3Ccircle%20cx%3D%2260%22%20cy%3D%2260%22%20r%3D%2250%22%20fill%3D%22green%22%20filter%3D%22url%28%27%23blur-_.%21~%2a%27%29%22%3E%3C%2Fcircle%3E%0A%3C%2Fsvg%3E%0A\");\n}`);\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline data-urls for binary files","suites":["css"],"updatePoint":{"line":250,"column":46,"index":10360},"line":250,"code":"  it('should inline data-urls for binary files', async () => {\n    await bundle(path.join(__dirname, '/integration/data-url/binary.css'));\n    let css = await outputFS.readFile(path.join(distDir, 'binary.css'), 'utf8');\n    assert(css.startsWith(`.webp-img {\n  background-image: url(\"data:image/webp;base64,UklGR`));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remap locations in diagnostics using the input source map","suites":["css"],"updatePoint":{"line":256,"column":70,"index":10707},"line":256,"code":"  it('should remap locations in diagnostics using the input source map', async () => {\n    let fixture = path.join(__dirname, 'integration/diagnostic-sourcemap/index.scss');\n    let code = await inputFS.readFileSync(fixture, 'utf8');\n    // $FlowFixMe\n    await assert.rejects(() => bundle(fixture, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: \"Failed to resolve 'x.png' from './index.scss'\",\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: fixture,\n          code,\n          codeHighlights: [{\n            start: {\n              line: 5,\n              column: 3\n            },\n            end: {\n              line: 5,\n              column: 3\n            }\n          }]\n        }]\n      }, {\n        message: \"Cannot load file './x.png' in './'.\",\n        origin: '@parcel/resolver-default',\n        hints: []\n      }]\n    });\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing CSS from node_modules with the npm: scheme","suites":["css"],"updatePoint":{"line":290,"column":73,"index":11670},"line":290,"code":"  it('should support importing CSS from node_modules with the npm: scheme', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/css-node-modules/index.css'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.css', 'foo.css']\n    }]);\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the style package exports condition","suites":["css"],"updatePoint":{"line":297,"column":56,"index":11937},"line":297,"code":"  it('should support the style package exports condition', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/css-exports/index.css'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.css', 'foo.css']\n    }]);\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support external CSS imports","suites":["css"],"updatePoint":{"line":304,"column":41,"index":12184},"line":304,"code":"  it('should support external CSS imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/css-external/a.css'));\n    assertBundles(b, [{\n      name: 'a.css',\n      assets: ['a.css', 'b.css']\n    }]);\n    let res = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(new RegExp(`@import \"http://example.com/external.css\";\n.b {\n  color: red;\n}\\n?\n.a {\n  color: green;\n}`).test(res));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support css nesting with lightningcss","suites":["css"],"updatePoint":{"line":319,"column":50,"index":12629},"line":319,"code":"  it('should support css nesting with lightningcss', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-nesting/a.css'), {\n      defaultTargetOptions: {\n        engines: {}\n      }\n    });\n    let res = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(res.includes('.foo.bar'));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a basic Elm bundle","suites":["elm"],"updatePoint":{"line":5,"column":39,"index":208},"line":5,"code":"  it('should produce a basic Elm bundle', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/elm/index.js'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['Main.elm', 'index.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output().Elm.Main.init, 'function');\n  });","file":"elm.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a elm bundle with debugger","suites":["elm"],"updatePoint":{"line":14,"column":47,"index":543},"line":14,"code":"  it('should produce a elm bundle with debugger', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/elm/index.js'));\n    await run(b);\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(js.includes('elm$browser$Debugger'));\n  });","file":"elm.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should apply elm-hot if HMR is enabled","suites":["elm"],"updatePoint":{"line":20,"column":44,"index":838},"line":20,"code":"  it('should apply elm-hot if HMR is enabled', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/elm/index.js'), {\n      hmrOptions: true\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['Main.elm', 'index.js']\n    }]);\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(js.includes('[elm-hot]'));\n  });","file":"elm.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove debugger in production","suites":["elm"],"updatePoint":{"line":31,"column":42,"index":1224},"line":31,"code":"  it('should remove debugger in production', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/elm/index.js'), {\n      mode: 'production'\n    });\n    await run(b);\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!js.includes('elm$browser$Debugger'));\n  });","file":"elm.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove debugger when environment variable `PARCEL_ELM_NO_DEBUG` is set to true","suites":["elm"],"updatePoint":{"line":39,"column":91,"index":1601},"line":39,"code":"  it('should remove debugger when environment variable `PARCEL_ELM_NO_DEBUG` is set to true', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/elm/index.js'), {\n      env: {\n        PARCEL_ELM_NO_DEBUG: true\n      }\n    });\n    await run(b);\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!js.includes('elm$browser$Debugger'));\n  });","file":"elm.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify Elm in production mode","suites":["elm"],"updatePoint":{"line":49,"column":42,"index":1959},"line":49,"code":"  it('should minify Elm in production mode', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/elm/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    await run(b);\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!js.includes('elm$core'));\n    assert(js.includes('Elm'));\n    assert(js.includes('init'));\n  });","file":"elm.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce correct formatting and indentation when compilation fails","suites":["elm"],"updatePoint":{"line":62,"column":78,"index":2444},"line":62,"code":"  it('should produce correct formatting and indentation when compilation fails', async function () {\n    const normalizedPath = path.normalize('test/integration/elm-compile-error/src/Main.elm');\n    await assert.rejects(() => bundle(path.join(__dirname, 'integration/elm-compile-error/index.js'), {\n      mode: 'production'\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: '\\n' + `-- TYPE MISMATCH --------------- ${normalizedPath}\\n` + '\\n' + 'The 1st argument to `text` is not what I expect:\\n' + '\\n' + '7|     Html.text 5 \"Hello, world!\"\\n' + '                 **^**\\n' + 'This argument is a number of type:\\n' + '\\n' + '    **number**\\n' + '\\n' + 'But `text` needs the 1st argument to be:\\n' + '\\n' + '    **String**\\n' + '\\n' + '__Hint__: Try using **String.fromInt** to convert it to a string?',\n        origin: '@parcel/elm-transformer',\n        stack: ''\n      }, {\n        message: '\\n' + `-- TOO MANY ARGS --------------- ${normalizedPath}\\n` + '\\n' + 'The `text` function expects 1 argument, but it got 2 instead.\\n' + '\\n' + '7|     Html.text 5 \"Hello, world!\"\\n' + '       **^^^^^^^^^**\\n' + 'Are there any missing commas? Or missing parentheses?',\n        origin: '@parcel/elm-transformer',\n        stack: ''\n      }]\n    });\n  });","file":"elm.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce extra Modules given in \"with\" query param","suites":["elm"],"updatePoint":{"line":79,"column":62,"index":3701},"line":79,"code":"  it('should produce extra Modules given in \"with\" query param', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/elm-multiple-apps/src/index.js'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['Main.elm', 'index.js', 'esmodule-helpers.js']\n    }]);\n    const output = await run(b);\n    const Elm = output.default();\n    assert.equal(typeof Elm.Main.init, 'function');\n    assert.equal(typeof Elm.MainB.init, 'function');\n    assert.equal(typeof Elm.MainC.init, 'function');\n  });","file":"elm.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling files which names in encoded URI","suites":["encodedURI"],"updatePoint":{"line":5,"column":62,"index":218},"line":5,"code":"  it('should support bundling files which names in encoded URI', async function () {\n    await bundle(path.join(__dirname, '/integration/encodedURI/index.html'));\n    let files = await outputFS.readdir(distDir);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    for (let file of files) {\n      if (file !== 'index.html') {\n        assert(html.includes(file));\n      }\n    }\n    assert(!!files.find(f => f.startsWith('')));\n  });","file":"encodedURI.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw validation error with eslint errors","suites":["eslint-validator"],"updatePoint":{"line":6,"column":54,"index":283},"line":6,"code":"  it('should throw validation error with eslint errors', async function () {\n    let didThrow = false;\n    let entry = path.join(__dirname, '/integration/eslint-error/index.js');\n    try {\n      await bundle(entry, {\n        defaultConfig: config\n      });\n    } catch (e) {\n      assert.equal(e.name, 'BuildError');\n      assert(Array.isArray(e.diagnostics));\n      assert(e.diagnostics[0].codeFrames);\n      assert.equal(e.diagnostics[0].origin, '@parcel/validator-eslint');\n      assert.equal(e.diagnostics[0].message, 'ESLint found **1** __errors__ and **1** __warnings__.');\n      let codeframe = e.diagnostics[0].codeFrames[0];\n      assert(codeframe);\n      assert.equal(codeframe.filePath, entry);\n      assert.equal(codeframe.codeHighlights.length, 2);\n      codeframe.codeHighlights.sort(({\n        start: {\n          line: a\n        }\n      }, {\n        start: {\n          line: b\n        }\n      }) => a - b);\n      assert.equal(codeframe.codeHighlights[0].message, 'Unexpected console statement.');\n      assert.equal(codeframe.codeHighlights[1].message, \"'hey' is assigned a value but never used.\");\n      didThrow = true;\n    }\n    assert(didThrow);\n  });","file":"eslint-validation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw a correct codeframe for a parse error","suites":["eslint-validator"],"updatePoint":{"line":38,"column":56,"index":1456},"line":38,"code":"  it('should throw a correct codeframe for a parse error', async function () {\n    let didThrow = false;\n    let entry = path.join(__dirname, '/integration/eslint-parse-error/index.js');\n    try {\n      await bundle(entry, {\n        defaultConfig: config\n      });\n    } catch (e) {\n      assert.equal(e.name, 'BuildError');\n      assert(Array.isArray(e.diagnostics));\n      assert.equal(e.diagnostics[0].origin, '@parcel/validator-eslint');\n      assert.equal(e.diagnostics[0].message, 'ESLint found **1** __errors__ and **0** __warnings__.');\n      let codeframe = e.diagnostics[0].codeFrames[0];\n      assert(codeframe);\n      assert.equal(codeframe.filePath, entry);\n      assert.equal(codeframe.codeHighlights.length, 1);\n      assert(codeframe.codeHighlights[0].start.line != null);\n      assert(codeframe.codeHighlights[0].start.column != null);\n      assert(codeframe.codeHighlights[0].end.line != null);\n      assert(codeframe.codeHighlights[0].end.column != null);\n      assert(codeframe.codeHighlights[0].message.startsWith('Parsing error'));\n      didThrow = true;\n    }\n    assert(didThrow);\n  });","file":"eslint-validation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not inline a file if disabled via config","suites":["fs","browser environment"],"updatePoint":{"line":10,"column":55,"index":401},"line":10,"code":"    it('should not inline a file if disabled via config', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-disabled/index.js'), {\n        inputFS: overlayFS\n      });\n\n      // $FlowFixMe\n      await assert.rejects(() => run(b), /\\.readFileSync is not a function/);\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not inline a file outside of the project root","suites":["fs","browser environment"],"updatePoint":{"line":18,"column":60,"index":716},"line":18,"code":"    it('should not inline a file outside of the project root', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-outside-root/index.js'), {\n        inputFS: overlayFS\n      });\n\n      // $FlowFixMe\n      await assert.rejects(() => run(b), /\\.readFileSync is not a function/);\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file as a string","suites":["fs","browser environment"],"updatePoint":{"line":26,"column":40,"index":1015},"line":26,"code":"    it('should inline a file as a string', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs/index.js'));\n      let output = await run(b);\n      assert.equal(output, 'hello');\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file as a buffer","suites":["fs","browser environment"],"updatePoint":{"line":31,"column":40,"index":1234},"line":31,"code":"    it('should inline a file as a buffer', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-buffer/index.js'));\n      let output = await run(b);\n      invariant(typeof output === 'object' && output != null);\n      assert(output.constructor.name.includes('Buffer'));\n      assert.equal(output.length, 5);\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file with fs require alias","suites":["fs","browser environment"],"updatePoint":{"line":38,"column":50,"index":1592},"line":38,"code":"    it('should inline a file with fs require alias', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-alias/index.js'));\n      let output = await run(b);\n      assert.equal(output, 'hello');\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file with fs require inline","suites":["fs","browser environment"],"updatePoint":{"line":43,"column":51,"index":1828},"line":43,"code":"    it('should inline a file with fs require inline', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-inline/index.js'));\n      let output = await run(b);\n      assert.equal(output, 'hello');\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file with fs require assignment","suites":["fs","browser environment"],"line":48,"code":"    it.skip('should inline a file with fs require assignment', async function () {","file":"fs.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file with fs require assignment alias","suites":["fs","browser environment"],"line":53,"code":"    it.skip('should inline a file with fs require assignment alias', async function () {","file":"fs.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file with fs require destructure","suites":["fs","browser environment"],"updatePoint":{"line":58,"column":56,"index":2574},"line":58,"code":"    it('should inline a file with fs require destructure', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-destructure/index.js'));\n      let output = await run(b);\n      assert.equal(output, 'hello');\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file with fs require destructure assignment","suites":["fs","browser environment"],"line":63,"code":"    it.skip('should inline a file with fs require destructure assignment', async function () {","file":"fs.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file with fs ES6 import","suites":["fs","browser environment"],"updatePoint":{"line":68,"column":47,"index":3082},"line":68,"code":"    it('should inline a file with fs ES6 import', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-import/index.js'));\n      let output = await run(b);\n      invariant(typeof output === 'object' && output != null);\n      assert.equal(output.default, 'hello');\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file with fs ES6 import and path.join","suites":["fs","browser environment"],"updatePoint":{"line":74,"column":61,"index":3400},"line":74,"code":"    it('should inline a file with fs ES6 import and path.join', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-import-path-join/index.js'));\n      let output = await run(b);\n      invariant(typeof output === 'object' && output != null);\n      assert.equal(output.default, 'hello');\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not evaluate fs calls when package.browser.fs is false","suites":["fs","browser environment"],"updatePoint":{"line":80,"column":69,"index":3736},"line":80,"code":"    it('should not evaluate fs calls when package.browser.fs is false', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/resolve-entries/ignore-fs.js'));\n      assertBundles(b, [{\n        name: 'ignore-fs.js',\n        // empty.js is generated by require('fs'), it gets mocked with an empty module\n        assets: ['_empty.js', 'esmodule-helpers.js', 'ignore-fs.js', 'index.js']\n      }]);\n      // $FlowFixMe[incompatible-call]\n      let output = await run(b);\n      assert.equal(typeof output.test, 'function');\n      assert.equal(output.test(), 'test-pkg-ignore-fs-ok');\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore fs calls when the filename is not evaluable","suites":["fs","browser environment"],"updatePoint":{"line":94,"column":65,"index":4400},"line":94,"code":"    it('should ignore fs calls when the filename is not evaluable', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-file-non-evaluable/index.js'));\n\n      // $FlowFixMe\n      await assert.rejects(() => run(b), /\\.readFileSync is not a function/);\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore fs calls when the filename is not evaluable after preset-env","suites":["fs","browser environment"],"updatePoint":{"line":100,"column":82,"index":4709},"line":100,"code":"    it('should ignore fs calls when the filename is not evaluable after preset-env', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-file-non-evaluable-template-env/index.js'));\n\n      // $FlowFixMe\n      await assert.rejects(() => run(b), /\\.readFileSync is not a function/);\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore fs calls when the options are not evaluable","suites":["fs","browser environment"],"updatePoint":{"line":106,"column":65,"index":5014},"line":106,"code":"    it('should ignore fs calls when the options are not evaluable', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-options-non-evaluable/index.js'));\n\n      // $FlowFixMe\n      await assert.rejects(() => run(b), /\\.readFileSync is not a function/);\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not inline a file in a node environment","suites":["fs","node environment"],"updatePoint":{"line":114,"column":54,"index":5349},"line":114,"code":"    it('should not inline a file in a node environment', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-node/index.js'));\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js']\n      }]);\n      let contents = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(contents.includes('readFileSync'));\n      await outputFS.writeFile(path.join(__dirname, '/integration/fs-node/', 'test.txt'), 'hey');\n      let output = await run(b);\n      assert.equal(output, 'hey');\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not inline a file in an Electron environment","suites":["fs","electron environment"],"updatePoint":{"line":128,"column":59,"index":5975},"line":128,"code":"    it('should not inline a file in an Electron environment', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs/index.js'), {\n        targets: ['electron']\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js']\n      }]);\n      let contents = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(contents.includes(\"require('fs')\"));\n      assert(contents.includes('readFileSync'));\n      await outputFS.writeFile(path.join(distDir, 'test.txt'), 'hey');\n      let output = await run(b);\n      assert.equal(output, 'hey');\n    });","file":"fs.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should require a glob of files","suites":["glob"],"updatePoint":{"line":6,"column":36,"index":243},"line":6,"code":"  it('should require a glob of files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glob/index.js'));\n    await assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', '*.js', 'a.js', 'b.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 3);\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should require nested directories with a glob","suites":["glob"],"updatePoint":{"line":16,"column":51,"index":628},"line":16,"code":"  it('should require nested directories with a glob', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glob-deep/index.js'));\n    await assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', '*.js', 'a.js', 'b.js', 'c.js', 'z.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 13);\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing a glob of CSS files","suites":["glob"],"updatePoint":{"line":26,"column":50,"index":1034},"line":26,"code":"  it('should support importing a glob of CSS files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glob-css/index.js'));\n    await assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['*.css', 'index.css', 'other.css', 'local.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(nullthrows(b.getBundles().find(b => b.type === 'css')).filePath, 'utf8');\n    assert(css.includes('.local'));\n    assert(css.includes('.other'));\n    assert(css.includes('.index'));\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should require a glob using a pipeline","suites":["glob"],"updatePoint":{"line":43,"column":44,"index":1703},"line":43,"code":"  it('should require a glob using a pipeline', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glob-pipeline/index.js'));\n    await assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', '*.js', 'bundle-url.js']\n    }, {\n      type: 'txt',\n      assets: ['a.txt']\n    }, {\n      type: 'txt',\n      assets: ['b.txt']\n    }]);\n    let output = await run(b);\n    assert.deepEqual(output, {\n      a: `http://localhost/${path.basename(nullthrows(b.getBundles().find(b => b.name.startsWith('a'))).filePath)}`,\n      b: `http://localhost/${path.basename(nullthrows(b.getBundles().find(b => b.name.startsWith('b'))).filePath)}`\n    });\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should import a glob with dynamic import","suites":["glob"],"updatePoint":{"line":61,"column":46,"index":2387},"line":61,"code":"  it('should import a glob with dynamic import', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glob-async/index.js'));\n    await assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', '*.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      type: 'js',\n      assets: ['a.js']\n    }, {\n      type: 'js',\n      assets: ['b.js']\n    }]);\n    let output = await run(b);\n    assert.equal(await output(), 3);\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when an unsupported asset type imports a glob","suites":["glob"],"updatePoint":{"line":76,"column":64,"index":2881},"line":76,"code":"  it('should error when an unsupported asset type imports a glob', async function () {\n    let filePath = path.join(__dirname, '/integration/glob-error/index.html');\n    // $FlowFixMe\n    await assert.rejects(() => bundle(filePath), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: \"Failed to resolve 'foo/\\\\*.js' from './index.html'\",\n        origin: '@parcel/core'\n      }, {\n        message: 'Glob imports are not supported in html files.',\n        origin: '@parcel/resolver-glob',\n        codeFrames: undefined\n      }]\n    });\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when a URL dependency imports a glob","suites":["glob"],"updatePoint":{"line":91,"column":55,"index":3428},"line":91,"code":"  it('should error when a URL dependency imports a glob', async function () {\n    let filePath = path.join(__dirname, '/integration/glob-error/index.css');\n    // $FlowFixMe\n    await assert.rejects(() => bundle(filePath), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: \"Failed to resolve 'images/\\\\*.jpg' from './index.css'\",\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath,\n          code: await inputFS.readFile(filePath, 'utf8'),\n          codeHighlights: [{\n            start: {\n              column: 19,\n              line: 2\n            },\n            end: {\n              column: 30,\n              line: 2\n            }\n          }]\n        }]\n      }, {\n        message: 'Glob imports are not supported in URL dependencies.',\n        origin: '@parcel/resolver-glob',\n        codeFrames: [{\n          codeHighlights: [{\n            start: {\n              column: 19,\n              line: 2\n            },\n            end: {\n              column: 30,\n              line: 2\n            }\n          }]\n        }]\n      }]\n    });\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should require a glob of files from a package","suites":["glob"],"updatePoint":{"line":131,"column":51,"index":4510},"line":131,"code":"  it('should require a glob of files from a package', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glob-package/index.js'));\n    await assertBundles(b, [{\n      name: 'index.js',\n      assets: ['*.js', '*.js', 'a.js', 'b.js', 'x.js', 'y.js', 'index.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 10);\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should require a glob of files from a package async","suites":["glob"],"updatePoint":{"line":141,"column":57,"index":4934},"line":141,"code":"  it('should require a glob of files from a package async', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glob-package-async/index.js'));\n    await assertBundles(b, [{\n      name: 'index.js',\n      assets: ['*.js', '*.js', 'bundle-url.js', 'cacheLoader.js', 'index.js', 'js-loader.js']\n    }, {\n      type: 'js',\n      assets: ['a.js']\n    }, {\n      type: 'js',\n      assets: ['b.js']\n    }, {\n      type: 'js',\n      assets: ['x.js']\n    }, {\n      type: 'js',\n      assets: ['y.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 10);\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support global alias syntax","suites":["global alias"],"updatePoint":{"line":5,"column":40,"index":184},"line":5,"code":"  it('should support global alias syntax', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/global-alias/index.js'));\n    assert.equal(await run(b, {\n      React: {\n        createElement: function () {\n          return 'ok';\n        }\n      }\n    }), 'ok');\n  });","file":"globals.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring GLSL files via glslify","suites":["glsl"],"updatePoint":{"line":6,"column":53,"index":229},"line":6,"code":"  it('should support requiring GLSL files via glslify', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glsl/index.js'));\n    let shader = fs.readFileSync(path.join(__dirname, '/integration/glsl/compiled.glsl'), 'utf8');\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.ok(output().reduce((acc, requiredShader) => {\n      return acc && normaliseNewlines(shader) === normaliseNewlines(requiredShader);\n    }, true));\n  });","file":"glsl.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly resolve relative GLSL imports","suites":["glsl"],"updatePoint":{"line":15,"column":52,"index":720},"line":15,"code":"  it('should correctly resolve relative GLSL imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glsl-relative-import/index.js'));\n    let output = await run(b);\n    assert.strictEqual(output.trim(), `#define GLSLIFY 1\nfloat b(float p) { return p*2.0; }\n\nfloat c(float p) { return b(p)*3.0; }\n\nvarying float x;\n\nvoid main() { gl_FragColor = vec4(c(x)); }`);\n  });","file":"glsl.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring graphql files","suites":["graphql"],"updatePoint":{"line":6,"column":44,"index":232},"line":6,"code":"  it('should support requiring graphql files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/graphql/index.js'));\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.deepEqual(normalize(output()), normalize(`\n        {\n          user(id: 5) {\n            ...UserFragment\n          }\n        }\n\n        fragment UserFragment on User {\n          firstName\n          lastName\n        }\n      `));\n  });","file":"graphql.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing other graphql files from a graphql file","suites":["graphql"],"updatePoint":{"line":23,"column":70,"index":727},"line":23,"code":"  it('should support importing other graphql files from a graphql file', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/graphql-import/index.js'));\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.deepEqual(normalize(output()), normalize(`\n        {\n          user(id: 6) {\n            ...UserFragment\n            ...AnotherUserFragment\n          }\n        }\n\n        fragment UserFragment on User {\n          firstName\n          lastName\n        }\n\n        fragment AnotherUserFragment on User {\n          address\n          email\n        }\n      `));\n  });","file":"graphql.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing fragments in other graphql files by name","suites":["graphql"],"updatePoint":{"line":46,"column":71,"index":1357},"line":46,"code":"  it('should support importing fragments in other graphql files by name', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/graphql-named-import/index.js'));\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.deepEqual(normalize(output()), normalize(`\n      query MyQuery {\n        user(id: 6) {\n          ...UserFragment\n          address {\n            ...Address\n          }\n        }\n      }\n\n      fragment UserFragment on User {\n        firstName\n        lastName\n        ...AnotherUserFragment\n      }\n\n      fragment Address on Address {\n        line1\n        county\n        postalCode\n      }\n\n      fragment AnotherUserFragment on User {\n        address\n        email\n      }\n\n      fragment otherUserFragment on User {\n        friends {\n          edges {\n            nodes {\n              name\n            }\n          }\n        }\n      }\n      `));\n  });","file":"graphql.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should emit an HMR update for the file that changed","suites":["hmr","hmr server"],"updatePoint":{"line":93,"column":59,"index":2795},"line":93,"code":"    it('should emit an HMR update for the file that changed', async function () {\n      let port = await getPort();\n      let b = bundler(path.join(__dirname, '/input/index.js'), {\n        hmrOptions: {\n          port\n        },\n        inputFS: overlayFS,\n        config\n      });\n      subscription = await b.watch();\n      await getNextBuild(b);\n      ws = await openSocket('ws://localhost:' + port);\n      outputFS.writeFile(path.join(__dirname, '/input/local.js'), 'exports.a = 5;\\nexports.b = 5;');\n      let message = await nextWSMessage(nullthrows(ws));\n      assert.equal(message.type, 'update');\n\n      // Figure out why output doesn't change...\n      let localAsset = message.assets.find(asset => asset.output.includes('exports.a = 5;\\nexports.b = 5;\\n'));\n      assert(!!localAsset);\n      assert(localAsset.output.includes('//# sourceMappingURL'));\n      assert(localAsset.output.includes('//# sourceURL'));\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should emit an HMR update for all new dependencies along with the changed file","suites":["hmr","hmr server"],"updatePoint":{"line":115,"column":86,"index":3751},"line":115,"code":"    it('should emit an HMR update for all new dependencies along with the changed file', async function () {\n      let port = await getPort();\n      let b = bundler(path.join(__dirname, '/input/index.js'), {\n        hmrOptions: {\n          port\n        },\n        inputFS: overlayFS,\n        config\n      });\n      subscription = await b.watch();\n      await getNextBuild(b);\n      ws = await openSocket('ws://localhost:' + port);\n      outputFS.writeFile(path.join(__dirname, '/input/local.js'), 'require(\"fs\"); exports.a = 5; exports.b = 5;');\n      let message = await nextWSMessage(nullthrows(ws));\n      assert.equal(message.type, 'update');\n      assert.equal(message.assets.length, 2);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should emit an HMR error on bundle failure","suites":["hmr","hmr server"],"updatePoint":{"line":132,"column":50,"index":4416},"line":132,"code":"    it('should emit an HMR error on bundle failure', async function () {\n      let port = await getPort();\n      let b = bundler(path.join(__dirname, '/input/index.js'), {\n        hmrOptions: {\n          port\n        },\n        inputFS: overlayFS,\n        config\n      });\n      subscription = await b.watch();\n      await getNextBuild(b);\n      ws = await openSocket('ws://localhost:' + port);\n      outputFS.writeFile(path.join(__dirname, '/input/local.js'), 'require(\"fs\"; exports.a = 5; exports.b = 5;');\n      let message = await nextWSMessage(nullthrows(ws));\n      assert.equal(message.type, 'error');\n      assert(!!message.diagnostics, 'Should contain a diagnostics key');\n      assert(!!message.diagnostics.html, 'Should contain a html diagnostic');\n      assert(!!message.diagnostics.ansi, 'Should contain an ansi diagnostic');\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should emit an HMR error to new connections after a bundle failure","suites":["hmr","hmr server"],"updatePoint":{"line":151,"column":74,"index":5287},"line":151,"code":"    it('should emit an HMR error to new connections after a bundle failure', async function () {\n      let port = await getPort();\n      let b = bundler(path.join(__dirname, '/input/index.js'), {\n        hmrOptions: {\n          port\n        },\n        inputFS: overlayFS,\n        config\n      });\n      subscription = await b.watch();\n      await getNextBuild(b);\n      await outputFS.writeFile(path.join(__dirname, '/input/local.js'), 'require(\"fs\"; exports.a = 5; exports.b = 5;');\n      ws = await openSocket('ws://localhost:' + port);\n      let message = await nextWSMessage(ws);\n      assert.equal(message.type, 'error');\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should emit an HMR update after error has been resolved","suites":["hmr","hmr server"],"updatePoint":{"line":167,"column":63,"index":5911},"line":167,"code":"    it('should emit an HMR update after error has been resolved', async function () {\n      let port = await getPort();\n      let b = bundler(path.join(__dirname, '/input/index.js'), {\n        hmrOptions: {\n          port\n        },\n        inputFS: overlayFS,\n        config\n      });\n      subscription = await b.watch();\n      await getNextBuild(b);\n      ws = await openSocket('ws://localhost:' + port);\n      await outputFS.writeFile(path.join(__dirname, '/input/local.js'), 'require(\"fs\"; exports.a = 5; exports.b = 5;');\n      let message = await nextWSMessage(nullthrows(ws));\n      assert.equal(message.type, 'error');\n      await outputFS.writeFile(path.join(__dirname, '/input/local.js'), 'require(\"fs\"); exports.a = 5; exports.b = 5;');\n      message = await nextWSMessage(nullthrows(ws));\n      assert.equal(message.type, 'update');\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should make a secure connection","suites":["hmr","hmr server"],"updatePoint":{"line":186,"column":39,"index":6741},"line":186,"code":"    it('should make a secure connection', async function () {\n      let port = await getPort();\n      let b = bundler(path.join(__dirname, '/input/index.js'), {\n        serveOptions: {\n          https: true,\n          port,\n          host: 'localhost'\n        },\n        hmrOptions: {\n          port\n        },\n        inputFS: overlayFS,\n        config\n      });\n      subscription = await b.watch();\n      await getNextBuild(b);\n      ws = await openSocket('wss://localhost:' + port, {\n        rejectUnauthorized: false\n      });\n      await outputFS.writeFile(path.join(__dirname, '/input/local.js'), 'exports.a = 5;\\nexports.b = 5;');\n      let message = await nextWSMessage(nullthrows(ws));\n      assert.equal(message.type, 'update');\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should make a secure connection with custom certificate","suites":["hmr","hmr server"],"updatePoint":{"line":209,"column":63,"index":7513},"line":209,"code":"    it('should make a secure connection with custom certificate', async function () {\n      let port = await getPort();\n      let b = bundler(path.join(__dirname, '/input/index.js'), {\n        serveOptions: {\n          https: {\n            key: path.join(__dirname, '/integration/https/private.pem'),\n            cert: path.join(__dirname, '/integration/https/primary.crt')\n          },\n          port,\n          host: 'localhost'\n        },\n        hmrOptions: {\n          port\n        },\n        inputFS: overlayFS,\n        config\n      });\n      subscription = await b.watch();\n      await getNextBuild(b);\n      ws = await openSocket('wss://localhost:' + port, {\n        rejectUnauthorized: false\n      });\n      outputFS.writeFile(path.join(__dirname, '/input/local.js'), 'exports.a = 5;\\nexports.b = 5;');\n      let message = await nextWSMessage(nullthrows(ws));\n      assert.equal(message.type, 'update');\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should respond to requests for assets by id","suites":["hmr","hmr server"],"updatePoint":{"line":235,"column":51,"index":8422},"line":235,"code":"    it('should respond to requests for assets by id', async function () {\n      let port = await getPort();\n      let b = bundler(path.join(__dirname, '/input/index.js'), {\n        serveOptions: {\n          port\n        },\n        hmrOptions: {\n          port\n        },\n        inputFS: overlayFS,\n        config\n      });\n      subscription = await b.watch();\n      let event = await getNextBuild(b);\n      let bundleGraph = nullthrows(event.bundleGraph);\n      let asset = nullthrows(bundleGraph.getBundles()[0].getMainEntry());\n      let contents = await request('/__parcel_hmr/' + asset.id, port);\n      let publicId = nullthrows(bundleGraph).getAssetPublicId(asset);\n      assert(contents.startsWith(`parcelHotUpdate['${publicId}'] = function (require, module, exports) {`));\n      assert(contents.includes('//# sourceMappingURL'));\n      assert(contents.includes('//# sourceURL'));\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support self accepting","suites":["hmr","hmr runtime"],"updatePoint":{"line":264,"column":37,"index":9564},"line":264,"code":"    it('should support self accepting', async function () {\n      let {\n        outputs\n      } = await testHMRClient('hmr-accept-self', outputs => {\n        assert.deepStrictEqual(outputs, [['other', 1], ['local', 1], ['index', 1]]);\n        return {\n          'other.js': 'export const value = 3; output([\"other\", value]);'\n        };\n      });\n      assert.deepStrictEqual(outputs, [['other', 1], ['local', 1], ['index', 1], ['other', 3], ['local', 3]]);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bubble through parents","suites":["hmr","hmr runtime"],"updatePoint":{"line":275,"column":37,"index":10030},"line":275,"code":"    it('should bubble through parents', async function () {\n      let {\n        outputs\n      } = await testHMRClient('hmr-bubble', outputs => {\n        assert.deepStrictEqual(outputs, [['other', 1], ['local', 1], ['index', 1]]);\n        return {\n          'other.js': 'export const value = 3; output([\"other\", value]);'\n        };\n      });\n      assert.deepStrictEqual(outputs, [['other', 1], ['local', 1], ['index', 1], ['other', 3], ['local', 3], ['index', 3]]);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should call dispose callbacks","suites":["hmr","hmr runtime"],"updatePoint":{"line":286,"column":37,"index":10505},"line":286,"code":"    it('should call dispose callbacks', async function () {\n      let {\n        outputs\n      } = await testHMRClient('hmr-dispose', outputs => {\n        assert.deepStrictEqual(outputs, [['eval:other', 1, null], ['eval:local', 1, null], ['eval:index', 1, null]]);\n        return {\n          'other.js': `export const value = 3;\noutput([\"eval:other\", value, module.hot.data]);\nmodule.hot.dispose((data) => {\n  output([\"dispose:other\", value]);\n  data.value = value;\n})\n`\n        };\n      });\n\n      // Webpack:\n      // [\"eval:other\", 1, undefined]\n      // [\"eval:local\", 1, undefined]\n      // [\"eval:index\", 1, undefined]\n      // [\"dispose:index\", 1]\n      // [\"dispose:local\", 1]\n      // [\"dispose:other\", 1]\n      // [\"eval:other\", 3, {value: 1}]\n      // [\"eval:local\", 3, {value: 1}]\n      // [\"eval:index\", 3, {value: 1}]\n      assert.deepStrictEqual(outputs, [['eval:other', 1, null], ['eval:local', 1, null], ['eval:index', 1, null], ['dispose:other', 1], ['dispose:local', 1], ['dispose:index', 1], ['eval:other', 3, {\n        value: 1\n      }], ['eval:local', 3, {\n        value: 1\n      }], ['eval:index', 3, {\n        value: 1\n      }]]);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with circular dependencies","suites":["hmr","hmr runtime"],"updatePoint":{"line":320,"column":46,"index":11676},"line":320,"code":"    it('should work with circular dependencies', async function () {\n      let {\n        outputs\n      } = await testHMRClient('hmr-circular', outputs => {\n        assert.deepEqual(outputs, [3]);\n        return {\n          'local.js': \"var other = require('./index.js'); exports.a = 5; exports.b = 5;\"\n        };\n      });\n      assert.deepEqual(outputs, [3, 10]);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should reload if not accepted","suites":["hmr","hmr runtime"],"updatePoint":{"line":331,"column":37,"index":12040},"line":331,"code":"    it('should reload if not accepted', async function () {\n      let {\n        reloaded\n      } = await testHMRClient('hmr-reload', outputs => {\n        assert.deepEqual(outputs, [3]);\n        return {\n          'local.js': 'exports.a = 5; exports.b = 5;'\n        };\n      });\n      assert(reloaded);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should reload when modifying the entry","suites":["hmr","hmr runtime"],"updatePoint":{"line":342,"column":46,"index":12359},"line":342,"code":"    it('should reload when modifying the entry', async function () {\n      let {\n        reloaded\n      } = await testHMRClient('hmr-reload', outputs => {\n        assert.deepEqual(outputs, [3]);\n        return {\n          'index.js': 'output(5)'\n        };\n      });\n      assert(reloaded);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with multiple parents","suites":["hmr","hmr runtime"],"updatePoint":{"line":353,"column":41,"index":12653},"line":353,"code":"    it('should work with multiple parents', async function () {\n      let {\n        outputs\n      } = await testHMRClient('hmr-multiple-parents', outputs => {\n        assert.deepEqual(outputs, ['a: fn1 b: fn2']);\n        return {\n          'fn2.js': 'export function fn2() { return \"UPDATED\"; }'\n        };\n      });\n      assert.deepEqual(outputs, ['a: fn1 b: fn2', 'a: fn1 b: UPDATED']);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should reload if only one parent accepts","suites":["hmr","hmr runtime"],"updatePoint":{"line":364,"column":48,"index":13058},"line":364,"code":"    it('should reload if only one parent accepts', async function () {\n      let {\n        reloaded\n      } = await testHMRClient('hmr-multiple-parents-reload', outputs => {\n        assert.deepEqual(outputs, ['a: fn1', 'b: fn2']);\n        return {\n          'fn2.js': 'export function fn2() { return \"UPDATED\"; }'\n        };\n      });\n      assert(reloaded);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work across bundles","suites":["hmr","hmr runtime"],"updatePoint":{"line":375,"column":34,"index":13411},"line":375,"code":"    it('should work across bundles', async function () {\n      let {\n        reloaded\n      } = await testHMRClient('hmr-dynamic', outputs => {\n        assert.deepEqual(outputs, [3]);\n        return {\n          'local.js': 'exports.a = 5; exports.b = 5;'\n        };\n      });\n\n      // assert.deepEqual(outputs, [3, 10]);\n      assert(reloaded); // TODO: this should eventually not reload...\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with urls","suites":["hmr","hmr runtime"],"updatePoint":{"line":389,"column":29,"index":13807},"line":389,"code":"    it('should work with urls', async function () {\n      let search;\n      let {\n        outputs\n      } = await testHMRClient('hmr-url', outputs => {\n        assert.equal(outputs.length, 1);\n        let url = new URL(outputs[0]);\n        assert(/test\\.[0-9a-f]+\\.txt/, url.pathname);\n        assert(!isNaN(url.search.slice(1)));\n        search = url.search;\n        return {\n          'test.txt': 'yo'\n        };\n      });\n      assert.equal(outputs.length, 2);\n      let url = new URL(outputs[1]);\n      assert(/test\\.[0-9a-f]+\\.txt/, url.pathname);\n      assert(!isNaN(url.search.slice(1)));\n      assert.notEqual(url.search, search);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should clean up orphaned assets when deleting a dependency","suites":["hmr","hmr runtime"],"updatePoint":{"line":409,"column":66,"index":14491},"line":409,"code":"    it('should clean up orphaned assets when deleting a dependency', async function () {\n      let search;\n      let {\n        outputs\n      } = await testHMRClient('hmr-url', [outputs => {\n        assert.equal(outputs.length, 1);\n        let url = new URL(outputs[0]);\n        assert(/test\\.[0-9a-f]+\\.txt/, url.pathname);\n        assert(!isNaN(url.search.slice(1)));\n        search = url.search;\n        return {\n          'index.js': 'output(\"yo\"); module.hot.accept();'\n        };\n      }, outputs => {\n        assert.equal(outputs.length, 2);\n        assert.equal(outputs[1], 'yo');\n        return {\n          'index.js': 'output(new URL(\"test.txt\", import.meta.url)); module.hot.accept();'\n        };\n      }]);\n      assert.equal(outputs.length, 3);\n      let url = new URL(outputs[2]);\n      assert(/test\\.[0-9a-f]+\\.txt/, url.pathname);\n      assert(!isNaN(url.search.slice(1)));\n      assert.notEqual(url.search, search);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should have correct source locations in errors","suites":["hmr","hmr runtime"],"updatePoint":{"line":435,"column":54,"index":15419},"line":435,"code":"    it('should have correct source locations in errors', async function () {\n      let {\n        outputs,\n        bundleGraph\n      } = await testHMRClient('hmr-accept-self', () => {\n        return {\n          'local.js': 'output(new Error().stack);'\n        };\n      });\n      let asset = bundleGraph.getBundles()[0].traverseAssets((asset, _, actions) => {\n        if (asset.filePath.endsWith('local.js')) {\n          actions.stop();\n          return asset;\n        }\n      });\n      let stack = outputs.pop();\n      assert(stack.includes('/__parcel_hmr/' + nullthrows(asset).id));\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update CSS link tags when a CSS asset is changed","suites":["hmr","hmr runtime"],"updatePoint":{"line":670,"column":63,"index":22412},"line":670,"code":"    it('should update CSS link tags when a CSS asset is changed', async () => {\n      let testDir = path.join(__dirname, '/input');\n      await overlayFS.rimraf(testDir);\n      await overlayFS.mkdirp(testDir);\n      await ncp(path.join(__dirname, '/integration/hmr-css'), testDir);\n      let port = await getPort();\n      let b = bundler(path.join(testDir, 'index.html'), {\n        inputFS: overlayFS,\n        outputFS: overlayFS,\n        serveOptions: {\n          https: false,\n          port,\n          host: '127.0.0.1'\n        },\n        hmrOptions: {\n          port\n        },\n        shouldContentHash: false,\n        config\n      });\n      subscription = await b.watch();\n      let bundleEvent = await getNextBuild(b);\n      assert.equal(bundleEvent.type, 'buildSuccess');\n      let window;\n      try {\n        let dom = await JSDOM.JSDOM.fromURL('http://127.0.0.1:' + port + '/index.html', {\n          runScripts: 'dangerously',\n          resources: 'usable',\n          pretendToBeVisual: true\n        });\n        let _window = window = dom.window; // For Flow\n        window.WebSocket = WebSocket;\n        await new Promise(res => dom.window.document.addEventListener('load', () => {\n          res();\n        }));\n        _window.console.clear = () => {};\n        _window.console.warn = () => {};\n        let initialHref = _window.document.querySelector('link').href;\n        await overlayFS.copyFile(path.join(testDir, 'index.2.css'), path.join(testDir, 'index.css'));\n        assert.equal((await getNextBuild(b)).type, 'buildSuccess');\n        await sleep(200);\n        let newHref = _window.document.querySelector('link').href;\n        assert.notStrictEqual(initialHref, newHref);\n      } finally {\n        if (window) {\n          window.close();\n        }\n      }\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle CSS Modules update correctly","suites":["hmr","hmr runtime"],"updatePoint":{"line":719,"column":50,"index":24184},"line":719,"code":"    it('should handle CSS Modules update correctly', async () => {\n      let testDir = path.join(__dirname, '/input');\n      await overlayFS.rimraf(testDir);\n      await overlayFS.mkdirp(testDir);\n      await ncp(path.join(__dirname, '/integration/hmr-css-modules'), testDir);\n      let port = await getPort();\n      let b = bundler(path.join(testDir, 'index.html'), {\n        inputFS: overlayFS,\n        outputFS: overlayFS,\n        serveOptions: {\n          https: false,\n          port,\n          host: '127.0.0.1'\n        },\n        hmrOptions: {\n          port\n        },\n        shouldContentHash: false,\n        config\n      });\n      subscription = await b.watch();\n      let bundleEvent = await getNextBuild(b);\n      assert.equal(bundleEvent.type, 'buildSuccess');\n      let window;\n      try {\n        let dom = await JSDOM.JSDOM.fromURL('http://127.0.0.1:' + port + '/index.html', {\n          runScripts: 'dangerously',\n          resources: 'usable',\n          pretendToBeVisual: true\n        });\n        let _window = window = dom.window; // For Flow\n        window.WebSocket = WebSocket;\n        await new Promise(res => dom.window.document.addEventListener('load', () => {\n          res();\n        }));\n        _window.console.clear = () => {};\n        _window.console.warn = () => {};\n        let initialHref = _window.document.querySelector('link').href;\n        await overlayFS.copyFile(path.join(testDir, 'index2.module.css'), path.join(testDir, 'index.module.css'));\n        assert.equal((await getNextBuild(b)).type, 'buildSuccess');\n        await sleep(200);\n        let newHref = _window.document.querySelector('link').href;\n        assert.notStrictEqual(initialHref, newHref);\n      } finally {\n        if (window) {\n          window.close();\n        }\n      }\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling HTML","suites":["html"],"updatePoint":{"line":15,"column":34,"index":488},"line":15,"code":"  it('should support bundling HTML', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/html/index.html'));\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'svg',\n      assets: ['icons.svg']\n    }, {\n      type: 'css',\n      assets: ['index.css']\n    }, {\n      type: 'html',\n      assets: ['other.html']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }]);\n    let files = await outputFS.readdir(distDir);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    for (let file of files) {\n      if (file !== 'index.html' && path.extname(file) !== '.map') {\n        assert(html.includes(file));\n      }\n    }\n    assert(html.includes('#hash_link'));\n    assert(html.includes('mailto:someone@acme.com'));\n    assert(html.includes('tel:+33636757575'));\n    assert(html.includes('https://unpkg.com/parcel-bundler'));\n    let iconsBundle = b.getBundles().find(b => b.name.startsWith('icons'));\n    assert(html.includes('/' + path.basename(iconsBundle.filePath) + '#icon-code'));\n    let value = null;\n    await run(b, {\n      alert: v => value = v\n    });\n    assert.equal(value, 'Hi');\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support pkg#source array as entrypoints","suites":["html"],"updatePoint":{"line":61,"column":52,"index":1888},"line":61,"code":"  it('should support pkg#source array as entrypoints', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/html-pkg-source-array'));\n    assertBundles(b, [{\n      name: 'a.html',\n      assets: ['a.html']\n    }, {\n      name: 'b.html',\n      assets: ['b.html']\n    }]);\n    assert(await outputFS.exists(path.join(distDir, 'a.html'), 'utf8'));\n    assert(await outputFS.exists(path.join(distDir, 'b.html'), 'utf8'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should find href attr when not first","suites":["html"],"updatePoint":{"line":73,"column":42,"index":2321},"line":73,"code":"  it('should find href attr when not first', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-attr-order/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'html',\n      assets: ['other.html']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert empty script tag for HMR at the end of the body","suites":["html"],"updatePoint":{"line":83,"column":67,"index":2654},"line":83,"code":"  it('should insert empty script tag for HMR at the end of the body', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/html-no-js/index.html'), {\n      hmrOptions: {}\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(/<script src=\".+?\\.js\"><\\/script><\\/body>/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert empty script tag for HMR at the implied </body>","suites":["html"],"updatePoint":{"line":97,"column":67,"index":3163},"line":97,"code":"  it('should insert empty script tag for HMR at the implied </body>', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/html-no-js/no-body.html'), {\n      hmrOptions: {}\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['no-body.html']\n    }, {\n      name: 'no-body.html',\n      assets: ['no-body.html']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'no-body.html'), 'utf8');\n    assert(/<script src=\".+?\\.js\"><\\/script><\\/html>/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert empty script tag for HMR at the end of the file if both </body> and </html> are implied","suites":["html"],"updatePoint":{"line":111,"column":107,"index":3722},"line":111,"code":"  it('should insert empty script tag for HMR at the end of the file if both </body> and </html> are implied', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/html-no-js/no-body-or-html.html'), {\n      hmrOptions: {}\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['no-body-or-html.html']\n    }, {\n      name: 'no-body-or-html.html',\n      assets: ['no-body-or-html.html']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'no-body-or-html.html'), 'utf8');\n    assert(/<script src=\".+?\\.js\"><\\/script>$/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert empty script tag for HMR at the end of the body when having normal inline script","suites":["html"],"updatePoint":{"line":125,"column":100,"index":4307},"line":125,"code":"  it('should insert empty script tag for HMR at the end of the body when having normal inline script', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/html-inline-js/index.html'), {\n      hmrOptions: {}\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(/<script src=\".+?\\.js\"><\\/script><\\/body>/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support canonical links","suites":["html"],"updatePoint":{"line":151,"column":36,"index":5013},"line":151,"code":"  it('should support canonical links', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-canonical/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(/<link rel=\"canonical\" href=\"\\.?\\/index.html\">/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support RSS feed links","suites":["html"],"updatePoint":{"line":160,"column":35,"index":5409},"line":160,"code":"  it('should support RSS feed links', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-feed/rss.html'));\n    assertBundles(b, [{\n      name: 'rss.html',\n      assets: ['rss.html']\n    }, {\n      name: 'feed.xml',\n      assets: ['feed.xml']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support atom feed links","suites":["html"],"updatePoint":{"line":170,"column":36,"index":5701},"line":170,"code":"  it('should support atom feed links', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-feed/atom.html'));\n    assertBundles(b, [{\n      name: 'atom.html',\n      assets: ['atom.html']\n    }, {\n      name: 'feed.xml',\n      assets: ['feed.xml']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support meta tags","suites":["html"],"updatePoint":{"line":180,"column":30,"index":5990},"line":180,"code":"  it('should support meta tags', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-meta/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      name: 'logo.svg',\n      assets: ['logo.svg']\n    }, {\n      type: 'png',\n      assets: ['logo.png']\n    }, {\n      type: 'png',\n      assets: ['logo.png']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes(`<meta name=\"msapplication-config\" content=\"none\">`));\n    assert(html.includes(`<meta property=\"og:image\" content=\"/logo.svg\">`));\n    assert(/<meta name=\"msapplication-TileImage\" content=\"\\/logo\\.[0-9a-f]+\\.png\">/.test(html));\n    assert(/<meta name=\"msapplication-square70x70logo\" content=\"\\/logo\\.[0-9a-f]+\\.png\">/.test(html));\n    assert(html.includes(`<meta name=\"twitter:image\" content=\"https://parceljs.org/assets/logo.svg\">`));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert sibling CSS bundles for JS files in the HEAD","suites":["html"],"updatePoint":{"line":202,"column":64,"index":6970},"line":202,"code":"  it('should insert sibling CSS bundles for JS files in the HEAD', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-css/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }, {\n      type: 'css',\n      assets: ['index.css']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(/<link rel=\"stylesheet\" href=\"[/\\\\]{1}index\\.[a-f0-9]+\\.css\">/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert sibling bundles before body element if no HEAD","suites":["html"],"updatePoint":{"line":217,"column":66,"index":7516},"line":217,"code":"  it('should insert sibling bundles before body element if no HEAD', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-css-head/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }, {\n      type: 'css',\n      assets: ['index.css']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(/<html>\\s*<link rel=\"stylesheet\" href=\"[/\\\\]{1}index\\.[a-f0-9]+\\.css\">\\s*<body>/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert sibling bundles after doctype if no html","suites":["html"],"updatePoint":{"line":232,"column":60,"index":8079},"line":232,"code":"  it('should insert sibling bundles after doctype if no html', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-css-doctype/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }, {\n      type: 'css',\n      assets: ['index.css']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(/^\\s*<!DOCTYPE html>\\s*<link .*>\\s*<script .*>\\s*<\\/script>\\s*$/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert sibling JS bundles for CSS files in the HEAD","suites":["html"],"line":247,"code":"  it.skip('should insert sibling JS bundles for CSS files in the HEAD', async function () {","file":"html.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should insert sibling bundles at correct location in tree when optional elements are absent","suites":["html"],"updatePoint":{"line":264,"column":97,"index":9279},"line":264,"code":"  it('should insert sibling bundles at correct location in tree when optional elements are absent', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-css-optional-elements/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }, {\n      type: 'css',\n      assets: ['index.css']\n    }, {\n      type: 'js',\n      assets: ['other.js']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(/^<link rel=\"stylesheet\" href=\"[/\\\\]index\\.[a-f0-9]+\\.css\">\\s*<script src=\"[/\\\\]index\\.[a-f0-9]+\\.js\" defer=\"\"><\\/script>\\s*<h1>Hello/m.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should combine sibling CSS from multiple script tags into one bundle","suites":["html"],"updatePoint":{"line":282,"column":74,"index":9978},"line":282,"code":"  it('should combine sibling CSS from multiple script tags into one bundle', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-css-multi/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['a.js']\n    }, {\n      type: 'js',\n      assets: ['b.js']\n    }, {\n      type: 'css',\n      assets: ['a.css', 'b.css']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert.equal(html.match(/<link rel=\"stylesheet\" href=\"[/\\\\]{1}index\\.[a-f0-9]+?\\.css\">/g).length, 1);\n    assert.equal(html.match(/<script src=\"[/\\\\]{1}index\\.[a-f0-9]+?\\.js\" defer=\"\">/g).length, 2);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should deduplicate shared code between script tags","suites":["html"],"updatePoint":{"line":301,"column":56,"index":10688},"line":301,"code":"  it('should deduplicate shared code between script tags', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js-dedup/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['component-1.js', 'obj.js', 'esmodule-helpers.js']\n    }, {\n      type: 'js',\n      assets: ['component-2.js']\n    }]);\n    let o = [];\n    await run(b, {\n      output: v => o.push(v)\n    });\n    assert.deepEqual(o, ['component-1', 'component-2']);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify HTML in production mode","suites":["html"],"updatePoint":{"line":319,"column":43,"index":11219},"line":319,"code":"  it('should minify HTML in production mode', async function () {\n    let inputFile = path.join(__dirname, '/integration/htmlnano/index.html');\n    await bundle(inputFile, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    let inputSize = (await inputFS.stat(inputFile)).size;\n    let outputFile = path.join(distDir, 'index.html');\n    let outputSize = (await outputFS.stat(outputFile)).size;\n    assert(inputSize > outputSize);\n    let html = await outputFS.readFile(outputFile, 'utf8');\n    assert(html.includes('Other page'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with an empty html file","suites":["html"],"updatePoint":{"line":333,"column":41,"index":11783},"line":333,"code":"  it('should work with an empty html file', async function () {\n    let inputFile = path.join(__dirname, '/integration/html-empty/index.html');\n    await bundle(inputFile, {\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    let outputFile = path.join(distDir, 'index.html');\n    let html = await outputFS.readFile(outputFile, 'utf8');\n    assert.equal(html.length, 0);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with an invalid html file","suites":["html"],"updatePoint":{"line":344,"column":43,"index":12190},"line":344,"code":"  it('should work with an invalid html file', async function () {\n    let inputFile = path.join(__dirname, '/integration/html-invalid/index.html');\n    await bundle(inputFile, {\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    let outputFile = path.join(distDir, 'index.html');\n    let html = await outputFS.readFile(outputFile, 'utf8');\n    assert(html.includes('This is a paragraph'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with html that doesn't include optional closing tags","suites":["html"],"updatePoint":{"line":355,"column":70,"index":12642},"line":355,"code":"  it(\"should work with html that doesn't include optional closing tags\", async function () {\n    let inputFile = path.join(__dirname, '/integration/html-optional-closing-tags/index.html');\n    await bundle(inputFile, {\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    let outputFile = path.join(distDir, 'index.html');\n    let html = await outputFS.readFile(outputFile, 'utf8');\n    assert(html.includes('Paragraph 1'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should read .htmlnanorc.json and minify HTML in production mode","suites":["html"],"updatePoint":{"line":366,"column":69,"index":13099},"line":366,"code":"  it('should read .htmlnanorc.json and minify HTML in production mode', async function () {\n    await bundle(path.join(__dirname, '/integration/htmlnano-config/index.html'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n\n    // minifyJson\n    assert(html.includes('<script type=application/json>{\"user\":\"me\"}</script>'));\n\n    // mergeStyles\n    assert(html.includes('<style>h1{color:red}div{font-size:20px}</style>'));\n    assert(!html.includes('sourceMappingURL'));\n\n    // minifySvg is false\n    assert(html.includes('<svg version=1.1 baseprofile=full width=300 height=200 xmlns=http://www.w3.org/2000/svg><rect width=100% height=100% fill=red></rect><circle cx=150 cy=100 r=80 fill=green></circle><text x=150 y=125 font-size=60 text-anchor=middle fill=white>SVG</text></svg>'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not minify default values inside HTML in production mode","suites":["html"],"updatePoint":{"line":384,"column":69,"index":14001},"line":384,"code":"  it('should not minify default values inside HTML in production mode', async function () {\n    let inputFile = path.join(__dirname, '/integration/htmlnano-defaults-form/index.html');\n    await bundle(inputFile, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    let inputSize = (await inputFS.stat(inputFile)).size;\n    let outputFile = path.join(distDir, '/index.html');\n    let outputSize = (await outputFS.stat(outputFile)).size;\n    assert(inputSize > outputSize);\n    let html = await outputFS.readFile(outputFile, 'utf8');\n    assert(html.includes('<input type=\"text\">'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not prepend the public path to assets with remote URLs","suites":["html"],"updatePoint":{"line":398,"column":67,"index":14615},"line":398,"code":"  it('should not prepend the public path to assets with remote URLs', async function () {\n    await bundle(path.join(__dirname, '/integration/html/index.html'));\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('<script src=\"https://unpkg.com/parcel-bundler\"></script>'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not prepend the public path to hash links","suites":["html"],"updatePoint":{"line":403,"column":54,"index":14939},"line":403,"code":"  it('should not prepend the public path to hash links', async function () {\n    await bundle(path.join(__dirname, '/integration/html/index.html'));\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('<a href=\"#hash_link\">'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect virtual paths","suites":["html"],"updatePoint":{"line":408,"column":33,"index":15207},"line":408,"code":"  it('should detect virtual paths', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-virtualpath/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'html',\n      assets: ['other.html']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not update root/main file in the bundles","suites":["html"],"updatePoint":{"line":418,"column":53,"index":15527},"line":418,"code":"  it('should not update root/main file in the bundles', async function () {\n    await bundle(path.join(__dirname, '/integration/html-root/index.html'));\n    let files = await outputFS.readdir(distDir);\n    for (let file of files) {\n      if (file !== 'index.html' && file.endsWith('.html')) {\n        let html = await outputFS.readFile(path.join(distDir, file), 'utf8');\n        assert(html.includes('index.html'));\n      }\n    }\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should preserve the spacing in the HTML tags","suites":["html"],"updatePoint":{"line":428,"column":50,"index":15960},"line":428,"code":"  it('should preserve the spacing in the HTML tags', async function () {\n    await bundle(path.join(__dirname, '/integration/html/index.html'));\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(/<i>hello<\\/i> <i>world<\\/i>/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support child bundles of different types","suites":["html"],"updatePoint":{"line":433,"column":53,"index":16250},"line":433,"code":"  it('should support child bundles of different types', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/child-bundle-different-types/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['main.js', 'util.js', 'other.js']\n    }, {\n      type: 'html',\n      assets: ['other.html']\n    }, {\n      type: 'js',\n      assets: ['index.js', 'util.js', 'other.js']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support circular dependencies","suites":["html"],"line":449,"code":"  it.skip('should support circular dependencies', async function () {","file":"html.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling HTM","suites":["html"],"updatePoint":{"line":468,"column":33,"index":17210},"line":468,"code":"  it('should support bundling HTM', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/htm-extension/index.htm'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.htm'],\n      type: 'html'\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect srcset attribute","suites":["html"],"updatePoint":{"line":479,"column":36,"index":17524},"line":479,"code":"  it('should detect srcset attribute', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-srcset/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'png',\n      assets: ['200x200.png']\n    }, {\n      type: 'png',\n      assets: ['300x300.png']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect srcset attribute of source element","suites":["html"],"updatePoint":{"line":495,"column":54,"index":17956},"line":495,"code":"  it('should detect srcset attribute of source element', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-source-srcset/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'png',\n      assets: ['200x200.png']\n    }, {\n      type: 'png',\n      assets: ['300x300.png']\n    }]);\n    const html = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    const source = html.match(/<source srcset=\".*>/)[0];\n    assert(source.split(', ').length === 3);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect imagesrcset attribute","suites":["html"],"updatePoint":{"line":514,"column":41,"index":18562},"line":514,"code":"  it('should detect imagesrcset attribute', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-imagesrcset/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'png',\n      assets: ['200x200.png']\n    }, {\n      type: 'png',\n      assets: ['300x300.png']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support webmanifest","suites":["html"],"line":530,"code":"  it.skip('should support webmanifest', async function () {","file":"html.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should treat webmanifest as an entry module so it doesn't get content hashed","suites":["html"],"line":546,"code":"  it.skip(\"should treat webmanifest as an entry module so it doesn't get content hashed\", async function () {","file":"html.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should bundle svg files correctly","suites":["html"],"updatePoint":{"line":559,"column":39,"index":20014},"line":559,"code":"  it('should bundle svg files correctly', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-svg/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'svg',\n      assets: ['file.svg']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore svgs referencing local symbols via <use xlink:href=\"#\">","suites":["html"],"updatePoint":{"line":569,"column":75,"index":20345},"line":569,"code":"  it('should ignore svgs referencing local symbols via <use xlink:href=\"#\">', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-svg-local-symbol/index.html'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('<svg><symbol id=\"all\"><rect width=\"100\" height=\"100\"/></symbol></svg><svg><use xlink:href=\"#all\" href=\"#all\"/></svg>'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bundle svg files using <image xlink:href=\"\"> correctly","suites":["html"],"updatePoint":{"line":580,"column":67,"index":20891},"line":580,"code":"  it('should bundle svg files using <image xlink:href=\"\"> correctly', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-svg-image/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'svg',\n      assets: ['file.svg']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support href attribute in <image /> in HTMLTransformer's collectDependencies","suites":["html"],"updatePoint":{"line":590,"column":89,"index":21242},"line":590,"code":"  it(\"should support href attribute in <image /> in HTMLTransformer's collectDependencies\", async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-image-href-attr/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'png',\n      assets: ['100x100.png']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bundle scripts inside svg","suites":["html"],"updatePoint":{"line":602,"column":38,"index":21630},"line":602,"code":"  it('should bundle scripts inside svg', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-svg-script/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['script-a.js']\n    }, {\n      type: 'js',\n      assets: ['script-b.js']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support data attribute of object element","suites":["html"],"updatePoint":{"line":615,"column":53,"index":22005},"line":615,"code":"  it('should support data attribute of object element', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-object/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'svg',\n      assets: ['file.svg']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve assets containing spaces","suites":["html"],"updatePoint":{"line":625,"column":45,"index":22309},"line":625,"code":"  it('should resolve assets containing spaces', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-spaces/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'html',\n      assets: ['other page.html']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should process inline JS","suites":["html"],"updatePoint":{"line":635,"column":30,"index":22609},"line":635,"code":"  it('should process inline JS', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-js/index.html'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n\n    // inline bundles are not output, but are apart of the bundleGraph\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let files = await outputFS.readdir(distDir);\n    // assert that the inline js files are not output\n    assert(!files.some(filename => filename.includes('js')));\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf-8');\n    assert(!html.includes('someArgument'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should process inline styles","suites":["html"],"updatePoint":{"line":665,"column":34,"index":23514},"line":665,"code":"  it('should process inline styles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-styles/index.html'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      type: 'jpg',\n      assets: ['bg.jpg']\n    }, {\n      type: 'jpg',\n      assets: ['img.jpg']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let bundles = b.getBundles();\n    let html = await outputFS.readFile(bundles.find(bundle => bundle.type === 'html').filePath, 'utf8');\n    let urls = [...html.matchAll(/url\\(([^)]*)\\)/g)].map(m => m[1]);\n    assert.strictEqual(urls.length, 2);\n    for (let url of urls) {\n      assert(bundles.find(bundle => bundle.bundleBehavior !== 'inline' && path.basename(bundle.filePath) === url));\n    }\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should process inline element styles","suites":["html"],"updatePoint":{"line":701,"column":42,"index":24576},"line":701,"code":"  it('should process inline element styles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-styles-element/index.html'), {\n      shouldDisableCache: false\n    });\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should process inline styles using lang","suites":["html"],"updatePoint":{"line":719,"column":45,"index":25052},"line":719,"code":"  it('should process inline styles using lang', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-sass/index.html'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('<style>.index{color:#00f}</style>'));\n    assert(!html.includes('sourceMappingURL'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should process inline non-js scripts","suites":["html"],"updatePoint":{"line":736,"column":42,"index":25630},"line":736,"code":"  it('should process inline non-js scripts', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-coffeescript/index.html'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('alert(\"Hello, World!\")'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle inline css with @imports","suites":["html"],"updatePoint":{"line":752,"column":44,"index":26158},"line":752,"code":"  it('should handle inline css with @imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-css-import/index.html'));\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['index.html', 'test.css']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(!html.includes('@import'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not modify inline importmaps","suites":["html"],"updatePoint":{"line":764,"column":41,"index":26604},"line":764,"code":"  it('should not modify inline importmaps', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-importmap/index.html'), {});\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(html.includes('/node_modules/lit1.3.0/'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should expose top level declarations globally in inline <script> tags","suites":["html"],"updatePoint":{"line":773,"column":75,"index":27027},"line":773,"code":"  it('should expose top level declarations globally in inline <script> tags', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-js-script/globals.html'));\n    let logs = [];\n    let ctx = await run(b, {\n      log(bar, baz) {\n        logs.push([bar, baz]);\n      }\n    }, {\n      require: false\n    });\n    let output = ctx.output;\n    assert.equal(output.x, 2);\n    assert.equal(output.y, 'undefined');\n    assert.equal(output.z, 4);\n    assert.equal(typeof output.bar, 'function');\n    assert.equal(output.Test, 'undefined');\n    assert.equal(typeof output.Foo, 'function');\n    assert.equal(typeof output.baz, 'function');\n\n    // x is a let, so is \"global\" but not part of the global object\n    assert(!('x' in ctx));\n    assert(!('y' in ctx));\n    assert.equal(ctx.z, 4);\n    assert.equal(typeof ctx.bar, 'function');\n    assert(!('Test' in ctx));\n    assert(!('Foo' in ctx));\n    assert.equal(typeof ctx.baz, 'function');\n    assert.deepEqual(logs, [['undefined', 'function'], ['function', 'function'], ['function', 'function']]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on imports in inline scripts without type=\"module\"","suites":["html"],"updatePoint":{"line":843,"column":69,"index":29668},"line":843,"code":"  it('should error on imports in inline scripts without type=\"module\"', async function () {\n    let errored = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/html-inline-js-script/error.html'));\n    } catch (err) {\n      assert.equal(err.message, 'Browser scripts cannot have imports or exports.');\n      assert.deepEqual(err.diagnostics, [{\n        message: 'Browser scripts cannot have imports or exports.',\n        origin: '@parcel/transformer-js',\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/html-inline-js-script/error.html'),\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 5,\n              column: 7\n            },\n            end: {\n              line: 5,\n              column: 24\n            }\n          }]\n        }],\n        hints: ['Add the type=\"module\" attribute to the <script> tag.'],\n        documentationURL: 'https://parceljs.org/languages/javascript/#classic-scripts'\n      }]);\n      errored = true;\n    }\n    assert(errored);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not import swc/helpers without type=\"module\"","suites":["html"],"updatePoint":{"line":873,"column":57,"index":30716},"line":873,"code":"  it('should not import swc/helpers without type=\"module\"', async function () {\n    await bundle(path.join(__dirname, '/integration/html-js-not-import-swc-helpers-without-module/index.html'), {\n      defaultTargetOptions: {\n        engines: {\n          // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#browser_compatibility\n          browsers: ['Chrome 48']\n        }\n      }\n    });\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(!html.includes('swc/helpers'));\n    assert(html.includes('sliced_to_array'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should allow imports and requires in inline <script> tags","suites":["html"],"updatePoint":{"line":886,"column":63,"index":31338},"line":886,"code":"  it('should allow imports and requires in inline <script> tags', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-js-require/index.html'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.html', 'test.js']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('console.log(\"test\")'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support protocol-relative urls","suites":["html"],"updatePoint":{"line":902,"column":43,"index":31871},"line":902,"code":"  it('should support protocol-relative urls', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-protocol-relative/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'css',\n      assets: ['index.css']\n    }]);\n    for (let bundle of b.getBundles()) {\n      let contents = await outputFS.readFile(bundle.filePath, 'utf8');\n      assert(contents.includes('//unpkg.com/xyz'));\n    }\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support inline <script type=\"module\">","suites":["html"],"updatePoint":{"line":916,"column":50,"index":32362},"line":916,"code":"  it('should support inline <script type=\"module\">', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-js-module/index.html'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('<script type=\"module\">'));\n    assert(html.includes('document.write(\"Hello world\")'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile inline <script type=\"module\"> to non-module if not all engines support esmodules","suites":["html"],"updatePoint":{"line":933,"column":101,"index":33006},"line":933,"code":"  it('should compile inline <script type=\"module\"> to non-module if not all engines support esmodules', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-js-module/index.html'), {\n      defaultTargetOptions: {\n        mode: 'production',\n        shouldScopeHoist: true,\n        engines: {\n          browsers: '>= 0.25%'\n        }\n      }\n    });\n    await assertBundles(b, [{\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(!html.includes('<script type=\"module\">'));\n    assert(html.includes('<script>'));\n    assert(html.includes('document.write(\"Hello world\")'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile a module and nomodule script when not all engines support esmodules natively","suites":["html"],"updatePoint":{"line":955,"column":97,"index":33781},"line":955,"code":"  it('should compile a module and nomodule script when not all engines support esmodules natively', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js/index.html'), {\n      defaultTargetOptions: {\n        mode: 'production',\n        shouldScopeHoist: true,\n        engines: {\n          browsers: '>= 0.25%'\n        }\n      }\n    });\n    await assertBundles(b, [{\n      type: 'js',\n      assets: ['index.js', 'other.js']\n    }, {\n      type: 'js',\n      assets: ['index.js', 'other.js']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let bundles = b.getBundles();\n    let html = await outputFS.readFile(bundles.find(b => b.type === 'html').filePath, 'utf8');\n    assert(html.includes('<script type=\"module\" src='));\n    assert(/<script src=\".*?\" nomodule/.test(html));\n    let js = await outputFS.readFile(bundles.find(b => b.type === 'js' && b.env.outputFormat === 'esmodule').filePath, 'utf8');\n    assert(/class \\$[a-f0-9]+\\$var\\$Useless \\{/.test(js));\n    js = await outputFS.readFile(bundles.find(b => b.type === 'js' && b.env.outputFormat === 'global').filePath, 'utf8');\n    assert(!/class \\$[a-f0-9]+\\$var\\$Useless \\{/.test(js));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove type=\"module\" when not scope hoisting","suites":["html"],"updatePoint":{"line":984,"column":57,"index":34951},"line":984,"code":"  it('should remove type=\"module\" when not scope hoisting', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js/index.html'));\n    await assertBundles(b, [{\n      type: 'js',\n      assets: ['esmodule-helpers.js', 'index.js', 'other.js']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(!html.includes('<script type=\"module\"'));\n    assert(html.includes('<script src='));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not add a nomodule version when all browsers support esmodules","suites":["html"],"updatePoint":{"line":997,"column":75,"index":35499},"line":997,"code":"  it('should not add a nomodule version when all browsers support esmodules', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js/index.html'), {\n      defaultTargetOptions: {\n        mode: 'production',\n        shouldScopeHoist: true,\n        engines: {\n          browsers: 'last 1 Chrome version'\n        }\n      }\n    });\n    await assertBundles(b, [{\n      type: 'js',\n      assets: ['index.js', 'other.js']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('<script type=\"module\" src='));\n    assert(!/<script src=\".*?\" nomodule/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on imports in scripts without type=\"module\"","suites":["html"],"updatePoint":{"line":1018,"column":62,"index":36206},"line":1018,"code":"  it('should error on imports in scripts without type=\"module\"', async function () {\n    let errored = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/html-js/error.html'));\n    } catch (err) {\n      assert.equal(err.message, 'Browser scripts cannot have imports or exports.');\n      assert.deepEqual(err.diagnostics, [{\n        message: 'Browser scripts cannot have imports or exports.',\n        origin: '@parcel/transformer-js',\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/html-js/index.js'),\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 29\n            }\n          }]\n        }, {\n          filePath: path.join(__dirname, '/integration/html-js/error.html'),\n          codeHighlights: [{\n            message: 'The environment was originally created here',\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 32\n            }\n          }]\n        }],\n        hints: ['Add the type=\"module\" attribute to the <script> tag.'],\n        documentationURL: 'https://parceljs.org/languages/javascript/#classic-scripts'\n      }]);\n      errored = true;\n    }\n    assert(errored);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly bundle loaders for nested dynamic imports","suites":["html"],"updatePoint":{"line":1061,"column":64,"index":37595},"line":1061,"code":"  it('should correctly bundle loaders for nested dynamic imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js-shared-dynamic-nested/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        engines: {\n          browsers: '>= 0.25%'\n        }\n      }\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'index.js', 'index.js', 'index.js', 'js-loader.js']\n    }, {\n      type: 'js',\n      assets: ['bundle-manifest.js', 'index.js', 'index.js', 'index.js']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['simpleHasher.js']\n    }, {\n      type: 'js',\n      assets: ['simpleHasher.js']\n    }]);\n    let res = await run(b, {\n      output: null\n    }, {\n      require: false\n    });\n    assert.deepEqual(await res.output, ['hasher', ['hasher', 'hasher']]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support shared bundles between multiple inline scripts","suites":["html"],"updatePoint":{"line":1094,"column":67,"index":38582},"line":1094,"code":"  it('should support shared bundles between multiple inline scripts', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-js-shared/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        shouldOptimize: false\n      }\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['lodash.js']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('<script type=\"module\" src=\"'));\n    assert(html.includes('<script type=\"module\">'));\n    assert(html.includes('.add(1, 2)'));\n    assert(html.includes('.add(2, 3)'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"inserts sibling bundles into html in the correct order (no head)","suites":["html"],"updatePoint":{"line":1121,"column":70,"index":39443},"line":1121,"code":"  it('inserts sibling bundles into html in the correct order (no head)', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js-shared/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['async.js']\n    }, {\n      type: 'js',\n      assets: ['bundle-manifest.js', 'get-worker-url.js', 'index.js', 'lodash.js']\n    }, {\n      name: 'index.html',\n      type: 'html',\n      assets: ['index.html']\n    },\n    // {\n    //   type: 'js',\n    //   assets: ['lodash.js'],\n    // },\n    {\n      type: 'js',\n      assets: ['worker.js', 'lodash.js']\n    }]);\n\n    // let lodashSibling = path.basename(\n    //   b.getBundles().find(v => v.getEntryAssets().length === 0).filePath,\n    // );\n\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    let insertedBundles = [];\n    let regex = /<script (?:type=\"[^\"]+\" )?src=\"([^\"]*)\"><\\/script>/g;\n    let match;\n    while ((match = regex.exec(html)) !== null) {\n      insertedBundles.push(path.basename(match[1]));\n    }\n    assert.equal(insertedBundles.length, 1);\n    // assert.equal(insertedBundles.length, 2);\n    // assert.equal(insertedBundles[0], lodashSibling);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"inserts sibling bundles into html in the correct order (head)","suites":["html"],"updatePoint":{"line":1164,"column":67,"index":40737},"line":1164,"code":"  it('inserts sibling bundles into html in the correct order (head)', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js-shared-head/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['async.js']\n    }, {\n      type: 'js',\n      assets: ['bundle-manifest.js', 'get-worker-url.js', 'index.js', 'lodash.js']\n    }, {\n      name: 'index.html',\n      type: 'html',\n      assets: ['index.html']\n    },\n    // {\n    //   type: 'js',\n    //   assets: ['lodash.js'],\n    // },\n    {\n      type: 'js',\n      assets: ['worker.js', 'lodash.js']\n    }]);\n\n    // let lodashSibling = path.basename(\n    //   b.getBundles().find(v => v.getEntryAssets().length === 0).filePath,\n    // );\n\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    let insertedBundles = [];\n    let regex = /<script (?:type=\"[^\"]+\" )?src=\"([^\"]*)\"><\\/script>/g;\n    let match;\n    while ((match = regex.exec(html)) !== null) {\n      insertedBundles.push(path.basename(match[1]));\n    }\n    assert.equal(insertedBundles.length, 1);\n    // assert.equal(insertedBundles.length, 2);\n    // assert.equal(insertedBundles[0], lodashSibling);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"inserts sibling bundles into html with nomodule or type=module","suites":["html"],"updatePoint":{"line":1207,"column":68,"index":42037},"line":1207,"code":"  it('inserts sibling bundles into html with nomodule or type=module', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js-shared-nomodule/*.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        shouldOptimize: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'a.html',\n      assets: ['a.html']\n    }, {\n      type: 'js',\n      assets: ['a.js']\n    }, {\n      type: 'js',\n      assets: ['a.js']\n    }, {\n      name: 'b.html',\n      assets: ['b.html']\n    }, {\n      type: 'js',\n      assets: ['b.js']\n    }, {\n      type: 'js',\n      assets: ['b.js']\n    }, {\n      type: 'js',\n      assets: ['lib.js']\n    }, {\n      type: 'js',\n      assets: ['lib.js']\n    }]);\n    for (let file of b.getBundles().filter(b => b.type === 'html').map(b => b.filePath)) {\n      let html = await outputFS.readFile(file, 'utf8');\n      let noModuleScripts = [];\n      let moduleScripts = [];\n      let regex = /<script ([^>]*)><\\/script>/g;\n      let match;\n      while ((match = regex.exec(html)) !== null) {\n        let attributes = new Map(match[1].split(' ').map(a => a.split('=')));\n        let url = attributes.get('src').replace(/\"/g, '');\n        assert(url);\n        if (attributes.get('type') === '\"module\"') {\n          assert.strictEqual(attributes.size, 2);\n          moduleScripts.push(path.basename(url));\n        } else {\n          assert.strictEqual(attributes.size, 3);\n          assert(attributes.get('nomodule'));\n          assert(attributes.get('defer'));\n          noModuleScripts.push(path.basename(url));\n        }\n      }\n      for (let scripts of [moduleScripts, noModuleScripts]) {\n        assert.strictEqual(scripts.length, 2);\n        assert(b.getBundles().find(b => b.filePath.endsWith(scripts[0])).getMainEntry() == null);\n        assert(b.getBundles().find(b => b.filePath.endsWith(scripts[1])).getMainEntry());\n      }\n    }\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should isolate async scripts","suites":["html"],"updatePoint":{"line":1267,"column":34,"index":43945},"line":1267,"code":"  it('should isolate async scripts', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-async-script/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        shouldOptimize: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      assets: ['a.js', 'c.js']\n    }, {\n      assets: ['b.js', 'c.js']\n    }]);\n    let output = [];\n    await run(b, {\n      output(o) {\n        output.push(o);\n      }\n    });\n\n    // could run in either order.\n    assert(output.sort(), ['a', 'b', 'c']);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should isolate classic scripts from nomodule scripts","suites":["html"],"updatePoint":{"line":1293,"column":58,"index":44605},"line":1293,"code":"  it('should isolate classic scripts from nomodule scripts', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-isolate-script/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        shouldOptimize: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      assets: ['a.js', 'bundle-manifest.js']\n    }, {\n      assets: ['a.js', 'bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['b.js', 'bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['c.js']\n    }, {\n      assets: ['c.js']\n    }]);\n    let output = [];\n    await run(b, {\n      output(o) {\n        output.push(o);\n      }\n    });\n\n    // could run in either order.\n    assert(output.sort(), ['a', 'b', 'c']);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support multiple entries with shared sibling bundles","suites":["html"],"updatePoint":{"line":1325,"column":65,"index":45522},"line":1325,"code":"  it('should support multiple entries with shared sibling bundles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/shared-sibling-entries/*.html'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      name: 'a.html',\n      type: 'html',\n      assets: ['a.html']\n    }, {\n      name: 'b.html',\n      type: 'html',\n      assets: ['b.html']\n    }, {\n      name: 'c.html',\n      type: 'html',\n      assets: ['c.html']\n    }, {\n      type: 'js',\n      assets: ['a.html', 'shared.js']\n    }, {\n      type: 'js',\n      assets: ['b.html', 'shared.js']\n    }, {\n      type: 'js',\n      assets: ['c.html', 'shared.js']\n    }, {\n      type: 'css',\n      assets: ['other.css']\n    }, {\n      type: 'css',\n      assets: ['shared.css']\n    }]);\n\n    // Both HTML files should point to the sibling CSS file\n    let html = await outputFS.readFile(path.join(distDir, 'a.html'), 'utf8');\n    assert(/<link rel=\"stylesheet\" href=\"\\/a\\.[a-z0-9]+\\.css\">/.test(html));\n    html = await outputFS.readFile(path.join(distDir, 'b.html'), 'utf8');\n    assert(/<link rel=\"stylesheet\" href=\"\\/a\\.[a-z0-9]+\\.css\">/.test(html));\n    html = await outputFS.readFile(path.join(distDir, 'c.html'), 'utf8');\n    assert(/<link rel=\"stylesheet\" href=\"\\/a\\.[a-z0-9]+\\.css\">/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert JS sibling bundle script tags in the correct order","suites":["html"],"updatePoint":{"line":1368,"column":70,"index":46871},"line":1368,"code":"  it('should insert JS sibling bundle script tags in the correct order', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/interop-async/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        shouldOptimize: false\n      }\n    });\n    let bundles = b.getBundles();\n    assertBundles(b, [{\n      name: 'index.html',\n      type: 'html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js', 'index.js', 'index.js', 'index.js', 'client.js', 'bundle-manifest.js']\n    }, {\n      type: 'js',\n      assets: ['viewer.js']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    let insertedBundles = [];\n    let regex = /<script (?:type=\"[^\"]+\" )?src=\"([^\"]*)\"><\\/script>/g;\n    let match;\n    while ((match = regex.exec(html)) !== null) {\n      let bundle = bundles.find(b => path.basename(b.filePath) === path.basename(match[1]));\n      insertedBundles.push(bundle);\n    }\n    assert.equal(insertedBundles.length, 1);\n    let res = await run(b, {\n      output: null\n    }, {\n      require: false\n    });\n    assert.deepEqual(await res.output, ['client', 'client', 'viewer']);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not point to unrelated sibling bundles","suites":["html"],"updatePoint":{"line":1404,"column":51,"index":48101},"line":1404,"code":"  it('should not point to unrelated sibling bundles', async function () {\n    await bundle(path.join(__dirname, '/integration/shared-sibling-entries-multiple/*.html'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n\n    // a.html should point to a CSS bundle containing a.css as well as\n    // reuse the b.css bundle from b.html.\n    let html = await outputFS.readFile(path.join(distDir, 'a.html'), 'utf8');\n    assert.equal(html.match(/<link rel=\"stylesheet\" href=\"\\/\\w+\\.[a-z0-9]+\\.css\">/g).length, 2);\n\n    // a.html should reference a.js only\n    assert.equal(html.match(/a\\.[a-z0-9]+\\.js/g).length, 1);\n    assert.equal(html.match(/b\\.[a-z0-9]+\\.js/g), null);\n    let css = await outputFS.readFile(path.join(distDir, html.match(/\\/\\w+\\.[a-z0-9]+\\.css/g)[0]), 'utf8');\n    assert(css.includes('.a {'));\n    assert(!css.includes('.b {'));\n\n    // b.html should point to a CSS bundle containing only b.css\n    // It should not point to the bundle containing a.css from a.html\n    html = await outputFS.readFile(path.join(distDir, 'b.html'), 'utf8');\n    assert.equal(html.match(/<link rel=\"stylesheet\" href=\"\\/\\w+\\.[a-z0-9]+\\.css\">/g).length, 1);\n\n    // b.html should reference b.js only\n    assert.equal(html.match(/a\\.[a-z0-9]+\\.js/g), null);\n    assert.equal(html.match(/b\\.[a-z0-9]+\\.js/g).length, 1);\n    css = await outputFS.readFile(path.join(distDir, html.match(/\\/\\w+\\.[a-z0-9]+\\.css/)[0]), 'utf8');\n    assert(!css.includes('.a {'));\n    assert(css.includes('.b {'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support split bundles with many pages","suites":["html"],"updatePoint":{"line":1435,"column":50,"index":49619},"line":1435,"code":"  it('should support split bundles with many pages', async function () {\n    await bundle(path.join(__dirname, '/integration/shared-many/*.html'), {\n      mode: 'production'\n    });\n    let html = await outputFS.readFile(path.join(distDir, 'a.html'), 'utf8');\n    assert.equal(html.match(/<script/g).length, 2);\n    html = await outputFS.readFile(path.join(distDir, 'b.html'), 'utf8');\n    assert.equal(html.match(/<script/g).length, 2);\n    html = await outputFS.readFile(path.join(distDir, 'c.html'), 'utf8');\n    assert.equal(html.match(/<script/g).length, 2);\n    html = await outputFS.readFile(path.join(distDir, 'd.html'), 'utf8');\n    assert.equal(html.match(/<script/g).length, 2);\n    html = await outputFS.readFile(path.join(distDir, 'e.html'), 'utf8');\n    assert.equal(html.match(/<script/g).length, 1);\n    html = await outputFS.readFile(path.join(distDir, 'f.html'), 'utf8');\n    assert.equal(html.match(/<script/g).length, 1);\n\n    // b.html hitting the parallel request limit should not prevent g.html from being optimized\n    html = await outputFS.readFile(path.join(distDir, 'g.html'), 'utf8');\n    assert.equal(html.match(/<script/g).length, 1);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not add CSS to a worker bundle group","suites":["html"],"updatePoint":{"line":1456,"column":49,"index":50789},"line":1456,"code":"  it('should not add CSS to a worker bundle group', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/shared-sibling-worker-css/index.html'));\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['style.css']\n    }, {\n      type: 'html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['a.js', 'worker.js', 'esmodule-helpers.js']\n    }, {\n      type: 'js',\n      assets: ['a.js', 'bundle-url.js', 'esmodule-helpers.js', 'get-worker-url.js', 'index.js']\n    }]);\n    let htmlBundle = b.getBundles().find(b => b.type === 'html');\n    let htmlSiblings = b.getReferencedBundles(htmlBundle);\n    assert.equal(htmlSiblings.length, 2);\n    assert(htmlSiblings.some(b => b.type === 'js'));\n    assert(htmlSiblings.some(b => b.type === 'css'));\n    let worker = b.getChildBundles(htmlSiblings.find(b => b.type === 'js'));\n    assert.equal(worker.length, 1);\n    let workerSiblings = b.getReferencedBundles(worker[0]);\n    assert.equal(workerSiblings.length, 0);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly add sibling bundles to all using bundles","suites":["html"],"updatePoint":{"line":1481,"column":63,"index":51820},"line":1481,"code":"  it('should correctly add sibling bundles to all using bundles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/shared-sibling/*.html'));\n    assertBundles(b, [{\n      type: 'html',\n      assets: ['form.html']\n    }, {\n      type: 'js',\n      assets: ['form.js', 'a.js', 'a.module.css', 'esmodule-helpers.js']\n    }, {\n      type: 'css',\n      assets: ['a.module.css']\n    }, {\n      type: 'html',\n      assets: ['searchfield.html']\n    }, {\n      type: 'js',\n      assets: ['searchfield.js', 'a.js', 'a.module.css', 'b.js', 'esmodule-helpers.js']\n    }, {\n      type: 'html',\n      assets: ['searchfield2.html']\n    }, {\n      type: 'js',\n      assets: ['searchfield2.js', 'a.js', 'a.module.css', 'b.js', 'esmodule-helpers.js']\n    }]);\n    for (let htmlBundle of b.getBundles().filter(b => b.type === 'html')) {\n      let htmlSiblings = b.getReferencedBundles(htmlBundle, true).map(b => b.type).sort();\n      assert.deepEqual(htmlSiblings, ['css', 'js']);\n    }\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove duplicate assets from sibling bundles","suites":["html"],"updatePoint":{"line":1510,"column":57,"index":52818},"line":1510,"code":"  it('should remove duplicate assets from sibling bundles', async function () {\n    let bundleGraph = await bundle(path.join(__dirname, '/integration/shared-sibling-duplicate/*.html'), {\n      mode: 'production'\n    });\n    bundleGraph.traverseBundles(bundle => {\n      bundle.traverseAssets(asset => {\n        let bundles = bundleGraph.getBundlesWithAsset(asset);\n        assert.equal(bundles.length, 1, `asset ${asset.filePath} is duplicated`);\n      });\n    });\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support split bundles with many pages with esmodule output","suites":["html"],"updatePoint":{"line":1521,"column":71,"index":53303},"line":1521,"code":"  it('should support split bundles with many pages with esmodule output', async function () {\n    await bundle(path.join(__dirname, '/integration/shared-many-esm/*.html'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let checkHtml = async filename => {\n      // Find all scripts referenced in the HTML file\n      let html = await outputFS.readFile(path.join(distDir, filename), 'utf8');\n      let re = /<script.*?src=\"(.*?)\"/g;\n      let match;\n      let scripts = new Set();\n      while (match = re.exec(html)) {\n        scripts.add(path.join(distDir, match[1]));\n      }\n      assert(scripts.size > 0, 'no scripts found');\n\n      // Ensure that those scripts don't import anything other than what's in the HTML.\n      for (let script of scripts) {\n        let js = await outputFS.readFile(script, 'utf8');\n        let re = /import .*? from \"(.*?)\"/g;\n        let match;\n        while (match = re.exec(js)) {\n          let imported = path.join(distDir, match[1]);\n          assert(scripts.has(imported), `unknown script ${match[1]} imported in ${path.basename(script)}`);\n        }\n      }\n    };\n    for (let letter of ['a', 'b', 'c', 'd', 'e', 'f', 'g']) {\n      await checkHtml(letter + '.html');\n    }\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should include the correct paths when using multiple entries and referencing style from html and js","suites":["html"],"updatePoint":{"line":1553,"column":105,"index":54588},"line":1553,"code":"  it('should include the correct paths when using multiple entries and referencing style from html and js', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-multi-entry/*.html'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      name: 'a.html',\n      type: 'html',\n      assets: ['a.html']\n    }, {\n      name: 'b.html',\n      type: 'html',\n      assets: ['b.html']\n    }, {\n      type: 'css',\n      assets: ['style.css']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }]);\n    let firstHtmlFile = await outputFS.readFile(path.join(distDir, 'a.html'), 'utf8');\n    let secondHtmlFile = await outputFS.readFile(path.join(distDir, 'b.html'), 'utf8');\n    let bundles = b.getBundles();\n    let cssBundle = path.basename(bundles.find(bundle => bundle.filePath.endsWith('.css')).filePath);\n    let jsBundle = path.basename(bundles.find(bundle => bundle.filePath.endsWith('.js')).filePath);\n    assert(firstHtmlFile.includes(cssBundle), `a.html should include a reference to ${cssBundle}`);\n    assert(secondHtmlFile.includes(cssBundle), `b.html should include a reference to ${cssBundle}`);\n    assert(firstHtmlFile.includes(jsBundle), `a.html should include a reference to ${jsBundle}`);\n    assert(secondHtmlFile.includes(jsBundle), `b.html should include a reference to ${jsBundle}`);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate parent bundle when inline bundles change","suites":["html"],"updatePoint":{"line":1584,"column":64,"index":55942},"line":1584,"code":"  it('should invalidate parent bundle when inline bundles change', async function () {\n    // copy into memory fs\n    await ncp(path.join(__dirname, '/integration/html-inline-js-require'), path.join(__dirname, '/html-inline-js-require'));\n    let distDir = path.join(outputFS.cwd(), 'dist');\n    let b = await bundler(path.join(__dirname, '/html-inline-js-require/index.html'), {\n      inputFS: overlayFS,\n      shouldDisableCache: false,\n      defaultTargetOptions: {\n        distDir\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let html = await outputFS.readFile('/dist/index.html', 'utf8');\n    assert(html.includes(`console.log(\"test\")`));\n    await overlayFS.writeFile(path.join(__dirname, '/html-inline-js-require/test.js'), \"console.log('foo')\");\n    await getNextBuild(b);\n    html = await outputFS.readFile(path.join(distDir, '/index.html'), 'utf8');\n    assert(html.includes(`console.log(\"foo\")`));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate parent bundle when nested inline bundles change","suites":["html"],"updatePoint":{"line":1604,"column":71,"index":56902},"line":1604,"code":"  it('should invalidate parent bundle when nested inline bundles change', async function () {\n    // copy into memory fs\n    await ncp(path.join(__dirname, '/integration/html-inline-js-nested'), path.join(__dirname, '/html-inline-js-nested'));\n    let distDir = path.join(outputFS.cwd(), 'dist');\n    let b = await bundler(path.join(__dirname, '/html-inline-js-nested/index.html'), {\n      inputFS: overlayFS,\n      shouldDisableCache: false,\n      defaultTargetOptions: {\n        distDir\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let html = await outputFS.readFile('/dist/index.html', 'utf8');\n    assert(html.includes('module.exports = \"hello world\"'));\n    assert(html.includes('console.log'));\n    await overlayFS.writeFile(path.join(__dirname, '/html-inline-js-nested/test.txt'), 'foo bar');\n    await getNextBuild(b);\n    html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(!html.includes('module.exports = \"hello world\"'));\n    assert(html.includes('module.exports = \"foo bar\"'));\n    assert(html.includes('console.log'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline data-urls","suites":["html"],"updatePoint":{"line":1627,"column":29,"index":57970},"line":1627,"code":"  it('should inline data-urls', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/data-url/index.html'), {\n      defaultTargetOptions: {\n        sourceMaps: false\n      }\n    });\n    let contents = await outputFS.readFile(b.getBundles().find(b => b.type === 'html').filePath, 'utf8');\n    assert.equal(contents.trim(), `<img src=\"data:image/svg+xml,%3Csvg%20width%3D%22120%22%20height%3D%22120%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%20%20%3Cfilter%20id%3D%22blur-_.%21~%2a%22%3E%0A%20%20%20%20%3CfeGaussianBlur%20stdDeviation%3D%225%22%3E%3C%2FfeGaussianBlur%3E%0A%20%20%3C%2Ffilter%3E%0A%20%20%3Ccircle%20cx%3D%2260%22%20cy%3D%2260%22%20r%3D%2250%22%20fill%3D%22green%22%20filter%3D%22url%28%27%23blur-_.%21~%2a%27%29%22%3E%3C%2Fcircle%3E%0A%3C%2Fsvg%3E%0A\">`);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should print a diagnostic for invalid bundler options","suites":["html"],"updatePoint":{"line":1636,"column":59,"index":58816},"line":1636,"code":"  it('should print a diagnostic for invalid bundler options', async () => {\n    let dir = path.join(__dirname, 'integration/invalid-bundler-config');\n    let pkg = path.join(dir, 'package.json');\n    let code = await inputFS.readFileSync(pkg, 'utf8');\n    await assert.rejects(() => bundle(path.join(dir, 'index.html')), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: 'Invalid config for @parcel/bundler-default',\n        origin: '@parcel/bundler-default',\n        codeFrames: [{\n          filePath: pkg,\n          language: 'json',\n          code,\n          codeHighlights: [{\n            message: 'Did you mean \"minBundleSize\", \"minBundles\"?',\n            start: {\n              column: 30,\n              line: 3\n            },\n            end: {\n              column: 45,\n              line: 3\n            }\n          }]\n        }]\n      }]\n    });\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should escape inline script tags","suites":["html"],"updatePoint":{"line":1664,"column":38,"index":59673},"line":1664,"code":"  it('should escape inline script tags', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/html-inline-escape/script.html'));\n    let output;\n    await run(b, {\n      output(o) {\n        output = o;\n      }\n    });\n    assert.deepEqual(output, {\n      a: '<script></script>',\n      b: '<!-- test',\n      c: '<SCRIPT></SCRIPT>'\n    });\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should share older JS sibling (script) assets to younger siblings","suites":["html"],"updatePoint":{"line":1678,"column":71,"index":60076},"line":1678,"code":"  it('should share older JS sibling (script) assets to younger siblings', async function () {\n    // JS script tags are siblings to a common parent, and are marked as such by parallel dependency priority\n    // Becuase of load order any older sibling (and it's assets) are loaded before any subsequent sibling\n    // Which means no younger sibling should have to reference sibling bundles for assets in them\n    let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/sibling-dependencies/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      assets: ['a.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['b.js']\n    }]);\n    let youngerSibling; // bundle containing younger sibling, b.js\n    let olderSibling; // bundle containing old sibling, a.js\n    b.traverseBundles(bundle => {\n      bundle.traverseAssets(asset => {\n        if (asset.filePath.includes('b.js')) {\n          youngerSibling = bundle;\n        } else if (asset.filePath.includes('a.js')) {\n          olderSibling = bundle;\n        }\n      });\n    });\n    assert(b.getReferencedBundles(youngerSibling).filter(b => b == olderSibling).length == 0);\n    let res = await run(b, {\n      output: null\n    }, {\n      require: false\n    });\n    assert.equal(res.output, 'a');\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should escape quotes in inline style attributes and style tags","suites":["html"],"updatePoint":{"line":1710,"column":68,"index":61390},"line":1710,"code":"  it('should escape quotes in inline style attributes and style tags', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/html-inline-escape/style.html'));\n    let output = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(output.includes(`content: &quot;hi&quot;`));\n    assert(output.includes('<\\\\/style>'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with bundle names that have colons in them","suites":["html"],"updatePoint":{"line":1716,"column":60,"index":61749},"line":1716,"code":"  it('should work with bundle names that have colons in them', async function () {\n    if (process.platform === 'win32') {\n      return;\n    }\n\n    // Windows paths cannot contain colons and will fail to git clone, so write the file here (in memory).\n    await overlayFS.mkdirp(path.join(__dirname, 'integration/url-colon'));\n    await overlayFS.writeFile(path.join(__dirname, 'integration/url-colon/a:b:c.html'), '<p>Test</p>');\n    let b = await bundle(path.join(__dirname, 'integration/url-colon/relative.html'), {\n      inputFS: overlayFS\n    });\n    assertBundles(b, [{\n      name: 'relative.html',\n      assets: ['relative.html']\n    }, {\n      name: 'a:b:c.html',\n      assets: ['a:b:c.html']\n    }]);\n    let output = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(output.includes('/a:b:c.html'));\n    b = await bundle(path.join(__dirname, 'integration/url-colon/absolute.html'), {\n      inputFS: overlayFS\n    });\n    assertBundles(b, [{\n      name: 'absolute.html',\n      assets: ['absolute.html']\n    }, {\n      name: 'a:b:c.html',\n      assets: ['a:b:c.html']\n    }]);\n    output = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(output.includes('/a:b:c.html'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should normalize case of SVG elements and attributes when minified","suites":["html"],"updatePoint":{"line":1749,"column":72,"index":62991},"line":1749,"code":"  it('should normalize case of SVG elements and attributes when minified', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/html-svg-case/index.html'), {\n      mode: 'production'\n    });\n    let output = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(output.includes('<x-custom stddeviation=\"0.5\"'));\n    assert(output.includes('<svg role=\"img\" viewBox='));\n    assert(output.includes('<filter'));\n    assert(output.includes('<feGaussianBlur in=\"SourceGraphic\" stdDeviation='));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw error with empty string reference to other resource","suites":["html"],"updatePoint":{"line":1759,"column":70,"index":63529},"line":1759,"code":"  it('should throw error with empty string reference to other resource', async function () {\n    await assert.rejects(() => bundle(path.join(__dirname, 'integration/html-empty-reference/index.html'), {\n      mode: 'production'\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: \"'src' should not be empty string\",\n        origin: '@parcel/transformer-html',\n        codeFrames: [{\n          filePath: path.join(__dirname, 'integration/html-empty-reference/index.html'),\n          language: 'html',\n          codeHighlights: [{\n            start: {\n              column: 1,\n              line: 1\n            },\n            end: {\n              column: 14,\n              line: 1\n            }\n          }]\n        }]\n      }, {\n        message: \"'src' should not be empty string\",\n        origin: '@parcel/transformer-html',\n        codeFrames: [{\n          filePath: path.join(__dirname, 'integration/html-empty-reference/index.html'),\n          language: 'html',\n          codeHighlights: [{\n            start: {\n              column: 1,\n              line: 2\n            },\n            end: {\n              column: 24,\n              line: 2\n            }\n          }]\n        }]\n      }, {\n        message: \"'href' should not be empty string\",\n        origin: '@parcel/transformer-html',\n        codeFrames: [{\n          filePath: path.join(__dirname, 'integration/html-empty-reference/index.html'),\n          language: 'html',\n          codeHighlights: [{\n            start: {\n              column: 1,\n              line: 3\n            },\n            end: {\n              column: 16,\n              line: 3\n            }\n          }]\n        }]\n      }]\n    });\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"extracts shared bundles that load referenced bundle roots across entries","suites":["html"],"updatePoint":{"line":1818,"column":78,"index":65230},"line":1818,"code":"  it('extracts shared bundles that load referenced bundle roots across entries', async () => {\n    let b = await bundle(['index1.html', 'index2.html'].map(entry => path.join(__dirname, 'integration/html-shared-referenced', entry)), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    await run(b);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not skip bundleRoots if an asset is both async required and static required","suites":["html"],"updatePoint":{"line":1827,"column":88,"index":65600},"line":1827,"code":"  it('should not skip bundleRoots if an asset is both async required and static required', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/html-sync-async-asset/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    await run(b, {\n      output: null\n    }, {\n      require: false\n    });\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should be able to resize images","suites":["image"],"updatePoint":{"line":8,"column":37,"index":285},"line":8,"code":"  it('Should be able to resize images', async () => {\n    await bundle(path.join(__dirname, '/integration/image/resized.js'));\n    let dirContent = await outputFS.readdir(distDir);\n    let imagePath = '';\n    let foundExtensions = [];\n    for (let filename of dirContent) {\n      let ext = path.extname(filename);\n      foundExtensions.push(ext);\n      if (ext === '.jpeg') {\n        imagePath = path.join(distDir, filename);\n      }\n    }\n    assert.deepStrictEqual(foundExtensions.sort(), ['.jpeg', '.js', '.map'].sort());\n    let buffer = await outputFS.readFile(imagePath);\n    let image = await sharp(buffer).metadata();\n    assert.equal(image.width, 600);\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should be able to import an image using multiple varying query parameters","suites":["image"],"updatePoint":{"line":25,"column":79,"index":995},"line":25,"code":"  it('Should be able to import an image using multiple varying query parameters', async () => {\n    await bundle(path.join(__dirname, '/integration/image-multiple-queries/index.html'));\n    let dirContent = await outputFS.readdir(distDir);\n    let foundExtensions = [];\n    for (let filename of dirContent) {\n      const foundExt = path.extname(filename);\n      if (foundExt !== '.map') {\n        foundExtensions.push(foundExt);\n      }\n    }\n    assert.deepStrictEqual(foundExtensions.sort(), ['.jpeg', '.jpeg', '.webp', '.html'].sort());\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"from JS","suites":["image","Should be able to change image format"],"updatePoint":{"line":52,"column":15,"index":2064},"line":52,"code":"    it('from JS', testCase('js'));","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"from HTML","suites":["image","Should be able to change image format"],"updatePoint":{"line":53,"column":17,"index":2101},"line":53,"code":"    it('from HTML', testCase('html'));","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"from CSS","suites":["image","Should be able to change image format"],"updatePoint":{"line":54,"column":16,"index":2139},"line":54,"code":"    it('from CSS', testCase('css'));","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"all formats","suites":["image","Should be able to change image format"],"updatePoint":{"line":55,"column":19,"index":2179},"line":55,"code":"    it('all formats', async () => {\n      let b = await bundle(path.join(__dirname, `/integration/image/reformat-all.html`));\n      let foundExtensions = new Set(b.getBundles().map(({\n        type\n      }) => type));\n      assert.deepStrictEqual(foundExtensions, new Set(['html', 'webp', 'avif', 'jpeg', 'png', 'tiff']));\n    });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should lossless optimise JPEGs","suites":["image","Should be able to change image format"],"updatePoint":{"line":63,"column":36,"index":2532},"line":63,"code":"  it('should lossless optimise JPEGs', async function () {\n    let img = path.join(__dirname, '/integration/image/image.jpg');\n    let b = await bundle(img, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    const imagePath = b.getBundles().find(b => b.type === 'jpg').filePath;\n    let input = await inputFS.readFile(img);\n    let inputRaw = await sharp(input).toFormat('raw').toBuffer();\n    let output = await outputFS.readFile(imagePath);\n    let outputRaw = await sharp(output).toFormat('raw').toBuffer();\n    assert(outputRaw.equals(inputRaw));\n    assert(output.length < input.length);\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should lossless optimise progressive JPEGs","suites":["image","Should be able to change image format"],"updatePoint":{"line":78,"column":48,"index":3173},"line":78,"code":"  it('should lossless optimise progressive JPEGs', async function () {\n    let img = path.join(__dirname, '/integration/image/banana.jpg');\n    let b = await bundle(img, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      },\n      logLevel: 'verbose'\n    });\n    const imagePath = b.getBundles().find(b => b.type === 'jpg').filePath;\n\n    // let input = await inputFS.readFile(img);\n    // let inputRaw = await sharp(input)\n    //   .toFormat('raw')\n    //   .toBuffer();\n    // Check validity of image\n    let output = await outputFS.readFile(imagePath);\n    await sharp(output).toFormat('raw').toBuffer();\n\n    // assert(outputRaw.equals(inputRaw));\n    // assert(output.length < input.length);\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should lossless optimise PNGs","suites":["image","Should be able to change image format"],"updatePoint":{"line":100,"column":35,"index":3879},"line":100,"code":"  it('should lossless optimise PNGs', async function () {\n    let img = path.join(__dirname, '/integration/image/clock.png');\n    let b = await bundle(img, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    const imagePath = b.getBundles().find(b => b.type === 'png').filePath;\n    let input = await inputFS.readFile(img);\n    let inputRaw = await sharp(input).toFormat('raw').toBuffer();\n    let output = await outputFS.readFile(imagePath);\n    let outputRaw = await sharp(output).toFormat('raw').toBuffer();\n    assert(outputRaw.equals(inputRaw));\n    assert(output.length < input.length);\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"support config files for jpeg files","suites":["image","Should be able to change image format"],"updatePoint":{"line":115,"column":41,"index":4513},"line":115,"code":"  it('support config files for jpeg files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/image-config/image.jpg'), {\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    const originalSize = 549196;\n    const imagePath = b.getBundles().find(b => b.type === 'jpeg').filePath;\n    const buffer = await outputFS.readFile(imagePath);\n    const image = await sharp(buffer).metadata();\n    assert.strictEqual(image.width, 1920);\n    assert.strictEqual(image.chromaSubsampling, '4:4:4');\n    assert(image.size < originalSize);\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"support config files for png files","suites":["image","Should be able to change image format"],"updatePoint":{"line":129,"column":40,"index":5100},"line":129,"code":"  it('support config files for png files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/image-config/clock.png'), {\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    const originalSize = 84435;\n    const imagePath = b.getBundles().find(b => b.type === 'png').filePath;\n    const buffer = await outputFS.readFile(imagePath);\n    const image = await sharp(buffer).metadata();\n    assert.strictEqual(image.width, 200);\n    assert.strictEqual(image.paletteBitDepth, 8);\n    assert(image.size < originalSize);\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should retain EXIF data","suites":["image","Should be able to change image format"],"updatePoint":{"line":143,"column":29,"index":5665},"line":143,"code":"  it('should retain EXIF data', async () => {\n    const b = await bundle(path.join(__dirname, '/integration/image-exif/resized.html'));\n    const imagePath = b.getBundles().find(b => b.type === 'jpeg').filePath;\n    const buffer = await outputFS.readFile(imagePath);\n    const image = await sharp(buffer).metadata();\n    const {\n      exif\n    } = exifReader(image.exif);\n    assert.strictEqual(exif.UserComment.toString(), 'ASCII\\u0000\\u0000\\u0000This is a comment');\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove EXIF data when optimizing","suites":["image","Should be able to change image format"],"updatePoint":{"line":153,"column":45,"index":6156},"line":153,"code":"  it('should remove EXIF data when optimizing', async () => {\n    const b = await bundle(path.join(__dirname, '/integration/image-exif/resized.html'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    const imagePath = b.getBundles().find(b => b.type === 'jpeg').filePath;\n    const buffer = await outputFS.readFile(imagePath);\n    const image = await sharp(buffer).metadata();\n    assert.strictEqual(image.exif, undefined);\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should use the EXIF orientation tag when resizing","suites":["image","Should be able to change image format"],"updatePoint":{"line":164,"column":55,"index":6628},"line":164,"code":"  it('should use the EXIF orientation tag when resizing', async () => {\n    const b = await bundle(path.join(__dirname, '/integration/image-exif/resized.html'));\n    const imagePath = b.getBundles().find(b => b.type === 'jpeg').filePath;\n    const buffer = await outputFS.readFile(imagePath);\n    const image = await sharp(buffer).metadata();\n    assert.strictEqual(image.orientation, 1);\n    assert.strictEqual(image.width, 240);\n    assert.strictEqual(image.height, 320);\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"add a console log should not bundle by default","suites":["incremental bundling","non-dependency based changes","javascript"],"updatePoint":{"line":32,"column":56,"index":1552},"line":32,"code":"      it('add a console log should not bundle by default', async () => {\n        let subscription;\n        let fixture = path.join(__dirname, '/integration/incremental-bundling');\n        try {\n          let b = bundler(path.join(fixture, 'index.js'), {\n            inputFS: overlayFS,\n            shouldDisableCache: false\n          });\n          await overlayFS.mkdirp(fixture);\n          subscription = await b.watch();\n          let event = await getNextBuildSuccess(b);\n          assertTimesBundled(defaultBundlerSpy.callCount, 1);\n          await overlayFS.writeFile(path.join(fixture, 'index.js'), `import {a} from './a';\nconsole.log('index.js');\nconsole.log(a);\nconsole.log('adding a new console');`);\n          event = await getNextBuildSuccess(b);\n          assertChangedAssets(event.changedAssets.size, 1);\n          assertTimesBundled(defaultBundlerSpy.callCount, 1);\n          let result = await b.run();\n          let contents = await overlayFS.readFile(result.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes(`console.log(\"adding a new console\")`));\n        } finally {\n          if (subscription) {\n            await subscription.unsubscribe();\n            subscription = null;\n          }\n        }\n      });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"disable by setting option to false","suites":["incremental bundling","non-dependency based changes","javascript"],"updatePoint":{"line":61,"column":44,"index":2799},"line":61,"code":"      it('disable by setting option to false', async () => {\n        let subscription;\n        let fixture = path.join(__dirname, '/integration/incremental-bundling');\n        try {\n          let b = bundler(path.join(fixture, 'index.js'), {\n            inputFS: overlayFS,\n            shouldDisableCache: false,\n            shouldBundleIncrementally: false\n          });\n          await overlayFS.mkdirp(fixture);\n          subscription = await b.watch();\n          let event = await getNextBuildSuccess(b);\n          assertTimesBundled(defaultBundlerSpy.callCount, 1);\n          await overlayFS.writeFile(path.join(fixture, 'index.js'), `import {a} from './a';\nconsole.log('index.js');\nconsole.log(a);\nconsole.log('adding a new console');`);\n          event = await getNextBuildSuccess(b);\n          assertChangedAssets(event.changedAssets.size, 1);\n          assertTimesBundled(defaultBundlerSpy.callCount, 2);\n          let result = await b.run();\n          let contents = await overlayFS.readFile(result.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes(`console.log(\"adding a new console\")`));\n        } finally {\n          if (subscription) {\n            await subscription.unsubscribe();\n            subscription = null;\n          }\n        }\n      });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"add a console log should not bundle","suites":["incremental bundling","non-dependency based changes","javascript"],"updatePoint":{"line":91,"column":45,"index":4093},"line":91,"code":"      it('add a console log should not bundle', async () => {\n        let subscription;\n        let fixture = path.join(__dirname, '/integration/incremental-bundling');\n        try {\n          let b = bundler(path.join(fixture, 'index.js'), {\n            inputFS: overlayFS,\n            shouldDisableCache: false,\n            shouldBundleIncrementally: true\n          });\n          await overlayFS.mkdirp(fixture);\n          subscription = await b.watch();\n          let event = await getNextBuildSuccess(b);\n          assertTimesBundled(defaultBundlerSpy.callCount, 1);\n          await overlayFS.writeFile(path.join(fixture, 'index.js'), `import {a} from './a';\nconsole.log('index.js');\nconsole.log(a);\nconsole.log('adding a new console');`);\n          event = await getNextBuildSuccess(b);\n          assertChangedAssets(event.changedAssets.size, 1);\n          assertTimesBundled(defaultBundlerSpy.callCount, 1);\n          let result = await b.run();\n          let contents = await overlayFS.readFile(result.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes(`console.log(\"adding a new console\")`));\n        } finally {\n          if (subscription) {\n            await subscription.unsubscribe();\n            subscription = null;\n          }\n        }\n      });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"updating a string value should not bundle","suites":["incremental bundling","non-dependency based changes","javascript"],"updatePoint":{"line":121,"column":51,"index":5392},"line":121,"code":"      it('updating a string value should not bundle', async () => {\n        let subscription;\n        let fixture = path.join(__dirname, '/integration/incremental-bundling');\n        try {\n          let b = bundler(path.join(fixture, 'index.js'), {\n            inputFS: overlayFS,\n            shouldDisableCache: false,\n            shouldBundleIncrementally: true\n          });\n          await overlayFS.mkdirp(fixture);\n          subscription = await b.watch();\n          let event = await getNextBuildSuccess(b);\n          assertTimesBundled(defaultBundlerSpy.callCount, 1);\n          await overlayFS.writeFile(path.join(fixture, 'index.js'), `import {a} from './a';\nconsole.log('index.js - updated string');\nconsole.log(a);\n`);\n          event = await getNextBuildSuccess(b);\n          assertChangedAssets(event.changedAssets.size, 1);\n          assertTimesBundled(defaultBundlerSpy.callCount, 1);\n          let result = await b.run();\n          let contents = await overlayFS.readFile(result.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes(`console.log(\"index.js - updated string\");`));\n        } finally {\n          if (subscription) {\n            await subscription.unsubscribe();\n            subscription = null;\n          }\n        }\n      });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"adding a comment","suites":["incremental bundling","non-dependency based changes","javascript"],"updatePoint":{"line":151,"column":26,"index":6653},"line":151,"code":"      it('adding a comment', async () => {\n        let subscription;\n        let fixture = path.join(__dirname, '/integration/incremental-bundling');\n        try {\n          let b = bundler(path.join(fixture, 'index.js'), {\n            inputFS: overlayFS,\n            shouldDisableCache: false,\n            shouldBundleIncrementally: true\n          });\n          await overlayFS.mkdirp(fixture);\n          subscription = await b.watch();\n          let event = await getNextBuildSuccess(b);\n          assertTimesBundled(defaultBundlerSpy.callCount, 1);\n          await overlayFS.writeFile(path.join(fixture, 'index.js'), `import {a} from './a';\n// test comment\nconsole.log('index.js');\nconsole.log(a);`);\n          event = await getNextBuildSuccess(b);\n          assertChangedAssets(event.changedAssets.size, 1);\n          assertTimesBundled(defaultBundlerSpy.callCount, 1);\n          let result = await b.run();\n          let contents = await overlayFS.readFile(result.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes(`// test comment`));\n        } finally {\n          if (subscription) {\n            await subscription.unsubscribe();\n            subscription = null;\n          }\n        }\n      });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"adds multiple non-dependency related changes","suites":["incremental bundling","non-dependency based changes","javascript"],"updatePoint":{"line":183,"column":54,"index":7999},"line":183,"code":"      it('adds multiple non-dependency related changes', async () => {\n        let subscription;\n        let fixture = path.join(__dirname, '/integration/incremental-bundling');\n        try {\n          let b = bundler(path.join(fixture, 'index-export.js'), {\n            inputFS: overlayFS,\n            shouldDisableCache: false,\n            shouldBundleIncrementally: true\n          });\n          await overlayFS.mkdirp(fixture);\n          subscription = await b.watch();\n          let event = await getNextBuildSuccess(b);\n          assertTimesBundled(defaultBundlerSpy.callCount, 1);\n          await overlayFS.writeFile(path.join(fixture, 'index-export.js'), `import {a} from './a';\nconsole.log('adding a new console');\nmodule.exports = a;`);\n          await overlayFS.writeFile(path.join(fixture, 'a.js'), `export const a = 'a updated';`);\n          event = await getNextBuildSuccess(b);\n          assertChangedAssets(event.changedAssets.size, 2);\n          assertTimesBundled(defaultBundlerSpy.callCount, 1);\n          let result = await b.run();\n          let contents = await overlayFS.readFile(result.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes(`console.log(\"adding a new console\")`));\n          let bundleOutput = await run(result.bundleGraph);\n          assert.equal(bundleOutput, 'a updated');\n        } finally {\n          if (subscription) {\n            await subscription.unsubscribe();\n            subscription = null;\n          }\n        }\n      });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"update an imported css file","suites":["incremental bundling","non-dependency based changes","javascript"],"updatePoint":{"line":216,"column":35,"index":9492},"line":216,"code":"    it('update an imported css file', async () => {\n      let subscription;\n      let fixture = path.join(__dirname, '/integration/incremental-bundling');\n      try {\n        let b = bundler(path.join(fixture, 'index-with-css.js'), {\n          inputFS: overlayFS,\n          shouldDisableCache: false,\n          shouldBundleIncrementally: true\n        });\n        await overlayFS.mkdirp(fixture);\n        subscription = await b.watch();\n        let event = await getNextBuildSuccess(b);\n        assertTimesBundled(defaultBundlerSpy.callCount, 1);\n        await overlayFS.writeFile(path.join(fixture, 'a.css'), `html {\n  color: red;\n}\n`);\n        event = await getNextBuildSuccess(b);\n        assertChangedAssets(event.changedAssets.size, 1);\n        assertTimesBundled(defaultBundlerSpy.callCount, 1);\n        let result = await b.run();\n        let bundleCSS = result.bundleGraph.getBundles()[1];\n        assert.equal(bundleCSS.type, 'css');\n        let cssContent = await overlayFS.readFile(bundleCSS.filePath, 'utf8');\n        assert(cssContent.includes(`color: red;`));\n      } finally {\n        if (subscription) {\n          await subscription.unsubscribe();\n          subscription = null;\n        }\n      }\n    });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"update both the js and imported css file","suites":["incremental bundling","non-dependency based changes","javascript"],"updatePoint":{"line":248,"column":48,"index":10725},"line":248,"code":"    it('update both the js and imported css file', async () => {\n      let subscription;\n      let fixture = path.join(__dirname, '/integration/incremental-bundling');\n      try {\n        let b = bundler(path.join(fixture, 'index-with-css.js'), {\n          inputFS: overlayFS,\n          shouldDisableCache: false,\n          shouldBundleIncrementally: true\n        });\n        await overlayFS.mkdirp(fixture);\n        subscription = await b.watch();\n        let event = await getNextBuildSuccess(b);\n        assertTimesBundled(defaultBundlerSpy.callCount, 1);\n        await overlayFS.writeFile(path.join(fixture, 'index-with-css.js'), `import {a} from './a';\nimport './a.css';\nconsole.log('index.js');\nconsole.log(a, 'updated');`);\n        await overlayFS.writeFile(path.join(fixture, 'a.css'), `html {\n  color: red;\n}`);\n        event = await getNextBuildSuccess(b);\n        assertChangedAssets(event.changedAssets.size, 2);\n        assertTimesBundled(defaultBundlerSpy.callCount, 1);\n        let result = await b.run();\n        let contents = await overlayFS.readFile(result.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(contents.includes(`console.log((0, _a.a), \"updated\");`));\n        let bundleCSS = result.bundleGraph.getBundles()[1];\n        assert.equal(bundleCSS.type, 'css');\n        let cssContent = await overlayFS.readFile(bundleCSS.filePath, 'utf8');\n        assert(cssContent.includes(`color: red;`));\n      } finally {\n        if (subscription) {\n          await subscription.unsubscribe();\n          subscription = null;\n        }\n      }\n    });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"update the bundles if entry is html and js asset is modified","suites":["incremental bundling","non-dependency based changes","javascript"],"updatePoint":{"line":285,"column":68,"index":12324},"line":285,"code":"    it('update the bundles if entry is html and js asset is modified', async () => {\n      let subscription;\n      let fixture = path.join(__dirname, '/integration/incremental-bundling');\n      try {\n        let b = bundler(path.join(fixture, 'index.html'), {\n          inputFS: overlayFS,\n          shouldDisableCache: false,\n          shouldBundleIncrementally: true\n        });\n        await overlayFS.mkdirp(fixture);\n        subscription = await b.watch();\n        let event = await getNextBuildSuccess(b);\n        assertTimesBundled(defaultBundlerSpy.callCount, 1);\n        await overlayFS.writeFile(path.join(fixture, 'index.js'), `import {a} from './a';\n// test comment\nconsole.log('index.js');\nconsole.log(a);`);\n        event = await getNextBuildSuccess(b);\n        assertChangedAssets(event.changedAssets.size, 1);\n        assertTimesBundled(defaultBundlerSpy.callCount, 1);\n        let result = await b.run();\n        let bundleHTML = result.bundleGraph.getBundles()[0];\n        assert.equal(bundleHTML.type, 'html');\n        let htmlContent = await overlayFS.readFile(bundleHTML.filePath, 'utf8');\n        assert(htmlContent.includes(`<html>`));\n        let bundleJS = result.bundleGraph.getBundles()[1];\n        assert.equal(bundleJS.type, 'js');\n        let jsContent = await overlayFS.readFile(bundleJS.filePath, 'utf8');\n        assert(jsContent.includes(`// test comment`));\n      } finally {\n        if (subscription) {\n          await subscription.unsubscribe();\n          subscription = null;\n        }\n      }\n    });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"adding a new dependency","suites":["incremental bundling","dependency based changes should run the bundler"],"updatePoint":{"line":323,"column":31,"index":13903},"line":323,"code":"    it('adding a new dependency', async () => {\n      let subscription;\n      let fixture = path.join(__dirname, '/integration/incremental-bundling');\n      try {\n        let b = bundler(path.join(fixture, 'index.js'), {\n          inputFS: overlayFS,\n          shouldDisableCache: false,\n          shouldBundleIncrementally: true\n        });\n        await overlayFS.mkdirp(fixture);\n        subscription = await b.watch();\n        await getNextBuildSuccess(b);\n        assertTimesBundled(defaultBundlerSpy.callCount, 1);\n        await overlayFS.writeFile(path.join(fixture, 'index.js'), `import {a} from './a';\nimport {b} from './b';\nconsole.log('index.js', b);\nconsole.log(a);\n`);\n        let event = await getNextBuildSuccess(b);\n        assertChangedAssets(event.changedAssets.size, 2);\n        assertTimesBundled(defaultBundlerSpy.callCount, 2);\n        let contents = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(contents.includes(`console.log(\"index.js\", (0, _b.b));`));\n      } finally {\n        if (subscription) {\n          await subscription.unsubscribe();\n          subscription = null;\n        }\n      }\n    });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"adding a new dependency of a different type","suites":["incremental bundling","dependency based changes should run the bundler"],"updatePoint":{"line":353,"column":51,"index":15095},"line":353,"code":"    it('adding a new dependency of a different type', async () => {\n      let subscription;\n      let fixture = path.join(__dirname, '/integration/incremental-bundling');\n      try {\n        let b = bundler(path.join(fixture, 'index.js'), {\n          inputFS: overlayFS,\n          shouldDisableCache: false,\n          shouldBundleIncrementally: true\n        });\n        await overlayFS.mkdirp(fixture);\n        subscription = await b.watch();\n        await getNextBuildSuccess(b);\n        assertTimesBundled(defaultBundlerSpy.callCount, 1);\n        await overlayFS.writeFile(path.join(fixture, 'index.js'), `import {a} from './a';\nimport './a.css';\nconsole.log(a);\n`);\n        let event = await getNextBuildSuccess(b);\n        assertChangedAssets(event.changedAssets.size, 2);\n        assertTimesBundled(defaultBundlerSpy.callCount, 2);\n\n        // one CSS and one JS bundle\n        assert.equal(event.bundleGraph.getBundles().length, 2);\n        let contents = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(contents.includes(`console.log((0, _a.a));`));\n        let bundleCSS = event.bundleGraph.getBundles()[1];\n        assert.equal(bundleCSS.type, 'css');\n        let cssContent = await overlayFS.readFile(bundleCSS.filePath, 'utf8');\n        assert(cssContent.includes(`color: #00f;`));\n      } finally {\n        if (subscription) {\n          await subscription.unsubscribe();\n          subscription = null;\n        }\n      }\n    });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"adding a new dynamic import","suites":["incremental bundling","dependency based changes should run the bundler"],"updatePoint":{"line":389,"column":35,"index":16564},"line":389,"code":"    it('adding a new dynamic import', async () => {\n      let subscription;\n      let fixture = path.join(__dirname, '/integration/incremental-bundling');\n      try {\n        let b = bundler(path.join(fixture, 'index.js'), {\n          inputFS: overlayFS,\n          shouldDisableCache: false,\n          shouldBundleIncrementally: true\n        });\n        await overlayFS.mkdirp(fixture);\n        subscription = await b.watch();\n        await getNextBuildSuccess(b);\n        assertTimesBundled(defaultBundlerSpy.callCount, 1);\n        await overlayFS.writeFile(path.join(fixture, 'index.js'), `import {a} from './a';\nconst b = import('./b');\nconsole.log(a, b);\n`);\n        let event = await getNextBuildSuccess(b);\n        let assets = Array.from(event.changedAssets.values());\n        assertChangedAssets(getChangedAssetsBeforeRuntimes(assets).length, 2);\n        assertTimesBundled(defaultBundlerSpy.callCount, 2);\n\n        // original bundle and new dynamic import bundle JS bundle\n        assert.equal(event.bundleGraph.getBundles().length, 2);\n        let contents = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(contents.includes(`console.log((0, _a.a), b);`));\n        let dynamicBundle = event.bundleGraph.getBundles()[1];\n        assert.equal(dynamicBundle.type, 'js');\n        let dynamicContent = await overlayFS.readFile(dynamicBundle.filePath, 'utf8');\n        assert(dynamicContent.includes(`parcelHelpers.export(exports, \"b\", ()=>b);\nconst b = \"b\";`));\n      } finally {\n        if (subscription) {\n          await subscription.unsubscribe();\n          subscription = null;\n        }\n      }\n    });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removing a dependency","suites":["incremental bundling","dependency based changes should run the bundler"],"updatePoint":{"line":427,"column":29,"index":18218},"line":427,"code":"    it('removing a dependency', async () => {\n      let subscription;\n      let fixture = path.join(__dirname, '/integration/incremental-bundling');\n      try {\n        let b = bundler(path.join(fixture, 'index.js'), {\n          inputFS: overlayFS,\n          shouldDisableCache: false,\n          shouldBundleIncrementally: true\n        });\n        await overlayFS.mkdirp(fixture);\n        subscription = await b.watch();\n        let event = await getNextBuildSuccess(b);\n        assertTimesBundled(defaultBundlerSpy.callCount, 1);\n        await overlayFS.writeFile(path.join(fixture, 'index.js'), `// import {a} from './a';\nconsole.log('index.js');`);\n        event = await getNextBuildSuccess(b);\n        assertChangedAssets(event.changedAssets.size, 1);\n        assertTimesBundled(defaultBundlerSpy.callCount, 2);\n        let output = await overlayFS.readFile(path.join(fixture, 'index.js'), 'utf8');\n        assert(output.includes(`// import {a} from './a'`));\n      } finally {\n        if (subscription) {\n          await subscription.unsubscribe();\n          subscription = null;\n        }\n      }\n    });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"changing the bundler in parcel configs","suites":["incremental bundling","other changes that would for a re-bundle"],"updatePoint":{"line":456,"column":46,"index":19415},"line":456,"code":"    it('changing the bundler in parcel configs', async () => {\n      let subscription;\n      let fixture = path.join(__dirname, '/integration/incremental-bundling');\n      try {\n        let b = bundler(path.join(fixture, 'index.js'), {\n          inputFS: overlayFS,\n          shouldDisableCache: false,\n          shouldBundleIncrementally: true\n        });\n        await overlayFS.mkdirp(fixture);\n        subscription = await b.watch();\n        let event = await getNextBuildSuccess(b);\n        assertTimesBundled(defaultBundlerSpy.callCount, 1);\n        assertTimesBundled(customBundlerSpy.callCount, 0);\n        await overlayFS.writeFile(path.join(fixture, '.parcelrc'), JSON.stringify({\n          extends: '@parcel/config-default',\n          bundler: 'parcel-bundler-test'\n        }));\n        event = await getNextBuildSuccess(b);\n        let assets = Array.from(event.changedAssets.values());\n        // should contain all the assets\n        assertChangedAssets(getChangedAssetsBeforeRuntimes(assets).length, 3);\n        // the default bundler was only called once\n        assertTimesBundled(defaultBundlerSpy.callCount, 1);\n        // calls the new bundler to rebundle\n        assertTimesBundled(customBundlerSpy.callCount, 1);\n        let output = await overlayFS.readFile(path.join(fixture, 'index.js'), 'utf8');\n        assert(output.includes(`import {a} from './a'`));\n      } finally {\n        if (subscription) {\n          await subscription.unsubscribe();\n          subscription = null;\n        }\n      }\n    });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"changing bundler options","suites":["incremental bundling","other changes that would for a re-bundle"],"updatePoint":{"line":491,"column":32,"index":20928},"line":491,"code":"    it('changing bundler options', async () => {\n      let subscription;\n      let fixture = path.join(__dirname, '/integration/incremental-bundling');\n      try {\n        let b = bundler(path.join(fixture, 'index.js'), {\n          inputFS: overlayFS,\n          shouldDisableCache: false,\n          shouldBundleIncrementally: true\n        });\n        await overlayFS.mkdirp(fixture);\n        subscription = await b.watch();\n        let event = await getNextBuildSuccess(b);\n        assertTimesBundled(defaultBundlerSpy.callCount, 1);\n        let pkgFile = path.join(fixture, 'package.json');\n        let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n        await overlayFS.writeFile(pkgFile, JSON.stringify({\n          ...pkg,\n          '@parcel/bundler-default': {\n            http: 1\n          }\n        }));\n        event = await getNextBuildSuccess(b);\n\n        // should contain all the assets\n        assertChangedAssets(event.changedAssets.size, 3);\n        assertTimesBundled(defaultBundlerSpy.callCount, 2);\n      } finally {\n        if (subscription) {\n          await subscription.unsubscribe();\n          subscription = null;\n        }\n      }\n    });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"changing the namer","suites":["incremental bundling","other changes that would for a re-bundle"],"updatePoint":{"line":525,"column":24,"index":22098},"line":525,"code":"  it('changing the namer', async () => {\n    let subscription;\n    let fixture = path.join(__dirname, '/integration/incremental-bundling');\n    try {\n      let b = bundler(path.join(fixture, 'index.js'), {\n        inputFS: overlayFS,\n        shouldDisableCache: false,\n        shouldBundleIncrementally: true\n      });\n      await overlayFS.mkdirp(fixture);\n      subscription = await b.watch();\n      let event = await getNextBuildSuccess(b);\n      assertTimesBundled(defaultBundlerSpy.callCount, 1);\n      await overlayFS.writeFile(path.join(fixture, '.parcelrc'), JSON.stringify({\n        extends: '@parcel/config-default',\n        namers: ['parcel-namer-test']\n      }));\n      event = await getNextBuildSuccess(b);\n\n      // should contain all the assets\n      assertChangedAssets(event.changedAssets.size, 3);\n      assertTimesBundled(defaultBundlerSpy.callCount, 2);\n      let result = await b.run();\n      let bundles = result.bundleGraph.getBundles();\n      assert.deepEqual(bundles.map(b => b.name), bundles.map(b => `${b.id}.${b.type}`));\n    } finally {\n      if (subscription) {\n        await subscription.unsubscribe();\n        subscription = null;\n      }\n    }\n  });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"changing the runtimes","suites":["incremental bundling","other changes that would for a re-bundle"],"updatePoint":{"line":557,"column":27,"index":23284},"line":557,"code":"  it('changing the runtimes', async () => {\n    let subscription;\n    let fixture = path.join(__dirname, '/integration/incremental-bundling');\n    try {\n      let b = bundler(path.join(fixture, 'index.js'), {\n        inputFS: overlayFS,\n        shouldDisableCache: false,\n        shouldBundleIncrementally: true\n      });\n      await overlayFS.mkdirp(fixture);\n      subscription = await b.watch();\n      let event = await getNextBuildSuccess(b);\n      assertTimesBundled(defaultBundlerSpy.callCount, 1);\n      await overlayFS.writeFile(path.join(fixture, '.parcelrc'), JSON.stringify({\n        extends: '@parcel/config-default',\n        runtimes: ['parcel-runtime-test']\n      }));\n      event = await getNextBuildSuccess(b);\n\n      // should contain all the assets\n      let assets = Array.from(event.changedAssets.values());\n      assertChangedAssets(getChangedAssetsBeforeRuntimes(assets).length, 3);\n      assertTimesBundled(defaultBundlerSpy.callCount, 2);\n      let result = await b.run();\n      let res = await run(result.bundleGraph, null, {\n        require: false\n      });\n      assert.equal(res.runtime_test, true);\n    } finally {\n      if (subscription) {\n        await subscription.unsubscribe();\n        subscription = null;\n      }\n    }\n  });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"changing target options","suites":["incremental bundling","other changes that would for a re-bundle"],"updatePoint":{"line":592,"column":29,"index":24547},"line":592,"code":"  it('changing target options', async () => {\n    let subscription;\n    let fixture = path.join(__dirname, '/integration/incremental-bundling');\n    try {\n      let b = bundler(path.join(fixture, 'index.js'), {\n        inputFS: overlayFS,\n        shouldDisableCache: false,\n        shouldBundleIncrementally: true\n      });\n      await overlayFS.mkdirp(fixture);\n      subscription = await b.watch();\n      let event = await getNextBuildSuccess(b);\n      assertTimesBundled(defaultBundlerSpy.callCount, 1);\n      assertTimesBundled(customBundlerSpy.callCount, 0);\n      let pkgFile = path.join(fixture, 'package.json');\n      let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n      await overlayFS.writeFile(pkgFile, JSON.stringify({\n        ...pkg,\n        targets: {\n          esmodule: {\n            outputFormat: 'esmodule'\n          }\n        }\n      }));\n      event = await getNextBuildSuccess(b);\n      assertChangedAssets(event.changedAssets.size, 3);\n      assertTimesBundled(defaultBundlerSpy.callCount, 2);\n      let output = await overlayFS.readFile(path.join(fixture, 'index.js'), 'utf8');\n      assert(output.includes(`import {a} from './a'`));\n    } finally {\n      if (subscription) {\n        await subscription.unsubscribe();\n        subscription = null;\n      }\n    }\n  });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"adding a new the entry","suites":["incremental bundling","other changes that would for a re-bundle"],"updatePoint":{"line":628,"column":28,"index":25846},"line":628,"code":"  it('adding a new the entry', async () => {\n    let subscription;\n    let fixture = path.join(__dirname, '/integration/incremental-bundling');\n    try {\n      let b = bundler(path.join(fixture, '*.html'), {\n        inputFS: overlayFS,\n        shouldDisableCache: false,\n        shouldBundleIncrementally: true\n      });\n      await overlayFS.mkdirp(fixture);\n      subscription = await b.watch();\n      let event = await getNextBuildSuccess(b);\n      assertTimesBundled(defaultBundlerSpy.callCount, 1);\n      assertTimesBundled(customBundlerSpy.callCount, 0);\n      await overlayFS.writeFile(path.join(fixture, 'index-new-entry.html'), '<html />');\n      event = await getNextBuildSuccess(b);\n\n      // should contain all the assets\n      assertChangedAssets(event.changedAssets.size, 1);\n      assertTimesBundled(defaultBundlerSpy.callCount, 2);\n    } finally {\n      if (subscription) {\n        await subscription.unsubscribe();\n        subscription = null;\n      }\n    }\n  });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"changing symbols (adding a new dependency via one symbol)","suites":["incremental bundling","other changes that would for a re-bundle"],"updatePoint":{"line":655,"column":63,"index":26862},"line":655,"code":"  it('changing symbols (adding a new dependency via one symbol)', async () => {\n    let subscription;\n    let fixture = path.join(__dirname, '/integration/incremental-bundling');\n    try {\n      let b = bundler(path.join(fixture, 'index-multi-symbol.js'), {\n        inputFS: overlayFS,\n        shouldDisableCache: false,\n        shouldBundleIncrementally: true,\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        }\n      });\n      await overlayFS.mkdirp(fixture);\n      subscription = await b.watch();\n      let event = await getNextBuildSuccess(b);\n      assertTimesBundled(defaultBundlerSpy.callCount, 1);\n      await overlayFS.writeFile(path.join(fixture, 'index-multi-symbol.js'), `import {a,b,c} from './multi-symbol-util.js';\n\n      console.log('index.js');\n      console.log(a,b,c);\n      module.exports = {a, b, c};\n      `);\n      event = await getNextBuildSuccess(b);\n      assertChangedAssets(event.changedAssets.size, 1);\n      assertTimesBundled(defaultBundlerSpy.callCount, 2);\n      let result = await b.run();\n      let contents = await overlayFS.readFile(result.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(/console\\.log\\(\\(0, [^)]+\\), \\(0, [^)]+\\), \\(0, [^)]+\\)\\);/.test(contents));\n    } finally {\n      if (subscription) {\n        await subscription.unsubscribe();\n        subscription = null;\n      }\n    }\n  });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"changing symbols (removing a dependency via one symbol)","suites":["incremental bundling","other changes that would for a re-bundle"],"updatePoint":{"line":690,"column":61,"index":28231},"line":690,"code":"  it('changing symbols (removing a dependency via one symbol)', async () => {\n    let subscription;\n    let fixture = path.join(__dirname, '/integration/incremental-bundling');\n    try {\n      let b = bundler(path.join(fixture, 'index-multi-symbol.js'), {\n        inputFS: overlayFS,\n        shouldDisableCache: false,\n        shouldBundleIncrementally: true,\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        }\n      });\n      await overlayFS.mkdirp(fixture);\n      subscription = await b.watch();\n      let event = await getNextBuildSuccess(b);\n      assertTimesBundled(defaultBundlerSpy.callCount, 1);\n      await overlayFS.writeFile(path.join(fixture, 'index-multi-symbol.js'), `import {a } from './multi-symbol-util.js';\n\nconsole.log('index.js');\nconsole.log(a);\nmodule.exports = {a};\n`);\n      event = await getNextBuildSuccess(b);\n      assertChangedAssets(event.changedAssets.size, 1);\n      assertTimesBundled(defaultBundlerSpy.callCount, 2);\n      let result = await b.run();\n      let contents = await overlayFS.readFile(result.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(/console\\.log\\(\\(0, [^)]+\\)\\);/.test(contents));\n      result.bundleGraph.getBundles()[0].traverseAssets(a => {\n        assert(!a.filePath.endsWith('b.js'));\n      });\n    } finally {\n      if (subscription) {\n        await subscription.unsubscribe();\n        subscription = null;\n      }\n    }\n  });","file":"incremental-bundling.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a basic JS bundle with CommonJS requires","suites":["javascript"],"updatePoint":{"line":14,"column":61,"index":682},"line":14,"code":"  it('should produce a basic JS bundle with CommonJS requires', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/commonjs/index.js'));\n\n    // assert.equal(b.assets.size, 8);\n    // assert.equal(b.childBundles.size, 1);\n\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support url: imports with CommonJS output","suites":["javascript"],"updatePoint":{"line":24,"column":54,"index":1040},"line":24,"code":"  it('should support url: imports with CommonJS output', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/commonjs-import-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'esmodule-helpers.js']\n    }, {\n      type: 'txt',\n      assets: ['x.txt']\n    }]);\n    let txtBundle = b.getBundles().find(b => b.type === 'txt').filePath;\n    let output = await run(b);\n    assert.strictEqual(path.basename(output), path.basename(txtBundle));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support url: imports of another javascript file","suites":["javascript"],"updatePoint":{"line":37,"column":60,"index":1558},"line":37,"code":"  it('should support url: imports of another javascript file', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worklet/pipeline.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'pipeline.js',\n      assets: ['bundle-url.js', 'pipeline.js', 'bundle-manifest.js']\n    }, {\n      type: 'js',\n      assets: ['worklet.js', 'colors.js']\n    }]);\n    let url;\n    await run(b, {\n      CSS: {\n        paintWorklet: {\n          addModule(u) {\n            url = u;\n          }\n        }\n      }\n    });\n    assert(/^http:\\/\\/localhost\\/worklet\\.[0-9a-f]+\\.js$/.test(url));\n    let name;\n    await runBundle(b, b.getBundles()[1], {\n      registerPaint(n) {\n        name = n;\n      }\n    }, {\n      require: false\n    });\n    assert.equal(name, 'checkerboard');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support new URL() of another javascript file","suites":["javascript"],"updatePoint":{"line":69,"column":57,"index":2370},"line":69,"code":"  it('should support new URL() of another javascript file', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worklet/url.js'));\n    assertBundles(b, [{\n      name: 'url.js',\n      assets: ['bundle-url.js', 'esmodule-helpers.js', 'url.js']\n    }, {\n      type: 'js',\n      assets: ['worklet.js', 'colors.js', 'esmodule-helpers.js']\n    }]);\n    let res = await run(b);\n    assert(/^http:\\/\\/localhost\\/worklet\\.[0-9a-f]+\\.js$/.test(res.default));\n    let name;\n    await runBundle(b, b.getBundles()[1], {\n      registerPaint(n) {\n        name = n;\n      }\n    }, {\n      require: false\n    });\n    assert.equal(name, 'checkerboard');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support CSS paint worklets","suites":["javascript"],"updatePoint":{"line":90,"column":39,"index":3022},"line":90,"code":"  it('should support CSS paint worklets', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worklet/url-worklet.js'));\n    assertBundles(b, [{\n      name: 'url-worklet.js',\n      assets: ['bundle-url.js', 'url-worklet.js']\n    }, {\n      type: 'js',\n      assets: ['worklet.js', 'colors.js', 'esmodule-helpers.js']\n    }]);\n    let url;\n    await run(b, {\n      CSS: {\n        paintWorklet: {\n          addModule(u) {\n            url = u;\n          }\n        }\n      }\n    });\n    assert(/^http:\\/\\/localhost\\/worklet\\.[0-9a-f]+\\.js$/.test(url));\n    let name;\n    await runBundle(b, b.getBundles()[1], {\n      registerPaint(n) {\n        name = n;\n      }\n    }, {\n      require: false\n    });\n    assert.equal(name, 'checkerboard');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on dynamic import() inside worklets","suites":["javascript"],"updatePoint":{"line":120,"column":54,"index":3807},"line":120,"code":"  it('should error on dynamic import() inside worklets', async function () {\n    let errored = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/worklet/url-worklet-error.js'));\n    } catch (err) {\n      errored = true;\n      assert.equal(err.message, 'import() is not allowed in worklets.');\n      assert.deepEqual(err.diagnostics, [{\n        message: 'import() is not allowed in worklets.',\n        origin: '@parcel/transformer-js',\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/worklet/worklet-error.js'),\n          codeHighlights: [{\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 18\n            }\n          }]\n        }, {\n          filePath: path.join(__dirname, 'integration/worklet/url-worklet-error.js'),\n          codeHighlights: [{\n            message: 'The environment was originally created here',\n            start: {\n              line: 1,\n              column: 36\n            },\n            end: {\n              line: 1,\n              column: 53\n            }\n          }]\n        }],\n        hints: ['Try using a static `import`.']\n      }]);\n    }\n    assert(errored);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support audio worklets via a pipeline","suites":["javascript"],"updatePoint":{"line":161,"column":50,"index":5049},"line":161,"code":"  it('should support audio worklets via a pipeline', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worklet/worklet-pipeline.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'worklet-pipeline.js',\n      assets: ['bundle-url.js', 'bundle-manifest.js', 'worklet-pipeline.js']\n    }, {\n      type: 'js',\n      assets: ['worklet.js', 'colors.js']\n    }]);\n    let res = await run(b);\n    assert(/^http:\\/\\/localhost\\/worklet\\.[0-9a-f]+\\.js$/.test(res));\n    let name;\n    await runBundle(b, b.getBundles()[1], {\n      registerPaint(n) {\n        name = n;\n      }\n    }, {\n      require: false\n    });\n    assert.equal(name, 'checkerboard');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on dynamic import() inside worklets imported via a pipeline","suites":["javascript"],"updatePoint":{"line":184,"column":78,"index":5781},"line":184,"code":"  it('should error on dynamic import() inside worklets imported via a pipeline', async function () {\n    let errored = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/worklet/worklet-pipeline-error.js'));\n    } catch (err) {\n      errored = true;\n      assert.equal(err.message, 'import() is not allowed in worklets.');\n      assert.deepEqual(err.diagnostics, [{\n        message: 'import() is not allowed in worklets.',\n        origin: '@parcel/transformer-js',\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/worklet/worklet-error.js'),\n          codeHighlights: [{\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 18\n            }\n          }]\n        }],\n        hints: ['Try using a static `import`.']\n      }]);\n    }\n    assert(errored);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a basic JS bundle with ES6 imports","suites":["javascript"],"updatePoint":{"line":212,"column":55,"index":6659},"line":212,"code":"  it('should produce a basic JS bundle with ES6 imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/es6/index.js'));\n\n    // assert.equal(b.assets.size, 8);\n    // assert.equal(b.childBundles.size, 1);\n\n    let output = await run(b);\n    assert.equal(typeof output, 'object');\n    assert.equal(typeof output.default, 'function');\n    assert.equal(output.default(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect dependencies inserted by a prior transform","suites":["javascript"],"updatePoint":{"line":223,"column":62,"index":7079},"line":223,"code":"  it('should detect dependencies inserted by a prior transform', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/dependency-prior-transform/index.js'));\n    let jsBundle = b.getBundles()[0];\n    let contents = await outputFS.readFile(jsBundle.filePath);\n    assert(!contents.includes('import'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore unused requires after process.env inlining","suites":["javascript"],"updatePoint":{"line":229,"column":62,"index":7407},"line":229,"code":"  it('should ignore unused requires after process.env inlining', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-unused-require/index.js'), {\n      env: {\n        ABC: 'XYZ'\n      }\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.js']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('unused'));\n    let output = await run(b);\n    assert.strictEqual(output(), 'ok');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a basic JS bundle with object rest spread support","suites":["javascript"],"updatePoint":{"line":244,"column":70,"index":7918},"line":244,"code":"  it('should produce a basic JS bundle with object rest spread support', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/object-rest-spread/object-rest-spread.js'));\n\n    // assert.equal(b.assets.size, 1);\n\n    let output = await run(b);\n    assert.equal(typeof output, 'object');\n    assert.equal(typeof output.default, 'function');\n    let res = output.default();\n    assert.equal(res.y, 'a');\n    assert.deepEqual(res.z, {\n      y: 'a',\n      b: 'b'\n    });\n    assert.deepEqual(res.ys, {\n      b: 'b'\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bundle node_modules for a browser environment","suites":["javascript"],"updatePoint":{"line":262,"column":58,"index":8457},"line":262,"code":"  it('should bundle node_modules for a browser environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/node_require_browser/main.js'));\n    assertBundles(b, [{\n      name: 'main.js',\n      assets: ['main.js', 'local.js', 'index.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not bundle node_modules for a node environment","suites":["javascript"],"updatePoint":{"line":272,"column":59,"index":8851},"line":272,"code":"  it('should not bundle node_modules for a node environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/node_require/main.js'));\n    assertBundles(b, [{\n      name: 'main.js',\n      assets: ['main.js', 'local.js']\n    }]);\n    await outputFS.mkdirp(path.join(distDir, 'node_modules/testmodule'));\n    await outputFS.writeFile(path.join(distDir, 'node_modules/testmodule/index.js'), 'exports.a = 5;');\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 7);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not bundle node_modules on --target=electron","suites":["javascript"],"line":284,"code":"  it.skip('should not bundle node_modules on --target=electron', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should preserve hashbangs in bundles and preserve executable file mode","suites":["javascript"],"updatePoint":{"line":298,"column":76,"index":10007},"line":298,"code":"  it('should preserve hashbangs in bundles and preserve executable file mode', async () => {\n    let fixturePath = path.join(__dirname, '/integration/node_hashbang');\n    await bundle(path.join(fixturePath, 'main.js'));\n    let mainPath = path.join(fixturePath, 'dist', 'node', 'main.js');\n    let main = await outputFS.readFile(mainPath, 'utf8');\n    assert.equal(main.lastIndexOf('#!/usr/bin/env node\\n'), 0);\n    assert.equal((await outputFS.stat(mainPath)).mode, (await inputFS.stat(path.join(fixturePath, 'main.js'))).mode);\n    await outputFS.rimraf(path.join(fixturePath, 'dist'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not preserve hashbangs in browser bundles","suites":["javascript"],"updatePoint":{"line":307,"column":54,"index":10580},"line":307,"code":"  it('should not preserve hashbangs in browser bundles', async () => {\n    let fixturePath = path.join(__dirname, '/integration/node_hashbang');\n    await bundle(path.join(fixturePath, 'main.js'));\n    let main = await outputFS.readFile(path.join(fixturePath, 'dist', 'browser', 'main.js'), 'utf8');\n    assert(!main.includes('#!/usr/bin/env node\\n'));\n    await outputFS.rimraf(path.join(fixturePath, 'dist'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should preserve hashbangs in scopehoisted bundles","suites":["javascript"],"updatePoint":{"line":314,"column":55,"index":10999},"line":314,"code":"  it('should preserve hashbangs in scopehoisted bundles', async () => {\n    let fixturePath = path.join(__dirname, '/integration/node_hashbang');\n    await bundle(path.join(__dirname, '/integration/node_hashbang/main.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let main = await outputFS.readFile(path.join(fixturePath, 'dist', 'node', 'main.js'), 'utf8');\n    assert.equal(main.lastIndexOf('#!/usr/bin/env node\\n'), 0);\n    await outputFS.rimraf(path.join(fixturePath, 'dist'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bundle node_modules for a node environment if includeNodeModules is specified","suites":["javascript"],"updatePoint":{"line":325,"column":90,"index":11564},"line":325,"code":"  it('should bundle node_modules for a node environment if includeNodeModules is specified', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/include_node_modules/main.js'));\n    assertBundles(b, [{\n      name: 'main.js',\n      assets: ['main.js', 'local.js', 'index.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bundle builtins for a browser environment","suites":["javascript"],"updatePoint":{"line":335,"column":54,"index":11953},"line":335,"code":"  it('should bundle builtins for a browser environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/include_builtins-browser/main.js'));\n    assertBundles(b, [{\n      name: 'main.js',\n      assets: ['_empty.js', 'browser.js', 'esmodule-helpers.js', 'index.js', 'main.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let [fs, filepath] = output();\n    assert.equal(filepath, path.posix.join('app', 'index.js'));\n    assert.equal(typeof fs, 'object');\n    assert.deepEqual(Object.keys(fs), Object.keys({}));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not bundle builtins for a node environment if includeNodeModules is specified","suites":["javascript"],"updatePoint":{"line":348,"column":90,"index":12583},"line":348,"code":"  it('should not bundle builtins for a node environment if includeNodeModules is specified', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/include_builtins-node/main.js'));\n    assertBundles(b, [{\n      name: 'main.js',\n      assets: ['esmodule-helpers.js', 'main.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let [fs, filepath] = output();\n    assert.equal(filepath, path.join('app', 'index.js'));\n    assert.equal(typeof fs.readFile, 'function');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bundle node_modules on --target=electron and --bundle-node-modules","suites":["javascript"],"line":360,"code":"  it.skip('should bundle node_modules on --target=electron and --bundle-node-modules', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should produce a JS bundle with default exports and no imports","suites":["javascript"],"updatePoint":{"line":373,"column":68,"index":13572},"line":373,"code":"  it('should produce a JS bundle with default exports and no imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/es6-default-only/index.js'));\n\n    // assert.equal(b.assets.size, 1);\n    // assert.equal(b.childBundles.size, 1);\n\n    let output = await run(b);\n    assert.equal(typeof output, 'object');\n    assert.equal(typeof output.default, 'function');\n    assert.equal(output.default(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should split bundles when a dynamic import is used a browser environment","suites":["javascript"],"updatePoint":{"line":384,"column":78,"index":14021},"line":384,"code":"  it('should split bundles when a dynamic import is used a browser environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['local.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should prefetch bundles when declared as an import attribute statically","suites":["javascript"],"updatePoint":{"line":396,"column":77,"index":14492},"line":396,"code":"  it('should prefetch bundles when declared as an import attribute statically', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-static-prefetch/index.js'));\n    let output = await run(b);\n    let headChildren = await output.default;\n    assert.strictEqual(headChildren.length, 4);\n    assert.strictEqual(headChildren[1].tag, 'script');\n    assert(headChildren[1].src.match(/async\\..*\\.js/));\n    assert.strictEqual(headChildren[2].tag, 'link');\n    assert.strictEqual(headChildren[2].rel, 'prefetch');\n    assert.strictEqual(headChildren[2].as, 'script');\n    assert(headChildren[2].href.match(/prefetched\\..*\\.js/));\n    assert.strictEqual(headChildren[3].tag, 'link');\n    assert.strictEqual(headChildren[3].rel, 'prefetch');\n    assert.strictEqual(headChildren[3].as, 'style');\n    assert(headChildren[3].href.match(/prefetched\\..*\\.css/));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should load additional links that were prefetched","suites":["javascript"],"updatePoint":{"line":412,"column":55,"index":15360},"line":412,"code":"  it('should load additional links that were prefetched', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-static-prefetch-loaded/index.js'));\n    let output = await run(b);\n    let outputReturn = await output.default;\n    await outputReturn.loadDependency();\n    let headChildren = outputReturn.children;\n    assert.equal(headChildren.length, 7);\n    let cssBundles = headChildren.filter(child => child.href?.match(/prefetched-loaded\\..*\\.css/));\n    assert.equal(cssBundles.length, 2);\n    assert(cssBundles[0].tag === 'link');\n    assert(cssBundles[0].rel === 'prefetch');\n    assert(cssBundles[0].as === 'style');\n    assert(cssBundles[0].href.match(/prefetched-loaded\\..*\\.css/));\n    assert(cssBundles[1].tag === 'link');\n    assert(cssBundles[1].rel === 'stylesheet');\n    assert(cssBundles[1].href.match(/prefetched-loaded\\..*\\.css/));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should preload bundles when declared as an import attribute statically","suites":["javascript"],"updatePoint":{"line":429,"column":76,"index":16270},"line":429,"code":"  it('should preload bundles when declared as an import attribute statically', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-static-preload/index.js'));\n    let output = await run(b);\n    let headChildren = await output.default;\n    assert(headChildren.length === 4);\n    assert(headChildren[2].tag === 'link');\n    assert(headChildren[2].rel === 'preload');\n    assert(headChildren[2].as === 'script');\n    assert(headChildren[2].href.match(/preloaded\\..*\\.js/));\n    assert(headChildren[3].tag === 'link');\n    assert(headChildren[3].rel === 'preload');\n    assert(headChildren[3].as === 'style');\n    assert(headChildren[3].href.match(/preloaded\\..*\\.css/));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"targetting esmodule, should modulepreload bundles when declared as an import attribute statically","suites":["javascript"],"updatePoint":{"line":445,"column":103,"index":17083},"line":445,"code":"  it('targetting esmodule, should modulepreload bundles when declared as an import attribute statically');","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove import attributes","suites":["javascript"],"updatePoint":{"line":446,"column":37,"index":17124},"line":446,"code":"  it('should remove import attributes', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-import-attributes/index.js'));\n    let mainBundle = b.getBundles()[0];\n    let mainBundleContent = await outputFS.readFile(mainBundle.filePath, 'utf8');\n    assert(!mainBundleContent.includes('foo:'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should split bundles when a dynamic import is used with a node environment","suites":["javascript"],"updatePoint":{"line":452,"column":80,"index":17497},"line":452,"code":"  it('should split bundles when a dynamic import is used with a node environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-node/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      assets: ['local.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should split bundles when a dynamic import is used with an electron-main environment","suites":["javascript"],"updatePoint":{"line":464,"column":90,"index":17935},"line":464,"code":"  it('should split bundles when a dynamic import is used with an electron-main environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-electron-main/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      assets: ['local.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should split bundles when a dynamic import is used with an electron-renderer environment","suites":["javascript"],"updatePoint":{"line":476,"column":94,"index":18386},"line":476,"code":"  it('should split bundles when a dynamic import is used with an electron-renderer environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-electron-renderer/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      assets: ['local.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should load dynamic bundle when entry is in a subdirectory","suites":["javascript"],"line":488,"code":"  it.skip('should load dynamic bundle when entry is in a subdirectory', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"Should not run parcel over external modules","suites":["javascript"],"line":501,"code":"  it.skip('Should not run parcel over external modules', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling workers","suites":["javascript"],"updatePoint":{"line":508,"column":37,"index":19641},"line":508,"code":"  it('should support bundling workers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/workers/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'common.js', 'worker-client.js', 'feature.js', 'get-worker-url.js', 'bundle-url.js']\n    }, {\n      assets: ['service-worker.js']\n    }, {\n      assets: ['shared-worker.js']\n    }, {\n      assets: ['worker.js', 'common.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling workers with dynamic import","suites":["javascript"],"updatePoint":{"line":521,"column":57,"index":20116},"line":521,"code":"  it('should support bundling workers with dynamic import', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-dynamic/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'get-worker-url.js']\n    }, {\n      assets: ['worker.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js', 'esmodule-helpers.js']\n    }]);\n    let res = await new Promise(resolve => {\n      run(b, {\n        output: resolve\n      });\n    });\n    assert.deepEqual(res, {\n      default: 42\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling workers with dynamic import with legacy browser targets","suites":["javascript"],"updatePoint":{"line":540,"column":85,"index":20743},"line":540,"code":"  it('should support bundling workers with dynamic import with legacy browser targets', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-dynamic/index.js'), {\n      defaultTargetOptions: {\n        outputFormat: 'esmodule',\n        shouldScopeHoist: true,\n        engines: {\n          browsers: 'IE 11'\n        }\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'get-worker-url.js']\n    }, {\n      assets: ['worker.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    let res = await new Promise(resolve => {\n      run(b, {\n        output: resolve\n      });\n    });\n    assert.deepEqual(res, {\n      default: 42\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"dynamic imports loaded as high-priority scripts when not all engines support esmodules natively","suites":["javascript"],"updatePoint":{"line":567,"column":101,"index":21533},"line":567,"code":"  it('dynamic imports loaded as high-priority scripts when not all engines support esmodules natively', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-imports-high-prio/index.js'), {\n      defaultTargetOptions: {\n        engines: {\n          browsers: 'IE 11'\n        }\n      }\n    });\n    let output = await run(b);\n    let headChildren = await output.default;\n    assert(headChildren[0].tag === 'link');\n    assert(headChildren[0].rel === 'preload');\n    assert(headChildren[0].as === 'script');\n    assert(headChildren[1].tag === 'script');\n    assert(headChildren[1].src.match(/async\\..*\\.js/));\n    assert(headChildren[0].href === headChildren[1].src);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling workers with dynamic import in both page and worker","suites":["javascript"],"updatePoint":{"line":584,"column":81,"index":22218},"line":584,"code":"  it('should support bundling workers with dynamic import in both page and worker', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-dynamic/index-async.js'));\n    assertBundles(b, [{\n      name: 'index-async.js',\n      assets: ['index-async.js', 'bundle-url.js', 'get-worker-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['worker.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['async.js', 'esmodule-helpers.js']\n    }]);\n    let res = await new Promise(resolve => {\n      run(b, {\n        output: resolve\n      });\n    });\n    assert.deepEqual(res, {\n      default: 42\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling workers with dynamic import in nested worker","suites":["javascript"],"updatePoint":{"line":605,"column":74,"index":22945},"line":605,"code":"  it('should support bundling workers with dynamic import in nested worker', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-dynamic/index-nested.js'));\n    assertBundles(b, [{\n      name: 'index-nested.js',\n      assets: ['index-nested.js', 'bundle-url.js', 'get-worker-url.js']\n    }, {\n      assets: ['worker-nested.js', 'bundle-url.js', 'get-worker-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['worker.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js', 'esmodule-helpers.js']\n    }]);\n    let res = await new Promise(resolve => {\n      run(b, {\n        output: resolve\n      });\n    });\n    assert.deepEqual(res, {\n      default: 42\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support workers pointing to themselves","suites":["javascript"],"updatePoint":{"line":626,"column":51,"index":23675},"line":626,"code":"  it('should support workers pointing to themselves', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-self/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'get-worker-url.js', 'workerHelpers.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['workerHelpers.js', 'bundle-url.js', 'get-worker-url.js', 'esmodule-helpers.js']\n    }]);\n    await run(b);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support workers pointing to themselves with import.meta.url","suites":["javascript"],"updatePoint":{"line":636,"column":72,"index":24149},"line":636,"code":"  it('should support workers pointing to themselves with import.meta.url', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-self/import-meta.js'));\n    assertBundles(b, [{\n      assets: ['import-meta.js', 'bundle-url.js', 'get-worker-url.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['import-meta.js', 'bundle-url.js', 'get-worker-url.js', 'esmodule-helpers.js']\n    }]);\n    await run(b);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling workers of type module","suites":["javascript"],"updatePoint":{"line":645,"column":52,"index":24569},"line":645,"code":"  it('should support bundling workers of type module', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/workers-module/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false,\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      assets: ['dedicated-worker.js']\n    }, {\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'get-worker-url.js', 'bundle-manifest.js']\n    }, {\n      assets: ['shared-worker.js']\n    }, {\n      assets: ['index.js']\n    }]);\n    let dedicated, shared;\n    b.traverseBundles((bundle, ctx, traversal) => {\n      let mainEntry = bundle.getMainEntry();\n      if (mainEntry && mainEntry.filePath.endsWith('shared-worker.js')) {\n        shared = bundle;\n      } else if (mainEntry && mainEntry.filePath.endsWith('dedicated-worker.js')) {\n        dedicated = bundle;\n      }\n      if (dedicated && shared) traversal.stop();\n    });\n    assert(dedicated);\n    assert(shared);\n    let main = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    dedicated = await outputFS.readFile(dedicated.filePath, 'utf8');\n    shared = await outputFS.readFile(shared.filePath, 'utf8');\n    assert(/new Worker(.*?, {[\\n\\s]+type: \"module\"[\\n\\s]+})/.test(main));\n    assert(/new SharedWorker(.*?, {[\\n\\s]+type: \"module\"[\\n\\s]+})/.test(main));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile workers to non modules if ","suites":["javascript"],"updatePoint":{"line":682,"column":128,"index":26073},"line":682,"code":"    it(`should compile workers to non modules if ${shouldScopeHoist ? 'browsers do not support it' : 'shouldScopeHoist = false'}`, async function () {\n      let b = await bundle(path.join(__dirname, '/integration/workers-module/index.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldOptimize: false,\n          shouldScopeHoist,\n          engines: {\n            browsers: '>= 0.25%'\n          }\n        }\n      });\n      assertBundles(b, [{\n        assets: ['dedicated-worker.js']\n      }, {\n        name: 'index.js',\n        assets: ['index.js', 'bundle-url.js', 'get-worker-url.js', 'bundle-manifest.js']\n      }, {\n        assets: [!shouldScopeHoist && 'esmodule-helpers.js', 'index.js'].filter(Boolean)\n      }, {\n        assets: ['shared-worker.js']\n      }]);\n      let dedicated, shared;\n      b.traverseBundles((bundle, ctx, traversal) => {\n        let mainEntry = bundle.getMainEntry();\n        if (mainEntry && mainEntry.filePath.endsWith('shared-worker.js')) {\n          shared = bundle;\n        } else if (mainEntry && mainEntry.filePath.endsWith('dedicated-worker.js')) {\n          dedicated = bundle;\n        }\n        if (dedicated && shared) traversal.stop();\n      });\n      assert(dedicated);\n      assert(shared);\n      let main = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      dedicated = await outputFS.readFile(dedicated.filePath, 'utf8');\n      shared = await outputFS.readFile(shared.filePath, 'utf8');\n      assert(/new Worker([^,]*?)/.test(main));\n      assert(/new SharedWorker([^,]*?)/.test(main));\n      assert(!/export var foo/.test(dedicated));\n      assert(!/export var foo/.test(shared));\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile workers to modules when browsers do support it with esmodule parent script","suites":["javascript"],"updatePoint":{"line":725,"column":149,"index":27823},"line":725,"code":"    it(`should compile workers to ${supported ? '' : 'non '}modules when browsers do ${supported ? '' : 'not '}support it with esmodule parent script`, async function () {\n      let b = await bundle(path.join(__dirname, '/integration/workers-module/index.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          engines: {\n            browsers: supported ? 'Chrome 80' : 'Chrome 75'\n          },\n          outputFormat: 'esmodule',\n          shouldScopeHoist: true,\n          shouldOptimize: false\n        }\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['dedicated-worker.js']\n      }, {\n        name: 'index.js',\n        assets: ['index.js', 'bundle-manifest.js', 'get-worker-url.js']\n      }, {\n        type: 'js',\n        assets: ['shared-worker.js']\n      }, {\n        type: 'js',\n        assets: ['index.js']\n      }]);\n      let dedicated, shared;\n      b.traverseBundles((bundle, ctx, traversal) => {\n        if (bundle.getMainEntry()?.filePath.endsWith('shared-worker.js')) {\n          shared = bundle;\n        } else if (bundle.getMainEntry()?.filePath.endsWith('dedicated-worker.js')) {\n          dedicated = bundle;\n        }\n        if (dedicated && shared) traversal.stop();\n      });\n      assert(dedicated);\n      assert(shared);\n      let main = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(/new Worker([^,]*?)/.test(main));\n      assert(/new SharedWorker([^,]*?)/.test(main));\n      dedicated = await outputFS.readFile(dedicated.filePath, 'utf8');\n      shared = await outputFS.readFile(shared.filePath, 'utf8');\n      let importRegex = supported ? /importScripts\\s*\\(/ : /import\\s*(\"|')/;\n      assert(!importRegex.test(dedicated));\n      assert(!importRegex.test(shared));\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should preserve the name option to workers","suites":["javascript"],"updatePoint":{"line":771,"column":48,"index":29503},"line":771,"code":"  it('should preserve the name option to workers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/workers-module/named.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        engines: {\n          browsers: '>= 0.25%'\n        }\n      }\n    });\n    let main = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(/new Worker(.*?, {[\\n\\s]+name: \"worker\"[\\n\\s]+})/.test(main));\n    assert(/new SharedWorker(.*?, {[\\n\\s]+name: \"shared\"[\\n\\s]+})/.test(main));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error if importing in a worker without type: module","suites":["javascript"],"updatePoint":{"line":784,"column":64,"index":30053},"line":784,"code":"  it('should error if importing in a worker without type: module', async function () {\n    let errored = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/workers-module/error.js'), {\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        }\n      });\n    } catch (err) {\n      errored = true;\n      assert.equal(err.message, 'Web workers cannot have imports or exports without the `type: \"module\"` option.');\n      assert.deepEqual(err.diagnostics, [{\n        message: 'Web workers cannot have imports or exports without the `type: \"module\"` option.',\n        origin: '@parcel/transformer-js',\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/workers-module/dedicated-worker.js'),\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 22\n            }\n          }]\n        }, {\n          filePath: path.join(__dirname, '/integration/workers-module/error.js'),\n          codeHighlights: [{\n            message: 'The environment was originally created here',\n            start: {\n              line: 1,\n              column: 20\n            },\n            end: {\n              line: 1,\n              column: 40\n            }\n          }]\n        }],\n        hints: [\"Add {type: 'module'} as a second argument to the Worker constructor.\"],\n        documentationURL: 'https://parceljs.org/languages/javascript/#classic-scripts'\n      }]);\n    }\n    assert(errored);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling workers with different order","suites":["javascript"],"updatePoint":{"line":831,"column":58,"index":31631},"line":831,"code":"  it('should support bundling workers with different order', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/workers/index-alternative.js'));\n    assertBundles(b, [{\n      name: 'index-alternative.js',\n      assets: ['index-alternative.js', 'common.js', 'worker-client.js', 'feature.js', 'bundle-url.js', 'get-worker-url.js']\n    }, {\n      assets: ['service-worker.js']\n    }, {\n      assets: ['shared-worker.js']\n    }, {\n      assets: ['worker.js', 'common.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when s use importScripts","suites":["javascript"],"updatePoint":{"line":845,"column":58,"index":32202},"line":845,"code":"    it(`should error when ${workerType}s use importScripts`, async function () {\n      let filePath = path.join(__dirname, `/integration/worker-import-scripts/index-${workerType}.js`);\n      let errored = false;\n      try {\n        await bundle(filePath);\n      } catch (err) {\n        errored = true;\n        assert.equal(err.message, 'Argument to importScripts() must be a fully qualified URL.');\n        assert.deepEqual(err.diagnostics, [{\n          message: 'Argument to importScripts() must be a fully qualified URL.',\n          origin: '@parcel/transformer-js',\n          codeFrames: [{\n            filePath: path.join(__dirname, `/integration/worker-import-scripts/importScripts.js`),\n            codeHighlights: [{\n              message: null,\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 27\n              }\n            }]\n          }, {\n            filePath: path.join(__dirname, `integration/worker-import-scripts/index-${workerType}.js`),\n            codeHighlights: [{\n              message: 'The environment was originally created here',\n              start: {\n                line: 1,\n                column: workerType === 'webworker' ? 20 : 42\n              },\n              end: {\n                line: 1,\n                column: workerType === 'webworker' ? 37 : 59\n              }\n            }]\n          }],\n          hints: ['Use a static `import`, or dynamic `import()` instead.', \"Add {type: 'module'} as a second argument to the \" + (workerType === 'webworker' ? 'Worker constructor.' : 'navigator.serviceWorker.register() call.')],\n          documentationURL: 'https://parceljs.org/languages/javascript/#classic-script-workers'\n        }]);\n      }\n      assert(errored);\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore importScripts when not in a worker context","suites":["javascript"],"updatePoint":{"line":890,"column":62,"index":34034},"line":890,"code":"  it('should ignore importScripts when not in a worker context', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-import-scripts/importScripts.js'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['importScripts.js']\n    }]);\n    let res = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(res.includes(`importScripts(\"imported.js\")`));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore importScripts in script workers when not passed a string literal","suites":["javascript"],"updatePoint":{"line":899,"column":84,"index":34469},"line":899,"code":"  it('should ignore importScripts in script workers when not passed a string literal', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-import-scripts/index-variable.js'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index-variable.js', 'bundle-url.js', 'get-worker-url.js']\n    }, {\n      type: 'js',\n      assets: ['variable.js']\n    }]);\n    let res = await outputFS.readFile(b.getBundles()[1].filePath, 'utf8');\n    assert(res.includes('importScripts(url)'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore importScripts in script workers a fully qualified URL is provided","suites":["javascript"],"updatePoint":{"line":911,"column":85,"index":34992},"line":911,"code":"  it('should ignore importScripts in script workers a fully qualified URL is provided', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-import-scripts/index-external.js'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index-external.js', 'bundle-url.js', 'get-worker-url.js']\n    }, {\n      type: 'js',\n      assets: ['external.js']\n    }]);\n    let res = await outputFS.readFile(b.getBundles()[1].filePath, 'utf8');\n    assert(res.includes(`importScripts(\"https://unpkg.com/parcel\")`));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling service-workers","suites":["javascript"],"updatePoint":{"line":923,"column":45,"index":35498},"line":923,"code":"  it('should support bundling service-workers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/service-worker/a/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'index.js', 'bundle-url.js']\n    }, {\n      assets: ['worker-nested.js']\n    }, {\n      assets: ['worker-outside.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling service-workers with type: module","suites":["javascript"],"updatePoint":{"line":934,"column":63,"index":35882},"line":934,"code":"  it('should support bundling service-workers with type: module', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/service-worker/module.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      name: 'module.js',\n      assets: ['module.js', 'bundle-url.js']\n    }, {\n      assets: ['module-worker.js']\n    }]);\n    let bundles = b.getBundles();\n    let main = bundles.find(b => !b.env.isWorker());\n    let worker = bundles.find(b => b.env.isWorker());\n    let mainContents = await outputFS.readFile(main.filePath, 'utf8');\n    let workerContents = await outputFS.readFile(worker.filePath, 'utf8');\n    assert(/navigator.serviceWorker.register\\([^,]+?\\)/.test(mainContents));\n    assert(!/export /.test(workerContents));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should preserve the scope option for service workers","suites":["javascript"],"updatePoint":{"line":954,"column":58,"index":36692},"line":954,"code":"  it('should preserve the scope option for service workers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/service-worker/scope.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      name: 'scope.js',\n      assets: ['bundle-url.js', 'scope.js']\n    }, {\n      assets: ['module-worker.js']\n    }]);\n    let bundles = b.getBundles();\n    let main = bundles.find(b => !b.env.isWorker());\n    let mainContents = await outputFS.readFile(main.filePath, 'utf8');\n    assert(/navigator.serviceWorker.register\\(.*?, {[\\n\\s]*scope: \"foo\"[\\n\\s]*}\\)/.test(mainContents));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error if importing in a service worker without type: module","suites":["javascript"],"updatePoint":{"line":971,"column":72,"index":37366},"line":971,"code":"  it('should error if importing in a service worker without type: module', async function () {\n    let errored = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/service-worker/error.js'), {\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        }\n      });\n    } catch (err) {\n      errored = true;\n      assert.equal(err.message, 'Service workers cannot have imports or exports without the `type: \"module\"` option.');\n      assert.deepEqual(err.diagnostics, [{\n        message: 'Service workers cannot have imports or exports without the `type: \"module\"` option.',\n        origin: '@parcel/transformer-js',\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/service-worker/module-worker.js'),\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 19\n            }\n          }]\n        }, {\n          filePath: path.join(__dirname, 'integration/service-worker/error.js'),\n          codeHighlights: [{\n            message: 'The environment was originally created here',\n            start: {\n              line: 1,\n              column: 42\n            },\n            end: {\n              line: 1,\n              column: 59\n            }\n          }]\n        }],\n        hints: [\"Add {type: 'module'} as a second argument to the navigator.serviceWorker.register() call.\"],\n        documentationURL: 'https://parceljs.org/languages/javascript/#classic-scripts'\n      }]);\n    }\n    assert(errored);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should expose a manifest to service workers","suites":["javascript"],"updatePoint":{"line":1018,"column":49,"index":38960},"line":1018,"code":"  it('should expose a manifest to service workers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/service-worker/manifest.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      name: 'manifest.js',\n      assets: ['manifest.js', 'bundle-url.js']\n    }, {\n      assets: ['manifest-worker.js', 'service-worker.js']\n    }]);\n    let bundles = b.getBundles();\n    let worker = bundles.find(b => b.env.isWorker());\n    let manifest, version;\n    await runBundle(b, worker, {\n      output(m, v) {\n        manifest = m;\n        version = v;\n      }\n    });\n    assert.deepEqual(manifest, ['/manifest.js']);\n    assert.equal(typeof version, 'string');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should recognize serviceWorker.register with static URL and import.meta.url","suites":["javascript"],"updatePoint":{"line":1042,"column":81,"index":39735},"line":1042,"code":"  it('should recognize serviceWorker.register with static URL and import.meta.url', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/service-worker-import-meta-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js']\n    }, {\n      assets: ['worker.js']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('import.meta.url'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw a codeframe for a missing file in serviceWorker.register with URL and import.meta.url","suites":["javascript"],"updatePoint":{"line":1053,"column":104,"index":40241},"line":1053,"code":"  it('should throw a codeframe for a missing file in serviceWorker.register with URL and import.meta.url', async function () {\n    let fixture = path.join(__dirname, 'integration/service-worker-import-meta-url/missing.js');\n    let code = await inputFS.readFileSync(fixture, 'utf8');\n    await assert.rejects(() => bundle(fixture), {\n      name: 'BuildError',\n      diagnostics: [{\n        codeFrames: [{\n          filePath: fixture,\n          code,\n          codeHighlights: [{\n            end: {\n              column: 55,\n              line: 1\n            },\n            start: {\n              column: 42,\n              line: 1\n            }\n          }]\n        }],\n        message: \"Failed to resolve './invalid.js' from './missing.js'\",\n        origin: '@parcel/core'\n      }, {\n        hints: [\"Did you mean '__./index.js__'?\"],\n        message: \"Cannot load file './invalid.js' in './'.\",\n        origin: '@parcel/resolver-default'\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on dynamic import() inside service workers","suites":["javascript"],"updatePoint":{"line":1082,"column":61,"index":41160},"line":1082,"code":"  it('should error on dynamic import() inside service workers', async function () {\n    let errored = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/service-worker/dynamic-import-index.js'));\n    } catch (err) {\n      errored = true;\n      assert.equal(err.message, 'import() is not allowed in service workers.');\n      assert.deepEqual(err.diagnostics, [{\n        message: 'import() is not allowed in service workers.',\n        origin: '@parcel/transformer-js',\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/service-worker/dynamic-import.js'),\n          codeHighlights: [{\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 27\n            }\n          }]\n        }, {\n          filePath: path.join(__dirname, 'integration/service-worker/dynamic-import-index.js'),\n          codeHighlights: [{\n            message: 'The environment was originally created here',\n            start: {\n              line: 1,\n              column: 42\n            },\n            end: {\n              line: 1,\n              column: 60\n            }\n          }]\n        }],\n        hints: ['Try using a static `import`.']\n      }]);\n    }\n    assert(errored);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling workers with circular dependencies","suites":["javascript"],"updatePoint":{"line":1123,"column":64,"index":42458},"line":1123,"code":"  it('should support bundling workers with circular dependencies', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-circular/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'get-worker-url.js']\n    }, {\n      assets: ['worker.js', 'worker-dep.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should recognize worker constructor with static URL and import.meta.url","suites":["javascript"],"updatePoint":{"line":1132,"column":77,"index":42829},"line":1132,"code":"  it('should recognize worker constructor with static URL and import.meta.url', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-import-meta-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'get-worker-url.js']\n    }, {\n      assets: ['worker.js']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('import.meta.url'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore worker constructors with dynamic URL and import.meta.url","suites":["javascript"],"updatePoint":{"line":1143,"column":76,"index":43320},"line":1143,"code":"  it('should ignore worker constructors with dynamic URL and import.meta.url', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-import-meta-url/dynamic.js'));\n    assertBundles(b, [{\n      name: 'dynamic.js',\n      assets: ['dynamic.js']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('import.meta.url'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore worker constructors with local URL binding and import.meta.url","suites":["javascript"],"updatePoint":{"line":1152,"column":82,"index":43747},"line":1152,"code":"  it('should ignore worker constructors with local URL binding and import.meta.url', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-import-meta-url/local-url.js'));\n    assertBundles(b, [{\n      name: 'local-url.js',\n      assets: ['local-url.js']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('import.meta.url'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw a codeframe for a missing file in worker constructor with URL and import.meta.url","suites":["javascript"],"updatePoint":{"line":1161,"column":100,"index":44198},"line":1161,"code":"  it('should throw a codeframe for a missing file in worker constructor with URL and import.meta.url', async function () {\n    let fixture = path.join(__dirname, 'integration/worker-import-meta-url/missing.js');\n    let code = await inputFS.readFileSync(fixture, 'utf8');\n    await assert.rejects(() => bundle(fixture), {\n      name: 'BuildError',\n      diagnostics: [{\n        codeFrames: [{\n          filePath: fixture,\n          code,\n          codeHighlights: [{\n            end: {\n              column: 33,\n              line: 1\n            },\n            start: {\n              column: 20,\n              line: 1\n            }\n          }]\n        }],\n        message: \"Failed to resolve './invalid.js' from './missing.js'\",\n        origin: '@parcel/core'\n      }, {\n        hints: [\"Did you mean '__./dynamic.js__'?\", \"Did you mean '__./index.js__'?\"],\n        message: \"Cannot load file './invalid.js' in './'.\",\n        origin: '@parcel/resolver-default'\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling in workers with other loaders","suites":["javascript"],"line":1190,"code":"  it.skip('should support bundling in workers with other loaders', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should create a shared bundle to deduplicate assets in workers","suites":["javascript"],"updatePoint":{"line":1209,"column":68,"index":45776},"line":1209,"code":"  it('should create a shared bundle to deduplicate assets in workers', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/worker-shared/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'lodash.js', 'bundle-url.js', 'get-worker-url.js', 'bundle-manifest.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['worker-a.js', 'bundle-url.js', 'get-worker-url.js', 'bundle-manifest.js']\n    }, {\n      assets: ['worker-b.js']\n    }, {\n      assets: ['esmodule-helpers.js', 'lodash.js']\n    }]);\n    let sharedBundle = b.getBundles().sort((a, b) => b.stats.size - a.stats.size).find(b => b.name !== 'index.js');\n    let workerBundle = b.getBundles().find(b => b.name.startsWith('worker-b'));\n    let contents = await outputFS.readFile(workerBundle.filePath, 'utf8');\n    assert(contents.includes(`importScripts(\"./${path.basename(sharedBundle.filePath)}\")`));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should deduplicate and remove an unnecessary async bundle when it contains a cyclic reference to its entry","suites":["javascript"],"updatePoint":{"line":1231,"column":112,"index":46845},"line":1231,"code":"  it('should deduplicate and remove an unnecessary async bundle when it contains a cyclic reference to its entry', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/deduplicate-from-async-cyclic-bundle-entry/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bar.js', 'bundle-url.js', 'cacheLoader.js', 'esmodule-helpers.js', 'foo.js', 'js-loader.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.deepEqual(await Promise.all((await run(b)).default), [5, 4]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not create bundles for dynamic imports when assets are available up the graph","suites":["javascript"],"updatePoint":{"line":1241,"column":88,"index":47359},"line":1241,"code":"  it('does not create bundles for dynamic imports when assets are available up the graph', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/internalize-no-bundle-split/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bar.js', 'foo.js', 'esmodule-helpers.js']\n    }]);\n    assert.deepEqual(await (await run(b)).default, [3, 3]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"async dependency internalization successfully removes unneeded bundlegroups and their bundles","suites":["javascript"],"updatePoint":{"line":1249,"column":99,"index":47769},"line":1249,"code":"  it('async dependency internalization successfully removes unneeded bundlegroups and their bundles', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/internalize-remove-bundlegroup/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['bundle-url.js', 'get-worker-url.js', 'index.js']\n    }, {\n      assets: ['bundle-url.js', 'get-worker-url.js', 'worker1.js', 'worker2.js', 'worker3.js', 'core.js']\n    }, {\n      assets: ['core.js', 'worker3.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a shared bundle between browser and worker contexts","suites":["javascript"],"updatePoint":{"line":1260,"column":71,"index":48253},"line":1260,"code":"  it('should create a shared bundle between browser and worker contexts', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/html-shared-worker/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      assets: ['index.js', 'get-worker-url.js', 'lodash.js', 'esmodule-helpers.js', 'bundle-url.js']\n    }, {\n      assets: ['bundle-manifest.js']\n    }, {\n      assets: ['worker.js', 'lodash.js', 'esmodule-helpers.js']\n    }]);\n\n    // let sharedBundle = b\n    //   .getBundles()\n    //   .sort((a, b) => b.stats.size - a.stats.size)\n    //   .find(b => b.name !== 'index.js');\n    let workerBundle = b.getBundles().find(b => b.name.startsWith('worker'));\n    // let contents = await outputFS.readFile(workerBundle.filePath, 'utf8');\n    // assert(\n    //   contents.includes(\n    //     `importScripts(\"./${path.basename(sharedBundle.filePath)}\")`,\n    //   ),\n    // );\n\n    let outputArgs = [];\n    let workerArgs = [];\n    await run(b, {\n      Worker: class {\n        constructor(url) {\n          workerArgs.push(url);\n        }\n      },\n      output: (ctx, val) => {\n        outputArgs.push([ctx, val]);\n      }\n    });\n    assert.deepStrictEqual(outputArgs, [['main', 3]]);\n    assert.deepStrictEqual(workerArgs, [`http://localhost/${path.basename(workerBundle.filePath)}`]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support workers with shared assets between page and worker with async imports","suites":["javascript"],"updatePoint":{"line":1305,"column":90,"index":49736},"line":1305,"code":"  it('should support workers with shared assets between page and worker with async imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-shared-page/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'get-worker-url.js', 'index.js', 'js-loader.js', 'large.js']\n    }, {\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'large.js', 'worker.js']\n    }, {\n      assets: ['bundle-manifest.js', 'get-worker-url.js', 'index.js', 'large.js']\n    }, {\n      assets: ['async.js']\n    }, {\n      assets: ['async.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    await run(b);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should dynamic import files which import raw files","suites":["javascript"],"updatePoint":{"line":1330,"column":56,"index":50587},"line":1330,"code":"  it('should dynamic import files which import raw files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-references-raw/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['local.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['test.txt']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should return all exports as an object when using ES modules","suites":["javascript"],"updatePoint":{"line":1344,"column":66,"index":51121},"line":1344,"code":"  it('should return all exports as an object when using ES modules', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-esm/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'esmodule-helpers.js', 'js-loader.js']\n    }, {\n      assets: ['local.js']\n    }]);\n    let output = (await run(b)).default;\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should duplicate small modules across multiple bundles","suites":["javascript"],"updatePoint":{"line":1356,"column":60,"index":51612},"line":1356,"code":"  it('should duplicate small modules across multiple bundles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-common-small/index.js'));\n    assertBundles(b, [{\n      assets: ['a.js', 'common.js', 'common-dep.js']\n    }, {\n      assets: ['b.js', 'common.js', 'common-dep.js']\n    }, {\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 7);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a separate bundle for large modules shared between bundles","suites":["javascript"],"updatePoint":{"line":1370,"column":78,"index":52185},"line":1370,"code":"  it('should create a separate bundle for large modules shared between bundles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-common-large/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      assets: ['a.js']\n    }, {\n      assets: ['b.js']\n    }, {\n      name: 'index.js',\n      assets: ['index.js', 'c.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'bundle-manifest.js']\n    }, {\n      assets: ['common.js', 'lodash.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 7);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not duplicate a module which is already in a parent bundle","suites":["javascript"],"updatePoint":{"line":1391,"column":71,"index":52876},"line":1391,"code":"  it('should not duplicate a module which is already in a parent bundle', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-hoist-dup/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'common.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['a.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 5);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should duplicate an asset if it is not present in every parent bundle","suites":["javascript"],"updatePoint":{"line":1403,"column":75,"index":53364},"line":1403,"code":"  it('should duplicate an asset if it is not present in every parent bundle', async function () {\n    let b = await bundle(['a.js', 'b.js'].map(entry => path.join(__dirname, 'integration/dynamic-hoist-no-dedupe', entry)));\n    assertBundles(b, [{\n      assets: ['c.js', 'common.js', 'esmodule-helpers.js']\n    }, {\n      name: 'b.js',\n      assets: ['b.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      name: 'a.js',\n      assets: ['a.js', 'bundle-url.js', 'common.js', 'cacheLoader.js', 'esmodule-helpers.js', 'js-loader.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should duplicate an asset if it is not available in all possible ancestries","suites":["javascript"],"updatePoint":{"line":1415,"column":81,"index":53933},"line":1415,"code":"  it('should duplicate an asset if it is not available in all possible ancestries', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-hoist-no-dedupe-ancestry/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['a.js', 'common.js']\n    }, {\n      assets: ['b.js']\n    }, {\n      assets: ['c.js']\n    }, {\n      assets: ['d.js', 'common.js']\n    }]);\n    let {\n      default: promise\n    } = await run(b);\n    assert.equal(await promise, 42);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support shared modules with async imports","suites":["javascript"],"updatePoint":{"line":1434,"column":54,"index":54520},"line":1434,"code":"  it('should support shared modules with async imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-hoist-deep/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'esmodule-helpers.js', 'js-loader.js']\n    }, {\n      assets: ['a.js', 'c.js']\n    }, {\n      assets: ['b.js', 'c.js']\n    }, {\n      assets: ['1.js']\n    }]);\n    let {\n      default: promise\n    } = await run(b);\n    assert.ok(await promise);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring JSON files","suites":["javascript"],"updatePoint":{"line":1451,"column":41,"index":55037},"line":1451,"code":"  it('should support requiring JSON files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/json/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'local.json']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring JSON5 files","suites":["javascript"],"updatePoint":{"line":1461,"column":42,"index":55391},"line":1461,"code":"  it('should support requiring JSON5 files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/json5/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'local.json5']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing a URL to a raw asset","suites":["javascript"],"updatePoint":{"line":1471,"column":51,"index":55756},"line":1471,"code":"  it('should support importing a URL to a raw asset', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/import-raw/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js']\n    }, {\n      type: 'txt',\n      assets: ['test.txt']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert(/^http:\\/\\/localhost\\/test\\.[0-9a-f]+\\.txt$/.test(output()));\n    let stats = await outputFS.stat(path.join(distDir, url.parse(output()).pathname));\n    assert.equal(stats.size, 9);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support referencing a raw asset with static URL and import.meta.url","suites":["javascript"],"updatePoint":{"line":1486,"column":80,"index":56374},"line":1486,"code":"  it('should support referencing a raw asset with static URL and import.meta.url', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/import-raw-import-meta-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'esmodule-helpers.js']\n    }, {\n      type: 'txt',\n      assets: ['test.txt']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('import.meta.url'));\n    let output = await run(b);\n    assert(/^http:\\/\\/localhost\\/test\\.[0-9a-f]+\\.txt$/.test(output.default));\n    let stats = await outputFS.stat(path.join(distDir, output.default.pathname));\n    assert.equal(stats.size, 9);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support referencing a raw asset with static URL and CJS __filename","suites":["javascript"],"updatePoint":{"line":1502,"column":79,"index":57117},"line":1502,"code":"  it('should support referencing a raw asset with static URL and CJS __filename', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/import-raw-import-meta-url/cjs.js'));\n    assertBundles(b, [{\n      name: 'cjs.js',\n      assets: ['cjs.js', 'bundle-url.js', 'esmodule-helpers.js']\n    }, {\n      type: 'txt',\n      assets: ['test.txt']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('import.meta.url'));\n    let output = await run(b);\n    assert(/^http:\\/\\/localhost\\/test\\.[0-9a-f]+\\.txt$/.test(output.default));\n    let stats = await outputFS.stat(path.join(distDir, output.default.pathname));\n    assert.equal(stats.size, 9);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore new URL and import.meta.url with local binding","suites":["javascript"],"updatePoint":{"line":1518,"column":66,"index":57841},"line":1518,"code":"  it('should ignore new URL and import.meta.url with local binding', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/import-raw-import-meta-url/local-url.js'));\n    assertBundles(b, [{\n      name: 'local-url.js',\n      assets: ['esmodule-helpers.js', 'local-url.js']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('\"file:///local-url.js\"'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw a codeframe for a missing raw asset with static URL and import.meta.url","suites":["javascript"],"updatePoint":{"line":1527,"column":90,"index":58316},"line":1527,"code":"  it('should throw a codeframe for a missing raw asset with static URL and import.meta.url', async function () {\n    let fixture = path.join(__dirname, 'integration/import-raw-import-meta-url/missing.js');\n    let code = await inputFS.readFileSync(fixture, 'utf8');\n    await assert.rejects(() => bundle(fixture), {\n      name: 'BuildError',\n      diagnostics: [{\n        codeFrames: [{\n          filePath: fixture,\n          code,\n          codeHighlights: [{\n            end: {\n              column: 36,\n              line: 1\n            },\n            start: {\n              column: 24,\n              line: 1\n            }\n          }]\n        }],\n        message: \"Failed to resolve 'invalid.txt' from './missing.js'\",\n        origin: '@parcel/core'\n      }, {\n        hints: [],\n        message: \"Cannot load file './invalid.txt' in './'.\",\n        origin: '@parcel/resolver-default'\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing a URL to a large raw asset","suites":["javascript"],"updatePoint":{"line":1556,"column":57,"index":59195},"line":1556,"code":"  it('should support importing a URL to a large raw asset', async function () {\n    // 6 megabytes, which exceeds the threshold in summarizeRequest for buffering\n    // entire contents into memory and should stream content instead\n    let assetSizeBytes = 6000000;\n    let distDir = path.join(outputFS.cwd(), '/dist');\n    let fixtureDir = path.join(__dirname, '/integration/import-raw');\n    let inputDir = path.join(__dirname, 'input');\n    await ncp(fixtureDir, inputDir);\n    await outputFS.writeFile(path.join(inputDir, 'test.txt'), Buffer.alloc(assetSizeBytes));\n    let b = await bundle(path.join(inputDir, 'index.js'), {\n      inputFS: overlayFS,\n      defaultTargetOptions: {\n        distDir\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js']\n    }, {\n      type: 'txt',\n      assets: ['test.txt']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert(/^http:\\/\\/localhost\\/test\\.[0-9a-f]+\\.txt$/.test(output()));\n    let stats = await outputFS.stat(path.join(distDir, url.parse(output()).pathname));\n    assert.equal(stats.size, assetSizeBytes);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify JS in production mode","suites":["javascript"],"updatePoint":{"line":1584,"column":41,"index":60340},"line":1584,"code":"  it('should minify JS in production mode', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/uglify/index.js'), {\n      defaultTargetOptions: {\n        shouldOptimize: true,\n        shouldScopeHoist: false\n      }\n    });\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!js.includes('local.a'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should use terser config","suites":["javascript"],"updatePoint":{"line":1597,"column":30,"index":60810},"line":1597,"code":"  it('should use terser config', async function () {\n    await bundle(path.join(__dirname, '/integration/terser-config/index.js'), {\n      defaultTargetOptions: {\n        shouldOptimize: true,\n        shouldScopeHoist: false\n      }\n    });\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!js.includes('console.log'));\n    assert(!js.includes('// This is a comment'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert global variables when needed","suites":["javascript"],"updatePoint":{"line":1608,"column":48,"index":61244},"line":1608,"code":"  it('should insert global variables when needed', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/globals/index.js'));\n    let output = await run(b);\n    assert.deepEqual(output(), {\n      dir: 'integration/globals',\n      file: 'integration/globals/index.js',\n      buf: Buffer.from('browser').toString('base64'),\n      global: true\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should replace __dirname and __filename with path relative to asset.filePath","suites":["javascript"],"updatePoint":{"line":1618,"column":82,"index":61659},"line":1618,"code":"  it('should replace __dirname and __filename with path relative to asset.filePath', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-node-replacements/index.js'));\n    let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(dist.includes('resolve(__dirname, \"../test/integration/env-node-replacements\")'));\n    assert(dist.includes('resolve(__dirname, \"../test/integration/env-node-replacements/other\")'));\n    assert(dist.includes('resolve(__dirname, \"../test/integration/env-node-replacements\", \"index.js\")'));\n    assert(dist.includes('resolve(__dirname, \"../test/integration/env-node-replacements/sub\")'));\n    assert(dist.includes('resolve(__dirname, \"../test/integration/env-node-replacements/sub\", \"index.js\")'));\n    let f = await run(b);\n    let output = f();\n    assert.equal(output.data, 'hello');\n    assert.equal(output.other, 'hello');\n    assert.equal(output.firstDirnameTest, path.join(__dirname, '/integration/env-node-replacements/data'));\n    assert.equal(output.secondDirnameTest, path.join(__dirname, '/integration/env-node-replacements/other-data'));\n    assert.equal(output.firstFilenameTest, path.join(__dirname, '/integration/env-node-replacements/index.js'));\n    assert.equal(output.secondFilenameTest, path.join(__dirname, '/integration/env-node-replacements/index.js?query-string=test'));\n    assert.equal(output.sub.dirname, path.join(__dirname, '/integration/env-node-replacements/sub'));\n    assert.equal(output.sub.filename, path.join(__dirname, '/integration/env-node-replacements/sub/index.js'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should replace __dirname and __filename with path relative to asset.filePath with scope hoisting","suites":["javascript"],"updatePoint":{"line":1637,"column":102,"index":63280},"line":1637,"code":"  it('should replace __dirname and __filename with path relative to asset.filePath with scope hoisting', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-node-replacements/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        shouldOptimize: false\n      }\n    });\n    let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(dist.includes('path.resolve(__dirname, \"../test/integration/env-node-replacements\")'));\n    assert(dist.includes('path.resolve(__dirname, \"../test/integration/env-node-replacements/other\")'));\n    assert(dist.includes('path.resolve(__dirname, \"../test/integration/env-node-replacements\", \"index.js\")'));\n    assert(dist.includes('path.resolve(__dirname, \"../test/integration/env-node-replacements/sub\")'));\n    assert(dist.includes('path.resolve(__dirname, \"../test/integration/env-node-replacements/sub\", \"index.js\")'));\n    let f = await run(b);\n    let output = f();\n    assert.equal(output.data, 'hello');\n    assert.equal(output.other, 'hello');\n    assert.equal(output.firstDirnameTest, path.join(__dirname, '/integration/env-node-replacements/data'));\n    assert.equal(output.secondDirnameTest, path.join(__dirname, '/integration/env-node-replacements/other-data'));\n    assert.equal(output.firstFilenameTest, path.join(__dirname, '/integration/env-node-replacements/index.js'));\n    assert.equal(output.secondFilenameTest, path.join(__dirname, '/integration/env-node-replacements/index.js?query-string=test'));\n    assert.equal(output.sub.dirname, path.join(__dirname, '/integration/env-node-replacements/sub'));\n    assert.equal(output.sub.filename, path.join(__dirname, '/integration/env-node-replacements/sub/index.js'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work when multiple files use globals with scope hoisting","suites":["javascript"],"updatePoint":{"line":1662,"column":69,"index":65028},"line":1662,"code":"  it('should work when multiple files use globals with scope hoisting', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/globals/multiple.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        shouldOptimize: false\n      }\n    });\n    let output = await run(b);\n    assert.deepEqual(output, {\n      file: 'integration/globals/multiple.js',\n      other: 'integration/globals/index.js'\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not insert global variables when used in a module specifier","suites":["javascript"],"updatePoint":{"line":1676,"column":72,"index":65509},"line":1676,"code":"  it('should not insert global variables when used in a module specifier', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/globals-module-specifier/a.js'));\n    assertBundles(b, [{\n      assets: ['a.js', 'b.js', 'c.js', 'esmodule-helpers.js']\n    }]);\n    let output = await run(b);\n    assert.deepEqual(output, 1234);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not insert global variables in dead branches","suites":["javascript"],"updatePoint":{"line":1684,"column":57,"index":65851},"line":1684,"code":"  it('should not insert global variables in dead branches', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/globals-unused/a.js'));\n    assertBundles(b, [{\n      assets: ['a.js']\n    }]);\n    let output = await run(b);\n    assert.deepEqual(output, 'foo');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle re-declaration of the global constant","suites":["javascript"],"updatePoint":{"line":1692,"column":57,"index":66145},"line":1692,"code":"  it('should handle re-declaration of the global constant', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/global-redeclare/index.js'));\n    let output = await run(b);\n    assert.deepEqual(output(), false);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert environment variables inserted by a prior transform","suites":["javascript"],"updatePoint":{"line":1697,"column":71,"index":66405},"line":1697,"code":"  it('should insert environment variables inserted by a prior transform', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/env-prior-transform/index.js'));\n    let jsBundle = b.getBundles()[0];\n    let contents = await outputFS.readFile(jsBundle.filePath, 'utf8');\n    assert(!contents.includes('process.env'));\n    assert.equal(await run(b), 'test');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not insert environment variables in node environment","suites":["javascript"],"updatePoint":{"line":1704,"column":65,"index":66782},"line":1704,"code":"  it('should not insert environment variables in node environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-node/index.js'));\n    let output = await run(b);\n    assert.ok(output.toString().includes('process.env'));\n    assert.equal(output(), 'test:test');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not replace process.env.hasOwnProperty with undefined","suites":["javascript"],"updatePoint":{"line":1710,"column":66,"index":67089},"line":1710,"code":"  it('should not replace process.env.hasOwnProperty with undefined', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-hasOwnProperty/index.js'));\n    let output = await run(b);\n    assert.strictEqual(output, false);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not insert environment variables in electron-main environment","suites":["javascript"],"updatePoint":{"line":1715,"column":74,"index":67354},"line":1715,"code":"  it('should not insert environment variables in electron-main environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env/index.js'), {\n      targets: {\n        main: {\n          context: 'electron-main',\n          distDir: path.join(__dirname, '/integration/env/dist.js')\n        }\n      }\n    });\n    let output = await run(b);\n    assert.ok(output.toString().includes('process.env'));\n    assert.equal(output(), 'test:test');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not insert environment variables in electron-renderer environment","suites":["javascript"],"updatePoint":{"line":1728,"column":78,"index":67832},"line":1728,"code":"  it('should not insert environment variables in electron-renderer environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env/index.js'), {\n      targets: {\n        main: {\n          context: 'electron-renderer',\n          distDir: path.join(__dirname, '/integration/env/dist.js')\n        }\n      }\n    });\n    let output = await run(b);\n    assert.ok(output.toString().includes('process.env'));\n    assert.equal(output(), 'test:test');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline NODE_ENV environment variable in browser environment even if disabled","suites":["javascript"],"updatePoint":{"line":1741,"column":89,"index":68325},"line":1741,"code":"  it('should inline NODE_ENV environment variable in browser environment even if disabled', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-nodeenv/index.js'), {\n      env: {\n        FOO: 'abc'\n      }\n    });\n    let output = await run(b);\n    assert.ok(!output.toString().includes('process.env'));\n    assert.equal(output(), 'test:undefined');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not insert environment variables in browser environment if disabled","suites":["javascript"],"updatePoint":{"line":1751,"column":80,"index":68704},"line":1751,"code":"  it('should not insert environment variables in browser environment if disabled', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-disabled/index.js'), {\n      env: {\n        FOOBAR: 'abc'\n      }\n    });\n    let output = await run(b);\n    assert.ok(!output.toString().includes('process.env'));\n    assert.equal(output(), 'undefined:undefined:undefined');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should only insert environment variables in browser environment matching the glob","suites":["javascript"],"updatePoint":{"line":1761,"column":87,"index":69109},"line":1761,"code":"  it('should only insert environment variables in browser environment matching the glob', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-disabled-glob/index.js'), {\n      env: {\n        A_1: 'abc',\n        B_1: 'def',\n        B_2: 'ghi'\n      }\n    });\n    let output = await run(b);\n    assert.ok(!output.toString().includes('process.env'));\n    assert.equal(output(), 'undefined:def:ghi');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should be able to inline environment variables in browser environment","suites":["javascript"],"updatePoint":{"line":1773,"column":75,"index":69532},"line":1773,"code":"  it('should be able to inline environment variables in browser environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env/index.js'), {\n      env: {\n        NODE_ENV: 'abc'\n      }\n    });\n    let output = await run(b);\n    assert.ok(!output.toString().includes('process.env'));\n    assert.equal(output(), 'abc:abc');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert the user's NODE_ENV as process.env.NODE_ENV if passed","suites":["javascript"],"updatePoint":{"line":1783,"column":73,"index":69894},"line":1783,"code":"  it(\"should insert the user's NODE_ENV as process.env.NODE_ENV if passed\", async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env/index.js'), {\n      env: {\n        NODE_ENV: 'production'\n      }\n    });\n    let output = await run(b);\n    assert.ok(!output.toString().includes('process.env'));\n    assert.equal(output(), 'production:production');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not inline computed accesses to process.env","suites":["javascript"],"updatePoint":{"line":1793,"column":56,"index":70260},"line":1793,"code":"  it('should not inline computed accesses to process.env', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-computed/index.js'), {\n      env: {\n        ABC: 'abc'\n      }\n    });\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('process.env'));\n    let output = await run(b);\n    assert.strictEqual(output, undefined);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline computed accesses with string literals to process.env","suites":["javascript"],"updatePoint":{"line":1804,"column":73,"index":70697},"line":1804,"code":"  it('should inline computed accesses with string literals to process.env', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-computed-string/index.js'), {\n      env: {\n        ABC: 'XYZ'\n      }\n    });\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('process.env'));\n    let output = await run(b);\n    assert.strictEqual(output, 'XYZ');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline environment variables when destructured in a variable declaration","suites":["javascript"],"updatePoint":{"line":1815,"column":85,"index":71150},"line":1815,"code":"  it('should inline environment variables when destructured in a variable declaration', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-destructuring/index.js'), {\n      env: {\n        TEST: 'XYZ'\n      },\n      defaultTargetOptions: {\n        engines: {\n          browsers: '>= 0.25%'\n        }\n      }\n    });\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('process.env'));\n    let output = await run(b);\n    assert.deepEqual(output, {\n      env: {},\n      NODE_ENV: 'test',\n      renamed: 'XYZ',\n      computed: undefined,\n      fallback: 'yo',\n      rest: {},\n      other: 'hi'\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline environment variables when destructured in an assignment","suites":["javascript"],"updatePoint":{"line":1839,"column":76,"index":71836},"line":1839,"code":"  it('should inline environment variables when destructured in an assignment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-destructuring/assign.js'), {\n      env: {\n        TEST: 'XYZ'\n      },\n      defaultTargetOptions: {\n        engines: {\n          browsers: '>= 0.25%'\n        }\n      }\n    });\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('process.env'));\n    let output = await run(b);\n    assert.deepEqual(output, {\n      env: {},\n      NODE_ENV: 'test',\n      renamed: 'XYZ',\n      computed: undefined,\n      fallback: 'yo',\n      rest: {},\n      result: {}\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline environment variables with in binary expression whose right branch is process.env and left branch is string literal","suites":["javascript"],"updatePoint":{"line":1863,"column":135,"index":72581},"line":1863,"code":"  it('should inline environment variables with in binary expression whose right branch is process.env and left branch is string literal', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-binary-in-expression/index.js'), {\n      env: {\n        ABC: 'any'\n      },\n      defaultTargetOptions: {\n        engines: {\n          browsers: '>= 0.25%'\n        }\n      }\n    });\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('process.env'));\n    let output = await run(b);\n    assert.deepEqual(output, {\n      existVar: 'correct',\n      notExistVar: 'correct'\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert environment variables from a file","suites":["javascript"],"updatePoint":{"line":1882,"column":53,"index":73162},"line":1882,"code":"  it('should insert environment variables from a file', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-file/index.js'));\n\n    // Make sure dotenv doesn't leak its values into the main process's env\n    assert(process.env.FOO == null);\n    let output = await run(b);\n    assert.equal(output, 'bartest');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert environment variables matching the user's NODE_ENV if passed","suites":["javascript"],"updatePoint":{"line":1890,"column":80,"index":73535},"line":1890,"code":"  it(\"should insert environment variables matching the user's NODE_ENV if passed\", async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-file/index.js'), {\n      env: {\n        NODE_ENV: 'production'\n      }\n    });\n    let output = await run(b);\n    assert.equal(output, 'productiontest');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should overwrite environment variables from a file if passed","suites":["javascript"],"updatePoint":{"line":1899,"column":66,"index":73848},"line":1899,"code":"  it('should overwrite environment variables from a file if passed', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-file/index.js'), {\n      env: {\n        BAR: 'baz'\n      }\n    });\n    let output = await run(b);\n    assert.equal(output, 'barbaz');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert environment variables from a file even if entry file is specified with source value in package.json","suites":["javascript"],"updatePoint":{"line":1908,"column":119,"index":74194},"line":1908,"code":"  it('should insert environment variables from a file even if entry file is specified with source value in package.json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-file-with-package-source'));\n    let output = await run(b);\n    assert.equal(output, 'bartest');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on process.env mutations","suites":["javascript"],"updatePoint":{"line":1913,"column":43,"index":74427},"line":1913,"code":"  it('should error on process.env mutations', async function () {\n    let filePath = path.join(__dirname, '/integration/env-mutate/index.js');\n    await assert.rejects(bundle(filePath), {\n      diagnostics: [{\n        origin: '@parcel/transformer-js',\n        message: 'Mutating process.env is not supported',\n        hints: null,\n        codeFrames: [{\n          filePath,\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 29\n            }\n          }]\n        }]\n      }, {\n        origin: '@parcel/transformer-js',\n        message: 'Mutating process.env is not supported',\n        hints: null,\n        codeFrames: [{\n          filePath,\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 2,\n              column: 1\n            },\n            end: {\n              line: 2,\n              column: 30\n            }\n          }]\n        }]\n      }, {\n        origin: '@parcel/transformer-js',\n        message: 'Mutating process.env is not supported',\n        hints: null,\n        codeFrames: [{\n          filePath,\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 3,\n              column: 1\n            },\n            end: {\n              line: 3,\n              column: 28\n            }\n          }]\n        }]\n      }, {\n        origin: '@parcel/transformer-js',\n        message: 'Mutating process.env is not supported',\n        hints: null,\n        codeFrames: [{\n          filePath,\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 4,\n              column: 1\n            },\n            end: {\n              line: 4,\n              column: 23\n            }\n          }]\n        }]\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should warn on process.env mutations in node_modules","suites":["javascript"],"updatePoint":{"line":1991,"column":58,"index":76340},"line":1991,"code":"  it('should warn on process.env mutations in node_modules', async function () {\n    let logs = [];\n    let disposable = Logger.onLog(d => logs.push(d));\n    let b = await bundle(path.join(__dirname, '/integration/env-mutate/warn.js'));\n    disposable.dispose();\n    assert.deepEqual(logs, [{\n      type: 'log',\n      level: 'warn',\n      diagnostics: [{\n        origin: '@parcel/transformer-js',\n        message: 'Mutating process.env is not supported',\n        hints: null,\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/env-mutate/node_modules/foo/index.js'),\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 36\n            }\n          }]\n        }]\n      }, {\n        origin: '@parcel/transformer-js',\n        message: 'Mutating process.env is not supported',\n        hints: null,\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/env-mutate/node_modules/foo/index.js'),\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 2,\n              column: 8\n            },\n            end: {\n              line: 2,\n              column: 35\n            }\n          }]\n        }]\n      }, {\n        origin: '@parcel/transformer-js',\n        message: 'Mutating process.env is not supported',\n        hints: null,\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/env-mutate/node_modules/foo/index.js'),\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 3,\n              column: 8\n            },\n            end: {\n              line: 3,\n              column: 30\n            }\n          }]\n        }]\n      }]\n    }]);\n    let output = [];\n    await run(b, {\n      output(o) {\n        output.push(o);\n      }\n    });\n    assert.deepEqual(output, ['foo', true, undefined]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should replace process.browser for target browser","suites":["javascript"],"updatePoint":{"line":2063,"column":55,"index":78341},"line":2063,"code":"  it('should replace process.browser for target browser', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/process/index.js'), {\n      targets: {\n        main: {\n          context: 'browser',\n          distDir: path.join(__dirname, '/integration/process/dist.js')\n        }\n      }\n    });\n    let output = await run(b);\n    assert.ok(output.toString().indexOf('process.browser') === -1);\n    assert.equal(output(), true);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not touch process.browser for target node","suites":["javascript"],"updatePoint":{"line":2076,"column":54,"index":78800},"line":2076,"code":"  it('should not touch process.browser for target node', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/process/index.js'), {\n      targets: {\n        main: {\n          context: 'node',\n          distDir: path.join(__dirname, '/integration/process/dist.js')\n        }\n      }\n    });\n    let output = await run(b);\n    assert.ok(output.toString().indexOf('process.browser') !== -1);\n    assert.equal(output(), false);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not touch process.browser for target electron-main","suites":["javascript"],"updatePoint":{"line":2089,"column":63,"index":79266},"line":2089,"code":"  it('should not touch process.browser for target electron-main', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/process/index.js'), {\n      targets: {\n        main: {\n          context: 'electron-main',\n          distDir: path.join(__dirname, '/integration/process/dist.js')\n        }\n      }\n    });\n    let output = await run(b);\n    assert.ok(output.toString().indexOf('process.browser') !== -1);\n    assert.equal(output(), false);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should replace process.browser for target electron-renderer","suites":["javascript"],"updatePoint":{"line":2102,"column":65,"index":79743},"line":2102,"code":"  it('should replace process.browser for target electron-renderer', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/process/index.js'), {\n      targets: {\n        main: {\n          context: 'electron-renderer',\n          distDir: path.join(__dirname, '/integration/process/dist.js')\n        }\n      }\n    });\n    let output = await run(b);\n    assert.ok(output.toString().indexOf('process.browser') === -1);\n    assert.equal(output(), true);\n    // Running the bundled code has the side effect of setting process.browser = true, which can mess\n    // up the instantiation of typescript.sys within validator-typescript, so we want to reset it.\n    process.browser = undefined;\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding implicit dependencies","suites":["javascript"],"line":2118,"code":"  it.skip('should support adding implicit dependencies', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring YAML files","suites":["javascript"],"updatePoint":{"line":2144,"column":41,"index":81147},"line":2144,"code":"  it('should support requiring YAML files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/yaml/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'local.yaml'],\n      childBundles: [{\n        type: 'map'\n      }]\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring TOML files","suites":["javascript"],"updatePoint":{"line":2157,"column":41,"index":81553},"line":2157,"code":"  it('should support requiring TOML files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/toml/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'local.toml'],\n      childBundles: [{\n        type: 'map'\n      }]\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring CoffeeScript files","suites":["javascript"],"updatePoint":{"line":2170,"column":49,"index":81967},"line":2170,"code":"  it('should support requiring CoffeeScript files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/coffee/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'local.coffee']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve the browser field before main","suites":["javascript"],"updatePoint":{"line":2180,"column":50,"index":82333},"line":2180,"code":"  it('should resolve the browser field before main', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-entries/browser.js'));\n    assertBundles(b, [{\n      name: 'browser.js',\n      assets: ['browser.js', 'browser-module.js', 'esmodule-helpers.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output.test, 'function');\n    assert.equal(output.test(), 'pkg-browser');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should exclude resolving specifiers that map to false in the browser field in browser builds","suites":["javascript"],"updatePoint":{"line":2190,"column":98,"index":82812},"line":2190,"code":"  it('should exclude resolving specifiers that map to false in the browser field in browser builds', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-entries/pkg-ignore-browser/index.js'), {\n      targets: ['browsers']\n    });\n    assert.deepEqual(await run(b), {});\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not exclude resolving specifiers that map to false in the browser field in node builds","suites":["javascript"],"updatePoint":{"line":2196,"column":99,"index":83119},"line":2196,"code":"  it('should not exclude resolving specifiers that map to false in the browser field in node builds', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-entries/pkg-ignore-browser/index.js'), {\n      targets: ['node']\n    });\n    assert.equal(await run(b), 'this should only exist in non-browser builds');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not resolve the browser field for --target=node","suites":["javascript"],"line":2202,"code":"  it.skip('should not resolve the browser field for --target=node', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should resolve advanced browser resolution","suites":["javascript"],"line":2217,"code":"  it.skip('should resolve advanced browser resolution', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should not resolve advanced browser resolution with --target=node","suites":["javascript"],"line":2234,"code":"  it.skip('should not resolve advanced browser resolution with --target=node', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should resolve the module field before main if scope-hoisting is enabled","suites":["javascript"],"line":2253,"code":"  it.skip('should resolve the module field before main if scope-hoisting is enabled', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should resolve the module field before main if scope-hoisting is enabled","suites":["javascript"],"line":2267,"code":"  it.skip('should resolve the module field before main if scope-hoisting is enabled', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should resolve the main field","suites":["javascript"],"updatePoint":{"line":2281,"column":35,"index":86383},"line":2281,"code":"  it('should resolve the main field', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-entries/main-field.js'));\n    assertBundles(b, [{\n      name: 'main-field.js',\n      assets: ['main-field.js', 'main.js', 'esmodule-helpers.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output.test, 'function');\n    assert.equal(output.test(), 'pkg-main-module');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify JSON files","suites":["javascript"],"updatePoint":{"line":2291,"column":30,"index":86797},"line":2291,"code":"  it('should minify JSON files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/uglify-json/index.json'), {\n      defaultTargetOptions: {\n        shouldOptimize: true,\n        shouldScopeHoist: false\n      }\n    });\n    let json = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(json.includes('{\"test\":\"test\"}'));\n    let output = await run(b);\n    assert.deepEqual(output, {\n      test: 'test'\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify JSON5 files","suites":["javascript"],"updatePoint":{"line":2305,"column":31,"index":87268},"line":2305,"code":"  it('should minify JSON5 files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/uglify-json5/index.json5'), {\n      defaultTargetOptions: {\n        shouldOptimize: true,\n        shouldScopeHoist: false\n      }\n    });\n    let json = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(json.includes('{\"test\":\"test\"}'));\n    let output = await run(b);\n    assert.deepEqual(output, {\n      test: 'test'\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify YAML for production","suites":["javascript"],"line":2319,"code":"  it.skip('should minify YAML for production', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should minify TOML for production","suites":["javascript"],"updatePoint":{"line":2332,"column":39,"index":88225},"line":2332,"code":"  it('should minify TOML for production', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/toml/index.js'), {\n      defaultTargetOptions: {\n        shouldOptimize: true,\n        shouldScopeHoist: false\n      }\n    });\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n    let json = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(json.includes('{a:1,b:{c:2}}'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support optional dependencies in try...catch blocks","suites":["javascript"],"updatePoint":{"line":2345,"column":64,"index":88736},"line":2345,"code":"  it('should support optional dependencies in try...catch blocks', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/optional-dep/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }]);\n    let output = await run(b);\n    assert.equal(Object.getPrototypeOf(output).constructor.name, 'Error');\n    assert(/Cannot find module ['\"]optional-dep['\"]/.test(output.message), 'Should set correct error message');\n    assert.equal(output.code, 'MODULE_NOT_FOUND');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support excluding dependencies in falsy branches","suites":["javascript"],"updatePoint":{"line":2356,"column":61,"index":89265},"line":2356,"code":"  it('should support excluding dependencies in falsy branches', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/falsy-dep/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'true-alternate.js', 'true-consequent.js']\n    }]);\n    let output = await run(b);\n    assert.equal(output, 2);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not autoinstall if resolve failed on installed module","suites":["javascript"],"line":2365,"code":"  it.skip('should not autoinstall if resolve failed on installed module', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should not autoinstall if resolve failed on aliased module","suites":["javascript"],"line":2375,"code":"  it.skip('should not autoinstall if resolve failed on aliased module', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should ignore require if it is defined in the scope","suites":["javascript"],"updatePoint":{"line":2385,"column":57,"index":90436},"line":2385,"code":"  it('should ignore require if it is defined in the scope', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/require-scope/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output.test, 'object');\n    let failed = Object.keys(output.test).some(key => output.test[key] !== 'test passed');\n    assert.equal(failed, false);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should expose to CommonJS entry point","suites":["javascript"],"updatePoint":{"line":2396,"column":43,"index":90882},"line":2396,"code":"  it('should expose to CommonJS entry point', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/entry-point/index.js'));\n    let module = {};\n    await run(b, {\n      module,\n      exports: {}\n    });\n    assert.equal(module.exports(), 'Test!');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should expose to RequireJS entry point","suites":["javascript"],"updatePoint":{"line":2405,"column":44,"index":91165},"line":2405,"code":"  it('should expose to RequireJS entry point', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/entry-point/index.js'));\n    let test;\n    const mockDefine = function (f) {\n      test = f();\n    };\n    mockDefine.amd = true;\n    await run(b, {\n      define: mockDefine,\n      module: undefined\n    });\n    assert.equal(test(), 'Test!');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should expose variable with --browser-global","suites":["javascript"],"line":2418,"code":"  it.skip('should expose variable with --browser-global', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should set `define` to undefined so AMD checks in UMD modules do not pass","suites":["javascript"],"line":2429,"code":"  it.skip('should set `define` to undefined so AMD checks in UMD modules do not pass', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should package successfully with comments on last line","suites":["javascript"],"updatePoint":{"line":2442,"column":60,"index":92304},"line":2442,"code":"  it('should package successfully with comments on last line', async function () {\n    let b = await bundle(path.join(__dirname, `/integration/js-comment/index.js`));\n    let output = await run(b);\n    assert.equal(output, 'Hello World!');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should package successfully with comments on last line and minification","suites":["javascript"],"updatePoint":{"line":2447,"column":77,"index":92567},"line":2447,"code":"  it('should package successfully with comments on last line and minification', async function () {\n    let b = await bundle(path.join(__dirname, `/integration/js-comment/index.js`));\n    let output = await run(b);\n    assert.equal(output, 'Hello World!');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should package successfully with comments on last line and scope hoisting","suites":["javascript"],"updatePoint":{"line":2452,"column":79,"index":92832},"line":2452,"code":"  it('should package successfully with comments on last line and scope hoisting', async function () {\n    let b = await bundle(path.join(__dirname, `/integration/js-comment/index.js`), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let output = await run(b);\n    assert.equal(output, 'Hello World!');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should package successfully with comments on last line, scope hoisting and minification","suites":["javascript"],"updatePoint":{"line":2461,"column":93,"index":93189},"line":2461,"code":"  it('should package successfully with comments on last line, scope hoisting and minification', async function () {\n    let b = await bundle(path.join(__dirname, `/integration/js-comment/index.js`), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        shouldOptimize: true\n      }\n    });\n    let output = await run(b);\n    assert.equal(output, 'Hello World!');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not replace toplevel this with undefined in CommonJS without scope-hoisting","suites":["javascript"],"updatePoint":{"line":2471,"column":88,"index":93571},"line":2471,"code":"  it('should not replace toplevel this with undefined in CommonJS without scope-hoisting', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/js-this-commonjs/a.js'));\n    let output;\n    function result(v) {\n      output = v;\n    }\n    await run(b, {\n      result\n    });\n    assert.deepEqual(output, [{\n      foo: 2\n    }, 1234]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not replace toplevel this with undefined in CommonJS when scope-hoisting","suites":["javascript"],"updatePoint":{"line":2484,"column":85,"index":93936},"line":2484,"code":"  it('should not replace toplevel this with undefined in CommonJS when scope-hoisting', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/js-this-commonjs/a.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let output;\n    function result(v) {\n      output = v;\n    }\n    await run(b, {\n      result\n    });\n    assert.deepEqual(output, [{\n      foo: 2\n    }, 1234]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should replace toplevel this with undefined in ESM without scope-hoisting","suites":["javascript"],"updatePoint":{"line":2501,"column":79,"index":94373},"line":2501,"code":"  it('should replace toplevel this with undefined in ESM without scope-hoisting', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/js-this-es6/a.js'));\n    let output;\n    function result(v) {\n      output = v;\n    }\n    await run(b, {\n      result\n    });\n    assert.deepEqual(output, [undefined, 1234]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should replace toplevel this with undefined in ESM when scope-hoisting","suites":["javascript"],"updatePoint":{"line":2512,"column":76,"index":94713},"line":2512,"code":"  it('should replace toplevel this with undefined in ESM when scope-hoisting', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/js-this-es6/a.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let output;\n    function result(v) {\n      output = v;\n    }\n    await run(b, {\n      result\n    });\n    assert.deepEqual(output, [undefined, 1234]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not dedupe imports with different contents","suites":["javascript"],"line":2527,"code":"  it.skip('should not dedupe imports with different contents', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should not dedupe imports with same content but different absolute dependency paths","suites":["javascript"],"line":2535,"code":"  it.skip('should not dedupe imports with same content but different absolute dependency paths', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should dedupe imports with same content and same dependency paths","suites":["javascript"],"line":2543,"code":"  it.skip('should dedupe imports with same content and same dependency paths', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should not dedupe assets that exist in more than one bundle","suites":["javascript"],"line":2559,"code":"  it.skip('should not dedupe assets that exist in more than one bundle', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support importing HTML from JS async","suites":["javascript"],"line":2572,"code":"  it.skip('should support importing HTML from JS async', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support importing HTML from JS async with --target=node","suites":["javascript"],"line":2599,"code":"  it.skip('should support importing HTML from JS async with --target=node', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support importing HTML from JS sync","suites":["javascript"],"line":2627,"code":"  it.skip('should support importing HTML from JS sync', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should stub require.cache","suites":["javascript"],"line":2663,"code":"  it.skip('should stub require.cache', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support async importing the same module from different bundles","suites":["javascript"],"updatePoint":{"line":2669,"column":75,"index":100114},"line":2669,"code":"  it('should support async importing the same module from different bundles', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/shared-bundlegroup/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'esmodule-helpers.js', 'js-loader.js']\n    }, {\n      assets: ['a.js']\n    }, {\n      assets: ['b.js']\n    }, {\n      assets: ['c.js']\n    }]);\n    let {\n      default: promise\n    } = await run(b);\n    assert.deepEqual(await promise, ['hello from a test', 'hello from b test']);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not create shared bundles from contents of entries","suites":["javascript"],"updatePoint":{"line":2686,"column":63,"index":100682},"line":2686,"code":"  it('should not create shared bundles from contents of entries', async () => {\n    let b = await bundle(['a.js', 'b.js'].map(entry => path.join(__dirname, '/integration/no-shared-bundles-from-entries/', entry)));\n    assertBundles(b, [{\n      name: 'a.js',\n      assets: ['a.js', 'esmodule-helpers.js', 'lodash.js']\n    }, {\n      name: 'b.js',\n      assets: ['b.js', 'esmodule-helpers.js', 'lodash.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should import the same dependency multiple times in the same bundle","suites":["javascript"],"updatePoint":{"line":2696,"column":73,"index":101112},"line":2696,"code":"  it('should import the same dependency multiple times in the same bundle', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/same-dependency-multiple-times/a1.js'));\n    await run(b);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a bundle's compiled text with `bundle-text`","suites":["javascript"],"updatePoint":{"line":2700,"column":63,"index":101317},"line":2700,"code":"  it(\"should inline a bundle's compiled text with `bundle-text`\", async () => {\n    let b = await bundle(path.join(__dirname, '/integration/bundle-text/index.js'));\n    let cssBundleContent = (await run(b)).default;\n    assert(cssBundleContent.startsWith(`body {\n  background-color: #000;\n}\n\n.svg-img {\n  background-image: url(\"data:image/svg+xml,%3Csvg%3E%0A%0A%3C%2Fsvg%3E%0A\");\n}`));\n    assert(!cssBundleContent.includes('sourceMappingURL'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not include the runtime manifest for `bundle-text`","suites":["javascript"],"updatePoint":{"line":2712,"column":63,"index":101770},"line":2712,"code":"  it('should not include the runtime manifest for `bundle-text`', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/bundle-text/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false,\n        shouldOptimize: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      type: 'js',\n      assets: ['esmodule-helpers.js', 'index.js']\n    }, {\n      type: 'svg',\n      assets: ['img.svg']\n    }, {\n      type: 'css',\n      assets: ['text.scss']\n    }]);\n    let cssBundleContent = (await run(b)).default;\n    assert(cssBundleContent.startsWith(`body {\n  background-color: #000;\n}\n\n.svg-img {\n  background-image: url(\"data:image/svg+xml,%3Csvg%3E%0A%0A%3C%2Fsvg%3E%0A\");\n}`));\n    assert(!cssBundleContent.includes('sourceMappingURL'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline an HTML bundle's compiled text with `bundle-text`","suites":["javascript"],"updatePoint":{"line":2741,"column":69,"index":102600},"line":2741,"code":"  it(\"should inline an HTML bundle's compiled text with `bundle-text`\", async () => {\n    let b = await bundle(path.join(__dirname, '/integration/bundle-text/index.html'));\n    let res = await run(b);\n    assert.equal(res.default, '<p>test</p>\\n');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline an HTML bundle and inline scripts with `bundle-text`","suites":["javascript"],"updatePoint":{"line":2746,"column":72,"index":102858},"line":2746,"code":"  it('should inline an HTML bundle and inline scripts with `bundle-text`', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/bundle-text/inline.js'));\n    let res = await run(b);\n    assert.equal(res.default, `<p>test</p>\\n<script>console.log(\"hi\");\\n\\n</script>\\n`);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a JS bundle's compiled text with `bundle-text` and HMR enabled","suites":["javascript"],"updatePoint":{"line":2751,"column":82,"index":103166},"line":2751,"code":"  it(\"should inline a JS bundle's compiled text with `bundle-text` and HMR enabled\", async () => {\n    let b = await bundle(path.join(__dirname, '/integration/bundle-text/javascript.js'), {\n      hmrOptions: {}\n    });\n    let res = await run(b);\n    let log;\n    let ctx = vm.createContext({\n      console: {\n        log(x) {\n          log = x;\n        }\n      }\n    });\n    vm.runInContext(res.default, ctx);\n    assert.equal(log, 'hi');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a JS bundle's compiled text with `bundle-text` with symbol propagation","suites":["javascript"],"updatePoint":{"line":2767,"column":90,"index":103620},"line":2767,"code":"  it(\"should inline a JS bundle's compiled text with `bundle-text` with symbol propagation\", async () => {\n    let b = await bundle(path.join(__dirname, '/integration/bundle-text/javascript.js'), {\n      mode: 'production'\n    });\n    let res = await run(b);\n    let log;\n    let ctx = vm.createContext({\n      console: {\n        log(x) {\n          log = x;\n        }\n      }\n    });\n    vm.runInContext(res, ctx);\n    assert.equal(log, 'hi');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a bundle's compiled text with `bundle-text` asynchronously","suites":["javascript"],"updatePoint":{"line":2783,"column":78,"index":104058},"line":2783,"code":"  it(\"should inline a bundle's compiled text with `bundle-text` asynchronously\", async () => {\n    let b = await bundle(path.join(__dirname, '/integration/bundle-text/async.js'));\n    let promise = (await run(b)).default;\n    assert.equal(typeof promise.then, 'function');\n    let cssBundleContent = await promise;\n    assert(cssBundleContent.startsWith(`body {\n  background-color: #000;\n}\n\n.svg-img {\n  background-image: url(\"data:image/svg+xml,%3Csvg%3E%0A%0A%3C%2Fsvg%3E%0A\");\n}`));\n    assert(!cssBundleContent.includes('sourceMappingURL'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline text content as url-encoded text and mime type with `data-url:*` imports","suites":["javascript"],"updatePoint":{"line":2797,"column":92,"index":104624},"line":2797,"code":"  it('should inline text content as url-encoded text and mime type with `data-url:*` imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/data-url/text.js'));\n    assert.equal((await run(b)).default, 'data:image/svg+xml,%3Csvg%20width%3D%22120%22%20height%3D%22120%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%20%20%3Cfilter%20id%3D%22blur-_.%21~%2a%22%3E%0A%20%20%20%20%3CfeGaussianBlur%20stdDeviation%3D%225%22%3E%3C%2FfeGaussianBlur%3E%0A%20%20%3C%2Ffilter%3E%0A%20%20%3Ccircle%20cx%3D%2260%22%20cy%3D%2260%22%20r%3D%2250%22%20fill%3D%22green%22%20filter%3D%22url%28%27%23blur-_.%21~%2a%27%29%22%3E%3C%2Fcircle%3E%0A%3C%2Fsvg%3E%0A');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline binary content as url-encoded base64 and mime type with `data-url:*` imports","suites":["javascript"],"updatePoint":{"line":2801,"column":96,"index":105320},"line":2801,"code":"  it('should inline binary content as url-encoded base64 and mime type with `data-url:*` imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/data-url/binary.js'));\n    ``;\n    assert((await run(b)).default.startsWith('data:image/webp;base64,UklGR'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support both pipeline and non-pipeline imports","suites":["javascript"],"updatePoint":{"line":2806,"column":59,"index":105572},"line":2806,"code":"  it('should support both pipeline and non-pipeline imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/multi-pipeline/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'esmodule-helpers.js']\n    }, {\n      name: 'index.css',\n      assets: ['style.css']\n    }, {\n      type: 'css',\n      assets: ['style.css']\n    }]);\n    assert((await run(b)).default.startsWith('.test'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect typescript style async requires in commonjs","suites":["javascript"],"updatePoint":{"line":2820,"column":63,"index":106027},"line":2820,"code":"  it('should detect typescript style async requires in commonjs', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/require-async/ts.js'));\n    assertBundles(b, [{\n      name: 'ts.js',\n      assets: ['ts.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.equal(await run(b), 2);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect typescript style async requires in commonjs with esModuleInterop flag","suites":["javascript"],"updatePoint":{"line":2830,"column":89,"index":106423},"line":2830,"code":"  it('should detect typescript style async requires in commonjs with esModuleInterop flag', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/require-async/ts-interop.js'));\n    assertBundles(b, [{\n      name: 'ts-interop.js',\n      assets: ['ts-interop.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.deepEqual(await run(b), {\n      default: 2\n    });\n    let jsBundle = b.getBundles()[0];\n    let contents = await outputFS.readFile(jsBundle.filePath, 'utf8');\n    assert(/.then\\(function\\(res\\) {\\n.*return __importStar\\(res\\)/.test(contents));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect typescript style async requires in commonjs with esModuleInterop flag and arrow functions","suites":["javascript"],"updatePoint":{"line":2845,"column":109,"index":107084},"line":2845,"code":"  it('should detect typescript style async requires in commonjs with esModuleInterop flag and arrow functions', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/require-async/ts-interop-arrow.js'));\n    assertBundles(b, [{\n      name: 'ts-interop-arrow.js',\n      assets: ['ts-interop-arrow.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.deepEqual(await run(b), {\n      default: 2\n    });\n    let jsBundle = b.getBundles()[0];\n    let contents = await outputFS.readFile(jsBundle.filePath, 'utf8');\n    assert(/.then\\(\\(res\\)=>__importStar\\(res\\)/.test(contents));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect rollup style async requires in commonjs","suites":["javascript"],"updatePoint":{"line":2860,"column":59,"index":107694},"line":2860,"code":"  it('should detect rollup style async requires in commonjs', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/require-async/rollup.js'));\n    assertBundles(b, [{\n      name: 'rollup.js',\n      assets: ['rollup.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.equal(await run(b), 2);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should only detect requires that are returned from the promise","suites":["javascript"],"updatePoint":{"line":2870,"column":68,"index":108081},"line":2870,"code":"  it('should only detect requires that are returned from the promise', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/require-async/sync.js'));\n    assertBundles(b, [{\n      name: 'sync.js',\n      assets: ['sync.js', 'async.js']\n    }]);\n    assert.equal(await run(b), 5);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should properly chain a dynamic import wrapped in a Promise.resolve()","suites":["javascript"],"updatePoint":{"line":2878,"column":75,"index":108394},"line":2878,"code":"  it('should properly chain a dynamic import wrapped in a Promise.resolve()', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/require-async/resolve-chain.js'));\n    assertBundles(b, [{\n      name: 'resolve-chain.js',\n      assets: ['resolve-chain.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.equal(await run(b), 1337);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect parcel style async requires in commonjs","suites":["javascript"],"updatePoint":{"line":2888,"column":59,"index":108796},"line":2888,"code":"  it('should detect parcel style async requires in commonjs', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/require-async/parcel.js'));\n    assertBundles(b, [{\n      name: 'parcel.js',\n      assets: ['parcel.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.equal(await run(b), 2);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect requires in commonjs with plain template literals","suites":["javascript"],"updatePoint":{"line":2898,"column":69,"index":109184},"line":2898,"code":"  it('should detect requires in commonjs with plain template literals', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/commonjs-template-literal-plain/index.js'));\n    let dist = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n    assert(dist.includes('$cPUKg$lodash = require(\"lodash\");'));\n    let add = await run(b);\n    assert.equal(add(2, 3), 5);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect requires in commonjs with plain template literals","suites":["javascript"],"updatePoint":{"line":2905,"column":69,"index":109612},"line":2905,"code":"  it(`should detect requires in commonjs with plain template literals`, async function () {\n    let b = await bundle(path.join(__dirname, '/integration/commonjs-template-literal-interpolation/index.js'));\n    let dist = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n    assert(dist.includes('const add = require(`lodash/${$8cad8166811e0063$var$fn}`);'));\n    let add = await run(b);\n    assert.equal(add(2, 3), 5);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"only updates bundle names of changed bundles for browsers","suites":["javascript"],"updatePoint":{"line":2912,"column":63,"index":110066},"line":2912,"code":"  it('only updates bundle names of changed bundles for browsers', async () => {\n    let fixtureDir = path.join(__dirname, '/integration/name-invalidation');\n    let _bundle = () => bundle(path.join(fixtureDir, 'index.js'), {\n      inputFS: overlayFS,\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false,\n        shouldOptimize: false\n      }\n    });\n    let first = await _bundle();\n    assert.equal(await (await run(first)).default, 42);\n    let bPath = path.join(fixtureDir, 'b.js');\n    await overlayFS.mkdirp(fixtureDir);\n    overlayFS.writeFile(bPath, (await overlayFS.readFile(bPath, 'utf8')).replace('42', '43'));\n    let second = await _bundle();\n    assert.equal(await (await run(second)).default, 43);\n    let getBundleNameWithPrefix = (b, prefix) => b.getBundles().map(bundle => path.basename(bundle.filePath)).find(name => name.startsWith(prefix));\n    assert.equal(getBundleNameWithPrefix(first, 'a'), getBundleNameWithPrefix(second, 'a'));\n    assert.notEqual(getBundleNameWithPrefix(first, 'b'), getBundleNameWithPrefix(second, 'b'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can load the same resource when referenced in multiple bundles","suites":["javascript"],"updatePoint":{"line":2933,"column":68,"index":111163},"line":2933,"code":"  it('can load the same resource when referenced in multiple bundles', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/same-resource-multiple-bundles/index.js'));\n    let res = await run(b);\n    assert(url.parse(await res.default()).pathname.startsWith('/resource'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can static import and dynamic import in the same bundle without creating a new bundle","suites":["javascript"],"updatePoint":{"line":2938,"column":91,"index":111486},"line":2938,"code":"  it('can static import and dynamic import in the same bundle without creating a new bundle', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/sync-async/same-bundle.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'same-bundle.js',\n      assets: ['same-bundle.js', 'get-dep.js', 'get-dep-2.js', 'dep.js', 'esmodule-helpers.js']\n    }]);\n    assert.deepEqual(await (await run(b)).default, [42, 42, 42]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"async dependency can be resolved internally and externally from two different bundles","suites":["javascript"],"updatePoint":{"line":2951,"column":91,"index":112020},"line":2951,"code":"  it('async dependency can be resolved internally and externally from two different bundles', async () => {\n    let b = await bundle(['entry1.js', 'entry2.js'].map(entry => path.join(__dirname, '/integration/async-dep-internal-external/', entry)), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      assets: ['async.js']\n    }, {\n      name: 'entry1.js',\n      assets: ['child.js', 'entry1.js', 'async.js']\n    }, {\n      name: 'entry2.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'child.js', 'entry2.js', 'js-loader.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can static import and dynamic import in the same bundle ancestry without creating a new bundle","suites":["javascript"],"updatePoint":{"line":2968,"column":100,"index":112681},"line":2968,"code":"  it('can static import and dynamic import in the same bundle ancestry without creating a new bundle', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/sync-async/same-ancestry.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'same-ancestry.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'dep.js', 'js-loader.js', 'same-ancestry.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['get-dep.js']\n    }]);\n    assert.deepEqual(await (await run(b)).default, [42, 42]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can static import and dynamic import in the same bundle when another bundle requires async","suites":["javascript"],"updatePoint":{"line":2983,"column":96,"index":113303},"line":2983,"code":"  it('can static import and dynamic import in the same bundle when another bundle requires async', async () => {\n    let b = await bundle(['same-bundle.js', 'get-dep.js'].map(entry => path.join(__dirname, '/integration/sync-async/', entry)), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      assets: ['dep.js']\n    }, {\n      name: 'same-bundle.js',\n      assets: ['same-bundle.js', 'get-dep.js', 'get-dep-2.js', 'dep.js', 'esmodule-helpers.js']\n    }, {\n      name: 'get-dep.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'get-dep.js', 'js-loader.js', 'esmodule-helpers.js']\n    }]);\n    let bundles = b.getBundles();\n    let sameBundle = bundles.find(b => b.name === 'same-bundle.js');\n    let getDep = bundles.find(b => b.name === 'get-dep.js');\n    assert.deepEqual(await (await runBundle(b, sameBundle)).default, [42, 42, 42]);\n    assert.deepEqual(await (await runBundle(b, getDep)).default, 42);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can share dependencies between a shared bundle and its sibling's descendants","suites":["javascript"],"updatePoint":{"line":3005,"column":82,"index":114314},"line":3005,"code":"  it(\"can share dependencies between a shared bundle and its sibling's descendants\", async () => {\n    let b = await bundle(path.join(__dirname, '/integration/shared-exports-for-sibling-descendant/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      assets: ['wraps.js', 'lodash.js']\n    }, {\n      assets: ['a.js']\n    }, {\n      assets: ['child.js']\n    }, {\n      assets: ['grandchild.js']\n    }, {\n      assets: ['b.js']\n    }, {\n      name: 'index.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'index.js', 'js-loader.js', 'esmodule-helpers.js']\n    }]);\n    assert.deepEqual(await (await run(b)).default, [3, 5]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can run an entry bundle whose entry asset is present in another bundle","suites":["javascript"],"updatePoint":{"line":3028,"column":76,"index":115059},"line":3028,"code":"  it('can run an entry bundle whose entry asset is present in another bundle', async () => {\n    let b = await bundle(['index.js', 'value.js'].map(basename => path.join(__dirname, '/integration/sync-entry-shared', basename)));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'esmodule-helpers.js']\n    }, {\n      name: 'value.js',\n      assets: ['value.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.equal(await (await run(b)).default, 43);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can run an async bundle whose entry asset is present in another bundle","suites":["javascript"],"updatePoint":{"line":3041,"column":76,"index":115621},"line":3041,"code":"  it('can run an async bundle whose entry asset is present in another bundle', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/async-entry-shared/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['value.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.deepEqual(await (await run(b)).default, [42, 43]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should display a codeframe on a Terser parse error","suites":["javascript"],"updatePoint":{"line":3053,"column":56,"index":116084},"line":3053,"code":"  it('should display a codeframe on a Terser parse error', async () => {\n    let fixture = path.join(__dirname, 'integration/terser-codeframe/index.js');\n    let code = await inputFS.readFileSync(fixture, 'utf8');\n    await assert.rejects(() => bundle(fixture, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: '`let` cannot be used as an identifier in strict mode',\n        origin: '@parcel/optimizer-swc',\n        codeFrames: [{\n          filePath: undefined,\n          language: 'js',\n          code,\n          codeHighlights: [{\n            start: {\n              column: 1,\n              line: 1\n            },\n            end: {\n              column: 1,\n              line: 1\n            }\n          }]\n        }]\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can run an async bundle that depends on a nonentry asset in a sibling","suites":["javascript"],"updatePoint":{"line":3083,"column":75,"index":116940},"line":3083,"code":"  it('can run an async bundle that depends on a nonentry asset in a sibling', async () => {\n    let b = await bundle(['index.js', 'other-entry.js'].map(basename => path.join(__dirname, '/integration/async-entry-shared-sibling', basename)));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'esmodule-helpers.js']\n    }, {\n      name: 'other-entry.js',\n      assets: ['other-entry.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['a.js', 'value.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['b.js']\n    }]);\n    assert.deepEqual(await (await run(b)).default, 43);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can share sibling bundles reachable from a common dependency","suites":["javascript"],"updatePoint":{"line":3098,"column":66,"index":117614},"line":3098,"code":"  it('can share sibling bundles reachable from a common dependency', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/shared-sibling-common-dependency/index.js'));\n    let bundles = b.getBundles();\n    let asyncJsBundles = bundles.filter(b => !b.needsStableName && b.type === 'js');\n    assert.equal(asyncJsBundles.length, 2);\n\n    // Every bundlegroup with an async js bundle should have the corresponding css\n    for (let bundle of asyncJsBundles) {\n      for (let bundleGroup of b.getBundleGroupsContainingBundle(bundle)) {\n        let bundlesInGroup = b.getBundlesInBundleGroup(bundleGroup);\n        assert(bundlesInGroup.find(s => s.type === 'css'));\n      }\n    }\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw a diagnostic for unkown pipelines","suites":["javascript"],"updatePoint":{"line":3112,"column":52,"index":118301},"line":3112,"code":"  it('should throw a diagnostic for unkown pipelines', async function () {\n    let fixture = path.join(__dirname, 'integration/pipeline-unknown/a.js');\n    let code = await inputFS.readFileSync(fixture, 'utf8');\n    await assert.rejects(() => bundle(fixture), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: \"Failed to resolve 'strange-pipeline:./b.js' from './a.js'\",\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: fixture,\n          code,\n          codeHighlights: [{\n            start: {\n              column: 19,\n              line: 1\n            },\n            end: {\n              column: 43,\n              line: 1\n            }\n          }]\n        }]\n      }, {\n        message: \"Unknown url scheme or pipeline 'strange-pipeline:'\",\n        origin: '@parcel/resolver-default'\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can create a bundle starting with a dot","suites":["javascript"],"updatePoint":{"line":3140,"column":45,"index":119148},"line":3140,"code":"  it('can create a bundle starting with a dot', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dotfile-bundle/index.js'));\n    assertBundles(b, [{\n      name: '.output.js',\n      assets: ['index.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not automatically name bundle files starting with a dot","suites":["javascript"],"updatePoint":{"line":3147,"column":68,"index":119419},"line":3147,"code":"  it('should not automatically name bundle files starting with a dot', async function () {\n    await bundle(path.join(__dirname, '/integration/bundle-naming/.invisible/index.js'));\n    let bundleFiles = await outputFS.readdir(distDir);\n    let renamedSomeFiles = bundleFiles.some(currFile => currFile.startsWith('invisible.'));\n    let namedWithDot = bundleFiles.some(currFile => currFile.startsWith('.invisible.'));\n    assert.equal(renamedSomeFiles, true);\n    assert.equal(namedWithDot, false);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support duplicate re-exports without scope hoisting","suites":["javascript"],"updatePoint":{"line":3155,"column":64,"index":119919},"line":3155,"code":"  it('should support duplicate re-exports without scope hoisting', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-duplicate-re-exports/index.js'));\n    let res = await run(b);\n    assert.equal(res.a, 'a');\n    assert.equal(res.b, 'b');\n    assert.equal(typeof res.c, 'function');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should prioritize named exports before re-exports withput scope hoisting (before)","suites":["javascript"],"updatePoint":{"line":3162,"column":87,"index":120263},"line":3162,"code":"  it('should prioritize named exports before re-exports withput scope hoisting (before)', async () => {\n    let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/re-export-priority/entry-a.mjs'));\n    let res = await run(b, null, {\n      require: false\n    });\n    assert.equal(res.output, 2);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should prioritize named exports before re-exports without scope hoisting (after)","suites":["javascript"],"updatePoint":{"line":3169,"column":86,"index":120582},"line":3169,"code":"  it('should prioritize named exports before re-exports without scope hoisting (after)', async () => {\n    let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/re-export-priority/entry-b.mjs'));\n    let res = await run(b, null, {\n      require: false\n    });\n    assert.equal(res.output, 2);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should exclude default from export all declaration","suites":["javascript"],"updatePoint":{"line":3176,"column":56,"index":120871},"line":3176,"code":"  it('should exclude default from export all declaration', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-export-all/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res, {\n      a: 4\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not use arrow functions for reexport declarations unless supported","suites":["javascript"],"updatePoint":{"line":3183,"column":79,"index":121140},"line":3183,"code":"  it('should not use arrow functions for reexport declarations unless supported', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-export-arrow-support/index.js'));\n    let content = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!content.includes('=>'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support import namespace declarations of other ES modules","suites":["javascript"],"updatePoint":{"line":3188,"column":70,"index":121451},"line":3188,"code":"  it('should support import namespace declarations of other ES modules', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-namespace/a.js'));\n    let res = await run(b);\n    assert.deepEqual(res, {\n      a: 4,\n      default: 1\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support import namespace declarations of class from CJS","suites":["javascript"],"updatePoint":{"line":3196,"column":68,"index":121729},"line":3196,"code":"  it('should support import namespace declarations of class from CJS', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-namespace/b.js'));\n    let res = await run(b);\n    assert.equal(typeof res, 'function');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support import namespace declarations of object from CJS","suites":["javascript"],"updatePoint":{"line":3201,"column":69,"index":121985},"line":3201,"code":"  it('should support import namespace declarations of object from CJS', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-namespace/c.js'));\n    let res = await run(b);\n    assert.deepEqual(res, {\n      foo: 2,\n      default: 3\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support export namespace declarations","suites":["javascript"],"updatePoint":{"line":3209,"column":50,"index":122247},"line":3209,"code":"  it('should support export namespace declarations', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-export-namespace/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res, {\n      ns: {\n        a: 4,\n        default: 1\n      }\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support export default declarations","suites":["javascript"],"updatePoint":{"line":3219,"column":48,"index":122533},"line":3219,"code":"  it('should support export default declarations', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-export-default/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res, {\n      other: 1\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with many different types of exports","suites":["javascript"],"updatePoint":{"line":3226,"column":54,"index":122785},"line":3226,"code":"  it('should work with many different types of exports', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-export-many/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res, {\n      foo: 'foo',\n      bar: 'bar',\n      default: 'baz',\n      boo: 'boo',\n      foobar: 'foobar',\n      type1: 'type1',\n      type2: 'type2'\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly export functions","suites":["javascript"],"updatePoint":{"line":3239,"column":39,"index":123147},"line":3239,"code":"  it('should correctly export functions', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-export-functions/index.js'));\n    let res = await run(b);\n    assert.deepEqual(Object.keys(res), ['foo', 'bar']);\n    assert.strictEqual(res.foo('test'), 'foo:test');\n    assert.strictEqual(res.bar('test'), 'bar:test');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle exports of imports","suites":["javascript"],"updatePoint":{"line":3246,"column":38,"index":123496},"line":3246,"code":"  it('should handle exports of imports', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-export-import/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res, {\n      other: 2\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle simultaneous import and reexports of the same identifier","suites":["javascript"],"updatePoint":{"line":3253,"column":76,"index":123769},"line":3253,"code":"  it('should handle simultaneous import and reexports of the same identifier', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-export-import-same/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res, {\n      foo: '123',\n      bar: '1234'\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate a unique variable name for imports","suites":["javascript"],"updatePoint":{"line":3261,"column":56,"index":124048},"line":3261,"code":"  it('should generate a unique variable name for imports', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-shadow/index.js'));\n    let res = await run(b);\n    assert.strictEqual(res.baz(), 'foo');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not replace identifier with a var declaration inside a for loop","suites":["javascript"],"updatePoint":{"line":3266,"column":76,"index":124312},"line":3266,"code":"  it('should not replace identifier with a var declaration inside a for loop', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-shadow-for-var/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res.baz(), [0, 1, 2, 3]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should replace an imported identifier with function locals of the same name","suites":["javascript"],"updatePoint":{"line":3271,"column":81,"index":124594},"line":3271,"code":"  it('should replace an imported identifier with function locals of the same name', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-shadow-func-var/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res.default, 123);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should replace imported values in member expressions","suites":["javascript"],"updatePoint":{"line":3276,"column":58,"index":124847},"line":3276,"code":"  it('should replace imported values in member expressions', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-member/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res.default, ['a', 'b', 'bar']);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should retain the correct dependency order between import and reexports","suites":["javascript"],"updatePoint":{"line":3281,"column":77,"index":125124},"line":3281,"code":"  it('should retain the correct dependency order between import and reexports', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-reexport-dep-order/index.js'));\n    let calls = [];\n    await run(b, {\n      sideEffect(v) {\n        calls.push(v);\n      }\n    });\n    assert.deepEqual(calls, ['a', 'b', 'c']);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not freeze live default imports","suites":["javascript"],"updatePoint":{"line":3291,"column":44,"index":125444},"line":3291,"code":"  it('should not freeze live default imports', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-default-live/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res.default, [123, 789]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not rewrite this in arrow function class properties","suites":["javascript"],"updatePoint":{"line":3296,"column":64,"index":125707},"line":3296,"code":"  it('should not rewrite this in arrow function class properties', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-class-this-esm/a.js'));\n    let res = await run(b);\n    assert.deepEqual(res.default, 'x: 123');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should call named imports without this context","suites":["javascript"],"updatePoint":{"line":3301,"column":52,"index":125947},"line":3301,"code":"  it('should call named imports without this context', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-this/index.js'));\n    let res = await run(b, {\n      output: null\n    }, {\n      strict: true\n    });\n    assert.deepEqual(res.default, {\n      unwrappedNamed: [true, false],\n      unwrappedDefault: [true, false],\n      unwrappedNamespace: [false, true],\n      wrappedNamed: [true, false],\n      wrappedDefault: [true, false],\n      wrappedNamespace: [false, true]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should only replace free references to require","suites":["javascript"],"updatePoint":{"line":3317,"column":52,"index":126470},"line":3317,"code":"  it('should only replace free references to require', async () => {\n    let b = await bundle(path.join(__dirname, 'integration/js-require-free/index.js'));\n    let output;\n    await run(b, {\n      output(v) {\n        output = v;\n      }\n    });\n    assert.strictEqual(output, 'a');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should only replace free references to require with scope hoisting","suites":["javascript"],"updatePoint":{"line":3327,"column":72,"index":126779},"line":3327,"code":"  it('should only replace free references to require with scope hoisting', async () => {\n    let b = await bundle(path.join(__dirname, 'integration/js-require-free/index.js'), {\n      mode: 'production'\n    });\n    let output;\n    await run(b, {\n      output(v) {\n        output = v;\n      }\n    });\n    assert.strictEqual(output, 'a');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support import and non-top-level require of same asset from different assets","suites":["javascript"],"updatePoint":{"line":3339,"column":89,"index":127139},"line":3339,"code":"  it('should support import and non-top-level require of same asset from different assets', async () => {\n    let b = await bundle(path.join(__dirname, 'integration/js-require-import-different/index.js'));\n    let {\n      output\n    } = await run(b, null, {\n      require: false\n    });\n    assert.deepEqual(output, [123, {\n      HooksContext: 123\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support import and non-top-level require of same asset from different assets with scope hoisting","suites":["javascript"],"updatePoint":{"line":3350,"column":109,"index":127522},"line":3350,"code":"  it('should support import and non-top-level require of same asset from different assets with scope hoisting', async () => {\n    let b = await bundle(path.join(__dirname, 'integration/js-require-import-different/index.js'), {\n      mode: 'production'\n    });\n    let {\n      output\n    } = await run(b, null, {\n      require: false\n    });\n    assert.deepEqual(output, [123, {\n      HooksContext: 123\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support runtime module deduplication","suites":["javascript"],"updatePoint":{"line":3363,"column":49,"index":127879},"line":3363,"code":"  it('should support runtime module deduplication', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-runtime-dedup/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async1.js', 'shared.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['async2.js', 'shared.js', 'esmodule-helpers.js']\n    }]);\n    let res = await run(b);\n    assert.equal(await res, true);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support runtime module deduplication with scope hoisting","suites":["javascript"],"updatePoint":{"line":3376,"column":69,"index":128410},"line":3376,"code":"  it('should support runtime module deduplication with scope hoisting', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-runtime-dedup/index.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'bundle-manifest.js']\n    }, {\n      assets: ['async1.js', 'shared.js']\n    }, {\n      assets: ['async2.js', 'shared.js']\n    }]);\n    let res = await run(b);\n    assert.equal(await res, true);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remap locations in diagnostics using the input source map","suites":["javascript"],"updatePoint":{"line":3391,"column":70,"index":128952},"line":3391,"code":"  it('should remap locations in diagnostics using the input source map', async () => {\n    let fixture = path.join(__dirname, 'integration/diagnostic-sourcemap/index.js');\n    let code = await inputFS.readFileSync(fixture, 'utf8');\n    await assert.rejects(() => bundle(fixture, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: \"Failed to resolve 'foo' from './index.js'\",\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: fixture,\n          code,\n          codeHighlights: [{\n            start: {\n              line: 11,\n              column: 17\n            },\n            end: {\n              line: 11,\n              column: 21\n            }\n          }]\n        }]\n      }, {\n        message: \"Cannot find module 'foo'\",\n        origin: '@parcel/resolver-default',\n        hints: []\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should reuse a bundle when its main asset (aka bundleroot) is imported sychronously","suites":["javascript"],"updatePoint":{"line":3424,"column":89,"index":129900},"line":3424,"code":"  it('should reuse a bundle when its main asset (aka bundleroot) is imported sychronously', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/shared-bundle-single-source/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'css-loader.js', 'esmodule-helpers.js', 'js-loader.js', 'bundle-manifest.js']\n    }, {\n      assets: ['bar.js']\n    }, {\n      assets: ['a.js', 'b.js', 'foo.js']\n    }, {\n      assets: ['styles.css']\n    }, {\n      assets: ['local.html']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on undeclared external dependencies for libraries","suites":["javascript"],"updatePoint":{"line":3444,"column":68,"index":130559},"line":3444,"code":"  it('should error on undeclared external dependencies for libraries', async function () {\n    let fixture = path.join(__dirname, 'integration/undeclared-external/index.js');\n    let pkg = path.join(__dirname, 'integration/undeclared-external/package.json');\n    await assert.rejects(() => bundle(fixture, {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: \"Failed to resolve 'lodash' from './index.js'\",\n        origin: '@parcel/core',\n        codeFrames: [{\n          code: await inputFS.readFile(fixture, 'utf8'),\n          filePath: fixture,\n          codeHighlights: [{\n            start: {\n              line: 1,\n              column: 19\n            },\n            end: {\n              line: 1,\n              column: 26\n            }\n          }]\n        }]\n      }, {\n        message: 'External dependency \"lodash\" is not declared in package.json.',\n        origin: '@parcel/resolver-default',\n        codeFrames: [{\n          code: await inputFS.readFile(pkg, 'utf8'),\n          filePath: pkg,\n          language: 'json',\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 5,\n              column: 3\n            },\n            end: {\n              line: 5,\n              column: 16\n            }\n          }]\n        }],\n        hints: ['Add \"lodash\" as a dependency.']\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on undeclared helpers dependency for libraries","suites":["javascript"],"updatePoint":{"line":3494,"column":65,"index":132028},"line":3494,"code":"  it('should error on undeclared helpers dependency for libraries', async function () {\n    let fixture = path.join(__dirname, 'integration/undeclared-external/helpers.js');\n    let pkg = path.join(__dirname, 'integration/undeclared-external/package.json');\n    await assert.rejects(() => bundle(fixture, {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: md`Failed to resolve '${'@swc/helpers/cjs/_class_call_check.cjs'}' from '${normalizePath(require.resolve('@parcel/transformer-js/src/JSTransformer.js'))}'`,\n        origin: '@parcel/core',\n        codeFrames: [{\n          code: await inputFS.readFile(fixture, 'utf8'),\n          filePath: fixture,\n          codeHighlights: [{\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }]\n        }]\n      }, {\n        message: 'External dependency \"@swc/helpers\" is not declared in package.json.',\n        origin: '@parcel/resolver-default',\n        codeFrames: [{\n          code: await inputFS.readFile(pkg, 'utf8'),\n          filePath: pkg,\n          language: 'json',\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 5,\n              column: 3\n            },\n            end: {\n              line: 5,\n              column: 16\n            }\n          }]\n        }],\n        hints: ['Add \"@swc/helpers\" as a dependency.']\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on mismatched helpers version for libraries","suites":["javascript"],"updatePoint":{"line":3544,"column":62,"index":133615},"line":3544,"code":"  it('should error on mismatched helpers version for libraries', async function () {\n    let fixture = path.join(__dirname, 'integration/undeclared-external/helpers.js');\n    let pkg = path.join(__dirname, 'integration/undeclared-external/package.json');\n    let pkgContents = JSON.stringify({\n      ...JSON.parse(await overlayFS.readFile(pkg, 'utf8')),\n      dependencies: {\n        '@swc/helpers': '^0.3.0'\n      }\n    }, false, 2);\n    await overlayFS.mkdirp(path.dirname(pkg));\n    await overlayFS.writeFile(pkg, pkgContents);\n    await assert.rejects(() => bundle(fixture, {\n      mode: 'production',\n      inputFS: overlayFS,\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: md`Failed to resolve '${'@swc/helpers/cjs/_class_call_check.cjs'}' from '${normalizePath(require.resolve('@parcel/transformer-js/src/JSTransformer.js'))}'`,\n        origin: '@parcel/core',\n        codeFrames: [{\n          code: await inputFS.readFile(fixture, 'utf8'),\n          filePath: fixture,\n          codeHighlights: [{\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }]\n        }]\n      }, {\n        message: 'External dependency \"@swc/helpers\" does not satisfy required semver range \"^0.5.0\".',\n        origin: '@parcel/resolver-default',\n        codeFrames: [{\n          code: pkgContents,\n          filePath: pkg,\n          language: 'json',\n          codeHighlights: [{\n            message: 'Found this conflicting requirement.',\n            start: {\n              line: 6,\n              column: 21\n            },\n            end: {\n              line: 6,\n              column: 28\n            }\n          }]\n        }],\n        hints: ['Update the dependency on \"@swc/helpers\" to satisfy \"^0.5.0\".']\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports both static and dynamic imports to the same specifier in the same file","suites":["javascript","multiple import types"],"updatePoint":{"line":3604,"column":87,"index":135625},"line":3604,"code":"    it('supports both static and dynamic imports to the same specifier in the same file', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/static-dynamic.js'));\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['static-dynamic.js', 'other.js', 'esmodule-helpers.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.Foo, 'function');\n      assert.equal(typeof res.LazyFoo, 'object');\n      assert.equal(res.Foo, await res.LazyFoo);\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports both static and dynamic imports to the same specifier in the same file with scope hoisting","suites":["javascript","multiple import types"],"updatePoint":{"line":3615,"column":107,"index":136174},"line":3615,"code":"    it('supports both static and dynamic imports to the same specifier in the same file with scope hoisting', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/static-dynamic.js'), {\n        defaultTargetOptions: {\n          outputFormat: 'esmodule',\n          isLibrary: true,\n          shouldScopeHoist: true\n        }\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['static-dynamic.js', 'other.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.Foo, 'function');\n      assert.equal(typeof res.LazyFoo, 'object');\n      assert.equal(res.Foo, await res.LazyFoo);\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports static, dynamic, and url to the same specifier in the same file","suites":["javascript","multiple import types"],"updatePoint":{"line":3632,"column":80,"index":136822},"line":3632,"code":"    it('supports static, dynamic, and url to the same specifier in the same file', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/static-dynamic-url.js'));\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['static-dynamic-url.js', 'other.js', 'esmodule-helpers.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n      }, {\n        type: 'js',\n        assets: ['other.js', 'esmodule-helpers.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.Foo, 'function');\n      assert.equal(typeof res.LazyFoo, 'object');\n      assert.equal(res.Foo, await res.LazyFoo);\n      assert.equal(res.url, 'http://localhost/' + path.basename(b.getBundles()[1].filePath));\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports static, dynamic, and url to the same specifier in the same file with scope hoisting","suites":["javascript","multiple import types"],"updatePoint":{"line":3647,"column":100,"index":137600},"line":3647,"code":"    it('supports static, dynamic, and url to the same specifier in the same file with scope hoisting', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/static-dynamic-url.js'), {\n        defaultTargetOptions: {\n          outputFormat: 'esmodule',\n          isLibrary: true,\n          shouldScopeHoist: true\n        }\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['static-dynamic-url.js', 'other.js']\n      }, {\n        type: 'js',\n        assets: ['other.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.Foo, 'function');\n      assert.equal(typeof res.LazyFoo, 'object');\n      assert.equal(res.Foo, await res.LazyFoo);\n      assert.equal(res.url, 'http://localhost/' + path.basename(b.getBundles()[1].filePath));\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports dynamic import and url to the same specifier in the same file","suites":["javascript","multiple import types"],"updatePoint":{"line":3668,"column":78,"index":138408},"line":3668,"code":"    it('supports dynamic import and url to the same specifier in the same file', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/dynamic-url.js'));\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['dynamic-url.js', 'esmodule-helpers.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n      }, {\n        type: 'js',\n        assets: ['other.js', 'esmodule-helpers.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.lazy, 'object');\n      assert.equal(typeof (await res.lazy), 'function');\n      assert.equal(res.url, 'http://localhost/' + path.basename(b.getBundles()[1].filePath));\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports dynamic import and url to the same specifier in the same file with scope hoisting","suites":["javascript","multiple import types"],"updatePoint":{"line":3682,"column":98,"index":139116},"line":3682,"code":"    it('supports dynamic import and url to the same specifier in the same file with scope hoisting', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/dynamic-url.js'), {\n        defaultTargetOptions: {\n          outputFormat: 'esmodule',\n          isLibrary: true,\n          shouldScopeHoist: true\n        }\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['dynamic-url.js']\n      }, {\n        type: 'js',\n        assets: ['other.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.lazy, 'object');\n      assert.equal(typeof (await res.lazy), 'function');\n      assert.equal(res.url, 'http://localhost/' + path.basename(b.getBundles()[1].filePath));\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports static import and inline bundle for the same asset","suites":["javascript","multiple import types"],"updatePoint":{"line":3702,"column":67,"index":139845},"line":3702,"code":"    it('supports static import and inline bundle for the same asset', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/static-inline.js'));\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['static-inline.js', 'other.js', 'esmodule-helpers.js']\n      }, {\n        type: 'js',\n        assets: ['other.js', 'esmodule-helpers.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.Foo, 'function');\n      assert.equal(typeof res.text, 'string');\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports static import and inline bundle for the same asset with scope hoisting","suites":["javascript","multiple import types"],"updatePoint":{"line":3715,"column":87,"index":140404},"line":3715,"code":"    it('supports static import and inline bundle for the same asset with scope hoisting', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/static-inline.js'), {\n        defaultTargetOptions: {\n          outputFormat: 'esmodule',\n          isLibrary: true,\n          shouldScopeHoist: true\n        }\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['static-inline.js', 'other.js']\n      }, {\n        type: 'js',\n        assets: ['other.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.Foo, 'function');\n      assert.equal(typeof res.text, 'string');\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports dynamic import and inline bundle for the same asset","suites":["javascript","multiple import types"],"updatePoint":{"line":3734,"column":68,"index":141047},"line":3734,"code":"    it('supports dynamic import and inline bundle for the same asset', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/dynamic-inline.js'));\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['dynamic-inline.js', 'esmodule-helpers.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n      }, {\n        type: 'js',\n        assets: ['other.js']\n      }, {\n        type: 'js',\n        assets: ['other.js', 'esmodule-helpers.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.lazy, 'object');\n      assert.equal(typeof (await res.lazy), 'function');\n      assert.equal(typeof res.text, 'string');\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports dynamic import and inline bundle for the same asset with scope hoisting","suites":["javascript","multiple import types"],"updatePoint":{"line":3751,"column":88,"index":141764},"line":3751,"code":"    it('supports dynamic import and inline bundle for the same asset with scope hoisting', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/dynamic-inline.js'), {\n        defaultTargetOptions: {\n          outputFormat: 'esmodule',\n          isLibrary: true,\n          shouldScopeHoist: true\n        }\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['dynamic-inline.js']\n      }, {\n        type: 'js',\n        assets: ['other.js']\n      }, {\n        type: 'js',\n        assets: ['other.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.lazy, 'object');\n      assert.equal(typeof (await res.lazy), 'function');\n      assert.equal(typeof res.text, 'string');\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should avoid creating a bundle for lazy dependencies already available in a shared bundle","suites":["javascript","multiple import types"],"updatePoint":{"line":3775,"column":95,"index":142546},"line":3775,"code":"  it('should avoid creating a bundle for lazy dependencies already available in a shared bundle', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/shared-bundle-internalization/index.mjs'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assert.deepEqual(await (await run(b)).default, [42, 42]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support standalone import.meta","suites":["javascript","multiple import types"],"updatePoint":{"line":3784,"column":43,"index":142888},"line":3784,"code":"  it('should support standalone import.meta', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/import-meta/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res.default, {\n      meta: {\n        url: 'file:///integration/import-meta/index.js'\n      },\n      url: 'file:///integration/import-meta/index.js',\n      equal: true\n    });\n    assert.equal(Object.getPrototypeOf(res.default.meta), null);\n    assert.equal(Object.isExtensible(res.default.meta), true);\n    assert.deepEqual(Object.getOwnPropertyDescriptors(res.default.meta), {\n      url: {\n        writable: true,\n        configurable: true,\n        enumerable: true,\n        value: 'file:///integration/import-meta/index.js'\n      }\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing async bundles from bundles with different dist paths","suites":["javascript","multiple import types"],"updatePoint":{"line":3805,"column":83,"index":143676},"line":3805,"code":"  it('should support importing async bundles from bundles with different dist paths', async function () {\n    let bundleGraph = await bundle(['bar/entry/entry-a.js', 'foo/entry-b.js'].map(f => path.join(__dirname, 'integration/differing-bundle-urls', f)), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    assertBundles(bundleGraph, [{\n      name: 'entry-a.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'entry-a.js', 'js-loader.js']\n    }, {\n      name: 'entry-b.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'entry-b.js', 'js-loader.js']\n    }, {\n      name: /deep\\.[a-f0-9]+\\.js/,\n      assets: ['deep.js']\n    }, {\n      name: /common\\.[a-f0-9]+\\.js/,\n      assets: ['index.js']\n    }]);\n    let [a, b] = bundleGraph.getBundles().filter(b => b.needsStableName);\n    let calls = [];\n    let bundles = [[await outputFS.readFile(a.filePath, 'utf8'), a], [await outputFS.readFile(b.filePath, 'utf8'), b]];\n    await runBundles(bundleGraph, a, bundles, {\n      sideEffect: v => {\n        calls.push(v);\n      }\n    });\n    assert.deepEqual(calls, ['common', 'deep']);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports deferring unused ESM imports with sideEffects: false","suites":["javascript","multiple import types"],"updatePoint":{"line":3835,"column":67,"index":144852},"line":3835,"code":"  it('supports deferring unused ESM imports with sideEffects: false', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/side-effects-false/import.js'));\n    let content = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!content.includes('returned from bar'));\n    let called = false;\n    let output = await run(b, {\n      sideEffect() {\n        called = true;\n      }\n    });\n    assert(!called, 'side effect called');\n    assert.strictEqual(output.default, 4);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports ESM imports and requires with sideEffects: false","suites":["javascript","multiple import types"],"updatePoint":{"line":3848,"column":63,"index":145370},"line":3848,"code":"  it('supports ESM imports and requires with sideEffects: false', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/side-effects-false/import-require.js'));\n    let output = await run(b, {\n      sideEffect() {}\n    });\n    assert.strictEqual(output.default, '4returned from bar');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not affect ESM import order","suites":["javascript","multiple import types"],"updatePoint":{"line":3855,"column":40,"index":145664},"line":3855,"code":"  it('should not affect ESM import order', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/js-import-initialization/a.mjs'));\n    await assert.rejects(run(b), new ReferenceError(\"Cannot access 'foo' before initialization\"));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not affect ESM import order with scope hoisting","suites":["javascript","multiple import types"],"updatePoint":{"line":3859,"column":60,"index":145949},"line":3859,"code":"  it('should not affect ESM import order with scope hoisting', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/js-import-initialization/a.mjs'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    await assert.rejects(run(b), /^ReferenceError: Cannot access '(.+)' before initialization$/);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce working output with both scope hoisting and non scope hoisting targets","suites":["javascript","multiple import types"],"updatePoint":{"line":3867,"column":91,"index":146342},"line":3867,"code":"  it('should produce working output with both scope hoisting and non scope hoisting targets', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/re-export-no-scope-hoist'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let bundles = b.getBundles();\n    let o1, o2;\n    await runBundle(b, bundles[0], {\n      output: (...o) => o1 = o\n    });\n    await runBundle(b, bundles[1], {\n      output: (...o) => o2 = o\n    });\n    assert.deepEqual(o1, ['UIIcon', 'Icon']);\n    assert.deepEqual(o2, ['UIIcon', 'Icon']);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not deduplicate an asset if it will become unreachable","suites":["javascript","multiple import types"],"updatePoint":{"line":3884,"column":67,"index":146899},"line":3884,"code":"  it('should not deduplicate an asset if it will become unreachable', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/sibling-deduplicate-unreachable/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    let res = await run(b);\n    assert.equal(await res.default, 'target');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports excluding unused CSS imports","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":3904,"column":49,"index":147611},"line":3904,"code":"        it('supports excluding unused CSS imports', async function () {\n          let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-css/index.html'), options);\n          assertBundles(b, [{\n            name: 'index.html',\n            assets: ['index.html']\n          }, {\n            type: 'js',\n            assets: ['index.js', 'b1.js']\n          }, {\n            type: 'css',\n            assets: ['b1.css']\n          }]);\n          let calls = [];\n          let res = await run(b, {\n            output: null,\n            sideEffect: caller => {\n              calls.push(caller);\n            }\n          }, {\n            require: false\n          });\n          assert.deepEqual(calls, ['b1']);\n          assert.deepEqual(res.output, 2);\n          let css = await outputFS.readFile(b.getBundles().find(bundle => bundle.type === 'css').filePath, 'utf8');\n          assert(!css.includes('.b2'));\n        });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"doesn't create new bundles for dynamic imports in excluded assets","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":3930,"column":77,"index":148582},"line":3930,"code":"        it(\"doesn't create new bundles for dynamic imports in excluded assets\", async function () {\n          let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-no-new-bundle/index.html'), options);\n          assertBundles(b, [{\n            name: 'index.html',\n            assets: ['index.html']\n          }, {\n            type: 'js',\n            assets: ['index.js', 'b1.js']\n          }]);\n          let calls = [];\n          let res = await run(b, {\n            output: null,\n            sideEffect: caller => {\n              calls.push(caller);\n            }\n          }, {\n            require: false\n          });\n          assert.deepEqual(calls, ['b1']);\n          assert.deepEqual(res.output, 2);\n        });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports deferring unused ES6 re-exports (namespace used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":3952,"column":67,"index":149334},"line":3952,"code":"      it('supports deferring unused ES6 re-exports (namespace used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports/a.js'), options);\n        assertBundles(b, [{\n          type: 'js',\n          assets: usesSymbolPropagation ? ['a.js', 'message1.js'] : ['a.js', 'esmodule-helpers.js', 'index.js', 'message1.js']\n        }]);\n        if (usesSymbolPropagation) {\n          // TODO this only excluded, but should be deferred.\n          assert(!findAsset(b, 'message3.js'));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['message1'] : ['message1', 'index']);\n        assert.deepEqual(res.output, 'Message 1');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports deferring an unused ES6 re-export (wildcard, empty, unused)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":3973,"column":78,"index":150243},"line":3973,"code":"      it('supports deferring an unused ES6 re-export (wildcard, empty, unused)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-all-empty/a.js'), options);\n        if (usesSymbolPropagation) {\n          assertDependencyWasExcluded(b, 'index.js', './empty.js');\n        }\n        assert.deepEqual((await run(b, null, {\n          require: false\n        })).output, 123);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports deferring unused ES6 re-exports (reexport named used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":3982,"column":72,"index":150696},"line":3982,"code":"      it('supports deferring unused ES6 re-exports (reexport named used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports/b.js'), options);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'message1.js'));\n          assert(!findAsset(b, 'message3.js'));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['message2'] : ['message2', 'index']);\n        assert.deepEqual(res.output, 'Message 2');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports deferring unused ES6 re-exports (namespace rename used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":3999,"column":74,"index":151397},"line":3999,"code":"      it('supports deferring unused ES6 re-exports (namespace rename used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports/c.js'), options);\n        assertBundles(b, [{\n          type: 'js',\n          assets: usesSymbolPropagation ? ['c.js', 'message3.js'] : ['c.js', 'esmodule-helpers.js', 'index.js', 'message3.js']\n        }]);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'message1.js'));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['message3'] : ['message3', 'index']);\n        assert.deepEqual(res.output, {\n          default: 'Message 3'\n        });\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports deferring unused ES6 re-exports (direct export used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4021,"column":71,"index":152268},"line":4021,"code":"      it('supports deferring unused ES6 re-exports (direct export used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports/d.js'), options);\n        assertDependencyWasExcluded(b, 'index.js', './message2.js');\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'message1.js'));\n          assert(!findAsset(b, 'message3.js'));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, ['index']);\n        assert.deepEqual(res.output, 'Message 4');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports chained ES6 re-exports","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4039,"column":41,"index":152959},"line":4039,"code":"      it('supports chained ES6 re-exports', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-chained/index.js'), options);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'bar.js'));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        if (shouldScopeHoist) {\n          try {\n            assert.deepEqual(calls, ['key', 'foo', 'index']);\n          } catch (e) {\n            // A different dependency order, but this is deemed acceptable as it's sideeffect free\n            assert.deepEqual(calls, ['foo', 'key', 'index']);\n          }\n        } else {\n          assert.deepEqual(calls, ['key', 'foo', 'types', 'index']);\n        }\n        assert.deepEqual(res.output, ['key', 'foo']);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not optimize away an unused ES6 re-export and an used import","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4064,"column":77,"index":153938},"line":4064,"code":"      it('should not optimize away an unused ES6 re-export and an used import', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-import/a.js'), options);\n        let res = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(res.output, 123);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not optimize away an unused ES6 re-export and an used import (different symbols)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4071,"column":97,"index":154319},"line":4071,"code":"      it('should not optimize away an unused ES6 re-export and an used import (different symbols)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-import-different/a.js'), options);\n        let res = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(res.output, 123);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"correctly handles ES6 re-exports in library mode entries","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4078,"column":66,"index":154679},"line":4078,"code":"      it('correctly handles ES6 re-exports in library mode entries', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-library/a.js'), options);\n        let contents = await outputFS.readFile(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-library/build.js'), 'utf8');\n        assert(!contents.includes('console.log'));\n        let res = await run(b);\n        assert.deepEqual(res, {\n          c1: 'foo'\n        });\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"correctly updates deferred assets that are reexported","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4088,"column":65,"index":155241},"line":4088,"code":"        it('correctly updates deferred assets that are reexported', async function () {\n          let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-update-deferred-reexported');\n          let b = bundler(path.join(testDir, 'index.js'), {\n            inputFS: overlayFS,\n            outputFS: overlayFS,\n            ...options\n          });\n          let subscription = await b.watch();\n          let bundleEvent = await getNextBuild(b);\n          assert(bundleEvent.type === 'buildSuccess');\n          let output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, '12345hello');\n          await overlayFS.mkdirp(path.join(testDir, 'node_modules', 'foo'));\n          await overlayFS.copyFile(path.join(testDir, 'node_modules', 'foo', 'foo_updated.js'), path.join(testDir, 'node_modules', 'foo', 'foo.js'));\n          bundleEvent = await getNextBuild(b);\n          assert(bundleEvent.type === 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, '1234556789');\n          await subscription.unsubscribe();\n        });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"correctly updates deferred assets that are reexported and imported directly","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4108,"column":87,"index":156385},"line":4108,"code":"        it('correctly updates deferred assets that are reexported and imported directly', async function () {\n          let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-update-deferred-direct');\n          let b = bundler(path.join(testDir, 'index.js'), {\n            inputFS: overlayFS,\n            outputFS: overlayFS,\n            ...options\n          });\n          let subscription = await b.watch();\n          let bundleEvent = await getNextBuild(b);\n          assert(bundleEvent.type === 'buildSuccess');\n          let output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, '12345hello');\n          await overlayFS.mkdirp(path.join(testDir, 'node_modules', 'foo'));\n          await overlayFS.copyFile(path.join(testDir, 'node_modules', 'foo', 'foo_updated.js'), path.join(testDir, 'node_modules', 'foo', 'foo.js'));\n          bundleEvent = await getNextBuild(b);\n          assert(bundleEvent.type === 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, '1234556789');\n          await subscription.unsubscribe();\n        });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes deferred reexports when imported from multiple asssets","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4128,"column":74,"index":157512},"line":4128,"code":"        it('removes deferred reexports when imported from multiple asssets', async function () {\n          let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-multiple-dynamic/a.js'), options);\n          let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('$import$'));\n          assert(/=\\s*1234/.test(contents));\n          assert(!/=\\s*5678/.test(contents));\n          let output = await run(b);\n          assert.deepEqual(output, [1234, {\n            default: 1234\n          }]);\n        });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"keeps side effects by default","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4140,"column":39,"index":158087},"line":4140,"code":"      it('keeps side effects by default', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects/a.js'), options);\n        let called = false;\n        let res = await run(b, {\n          sideEffect: () => {\n            called = true;\n          }\n        }, {\n          require: false\n        });\n        assert(called, 'side effect not called');\n        assert.deepEqual(res.output, 4);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports the package.json sideEffects: false flag","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4153,"column":59,"index":158564},"line":4153,"code":"      it('supports the package.json sideEffects: false flag', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-false/a.js'), options);\n        let called = false;\n        let res = await run(b, {\n          sideEffect: () => {\n            called = true;\n          }\n        }, {\n          require: false\n        });\n        assert(!called, 'side effect called');\n        assert.deepEqual(res.output, 4);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports removing a deferred dependency","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4166,"column":49,"index":159034},"line":4166,"code":"      it('supports removing a deferred dependency', async function () {\n        let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-false');\n        let b = bundler(path.join(testDir, 'a.js'), {\n          inputFS: overlayFS,\n          outputFS: overlayFS,\n          ...options\n        });\n        let subscription = await b.watch();\n        try {\n          let bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          let called = false;\n          let res = await run(bundleEvent.bundleGraph, {\n            sideEffect: () => {\n              called = true;\n            }\n          }, {\n            require: false\n          });\n          assert(!called, 'side effect called');\n          assert.deepEqual(res.output, 4);\n          if (usesSymbolPropagation) {\n            assert(!findAsset(bundleEvent.bundleGraph, 'index.js'));\n          }\n          await overlayFS.mkdirp(path.join(testDir, 'node_modules/bar'));\n          await overlayFS.copyFile(path.join(testDir, 'node_modules/bar/index.1.js'), path.join(testDir, 'node_modules/bar/index.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          called = false;\n          res = await run(bundleEvent.bundleGraph, {\n            sideEffect: () => {\n              called = true;\n            }\n          }, {\n            require: false\n          });\n          assert(!called, 'side effect called');\n          assert.deepEqual(res.output, 4);\n        } finally {\n          await subscription.unsubscribe();\n        }\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports wildcards","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4208,"column":28,"index":160641},"line":4208,"code":"      it('supports wildcards', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-false-wildcards/a.js'), options);\n        let called = false;\n        let res = await run(b, {\n          sideEffect: () => {\n            called = true;\n          }\n        }, {\n          require: false\n        });\n        if (usesSymbolPropagation) {\n          assert(!called, 'side effect called');\n        }\n        assert.deepEqual(res.output, 'bar');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"correctly handles excluded and wrapped reexport assets","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4223,"column":64,"index":161189},"line":4223,"code":"      it('correctly handles excluded and wrapped reexport assets', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-false-wrap-excluded/a.js'), options);\n        let res = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(res.output, 4);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports the package.json sideEffects flag with an array","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4230,"column":66,"index":161539},"line":4230,"code":"      it('supports the package.json sideEffects flag with an array', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-array/a.js'), options);\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert(calls.toString() == 'foo', \"side effect called for 'foo'\");\n        assert.deepEqual(res.output, 4);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports the package.json sideEffects: false flag with shared dependencies","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4243,"column":84,"index":162077},"line":4243,"code":"      it('supports the package.json sideEffects: false flag with shared dependencies', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-false-duplicate/a.js'), options);\n        let called = false;\n        let res = await run(b, {\n          sideEffect: () => {\n            called = true;\n          }\n        }, {\n          require: false\n        });\n        assert(!called, 'side effect called');\n        assert.deepEqual(res.output, 6);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports the package.json sideEffects: false flag with shared dependencies and code splitting","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4256,"column":103,"index":162611},"line":4256,"code":"      it('supports the package.json sideEffects: false flag with shared dependencies and code splitting', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-split/a.js'), options);\n        let res = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(await res.output, 581);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports the package.json sideEffects: false flag with shared dependencies and code splitting II","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4263,"column":106,"index":162995},"line":4263,"code":"      it('supports the package.json sideEffects: false flag with shared dependencies and code splitting II', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-split2/a.js'), options);\n        let res = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(await res.output, [{\n          default: 123,\n          foo: 2\n        }, 581]);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"missing exports should be replaced with an empty object","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4273,"column":65,"index":163395},"line":4273,"code":"      it('missing exports should be replaced with an empty object', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/empty-module/a.js'), options);\n        let res = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(res.output, {\n          b: {}\n        });\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports namespace imports of theoretically excluded reexporting assets","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4282,"column":81,"index":163766},"line":4282,"code":"      it('supports namespace imports of theoretically excluded reexporting assets', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace-sideEffects/index.js'), options);\n        let res = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(res.output, {\n          Main: 'main',\n          a: 'foo',\n          b: 'bar'\n        });\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can import from a different bundle via a re-export","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4293,"column":60,"index":164183},"line":4293,"code":"      it('can import from a different bundle via a re-export', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-bundle-boundary-side-effects/index.js'), options);\n        let res = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(await res.output, ['operational', 'ui']);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports excluding multiple chained namespace reexports","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4300,"column":65,"index":164568},"line":4300,"code":"      it('supports excluding multiple chained namespace reexports', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-chained-re-exports-multiple/a.js'), options);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'symbol1.js'));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['message1'] : ['message1', 'message']);\n        assert.deepEqual(res.output, 'Message 1');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports excluding when doing both exports and reexports","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4316,"column":66,"index":165231},"line":4316,"code":"      it('supports excluding when doing both exports and reexports', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-export-reexport/a.js'), options);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'other.js'));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, ['index']);\n        assert.deepEqual(res.output, 'Message 1');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports deferring with chained renaming reexports","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4332,"column":60,"index":165826},"line":4332,"code":"      it('supports deferring with chained renaming reexports', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-rename-chained/a.js'), options);\n\n        // assertDependencyWasExcluded(b, 'message.js', './message2');\n\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['message1'] : ['message1', 'message', 'index2', 'index']);\n        assert.deepEqual(res.output, 'Message 1');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named and renamed reexports of the same asset (default used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4348,"column":79,"index":166498},"line":4348,"code":"      it('supports named and renamed reexports of the same asset (default used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-rename-same2/a.js'), options);\n        if (usesSymbolPropagation) {\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'other.js')))), new Set(['bar']));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['other'] : ['other', 'index']);\n        assert.deepEqual(res.output, 'bar');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named and renamed reexports of the same asset (named used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4364,"column":77,"index":167224},"line":4364,"code":"      it('supports named and renamed reexports of the same asset (named used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-rename-same2/b.js'), options);\n        if (usesSymbolPropagation) {\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'other.js')))), new Set(['bar']));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['other'] : ['other', 'index']);\n        assert.deepEqual(res.output, 'bar');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named and renamed reexports of the same asset (namespace used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4380,"column":81,"index":167954},"line":4380,"code":"      it('supports named and renamed reexports of the same asset (namespace used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-rename-same/index.js'), options);\n        let res = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(res.output, [{\n          value1: 123,\n          value2: 123\n        }, 123, 123]);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports reexports via variable declaration (unused)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4390,"column":62,"index":168374},"line":4390,"code":"      it('supports reexports via variable declaration (unused)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-rename-var-unused/index.js'), options);\n        let res = await run(b, {}, {\n          require: false\n        });\n        assert.deepEqual((await res.output).foo, 'foo');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named and namespace exports of the same asset (named used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4397,"column":77,"index":168762},"line":4397,"code":"      it('supports named and namespace exports of the same asset (named used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-namespace-same/a.js'), options);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'index.js'));\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'other.js')))), new Set(['default']));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['other'] : ['other', 'index']);\n        assert.deepEqual(res.output, ['foo']);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named and namespace exports of the same asset (namespace used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4414,"column":81,"index":169545},"line":4414,"code":"      it('supports named and namespace exports of the same asset (namespace used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-namespace-same/b.js'), options);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'index.js'));\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'other.js')))), new Set(['bar']));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['other'] : ['other', 'index']);\n        assert.deepEqual(res.output, ['bar']);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named and namespace exports of the same asset (both used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4431,"column":76,"index":170319},"line":4431,"code":"      it('supports named and namespace exports of the same asset (both used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-namespace-same/c.js'), options);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'index.js'));\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'other.js')))), new Set(['default', 'bar']));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['other'] : ['other', 'index']);\n        assert.deepEqual(res.output, ['foo', 'bar']);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports partially used reexporting index file","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4448,"column":56,"index":171091},"line":4448,"code":"      it('supports partially used reexporting index file', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-partially-used/index.js'), options);\n        let calls = [];\n        let res = (await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        })).output;\n        let [v, async] = res;\n        assert.deepEqual(calls, shouldScopeHoist ? ['b'] : ['b', 'index']);\n        assert.deepEqual(v, 2);\n        v = await async();\n        assert.deepEqual(calls, shouldScopeHoist ? ['b', 'a', 'index', 'dynamic'] : ['b', 'index', 'a', 'dynamic']);\n        assert.deepEqual(v.default, [1, 3]);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports deferring non-weak dependencies that are not used","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4465,"column":68,"index":171857},"line":4465,"code":"      it('supports deferring non-weak dependencies that are not used', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-semi-weak/a.js'), options);\n\n        // assertDependencyWasExcluded(b, 'esm2.js', './other.js');\n\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['esm1'] : ['esm1', 'index']);\n        assert.deepEqual(res.output, 'Message 1');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports excluding CommonJS (CommonJS unused)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4481,"column":55,"index":172457},"line":4481,"code":"      it('supports excluding CommonJS (CommonJS unused)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-commonjs/a.js'), options);\n        if (usesSymbolPropagation) {\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'esm.js')))), new Set(['message1']));\n          // We can't statically analyze commonjs.js, so message1 appears to be used\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'commonjs.js')))),\n          // the exports object is used freely\n          new Set(['*', 'message1']));\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'index.js', './commonjs.js'))), new Set(['message1']));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, ['esm', 'commonjs', 'index']);\n        assert.deepEqual(res.output, 'Message 1');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports excluding CommonJS (CommonJS used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4502,"column":53,"index":173536},"line":4502,"code":"      it('supports excluding CommonJS (CommonJS used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-commonjs/b.js'), options);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'esm.js'));\n          assert(!findAsset(b, 'index.js'));\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'commonjs.js')))),\n          // the exports object is used freely\n          new Set(['*', 'message2']));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['commonjs'] : ['commonjs', 'index']);\n        assert.deepEqual(res.output, 'Message 2');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"ignores missing unused import specifiers in source assets  scope-hoisting","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4523,"column":121,"index":174469},"line":4523,"code":"    it(`ignores missing unused import specifiers in source assets ${shouldScopeHoist ? 'with' : 'without'} scope-hoisting`, async function () {\n      let b = await bundle(path.join(__dirname, 'integration/js-unused-import-specifier/a.js'), options);\n      let res = await run(b, null, {\n        require: false\n      });\n      assert.equal(res.output, 123);\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"ignores missing unused import specifiers in node-modules  scope-hoisting","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4530,"column":120,"index":174833},"line":4530,"code":"    it(`ignores missing unused import specifiers in node-modules ${shouldScopeHoist ? 'with' : 'without'} scope-hoisting`, async function () {\n      let b = await bundle(path.join(__dirname, '/integration/js-unused-import-specifier-node-modules/a.js'), options);\n      let res = await run(b, null, {\n        require: false\n      });\n      assert.equal(res.output, 123);\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"logs bundling a commonjs bundle to stdout as json","suites":["json reporter"],"updatePoint":{"line":9,"column":55,"index":373},"line":9,"code":"  it('logs bundling a commonjs bundle to stdout as json', async () => {\n    let consoleStub = sinon.stub(console, 'log');\n    try {\n      await bundle(path.join(__dirname, '/integration/commonjs/index.js'), {\n        config,\n        logLevel: 'info'\n      });\n      let parsedCalls = consoleStub.getCalls().map(call => {\n        invariant(typeof call.lastArg === 'string');\n        return JSON.parse(call.lastArg);\n      });\n      for (let [iStr, parsed] of Object.entries(parsedCalls)) {\n        parsed = parsed;\n        invariant(typeof iStr === 'string');\n        let i = parseInt(iStr, 10);\n        if (i === 0) {\n          assert.deepEqual(parsed, {\n            type: 'buildStart'\n          });\n        } else if (i > 0 && i < 9) {\n          assert.equal(parsed.type, 'buildProgress');\n          assert.equal(parsed.phase, 'transforming');\n          assert(typeof parsed.filePath === 'string');\n        } else if (i === 9) {\n          assert.deepEqual(parsed, {\n            type: 'buildProgress',\n            phase: 'bundling'\n          });\n        } else if (i === 10) {\n          assert.equal(parsed.type, 'buildProgress');\n          assert.equal(parsed.phase, 'packaging');\n          assert.equal(parsed.bundleName, 'index.js');\n        } else if (i === 11) {\n          assert.equal(parsed.type, 'buildProgress');\n          assert.equal(parsed.phase, 'optimizing');\n          assert.equal(parsed.bundleName, 'index.js');\n        } else if (i === 12) {\n          assert.equal(parsed.type, 'buildSuccess');\n          assert(typeof parsed.buildTime === 'number');\n          assert(Array.isArray(parsed.bundles));\n          let bundle = parsed.bundles[0];\n          assert.equal(path.basename(bundle.filePath), 'index.js');\n          assert(typeof bundle.size === 'number');\n          assert(typeof bundle.time === 'number');\n          assert(Array.isArray(bundle.assets));\n        }\n      }\n    } finally {\n      consoleStub.restore();\n    }\n  });","file":"json-reporter.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a basic kotlin bundle","suites":["kotlin"],"updatePoint":{"line":10,"column":42,"index":413},"line":10,"code":"  it('should produce a basic kotlin bundle', async function () {\n    let b = await bundle(__dirname + '/integration/kotlin/index.js');\n    await assertBundleTree(b, {\n      type: 'js',\n      assets: ['test.kt', 'index.js', 'browser.js', 'kotlin.js']\n    });\n    let output = await run(b);\n    assert.equal(output, 5);\n  });","file":"kotlin.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring less files","suites":["less"],"updatePoint":{"line":6,"column":41,"index":252},"line":6,"code":"  it('should support requiring less files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.less']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.index'));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support less imports","suites":["less"],"updatePoint":{"line":21,"column":33,"index":762},"line":21,"code":"  it('should support less imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less-import/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.less']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.a'));\n    assert(css.includes('.b'));\n    assert(css.includes('.c'));\n    assert(css.includes('.d'));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support advanced less imports","suites":["less"],"updatePoint":{"line":39,"column":42,"index":1380},"line":39,"code":"  it('should support advanced less imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less-advanced-import/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.less']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.a'));\n    assert(css.includes('.external-index'));\n    assert(css.includes('.external-a'));\n    assert(css.includes('.external-with-main'));\n    assert(css.includes('.explicit-external-a'));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring empty less files","suites":["less"],"updatePoint":{"line":58,"column":47,"index":2101},"line":58,"code":"  it('should support requiring empty less files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less-empty/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.less']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert.equal(css.trim(), '/*# sourceMappingURL=index.css.map */');\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support linking to assets with url() from less","suites":["less"],"updatePoint":{"line":73,"column":59,"index":2678},"line":73,"code":"  it('should support linking to assets with url() from less', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.less']\n    }, {\n      type: 'woff2',\n      assets: ['test.woff2']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(/url\\(\"?test\\.[0-9a-f]+\\.woff2\"?\\)/.test(css));\n    assert(/url\\(\"?http:\\/\\/google.com\"?\\)/.test(css));\n    assert(css.includes('.index'));\n    assert(await outputFS.exists(path.join(distDir, css.match(/url\\(\"?(test\\.[0-9a-f]+\\.woff2)\"?\\)/)[1])));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support less url rewrites","suites":["less"],"updatePoint":{"line":94,"column":38,"index":3479},"line":94,"code":"  it('should support less url rewrites', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less-url-rewrite/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.less']\n    }, {\n      type: 'woff2',\n      assets: ['a.woff2']\n    }, {\n      type: 'woff2',\n      assets: ['b.woff2']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.a'));\n    assert(css.includes('.b'));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support css modules in less","suites":["less"],"updatePoint":{"line":116,"column":40,"index":4148},"line":116,"code":"  it('should support css modules in less', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less-postcss/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'index.module.less']\n    }, {\n      name: 'index.css',\n      assets: ['index.module.less']\n    }, {\n      assets: ['img.svg']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert(output().endsWith('_index'));\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(/\\.[_0-9a-zA-Z]+_index/.test(css));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw an exception when using webpack syntax","suites":["less"],"updatePoint":{"line":133,"column":57,"index":4774},"line":133,"code":"  it('should throw an exception when using webpack syntax', async function () {\n    await assert.rejects(() => bundle(path.join(__dirname, '/integration/less-webpack-import-error/index.js')), {\n      message: md`The @import path \"${'~library/style.less'}\" is using webpack specific syntax, which isn't supported by Parcel.\\n\\nTo @import files from ${'node_modules'}, use \"${'library/style.less'}\"`\n    });\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support configuring less include paths","suites":["less"],"updatePoint":{"line":138,"column":51,"index":5180},"line":138,"code":"  it('should support configuring less include paths', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less-include-paths/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.less']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.a'));\n    assert(css.includes('.b'));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore url() with IE behavior specifiers","suites":["less"],"updatePoint":{"line":154,"column":53,"index":5752},"line":154,"code":"  it('should ignore url() with IE behavior specifiers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less-url-behavior/index.less'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.less']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('url(\"#default#VML\")'));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"preserves quotes around data urls that require them","suites":["less"],"updatePoint":{"line":163,"column":57,"index":6147},"line":163,"code":"  it('preserves quotes around data urls that require them', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/less-url-quotes/index.less'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.less']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes(\n    // Note the literal space after \"xml\"\n    'background: url(\"data:image/svg+xml,%3C%3Fxml version%3D%221.0%22%3F%3E%3Csvg%3E%3C%2Fsvg%3E\")'));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the less package exports condition","suites":["less"],"updatePoint":{"line":174,"column":55,"index":6654},"line":174,"code":"  it('should support the less package exports condition', async function () {\n    await bundle(path.join(__dirname, '/integration/less-exports/index.less'));\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.a'));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling Markdown","suites":["markdown"],"updatePoint":{"line":5,"column":38,"index":206},"line":5,"code":"  it('should support bundling Markdown', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/markdown/index.md'));\n    await assertBundleTree(b, {\n      name: 'index.html',\n      assets: ['index.md'],\n      childBundles: [{\n        type: 'png',\n        assets: ['100x100.png'],\n        childBundles: []\n      }]\n    });\n    let files = await outputFS.readdir(path.join(__dirname, '/dist'));\n    let html = await outputFS.readFile(path.join(__dirname, '/dist/index.html'));\n    for (let file of files) {\n      let ext = file.match(/\\.([0-9a-z]+)(?:[?#]|$)/i)[0];\n      if (file !== 'index.html' && ext !== '.map') {\n        assert(html.includes(file));\n      }\n    }\n  });","file":"markdown.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling MDX","suites":["mdx"],"updatePoint":{"line":8,"column":33,"index":187},"line":8,"code":"  it('should support bundling MDX', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/mdx/index.mdx'));\n    let output = await run(b);\n    assert.equal(typeof output.default, 'function');\n    assert(output.default.isMDXComponent);\n  });","file":"mdx.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling MDX with React 17","suites":["mdx"],"updatePoint":{"line":14,"column":47,"index":468},"line":14,"code":"  it('should support bundling MDX with React 17', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/mdx-react-17/index.mdx'));\n    let output = await run(b);\n    assert.equal(typeof output.default, 'function');\n    assert(output.default.isMDXComponent);\n  });","file":"mdx.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should dump bundle metrics to parcel-metrics.json","suites":["Build Metrics Reporter"],"updatePoint":{"line":6,"column":55,"index":302},"line":6,"code":"  it('Should dump bundle metrics to parcel-metrics.json', async () => {\n    let b = bundler(path.join(__dirname, '/integration/commonjs/index.js'), {\n      config,\n      logLevel: 'info'\n    });\n    await b.run();\n    let projectRoot = b._getResolvedParcelOptions().projectRoot;\n    let dirContent = await outputFS.readdir(projectRoot);\n    assert(dirContent.includes('parcel-metrics.json'), 'Should create a parcel-metrics.json file');\n    let metrics = JSON.parse(await outputFS.readFile(path.join(projectRoot, 'parcel-metrics.json'), 'utf8'));\n    assert(!!metrics.buildTime, 'Should contain buildTime');\n    assert(metrics.bundles.length > 0, 'Should contain bundle(s)');\n    for (let bundle of metrics.bundles) {\n      assert(bundle.filePath, 'Each bundle should have a filePath');\n      assert(bundle.size, 'Each bundle should have a size');\n      assert(bundle.time, 'Each bundle should have a time');\n      assert(Array.isArray(bundle.largestAssets), 'Each bundle should contain a list of largest assets');\n      assert(bundle.totalAssets, 'Each bundle should contain the amount of assets');\n    }\n  });","file":"metrics-reporter.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile packages with target source overrides","suites":["monorepos"],"updatePoint":{"line":16,"column":58,"index":592},"line":16,"code":"  it('should compile packages with target source overrides', async function () {\n    let fixture = path.join(__dirname, '/integration/target-source');\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(fixture);\n    try {\n      let b = await bundle([path.join(fixture, 'packages/package-a'), path.join(fixture, 'packages/package-b')], {\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          distDir\n        }\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['foo.js', 'index.js']\n      }, {\n        name: 'indexAlternate.js',\n        assets: ['bar.js', 'indexAlternate.js']\n      }, {\n        name: 'index.js',\n        assets: ['foo.js', 'index.js']\n      }, {\n        name: 'indexAlternate.js',\n        assets: ['bar.js', 'indexAlternate.js']\n      }, {\n        name: 'indexAlternate2.js',\n        assets: ['foo.js', 'indexAlternate2.js']\n      }]);\n      let contents = await outputFS.readFile(path.join(distDir, '/package-a/src/index.js'), 'utf8');\n      assert(contents.includes('hello foo'));\n      contents = await outputFS.readFile(path.join(distDir, '/package-a/src/indexAlternate.js'), 'utf8');\n      assert(contents.includes('hello bar'));\n      contents = await outputFS.readFile(path.join(distDir, '/package-a/src/indexAlternate2.js'), 'utf8');\n      assert(contents.includes('hello foo'));\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile packages with target source overrides and --target option","suites":["monorepos"],"updatePoint":{"line":53,"column":78,"index":2023},"line":53,"code":"  it('should compile packages with target source overrides and --target option', async function () {\n    let fixture = path.join(__dirname, '/integration/target-source');\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(fixture);\n    try {\n      let b = await bundle([path.join(fixture, 'packages/package-a'), path.join(fixture, 'packages/package-b')], {\n        targets: ['alternate'],\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          distDir\n        }\n      });\n      assertBundles(b, [{\n        name: 'indexAlternate.js',\n        assets: ['bar.js', 'indexAlternate.js']\n      }, {\n        name: 'indexAlternate.js',\n        assets: ['bar.js', 'indexAlternate.js']\n      }, {\n        name: 'indexAlternate2.js',\n        assets: ['foo.js', 'indexAlternate2.js']\n      }]);\n      let contents = await outputFS.readFile(path.join(distDir, '/package-a/src/indexAlternate.js'), 'utf8');\n      assert(contents.includes('hello bar'));\n      contents = await outputFS.readFile(path.join(distDir, '/package-a/src/indexAlternate2.js'), 'utf8');\n      assert(contents.includes('hello foo'));\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile packages with target source overrides and --target option in serve mode","suites":["monorepos"],"updatePoint":{"line":83,"column":92,"index":3205},"line":83,"code":"  it('should compile packages with target source overrides and --target option in serve mode', async function () {\n    let fixture = path.join(__dirname, '/integration/target-source');\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(fixture);\n    try {\n      let b = await bundle(path.join(fixture, 'packages/package-b'), {\n        targets: ['alternate'],\n        serveOptions: {\n          port: 1234\n        }\n      });\n      assertBundles(b, [{\n        name: 'indexAlternate.js',\n        assets: ['bar.js', 'esmodule-helpers.js', 'indexAlternate.js']\n      }]);\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build using root targets with entry files inside packages and cwd at project root","suites":["monorepos"],"updatePoint":{"line":102,"column":94,"index":3830},"line":102,"code":"  it('should build using root targets with entry files inside packages and cwd at project root', async function () {\n    let fixture = path.join(__dirname, '/integration/monorepo');\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(fixture);\n    try {\n      let b = await bundle([path.join(fixture, 'packages/pkg-a/src/index.js'), path.join(fixture, 'packages/pkg-b/src/index.js')], {\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          distDir\n        }\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js']\n      }, {\n        name: 'index.js',\n        assets: ['index.js', 'index.module.css']\n      }, {\n        name: 'index.css',\n        assets: ['index.module.css']\n      }]);\n      let contents = await outputFS.readFile(path.join(distDir, '/pkg-a/src/index.js'), 'utf8');\n      assert(contents.includes('$parcel$export(module.exports, \"default\"'));\n      contents = await outputFS.readFile(path.join(distDir, '/pkg-b/src/index.js'), 'utf8');\n      assert(contents.includes('require(\"./index.css\")'));\n      contents = await outputFS.readFile(path.join(distDir, '/pkg-b/src/index.css'), 'utf8');\n      assert(/\\.[_0-9a-zA-Z]+_foo/.test(contents));\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build multiple packages in a monorepo at once, pointing at directories with \"source\" field in package.json","suites":["monorepos"],"updatePoint":{"line":133,"column":119,"index":5126},"line":133,"code":"  it('should build multiple packages in a monorepo at once, pointing at directories with \"source\" field in package.json', async function () {\n    let b = await bundle([path.join(__dirname, '/integration/monorepo/packages/pkg-a'), path.join(__dirname, '/integration/monorepo/packages/pkg-b')], {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      name: 'pkg-a.cjs.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-a.module.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-b.cjs.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-b.module.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-b.cjs.css',\n      assets: ['index.module.css']\n    }]);\n    let contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-a/dist/pkg-a.cjs.js'), 'utf8');\n    assert(contents.includes('$parcel$export(module.exports, \"default\"'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-a/dist/pkg-a.module.js'), 'utf8');\n    assert(contents.includes('export {'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-b/dist/pkg-b.cjs.js'), 'utf8');\n    assert(contents.includes('require(\"./pkg-b.cjs.css\")'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-b/dist/pkg-b.cjs.css'), 'utf8');\n    assert(/\\.[_0-9a-zA-Z]+_foo/.test(contents));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-b/dist/pkg-b.module.js'), 'utf8');\n    assert(contents.includes('import \"./pkg-b.cjs.css\"'));\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build using root targets with a glob pointing at files inside packages and cwd at project root","suites":["monorepos"],"updatePoint":{"line":166,"column":107,"index":6830},"line":166,"code":"  it('should build using root targets with a glob pointing at files inside packages and cwd at project root', async function () {\n    let fixture = path.join(__dirname, '/integration/monorepo');\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(fixture);\n    try {\n      let b = await bundle(path.join(fixture, 'packages/*/src/index.js'), {\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          distDir\n        }\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js']\n      }, {\n        name: 'index.js',\n        assets: ['index.js', 'index.module.css']\n      }, {\n        name: 'index.css',\n        assets: ['index.module.css']\n      }]);\n      let contents = await outputFS.readFile(path.join(distDir, '/pkg-a/src/index.js'), 'utf8');\n      assert(contents.includes('$parcel$export(module.exports, \"default\"'));\n      contents = await outputFS.readFile(path.join(distDir, '/pkg-b/src/index.js'), 'utf8');\n      assert(contents.includes('require(\"./index.css\")'));\n      contents = await outputFS.readFile(path.join(distDir, '/pkg-b/src/index.css'), 'utf8');\n      assert(/\\.[_0-9a-zA-Z]+_foo/.test(contents));\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build using root targets with a glob pointing at files inside packages and cwd outside project root","suites":["monorepos"],"updatePoint":{"line":197,"column":112,"index":8062},"line":197,"code":"  it('should build using root targets with a glob pointing at files inside packages and cwd outside project root', async function () {\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(path.join(__dirname, '/integration'));\n    try {\n      let b = await bundle(path.join(__dirname, '/integration/monorepo/packages/*/src/index.js'), {\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          distDir\n        }\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js']\n      }, {\n        name: 'index.js',\n        assets: ['index.js', 'index.module.css']\n      }, {\n        name: 'index.css',\n        assets: ['index.module.css']\n      }]);\n      let contents = await outputFS.readFile(path.join(distDir, '/pkg-a/src/index.js'), 'utf8');\n      assert(contents.includes('$parcel$export(module.exports, \"default\"'));\n      contents = await outputFS.readFile(path.join(distDir, '/pkg-b/src/index.js'), 'utf8');\n      assert(contents.includes('require(\"./index.css\")'));\n      contents = await outputFS.readFile(path.join(distDir, '/pkg-b/src/index.css'), 'utf8');\n      assert(/\\.[_0-9a-zA-Z]+_foo/.test(contents));\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build a single package with an entry file and cwd at a package","suites":["monorepos"],"updatePoint":{"line":227,"column":75,"index":9245},"line":227,"code":"  it('should build a single package with an entry file and cwd at a package', async function () {\n    let fixture = path.join(__dirname, '/integration/monorepo/packages/pkg-a');\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(fixture);\n    try {\n      let b = await bundle(path.join(fixture, 'src/index.js'), {\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          distDir\n        }\n      });\n      assertBundles(b, [{\n        name: 'pkg-a.cjs.js',\n        assets: ['index.js']\n      }, {\n        name: 'pkg-a.module.js',\n        assets: ['index.js']\n      }]);\n      let contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-a/dist/pkg-a.cjs.js'), 'utf8');\n      assert(contents.includes('$parcel$export(module.exports, \"default\"'));\n      contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-a/dist/pkg-a.module.js'), 'utf8');\n      assert(contents.includes('export {'));\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build a single package with an entry file and cwd inside a package","suites":["monorepos"],"updatePoint":{"line":253,"column":79,"index":10281},"line":253,"code":"  it('should build a single package with an entry file and cwd inside a package', async function () {\n    let fixture = path.join(__dirname, '/integration/monorepo/packages/pkg-a/src');\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(fixture);\n    try {\n      let b = await bundle(path.join(fixture, 'index.js'), {\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          distDir\n        }\n      });\n      assertBundles(b, [{\n        name: 'pkg-a.cjs.js',\n        assets: ['index.js']\n      }, {\n        name: 'pkg-a.module.js',\n        assets: ['index.js']\n      }]);\n      let contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-a/dist/pkg-a.cjs.js'), 'utf8');\n      assert(contents.includes('$parcel$export(module.exports, \"default\"'));\n      contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-a/dist/pkg-a.module.js'), 'utf8');\n      assert(contents.includes('export {'));\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build multiple packages in a monorepo at once, pointing at a glob of directories","suites":["monorepos"],"updatePoint":{"line":279,"column":93,"index":11331},"line":279,"code":"  it('should build multiple packages in a monorepo at once, pointing at a glob of directories', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/monorepo/packages/*'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      name: 'pkg-a.cjs.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-a.module.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-b.cjs.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-b.module.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-b.cjs.css',\n      assets: ['index.module.css']\n    }]);\n    let contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-a/dist/pkg-a.cjs.js'), 'utf8');\n    assert(contents.includes('$parcel$export(module.exports, \"default\"'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-a/dist/pkg-a.module.js'), 'utf8');\n    assert(contents.includes('export {'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-b/dist/pkg-b.cjs.js'), 'utf8');\n    assert(contents.includes('require(\"./pkg-b.cjs.css\")'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-b/dist/pkg-b.cjs.css'), 'utf8');\n    assert(/\\.[_0-9a-zA-Z]+_foo/.test(contents));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-b/dist/pkg-b.module.js'), 'utf8');\n    assert(contents.includes('import \"./pkg-b.cjs.css\"'));\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should watch glob entries and build new packages that are added","suites":["monorepos"],"updatePoint":{"line":312,"column":69,"index":12929},"line":312,"code":"  it('should watch glob entries and build new packages that are added', async function () {\n    // copy into memory fs\n    await ncp(path.join(__dirname, '/integration/monorepo/packages/pkg-a'), path.join(__dirname, '/monorepo/packages/pkg-a'));\n    let b = await bundler(path.join(__dirname, '/monorepo/packages/*'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      },\n      inputFS: overlayFS\n    });\n    subscription = await b.watch();\n    let evt = await getNextBuild(b);\n    assertBundles(evt.bundleGraph, [{\n      name: 'pkg-a.cjs.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-a.module.js',\n      assets: ['index.js']\n    }]);\n    await ncp(path.join(__dirname, '/integration/monorepo/packages/pkg-b'), path.join(__dirname, '/monorepo/packages/pkg-b'));\n    evt = await getNextBuild(b);\n    assertBundles(evt.bundleGraph, [{\n      name: 'pkg-a.cjs.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-a.module.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-b.cjs.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-b.module.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-b.cjs.css',\n      assets: ['index.module.css']\n    }]);\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should watch package.json containing \"source\" field for changes","suites":["monorepos"],"updatePoint":{"line":349,"column":69,"index":14173},"line":349,"code":"  it('should watch package.json containing \"source\" field for changes', async function () {\n    // copy into memory fs\n    await ncp(path.join(__dirname, '/integration/monorepo/packages/pkg-a'), path.join(__dirname, '/monorepo/packages/pkg-a'));\n    let b = await bundler(path.join(__dirname, '/monorepo/packages/*'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      },\n      inputFS: overlayFS\n    });\n    subscription = await b.watch();\n    let evt = await getNextBuild(b);\n    assertBundles(evt.bundleGraph, [{\n      name: 'pkg-a.cjs.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-a.module.js',\n      assets: ['index.js']\n    }]);\n    let pkgFile = path.join(__dirname, '/monorepo/packages/pkg-a/package.json');\n    let pkg = JSON.parse(await outputFS.readFile(pkgFile, 'utf8'));\n    await outputFS.writeFile(pkgFile, JSON.stringify({\n      ...pkg,\n      source: 'src/alt.js'\n    }));\n    evt = await getNextBuild(b);\n    assert(evt.type === 'buildSuccess');\n    assertBundles(evt.bundleGraph, [{\n      name: 'pkg-a.cjs.js',\n      assets: ['alt.js']\n    }, {\n      name: 'pkg-a.module.js',\n      assets: ['alt.js']\n    }]);\n    let contents = await outputFS.readFile(path.join(__dirname, '/monorepo/packages/pkg-a/dist/pkg-a.cjs.js'), 'utf8');\n    assert(contents.includes('return 3'));\n    contents = await outputFS.readFile(path.join(__dirname, '/monorepo/packages/pkg-a/dist/pkg-a.module.js'), 'utf8');\n    assert(contents.includes('return 3'));\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should watch package.json containing targets for changes","suites":["monorepos"],"updatePoint":{"line":387,"column":62,"index":15655},"line":387,"code":"  it('should watch package.json containing targets for changes', async function () {\n    // copy into memory fs\n    await ncp(path.join(__dirname, '/integration/monorepo/packages/pkg-a'), path.join(__dirname, '/monorepo/packages/pkg-a'));\n    let b = await bundler(path.join(__dirname, '/monorepo/packages/*'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      },\n      inputFS: overlayFS\n    });\n    subscription = await b.watch();\n    let evt = await getNextBuild(b);\n    assertBundles(evt.bundleGraph, [{\n      name: 'pkg-a.cjs.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-a.module.js',\n      assets: ['index.js']\n    }]);\n    let pkgFile = path.join(__dirname, '/monorepo/packages/pkg-a/package.json');\n    let pkg = JSON.parse(await outputFS.readFile(pkgFile, 'utf8'));\n    await outputFS.writeFile(pkgFile, JSON.stringify({\n      ...pkg,\n      main: 'dist/alt.js',\n      module: 'dist/alt.module.js'\n    }));\n    evt = await getNextBuild(b);\n    assertBundles(evt.bundleGraph, [{\n      name: 'alt.js',\n      assets: ['index.js']\n    }, {\n      name: 'alt.module.js',\n      assets: ['index.js']\n    }]);\n    let contents = await outputFS.readFile(path.join(__dirname, '/monorepo/packages/pkg-a/dist/alt.js'), 'utf8');\n    assert(contents.includes('return 2'));\n    contents = await outputFS.readFile(path.join(__dirname, '/monorepo/packages/pkg-a/dist/alt.module.js'), 'utf8');\n    assert(contents.includes('return 2'));\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not share bundles between targets","suites":["monorepos"],"updatePoint":{"line":425,"column":46,"index":17103},"line":425,"code":"  it('should not share bundles between targets', async function () {\n    let b = await bundle([path.join(__dirname, '/integration/monorepo-shared/packages/pkg-a'), path.join(__dirname, '/integration/monorepo-shared/packages/pkg-b')], {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      name: 'pkg-a.cjs.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-a.module.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-a.cjs.css',\n      assets: ['index.module.css']\n    }, {\n      name: 'pkg-b.cjs.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-b.module.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-b.cjs.css',\n      assets: ['index.module.css']\n    }]);\n    let contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo-shared/packages/pkg-a/dist/pkg-a.cjs.js'), 'utf8');\n    assert(contents.includes('$parcel$export(module.exports, \"default\"'));\n    assert(contents.includes('require(\"./pkg-a.cjs.css\")'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo-shared/packages/pkg-a/dist/pkg-a.module.js'), 'utf8');\n    assert(contents.includes('export {'));\n    assert(contents.includes('import \"./pkg-a.cjs.css\"'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo-shared/packages/pkg-a/dist/pkg-a.cjs.css'), 'utf8');\n    assert(/\\.[_0-9a-zA-Z]+_foo/.test(contents));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo-shared/packages/pkg-b/dist/pkg-b.cjs.js'), 'utf8');\n    assert(contents.includes('require(\"./pkg-b.cjs.css\")'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo-shared/packages/pkg-b/dist/pkg-b.cjs.css'), 'utf8');\n    assert(/\\.[_0-9a-zA-Z]+_foo/.test(contents));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo-shared/packages/pkg-b/dist/pkg-b.module.js'), 'utf8');\n    assert(contents.includes('import \"./pkg-b.cjs.css\"'));\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should search for .parcelrc at cwd in monorepos","suites":["monorepos"],"updatePoint":{"line":465,"column":53,"index":19221},"line":465,"code":"  it('should search for .parcelrc at cwd in monorepos', async () => {\n    let fixture = path.join(__dirname, '/integration/parcelrc-monorepo/app/index.js');\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(path.dirname(fixture));\n    try {\n      let b = await bundle(fixture);\n      assert.equal((await run(b)).default, '<svg></svg>\\n');\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should determine correct entry root when building a directory","suites":["namer"],"updatePoint":{"line":5,"column":67,"index":218},"line":5,"code":"  it('should determine correct entry root when building a directory', async function () {\n    await bundle(path.join(__dirname, 'integration/namer-dir'));\n    assert(await outputFS.exists(path.join(distDir, 'index.html')));\n    assert(await outputFS.exists(path.join(distDir, 'nested/other.html')));\n  });","file":"namer.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output (exports)","suites":["output formats","commonjs"],"updatePoint":{"line":18,"column":48,"index":656},"line":18,"code":"    it('should support commonjs output (exports)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs/exports.js'));\n      assert.equal((await run(b)).bar, 5);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output (module.exports)","suites":["output formats","commonjs"],"updatePoint":{"line":22,"column":55,"index":879},"line":22,"code":"    it('should support commonjs output (module.exports)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs/module-exports.js'));\n      let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(!dist.includes('function')); // no iife\n      assert.equal(await run(b), 5);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output from esmodule input","suites":["output formats","commonjs"],"updatePoint":{"line":28,"column":58,"index":1237},"line":28,"code":"    it('should support commonjs output from esmodule input', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-commonjs/a.js'));\n      assert.equal((await run(b)).bar, 5);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output from esmodule input (re-export rename)","suites":["output formats","commonjs"],"updatePoint":{"line":32,"column":77,"index":1480},"line":32,"code":"    it('should support commonjs output from esmodule input (re-export rename)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-commonjs/re-export-rename.js'));\n      assert.equal((await run(b)).default, 2);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output from esmodule input (re-export namespace as)","suites":["output formats","commonjs"],"line":36,"code":"    it.skip('should support commonjs output from esmodule input (re-export namespace as)', async function () {","file":"output-formats.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output from esmodule input (same binding multiple exports)","suites":["output formats","commonjs"],"updatePoint":{"line":44,"column":90,"index":2221},"line":44,"code":"    it('should support commonjs output from esmodule input (same binding multiple exports)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-commonjs/multiple-times.js'));\n      assert.deepStrictEqual(await run(b), {\n        default: 1,\n        test: 1,\n        other: 1,\n        foo: 2\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output from esmodule input (skipped exports)","suites":["output formats","commonjs"],"updatePoint":{"line":53,"column":76,"index":2558},"line":53,"code":"    it('should support commonjs output from esmodule input (skipped exports)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-commonjs-isLibrary-false/skipped.js'));\n      assert.deepEqual(await run(b), {});\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with external modules (require)","suites":["output formats","commonjs"],"updatePoint":{"line":57,"column":70,"index":2815},"line":57,"code":"    it('should support commonjs output with external modules (require)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-external/require.js'));\n      let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(dist.includes('require(\"lodash\")'));\n      assert.equal((await run(b)).bar, 3);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with external modules (named import)","suites":["output formats","commonjs"],"updatePoint":{"line":63,"column":75,"index":3195},"line":63,"code":"    it('should support commonjs output with external modules (named import)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-external/named.js'));\n      assert.equal((await run(b)).bar, 3);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with external modules (named import with same name)","suites":["output formats","commonjs"],"updatePoint":{"line":67,"column":90,"index":3460},"line":67,"code":"    it('should support commonjs output with external modules (named import with same name)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-external/named-same.js'));\n      assert.equal((await run(b)).bar, true);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with external modules (namespace import)","suites":["output formats","commonjs"],"updatePoint":{"line":71,"column":79,"index":3722},"line":71,"code":"    it('should support commonjs output with external modules (namespace import)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-external/namespace.js'));\n      let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(dist.includes('= require(\"lodash\")'));\n      assert.equal((await run(b)).bar, 3);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with external modules (default import)","suites":["output formats","commonjs"],"updatePoint":{"line":77,"column":77,"index":4108},"line":77,"code":"    it('should support commonjs output with external modules (default import)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-external/default.js'));\n      let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(dist.includes('$parcel$interopDefault'));\n      assert.equal((await run(b)).bar, 3);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with external modules (default import new call)","suites":["output formats","commonjs"],"updatePoint":{"line":83,"column":86,"index":4504},"line":83,"code":"    it('should support commonjs output with external modules (default import new call)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-external/default-new.js'));\n      let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(dist.includes('$parcel$interopDefault'));\n      await run(b);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with external modules (multiple specifiers)","suites":["output formats","commonjs"],"updatePoint":{"line":89,"column":82,"index":4877},"line":89,"code":"    it('should support commonjs output with external modules (multiple specifiers)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-external/multiple.js'));\n      let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(dist.includes('= require(\"lodash\")'));\n      assert(dist.includes('= (0, ($parcel$interopDefault('));\n      assert(/var {add: \\s*\\$.+?\\$add\\s*} = lodash/);\n      assert.equal((await run(b)).bar, 6);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with old node without destructuring (single)","suites":["output formats","commonjs"],"updatePoint":{"line":97,"column":83,"index":5385},"line":97,"code":"    it('should support commonjs output with old node without destructuring (single)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-destructuring-node/single.js'));\n      assert.equal((await run(b)).bar, 3);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with old node without destructuring (multiple single with same name)","suites":["output formats","commonjs"],"updatePoint":{"line":101,"column":107,"index":5678},"line":101,"code":"    it('should support commonjs output with old node without destructuring (multiple single with same name)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-destructuring-node/single-same.js'));\n      assert.equal((await run(b)).bar, true);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with old node without destructuring (multiple)","suites":["output formats","commonjs"],"updatePoint":{"line":105,"column":85,"index":5957},"line":105,"code":"    it('should support commonjs output with old node without destructuring (multiple)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-destructuring-node/multiple.js'));\n      assert.equal((await run(b)).bar, 2);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with old browsers without destructuring (single)","suites":["output formats","commonjs"],"updatePoint":{"line":109,"column":87,"index":6232},"line":109,"code":"    it('should support commonjs output with old browsers without destructuring (single)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-destructuring-browsers/single.js'));\n      assert.equal((await run(b, {\n        require\n      })).bar, 3);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with old node without destructuring (multiple)","suites":["output formats","commonjs"],"updatePoint":{"line":115,"column":85,"index":6534},"line":115,"code":"    it('should support commonjs output with old node without destructuring (multiple)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-destructuring-browsers/multiple.js'));\n      assert.equal((await run(b, {\n        require\n      })).bar, 2);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing sibling bundles in library mode","suites":["output formats","commonjs"],"updatePoint":{"line":121,"column":64,"index":6817},"line":121,"code":"    it('should support importing sibling bundles in library mode', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-siblings/a.js'));\n      let dist = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n      assert(dist.includes('require(\"./index.css\")'));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support async imports","suites":["output formats","commonjs"],"updatePoint":{"line":126,"column":36,"index":7138},"line":126,"code":"    it('should support async imports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-async/index.js'));\n      let index = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('index')).filePath, 'utf8');\n      assert(/Promise\\.resolve\\(require\\(\"\\.\\/async\\..+?\\.js\"\\)\\)/.test(index));\n      assert.equal(await run(b), 4);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support async split bundles","suites":["output formats","commonjs"],"updatePoint":{"line":132,"column":42,"index":7541},"line":132,"code":"    it('should support async split bundles', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-split/index.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldOptimize: false\n        }\n      });\n      let index = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('index')).filePath, 'utf8');\n      assert(/Promise\\.resolve\\(require\\(\"\\.\\/async1\\..+?\\.js\"\\)\\)/.test(index));\n      assert(/Promise\\.resolve\\(require\\(\"\\.\\/async2\\..+?\\.js\"\\)\\)/.test(index));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support async split bundles (reexport default)","suites":["output formats","commonjs"],"updatePoint":{"line":143,"column":61,"index":8122},"line":143,"code":"    it('should support async split bundles (reexport default)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-split-reexport-default/index.js'), {\n        mode: 'production'\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js']\n      }, {\n        type: 'js',\n        assets: ['shared.js']\n      }, {\n        type: 'js',\n        assets: ['async1.js']\n      }, {\n        type: 'js',\n        assets: ['async2.js']\n      }]);\n      assert.strictEqual(await run(b), 20579 * 2);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should call init for wrapped modules when codesplitting to to commonjs","suites":["output formats","commonjs"],"updatePoint":{"line":162,"column":78,"index":8710},"line":162,"code":"    it('should call init for wrapped modules when codesplitting to to commonjs', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-wrap-codesplit/a.js'));\n      assert.equal(await run(b), 2);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support sideEffects: false","suites":["output formats","commonjs"],"updatePoint":{"line":166,"column":41,"index":8922},"line":166,"code":"    it('should support sideEffects: false', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-sideeffects/index.js'));\n      let ns = await run(b);\n      assert.equal(typeof ns.test, 'function');\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw an error on missing export with esmodule input and sideEffects: false","suites":["output formats","commonjs"],"updatePoint":{"line":171,"column":90,"index":9224},"line":171,"code":"    it('should throw an error on missing export with esmodule input and sideEffects: false', async function () {\n      let message = \"other.js does not export 'a'\";\n      let source = path.join(__dirname, '/integration/formats/commonjs-sideeffects', 'missing-export.js');\n      await assert.rejects(() => bundle(path.join(__dirname, '/integration/formats/commonjs-sideeffects', 'missing-export.js')), {\n        name: 'BuildError',\n        message,\n        diagnostics: [{\n          message,\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: source,\n            language: 'js',\n            codeHighlights: [{\n              start: {\n                line: 1,\n                column: 10\n              },\n              end: {\n                line: 1,\n                column: 15\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs input","suites":["output formats","commonjs"],"updatePoint":{"line":197,"column":37,"index":10048},"line":197,"code":"    it('should support commonjs input', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-dynamic/index.js'));\n      let dist = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n      assert(dist.includes('Object.assign(module.exports'));\n      let ns = await run(b);\n      assert.equal(typeof ns.test, 'function');\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs requires without interop","suites":["output formats","commonjs"],"updatePoint":{"line":204,"column":56,"index":10475},"line":204,"code":"    it('should support commonjs requires without interop', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-require/index.js'));\n      let dist = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n      assert(dist.includes('= require(\"lodash\")'));\n      let add = await run(b);\n      assert.equal(add(2, 3), 5);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support generating commonjs output with re-exports in entry","suites":["output formats","commonjs"],"updatePoint":{"line":211,"column":74,"index":10898},"line":211,"code":"    it('should support generating commonjs output with re-exports in entry', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-entry-re-export/a.js'));\n      assert.deepEqual(await run(b), {\n        foo: 'foo'\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile workers to statically analyzable URL expressions","suites":["output formats","commonjs"],"updatePoint":{"line":217,"column":71,"index":11172},"line":217,"code":"    it('should compile workers to statically analyzable URL expressions', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/workers-module/index.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          outputFormat: 'commonjs',\n          shouldScopeHoist: true,\n          shouldOptimize: false,\n          isLibrary: true\n        }\n      });\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      let workerBundle = b.getBundles().find(b => b.name.startsWith('dedicated-worker'));\n      let sharedWorkerBundle = b.getBundles().find(b => b.name.startsWith('shared-worker'));\n      assert(contents.includes(`new Worker(new URL(\"${path.basename(workerBundle.filePath)}\", \"file:\" + __filename)`));\n      assert(contents.includes(`new SharedWorker(new URL(\"${path.basename(sharedWorkerBundle.filePath)}\", \"file:\" + __filename)`));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile url: pipeline dependencies to statically analyzable URL expressions for libraries","suites":["output formats","commonjs"],"updatePoint":{"line":233,"column":104,"index":12124},"line":233,"code":"    it('should compile url: pipeline dependencies to statically analyzable URL expressions for libraries', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/worklet/pipeline.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          outputFormat: 'commonjs',\n          shouldScopeHoist: true,\n          shouldOptimize: false,\n          isLibrary: true\n        }\n      });\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes(`new URL(\"${path.basename(b.getBundles()[1].filePath)}\", \"file:\" + __filename)`));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should URL dependencies to statically analyzable URL expressions for libraries","suites":["output formats","commonjs"],"updatePoint":{"line":246,"column":86,"index":12733},"line":246,"code":"    it('should URL dependencies to statically analyzable URL expressions for libraries', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/worklet/url.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          outputFormat: 'commonjs',\n          shouldScopeHoist: true,\n          shouldOptimize: false,\n          isLibrary: true\n        }\n      });\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes(`new URL(\"${path.basename(b.getBundles()[1].filePath)}\", \"file:\" + __filename)`));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support live binding of external modules","suites":["output formats","commonjs"],"updatePoint":{"line":259,"column":55,"index":13306},"line":259,"code":"    it('should support live binding of external modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-live-externals/a.js'));\n      let external = {\n        foo: 1,\n        setFoo(f) {\n          this.foo = f;\n        }\n      };\n      let out = [];\n      await run(b, {\n        require: () => external,\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, [1, 2]);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with SWC helpers","suites":["output formats","commonjs"],"updatePoint":{"line":276,"column":36,"index":13752},"line":276,"code":"    it('should work with SWC helpers', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-helpers/index.js'));\n      let out = [];\n      await run(b, {\n        require,\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out[0].x, new Map());\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (named export)","suites":["output formats","esmodule"],"updatePoint":{"line":289,"column":53,"index":14145},"line":289,"code":"    it('should support esmodule output (named export)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm/named.js'));\n      await assertESMExports(b, {\n        bar: 5,\n        foo: 2\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (default identifier)","suites":["output formats","esmodule"],"updatePoint":{"line":296,"column":59,"index":14397},"line":296,"code":"    it('should support esmodule output (default identifier)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm/default-value.js'));\n      let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(!dist.includes('function')); // no iife\n      await assertESMExports(b, {\n        default: 4\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (default function)","suites":["output formats","esmodule"],"updatePoint":{"line":304,"column":57,"index":14774},"line":304,"code":"    it('should support esmodule output (default function)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm/default-function.js'));\n      assert.strictEqual((await run(b)).default(), 2);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (multiple)","suites":["output formats","esmodule"],"updatePoint":{"line":308,"column":49,"index":15007},"line":308,"code":"    it('should support esmodule output (multiple)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm/multiple.js'));\n      await assertESMExports(b, {\n        a: 2,\n        c: 5,\n        default: 3\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (exporting symbol multiple times)","suites":["output formats","esmodule"],"updatePoint":{"line":316,"column":72,"index":15291},"line":316,"code":"    it('should support esmodule output (exporting symbol multiple times)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm/multiple-times.js'));\n      await assertESMExports(b, {\n        default: 1,\n        foo: 2,\n        other: 1,\n        test: 1\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (re-export)","suites":["output formats","esmodule"],"updatePoint":{"line":325,"column":50,"index":15582},"line":325,"code":"    it('should support esmodule output (re-export)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm/re-export.js'));\n      await assertESMExports(b, {\n        a: 2,\n        c: 5\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (re-export namespace as)","suites":["output formats","esmodule"],"line":332,"code":"    it.skip('should support esmodule output (re-export namespace as)', async function () {","file":"output-formats.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (renaming re-export)","suites":["output formats","esmodule"],"updatePoint":{"line":341,"column":59,"index":16136},"line":341,"code":"    it('should support esmodule output (renaming re-export)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm/re-export-rename.js'));\n      await assertESMExports(b, {\n        foo: 4\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output with external modules (named import)","suites":["output formats","esmodule"],"updatePoint":{"line":347,"column":75,"index":16399},"line":347,"code":"    it('should support esmodule output with external modules (named import)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-external/named.js'));\n      await assertESMExports(b, {\n        bar: 3\n      }, {\n        lodash: () => ({\n          add: (a, b) => a + b\n        })\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output with external modules (named import with same name)","suites":["output formats","esmodule"],"updatePoint":{"line":357,"column":90,"index":16753},"line":357,"code":"    it('should support esmodule output with external modules (named import with same name)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-external/named-same.js'));\n      await assertESMExports(b, {\n        bar: true\n      }, {\n        lodash: () => lodash,\n        'lodash/fp': () => lodashFP\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output with external modules (namespace import)","suites":["output formats","esmodule"],"updatePoint":{"line":366,"column":79,"index":17103},"line":366,"code":"    it('should support esmodule output with external modules (namespace import)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-external/namespace.js'));\n      await assertESMExports(b, {\n        bar: 3\n      }, {\n        lodash: () => lodash\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output with external modules (default import)","suites":["output formats","esmodule"],"updatePoint":{"line":374,"column":77,"index":17410},"line":374,"code":"    it('should support esmodule output with external modules (default import)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-external/default.js'));\n      await assertESMExports(b, {\n        bar: 3\n      }, {\n        lodash: () => lodash\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output with external modules (multiple specifiers)","suites":["output formats","esmodule"],"updatePoint":{"line":382,"column":82,"index":17720},"line":382,"code":"    it('should support esmodule output with external modules (multiple specifiers)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-external/multiple.js'));\n      await assertESMExports(b, {\n        bar: 6\n      }, {\n        lodash: () => lodash\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output with external modules (export)","suites":["output formats","esmodule"],"updatePoint":{"line":390,"column":69,"index":18018},"line":390,"code":"    it('should support esmodule output with external modules (export)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-external/export.js'));\n      await assertESMExports(b, 3, {\n        lodash: () => lodash\n      }, ns => ns.add(1, 2));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output with external modules (re-export)","suites":["output formats","esmodule"],"updatePoint":{"line":396,"column":72,"index":18314},"line":396,"code":"    it('should support esmodule output with external modules (re-export)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-external/re-export.js'));\n      await assertESMExports(b, 3, {\n        lodash: () => lodash\n      }, ns => ns.add(1, 2));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output with external modules (re-export child)","suites":["output formats","esmodule"],"updatePoint":{"line":402,"column":78,"index":18619},"line":402,"code":"    it('should support esmodule output with external modules (re-export child)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-external/re-export-child.js'));\n      await assertESMExports(b, 3, {\n        lodash: () => lodash\n      }, ns => ns.add(1, 2));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing sibling bundles in library mode","suites":["output formats","esmodule"],"updatePoint":{"line":408,"column":64,"index":18916},"line":408,"code":"    it('should support importing sibling bundles in library mode', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-siblings/a.js'));\n      let dist = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n      assert(dist.includes('import \"./index.css\"'));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (skipped exports)","suites":["output formats","esmodule"],"updatePoint":{"line":413,"column":56,"index":19250},"line":413,"code":"    it('should support esmodule output (skipped exports)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-isLibrary-false/skipped.js'));\n      let dist = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n      assert(!dist.includes('foo'));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support interop imports from other bundles","suites":["output formats","esmodule"],"updatePoint":{"line":418,"column":57,"index":19582},"line":418,"code":"    it('should support interop imports from other bundles', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-interop-cross-bundle/a.js'));\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['a.js', 'c.js']\n      }, {\n        type: 'js',\n        assets: ['b.js']\n      }]);\n      let dist = await outputFS.readFile(b.getBundles().find(b => !b.needsStableName).filePath, 'utf8');\n      assert(dist.includes('$parcel$interopDefault'));\n      let ns = await run(b);\n      assert.deepEqual(await ns.default, [123, 123]);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should rename imports that conflict with exports","suites":["output formats","esmodule"],"updatePoint":{"line":432,"column":56,"index":20162},"line":432,"code":"    it('should rename imports that conflict with exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-conflict/a.js'));\n      await assertESMExports(b, {\n        foo: 13\n      }, {\n        foo: () => ({\n          foo: 10\n        })\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support async imports","suites":["output formats","esmodule"],"updatePoint":{"line":442,"column":36,"index":20443},"line":442,"code":"    it('should support async imports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-async/index.js'));\n      let index = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('index')).filePath, 'utf8');\n      assert(/import\\(\"\\.\\/async\\..+?\\.js\"\\)/.test(index));\n      await assertESMExports(b, 4, {}, ns => ns.default);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support dynamic imports with chained reexports","suites":["output formats","esmodule"],"line":451,"code":"    it.skip('should support dynamic imports with chained reexports', async function () {","file":"output-formats.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support dynamic imports with chained reexports II","suites":["output formats","esmodule"],"updatePoint":{"line":456,"column":64,"index":21354},"line":456,"code":"    it('should support dynamic imports with chained reexports II', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-async-chained-reexport2/index.js'));\n      let async = await outputFS.readFile(b.getChildBundles(b.getBundles()[0])[0].filePath, 'utf8');\n      assert(!async.includes('$import$'));\n      await assertESMExports(b, ['index', 'a', 1], {}, ns => ns.default);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw an error on missing export with esmodule output and sideEffects: false","suites":["output formats","esmodule"],"updatePoint":{"line":462,"column":91,"index":21805},"line":462,"code":"    it('should throw an error on missing export with esmodule output and sideEffects: false', async function () {\n      let message = \"b.js does not export 'a'\";\n      let source = path.join(__dirname, 'integration/formats/esm-sideeffects', 'missing-export.js');\n      await assert.rejects(() => bundle(path.join(__dirname, 'integration/formats/esm-sideeffects/missing-export.js')), {\n        name: 'BuildError',\n        message,\n        diagnostics: [{\n          message,\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: source,\n            language: 'js',\n            codeHighlights: [{\n              start: {\n                line: 1,\n                column: 10\n              },\n              end: {\n                line: 1,\n                column: 15\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support async split bundles","suites":["output formats","esmodule"],"updatePoint":{"line":488,"column":42,"index":22615},"line":488,"code":"    it('should support async split bundles', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-split/index.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldOptimize: false\n        }\n      });\n      let index = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('index')).filePath, 'utf8');\n      assert(/import\\(\"\\.\\/async1\\..+?\\.js\"\\)/.test(index));\n      assert(/import\\(\"\\.\\/async2\\..+?\\.js\"\\)/.test(index));\n      await assertESMExports(b, true, {\n        lodash: () => lodash,\n        react: () => react\n      }, ns => ns.default);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should call init for wrapped modules when codesplitting to esmodules","suites":["output formats","esmodule"],"updatePoint":{"line":503,"column":76,"index":23289},"line":503,"code":"    it('should call init for wrapped modules when codesplitting to esmodules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-wrap-codesplit/a.js'));\n      let ns = await run(b);\n      // TODO: https://github.com/parcel-bundler/parcel/issues/5459\n      assert.deepStrictEqual(await ns.default, 2);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support async split bundles for workers","suites":["output formats","esmodule"],"updatePoint":{"line":509,"column":54,"index":23620},"line":509,"code":"    it('should support async split bundles for workers', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-split-worker/index.html'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldOptimize: false\n        }\n      });\n      let workerBundle = nullthrows(b.getBundles().find(b => b.env.context === 'web-worker'));\n      let workerBundleContents = await outputFS.readFile(workerBundle.filePath, 'utf8');\n      let asyncBundle = b.getChildBundles(workerBundle).find(b => b.filePath.includes('async'));\n      let syncBundle = b.getReferencedBundles(workerBundle).find(b => !b.filePath.includes('async'));\n      assert(workerBundleContents.includes(`import \"./${path.basename(syncBundle.filePath)}\"`));\n      assert(workerBundleContents.includes(path.basename(asyncBundle.filePath)));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support building esmodules for browser targets","suites":["output formats","esmodule"],"updatePoint":{"line":523,"column":61,"index":24489},"line":523,"code":"    it('should support building esmodules for browser targets', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-browser/index.html'));\n      let html = await outputFS.readFile(b.getBundles().find(b => b.type === 'html').filePath, 'utf8');\n      assert(html.includes('<script type=\"module\" src=\"/index'));\n      let entry = await outputFS.readFile(b.getBundles().find(b => path.basename(b.filePath) === html.match(/src=\"\\/(.*?)\"/)[1]).filePath, 'utf8');\n      let asyncBundle = b.getBundles().find(bundle => bundle.name.startsWith('async'));\n      assert(entry.includes(`import(\"./${path.basename(asyncBundle.filePath)}\")`));\n      let res = await run(b, {\n        output: null\n      }, {\n        require: false\n      });\n      assert.equal(await res.output, 4);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support using an import polyfill for older browsers","suites":["output formats","esmodule"],"updatePoint":{"line":537,"column":66,"index":25310},"line":537,"code":"    it('should support using an import polyfill for older browsers', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-browser/index.html'), {\n        defaultTargetOptions: {\n          engines: {\n            browsers: [\n            // Implements es modules but not dynamic imports\n            'Chrome 61']\n          }\n        }\n      });\n      let html = await outputFS.readFile(b.getBundles().find(b => b.type === 'html').filePath, 'utf8');\n      assert(html.includes('<script type=\"module\" src=\"/index'));\n      let entry = await outputFS.readFile(b.getBundles().find(b => path.basename(b.filePath) === html.match(/src=\"\\/(.*?)\"/)[1]).filePath, 'utf8');\n      assert(entry.includes('function importModule'));\n      let asyncBundle = b.getBundles().find(bundle => bundle.name.startsWith('async'));\n      assert(new RegExp(`getBundleURL\\\\(\"[a-zA-Z0-9]+\"\\\\) \\\\+ \"` + path.basename(asyncBundle.filePath) + '\"').test(entry));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support building esmodules with css imports","suites":["output formats","esmodule"],"updatePoint":{"line":554,"column":58,"index":26277},"line":554,"code":"    it('should support building esmodules with css imports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-browser-css/index.html'));\n      let html = await outputFS.readFile(b.getBundles().find(b => b.type === 'html').filePath, 'utf8');\n      assert(html.includes('<script type=\"module\" src=\"/index'));\n      assert(html.includes('<link rel=\"stylesheet\" href=\"/index'));\n      let entry = await outputFS.readFile(b.getBundles().find(b => path.basename(b.filePath) === html.match(/src=\"\\/(.*?)\"/)[1]).filePath, 'utf8');\n      let bundles = b.getBundles();\n      let asyncJsBundle = bundles.find(bundle => bundle.type === 'js' && bundle.name.startsWith('async'));\n      let asyncCssBundle = bundles.find(bundle => bundle.type === 'css' && bundle.name.startsWith('async'));\n      assert(new RegExp('Promise.all\\\\(\\\\[\\\\n.+?new URL\\\\(\"' + path.basename(asyncCssBundle.filePath) + '\", import.meta.url\\\\).toString\\\\(\\\\)\\\\),\\\\n\\\\s*import\\\\(\"\\\\.\\\\/' + path.basename(asyncJsBundle.filePath) + '\"\\\\)\\\\n\\\\s*\\\\]\\\\)').test(entry));\n      let async = await outputFS.readFile(b.getBundles().find(b => b.type === 'js' && b.name.startsWith('async')).filePath, 'utf8');\n      assert(!async.includes('.css\"'));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support building esmodules with split bundles","suites":["output formats","esmodule"],"updatePoint":{"line":567,"column":60,"index":27527},"line":567,"code":"    it('should support building esmodules with split bundles', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-browser-split-bundle/index.html'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldOptimize: false\n        }\n      });\n      let html = await outputFS.readFile(b.getBundles().find(b => b.type === 'html').filePath, 'utf8');\n      assert(html.includes('<script type=\"module\" src=\"/index'));\n      let bundles = b.getBundles();\n      let entry = await outputFS.readFile(bundles.find(b => path.basename(b.filePath) === html.match(/src=\"\\/(.*?)\"/)[1]).filePath, 'utf8');\n      let sharedBundle = bundles.find(b => b.getEntryAssets().length === 0);\n      let async1Bundle = bundles.find(b => b.name.startsWith('async1') && b.id !== sharedBundle.id);\n      let async2Bundle = bundles.find(b => b.name.startsWith('async2'));\n      for (let bundle of [async1Bundle, async2Bundle]) {\n        // async import both bundles in parallel for performance\n        assert(new RegExp(`import\\\\(\"\\\\./\" \\\\+ .+\\\\.resolve\\\\(\"${sharedBundle.publicId}\"\\\\)\\\\),\\\\n\\\\s*import\\\\(\"./\" \\\\+ .+\\\\.resolve\\\\(\"${bundle.publicId}\"\\\\)\\\\)`).test(entry));\n      }\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create correct bundle import for reexports","suites":["output formats","esmodule"],"updatePoint":{"line":586,"column":57,"index":28744},"line":586,"code":"    it('should create correct bundle import for reexports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-bundle-import-reexport/index.js'));\n      await assertESMExports(b, ['!!!index!!!', 'DiagramVersion: !!!some name!!!'], {}, ns => ns.default);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support generating ESM from CommonJS","suites":["output formats","esmodule"],"updatePoint":{"line":590,"column":51,"index":29043},"line":590,"code":"    it('should support generating ESM from CommonJS', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-esm/index.js'));\n      let ns = await run(b, {}, {}, {\n        lodash: () => lodash\n      });\n      assert.strictEqual(ns.default(1, 2), 3);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support re-assigning to module.exports","suites":["output formats","esmodule"],"updatePoint":{"line":597,"column":53,"index":29347},"line":597,"code":"    it('should support re-assigning to module.exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-esm/re-assign.js'));\n      let ns = await run(b);\n      assert.deepStrictEqual({\n        ...ns\n      }, {\n        default: 'xyz'\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"doesn't support require.resolve calls for excluded assets without commonjs","suites":["output formats","esmodule"],"line":606,"code":"    it.skip(\"doesn't support require.resolve calls for excluded assets without commonjs\", async function () {","file":"output-formats.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support generating commonjs output with re-exports in entry","suites":["output formats","esmodule"],"updatePoint":{"line":632,"column":74,"index":30525},"line":632,"code":"    it('should support generating commonjs output with re-exports in entry', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-esm-entry-re-export/a.js'));\n      let ns = await run(b);\n      assert.deepEqual({\n        ...ns\n      }, {\n        default: {\n          default: 'default'\n        }\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support rewriting filename and importing path","suites":["output formats","esmodule"],"updatePoint":{"line":643,"column":60,"index":30871},"line":643,"code":"    it('should support rewriting filename and importing path', async function () {\n      let input = path.join(__dirname, '/integration/formats/esm-filename-import/index.js');\n      let b = await bundle(input);\n      let ns = await run(b);\n      assert.deepEqual(ns.foo, input);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should rename shadowed imported specifiers to something unique","suites":["output formats","esmodule"],"updatePoint":{"line":649,"column":70,"index":31168},"line":649,"code":"    it('should rename shadowed imported specifiers to something unique', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-import-shadow/a.mjs'));\n      let _b = await import(pathToFileURL(path.join(__dirname, '/integration/formats/esm-import-shadow/node_modules/b/index.mjs')).toString());\n      let ns = await run(b, {}, {}, {\n        b: () => _b\n      });\n      let [useContext] = ns.createContext('Hello');\n      assert.strictEqual(useContext(), 'Hello World');\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should rename shadowed exports to something unique","suites":["output formats","esmodule"],"updatePoint":{"line":658,"column":58,"index":31674},"line":658,"code":"    it('should rename shadowed exports to something unique', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-export-shadow/a.mjs'));\n      let ns = await run(b);\n      assert.strictEqual(ns.fib(5), 8);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support ESM output from CJS input","suites":["output formats","esmodule"],"updatePoint":{"line":663,"column":48,"index":31920},"line":663,"code":"    it('should support ESM output from CJS input', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-cjs/a.js'));\n      let ns = await run(b);\n      assert.deepEqual(ns.test, true);\n      assert.deepEqual(ns.default, {\n        test: true\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support outputting .mjs files","suites":["output formats","esmodule"],"updatePoint":{"line":671,"column":44,"index":32216},"line":671,"code":"    it('should support outputting .mjs files', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-mjs/index.js'));\n      let filePath = b.getBundles()[0].filePath;\n      assert(filePath.endsWith('.mjs'));\n      let output = await outputFS.readFile(filePath, 'utf8');\n      assert(output.includes('import '));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support outputting ESM in .js files with \"type\": \"module\"","suites":["output formats","esmodule"],"updatePoint":{"line":678,"column":72,"index":32604},"line":678,"code":"    it('should support outputting ESM in .js files with \"type\": \"module\"', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-type-module/index.js'));\n      let filePath = b.getBundles()[0].filePath;\n      assert(filePath.endsWith('.js'));\n      let output = await outputFS.readFile(filePath, 'utf8');\n      assert(output.includes('import '));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":".cjs extension should override \"type\": \"module\"","suites":["output formats","esmodule"],"updatePoint":{"line":685,"column":55,"index":32982},"line":685,"code":"    it('.cjs extension should override \"type\": \"module\"', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/cjs-type-module/index.js'));\n      let filePath = b.getBundles()[0].filePath;\n      assert(filePath.endsWith('.cjs'));\n      let output = await outputFS.readFile(filePath, 'utf8');\n      assert(!output.includes('import '));\n      assert(output.includes('require('));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile workers to statically analyzable URL expressions","suites":["output formats","esmodule"],"updatePoint":{"line":693,"column":71,"index":33421},"line":693,"code":"    it('should compile workers to statically analyzable URL expressions', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/workers-module/index.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          outputFormat: 'esmodule',\n          shouldScopeHoist: true,\n          shouldOptimize: false,\n          isLibrary: true\n        }\n      });\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      let workerBundle = b.getBundles().find(b => b.name.startsWith('dedicated-worker'));\n      let sharedWorkerBundle = b.getBundles().find(b => b.name.startsWith('shared-worker'));\n      assert(contents.includes(`new Worker(new URL(\"${path.basename(workerBundle.filePath)}\", import.meta.url)`));\n      assert(contents.includes(`new SharedWorker(new URL(\"${path.basename(sharedWorkerBundle.filePath)}\", import.meta.url)`));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile url: pipeline dependencies to statically analyzable URL expressions for libraries","suites":["output formats","esmodule"],"updatePoint":{"line":709,"column":104,"index":34363},"line":709,"code":"    it('should compile url: pipeline dependencies to statically analyzable URL expressions for libraries', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/worklet/pipeline.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          outputFormat: 'esmodule',\n          shouldScopeHoist: true,\n          shouldOptimize: false,\n          isLibrary: true\n        }\n      });\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes(`new URL(\"${path.basename(b.getBundles()[1].filePath)}\", import.meta.url)`));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should URL dependencies to statically analyzable URL expressions for libraries","suites":["output formats","esmodule"],"updatePoint":{"line":722,"column":86,"index":34967},"line":722,"code":"    it('should URL dependencies to statically analyzable URL expressions for libraries', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/worklet/url.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          outputFormat: 'esmodule',\n          shouldScopeHoist: true,\n          shouldOptimize: false,\n          isLibrary: true\n        }\n      });\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes(`new URL(\"${path.basename(b.getBundles()[1].filePath)}\", import.meta.url)`));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support generating ESM from universal module wrappers","suites":["output formats","esmodule"],"updatePoint":{"line":736,"column":66,"index":35552},"line":736,"code":"  it('should support generating ESM from universal module wrappers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-esm/universal-library.js'));\n    let ns = await run(b);\n    assert.deepEqual({\n      ...ns\n    }, {\n      default: {\n        a: 2\n      }\n    });\n  });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"doesn't overwrite used global variables","suites":["output formats","esmodule"],"updatePoint":{"line":747,"column":45,"index":35849},"line":747,"code":"  it(\"doesn't overwrite used global variables\", async function () {\n    let b = await bundle(path.join(__dirname, '/integration/formats/conflict-global/index.js'));\n    let cjs = b.getBundles().find(b => b.type === 'js' && b.env.outputFormat === 'commonjs');\n    let calls = [];\n    assert.deepEqual(await runBundle(b, cjs, {\n      foo(v) {\n        calls.push(v);\n      }\n    }), {\n      Map: 2\n    });\n    assert.deepEqual(calls, [[['a', 10]]]);\n    calls = [];\n    assert.deepEqual(await runBundle(b, cjs, {\n      foo(v) {\n        calls.push(v);\n      }\n    }), {\n      Map: 2\n    });\n    assert.deepEqual(calls, [[['a', 10]]]);\n  });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support split bundles between main script and workers","suites":["output formats","global"],"line":770,"code":"    it.skip('should support split bundles between main script and workers', async function () {","file":"output-formats.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support async split bundles for workers","suites":["output formats","global"],"updatePoint":{"line":809,"column":54,"index":37679},"line":809,"code":"    it('should support async split bundles for workers', async function () {\n      await bundle(path.join(__dirname, '/integration/formats/global-split-worker-async/index.html'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldOptimize: false\n        }\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw with external modules","suites":["output formats","global"],"updatePoint":{"line":817,"column":42,"index":37968},"line":817,"code":"    it('should throw with external modules', async function () {\n      let message = 'External modules are not supported when building for browser';\n      let source = path.join(__dirname, 'integration/formats/global-external/index.js');\n      await assert.rejects(() => bundle(source), {\n        name: 'BuildError',\n        message,\n        diagnostics: [{\n          message,\n          origin: '@parcel/packager-js',\n          codeFrames: [{\n            filePath: source,\n            codeHighlights: [{\n              start: {\n                line: 1,\n                column: 21\n              },\n              end: {\n                line: 1,\n                column: 28\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can be required at an entry script and transform following requires","suites":["@parcel/register"],"updatePoint":{"line":5,"column":73,"index":212},"line":5,"code":"  it('can be required at an entry script and transform following requires', () => {\n    assert.equal(execSync(`node ${path.join(__dirname, 'integration', 'parcel-register', 'entry.js')}`), '123');\n  });","file":"parcel-register.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"can transform with --r and --require","suites":["@parcel/register"],"updatePoint":{"line":8,"column":42,"index":384},"line":8,"code":"  it('can transform with --r and --require', () => {\n    assert.equal(execSync(`node -r @parcel/register ${path.join(__dirname, 'integration', 'parcel-register', 'index.js')}`), '123');\n  });","file":"parcel-register.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"enables Parcel's resolver in node","suites":["@parcel/register"],"updatePoint":{"line":11,"column":39,"index":573},"line":11,"code":"  it(\"enables Parcel's resolver in node\", () => {\n    let [foo, resolved] = execSync(`node -r @parcel/register ${path.join(__dirname, 'integration', 'parcel-register', 'resolver.js')}`, {\n      cwd: path.join(__dirname, 'integration', 'parcel-register')\n    }).toString().split('\\n');\n    assert.equal(foo, 'foo');\n    assert.equal(resolved, path.join(__dirname, 'integration', 'parcel-register', 'foo.js'));\n  });","file":"parcel-register.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"can be disposed of, which reverts resolving","suites":["@parcel/register"],"updatePoint":{"line":18,"column":49,"index":998},"line":18,"code":"  it('can be disposed of, which reverts resolving', () => {\n    try {\n      execSync(`node ${path.join(__dirname, 'integration', 'parcel-register', 'dispose-resolve.js')}`, {\n        cwd: path.join(__dirname, 'integration', 'parcel-register'),\n        stdio: 'pipe'\n      }).toString().split('\\n');\n    } catch (e) {\n      assert.equal(e.stdout.toString().trim(), path.join(__dirname, 'integration', 'parcel-register', 'foo.js'));\n      assert(e.stderr.includes(\"Error: Cannot find module '~foo.js'\"));\n      return;\n    }\n\n    // $FlowFixMe\n    assert.fail();\n  });","file":"parcel-register.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"can be disposed of, which reverts transforming","suites":["@parcel/register"],"updatePoint":{"line":33,"column":52,"index":1568},"line":33,"code":"  it('can be disposed of, which reverts transforming', () => {\n    try {\n      execSync(`node ${path.join(__dirname, 'integration', 'parcel-register', 'dispose-transform.js')}`, {\n        cwd: path.join(__dirname, 'integration', 'parcel-register'),\n        stdio: 'pipe'\n      }).toString().split('\\n');\n    } catch (e) {\n      assert.equal(e.stdout.toString().trim(), '123');\n      assert(e.stderr.includes('SyntaxError: Unexpected identifier'));\n      return;\n    }\n\n    // $FlowFixMe\n    assert.fail();\n  });","file":"parcel-register.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support case-insensitive file extension","suites":["parser"],"updatePoint":{"line":5,"column":52,"index":223},"line":5,"code":"  it('should support case-insensitive file extension', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/parser-case-insensitive-ext/index.html'));\n    await assertBundleTree(b, {\n      name: 'index.html',\n      assets: ['index.html'],\n      childBundles: [{\n        type: 'svg',\n        assets: ['icons.SVG'],\n        childBundles: []\n      }, {\n        type: 'css',\n        assets: ['index.cSs'],\n        childBundles: [{\n          type: 'map'\n        }]\n      }, {\n        type: 'html',\n        assets: ['other.HTM'],\n        childBundles: [{\n          type: 'js',\n          assets: ['index.js'],\n          childBundles: [{\n            type: 'map'\n          }]\n        }]\n      }]\n    });\n    let files = await fs.readdir(path.join(__dirname, '/dist'));\n    let html = await fs.readFile(path.join(__dirname, '/dist/index.html'));\n    for (let file of files) {\n      let ext = file.match(/\\.([0-9a-z]+)(?:[?#]|$)/i)[0];\n      if (file !== 'index.html' && ext !== '.map') {\n        assert(html.includes(file));\n      }\n    }\n  });","file":"parser.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"continue transformer pipeline on type change that doesn't change the pipeline","suites":["plugin"],"updatePoint":{"line":7,"column":83,"index":375},"line":7,"code":"  it(\"continue transformer pipeline on type change that doesn't change the pipeline\", async function () {\n    await bundle(path.join(__dirname, '/integration/pipeline-type-change/index.ini'));\n    let output = await fs.readFile(path.join(distDir, 'index.txt'), 'utf8');\n    assert.equal(output, `INPUT\nparcel-transformer-a\nparcel-transformer-b`);\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should allow optimizer plugins to change the output file type","suites":["plugin"],"updatePoint":{"line":14,"column":67,"index":712},"line":14,"code":"  it('should allow optimizer plugins to change the output file type', async function () {\n    await bundle(path.join(__dirname, '/integration/optimizer-changing-type/index.js'));\n    assert.deepEqual(fs.readdirSync(distDir), ['index.test']);\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should allow resolver plugins to disable deferring","suites":["plugin"],"updatePoint":{"line":18,"column":56,"index":949},"line":18,"code":"  it('should allow resolver plugins to disable deferring', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolver-canDefer/index.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.js', 'index.js', 'a.js', 'b.js']\n    }]);\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should allow resolvers to return changes for dependency.meta","suites":["plugin"],"updatePoint":{"line":27,"column":66,"index":1275},"line":27,"code":"  it('should allow resolvers to return changes for dependency.meta', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolver-dependency-meta/a.js'), {\n      shouldDisableCache: false,\n      shouldContentHash: false,\n      inputFS: overlayFS\n    });\n    let calls = [];\n    await run(b, {\n      sideEffect(v) {\n        calls.push(v);\n      }\n    });\n    assert.deepEqual(calls, [1234]);\n    await overlayFS.writeFile(path.join(__dirname, '/integration/resolver-dependency-meta/a.js'), (await overlayFS.readFile(path.join(__dirname, '/integration/resolver-dependency-meta/a.js'), 'utf8')) + '\\n// abc');\n    b = await bundle(path.join(__dirname, '/integration/resolver-dependency-meta/a.js'), {\n      shouldDisableCache: false,\n      shouldContentHash: false,\n      inputFS: overlayFS\n    });\n    calls = [];\n    await run(b, {\n      sideEffect(v) {\n        calls.push(v);\n      }\n    });\n    assert.deepEqual(calls, [1234]);\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"invalidate the cache based on loadBundleConfig in a packager","suites":["plugin"],"updatePoint":{"line":54,"column":66,"index":2238},"line":54,"code":"  it('invalidate the cache based on loadBundleConfig in a packager', async function () {\n    let fixture = path.join(__dirname, '/integration/packager-loadBundleConfig');\n    let entry = path.join(fixture, 'index.html');\n    let b = await bundler(entry, {\n      inputFS: overlayFS,\n      shouldDisableCache: false\n    });\n    let subscription = await b.watch();\n    try {\n      let bundleEvent = await getNextBuild(b);\n      invariant(bundleEvent.type === 'buildSuccess');\n      assert.strictEqual(await overlayFS.readFile(nullthrows(bundleEvent.bundleGraph.getBundles().find(b => b.getMainEntry()?.filePath.endsWith('a.txt'))).filePath, 'utf8'), `Bundles: a.txt. Contents: Hello from a\\n`);\n      await overlayFS.copyFile(path.join(fixture, 'index.2.html'), entry);\n      bundleEvent = await getNextBuild(b);\n      invariant(bundleEvent.type === 'buildSuccess');\n      assert.strictEqual(await overlayFS.readFile(nullthrows(bundleEvent.bundleGraph.getBundles().find(b => b.getMainEntry()?.filePath.endsWith('a.txt'))).filePath, 'utf8'), `Bundles: a.txt,b.txt. Contents: Hello from a\\n`);\n      assert.strictEqual(await overlayFS.readFile(nullthrows(bundleEvent.bundleGraph.getBundles().find(b => b.getMainEntry()?.filePath.endsWith('b.txt'))).filePath, 'utf8'), `Bundles: a.txt,b.txt. Contents: Hello from b\\n`);\n    } finally {\n      await subscription.unsubscribe();\n    }\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"invalidate the cache based on loadConfig in a packager","suites":["plugin"],"updatePoint":{"line":75,"column":60,"index":3614},"line":75,"code":"  it('invalidate the cache based on loadConfig in a packager', async function () {\n    let fixture = path.join(__dirname, '/integration/packager-loadConfig');\n    let entry = path.join(fixture, 'index.txt');\n    let config = path.join(fixture, 'foo.config.json');\n    let b = await bundle(entry, {\n      inputFS: overlayFS,\n      shouldDisableCache: false\n    });\n    assert.strictEqual(await overlayFS.readFile(b.getBundles()[0].filePath, 'utf8'), '1234');\n    await overlayFS.writeFile(config, JSON.stringify({\n      contents: 'xyz'\n    }));\n    b = await bundle(entry, {\n      inputFS: overlayFS,\n      shouldDisableCache: false\n    });\n    assert.strictEqual(await overlayFS.readFile(b.getBundles()[0].filePath, 'utf8'), 'xyz');\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"merges symbol information when applying runtime assets","suites":["plugin"],"updatePoint":{"line":93,"column":60,"index":4353},"line":93,"code":"  it('merges symbol information when applying runtime assets', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/runtime-symbol-merging/entry.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      },\n      mode: 'production'\n    });\n    assert(!findAsset(b, 'index.js'));\n    assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'a.js')))), new Set(['a']));\n    assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'b.js')))), new Set(['b']));\n    let calls = [];\n    await run(b, {\n      call(v) {\n        calls.push(v);\n      }\n    });\n    assert.deepStrictEqual(calls, [789, 123]);\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"properly excludes assets that are excluded and deferred by both app code and runtimes","suites":["plugin"],"updatePoint":{"line":111,"column":91,"index":5063},"line":111,"code":"  it('properly excludes assets that are excluded and deferred by both app code and runtimes', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/runtime-deferred-excluded/index.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let calls = [];\n    let output = await run(b, {\n      f(v) {\n        calls.push(v);\n      }\n    });\n    assert.deepStrictEqual(\n    // `output` is from the vm and so is not deepStrictEqual\n    [...output], ['index', 'used']);\n    assert.deepStrictEqual(calls, ['used']);\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"handles multiple assets returned by a transformer","suites":["plugin"],"updatePoint":{"line":128,"column":55,"index":5599},"line":128,"code":"  it('handles multiple assets returned by a transformer', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/multi-asset-transformer/index.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assert.equal(await run(b), 2);\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should allow resolvers to invalidateOnEnvChange","suites":["plugin"],"updatePoint":{"line":136,"column":53,"index":5891},"line":136,"code":"  it('should allow resolvers to invalidateOnEnvChange', async () => {\n    async function assertAsset(replacedCode) {\n      let b = await bundle(path.join(__dirname, '/integration/resolver-can-invalidateonenvchange/index.js'), {\n        shouldDisableCache: false,\n        inputFS: overlayFS,\n        env: {\n          replacedCode\n        }\n      });\n      let code = await b.getBundles()[0].getEntryAssets()[0].getCode();\n      assert(code.indexOf(replacedCode) !== -1);\n    }\n    await assertAsset('const replaced = 1;');\n    await assertAsset('const replaced = 2;');\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should defer to the pnp resolution when needed","suites":["pnp"],"updatePoint":{"line":8,"column":52,"index":295},"line":8,"code":"  it('should defer to the pnp resolution when needed', async function () {\n    let dir = path.join(__dirname, 'integration/pnp-require');\n    let origPnpVersion = process.versions.pnp;\n    process.versions.pnp = 42;\n    let origModuleResolveFilename = Module._resolveFilename;\n    Module.findPnpApi = () => require(path.join(dir, '.pnp.js'));\n    Module._resolveFilename = (name, ...args) => name === 'pnpapi' ? path.join(dir, '.pnp.js') : origModuleResolveFilename(name, ...args);\n    let origReadFileSync = inputFS.readFileSync;\n    inputFS.readFileSync = (p, ...args) => {\n      return origReadFileSync.call(inputFS, p.replace(ZIPFS, ''), ...args);\n    };\n    let origRealpathSync = fs.realpathSync;\n    inputFS.realpathSync = (p, ...args) => {\n      return origRealpathSync.call(inputFS, p.replace(ZIPFS, ''), ...args);\n    };\n    let origStatSync = inputFS.statSync;\n    inputFS.statSync = (p, ...args) => {\n      return origStatSync.call(inputFS, p.replace(ZIPFS, ''), ...args);\n    };\n    try {\n      let b = await bundle(path.join(dir, 'index.js'));\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js', 'local.js', 'index.js']\n      }]);\n      let output = await run(b);\n      assert.equal(output(), 3);\n    } finally {\n      process.versions.pnp = origPnpVersion;\n      Module._resolveFilename = origModuleResolveFilename;\n      inputFS.readFileSync = origReadFileSync;\n      inputFS.statSync = origStatSync;\n      inputFS.realpathSync = origRealpathSync;\n    }\n  });","file":"pnp.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing Node builtin modules from npm when requested","suites":["pnp"],"updatePoint":{"line":43,"column":75,"index":1823},"line":43,"code":"  it('should support importing Node builtin modules from npm when requested', async function () {\n    let dir = path.join(__dirname, 'integration/pnp-builtin');\n    let origPnpVersion = process.versions.pnp;\n    process.versions.pnp = 42;\n    let origModuleResolveFilename = Module._resolveFilename;\n    Module.findPnpApi = () => require(path.join(dir, '.pnp.js'));\n    Module._resolveFilename = (name, ...args) => name === 'pnpapi' ? path.join(dir, '.pnp.js') : origModuleResolveFilename(name, ...args);\n    try {\n      let b = await bundle(path.join(dir, 'index.js'));\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js', 'local.js', 'index.js']\n      }]);\n      let output = await run(b);\n      assert.equal(output(), 3);\n    } finally {\n      process.versions.pnp = origPnpVersion;\n      Module._resolveFilename = origModuleResolveFilename;\n    }\n  });","file":"pnp.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build successfully with only postcss-modules config","suites":["postcss"],"updatePoint":{"line":6,"column":64,"index":363},"line":6,"code":"  it('should build successfully with only postcss-modules config', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-modules-config/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['foo.css', 'foo.js', 'index.css', 'index.js']\n    }, {\n      name: 'index.css',\n      assets: ['foo.css', 'index.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let value = output();\n    assert(/foo_[0-9a-z]/.test(value));\n    let cssClass = value.match(/(foo_[0-9a-z])/)[1];\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes(`.${cssClass}`));\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build successfully with only postcss-modules config in package.json","suites":["postcss"],"updatePoint":{"line":23,"column":80,"index":1070},"line":23,"code":"  it('should build successfully with only postcss-modules config in package.json', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-modules-config-package/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['foo.css', 'foo.js', 'index.css', 'index.js']\n    }, {\n      name: 'index.css',\n      assets: ['foo.css', 'index.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let value = output();\n    assert(/foo_[0-9a-z]/.test(value));\n    let cssClass = value.match(/(foo_[0-9a-z])/)[1];\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes(`.${cssClass}`));\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming with postcss twice with the same result","suites":["postcss"],"updatePoint":{"line":40,"column":73,"index":1778},"line":40,"code":"  it('should support transforming with postcss twice with the same result', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-plugins/index.js'));\n    let c = await bundle(path.join(__dirname, '/integration/postcss-plugins/index2.js'));\n    let [run1, run2] = await Promise.all([run(b), run(c)]);\n    assert.equal(run1(), run2());\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming declarations with missing source","suites":["postcss"],"updatePoint":{"line":46,"column":66,"index":2140},"line":46,"code":"  it('should support transforming declarations with missing source', async () => {\n    await bundle(path.join(__dirname, '/integration/postcss-plugins-decl/index.css'));\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('url(\"data:image/gif;base64,quotes\")'));\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should automatically install postcss plugins if needed","suites":["postcss"],"updatePoint":{"line":51,"column":60,"index":2455},"line":51,"code":"  it('should automatically install postcss plugins if needed', async () => {\n    let inputDir = path.join(__dirname, '/input');\n    await outputFS.rimraf(inputDir);\n    await ncp(path.join(__dirname, '/integration/postcss-autoinstall/npm'), inputDir);\n    let packageInstaller = new MockPackageInstaller();\n    packageInstaller.register('postcss-test', inputFS, path.join(__dirname, '/integration/postcss-autoinstall/postcss-test'));\n\n    // The package manager uses an overlay filesystem, which performs writes to\n    // an in-memory fs and reads first from memory, then falling back to the real fs.\n    let packageManager = new NodePackageManager(overlayFS, inputDir, packageInstaller);\n    let distDir = path.join(outputFS.cwd(), 'dist');\n    await bundle(path.join(__dirname, '/input/index.css'), {\n      inputFS: overlayFS,\n      packageManager,\n      shouldAutoInstall: true,\n      defaultTargetOptions: {\n        distDir\n      }\n    });\n\n    // cssnext was installed\n    let pkg = JSON.parse(await outputFS.readFile(path.join(__dirname, '/input/package.json'), 'utf8'));\n    assert(pkg.devDependencies['postcss-test']);\n\n    // postcss-test is applied\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('background: green'));\n\n    // Increase the timeout for just this test. It takes a while with npm.\n    // This method works with arrow functions, and doesn't seem to be documented\n    // on the main Mocha docs.\n    // https://stackoverflow.com/questions/15971167/how-to-increase-timeout-for-a-single-test-case-in-mocha\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support using postcss for importing","suites":["postcss"],"updatePoint":{"line":85,"column":48,"index":4032},"line":85,"code":"  it('should support using postcss for importing', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-import/style.css'));\n    assertBundles(b, [{\n      name: 'style.css',\n      assets: ['style.css']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'style.css'), 'utf8');\n    assert.equal(css.split('red').length - 1, 1);\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support using a postcss config in package.json","suites":["postcss"],"updatePoint":{"line":94,"column":59,"index":4425},"line":94,"code":"  it('should support using a postcss config in package.json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-config-package/style.css'));\n    assertBundles(b, [{\n      name: 'style.css',\n      assets: ['style.css']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'style.css'), 'utf8');\n    assert(/background-color:\\s*red/.test(css));\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should support postcss.config.js config file with PostCSS 7 plugin","suites":["postcss"],"updatePoint":{"line":103,"column":72,"index":4838},"line":103,"code":"  it('Should support postcss.config.js config file with PostCSS 7 plugin', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-js-config-7/style.css'));\n    assertBundles(b, [{\n      name: 'style.css',\n      assets: ['style.css']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'style.css'), 'utf8');\n    assert(css.includes('background-color: red;'));\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should support postcss.config.js config file with PostCSS 8 plugin","suites":["postcss"],"updatePoint":{"line":112,"column":72,"index":5251},"line":112,"code":"  it('Should support postcss.config.js config file with PostCSS 8 plugin', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-js-config-8/style.css'));\n    assertBundles(b, [{\n      name: 'style.css',\n      assets: ['style.css']\n    }]);\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support dir-dependency messages from plugins","suites":["postcss"],"updatePoint":{"line":119,"column":57,"index":5517},"line":119,"code":"  it('should support dir-dependency messages from plugins', async function () {\n    let inputDir = path.join(__dirname, '/input', Math.random().toString(36).slice(2));\n    await inputFS.mkdirp(inputDir);\n    await inputFS.ncp(path.join(__dirname, '/integration/postcss-dir-dependency'), inputDir);\n    let b = await bundler(path.join(inputDir, 'index.css'));\n    let subscription = await b.watch();\n    let buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    let contents = await outputFS.readFile(buildEvent.bundleGraph.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('background: linear-gradient(green, pink), linear-gradient(red, orange)'));\n\n    // update\n    await inputFS.writeFile(path.join(inputDir, 'backgrounds', 'green.txt'), 'linear-gradient(purple, orange)');\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    contents = await outputFS.readFile(buildEvent.bundleGraph.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('background: linear-gradient(purple, orange), linear-gradient(red, orange)'));\n\n    // create\n    await inputFS.writeFile(path.join(inputDir, 'backgrounds', 'orange.txt'), 'linear-gradient(orange, purple)');\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    contents = await outputFS.readFile(buildEvent.bundleGraph.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('background: linear-gradient(purple, orange), linear-gradient(orange, purple), linear-gradient(red, orange)'));\n\n    // delete\n    await inputFS.unlink(path.join(inputDir, 'backgrounds', 'red.txt'));\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    contents = await outputFS.readFile(buildEvent.bundleGraph.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('background: linear-gradient(purple, orange), linear-gradient(orange, purple)'));\n    await subscription.unsubscribe();\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw an error with code frame when .postcssrc is invalid","suites":["postcss"],"updatePoint":{"line":152,"column":70,"index":7543},"line":152,"code":"  it('should throw an error with code frame when .postcssrc is invalid', async function () {\n    let configFilePath = path.join(__dirname, '/integration/postcss-modules-config-invalid/.postcssrc');\n    let code = await inputFS.readFile(configFilePath, 'utf8');\n    await assert.rejects(() => bundle(path.join(__dirname, '/integration/postcss-modules-config-invalid/src/index.css')), {\n      name: 'BuildError',\n      diagnostics: [{\n        codeFrames: [{\n          code,\n          filePath: configFilePath,\n          language: 'json5',\n          codeHighlights: [{\n            end: {\n              column: 5,\n              line: 5\n            },\n            start: {\n              column: 5,\n              line: 5\n            },\n            message: `JSON5: invalid character '\\\\\"' at 5:5`\n          }]\n        }],\n        message: 'Failed to parse .postcssrc',\n        origin: '@parcel/utils'\n      }]\n    });\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming HTML with posthtml","suites":["posthtml"],"updatePoint":{"line":9,"column":52,"index":416},"line":9,"code":"  it('should support transforming HTML with posthtml', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/posthtml/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    assert(html.includes('<h1>Other page</h1>'));\n  });","file":"posthtml.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should find assets inside posthtml","suites":["posthtml"],"updatePoint":{"line":18,"column":40,"index":781},"line":18,"code":"  it('should find assets inside posthtml', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/posthtml-assets/index.html'));\n    assertBundles(b, [{\n      type: 'html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }]);\n  });","file":"posthtml.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should be able to process an html file with plugins without any params for plugin","suites":["posthtml"],"updatePoint":{"line":28,"column":87,"index":1124},"line":28,"code":"  it('Should be able to process an html file with plugins without any params for plugin', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/posthtml-plugins/index.html'));\n    assertBundles(b, [{\n      type: 'html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf-8');\n    assert(html.includes('&#115;&#97;&#109;&#64;&#115;&#109;&#105;&#116;&#104;&#46;&#99;&#111;&#109;'));\n    assert(!html.includes('sam@smith.com'));\n  });","file":"posthtml.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should add dependencies referenced by posthtml-include","suites":["posthtml"],"line":38,"code":"  it.skip('should add dependencies referenced by posthtml-include', async () => {","file":"posthtml.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should add dependencies referenced by plugins","suites":["posthtml"],"line":45,"code":"  it.skip('should add dependencies referenced by plugins', async () => {","file":"posthtml.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should automatically install posthtml plugins if needed","suites":["posthtml"],"updatePoint":{"line":52,"column":61,"index":2455},"line":52,"code":"  it('should automatically install posthtml plugins if needed', async () => {\n    let inputDir = path.join(__dirname, '/input');\n    await outputFS.rimraf(inputDir);\n    await ncp(path.join(__dirname, '/integration/posthtml-autoinstall'), inputDir);\n    let packageInstaller = new MockPackageInstaller();\n    packageInstaller.register('posthtml-test', inputFS, path.join(__dirname, '/integration/posthtml-autoinstall/posthtml-test'));\n\n    // The package manager uses an overlay filesystem, which performs writes to\n    // an in-memory fs and reads first from memory, then falling back to the real fs.\n    let packageManager = new NodePackageManager(overlayFS, inputDir, packageInstaller);\n    let distDir = path.join(outputFS.cwd(), 'dist');\n    await bundle(path.join(__dirname, '/input/index.html'), {\n      inputFS: overlayFS,\n      packageManager,\n      shouldAutoInstall: true,\n      defaultTargetOptions: {\n        distDir\n      }\n    });\n\n    // posthtml-test was installed\n    let pkg = JSON.parse(await outputFS.readFile(path.join(__dirname, '/input/package.json'), 'utf8'));\n    assert(pkg.devDependencies['posthtml-test']);\n\n    // posthtml-test is applied\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('<span id=\"test\">Test</span>'));\n  });","file":"posthtml.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle proxy table written in .proxyrc","suites":["proxy"],"updatePoint":{"line":58,"column":51,"index":1444},"line":58,"code":"  it('should handle proxy table written in .proxyrc', async function () {\n    let dir = path.join(__dirname, 'integration/proxyrc');\n    inputFS.chdir(dir);\n    let port = await getPort();\n    let b = bundler(path.join(dir, 'index.js'), {\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    server = apiServer();\n    let data = await get('/index.js', port);\n    assert.notEqual(data, 'Request URL: /index.js');\n    data = await get('/api/get', port);\n    assert.equal(data, 'Request URL: /api/get');\n  });","file":"proxy.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle proxy table written in .proxyrc.json","suites":["proxy"],"updatePoint":{"line":78,"column":56,"index":2090},"line":78,"code":"  it('should handle proxy table written in .proxyrc.json', async function () {\n    let dir = path.join(__dirname, 'integration/proxyrc-json');\n    inputFS.chdir(dir);\n    let port = await getPort();\n    let b = bundler(path.join(dir, 'index.js'), {\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    server = apiServer();\n    let data = await get('/index.js', port);\n    assert.notEqual(data, 'Request URL: /index.js');\n    data = await get('/api/get', port);\n    assert.equal(data, 'Request URL: /api/get');\n  });","file":"proxy.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle proxy table written in .proxyrc.js","suites":["proxy"],"updatePoint":{"line":98,"column":54,"index":2739},"line":98,"code":"  it('should handle proxy table written in .proxyrc.js', async function () {\n    let dir = path.join(__dirname, 'integration/proxyrc-js');\n    inputFS.chdir(dir);\n    let port = await getPort();\n    let b = bundler(path.join(dir, 'index.js'), {\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    server = apiServer();\n    let data = await get('/index.js', port);\n    assert.notEqual(data, 'Request URL: /index.js');\n    data = await get('/api/get', port);\n    assert.equal(data, 'Request URL: /get');\n  });","file":"proxy.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle proxy table written in .proxyrc.cjs","suites":["proxy"],"updatePoint":{"line":118,"column":55,"index":3383},"line":118,"code":"  it('should handle proxy table written in .proxyrc.cjs', async function () {\n    let dir = path.join(__dirname, 'integration/proxyrc-cjs');\n    inputFS.chdir(dir);\n    let port = await getPort();\n    let b = bundler(path.join(dir, 'index.js'), {\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    server = apiServer();\n    let data = await get('/index.js', port);\n    assert.notEqual(data, 'Request URL: /index.js');\n    data = await get('/api/get', port);\n    assert.equal(data, 'Request URL: /get');\n  });","file":"proxy.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling HTML","suites":["pug"],"updatePoint":{"line":5,"column":34,"index":198},"line":5,"code":"  it('should support bundling HTML', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/pug/index.pug'));\n    assertBundles(b, [{\n      type: 'html',\n      name: 'index.html',\n      assets: ['index.pug']\n    }, {\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'svg',\n      assets: ['icons.svg']\n    }, {\n      type: 'css',\n      assets: ['index.css']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }]);\n    const files = await outputFS.readdir(distDir);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    for (let file of files) {\n      const ext = file.match(/\\.([0-9a-z]+)(?:[?#]|$)/i)[0];\n      if (file !== 'index.html' && ext !== '.map') {\n        assert(html.includes(file));\n      }\n    }\n  });","file":"pug.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support include and extends files, connect files","suites":["pug"],"updatePoint":{"line":33,"column":61,"index":1021},"line":33,"code":"  it('should support include and extends files, connect files', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/pug-include-extends/index.pug'));\n    assertBundles(b, [{\n      type: 'html',\n      name: 'index.html',\n      assets: ['index.pug']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    assert(html.includes('<!DOCTYPE html>'));\n    assert(html.includes(\"<h1>Yep, it's working!</h1>\"));\n    assert(html.includes('<p>And for nested.</p>'));\n  });","file":"pug.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support variables","suites":["pug"],"updatePoint":{"line":45,"column":30,"index":1516},"line":45,"code":"  it('should support variables', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/pug-var/index.pug'));\n    assertBundles(b, [{\n      type: 'html',\n      name: 'index.html',\n      assets: ['index.pug']\n    }, {\n      type: 'png',\n      assets: ['100x100.png']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    assert(/src=\"\\/?100x100.*.png\"/.test(html));\n  });","file":"pug.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support mixins","suites":["pug"],"updatePoint":{"line":58,"column":27,"index":1946},"line":58,"code":"  it('should support mixins', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/pug-mixins/index.pug'));\n    assertBundles(b, [{\n      type: 'html',\n      name: 'index.html',\n      assets: ['index.pug']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    assert(html.includes('Greetings, Parcel'));\n  });","file":"pug.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support filters","suites":["pug"],"updatePoint":{"line":68,"column":28,"index":2321},"line":68,"code":"  it('should support filters', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/pug-filters/index.pug'));\n    assertBundles(b, [{\n      type: 'html',\n      name: 'index.html',\n      assets: ['index.pug']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    assert(html.includes('FILTERED: Hello!'));\n  });","file":"pug.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support locals with config file","suites":["pug"],"updatePoint":{"line":78,"column":44,"index":2712},"line":78,"code":"  it('should support locals with config file', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/pug-locals/index.pug'));\n    assertBundles(b, [{\n      type: 'html',\n      name: 'index.html',\n      assets: ['index.pug']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    assert(html.includes(\"It's a great!\"));\n  });","file":"pug.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify HTML in production mode","suites":["pug"],"updatePoint":{"line":88,"column":43,"index":3098},"line":88,"code":"  it('should minify HTML in production mode', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/pug-minify/index.pug'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.pug']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    assert(html.includes('Minified'));\n  });","file":"pug.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"retains state in functional components","suites":["react-refresh","synchronous (automatic runtime)"],"updatePoint":{"line":36,"column":48,"index":1111},"line":36,"code":"      it('retains state in functional components', async function () {\n        await fs.mkdirp(testDir);\n        await fs.copyFile(path.join(testDir, 'Foo.1.js'), path.join(testDir, 'Foo.js'));\n        assert.equal((await getNextBuild(b)).type, 'buildSuccess');\n\n        // Wait for the hmr-runtime to process the event\n        await sleep(100);\n        let [, indexNum, appNum, fooText, fooNum] = root.textContent.match(/^([\\d.]+) ([\\d.]+) ([\\w]+):([\\d.]+)$/);\n        assert.equal(randoms?.indexNum, indexNum);\n        assert.equal(randoms?.appNum, appNum);\n        assert.equal(randoms?.fooNum, fooNum);\n        assert.equal(fooText, 'OtherFunctional');\n      });","file":"react-refresh.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"retains state in functional components","suites":["react-refresh","synchronous"],"updatePoint":{"line":72,"column":48,"index":2301},"line":72,"code":"      it('retains state in functional components', async function () {\n        await fs.mkdirp(testDir);\n        await fs.copyFile(path.join(testDir, 'Foo.1.js'), path.join(testDir, 'Foo.js'));\n        assert.equal((await getNextBuild(b)).type, 'buildSuccess');\n\n        // Wait for the hmr-runtime to process the event\n        await sleep(100);\n        let [, indexNum, appNum, fooText, fooNum] = root.textContent.match(/^([\\d.]+) ([\\d.]+) ([\\w]+):([\\d.]+)$/);\n        assert.equal(randoms?.indexNum, indexNum);\n        assert.equal(randoms?.appNum, appNum);\n        assert.equal(randoms?.fooNum, fooNum);\n        assert.equal(fooText, 'OtherFunctional');\n      });","file":"react-refresh.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports changing hooks in functional components","suites":["react-refresh","synchronous"],"updatePoint":{"line":85,"column":58,"index":2978},"line":85,"code":"      it('supports changing hooks in functional components', async function () {\n        await fs.mkdirp(testDir);\n        await fs.copyFile(path.join(testDir, 'Foo.2-hooks.js'), path.join(testDir, 'Foo.js'));\n        assert.equal((await getNextBuild(b)).type, 'buildSuccess');\n\n        // Wait for the hmr-runtime to process the event\n        await sleep(100);\n        let [, indexNum, appNum, fooText, fooNum, fooNum2] = root.textContent.match(/^([\\d.]+) ([\\d.]+) ([\\w]+):([\\d.]+):([\\d.]+)$/);\n        assert.equal(randoms?.indexNum, indexNum);\n        assert.equal(randoms?.appNum, appNum);\n        assert.notEqual(randoms?.fooNum, fooNum);\n        assert(fooNum2);\n        assert.equal(fooText, 'Hooks');\n      });","file":"react-refresh.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"retains state in parent components when swapping function and class component","suites":["react-refresh","synchronous"],"updatePoint":{"line":99,"column":87,"index":3726},"line":99,"code":"      it('retains state in parent components when swapping function and class component', async function () {\n        await fs.mkdirp(testDir);\n        await fs.copyFile(path.join(testDir, 'Foo.3-class.js'), path.join(testDir, 'Foo.js'));\n        assert.equal((await getNextBuild(b)).type, 'buildSuccess');\n\n        // Wait for the hmr-runtime to process the event\n        await sleep(100);\n        let [, indexNum, appNum, fooText, fooNum] = root.textContent.match(/^([\\d.]+) ([\\d.]+) ([\\w]+):([\\d.]+)$/);\n        assert.equal(randoms?.indexNum, indexNum);\n        assert.equal(randoms?.appNum, appNum);\n        assert.notEqual(randoms?.fooNum, fooNum);\n        assert.equal(fooText, 'Class');\n      });","file":"react-refresh.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"retains state in async components on change","suites":["react-refresh","lazy child component"],"updatePoint":{"line":135,"column":53,"index":4940},"line":135,"code":"      it('retains state in async components on change', async function () {\n        assert.equal(randoms?.fooText, 'Async');\n        await fs.mkdirp(testDir);\n        await fs.copyFile(path.join(testDir, 'Async.1.js'), path.join(testDir, 'Async.js'));\n        assert.equal((await getNextBuild(b)).type, 'buildSuccess');\n\n        // Wait for the hmr-runtime to process the event\n        await sleep(100);\n        let [, indexNum, appNum, fooText, fooNum] = root.textContent.match(/^([\\d.]+) ([\\d.]+) ([\\w]+):([\\d.]+)$/);\n        assert.equal(randoms?.indexNum, indexNum);\n        assert.equal(randoms?.appNum, appNum);\n        assert.equal(randoms?.fooNum, fooNum);\n        assert.equal(fooText, 'OtherAsync');\n      });","file":"react-refresh.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not become null when modifying provider","suites":["react-refresh","circular context dependency"],"updatePoint":{"line":170,"column":54,"index":6173},"line":170,"code":"      it('does not become null when modifying provider', async function () {\n        await fs.mkdirp(testDir);\n        let f = path.join(testDir, 'Provider.js');\n        await fs.writeFile(f, (await fs.readFile(f, 'utf8')).replace('2', '3'));\n        assert.equal((await getNextBuild(b)).type, 'buildSuccess');\n\n        // Wait for the hmr-runtime to process the event\n        await sleep(100);\n        assert.equal(root.textContent, '3');\n      });","file":"react-refresh.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not become null when modifying consumer","suites":["react-refresh","circular context dependency"],"updatePoint":{"line":180,"column":54,"index":6623},"line":180,"code":"      it('does not become null when modifying consumer', async function () {\n        await fs.mkdirp(testDir);\n        let f = path.join(testDir, 'Consumer.js');\n        await fs.writeFile(f, (await fs.readFile(f, 'utf8')).replace('tmp', 'foo'));\n        assert.equal((await getNextBuild(b)).type, 'buildSuccess');\n\n        // Wait for the hmr-runtime to process the event\n        await sleep(100);\n        assert.equal(root.textContent, '2');\n      });","file":"react-refresh.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not error on inline scripts","suites":["react-refresh","circular context dependency"],"updatePoint":{"line":197,"column":40,"index":7188},"line":197,"code":"    it('does not error on inline scripts', async () => {\n      let port = await getPort();\n      let b = await bundle(path.join(__dirname, 'integration/react-refresh-inline-script/index.html'), {\n        hmrOptions: {\n          port\n        }\n      });\n      await run(b, {}, {\n        require: false\n      });\n    });","file":"react-refresh.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not apply to library targets","suites":["react-refresh","circular context dependency"],"updatePoint":{"line":208,"column":41,"index":7508},"line":208,"code":"    it('does not apply to library targets', async () => {\n      let port = await getPort();\n      let parcel = await bundler(path.join(__dirname, '/integration/react-refresh-library-target/index.js'), {\n        hmrOptions: {\n          port\n        }\n      });\n      let result = await getNextBuildSuccess(parcel);\n      let bundle = nullthrows(result.bundleGraph.getBundles().find(b => b.type === 'js'));\n\n      // Make sure react-refresh transforms were not applied.\n      let assets = [];\n      bundle.traverse(node => {\n        if (node.type === 'asset') {\n          assets.push(node.value);\n        } else if (node.type === 'dependency') {\n          assert(!node.value.specifier.startsWith('react-refresh/runtime') && !node.value.specifier.startsWith('@parcel/transformer-react-refresh-wrap'));\n        }\n      });\n      for (let asset of assets) {\n        let code = await asset.getCode();\n        assert(!code.includes('$RefreshReg$') && !code.includes('$RefreshSig$'));\n      }\n    });","file":"react-refresh.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a bundle","suites":["reason"],"updatePoint":{"line":5,"column":29,"index":172},"line":5,"code":"  it('should produce a bundle', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/reason/index.js'));\n    assert.equal(b.assets.size, 2);\n    assert.equal(b.childBundles.size, 1);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"reason.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support resolving tilde in monorepo packages","suites":["resolver"],"updatePoint":{"line":5,"column":57,"index":223},"line":5,"code":"  it('should support resolving tilde in monorepo packages', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-tilde-monorepo/client/src/index.js'));\n    let output = await run(b);\n    assert.strictEqual(output.default, 1234);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support node: prefix for node_modules","suites":["resolver"],"updatePoint":{"line":10,"column":50,"index":486},"line":10,"code":"  it('should support node: prefix for node_modules', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-node-prefix/src/index.js'));\n    let output = await run(b);\n    assert.strictEqual(output.default, '6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50');\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly resolve tilde in node_modules","suites":["resolver"],"updatePoint":{"line":15,"column":52,"index":803},"line":15,"code":"  it('should correctly resolve tilde in node_modules', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-tilde-nodemodules/index.js'));\n    let output = await run(b);\n    assert.strictEqual(output.default, 1234);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should fall back to index.js if the resolved `main` file does not exist","suites":["resolver"],"updatePoint":{"line":20,"column":77,"index":1085},"line":20,"code":"  it('should fall back to index.js if the resolved `main` file does not exist', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-index-fallback/incorrect-entry.js'));\n    let output = await run(b);\n    assert.strictEqual(output.default, 42);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should fall back to index.js if there is no `main` field at all","suites":["resolver"],"updatePoint":{"line":25,"column":69,"index":1364},"line":25,"code":"  it('should fall back to index.js if there is no `main` field at all', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-index-fallback/no-entry.js'));\n    let output = await run(b);\n    assert.strictEqual(output.default, 42);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should print a diagnostic when a configured target field will overwrite an entry","suites":["resolver"],"updatePoint":{"line":30,"column":86,"index":1653},"line":30,"code":"  it('should print a diagnostic when a configured target field will overwrite an entry', async function () {\n    let errorThrows = 0;\n    const overwriteDirs = ['browser', 'app', 'main', 'module'];\n    for (const currDir of overwriteDirs) {\n      try {\n        await bundle(path.join(__dirname, `integration/target-overwrite-source/${currDir}`));\n      } catch (e) {\n        errorThrows++;\n        let pkg = JSON.parse(await overlayFS.readFile(path.join(__dirname, `integration/target-overwrite-source/${currDir}/package.json`)));\n        assert.deepEqual(e.diagnostics[0].message, `Target \"${currDir}\" is configured to overwrite entry \"${path.normalize(`test/integration/target-overwrite-source/${currDir}/${pkg.source}`)}\".`);\n      }\n    }\n    assert.deepEqual(errorThrows, overwriteDirs.length);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw an error on Webpack loader imports","suites":["resolver"],"updatePoint":{"line":44,"column":53,"index":2426},"line":44,"code":"  it('should throw an error on Webpack loader imports', async function () {\n    let didThrow = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/webpack-import-syntax-error/index.js'));\n    } catch (e) {\n      didThrow = true;\n      assert.equal(e.diagnostics[1].message, `The import path: node-loader!./index.js is using webpack specific loader import syntax, which isn't supported by Parcel.`);\n    }\n    assert(didThrow);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw an error with codeframe on invalid js import","suites":["resolver"],"updatePoint":{"line":54,"column":63,"index":2888},"line":54,"code":"  it('should throw an error with codeframe on invalid js import', async function () {\n    let didThrow = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/js-invalid-import/index.js'));\n    } catch (e) {\n      didThrow = true;\n      assert(e.diagnostics[0].message.startsWith(`Failed to resolve './doesnotexisstt' from `));\n      assert.deepEqual(e.diagnostics[0].codeFrames[0].codeHighlights[0], {\n        start: {\n          line: 1,\n          column: 8\n        },\n        end: {\n          line: 1,\n          column: 25\n        }\n      });\n    }\n    assert(didThrow);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw an error with codeframe on invalid css import","suites":["resolver"],"updatePoint":{"line":74,"column":64,"index":3485},"line":74,"code":"  it('should throw an error with codeframe on invalid css import', async function () {\n    let didThrow = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/css-invalid-import/index.css'));\n    } catch (e) {\n      didThrow = true;\n      assert(e.diagnostics[0].message.startsWith(`Failed to resolve './thisdoesnotexist.css' from `));\n      assert.deepEqual(e.diagnostics[0].codeFrames[0].codeHighlights[0], {\n        start: {\n          line: 1,\n          column: 9\n        },\n        end: {\n          line: 1,\n          column: 32\n        }\n      });\n    }\n    assert(didThrow);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should return codeframe with hints when package.json is invalid","suites":["resolver"],"updatePoint":{"line":94,"column":69,"index":4095},"line":94,"code":"  it('Should return codeframe with hints when package.json is invalid', async function () {\n    let didThrow = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/resolver-invalid-pkgjson/index.js'));\n    } catch (e) {\n      didThrow = true;\n      assert.equal(e.diagnostics[1].message, `Could not load './entryx.js' from module 'invalid-module' found in package.json#main`);\n      assert.deepEqual(e.diagnostics[1].codeFrames[0].codeHighlights[0], {\n        end: {\n          column: 25,\n          line: 4\n        },\n        message: \"'./entryx.js' does not exist, did you mean './entry.js'?'\",\n        start: {\n          column: 13,\n          line: 4\n        }\n      });\n    }\n    assert(didThrow);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should suggest alternative filenames for relative imports","suites":["resolver"],"updatePoint":{"line":115,"column":63,"index":4814},"line":115,"code":"  it('Should suggest alternative filenames for relative imports', async function () {\n    let threw = 0;\n    try {\n      await bundle(path.join(__dirname, '/integration/resolver-alternative-relative/a.js'));\n    } catch (e) {\n      threw++;\n      assert.equal(e.diagnostics[1].message, `Cannot load file './test/teste.js' in './integration/resolver-alternative-relative'.`);\n      assert.equal(e.diagnostics[1].hints[0], `Did you mean '__./test/test.js__'?`);\n    }\n    try {\n      await bundle(path.join(__dirname, '/integration/resolver-alternative-relative/b.js'));\n    } catch (e) {\n      threw++;\n      assert.equal(e.diagnostics[1].message, `Cannot load file './aa.js' in './integration/resolver-alternative-relative'.`);\n      assert.equal(e.diagnostics[1].hints[0], `Did you mean '__./a.js__'?`);\n    }\n    try {\n      await bundle(path.join(__dirname, '/integration/resolver-alternative-relative/test/test.js'));\n    } catch (e) {\n      threw++;\n      assert.equal(e.diagnostics[1].message, `Cannot load file '../../a.js' in './integration/resolver-alternative-relative/test'.`);\n      assert.equal(e.diagnostics[1].hints[0], `Did you mean '__../a.js__'?`);\n    }\n    assert.equal(threw, 3);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should suggest alternative modules for module imports","suites":["resolver"],"updatePoint":{"line":140,"column":59,"index":6017},"line":140,"code":"  it('Should suggest alternative modules for module imports', async function () {\n    let threw = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/resolver-alternative-module/index.js'));\n    } catch (e) {\n      threw = true;\n      assert.equal(e.diagnostics[1].message, `Cannot find module '@baebal/core'`);\n      assert.equal(e.diagnostics[1].hints[0], `Did you mean '__@babel/core__'?`);\n    }\n    assert(threw);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve packages to packages through the alias field","suites":["resolver"],"updatePoint":{"line":151,"column":65,"index":6467},"line":151,"code":"  it('should resolve packages to packages through the alias field', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/alias/package-to-package.js'));\n    let output = await run(b);\n    assert.strictEqual(output.default, 3);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve packages to local files through the alias field","suites":["resolver"],"updatePoint":{"line":156,"column":68,"index":6730},"line":156,"code":"  it('should resolve packages to local files through the alias field', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/alias/package-to-local.js'));\n    let output = await run(b);\n    assert.strictEqual(output.default, 'bar');\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should exclude local files using the alias field","suites":["resolver"],"updatePoint":{"line":161,"column":54,"index":6981},"line":161,"code":"  it('should exclude local files using the alias field', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/alias/exclude-local.js'));\n    let output = await run(b);\n    assert.deepEqual(output.default, {});\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should exclude packages using the alias field","suites":["resolver"],"updatePoint":{"line":166,"column":51,"index":7221},"line":166,"code":"  it('should exclude packages using the alias field', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/alias/exclude-package.js'));\n    let output = await run(b);\n    assert.deepEqual(output.default, {});\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support symlinked node_modules structure","suites":["resolver"],"updatePoint":{"line":171,"column":53,"index":7465},"line":171,"code":"  it('should support symlinked node_modules structure', async function () {\n    const rootDir = path.join(__dirname, 'integration/resolve-symlinked-node_modules-structure');\n    await overlayFS.mkdirp(rootDir);\n    await ncp(rootDir, rootDir);\n    await outputFS.symlink(path.join(rootDir, 'node_modules/.origin/library@1.0.0/node_modules/library'), path.join(rootDir, 'node_modules/library'));\n    await outputFS.symlink(path.join(rootDir, 'node_modules/.origin/library-dep@1.0.0/node_modules/library-dep'), path.join(rootDir, 'node_modules/.origin/library@1.0.0/node_modules/library-dep'));\n    let b = await bundle(path.join(__dirname, '/integration/resolve-symlinked-node_modules-structure/index.js'), {\n      inputFS: overlayFS,\n      outputFS\n    });\n    let output = await run(b);\n    assert.strictEqual(output.default, 42);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support symlinked monorepos structure","suites":["resolver"],"updatePoint":{"line":184,"column":50,"index":8300},"line":184,"code":"  it('should support symlinked monorepos structure', async function () {\n    const rootDir = path.join(__dirname, 'integration/resolve-symlinked-monorepos');\n    await overlayFS.mkdirp(rootDir);\n    await ncp(rootDir, rootDir);\n    await outputFS.symlink(path.join(rootDir, 'packages/library'), path.join(rootDir, 'packages/app/node_modules/library'));\n    await outputFS.symlink(path.join(rootDir, 'node_modules/.origin/pkg@1.0.0/node_modules/pkg'), path.join(rootDir, 'packages/app/node_modules/pkg'));\n    await outputFS.symlink(path.join(rootDir, 'node_modules/.origin/pkg@1.0.0/node_modules/pkg'), path.join(rootDir, 'packages/library/node_modules/pkg'));\n    let b = await bundle(path.join(__dirname, '/integration/resolve-symlinked-monorepos/packages/app/index.js'), {\n      inputFS: overlayFS,\n      outputFS\n    });\n    let output = await run(b);\n    assert.strictEqual(output.default, 2);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support very long dependency specifiers","suites":["resolver"],"updatePoint":{"line":198,"column":52,"index":9207},"line":198,"code":"  it('should support very long dependency specifiers', async function () {\n    this.timeout(8000);\n    let inputDir = path.join(__dirname, 'input');\n    await outputFS.mkdirp(inputDir);\n    await outputFS.writeFile(path.join(inputDir, 'index.html'), `<img src=\"data:image/jpeg;base64,/9j/${'A'.repeat(200000)}\">`);\n    await bundle(path.join(inputDir, 'index.html'), {\n      inputFS: overlayFS\n    });\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support empty dependency specifiers","suites":["resolver"],"updatePoint":{"line":207,"column":48,"index":9611},"line":207,"code":"  it('should support empty dependency specifiers', async function () {\n    // $FlowFixMe[prop-missing];\n    await assert.rejects(() => bundle(path.join(__dirname, '/integration/resolve-empty-specifier/index.js')), {\n      message: `Failed to resolve '' from './integration/resolve-empty-specifier/index.js'`\n    });\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate a wasm file from a rust file with rustc with --target=browser","suites":["rust"],"updatePoint":{"line":11,"column":83,"index":526},"line":11,"code":"  it('should generate a wasm file from a rust file with rustc with --target=browser', async function () {\n    this.timeout(500000);\n    let b = await bundle(path.join(__dirname, '/integration/rust/index.js'));\n    await assertBundleTree(b, {\n      name: 'index.js',\n      assets: ['bundle-loader.js', 'bundle-url.js', 'index.js', 'wasm-loader.js'],\n      childBundles: [{\n        type: 'wasm',\n        assets: ['add.rs'],\n        childBundles: []\n      }, {\n        type: 'map'\n      }]\n    });\n    var res = await await run(b);\n    assert.equal(res, 5);\n\n    // not minified\n    assert((await outputFS.stat(Array.from(b.childBundles)[0].name)).size > 500);\n  });","file":"rust.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should generate a wasm file from a rust file with rustc with --target=node","suites":["rust"],"updatePoint":{"line":31,"column":80,"index":1187},"line":31,"code":"  it('should generate a wasm file from a rust file with rustc with --target=node', async function () {\n    this.timeout(500000);\n    let b = await bundle(path.join(__dirname, '/integration/rust/index.js'), {\n      target: 'node'\n    });\n    await assertBundleTree(b, {\n      name: 'index.js',\n      assets: ['bundle-loader.js', 'bundle-url.js', 'index.js', 'wasm-loader.js'],\n      childBundles: [{\n        type: 'wasm',\n        assets: ['add.rs'],\n        childBundles: []\n      }, {\n        type: 'map'\n      }]\n    });\n    var res = await run(b);\n    assert.equal(res, 5);\n\n    // not minified\n    assert((await outputFS.stat(Array.from(b.childBundles)[0].name)).size > 500);\n  });","file":"rust.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support rust files with dependencies via rustc","suites":["rust"],"updatePoint":{"line":53,"column":59,"index":1851},"line":53,"code":"  it('should support rust files with dependencies via rustc', async function () {\n    this.timeout(500000);\n    let b = bundler(path.join(__dirname, '/integration/rust-deps/index.js'));\n    let bundle = await b.bundle();\n    await assertBundleTree(bundle, {\n      name: 'index.js',\n      assets: ['bundle-loader.js', 'bundle-url.js', 'index.js', 'wasm-loader.js'],\n      childBundles: [{\n        type: 'map'\n      }, {\n        type: 'wasm',\n        assets: ['test.rs'],\n        childBundles: []\n      }]\n    });\n    var res = await run(bundle);\n    assert.equal(res, 10);\n  });","file":"rust.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should generate a wasm file from a rust file with cargo","suites":["rust"],"updatePoint":{"line":71,"column":61,"index":2431},"line":71,"code":"  it('should generate a wasm file from a rust file with cargo', async function () {\n    this.timeout(500000);\n    let b = await bundle(path.join(__dirname, '/integration/rust-cargo/src/index.js'));\n    await assertBundleTree(b, {\n      name: 'index.js',\n      assets: ['bundle-loader.js', 'bundle-url.js', 'index.js', 'wasm-loader.js'],\n      childBundles: [{\n        type: 'map'\n      }, {\n        type: 'wasm',\n        assets: ['lib.rs'],\n        childBundles: []\n      }]\n    });\n    var res = await run(b);\n    assert.equal(res, 5);\n  });","file":"rust.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should generate a wasm file from a rust file in cargo workspace","suites":["rust"],"updatePoint":{"line":88,"column":69,"index":2982},"line":88,"code":"  it('should generate a wasm file from a rust file in cargo workspace', async function () {\n    this.timeout(500000);\n    let b = await bundle(path.join(__dirname, '/integration/rust-cargo-workspace/member/src/index.js'));\n    await assertBundleTree(b, {\n      name: 'index.js',\n      assets: ['bundle-loader.js', 'bundle-url.js', 'index.js', 'wasm-loader.js'],\n      childBundles: [{\n        type: 'map'\n      }, {\n        type: 'wasm',\n        assets: ['lib.rs'],\n        childBundles: []\n      }]\n    });\n    var res = await run(b);\n    assert.equal(res, 5);\n  });","file":"rust.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring sass files","suites":["sass"],"updatePoint":{"line":5,"column":41,"index":211},"line":5,"code":"  it('should support requiring sass files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/sass/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.sass']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.index'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring scss files","suites":["sass"],"updatePoint":{"line":20,"column":41,"index":729},"line":20,"code":"  it('should support requiring scss files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scss/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.scss']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.index'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support scss imports","suites":["sass"],"updatePoint":{"line":35,"column":33,"index":1239},"line":35,"code":"  it('should support scss imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scss-import/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.scss']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.index'));\n    assert(css.includes('.foo'));\n    assert(css.includes('.bar'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support scss imports in html for >1 target","suites":["sass"],"updatePoint":{"line":52,"column":55,"index":1846},"line":52,"code":"  it('should support scss imports in html for >1 target', async function () {\n    //Repro copied from https://github.com/parcel-bundler/parcel/issues/8754\n    let b = await bundle(path.join(__dirname, '/integration/scss-html-import'));\n    assertBundles(b, [{\n      name: 'target1.html',\n      assets: ['target1.html']\n    }, {\n      assets: ['style.scss']\n    }, {\n      name: 'target2.html',\n      assets: ['target2.html']\n    }, {\n      assets: ['style.scss']\n    }, {\n      assets: ['fa-regular-400.ttf']\n    }, {\n      assets: ['fa-regular-400.ttf']\n    }]);\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring empty scss files","suites":["sass"],"updatePoint":{"line":71,"column":47,"index":2408},"line":71,"code":"  it('should support requiring empty scss files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scss-empty/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.scss']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert.equal(css.trim(), '/*# sourceMappingURL=index.css.map */');\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support linking to assets with url() from scss","suites":["sass"],"updatePoint":{"line":86,"column":59,"index":2985},"line":86,"code":"  it('should support linking to assets with url() from scss', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scss-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      type: 'jpeg',\n      assets: ['image.jpeg']\n    }, {\n      name: 'index.css',\n      assets: ['index.scss']\n    }, {\n      type: 'woff2',\n      assets: ['test.woff2']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(/url\\(\"test\\.[0-9a-f]+\\.woff2\"\\)/.test(css));\n    assert(css.includes('url(\"http://google.com\")'));\n    assert(css.includes('.index'));\n    assert(await outputFS.exists(path.join(distDir, css.match(/url\\(\"(test\\.[0-9a-f]+\\.woff2)\"\\)/)[1])));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming scss with postcss","suites":["sass"],"updatePoint":{"line":110,"column":51,"index":3851},"line":110,"code":"  it('should support transforming scss with postcss', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scss-postcss/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'index.module.scss']\n    }, {\n      name: 'index.css',\n      assets: ['index.module.scss']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let className = output();\n    assert.notStrictEqual(className, 'index');\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes(`.${className}`));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support advanced import syntax","suites":["sass"],"updatePoint":{"line":126,"column":43,"index":4460},"line":126,"code":"  it('should support advanced import syntax', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/sass-advanced-import/index.sass'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.sass']\n    }]);\n    let css = (await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8')).replace(/\\s+/g, ' ');\n    assert(css.includes('.foo { color: pink;'));\n    assert(css.includes('.bar { color: green;'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support absolute imports","suites":["sass"],"updatePoint":{"line":136,"column":37,"index":4911},"line":136,"code":"  it('should support absolute imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scss-absolute-imports/style.scss'));\n    assertBundles(b, [{\n      name: 'style.css',\n      assets: ['style.scss']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'style.css'), 'utf8');\n    assert(css.includes('.a'));\n    assert(css.includes('.b'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should merge global data property from .sassrc.js","suites":["sass"],"updatePoint":{"line":146,"column":55,"index":5323},"line":146,"code":"  it('should merge global data property from .sassrc.js', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scss-global-data/index.scss'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.scss']\n    }]);\n    let css = (await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8')).replace(/\\s+/g, ' ');\n    assert(css.includes('.a { color: red;'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support using the custom webpack/sass node_modules syntax","suites":["sass"],"updatePoint":{"line":155,"column":70,"index":5750},"line":155,"code":"  it('should support using the custom webpack/sass node_modules syntax', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/sass-webpack-import-error/index.sass'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.sass']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.external'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support node_modules imports","suites":["sass"],"updatePoint":{"line":164,"column":41,"index":6127},"line":164,"code":"  it('should support node_modules imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/sass-node-modules-import/index.sass'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.sass']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.external'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support imports from includePaths","suites":["sass"],"updatePoint":{"line":173,"column":46,"index":6508},"line":173,"code":"  it('should support imports from includePaths', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/sass-include-paths-import/index.sass'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.sass']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.included'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support package.json exports","suites":["sass"],"updatePoint":{"line":182,"column":41,"index":6885},"line":182,"code":"  it('should support package.json exports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/sass-exports/index.sass'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.sass']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.external'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should parse a LD+JSON schema and collect dependencies","suites":["jsonld"],"updatePoint":{"line":5,"column":60,"index":227},"line":5,"code":"  it('Should parse a LD+JSON schema and collect dependencies', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/schema-jsonld/index.html'), {\n      publicURL: 'https://place.holder/'\n    });\n    assertBundles(b, [{\n      type: 'jsonld',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'css',\n      assets: ['other.css']\n    }, {\n      type: 'png',\n      assets: ['logo.png']\n    }, {\n      type: 'jpeg',\n      assets: ['image.jpeg']\n    }]);\n    let file = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf-8');\n    let contentBetweenScriptTag = new RegExp(/<\\s*script \\s*type=\"application\\/ld\\+json\"\\s*>(.*)<\\/\\s*script\\s*>/gm).exec(file)[1];\n    let jsonldData = assertValidJsonObject(contentBetweenScriptTag);\n    match(jsonldData.logo.url, /logo\\.[a-f0-9]+\\.png/);\n    match(jsonldData.image[0], /image\\.[a-f0-9]+\\.jpeg/);\n    match(jsonldData.image[1], /image\\.[a-f0-9]+\\.jpeg/);\n  });","file":"schema-jsonld.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports default imports and exports of expressions","suites":["scope hoisting","es6"],"updatePoint":{"line":28,"column":59,"index":920},"line":28,"code":"    it('supports default imports and exports of expressions', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/default-export-expression/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports default imports and exports of declarations","suites":["scope hoisting","es6"],"updatePoint":{"line":33,"column":60,"index":1191},"line":33,"code":"    it('supports default imports and exports of declarations', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/default-export-declaration/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports default imports and exports of anonymous declarations","suites":["scope hoisting","es6"],"updatePoint":{"line":38,"column":70,"index":1473},"line":38,"code":"    it('supports default imports and exports of anonymous declarations', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/default-export-anonymous/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports default imports and exports of variables","suites":["scope hoisting","es6"],"updatePoint":{"line":43,"column":57,"index":1740},"line":43,"code":"    it('supports default imports and exports of variables', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/default-export-variable/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named imports and exports of declarations","suites":["scope hoisting","es6"],"updatePoint":{"line":48,"column":58,"index":2007},"line":48,"code":"    it('supports named imports and exports of declarations', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/named-export-declaration/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named imports and exports of variables","suites":["scope hoisting","es6"],"updatePoint":{"line":53,"column":55,"index":2272},"line":53,"code":"    it('supports named imports and exports of variables', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/named-export-variable/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named exports of variables with a different name","suites":["scope hoisting","es6"],"updatePoint":{"line":58,"column":65,"index":2544},"line":58,"code":"    it('supports named exports of variables with a different name', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/named-export-variable-rename/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named exports of variables with a different name when wrapped","suites":["scope hoisting","es6"],"updatePoint":{"line":63,"column":78,"index":2836},"line":63,"code":"    it('supports named exports of variables with a different name when wrapped', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/named-export-variable-rename-wrapped/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports renaming non-ASCII identifiers","suites":["scope hoisting","es6"],"updatePoint":{"line":68,"column":47,"index":3105},"line":68,"code":"    it('supports renaming non-ASCII identifiers', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/non-ascii-identifiers/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, [1, 2, 3, 4]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports renaming superclass identifiers","suites":["scope hoisting","es6"],"updatePoint":{"line":73,"column":48,"index":3375},"line":73,"code":"    it('supports renaming superclass identifiers', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/rename-superclass/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports renaming helpers inserted during transpiling","suites":["scope hoisting","es6"],"updatePoint":{"line":78,"column":61,"index":3639},"line":78,"code":"    it('supports renaming helpers inserted during transpiling', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/rename-helpers/a.js'));\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(/let \\S* = Symbol.toStringTag;/.test(contents));\n      let output = await run(b);\n      assert.deepEqual(output, ['1', '2']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"correctly renames member expression properties","suites":["scope hoisting","es6"],"updatePoint":{"line":85,"column":54,"index":4050},"line":85,"code":"    it('correctly renames member expression properties', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/rename-member-prop/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output({\n        foo: 12,\n        bar: 34\n      }), [12, 12, 34, 34]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports renaming imports","suites":["scope hoisting","es6"],"updatePoint":{"line":93,"column":33,"index":4350},"line":93,"code":"    it('supports renaming imports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/renamed-import/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports renaming exports","suites":["scope hoisting","es6"],"updatePoint":{"line":98,"column":33,"index":4583},"line":98,"code":"    it('supports renaming exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/renamed-export/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing from a reexporting asset in an anchestor (1)","suites":["scope hoisting","es6"],"updatePoint":{"line":103,"column":71,"index":4854},"line":103,"code":"    it('supports importing from a reexporting asset in an anchestor (1)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/ancestor-reexport/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, ['index', 'async']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing from a reexporting asset in an anchestor (2)","suites":["scope hoisting","es6"],"updatePoint":{"line":108,"column":71,"index":5149},"line":108,"code":"    it('supports importing from a reexporting asset in an anchestor (2)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/ancestor-reexport2/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, [123, 123]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing from a reexporting asset in an anchestor (3)","suites":["scope hoisting","es6"],"updatePoint":{"line":113,"column":71,"index":5437},"line":113,"code":"    it('supports importing from a reexporting asset in an anchestor (3)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/ancestor-reexport2/b.js'));\n      let output = await run(b);\n      assert.deepEqual(output, [123, 123]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports async import of internalized asset with unused return value","suites":["scope hoisting","es6"],"updatePoint":{"line":118,"column":76,"index":5730},"line":118,"code":"    it('supports async import of internalized asset with unused return value', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/async-internalize-unused/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 'bc');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing a namespace of exported values","suites":["scope hoisting","es6"],"updatePoint":{"line":123,"column":57,"index":6006},"line":123,"code":"    it('supports importing a namespace of exported values', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports namespace imports of excluded assets (node_modules)","suites":["scope hoisting","es6"],"updatePoint":{"line":128,"column":68,"index":6276},"line":128,"code":"    it('supports namespace imports of excluded assets (node_modules)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace-external/a.js'));\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('require(\"lodash\")'));\n      let output = await run(b);\n      assert.deepEqual(output.default, 12);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting all exports from another module","suites":["scope hoisting","es6"],"updatePoint":{"line":135,"column":61,"index":6697},"line":135,"code":"    it('supports re-exporting all exports from another module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-all/a.js'));\n      let output = await run(b);\n      assert.equal(output, 6);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting all when falling back to namespace at runtime 1","suites":["scope hoisting","es6"],"updatePoint":{"line":140,"column":77,"index":6973},"line":140,"code":"    it('supports re-exporting all when falling back to namespace at runtime 1', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-all-fallback-1/index.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting all when falling back to namespace at runtime 2","suites":["scope hoisting","es6"],"updatePoint":{"line":145,"column":77,"index":7270},"line":145,"code":"    it('supports re-exporting all when falling back to namespace at runtime 2', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-all-fallback-2/index.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting all when falling back to namespace at runtime 3","suites":["scope hoisting","es6"],"updatePoint":{"line":150,"column":77,"index":7567},"line":150,"code":"    it('supports re-exporting all when falling back to namespace at runtime 3', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/re-export-all-fallback-3/entry.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 'FOOBAR!');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports nested re-exporting all when falling back to namespace at runtime","suites":["scope hoisting","es6"],"updatePoint":{"line":155,"column":82,"index":7876},"line":155,"code":"    it('supports nested re-exporting all when falling back to namespace at runtime', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-all-fallback-nested/index.js'));\n      let output = await run(b);\n      assert.strictEqual(output, '2 4');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting all exports from an external module","suites":["scope hoisting","es6"],"updatePoint":{"line":160,"column":65,"index":8170},"line":160,"code":"    it('supports re-exporting all exports from an external module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-all-external/a.js'));\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['a.js', 'b.js']\n      }]);\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'b.js', 'lodash'))), new Set(['add']));\n\n      // getSymbolResolution is broken\n      // let output = await run(b);\n      // assert.equal(output, 3);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting all exports from multiple modules","suites":["scope hoisting","es6"],"updatePoint":{"line":173,"column":63,"index":8690},"line":173,"code":"    it('supports re-exporting all exports from multiple modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-all-multiple/a.js'));\n      let output = await run(b);\n      assert.equal(output, 15);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting all exports and overriding individual exports","suites":["scope hoisting","es6"],"updatePoint":{"line":178,"column":75,"index":8974},"line":178,"code":"    it('supports re-exporting all exports and overriding individual exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-all-override/index.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 'fooBfooCC');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can import from a different bundle via a re-export (1)","suites":["scope hoisting","es6"],"updatePoint":{"line":183,"column":62,"index":9264},"line":183,"code":"    it('can import from a different bundle via a re-export (1)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-bundle-boundary/index.js'));\n      let output = await run(b);\n      assert.deepEqual(output, ['operational', 'ui']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can import from a different bundle via a re-export (2)","suites":["scope hoisting","es6"],"updatePoint":{"line":188,"column":62,"index":9565},"line":188,"code":"    it('can import from a different bundle via a re-export (2)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-bundle-boundary2/index.js'));\n      let output = await run(b);\n      assert.deepEqual(output, ['foo', 'foo']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can import from its own bundle with a split package","suites":["scope hoisting","es6"],"updatePoint":{"line":193,"column":59,"index":9857},"line":193,"code":"    it('can import from its own bundle with a split package', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-bundle-boundary3/index.js'));\n      let output = await run(b);\n      assert.deepEqual(output, [['a', 'b'], 'themed']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing all exports re-exported from multiple modules deep","suites":["scope hoisting","es6"],"updatePoint":{"line":198,"column":77,"index":10175},"line":198,"code":"    it('supports importing all exports re-exported from multiple modules deep', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-multiple-wildcards/a.js'));\n      let {\n        foo,\n        bar,\n        baz,\n        a,\n        b: bb\n      } = await run(b);\n      assert.equal(foo + bar + baz + a + bb, 15);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting all exports from multiple modules deep","suites":["scope hoisting","es6"],"updatePoint":{"line":209,"column":68,"index":10540},"line":209,"code":"    it('supports re-exporting all exports from multiple modules deep', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-multiple/a.js'));\n      let output = await run(b);\n      assert.equal(output, 7);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting individual named exports from another module","suites":["scope hoisting","es6"],"updatePoint":{"line":214,"column":74,"index":10818},"line":214,"code":"    it('supports re-exporting individual named exports from another module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-named/a.js'));\n      let output = await run(b);\n      assert.equal(output, 3);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting default exports from another module","suites":["scope hoisting","es6"],"updatePoint":{"line":219,"column":65,"index":11084},"line":219,"code":"    it('supports re-exporting default exports from another module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-default/a.js'));\n      let output = await run(b);\n      assert.equal(output, 3);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting a namespace from another module","suites":["scope hoisting","es6"],"updatePoint":{"line":224,"column":61,"index":11348},"line":224,"code":"    it('supports re-exporting a namespace from another module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-namespace/a.js'));\n      let output = await run(b);\n      assert.equal(output, 6);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting a namespace from another module (chained)","suites":["scope hoisting","es6"],"updatePoint":{"line":229,"column":71,"index":11624},"line":229,"code":"    it('supports re-exporting a namespace from another module (chained)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-namespace-chained/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        Bar: {\n          A: 1,\n          B: 2\n        },\n        Foo: {\n          A: 1,\n          B: 2\n        }\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"has the correct order with namespace re-exports","suites":["scope hoisting","es6"],"updatePoint":{"line":243,"column":55,"index":12017},"line":243,"code":"    it('has the correct order with namespace re-exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-namespace-order/index.js'));\n      let output = await run(b);\n      assert.equal(output, Symbol.for('abc'));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"excludes default when re-exporting a module","suites":["scope hoisting","es6"],"updatePoint":{"line":248,"column":51,"index":12299},"line":248,"code":"    it('excludes default when re-exporting a module', async function () {\n      let source = path.normalize('integration/scope-hoisting/es6/re-export-exclude-default/a.js');\n      let message = md`${normalizePath('integration/scope-hoisting/es6/re-export-exclude-default/b.js', false)} does not export 'default'`;\n      await assert.rejects(() => bundle(path.join(__dirname, source)), {\n        name: 'BuildError',\n        message,\n        diagnostics: [{\n          message,\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: path.join(__dirname, source),\n            language: 'js',\n            codeHighlights: [{\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 8\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"throws when reexporting a missing symbol","suites":["scope hoisting","es6"],"updatePoint":{"line":274,"column":48,"index":13177},"line":274,"code":"    it('throws when reexporting a missing symbol', async function () {\n      let source = path.normalize('integration/scope-hoisting/es6/re-export-missing/a.js');\n      let message = md`${normalizePath('integration/scope-hoisting/es6/re-export-missing/c.js', false)} does not export 'foo'`;\n      await assert.rejects(() => bundle(path.join(__dirname, source)), {\n        name: 'BuildError',\n        message,\n        diagnostics: [{\n          message,\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: path.join(__dirname, 'integration/scope-hoisting/es6/re-export-missing/b.js'),\n            language: 'js',\n            codeHighlights: [{\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 11\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"throws when importing a missing symbol on cached builds without changes","suites":["scope hoisting","es6"],"updatePoint":{"line":300,"column":79,"index":14116},"line":300,"code":"    it('throws when importing a missing symbol on cached builds without changes', async function () {\n      let entry = 'integration/scope-hoisting/es6/import-missing/a.js';\n      let message = md`${normalizePath('integration/scope-hoisting/es6/import-missing/b.js', false)} does not export 'foo'`;\n      let error = {\n        name: 'BuildError',\n        message,\n        diagnostics: [{\n          message,\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: path.join(__dirname, entry),\n            language: 'js',\n            codeHighlights: [{\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 11\n              }\n            }]\n          }]\n        }]\n      };\n      let source = path.join(__dirname, entry);\n      await assert.rejects(() => bundle(source, {\n        inputFS: overlayFS,\n        outputFS: overlayFS,\n        shouldDisableCache: false\n      }), error);\n      await assert.rejects(() => bundle(source, {\n        inputFS: overlayFS,\n        outputFS: overlayFS,\n        shouldDisableCache: false\n      }), error);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports multiple exports of the same variable","suites":["scope hoisting","es6"],"updatePoint":{"line":337,"column":54,"index":15269},"line":337,"code":"    it('supports multiple exports of the same variable', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/multi-export/a.js'));\n      let output = await run(b);\n      assert.equal(output, 6);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports live bindings of named exports","suites":["scope hoisting","es6"],"updatePoint":{"line":342,"column":47,"index":15514},"line":342,"code":"    it('supports live bindings of named exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/live-bindings/a.js'));\n      let output = await run(b);\n      assert.equal(output, 8);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports live bindings in namespaces of reexporting assets","suites":["scope hoisting","es6"],"updatePoint":{"line":347,"column":66,"index":15779},"line":347,"code":"    it('supports live bindings in namespaces of reexporting assets', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/live-bindings-reexports-namespace/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, [1, 2]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports live bindings across bundles","suites":["scope hoisting","es6"],"updatePoint":{"line":352,"column":45,"index":16052},"line":352,"code":"    it('supports live bindings across bundles', async function () {\n      let b = await bundle(['a.html', 'b.html'].map(f => path.join(__dirname, '/integration/scope-hoisting/es6/live-bindings-cross-bundle', f)), {\n        mode: 'production'\n      });\n      let ctx = await runBundle(b, b.getBundles().find(b => b.type === 'html'), {\n        output: null\n      }, {\n        require: false\n      });\n      assert.deepEqual(ctx.output, 'aaa');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports live bindings of default exports","suites":["scope hoisting","es6"],"updatePoint":{"line":363,"column":49,"index":16506},"line":363,"code":"    it('supports live bindings of default exports', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5658\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/export-default-live/a.js'));\n      let out = [];\n      await run(b, {\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, [5, 10]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports dynamic import syntax for code splitting","suites":["scope hoisting","es6"],"updatePoint":{"line":374,"column":57,"index":16908},"line":374,"code":"    it('supports dynamic import syntax for code splitting', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/dynamic-import/a.js'));\n      assert.equal(await run(b), 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports nested dynamic imports","suites":["scope hoisting","es6"],"updatePoint":{"line":378,"column":39,"index":17120},"line":378,"code":"    it('supports nested dynamic imports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/dynamic-import-dynamic/a.js'));\n      assert.equal(await run(b), 123);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named exports before the variable declaration","suites":["scope hoisting","es6"],"updatePoint":{"line":382,"column":62,"index":17365},"line":382,"code":"    it('supports named exports before the variable declaration', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/export-before-declaration/a.js'));\n      assert.deepEqual(await run(b), {\n        x: 2\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not export function arguments","suites":["scope hoisting","es6"],"updatePoint":{"line":388,"column":44,"index":17618},"line":388,"code":"    it('should not export function arguments', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/export-binding-identifiers/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, ['test']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should default export classes when wrapped","suites":["scope hoisting","es6"],"updatePoint":{"line":393,"column":50,"index":17891},"line":393,"code":"    it('should default export classes when wrapped', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/export-default-class-wrapped/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output.VERSION, 1234);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should default export functions when wrapped","suites":["scope hoisting","es6"],"updatePoint":{"line":398,"column":52,"index":18174},"line":398,"code":"    it('should default export functions when wrapped', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/export-default-function-wrapped/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output.VERSION, 1234);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should default export globals","suites":["scope hoisting","es6"],"updatePoint":{"line":403,"column":37,"index":18445},"line":403,"code":"    it('should default export globals', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/export-default-global/a.js'));\n      let Test = Symbol('Test');\n      let output = await run(b, {\n        Test\n      });\n      assert.strictEqual(output, Test);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should default export JS globals","suites":["scope hoisting","es6"],"updatePoint":{"line":411,"column":40,"index":18758},"line":411,"code":"    it('should default export JS globals', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/export-default-js-global/a.js'));\n      let output = await run(b);\n      assert(new output([1, 2, 3]).has(1));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove export named declaration without specifiers","suites":["scope hoisting","es6"],"updatePoint":{"line":416,"column":65,"index":19046},"line":416,"code":"    it('should remove export named declaration without specifiers', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/export-named-empty/a.js'));\n      let content = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(!/export\\s*{\\s*}\\s*;/.test(content));\n      let output = await run(b);\n      assert.strictEqual(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"throws a meaningful error on undefined exports","suites":["scope hoisting","es6"],"line":423,"code":"    it.skip('throws a meaningful error on undefined exports', async function () {","file":"scope-hoisting.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"supports importing named CommonJS (export individual)","suites":["scope hoisting","es6"],"updatePoint":{"line":433,"column":61,"index":19841},"line":433,"code":"    it('supports importing named CommonJS (export individual)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-commonjs-export-individual/a.js'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'c.js')))), new Set(['name', 'version']));\n      let output = await run(b);\n      assert.deepEqual(output, 'name:1.2.3');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing named CommonJS (export namespace)","suites":["scope hoisting","es6"],"updatePoint":{"line":439,"column":60,"index":20256},"line":439,"code":"    it('supports importing named CommonJS (export namespace)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-commonjs-export-object/a.js'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'c.js')))), new Set(['name', 'version']));\n      let output = await run(b);\n      assert.deepEqual(output, 'name:1.2.3');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports default importing CommonJS (export namespace)","suites":["scope hoisting","es6"],"updatePoint":{"line":445,"column":62,"index":20669},"line":445,"code":"    it('supports default importing CommonJS (export namespace)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-commonjs-export-object-default/a.js'));\n      assert.deepStrictEqual(new Set(nullthrows(findAsset(b, 'b1.js')).symbols.exportSymbols()), new Set(['*']));\n      assert.deepStrictEqual(new Set(nullthrows(findAsset(b, 'b2.js')).symbols.exportSymbols()), new Set(['*']));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        x: {\n          foo: 1,\n          default: 2\n        },\n        y: 4\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports import default CommonJS interop (export value)","suites":["scope hoisting","es6"],"updatePoint":{"line":458,"column":63,"index":21271},"line":458,"code":"    it('supports import default CommonJS interop (export value)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-commonjs-default/a.js'));\n      let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(dist.includes('$parcel$interopDefault'));\n      let output = await run(b);\n      assert.deepEqual(output, 'foobar:foo:bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports import default CommonJS interop (individual exports)","suites":["scope hoisting","es6"],"updatePoint":{"line":465,"column":69,"index":21701},"line":465,"code":"    it('supports import default CommonJS interop (individual exports)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-commonjs-export-individual-default/a.js'));\n      assert.deepStrictEqual(new Set(nullthrows(findAsset(b, 'b1.js')).symbols.exportSymbols()), new Set(['*', 'default', 'foo']));\n      assert.deepStrictEqual(new Set(nullthrows(findAsset(b, 'b2.js')).symbols.exportSymbols()), new Set(['*', 'foo', 'default', '__esModule']));\n      assert.deepStrictEqual(new Set(nullthrows(findAsset(b, 'b3.js')).symbols.exportSymbols()), new Set(['*']));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        x: {\n          foo: 1,\n          default: 2\n        },\n        y: 4,\n        z: 6\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"falls back when importing missing symbols from CJS","suites":["scope hoisting","es6"],"updatePoint":{"line":480,"column":58,"index":22480},"line":480,"code":"    it('falls back when importing missing symbols from CJS', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-commonjs-missing/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, undefined);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not export reassigned CommonJS exports references","suites":["scope hoisting","es6"],"updatePoint":{"line":485,"column":62,"index":22765},"line":485,"code":"    it('does not export reassigned CommonJS exports references', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/commonjs-exports-reassign/a.js'));\n      let [foo, bExports] = await run(b);\n      assert.equal(foo, 'foobar');\n      assert.equal(typeof bExports, 'object');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports import default CommonJS interop with dynamic imports","suites":["scope hoisting","es6"],"updatePoint":{"line":491,"column":69,"index":23105},"line":491,"code":"    it('supports import default CommonJS interop with dynamic imports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/dynamic-default-interop/a.js'));\n      assert.deepEqual(await run(b), 6);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports exporting an import","suites":["scope hoisting","es6"],"updatePoint":{"line":495,"column":36,"index":23327},"line":495,"code":"    it('supports exporting an import', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-var/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'foobar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing from a wrapped asset","suites":["scope hoisting","es6"],"updatePoint":{"line":500,"column":47,"index":23584},"line":500,"code":"    it('supports importing from a wrapped asset', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-wrapped/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, ['a', true]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"wraps an asset if any of its ancestors is wrapped, even if one is not","suites":["scope hoisting","es6"],"updatePoint":{"line":505,"column":77,"index":23878},"line":505,"code":"    it('wraps an asset if any of its ancestors is wrapped, even if one is not', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/multiple-ancestors-wrap/index.js'));\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(contents.match(/parcelRequire.register\\(/g).length, 2 /* once for parent asset, once for child wrapped asset */);\n\n      let output = await run(b);\n      assert.deepEqual(output, [42, 43]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing from a wrapped asset with multiple bailouts","suites":["scope hoisting","es6"],"updatePoint":{"line":513,"column":70,"index":24394},"line":513,"code":"    it('supports importing from a wrapped asset with multiple bailouts', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-wrapped-bailout/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, ['b', true]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"unused and missing pseudo re-exports doesn't fail the build with scope-hoisting","suites":["scope hoisting","es6"],"updatePoint":{"line":519,"column":121,"index":24790},"line":519,"code":"      it(`unused and missing pseudo re-exports doesn't fail the build with${shouldScopeHoist ? '' : 'out'} scope-hoisting`, async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-pseudo/a.js'), {\n          defaultTargetOptions: {\n            shouldScopeHoist\n          }\n        });\n        let {\n          output\n        } = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(output, 'foo');\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports requiring a re-exported and renamed ES6 import","suites":["scope hoisting","es6"],"updatePoint":{"line":533,"column":63,"index":25231},"line":533,"code":"    it('supports requiring a re-exported and renamed ES6 import', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-renamed/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'foobar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports requiring a re-exported and renamed ES6 import (reversed order)","suites":["scope hoisting","es6"],"updatePoint":{"line":538,"column":80,"index":25525},"line":538,"code":"    it('supports requiring a re-exported and renamed ES6 import (reversed order)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-renamed2/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'foobar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports requiring a re-exported and renamed ES6 namespace import","suites":["scope hoisting","es6"],"updatePoint":{"line":543,"column":73,"index":25813},"line":543,"code":"    it('supports requiring a re-exported and renamed ES6 namespace import', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-renamed-namespace/a.js'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'a.js', './b.js'))), new Set(['default', 'x']));\n      let output = await run(b);\n      assert.deepEqual(output, [123, 123]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports reexporting an asset from a shared bundle inside a shared bundle","suites":["scope hoisting","es6"],"updatePoint":{"line":549,"column":81,"index":26241},"line":549,"code":"    it('supports reexporting an asset from a shared bundle inside a shared bundle', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/shared-bundle-reexport/*.html'), {\n        mode: 'production'\n      });\n      assertBundles(b, [{\n        type: 'html',\n        assets: ['index1.html']\n      }, {\n        type: 'js',\n        assets: ['index1.js']\n      }, {\n        type: 'html',\n        assets: ['index2.html']\n      }, {\n        type: 'js',\n        assets: ['index2.js', 'b.js']\n      }, {\n        type: 'html',\n        assets: ['index3.html']\n      }, {\n        type: 'js',\n        assets: ['index3.js', 'b.js']\n      }, {\n        type: 'js',\n        assets: ['a.js']\n      }]);\n      for (let bundle of b.getBundles().filter(b => b.type === 'html')) {\n        let calls = [];\n        await runBundle(b, bundle, {\n          call(v) {\n            calls.push(v);\n          }\n        });\n        assert.equal(calls.length, 1);\n        assert(calls[0].startsWith('abcabc'));\n      }\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports simultaneous import and re-export of a symbol","suites":["scope hoisting","es6"],"updatePoint":{"line":586,"column":62,"index":27263},"line":586,"code":"    it('supports simultaneous import and re-export of a symbol', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-import/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 5 * 123);\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'e.js')))), new Set(['default']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'e2.js')))), new Set(['default']));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing a namespace from a commonjs module when code split","suites":["scope hoisting","es6"],"updatePoint":{"line":593,"column":77,"index":27779},"line":593,"code":"    it('supports importing a namespace from a commonjs module when code split', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace-commonjs/a.js'));\n      assert.deepEqual(await run(b), 4);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports resolving a static member access on a namespace","suites":["scope hoisting","es6"],"updatePoint":{"line":597,"column":64,"index":28031},"line":597,"code":"    it('supports resolving a static member access on a namespace', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace-static-member/a.js'));\n      let calls = [];\n      let output = await run(b, {\n        sideEffect: v => {\n          calls.push(v);\n        }\n      });\n      assert.deepEqual(output, 'foofoobar');\n      assert.deepEqual(calls, ['c1', 'c3']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bailout with a non-static member access on a namespace","suites":["scope hoisting","es6"],"updatePoint":{"line":608,"column":69,"index":28470},"line":608,"code":"    it('should bailout with a non-static member access on a namespace', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace-static-member/b.js'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'b.js', './library/index.js'))), new Set(['*']));\n      let calls = [];\n      let output = await run(b, {\n        sideEffect: v => {\n          calls.push(v);\n        }\n      });\n      assert.deepEqual(output, 'foo');\n      assert.deepEqual(calls, ['c1', 'c2', 'c3']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing a namespace from a wrapped module","suites":["scope hoisting","es6"],"updatePoint":{"line":620,"column":60,"index":29022},"line":620,"code":"    it('supports importing a namespace from a wrapped module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace-wrapped/a.js'));\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('$parcel$exportWildcard'));\n      let output = await run(b);\n      assert.deepEqual(output, 1);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports wrapped assets importing their own namespace","suites":["scope hoisting","es6"],"updatePoint":{"line":627,"column":61,"index":29439},"line":627,"code":"    it('supports wrapped assets importing their own namespace', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace-wrapped-self/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, true);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing a namespace from a transpiled CommonJS module","suites":["scope hoisting","es6"],"updatePoint":{"line":632,"column":72,"index":29735},"line":632,"code":"    it('supports importing a namespace from a transpiled CommonJS module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace-commonjs-transpiled/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        bar: 3,\n        foo: 1\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes unused exports","suites":["scope hoisting","es6"],"updatePoint":{"line":640,"column":30,"index":30030},"line":640,"code":"    it('removes unused exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking/a.js'), {\n        mode: 'production'\n      });\n      let output = await run(b);\n      assert.deepEqual(output, 2);\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('output=2'));\n      assert(!contents.includes('bar'));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes unused function exports when minified","suites":["scope hoisting","es6"],"updatePoint":{"line":650,"column":53,"index":30491},"line":650,"code":"    it('removes unused function exports when minified', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-functions/a.js'), {\n        defaultTargetOptions: {\n          shouldOptimize: true\n        }\n      });\n      let output = await run(b);\n      assert.deepEqual(output, 9);\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(/output=9/.test(contents));\n      assert(!/.-./.test(contents));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes unused transpiled classes using terser when minified","suites":["scope hoisting","es6"],"updatePoint":{"line":662,"column":68,"index":31015},"line":662,"code":"    it('removes unused transpiled classes using terser when minified', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-classes-babel/a.js'), {\n        defaultTargetOptions: {\n          shouldOptimize: true\n        }\n      });\n      let output = await run(b);\n      assert.deepEqual(output, 3);\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('method'));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes unused exports across bundles","suites":["scope hoisting","es6"],"updatePoint":{"line":681,"column":49,"index":31714},"line":681,"code":"        it('removes unused exports across bundles', async () => {\n          let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-cross-bundle/a.js'), {\n            targets,\n            mode: 'production'\n          });\n          if (outputFormat != 'esmodule') {\n            // TODO execute ESM at some point\n            assert.deepEqual(await run(b), ['b1:foo', 'b2:foo']);\n          }\n          let contents = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('b1')).filePath, 'utf8');\n          assert(!contents.includes('bar'));\n          contents = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('b2')).filePath, 'utf8');\n          assert(!contents.includes('bar'));\n        });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes unused exports with re-exports across bundles","suites":["scope hoisting","es6"],"updatePoint":{"line":695,"column":65,"index":32485},"line":695,"code":"        it('removes unused exports with re-exports across bundles', async () => {\n          let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-cross-bundle-re-export/a.js'), {\n            targets,\n            mode: 'production'\n          });\n          if (outputFormat != 'esmodule') {\n            // TODO execute ESM at some point\n            assert.deepEqual(await run(b), ['b1:foo', 'b2:foo']);\n          }\n          let contents = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('b1')).filePath, 'utf8');\n          assert(!contents.includes('bar'));\n          contents = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('b2')).filePath, 'utf8');\n          assert(!contents.includes('bar'));\n        });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes unused exports with wildcard re-exports across bundles","suites":["scope hoisting","es6"],"updatePoint":{"line":709,"column":74,"index":33275},"line":709,"code":"        it('removes unused exports with wildcard re-exports across bundles', async () => {\n          let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-cross-bundle-re-export-wildcard/a.js'), {\n            targets,\n            mode: 'production'\n          });\n          if (outputFormat != 'esmodule') {\n            // TODO execute ESM at some point\n            assert.deepEqual(await run(b), ['b1:foo', 'b2:foo']);\n          }\n          let contents = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('b1')).filePath, 'utf8');\n          assert(!contents.includes('bar'));\n          contents = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('b2')).filePath, 'utf8');\n          assert(!contents.includes('bar'));\n        });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: destructued await assignment","suites":["scope hoisting","es6","tree shaking dynamic imports"],"line":726,"code":"      it.skip('supports tree shaking statically analyzable dynamic import: destructued await assignment', async function () {","file":"scope-hoisting.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: destructured await declaration","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":736,"column":100,"index":34985},"line":736,"code":"      it('supports tree shaking statically analyzable dynamic import: destructured await declaration', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-dynamic-import/await-declaration.js'), {\n          mode: 'production'\n        });\n        let output = await run(b);\n        assert.deepEqual(output, ['foo', 'thing']);\n        assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'await-declaration.js', './async.js'))), new Set(['foo', 'thing']));\n        assert(b.isDependencySkipped(findDependency(b, 'async.js', './a1.js')));\n        let contents = await outputFS.readFile(b.getBundles().find(b => b.getMainEntry().filePath.endsWith('async.js')).filePath, 'utf8');\n        assert(!contents.includes('bar'));\n        assert(!contents.includes('stuff'));\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: namespace await declaration","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":748,"column":97,"index":35831},"line":748,"code":"      it('supports tree shaking statically analyzable dynamic import: namespace await declaration', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-dynamic-import/await-declaration-namespace.js'), {\n          mode: 'production'\n        });\n        let output = await run(b);\n        assert.deepEqual(output, ['foo', 'thing']);\n        assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'await-declaration-namespace.js', './async.js'))), new Set(['foo', 'thing']));\n        assert(b.isDependencySkipped(findDependency(b, 'async.js', './a1.js')));\n        let contents = await outputFS.readFile(b.getBundles().find(b => b.getMainEntry().filePath.endsWith('async.js')).filePath, 'utf8');\n        assert(!contents.includes('bar'));\n        assert(!contents.includes('stuff'));\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: namespace await declaration bailout","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":760,"column":105,"index":36705},"line":760,"code":"      it('supports tree shaking statically analyzable dynamic import: namespace await declaration bailout', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-dynamic-import/await-declaration-namespace-bailout.js'));\n        let output = await run(b);\n        assert.deepEqual(output, {\n          bar: 'bar',\n          foo: 'foo',\n          other: 'other',\n          stuff: 'stuff',\n          thing: 'thing'\n        });\n        assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'await-declaration-namespace-bailout.js', './async.js'))), new Set(['*']));\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: namespace await declaration eval bailout","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":772,"column":110,"index":37355},"line":772,"code":"      it('supports tree shaking statically analyzable dynamic import: namespace await declaration eval bailout', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-dynamic-import/await-declaration-namespace-bailout-eval.js'));\n        let output = await run(b);\n        assert.deepEqual(output, 'thing');\n        assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'await-declaration-namespace-bailout-eval.js', './async.js'))), new Set(['*']));\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: destructured then","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":778,"column":87,"index":37867},"line":778,"code":"      it('supports tree shaking statically analyzable dynamic import: destructured then', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-dynamic-import/then.js'), {\n          mode: 'production'\n        });\n        let output = await run(b);\n        assert.deepEqual(output, ['foo', 'thing']);\n        assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'then.js', './async.js'))), new Set(['foo', 'thing']));\n        assert(b.isDependencySkipped(findDependency(b, 'async.js', './a1.js')));\n        let contents = await outputFS.readFile(b.getBundles().find(b => b.getMainEntry().filePath.endsWith('async.js')).filePath, 'utf8');\n        assert(!contents.includes('bar'));\n        assert(!contents.includes('stuff'));\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: namespace then","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":790,"column":84,"index":38674},"line":790,"code":"      it('supports tree shaking statically analyzable dynamic import: namespace then', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-dynamic-import/then-namespace.js'), {\n          mode: 'production'\n        });\n        let output = await run(b);\n        assert.deepEqual(output, ['foo', 'thing']);\n        assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'then-namespace.js', './async.js'))), new Set(['foo', 'thing']));\n        assert(b.isDependencySkipped(findDependency(b, 'async.js', './a1.js')));\n        let contents = await outputFS.readFile(b.getBundles().find(b => b.getMainEntry().filePath.endsWith('async.js')).filePath, 'utf8');\n        assert(!contents.includes('bar'));\n        assert(!contents.includes('stuff'));\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: namespace then bailout","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":802,"column":92,"index":39509},"line":802,"code":"      it('supports tree shaking statically analyzable dynamic import: namespace then bailout', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-dynamic-import/then-namespace-bailout.js'));\n        let output = await run(b);\n        assert.deepEqual(output, {\n          bar: 'bar',\n          foo: 'foo',\n          other: 'other',\n          stuff: 'stuff',\n          thing: 'thing'\n        });\n        assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'then-namespace-bailout.js', './async.js'))), new Set(['*']));\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: esmodule output","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":814,"column":85,"index":40108},"line":814,"code":"      it('supports tree shaking statically analyzable dynamic import: esmodule output', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-dynamic-import/then.js'), {\n          mode: 'production',\n          targets: {\n            default: {\n              outputFormat: 'esmodule',\n              distDir\n            }\n          }\n        });\n\n        // let output = await run(b);\n        // assert.deepEqual(output, 'foo');\n\n        assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'then.js', './async.js'))), new Set(['foo', 'thing']));\n        assert(b.isDependencySkipped(findDependency(b, 'async.js', './a1.js')));\n        let contents = await outputFS.readFile(b.getBundles().find(b => b.getMainEntry().filePath.endsWith('async.js')).filePath, 'utf8');\n        assert(!contents.includes('bar'));\n        assert(!contents.includes('stuff'));\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"throws an error for missing exports for dynamic import: destructured await assignment","suites":["scope hoisting","es6","tree shaking dynamic imports"],"line":834,"code":"      it.skip('throws an error for missing exports for dynamic import: destructured await assignment', async function () {","file":"scope-hoisting.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"throws an error for missing exports for dynamic import: destructured await declaration","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":860,"column":96,"index":41944},"line":860,"code":"      it('throws an error for missing exports for dynamic import: destructured await declaration', async function () {\n        let source = path.join(__dirname, 'integration/scope-hoisting/es6/tree-shaking-dynamic-import', 'await-declaration-error.js');\n        let message = `async.js does not export 'missing'`;\n        await assert.rejects(() => bundle(path.join(__dirname, 'integration/scope-hoisting/es6/tree-shaking-dynamic-import', 'await-declaration-error.js')), {\n          name: 'BuildError',\n          message,\n          diagnostics: [{\n            message,\n            origin: '@parcel/core',\n            codeFrames: [{\n              filePath: source,\n              language: 'js',\n              codeHighlights: [{\n                start: {\n                  column: 8,\n                  line: 2\n                },\n                end: {\n                  column: 14,\n                  line: 2\n                }\n              }]\n            }]\n          }]\n        });\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"throws an error for missing exports for dynamic import: namespace await declaration","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":886,"column":93,"index":42931},"line":886,"code":"      it('throws an error for missing exports for dynamic import: namespace await declaration', async function () {\n        let source = path.join(__dirname, 'integration/scope-hoisting/es6/tree-shaking-dynamic-import', 'await-declaration-namespace-error.js');\n        let message = `async.js does not export 'missing'`;\n        await assert.rejects(() => bundle(path.join(__dirname, 'integration/scope-hoisting/es6/tree-shaking-dynamic-import', 'await-declaration-namespace-error.js')), {\n          name: 'BuildError',\n          message,\n          diagnostics: [{\n            message,\n            origin: '@parcel/core',\n            codeFrames: [{\n              filePath: source,\n              language: 'js',\n              codeHighlights: [{\n                start: {\n                  column: 10,\n                  line: 3\n                },\n                end: {\n                  column: 19,\n                  line: 3\n                }\n              }]\n            }]\n          }]\n        });\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"throws an error for missing exports for dynamic import: destructured then","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":912,"column":83,"index":43929},"line":912,"code":"      it('throws an error for missing exports for dynamic import: destructured then', async function () {\n        let source = path.join(__dirname, 'integration/scope-hoisting/es6/tree-shaking-dynamic-import', 'then-error.js');\n        let message = `async.js does not export 'missing'`;\n        await assert.rejects(() => bundle(path.join(__dirname, 'integration/scope-hoisting/es6/tree-shaking-dynamic-import', 'then-error.js')), {\n          name: 'BuildError',\n          message,\n          diagnostics: [{\n            message,\n            origin: '@parcel/core',\n            codeFrames: [{\n              filePath: source,\n              language: 'js',\n              codeHighlights: [{\n                start: {\n                  column: 38,\n                  line: 1\n                },\n                end: {\n                  column: 44,\n                  line: 1\n                }\n              }]\n            }]\n          }]\n        });\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"throws an error for missing exports for dynamic import: namespace then","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":938,"column":80,"index":44878},"line":938,"code":"      it('throws an error for missing exports for dynamic import: namespace then', async function () {\n        let source = path.join(__dirname, 'integration/scope-hoisting/es6/tree-shaking-dynamic-import', 'then-namespace-error.js');\n        let message = `async.js does not export 'missing'`;\n        await assert.rejects(() => bundle(path.join(__dirname, 'integration/scope-hoisting/es6/tree-shaking-dynamic-import', 'then-namespace-error.js')), {\n          name: 'BuildError',\n          message,\n          diagnostics: [{\n            message,\n            origin: '@parcel/core',\n            codeFrames: [{\n              filePath: source,\n              language: 'js',\n              codeHighlights: [{\n                start: {\n                  column: 45,\n                  line: 1\n                },\n                end: {\n                  column: 54,\n                  line: 1\n                }\n              }]\n            }]\n          }]\n        });\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"keeps member expression with computed properties that are variables","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":965,"column":75,"index":45850},"line":965,"code":"    it('keeps member expression with computed properties that are variables', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-export-computed-prop/a.js'), {\n        defaultTargetOptions: {\n          shouldOptimize: true\n        }\n      });\n      let output = await run(b);\n      assert.strictEqual(output[0], true);\n      assert.strictEqual(typeof output[1], 'undefined');\n      assert.strictEqual(output[2], true);\n      assert.strictEqual(typeof output[3], 'undefined');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"support exporting a ES6 module exported as CommonJS","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":977,"column":59,"index":46381},"line":977,"code":"    it('support exporting a ES6 module exported as CommonJS', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-commonjs/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'foo');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"concatenates in the correct order when re-exporting assets were excluded","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":982,"column":80,"index":46673},"line":982,"code":"    it('concatenates in the correct order when re-exporting assets were excluded', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-false-order/index.js'));\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(/\\s+class\\s+/.test(contents));\n      let called = false;\n      let output = await run(b, {\n        sideEffect: () => {\n          called = true;\n        }\n      });\n      assert(!called, 'side effect called');\n      assert.strictEqual(output[0], 'a');\n      assert.strictEqual(output[1], 'b');\n      assert(new output[3]() instanceof output[2]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support chained reexports from hybrid modules","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":997,"column":60,"index":47323},"line":997,"code":"    it('should support chained reexports from hybrid modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-hybrid/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support chained reexports as default from hybrid modules","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1002,"column":71,"index":47602},"line":1002,"code":"    it('should support chained reexports as default from hybrid modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-default-hybrid/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"support chained namespace reexports of CommonJS","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1007,"column":55,"index":47873},"line":1007,"code":"    it('support chained namespace reexports of CommonJS', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-commonjs-wildcard/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'foo');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support assets importing themselves","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1012,"column":50,"index":48144},"line":1012,"code":"    it('should support assets importing themselves', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-self/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 4);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support named imports on wrapped modules","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1017,"column":55,"index":48402},"line":1017,"code":"    it('should support named imports on wrapped modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-wrapped/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support unused imports of wrapped modules in different bundles","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1022,"column":77,"index":48687},"line":1022,"code":"    it('should support unused imports of wrapped modules in different bundles', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-wrapped-bundle-unused/a.js'));\n      let called = false;\n      await run(b, {\n        sideEffect() {\n          called = true;\n        }\n      });\n      assert(called);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert esModule flag for interop for async (or shared) bundles","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1032,"column":77,"index":49051},"line":1032,"code":"    it('should insert esModule flag for interop for async (or shared) bundles', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/interop-async/index.html'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldOptimize: false\n        }\n      });\n      let res = await run(b, {\n        output: null\n      }, {\n        require: false\n      });\n      assert.deepEqual(await res.output, ['client', 'client', 'viewer']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should enable minifier to remove unused modules despite of interopDefault","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1046,"column":81,"index":49556},"line":1046,"code":"    it('should enable minifier to remove unused modules despite of interopDefault', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/interop-pure/a.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldOptimize: true,\n          sourceMaps: false\n        }\n      });\n      let contents = await outputFS.readFileSync(b.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(contents.trim().length, 0);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the jsx pragma","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1057,"column":37,"index":50007},"line":1057,"code":"    it('should support the jsx pragma', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/jsx-pragma/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        children: 'Test',\n        props: null,\n        type: 'span'\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not nameclash with internal variables","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1066,"column":52,"index":50335},"line":1066,"code":"    it('should not nameclash with internal variables', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/name-clash/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should shake pure property assignments","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1071,"column":46,"index":50585},"line":1071,"code":"    it('should shake pure property assignments', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/pure-assignment/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 2);\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('exports.bar ='));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly rename references to default exported classes","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1078,"column":70,"index":50993},"line":1078,"code":"    it('should correctly rename references to default exported classes', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/default-export-class-rename/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output.foo, 'bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly rename references to a class in the class body","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1083,"column":71,"index":51289},"line":1083,"code":"    it('should correctly rename references to a class in the class body', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/class-selfreference/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output.foo, 'bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly codesplit even with reexporting library index","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1088,"column":70,"index":51576},"line":1088,"code":"    it('should correctly codesplit even with reexporting library index', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/codesplit-reexports/src/entry.js'), {\n        mode: 'production'\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['entry.js', 'foo.js', 'bar.js', 'bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n      }, {\n        type: 'js',\n        assets: ['async.js', 'foo2.js', 'bar2.js']\n      }]);\n      let output = await run(b);\n      assert.deepEqual(output, [[20, 30], [2, 3]]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly retarget dependencies when both namespace and indvidual export are used","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1102,"column":96,"index":52205},"line":1102,"code":"    it('should correctly retarget dependencies when both namespace and indvidual export are used', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/retarget-namespace-single/index.js'));\n      let output = await run(b);\n      assert.deepEqual(output, [123, 123]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly handle circular dependencies","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1107,"column":53,"index":52486},"line":1107,"code":"    it('should correctly handle circular dependencies', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/circular/a.mjs'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'b.mjs')))), new Set(['foo']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'c.mjs')))), new Set(['run']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'b.mjs', './c.mjs'))), new Set(['run']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'c.mjs', './b.mjs'))), new Set(['foo']));\n      let output = await run(b);\n      assert.strictEqual(output, 'c:foo');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly handle circular dependencies (2)","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1116,"column":57,"index":53198},"line":1116,"code":"    it('should correctly handle circular dependencies (2)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/circular2/a.mjs'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'b.mjs')))), new Set(['run', 'foo']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'c.mjs')))), new Set([]));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'b.mjs', './c.mjs'))), new Set(['foo']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'c.mjs', './b.mjs'))), new Set(['foo']));\n      let output = await run(b);\n      assert.strictEqual(output, 'b:foo:foo');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly handle circular dependencies (3)","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1125,"column":57,"index":53917},"line":1125,"code":"    it('should correctly handle circular dependencies (3)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/circular3/a.mjs'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'b.mjs')))), new Set([]));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'c.mjs')))), new Set(['a']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'd.mjs')))), new Set([]));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'a.mjs', './b.mjs'))), new Set(['h']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'b.mjs', './c.mjs'))), new Set(['a', 'd', 'g']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'c.mjs', './d.mjs'))), new Set(['c', 'f']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'd.mjs', './b.mjs'))), new Set(['b', 'e']));\n      let output = await run(b);\n      assert.strictEqual(output, 123);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle circular dependencies with wrapped assets","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1137,"column":63,"index":54970},"line":1137,"code":"    it('should handle circular dependencies with wrapped assets', async () => {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/circular-wrap/index.mjs'));\n      let output = [];\n      await run(b, {\n        output(o) {\n          output.push(o);\n        }\n      });\n      assert.deepEqual(output, ['d', 'c', 'b', 'a', 'index']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not tree-shake assignments to unknown objects","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1147,"column":58,"index":55335},"line":1147,"code":"    it('does not tree-shake assignments to unknown objects', async () => {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-no-unknown-objects/index.js'));\n      assert.equal(await run(b), 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can conditionally reference an imported symbol and unconditionally reference it","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1151,"column":87,"index":55611},"line":1151,"code":"    it('can conditionally reference an imported symbol and unconditionally reference it', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/conditional-import-reference/index.js'));\n      let output = await run(b);\n      assert.equal(output, 'hello');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can conditionally reference an imported symbol from another bundle in a case clause","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1156,"column":91,"index":55926},"line":1156,"code":"    it('can conditionally reference an imported symbol from another bundle in a case clause', async () => {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/async-interop-conditional/index.js'));\n      let output = await run(b);\n      assert.equal(await output, 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"handles redirects up the tree","suites":["scope hoisting","es6","considers an asset's closest package.json for sideEffects, not the package through which it found the asset"],"updatePoint":{"line":1162,"column":39,"index":56313},"line":1162,"code":"      it('handles redirects up the tree', async () => {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-package-redirect-up/index.js'));\n        let result = await run(b);\n        assert.strictEqual(result, 1);\n        let bar = findAsset(b, 'real-bar.js');\n        assert(bar);\n        assert.strictEqual(bar.sideEffects, false);\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"handles redirects down the tree","suites":["scope hoisting","es6","considers an asset's closest package.json for sideEffects, not the package through which it found the asset"],"updatePoint":{"line":1170,"column":41,"index":56704},"line":1170,"code":"      it('handles redirects down the tree', async () => {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-package-redirect-down/index.js'));\n        let result = await run(b);\n        assert.strictEqual(result, 1);\n        let bar = findAsset(b, 'real-bar.js');\n        assert(bar);\n        assert.strictEqual(bar.sideEffects, false);\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"throws after removing an export","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1180,"column":41,"index":57171},"line":1180,"code":"      it('throws after removing an export', async function () {\n        let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/update-used-symbols-remove-export');\n        let b = bundler(path.join(testDir, 'a.js'), {\n          inputFS: overlayFS,\n          outputFS: overlayFS\n        });\n        await overlayFS.mkdirp(testDir);\n        await overlayFS.copyFile(path.join(testDir, 'b.1.js'), path.join(testDir, 'b.js'));\n        let subscription = await b.watch();\n        try {\n          let bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          let output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, 123);\n          await overlayFS.copyFile(path.join(testDir, 'b.2.js'), path.join(testDir, 'b.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildFailure');\n          let message = md`${normalizePath('integration/scope-hoisting/es6/update-used-symbols-remove-export/b.js', false)} does not export 'foo'`;\n          assert.deepEqual(bundleEvent.diagnostics, [{\n            message,\n            origin: '@parcel/core',\n            codeFrames: [{\n              filePath: path.join(testDir, 'a.js'),\n              language: 'js',\n              codeHighlights: [{\n                start: {\n                  line: 1,\n                  column: 10\n                },\n                end: {\n                  line: 1,\n                  column: 12\n                }\n              }]\n            }]\n          }]);\n          await overlayFS.copyFile(path.join(testDir, 'b.1.js'), path.join(testDir, 'b.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, 123);\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(findAsset(bundleEvent.bundleGraph, 'b.js'))), new Set(['foo']));\n        } finally {\n          await subscription.unsubscribe();\n        }\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"dependency symbols change","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1226,"column":35,"index":59255},"line":1226,"code":"      it('dependency symbols change', async function () {\n        let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/update-used-symbols-dependency-symbols');\n        let b = bundler(path.join(testDir, 'index.js'), {\n          inputFS: overlayFS,\n          outputFS: overlayFS\n        });\n        await overlayFS.mkdirp(testDir);\n        await overlayFS.copyFile(path.join(testDir, 'index.1.js'), path.join(testDir, 'index.js'));\n        let subscription = await b.watch();\n        try {\n          let bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          let output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, [123]);\n          await overlayFS.copyFile(path.join(testDir, 'index.2.js'), path.join(testDir, 'index.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, [123, 789]);\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(findAsset(bundleEvent.bundleGraph, 'c.js'))), new Set(['c']));\n          await overlayFS.copyFile(path.join(testDir, 'index.1.js'), path.join(testDir, 'index.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, [123]);\n          assert(!findAsset(bundleEvent.bundleGraph, 'c.js'));\n        } finally {\n          await subscription.unsubscribe();\n        }\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"add and remove dependency (keep asset)","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1256,"column":48,"index":60907},"line":1256,"code":"      it('add and remove dependency (keep asset)', async function () {\n        let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/update-used-symbols-dependency-add');\n        let b = bundler(path.join(testDir, 'index.js'), {\n          inputFS: overlayFS,\n          outputFS: overlayFS\n        });\n        await overlayFS.mkdirp(testDir);\n        await overlayFS.copyFile(path.join(testDir, 'index.1.js'), path.join(testDir, 'index.js'));\n        let subscription = await b.watch();\n        try {\n          let bundleEvent = await getNextBuild(b);\n          assert(bundleEvent.type === 'buildSuccess');\n          let output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, [123]);\n          let assetC = nullthrows(findAsset(bundleEvent.bundleGraph, 'd1.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetC)), new Set(['a']));\n          assert(!findAsset(bundleEvent.bundleGraph, 'd2.js'));\n          await overlayFS.copyFile(path.join(testDir, 'index.2.js'), path.join(testDir, 'index.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, [123, 789, {\n            d1: 1,\n            d2: 2\n          }]);\n          assetC = nullthrows(findAsset(bundleEvent.bundleGraph, 'd1.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetC)), new Set(['a', 'b']));\n          let assetD = nullthrows(findAsset(bundleEvent.bundleGraph, 'd2.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetD)), new Set(['*']));\n          await overlayFS.copyFile(path.join(testDir, 'index.1.js'), path.join(testDir, 'index.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, [123]);\n          assetC = nullthrows(findAsset(bundleEvent.bundleGraph, 'd1.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetC)), new Set(['a']));\n          assert(!findAsset(bundleEvent.bundleGraph, 'd2.js'));\n        } finally {\n          await subscription.unsubscribe();\n        }\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"add and remove dependency (remove asset)","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1297,"column":50,"index":63267},"line":1297,"code":"      it('add and remove dependency (remove asset)', async function () {\n        let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/update-used-symbols-dependency-add');\n        let b = bundler(path.join(testDir, 'index.js'), {\n          inputFS: overlayFS,\n          outputFS: overlayFS\n        });\n        await overlayFS.mkdirp(testDir);\n        await overlayFS.copyFile(path.join(testDir, 'index.3.js'), path.join(testDir, 'index.js'));\n        let subscription = await b.watch();\n        try {\n          let bundleEvent = await getNextBuild(b);\n          assert(bundleEvent.type === 'buildSuccess');\n          let output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, [789, {\n            d1: 1,\n            d2: 2\n          }]);\n          let assetC = nullthrows(findAsset(bundleEvent.bundleGraph, 'd1.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetC)), new Set(['b']));\n          let assetD = nullthrows(findAsset(bundleEvent.bundleGraph, 'd2.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetD)), new Set(['*']));\n          await overlayFS.copyFile(path.join(testDir, 'index.2.js'), path.join(testDir, 'index.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, [123, 789, {\n            d1: 1,\n            d2: 2\n          }]);\n          assetC = nullthrows(findAsset(bundleEvent.bundleGraph, 'd1.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetC)), new Set(['a', 'b']));\n          assetD = nullthrows(findAsset(bundleEvent.bundleGraph, 'd2.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetD)), new Set(['*']));\n          await overlayFS.copyFile(path.join(testDir, 'index.3.js'), path.join(testDir, 'index.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, [789, {\n            d1: 1,\n            d2: 2\n          }]);\n          assetC = nullthrows(findAsset(bundleEvent.bundleGraph, 'd1.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetC)), new Set(['b']));\n          assetD = nullthrows(findAsset(bundleEvent.bundleGraph, 'd2.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetD)), new Set(['*']));\n        } finally {\n          await subscription.unsubscribe();\n        }\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"add and remove dependency with inline asset","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1346,"column":53,"index":65972},"line":1346,"code":"      it('add and remove dependency with inline asset', async function () {\n        let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/update-used-symbols-dependency-add-inline');\n        let b = bundler(path.join(testDir, 'index.js'), {\n          inputFS: overlayFS,\n          outputFS: overlayFS\n        });\n        await overlayFS.mkdirp(testDir);\n        await overlayFS.copyFile(path.join(testDir, 'other.1.js'), path.join(testDir, 'other.js'));\n        let subscription = await b.watch();\n        try {\n          let bundleEvent = await getNextBuild(b);\n          assert(bundleEvent.type === 'buildSuccess');\n          let output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, 123);\n          let assetOther = nullthrows(findAsset(bundleEvent.bundleGraph, 'other.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetOther)), new Set([]));\n          await overlayFS.copyFile(path.join(testDir, 'other.2.js'), path.join(testDir, 'other.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, 1);\n          assetOther = nullthrows(findAsset(bundleEvent.bundleGraph, 'other.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetOther)), new Set(['a']));\n          await overlayFS.copyFile(path.join(testDir, 'other.1.js'), path.join(testDir, 'other.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, 123);\n          assetOther = nullthrows(findAsset(bundleEvent.bundleGraph, 'other.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetOther)), new Set([]));\n          assert(!findAsset(bundleEvent.bundleGraph, 'd2.js'));\n        } finally {\n          await subscription.unsubscribe();\n        }\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"add and remove dependency with namespace","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1381,"column":50,"index":68045},"line":1381,"code":"      it('add and remove dependency with namespace', async function () {\n        let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/update-used-symbols-dependency-add-namespace');\n        let b = bundler(path.join(testDir, 'index.html'), {\n          inputFS: overlayFS,\n          outputFS: overlayFS,\n          mode: 'production'\n        });\n        await overlayFS.mkdirp(testDir);\n        await overlayFS.copyFile(path.join(testDir, 'index.1.js'), path.join(testDir, 'index.js'));\n        let subscription = await b.watch();\n        try {\n          let bundleEvent = await getNextBuild(b);\n          assert(bundleEvent.type === 'buildSuccess');\n          let res = await run(bundleEvent.bundleGraph, {\n            output: null\n          }, {\n            require: false\n          });\n          assert.deepEqual(await res.output, {\n            akGridSize: 8\n          });\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(findAsset(bundleEvent.bundleGraph, 'themeConstants.js'))), new Set(['gridSize']));\n          assert(!findAsset(bundleEvent.bundleGraph, 'themeColors.js'));\n          await overlayFS.copyFile(path.join(testDir, 'index.2.js'), path.join(testDir, 'index.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          res = await run(bundleEvent.bundleGraph, {\n            output: null\n          }, {\n            require: false\n          });\n          assert.deepEqual(await res.output, [{\n            akGridSize: 8\n          }, {\n            akEmojiSelectedBackgroundColor: '#EBECF0'\n          }]);\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(findAsset(bundleEvent.bundleGraph, 'themeConstants.js'))), new Set(['borderRadius', 'gridSize']));\n          assert(!findAsset(bundleEvent.bundleGraph, 'theme.js'));\n          assert(findAsset(bundleEvent.bundleGraph, 'themeColors.js'));\n          await overlayFS.copyFile(path.join(testDir, 'index.1.js'), path.join(testDir, 'index.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          res = await run(bundleEvent.bundleGraph, {\n            output: null\n          }, {\n            require: false\n          });\n          assert.deepEqual(await res.output, {\n            akGridSize: 8\n          });\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(findAsset(bundleEvent.bundleGraph, 'themeConstants.js'))), new Set(['gridSize']));\n          assert(!findAsset(bundleEvent.bundleGraph, 'themeColors.js'));\n        } finally {\n          await subscription.unsubscribe();\n        }\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes functions that increment variables in object properties","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1438,"column":71,"index":70776},"line":1438,"code":"    it('removes functions that increment variables in object properties', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-increment-object/a.js'), {\n        defaultTargetOptions: {\n          shouldOptimize: true\n        }\n      });\n      let content = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(!content.includes('++'));\n      await run(b);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can import urls to raw assets","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1448,"column":37,"index":71188},"line":1448,"code":"    it('can import urls to raw assets', async () => {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/raw-url/index-import.js'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'index-import.js', 'url:./foo.png'))), new Set(['default']));\n      let output = await run(b);\n      assert(/foo\\.[a-f0-9]+\\.png$/.test(output));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can reexport urls to raw assets","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1454,"column":39,"index":71579},"line":1454,"code":"    it('can reexport urls to raw assets', async () => {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/raw-url/index-reexport.js'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'index-reexport.js', './reexports'))), new Set(['assetUrl']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'reexports.js', 'url:./foo.png'))), new Set(['default']));\n      let output = await run(b);\n      assert(/foo\\.[a-f0-9]+\\.png$/.test(output));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should wrap modules in shared bundles","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1461,"column":45,"index":72110},"line":1461,"code":"    it('should wrap modules in shared bundles', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5659\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/shared-bundle-side-effect-order/index.js'), {\n        mode: 'production'\n      });\n      let sideEffects = [];\n      let res = await run(b, {\n        sideEffect(out) {\n          sideEffects.push(out);\n        }\n      });\n      await res;\n      assert.deepEqual(sideEffects, ['shared1', 'run1 1', 'shared2', 'run2 2']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ensure that modules are only executed once in shared bundles","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1475,"column":75,"index":72677},"line":1475,"code":"    it('should ensure that modules are only executed once in shared bundles', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5659\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/shared-bundle-side-effect-duplication/index.js'), {\n        mode: 'production'\n      });\n      let sideEffects = [];\n      let res = await run(b, {\n        sideEffect(out) {\n          sideEffects.push(out);\n        }\n      });\n      await res;\n      assert.deepEqual(sideEffects, ['v']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when assigning to a named import","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1489,"column":53,"index":73191},"line":1489,"code":"    it('should error when assigning to a named import', async function () {\n      let source = path.join(__dirname, 'integration/scope-hoisting/es6/import-local-assign/named.js');\n      await assert.rejects(() => bundle(source), {\n        name: 'BuildError',\n        message: 'Assignment to an import specifier is not allowed',\n        diagnostics: [{\n          message: 'Assignment to an import specifier is not allowed',\n          origin: '@parcel/transformer-js',\n          codeFrames: [{\n            filePath: source,\n            codeHighlights: [{\n              message: null,\n              start: {\n                line: 2,\n                column: 1\n              },\n              end: {\n                line: 2,\n                column: 3\n              }\n            }, {\n              message: 'Originally imported here',\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 11\n              }\n            }]\n          }],\n          hints: null\n        }]\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when assigning to a default import","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1525,"column":55,"index":74282},"line":1525,"code":"    it('should error when assigning to a default import', async function () {\n      let source = path.join(__dirname, 'integration/scope-hoisting/es6/import-local-assign/default.js');\n      await assert.rejects(() => bundle(source), {\n        name: 'BuildError',\n        message: 'Assignment to an import specifier is not allowed',\n        diagnostics: [{\n          message: 'Assignment to an import specifier is not allowed',\n          origin: '@parcel/transformer-js',\n          codeFrames: [{\n            filePath: source,\n            codeHighlights: [{\n              message: null,\n              start: {\n                line: 2,\n                column: 1\n              },\n              end: {\n                line: 2,\n                column: 1\n              }\n            }, {\n              message: 'Originally imported here',\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 8\n              }\n            }]\n          }],\n          hints: null\n        }]\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when assigning to a namespace import","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1561,"column":57,"index":75376},"line":1561,"code":"    it('should error when assigning to a namespace import', async function () {\n      let source = path.join(__dirname, 'integration/scope-hoisting/es6/import-local-assign/namespace.js');\n      await assert.rejects(() => bundle(source), {\n        name: 'BuildError',\n        message: 'Assignment to an import specifier is not allowed',\n        diagnostics: [{\n          message: 'Assignment to an import specifier is not allowed',\n          origin: '@parcel/transformer-js',\n          codeFrames: [{\n            filePath: source,\n            codeHighlights: [{\n              message: null,\n              start: {\n                line: 2,\n                column: 1\n              },\n              end: {\n                line: 2,\n                column: 1\n              }\n            }, {\n              message: 'Originally imported here',\n              start: {\n                line: 1,\n                column: 13\n              },\n              end: {\n                line: 1,\n                column: 13\n              }\n            }]\n          }],\n          hints: null\n        }]\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error with a destructuring assignment to a namespace import","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1597,"column":74,"index":76491},"line":1597,"code":"    it('should error with a destructuring assignment to a namespace import', async function () {\n      let source = path.join(__dirname, 'integration/scope-hoisting/es6/import-local-assign/destructure-assign.js');\n      await assert.rejects(() => bundle(source), {\n        name: 'BuildError',\n        message: 'Assignment to an import specifier is not allowed',\n        diagnostics: [{\n          message: 'Assignment to an import specifier is not allowed',\n          origin: '@parcel/transformer-js',\n          codeFrames: [{\n            filePath: source,\n            codeHighlights: [{\n              message: null,\n              start: {\n                line: 2,\n                column: 8\n              },\n              end: {\n                line: 2,\n                column: 10\n              }\n            }, {\n              message: 'Originally imported here',\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 11\n              }\n            }]\n          }],\n          hints: null\n        }]\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error with multiple assignments to an import","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1633,"column":59,"index":77600},"line":1633,"code":"    it('should error with multiple assignments to an import', async function () {\n      let source = path.join(__dirname, 'integration/scope-hoisting/es6/import-local-assign/multiple.js');\n      await assert.rejects(() => bundle(source), {\n        name: 'BuildError',\n        message: 'Assignment to an import specifier is not allowed',\n        diagnostics: [{\n          message: 'Assignment to an import specifier is not allowed',\n          origin: '@parcel/transformer-js',\n          codeFrames: [{\n            filePath: source,\n            codeHighlights: [{\n              message: null,\n              start: {\n                line: 2,\n                column: 1\n              },\n              end: {\n                line: 2,\n                column: 3\n              }\n            }, {\n              message: null,\n              start: {\n                line: 3,\n                column: 1\n              },\n              end: {\n                line: 3,\n                column: 3\n              }\n            }, {\n              message: 'Originally imported here',\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 11\n              }\n            }]\n          }],\n          hints: null\n        }]\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should allow re-declaring __esModule interop flag","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1679,"column":57,"index":78921},"line":1679,"code":"    it('should allow re-declaring __esModule interop flag', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/double-esmodule/index.js'));\n      let res = await run(b);\n      assert.deepEqual(res, 'default');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can dynamically import a side-effect-free reexport","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1684,"column":58,"index":79189},"line":1684,"code":"    it('can dynamically import a side-effect-free reexport', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/conditional-import-side-effect-free-reexport/index.mjs'));\n      assert.deepEqual(await run(b), 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"individually exports symbols from intermediately wrapped reexports","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1688,"column":74,"index":79469},"line":1688,"code":"    it('individually exports symbols from intermediately wrapped reexports', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/export-intermediate-wrapped-reexports/index.mjs'));\n      let res = await Promise.all(await run(b));\n      assert.deepEqual(res, [42, 42]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should treat type-only TypeScript modules as ESM","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1693,"column":56,"index":79770},"line":1693,"code":"    it('should treat type-only TypeScript modules as ESM', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/empty-ts/index.ts'));\n      let test = await run(b);\n      assert.equal(test({\n        foo: 2\n      }), 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not include default when reexporting * without $parcel$exportWildcard","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1700,"column":84,"index":80067},"line":1700,"code":"    it('should not include default when reexporting * without $parcel$exportWildcard', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/no-reexport-default/index.js'));\n      assert.equal(await run(b), 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not include __esModule when reexporting * without $parcel$exportWildcard","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1704,"column":87,"index":80330},"line":1704,"code":"    it('should not include __esModule when reexporting * without $parcel$exportWildcard', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/no-reexport-esmodule/index.js'));\n      assert.equal(await run(b), undefined);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle interop with a re-export namespace","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1708,"column":56,"index":80570},"line":1708,"code":"    it('should handle interop with a re-export namespace', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/re-export-interop/a.js'));\n      let res = await run(b);\n      assert.deepEqual(res['en_US'], {\n        test: 'foo'\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should prioritize named exports before re-exports (before)","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1715,"column":66,"index":80867},"line":1715,"code":"    it('should prioritize named exports before re-exports (before)', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/re-export-priority/entry-a.mjs'));\n      let res = await run(b);\n      assert.equal(res, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should prioritize named exports before re-exports (after)","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1720,"column":65,"index":81130},"line":1720,"code":"    it('should prioritize named exports before re-exports (after)', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/re-export-priority/entry-b.mjs'));\n      let res = await run(b);\n      assert.equal(res, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should prioritize named exports before re-exports in namespace (before)","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1725,"column":79,"index":81407},"line":1725,"code":"    it('should prioritize named exports before re-exports in namespace (before)', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/re-export-priority/namespace-a.mjs'));\n      let res = await run(b);\n      assert.deepEqual(res, {\n        foo: 2\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should prioritize named exports before re-exports in namespace (after)","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1732,"column":78,"index":81714},"line":1732,"code":"    it('should prioritize named exports before re-exports in namespace (after)', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/re-export-priority/namespace-b.mjs'));\n      let res = await run(b);\n      assert.deepEqual(res, {\n        foo: 2\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of commonjs modules","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1741,"column":44,"index":82030},"line":1741,"code":"    it('supports require of commonjs modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"concats commonjs modules in the correct order","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1746,"column":53,"index":82281},"line":1746,"code":"    it('concats commonjs modules in the correct order', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/concat-order/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports default imports of commonjs modules","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1751,"column":52,"index":82536},"line":1751,"code":"    it('supports default imports of commonjs modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/default-import/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"concats modules with inserted globals in the correct order","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1756,"column":66,"index":82807},"line":1756,"code":"    it('concats modules with inserted globals in the correct order', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/concat-order-globals/a.js'));\n      let output = await run(b);\n      assert.equal(output, 'foobar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named imports of commonjs modules","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1761,"column":50,"index":83075},"line":1761,"code":"    it('supports named imports of commonjs modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/named-import/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports namespace imports of commonjs modules","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1766,"column":54,"index":83332},"line":1766,"code":"    it('supports namespace imports of commonjs modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/import-namespace/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of es6 default export of expressions","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1771,"column":61,"index":83600},"line":1771,"code":"    it('supports require of es6 default export of expressions', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-default-export-expression/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of es6 default export of declarations","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1776,"column":62,"index":83886},"line":1776,"code":"    it('supports require of es6 default export of declarations', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-default-export-declaration/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of es6 default export of variables","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1781,"column":59,"index":84170},"line":1781,"code":"    it('supports require of es6 default export of variables', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-default-export-variable/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of es6 named export of declarations","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1786,"column":60,"index":84452},"line":1786,"code":"    it('supports require of es6 named export of declarations', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-named-export-declaration/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of es6 named export of variables","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1791,"column":57,"index":84732},"line":1791,"code":"    it('supports require of es6 named export of variables', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-named-export-variable/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of es6 renamed exports","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1796,"column":47,"index":84999},"line":1796,"code":"    it('supports require of es6 renamed exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-renamed-export/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of es6 module re-exporting all exports from another module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1801,"column":83,"index":85295},"line":1801,"code":"    it('supports require of es6 module re-exporting all exports from another module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-re-export-all/a.js'));\n      let output = await run(b);\n      assert.equal(output, 6);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of es6 module re-exporting all exports from multiple modules","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1806,"column":85,"index":85592},"line":1806,"code":"    it('supports require of es6 module re-exporting all exports from multiple modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-re-export-multiple/a.js'));\n      let output = await run(b);\n      assert.equal(output, 7);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting individual named exports from another module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1811,"column":74,"index":85883},"line":1811,"code":"    it('supports re-exporting individual named exports from another module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-re-export-named/a.js'));\n      let output = await run(b);\n      assert.equal(output, 3);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting default exports from another module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1816,"column":65,"index":86162},"line":1816,"code":"    it('supports re-exporting default exports from another module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-re-export-default/a.js'));\n      let output = await run(b);\n      assert.equal(output, 3);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting a namespace from another module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1821,"column":61,"index":86439},"line":1821,"code":"    it('supports re-exporting a namespace from another module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-re-export-namespace/a.js'));\n      let output = await run(b);\n      assert.equal(output, 6);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"excludes default when re-exporting a module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1826,"column":51,"index":86708},"line":1826,"code":"    it('excludes default when re-exporting a module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-re-export-exclude-default/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        foo: 3\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports hybrid ES6 + commonjs modules","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1833,"column":46,"index":87005},"line":1833,"code":"    it('supports hybrid ES6 + commonjs modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/es6-commonjs-hybrid/a.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"inserts commonjs exports object in the right place","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1838,"column":58,"index":87273},"line":1838,"code":"    it('inserts commonjs exports object in the right place', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/export-order/a.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out exports access resolving if it is accessed freely (exports assign)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1843,"column":84,"index":87560},"line":1843,"code":"    it('bails out exports access resolving if it is accessed freely (exports assign)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/exports-assign.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out exports access resolving if it is accessed freely (exports define)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1848,"column":84,"index":87870},"line":1848,"code":"    it('bails out exports access resolving if it is accessed freely (exports define)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/exports-define.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out exports access resolving if it is accessed freely (module.exports assign)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1853,"column":91,"index":88187},"line":1853,"code":"    it('bails out exports access resolving if it is accessed freely (module.exports assign)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/module-exports-assign.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out exports access resolving if it is accessed freely (module.exports define)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1858,"column":91,"index":88511},"line":1858,"code":"    it('bails out exports access resolving if it is accessed freely (module.exports define)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/module-exports-define.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out imported exports access resolving if it is accessed freely (exports assign)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1863,"column":93,"index":88837},"line":1863,"code":"    it('bails out imported exports access resolving if it is accessed freely (exports assign)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/exports-assign-entry.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out imported exports access resolving if it is accessed freely (exports define)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1868,"column":93,"index":89162},"line":1868,"code":"    it('bails out imported exports access resolving if it is accessed freely (exports define)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/exports-define-entry.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out imported exports access resolving if it is accessed freely (module.exports assign)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1873,"column":100,"index":89494},"line":1873,"code":"    it('bails out imported exports access resolving if it is accessed freely (module.exports assign)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/module-exports-assign-entry.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out imported exports access resolving if it is accessed freely (module.exports define)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1878,"column":100,"index":89833},"line":1878,"code":"    it('bails out imported exports access resolving if it is accessed freely (module.exports define)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/module-exports-define-entry.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out imported exports access resolving if it is accessed freely (exports reexport)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1883,"column":95,"index":90167},"line":1883,"code":"    it('bails out imported exports access resolving if it is accessed freely (exports reexport)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/exports-assign-reexport-entry.js'));\n      let output = await run(b);\n      assert.deepEqual(output, [5, 5]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"builds commonjs modules that assigns to exports before module.exports","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1888,"column":77,"index":90494},"line":1888,"code":"    it('builds commonjs modules that assigns to exports before module.exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-before-module-exports/a.js'));\n      let output = await run(b);\n      assert.equal(output, 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"builds commonjs modules that assigns to module.exports before exports","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1893,"column":77,"index":90792},"line":1893,"code":"    it('builds commonjs modules that assigns to module.exports before exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/module-exports-before-exports/a.js'));\n      let output = await run(b);\n      assert.equal(output, 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support assigning to module.exports with another export","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1898,"column":70,"index":91083},"line":1898,"code":"    it('should support assigning to module.exports with another export', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5782\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/module-exports-default-assignment/index.js'));\n      let output = await run(b);\n      assert.equal(output.foo, 'b');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"doesn't insert parcelRequire for missing non-js assets","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1904,"column":62,"index":91441},"line":1904,"code":"    it(\"doesn't insert parcelRequire for missing non-js assets\", async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/missing-non-js/a.js'));\n      let output = await run(b);\n      assert.equal(output, 27);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"define exports in the outermost scope","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1909,"column":45,"index":91692},"line":1909,"code":"    it('define exports in the outermost scope', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/define-exports/a.js'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'a.js')))), new Set(['*']));\n      let output = await run(b);\n      assert.equal(output, 'bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports live bindings of named exports","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1915,"column":47,"index":92055},"line":1915,"code":"    it('supports live bindings of named exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/live-bindings/a.js'));\n      let output = await run(b);\n      assert.equal(output, 8);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should wrap modules that use eval in a function","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1920,"column":55,"index":92314},"line":1920,"code":"    it('should wrap modules that use eval in a function', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-eval/a.js'));\n      let output = await run(b);\n      assert.equal(output, 4);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should wrap modules that have a top-level return","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1925,"column":56,"index":92570},"line":1925,"code":"    it('should wrap modules that have a top-level return', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-return/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove unused exports assignments for wrapped modules","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1930,"column":68,"index":92840},"line":1930,"code":"    it('should remove unused exports assignments for wrapped modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-unused/a.js'));\n      let output = await run(b);\n      assert.equal(output, 1);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should hoist all vars in the scope","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1935,"column":42,"index":93084},"line":1935,"code":"    it('should hoist all vars in the scope', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-var-hoisting/a.js'));\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.split('f1_var').length - 1, 1);\n      assert(contents.split('f2_var').length - 1, 1);\n      assert(contents.split('f3_var').length - 1, 1);\n      assert(contents.split('f4_var').length - 1, 1);\n      assert(contents.split('c1_var').length - 1, 1);\n      assert(contents.split('c2_var').length - 1, 1);\n      assert(contents.split('BigIntSupported').length - 1, 4);\n      assert(contents.split('inner_let').length - 1, 2);\n      let output = await run(b);\n      assert.equal(output, true);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should wrap modules that access `module` as a free variable","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1949,"column":67,"index":93888},"line":1949,"code":"    it('should wrap modules that access `module` as a free variable', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-module/a.js'));\n      assert.deepEqual((await run(b)).exports, {\n        foo: 2\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should call init for wrapped modules when codesplitting","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1955,"column":63,"index":94163},"line":1955,"code":"    it('should call init for wrapped modules when codesplitting', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-module-codesplit/a.js'));\n      assert.deepEqual(await run(b), 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should wrap modules that non-statically access `module`","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1959,"column":63,"index":94415},"line":1959,"code":"    it('should wrap modules that non-statically access `module`', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-module-computed/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        foo: 2\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support referencing a require in object literal shorthands when wrapped","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1966,"column":86,"index":94739},"line":1966,"code":"    it('should support referencing a require in object literal shorthands when wrapped', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-module-obj-literal-require/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 1234);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support typeof require when wrapped","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1971,"column":50,"index":95020},"line":1971,"code":"    it('should support typeof require when wrapped', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5883\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-typeof-require/a.js'));\n      let output = await run(b);\n      assert.equal(output, 'c1');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not rename function local variables according to global replacements","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1977,"column":83,"index":95378},"line":1977,"code":"    it('should not rename function local variables according to global replacements', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/keep-local-function-var/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'foo');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports using this in arrow functions","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1982,"column":46,"index":95646},"line":1982,"code":"    it('supports using this in arrow functions', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/this-arrow-function/a.js'));\n      let content = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(content.includes('=>'));\n      let output = await run(b);\n      assert.strictEqual(output, 'Say other');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports assigning to this as exports object","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1989,"column":52,"index":96043},"line":1989,"code":"    it('supports assigning to this as exports object', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/this-reference/a.js'));\n      let output = await run(b, {\n        output: null\n      }, {\n        strict: true\n      });\n      assert.deepEqual(output, [6, undefined]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports assigning to this as exports object in wrapped module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1998,"column":70,"index":96399},"line":1998,"code":"    it('supports assigning to this as exports object in wrapped module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/this-reference-wrapped/a.js'));\n      let output = await run(b, {\n        output: null\n      }, {\n        strict: true\n      });\n      assert.deepEqual(output, [6, undefined, 4]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports using exports self reference","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2007,"column":45,"index":96741},"line":2007,"code":"    it('supports using exports self reference', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-self-reference/a.js'));\n      let content = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(content.includes('=>'));\n      let output = await run(b);\n      assert.strictEqual(output, 'Say other');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports using module.exports self reference","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2014,"column":52,"index":97141},"line":2014,"code":"    it('supports using module.exports self reference', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/module-exports-self-reference/a.js'));\n      let content = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(content.includes('=>'));\n      let output = await run(b);\n      assert.strictEqual(output, 'Say other');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports using module.require like require","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2021,"column":50,"index":97546},"line":2021,"code":"    it('supports using module.require like require', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/module-require/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output.b, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"support url imports in wrapped modules with interop","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2026,"column":59,"index":97818},"line":2026,"code":"    it('support url imports in wrapped modules with interop', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-interop-url-import/a.js'));\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['a.js', 'b.js', 'bundle-url.js']\n      }, {\n        type: 'txt',\n        assets: ['data.txt']\n      }]);\n      let output = await run(b);\n      assert(output.endsWith('.txt'));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports module object properties","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2038,"column":41,"index":98249},"line":2038,"code":"    it('supports module object properties', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/module-object/a.js'));\n      let entryAsset = b.getBundles()[0].getMainEntry();\n\n      // TODO: this test doesn't currently work in older browsers since babel\n      // replaces the typeof calls before we can get to them.\n      let output = await run(b);\n      assert.equal(output.id, b.getAssetPublicId(entryAsset));\n      assert.equal(output.hot, null);\n      assert.equal(output.moduleRequire, null);\n      assert.equal(output.type, 'object');\n      assert.deepEqual(output.exports, {});\n      assert.equal(output.exportsType, 'object');\n      assert.equal(output.require, 'function');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"doesn't support require.resolve calls for included assets","suites":["scope hoisting","commonjs"],"line":2053,"code":"    it.skip(\"doesn't support require.resolve calls for included assets\", async function () {","file":"scope-hoisting.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"supports mutations of the exports object by the importer","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2079,"column":64,"index":99867},"line":2079,"code":"    it('supports mutations of the exports object by the importer', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/mutated-exports-object-importer/index.js'));\n      assert.deepEqual(await run(b), [43, {\n        foo: 43\n      }]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports mutations of the exports object by a different asset","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2085,"column":69,"index":100169},"line":2085,"code":"    it('supports mutations of the exports object by a different asset', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/mutated-exports-object-different/index.js'));\n      assert.equal(await run(b), 43);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports mutations of the exports object inside an expression","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2089,"column":69,"index":100439},"line":2089,"code":"    it('supports mutations of the exports object inside an expression', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/mutated-exports-object-expression/index.js'));\n      assert.deepEqual(await run(b), [{\n        foo: 3\n      }, 3, 3]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports non-static mutations of the exports object","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2095,"column":59,"index":100734},"line":2095,"code":"    it('supports non-static mutations of the exports object', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5591\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/mutated-non-static-require/index.js'));\n      assert.deepEqual(await run(b), 4);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports mutations of the cjs exports by the importer from a mixed module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2100,"column":81,"index":101075},"line":2100,"code":"    it('supports mutations of the cjs exports by the importer from a mixed module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/mutated-exports-mixed-module/index.js'));\n      assert.deepEqual(await run(b), ['CJS mutated', 'ESM', {\n        cjs: 'CJS mutated',\n        esm: 'ESM'\n      }]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require.resolve calls for excluded modules","suites":["scope hoisting","commonjs"],"line":2107,"code":"    it.skip('supports require.resolve calls for excluded modules', async function () {","file":"scope-hoisting.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support assets requiring themselves","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2116,"column":50,"index":101784},"line":2116,"code":"    it('should support assets requiring themselves', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-self/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 4);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports requiring a re-exported ES6 import","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2121,"column":51,"index":102044},"line":2121,"code":"    it('supports requiring a re-exported ES6 import', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/re-export-var/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'foobar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports object pattern requires","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2126,"column":40,"index":102299},"line":2126,"code":"    it('supports object pattern requires', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/object-pattern/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"eliminates CommonJS export object where possible","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2131,"column":56,"index":102564},"line":2131,"code":"    it('eliminates CommonJS export object where possible', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/eliminate-exports/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 6);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports multiple assignments in one line","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2136,"column":49,"index":102825},"line":2136,"code":"    it('supports multiple assignments in one line', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/multi-assign/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        foo: 2,\n        bar: 2,\n        baz: 2\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports circular dependencies","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2145,"column":38,"index":103125},"line":2145,"code":"    it('supports circular dependencies', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-circular/a.js'));\n      let output = await run(b);\n      assert.equal(output, 'foo bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"executes modules in the correct order","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2150,"column":45,"index":103385},"line":2150,"code":"    it('executes modules in the correct order', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-execution-order/a.js'));\n      let out = [];\n      await run(b, {\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, ['a', 'b', 'c', 'd']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports conditional requires","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2160,"column":37,"index":103727},"line":2160,"code":"    it('supports conditional requires', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-conditional/a.js'));\n      let out = [];\n      await run(b, {\n        b: false,\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, ['a', 'd']);\n      out = [];\n      await run(b, {\n        b: true,\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, ['a', 'b', 'c', 'd']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports requiring a CSS asset","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2179,"column":38,"index":104242},"line":2179,"code":"    it('supports requiring a CSS asset', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-css/a.js'));\n      assertBundles(b, [{\n        name: 'a.js',\n        assets: ['a.js']\n      }, {\n        type: 'css',\n        assets: ['b.css']\n      }]);\n      await run(b);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports requires inside functions","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2190,"column":42,"index":104584},"line":2190,"code":"    it('supports requires inside functions', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-in-function/a.js'));\n      let out = [];\n      await run(b, {\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, ['a', 'c', 'b']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports requires inside functions with es6 import side effects","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2200,"column":71,"index":104951},"line":2200,"code":"    it('supports requires inside functions with es6 import side effects', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-in-function-import/a.js'));\n      let out = [];\n      await run(b, {\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, ['a', 'd', 'c', 'b']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"hoists import calls to the top","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2210,"column":38,"index":105297},"line":2210,"code":"    it('hoists import calls to the top', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-in-function-import-hoist/a.js'));\n      let out = [];\n      await run(b, {\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, ['a', 'd', 'c', 'b']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports requires inside functions with es6 re-export side effects","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2220,"column":74,"index":105685},"line":2220,"code":"    it('supports requires inside functions with es6 re-export side effects', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-in-function-reexport/a.js'));\n      let out = [];\n      await run(b, {\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, ['a', 'd', 'c', 'b']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can bundle the node stream module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2230,"column":41,"index":106036},"line":2230,"code":"    it('can bundle the node stream module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/stream-module/a.js'));\n      let res = await run(b);\n      assert.equal(typeof res.Readable, 'function');\n      assert.equal(typeof res.Writable, 'function');\n      assert.equal(typeof res.Duplex, 'function');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"missing exports should be replaced with an empty object","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2237,"column":63,"index":106426},"line":2237,"code":"    it('missing exports should be replaced with an empty object', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/empty-module/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        b: {}\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes unused exports","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2244,"column":30,"index":106685},"line":2244,"code":"    it('removes unused exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/tree-shaking/a.js'), {\n        mode: 'production'\n      });\n      let output = await run(b);\n      assert.deepEqual(output, 2);\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('foo'));\n      assert(!contents.includes('bar'));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes unused exports when assigning with a string literal","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2254,"column":67,"index":107160},"line":2254,"code":"    it('removes unused exports when assigning with a string literal', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/tree-shaking-string/a.js'), {\n        mode: 'production'\n      });\n      let output = await run(b);\n      assert.deepEqual(output, [2, 20]);\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('foo'));\n      assert(!contents.includes('bar'));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports removing an unused inline export with uglify minification","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2264,"column":74,"index":107655},"line":2264,"code":"    it('supports removing an unused inline export with uglify minification', async function () {\n      // Uglify does strange things to multiple assignments in a line.\n      // See https://github.com/parcel-bundler/parcel/issues/1549\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/export-local/a.js'), {\n        defaultTargetOptions: {\n          shouldOptimize: true\n        }\n      });\n      let output = await run(b);\n      assert.deepEqual(output, 3);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support sideEffects: false","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2275,"column":41,"index":108124},"line":2275,"code":"    it('should support sideEffects: false', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/side-effects-false/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 9);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can bundle browserify-produced umd bundles","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2280,"column":50,"index":108387},"line":2280,"code":"    it('can bundle browserify-produced umd bundles', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/browserify-compat/index.js'));\n      assert.equal(await run(b), 'foo');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"replaces properties of require with undefined","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2284,"column":53,"index":108629},"line":2284,"code":"    it('replaces properties of require with undefined', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-extensions/index.js'));\n      await run(b);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support two aliases to the same module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2288,"column":53,"index":108851},"line":2288,"code":"    it('should support two aliases to the same module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-aliases/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should retain the correct concat order with wrapped assets","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2293,"column":66,"index":109125},"line":2293,"code":"    it('should retain the correct concat order with wrapped assets', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-concat-order/a.js'));\n      let calls = [];\n      await run(b, {\n        sideEffect(v) {\n          calls.push(v);\n        }\n      });\n      assert.deepStrictEqual(calls, [1, 2, 3, 4, 5, 6, 7]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support optional requires","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2303,"column":40,"index":109481},"line":2303,"code":"    it('should support optional requires', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-optional/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert __esModule interop flag when importing from an ES module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2308,"column":78,"index":109768},"line":2308,"code":"    it('should insert __esModule interop flag when importing from an ES module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/interop-require-es-module/a.js'));\n      let output = await run(b);\n      assert.equal(output.__esModule, true);\n      assert.equal(output.default, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should export the same values for interop shared modules in main and child bundle","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2314,"column":89,"index":110126},"line":2314,"code":"    it('should export the same values for interop shared modules in main and child bundle', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/interop-require-es-module-code-split/main.js'));\n      assert.equal(await run(b), 'bar:bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should export the same values for interop shared modules in main and child bundle if shared bundle is deep nested","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2318,"column":121,"index":110458},"line":2318,"code":"    it('should export the same values for interop shared modules in main and child bundle if shared bundle is deep nested', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/interop-require-es-module-code-split-intermediate/main.js'));\n      assert.equal(await run(b), 'bar:bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not insert interop default for commonjs modules with default export","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2322,"column":82,"index":110764},"line":2322,"code":"    it('should not insert interop default for commonjs modules with default export', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/interop-require-commonjs/a.js'));\n      let output = await run(b);\n      let obj = {\n        test: 2\n      };\n      obj.default = obj;\n      assert.deepEqual(output.default, obj);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should add a default interop for a CJS module used in a hybrid module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2331,"column":77,"index":111138},"line":2331,"code":"    it('should add a default interop for a CJS module used in a hybrid module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/interop-commonjs-hybrid/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should add a default interop for a CJS module used non-statically in a hybrid module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2336,"column":92,"index":111444},"line":2336,"code":"    it('should add a default interop for a CJS module used non-statically in a hybrid module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/interop-commonjs-hybrid-dynamic/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not insert default interop for wrapped CJS modules","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2341,"column":65,"index":111731},"line":2341,"code":"    it('should not insert default interop for wrapped CJS modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/interop-require-commonjs-wrapped/a.js'));\n      let output = await run(b);\n      assert.equal(output, 'default');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support multiple requires in the same variable declaration","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2346,"column":73,"index":112035},"line":2346,"code":"    it('should support multiple requires in the same variable declaration', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-multiple/a.js'));\n      let output = await run(b);\n      assert.equal(output, 'before foo middle bar after');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support assigning to exports from inside a function","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2351,"column":66,"index":112336},"line":2351,"code":"    it('should support assigning to exports from inside a function', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/export-assign-scope/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should also hoist inserted polyfills of globals","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2356,"column":55,"index":112605},"line":2356,"code":"    it('should also hoist inserted polyfills of globals', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/globals-polyfills/a.js'));\n      let output = await run(b);\n      assert.equal(output, true);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support wrapping array destructuring declarations","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2361,"column":64,"index":112880},"line":2361,"code":"    it('should support wrapping array destructuring declarations', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-destructuring-array/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, [1, 2]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support wrapping object destructuring declarations","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2366,"column":65,"index":113169},"line":2366,"code":"    it('should support wrapping object destructuring declarations', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-destructuring-object/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, [4, 2]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not tree-shake assignments to unknown objects","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2371,"column":58,"index":113452},"line":2371,"code":"    it('does not tree-shake assignments to unknown objects', async () => {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/tree-shaking-no-unknown-objects/index.js'));\n      assert.equal(await run(b), 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can conditionally reference an imported symbol and unconditionally reference it","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2375,"column":87,"index":113733},"line":2375,"code":"    it('can conditionally reference an imported symbol and unconditionally reference it', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/conditional-import-reference/index.js'));\n      let output = await run(b);\n      assert.equal(output, 'hello');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports assigning to the result of a require","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2380,"column":53,"index":114015},"line":2380,"code":"    it('supports assigning to the result of a require', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-assign/a.js'));\n      let output = await run(b);\n      assert.equal(output, 4);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports both static and non-static exports in the same module with self-reference","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2385,"column":90,"index":114310},"line":2385,"code":"    it('supports both static and non-static exports in the same module with self-reference', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/non-static-exports/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        foo: 2,\n        bar: 4,\n        baz: 6\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not replace assignments to the exports object in the same module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2394,"column":77,"index":114655},"line":2394,"code":"    it('does not replace assignments to the exports object in the same module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/self-reference-assignment/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        foo: {\n          bar: 'bar'\n        }\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"replaces static require member expressions with the correct `this` context","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2403,"column":82,"index":115011},"line":2403,"code":"    it('replaces static require member expressions with the correct `this` context', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-member-wrapped/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output(), {\n        foo: 2,\n        bar: 4\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not create a self-referencing dependency for the default symbol without an __esModule flag","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2411,"column":103,"index":115372},"line":2411,"code":"    it('does not create a self-referencing dependency for the default symbol without an __esModule flag', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/self-reference-default/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ensure that side effect ordering is correct in sequence expressions with require","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2416,"column":95,"index":115680},"line":2416,"code":"    it('should ensure that side effect ordering is correct in sequence expressions with require', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5606\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/commonjs/wrap-expressions/a.js'));\n      let sideEffects = [];\n      let res = await run(b, {\n        sideEffect(out) {\n          sideEffects.push(out);\n        }\n      });\n      await res;\n      assert.deepEqual(sideEffects, ['before', 'require', 'after']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ensure that side effect ordering is correct in binary expressions with require","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2428,"column":93,"index":116201},"line":2428,"code":"    it('should ensure that side effect ordering is correct in binary expressions with require', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5606\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/commonjs/wrap-expressions/b.js'));\n      let sideEffects = [];\n      let res = await run(b, {\n        sideEffect(out) {\n          sideEffects.push(out);\n        }\n      });\n      await res;\n      assert.deepEqual(sideEffects, ['before', 'require', 'after']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ensure that side effect ordering is correct with default interop","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2440,"column":79,"index":116708},"line":2440,"code":"    it('should ensure that side effect ordering is correct with default interop', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5662\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/commonjs/wrap-default-interop/index.js'));\n      let sideEffects = [];\n      let res = await run(b, {\n        sideEffect(out) {\n          sideEffects.push(out);\n        }\n      });\n      await res;\n      assert.deepEqual(sideEffects, ['shared', 'run1', 'async c: 123']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support non-object module.exports","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2452,"column":48,"index":117196},"line":2452,"code":"    it('should support non-object module.exports', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5892\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/export-non-object/index.js'));\n      await run(b, null, {\n        strict: true\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support assignment to a local variable with require","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2459,"column":66,"index":117530},"line":2459,"code":"    it('should support assignment to a local variable with require', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-local-assign/basic.js'));\n      let outputs = [];\n      await run(b, {\n        output(x) {\n          outputs.push(x);\n        }\n      });\n      assert.deepEqual(outputs, [[{\n        foo: 2\n      }, {\n        foo: 2\n      }], [4, {\n        foo: 2\n      }]]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support out of order assignment to a local variable with require","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2475,"column":79,"index":117992},"line":2475,"code":"    it('should support out of order assignment to a local variable with require', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-local-assign/in-function.js'));\n      let outputs = [];\n      await run(b, {\n        output(x) {\n          outputs.push(x);\n        }\n      });\n      assert.deepEqual(outputs, [[{\n        foo: 2\n      }, {\n        foo: 2\n      }], [4, {\n        foo: 2\n      }]]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support assignment to a local variable with require and member expression","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2491,"column":88,"index":118469},"line":2491,"code":"    it('should support assignment to a local variable with require and member expression', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-local-assign/member.js'));\n      let outputs = [];\n      await run(b, {\n        output(x) {\n          outputs.push(x);\n        }\n      });\n      assert.deepEqual(outputs, [[2, 2], [4, 2]]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support assignment to a local variable with require and destructuring","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2501,"column":84,"index":118868},"line":2501,"code":"    it('should support assignment to a local variable with require and destructuring', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-local-assign/destructure.js'));\n      let outputs = [];\n      await run(b, {\n        output(x) {\n          outputs.push(x);\n        }\n      });\n      assert.deepEqual(outputs, [[2, 2], [4, 2]]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support assignment to a local variable with require and non-static access","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2511,"column":88,"index":119276},"line":2511,"code":"    it('should support assignment to a local variable with require and non-static access', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-local-assign/destructure.js'));\n      let outputs = [];\n      await run(b, {\n        output(x) {\n          outputs.push(x);\n        }\n      });\n      assert.deepEqual(outputs, [[2, 2], [4, 2]]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle require as the callee in a new expression","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2521,"column":63,"index":119659},"line":2521,"code":"    it('should handle require as the callee in a new expression', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-new/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output.foo(), 1);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not update mutated destructured requires","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2526,"column":55,"index":119928},"line":2526,"code":"    it('should not update mutated destructured requires', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-non-const-export/destructure.js'));\n      let outputs = [];\n      await run(b, {\n        output(x) {\n          outputs.push(x);\n        }\n      });\n      assert.deepEqual(outputs, [2, 2]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not update mutated require members","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2536,"column":49,"index":120291},"line":2536,"code":"    it('should not update mutated require members', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-non-const-export/member.js'));\n      let outputs = [];\n      await run(b, {\n        output(x) {\n          outputs.push(x);\n        }\n      });\n      assert.deepEqual(outputs, [2, 2]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update live mutated require members","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2546,"column":50,"index":120650},"line":2546,"code":"    it('should update live mutated require members', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-non-const-export/live.js'));\n      let outputs = [];\n      await run(b, {\n        output(x) {\n          outputs.push(x);\n        }\n      });\n      assert.deepEqual(outputs, [2, 3]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should wrap all assets with an incoming wrapped dependency","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2556,"column":66,"index":121023},"line":2556,"code":"    it('should wrap all assets with an incoming wrapped dependency', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-deps-circular/index.js'));\n      assert.deepEqual(await run(b), {\n        test: 2\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not throw with JS included from HTML","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2563,"column":49,"index":121292},"line":2563,"code":"  it('should not throw with JS included from HTML', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js', 'other.js']\n    }]);\n    let asset = nullthrows(findAsset(b, 'other.js'));\n    assert.deepStrictEqual(new Set(b.getUsedSymbols(asset)), new Set(['default']));\n    let value = [];\n    await run(b, {\n      alert: v => value.push(v)\n    });\n    assert.deepEqual(value, ['other']);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not throw with JS dynamic imports included from HTML","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2580,"column":65,"index":121880},"line":2580,"code":"  it('should not throw with JS dynamic imports included from HTML', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js-dynamic/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }, {\n      type: 'js',\n      assets: ['local.js']\n    }]);\n    let res = await run(b, {\n      output: null\n    }, {\n      require: false\n    });\n    assert.equal(typeof res.output, 'function');\n    assert.equal(await res.output(), 'Imported: foobar');\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should include the prelude in shared entry bundles","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2600,"column":56,"index":122445},"line":2600,"code":"  it('should include the prelude in shared entry bundles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-shared/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }, {\n      name: 'iframe.html',\n      assets: ['iframe.html']\n    }, {\n      type: 'js',\n      assets: ['iframe.js']\n    }, {\n      type: 'js',\n      assets: ['lodash.js']\n    }]);\n    let sharedBundle = b.getBundles().sort((a, b) => b.stats.size - a.stats.size)[0];\n    let contents = await outputFS.readFile(sharedBundle.filePath, 'utf8');\n    assert(contents.includes(`if (parcelRequire == null) {`));\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not include prelude if child bundles are isolated","suites":["scope hoisting","commonjs"],"line":2627,"code":"  it.skip('does not include prelude if child bundles are isolated', async function () {","file":"scope-hoisting.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should include prelude in shared worker bundles","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2634,"column":53,"index":123703},"line":2634,"code":"  it('should include prelude in shared worker bundles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-shared/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    let sharedBundle = b.getBundles().sort((a, b) => b.stats.size - a.stats.size).find(b => b.name !== 'index.js');\n    let contents = await outputFS.readFile(sharedBundle.filePath, 'utf8');\n    assert(contents.includes(`if (parcelRequire == null) {`));\n    let workerBundle = b.getBundles().find(b => b.name.startsWith('worker-b'));\n    contents = await outputFS.readFile(workerBundle.filePath, 'utf8');\n    assert(contents.includes(`importScripts(\"./${path.basename(sharedBundle.filePath)}\")`));\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert global variables when needed","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2650,"column":48,"index":124519},"line":2650,"code":"  it('should insert global variables when needed', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/globals/scope-hoisting.js'));\n    let output = await run(b);\n    assert.deepEqual(output(), {\n      dir: 'integration/globals',\n      file: 'integration/globals/index.js',\n      buf: Buffer.from('browser').toString('base64'),\n      global: true\n    });\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should be able to named import a reexported namespace in an async bundle","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2660,"column":78,"index":124939},"line":2660,"code":"  it('should be able to named import a reexported namespace in an async bundle', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/async-named-import-ns-reexport/index.js'));\n    assert.deepEqual(await run(b), [42, 42, 42, 42]);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not remove a binding with a used AssignmentExpression","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2664,"column":66,"index":125211},"line":2664,"code":"  it('should not remove a binding with a used AssignmentExpression', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/used-assignmentexpression/a.js'));\n    assert.strictEqual(await run(b), 3);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should wrap imports inside arrow functions","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2668,"column":48,"index":125443},"line":2668,"code":"  it('should wrap imports inside arrow functions', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/wrap-import-arrowfunction/a.js'));\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('=>'));\n    let calls = [];\n    let output = await run(b, {\n      sideEffect(id) {\n        calls.push(id);\n      }\n    });\n    assert.deepEqual(calls, []);\n    assert.equal(typeof output, 'function');\n    assert.deepEqual(await output(), {\n      default: 1234\n    });\n    assert.deepEqual(calls, ['async']);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can static import and dynamic import in the same bundle without creating a new bundle","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2685,"column":91,"index":126094},"line":2685,"code":"  it('can static import and dynamic import in the same bundle without creating a new bundle', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/sync-async/same-bundle-scope-hoisting.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'same-bundle-scope-hoisting.js',\n      assets: ['same-bundle-scope-hoisting.js', 'get-dep.js', 'get-dep-2.js', 'dep.js']\n    }]);\n    assert.deepEqual(await await run(b), [42, 42, 42]);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can static import and dynamic import in the same bundle ancestry without creating a new bundle","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2695,"column":100,"index":126578},"line":2695,"code":"  it('can static import and dynamic import in the same bundle ancestry without creating a new bundle', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/sync-async/same-ancestry-scope-hoisting.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'same-ancestry-scope-hoisting.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'dep.js', 'js-loader.js', 'same-ancestry-scope-hoisting.js']\n    }, {\n      assets: ['get-dep.js']\n    }]);\n    assert.deepEqual(await run(b), [42, 42]);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"loads another bundle from a dynamic import with a shared dependency only when necessary","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2707,"column":93,"index":127132},"line":2707,"code":"  it('loads another bundle from a dynamic import with a shared dependency only when necessary', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/sync-async-when-needed/index.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['dep.js']\n    }, {\n      assets: ['async-has-dep.js', 'dep.js', 'get-dep.js']\n    }, {\n      assets: ['get-dep.js']\n    }]);\n    assert.deepEqual(await run(b), [42, 42]);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can static import and dynamic import in the same bundle when another bundle requires async","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2723,"column":96,"index":127724},"line":2723,"code":"  it('can static import and dynamic import in the same bundle when another bundle requires async', async () => {\n    let b = await bundle(['same-bundle-scope-hoisting.js', 'get-dep-scope-hoisting.js'].map(entry => path.join(__dirname, '/integration/sync-async/', entry)), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      assets: ['dep.js']\n    }, {\n      name: 'same-bundle-scope-hoisting.js',\n      assets: ['same-bundle-scope-hoisting.js', 'get-dep.js', 'get-dep-2.js', 'dep.js']\n    }, {\n      name: 'get-dep-scope-hoisting.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'get-dep-scope-hoisting.js', 'js-loader.js']\n    }]);\n    let bundles = b.getBundles();\n    let sameBundle = bundles.find(b => b.name === 'same-bundle-scope-hoisting.js');\n    let getDep = bundles.find(b => b.name === 'get-dep-scope-hoisting.js');\n    assert.deepEqual(await runBundle(b, sameBundle), [42, 42, 42]);\n    assert.deepEqual(await runBundle(b, getDep), 42);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can share dependencies between a shared bundle and its sibling's descendants","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2742,"column":82,"index":128706},"line":2742,"code":"  it(\"can share dependencies between a shared bundle and its sibling's descendants\", async () => {\n    let b = await bundle(path.join(__dirname, '/integration/shared-exports-for-sibling-descendant/scope-hoisting.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      assets: ['wraps.js', 'lodash.js']\n    }, {\n      assets: ['a.js']\n    }, {\n      assets: ['child.js']\n    }, {\n      assets: ['grandchild.js']\n    }, {\n      assets: ['b.js']\n    }, {\n      name: 'scope-hoisting.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'scope-hoisting.js', 'js-loader.js']\n    }]);\n    assert.deepEqual(await run(b), [3, 5]);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"deduplicates shared sibling assets between bundle groups","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2762,"column":62,"index":129354},"line":2762,"code":"  it('deduplicates shared sibling assets between bundle groups', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/shared-sibling-scope-hoist/index.js'));\n    assert.deepEqual(await run(b), ['a', 'b', 'c']);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can run an entry bundle whose entry asset is present in another bundle","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2766,"column":76,"index":129606},"line":2766,"code":"  it('can run an entry bundle whose entry asset is present in another bundle', async () => {\n    let b = await bundle(['index.js', 'value.js'].map(basename => path.join(__dirname, '/integration/sync-entry-shared', basename)), {\n      targets: {\n        main: {\n          context: 'node',\n          distDir,\n          isLibrary: true\n        }\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'value.js',\n      assets: ['value.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.equal(await (await run(b)).default, 43);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can run an async bundle whose entry asset is present in another bundle","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2787,"column":76,"index":130203},"line":2787,"code":"  it('can run an async bundle whose entry asset is present in another bundle', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/async-entry-shared/scope-hoisting.js'));\n    assertBundles(b, [{\n      name: 'scope-hoisting.js',\n      assets: ['scope-hoisting.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['value.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.deepEqual(await run(b), [42, 43]);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can run an async bundle that depends on a nonentry asset in a sibling","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2799,"column":75,"index":130673},"line":2799,"code":"  it('can run an async bundle that depends on a nonentry asset in a sibling', async () => {\n    let b = await bundle(['scope-hoisting.js', 'other-entry.js'].map(basename => path.join(__dirname, '/integration/async-entry-shared-sibling', basename)));\n    assertBundles(b, [{\n      name: 'scope-hoisting.js',\n      assets: ['scope-hoisting.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      name: 'other-entry.js',\n      assets: ['other-entry.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['a.js', 'value.js']\n    }, {\n      assets: ['b.js']\n    }]);\n    assert.deepEqual(await run(b), 43);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"correctly updates dependencies when a specifier is added","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2814,"column":62,"index":131308},"line":2814,"code":"  it('correctly updates dependencies when a specifier is added', async function () {\n    let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/cache-add-specifier');\n    let b = bundler(path.join(testDir, 'a.js'), {\n      inputFS: overlayFS,\n      outputFS: overlayFS\n    });\n    let subscription = await b.watch();\n    let bundleEvent = await getNextBuild(b);\n    assert(bundleEvent.type === 'buildSuccess');\n    let output = await run(bundleEvent.bundleGraph);\n    assert.deepEqual(output, 'foo');\n    await overlayFS.mkdirp(testDir);\n    await overlayFS.copyFile(path.join(testDir, 'a.1.js'), path.join(testDir, 'a.js'));\n    bundleEvent = await getNextBuild(b);\n    assert(bundleEvent.type === 'buildSuccess');\n    output = await run(bundleEvent.bundleGraph);\n    assert.deepEqual(output, 'foobar');\n    await subscription.unsubscribe();\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not rewrite this in arrow function class properties","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2833,"column":64,"index":132172},"line":2833,"code":"  it('should not rewrite this in arrow function class properties', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-class-this-esm/a.js'));\n    let res = await run(b);\n    assert.deepEqual(res, 'x: 123');\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should call named imports without this context","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2838,"column":52,"index":132404},"line":2838,"code":"  it('should call named imports without this context', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-this/index.js'));\n    let res = await run(b, {\n      output: null\n    }, {\n      strict: true\n    });\n    assert.deepEqual(res, {\n      unwrappedNamed: [true, false],\n      unwrappedDefault: [true, false],\n      // TODO: unwrappedNamespace should actually be `[false, true]` but we optimize\n      // the `ns.foo` expression into a named import, so that namespace isn't available anymore.\n      unwrappedNamespace: [true, false],\n      wrappedNamed: [true, false],\n      wrappedDefault: [true, false],\n      wrappedNamespace: [false, true]\n    });\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert the prelude for sibling bundles referenced in HTML","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2856,"column":70,"index":133119},"line":2856,"code":"  it('should insert the prelude for sibling bundles referenced in HTML', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/sibling-dependencies/index.html'));\n    let res = await run(b, {\n      output: null\n    }, {\n      require: false\n    });\n    assert.equal(res.output, 'a');\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should unmark dependency as deferred when dependency becomes used","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2865,"column":71,"index":133454},"line":2865,"code":"  it('should unmark dependency as deferred when dependency becomes used', async function () {\n    let testDir = path.join(__dirname, 'integration/scope-hoisting/es6/unmarks-defer-for-new-deps');\n    let packageDir = path.join(testDir, '/package');\n    await overlayFS.mkdirp(packageDir);\n    await overlayFS.copyFile(path.join(packageDir, 'b1.js'), path.join(packageDir, 'b.js'));\n    await bundle(path.join(testDir, 'index.js'), {\n      inputFS: overlayFS,\n      outputFS: overlayFS,\n      shouldDisableCache: true\n    });\n    await overlayFS.copyFile(path.join(packageDir, 'b2.js'), path.join(packageDir, 'b.js'));\n    await bundle(path.join(testDir, 'index.js'), {\n      inputFS: overlayFS,\n      outputFS: overlayFS,\n      shouldDisableCache: false\n    });\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"unmark an asset group as deferred when it becomes used","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2882,"column":60,"index":134210},"line":2882,"code":"  it('unmark an asset group as deferred when it becomes used', async function () {\n    let testDir = path.join(__dirname, 'integration/scope-hoisting/es6/unmarks-defer-for-assetgroup');\n    await overlayFS.mkdirp(testDir);\n    await overlayFS.copyFile(path.join(testDir, 'index1.js'), path.join(testDir, 'index.js'));\n    let b = await bundle(path.join(testDir, 'index.js'), {\n      inputFS: overlayFS,\n      outputFS: overlayFS,\n      shouldDisableCache: true\n    });\n    assert.strictEqual(await run(b), 'bar');\n    await overlayFS.copyFile(path.join(testDir, 'index2.js'), path.join(testDir, 'index.js'));\n    b = await bundle(path.join(testDir, 'index.js'), {\n      inputFS: overlayFS,\n      outputFS: overlayFS,\n      shouldDisableCache: false\n    });\n    assert.strictEqual(await run(b), 'bar foo');\n    await overlayFS.copyFile(path.join(testDir, 'index3.js'), path.join(testDir, 'index.js'));\n    b = await bundle(path.join(testDir, 'index.js'), {\n      inputFS: overlayFS,\n      outputFS: overlayFS,\n      shouldDisableCache: false\n    });\n    assert.strictEqual(await run(b), 'bar foo bar');\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"not insert unused requires that aren't registered anywhere","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2907,"column":64,"index":135322},"line":2907,"code":"  it(\"not insert unused requires that aren't registered anywhere\", async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/unused-require/index.js'));\n    let output = await run(b);\n    assert.strictEqual(output, 'foo');\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"produce the same bundle hash regardless of transformation order","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2912,"column":69,"index":135597},"line":2912,"code":"  it('produce the same bundle hash regardless of transformation order', async function () {\n    let testDir = path.join(__dirname, 'integration/scope-hoisting/es6/non-deterministic-bundle-hashes');\n    const waitHandler = (fileToDelay, fileToWaitFor) => {\n      const waitMap = new Map();\n      function wait(filePath) {\n        if (waitMap.has(filePath)) {\n          return Promise.resolve();\n        }\n        return new Promise(resolve => {\n          waitMap.set(filePath, resolve);\n        });\n      }\n      // a set of filepaths that have been read\n      function seen(filePath) {\n        // check map of things we're waiting for to resolved promises\n        let promisesToResolve = waitMap.get(filePath);\n        if (promisesToResolve) {\n          // if we find any, we call it\n          promisesToResolve();\n        }\n        waitMap.set(filePath, null);\n      }\n      return {\n        get(target, prop) {\n          let original = Reflect.get(...arguments);\n          if (prop === 'readFile') {\n            return async function (...args) {\n              if (args[0].includes(fileToDelay)) {\n                await wait(fileToWaitFor);\n              }\n              let result = await original.apply(this, args);\n              seen(path.basename(args[0]));\n              return result;\n            };\n          }\n          return original;\n        }\n      };\n    };\n    let workerFarm = createWorkerFarm({\n      maxConcurrentWorkers: 0\n    });\n    let slowFooFS = new Proxy(overlayFS, waitHandler('foo.js', 'bar.js'));\n    try {\n      let b = await bundle(path.join(testDir, 'index.html'), {\n        inputFS: slowFooFS,\n        outputFS: slowFooFS,\n        shouldDisableCache: true,\n        workerFarm\n      });\n      let bundleHashDelayFoo = b.getBundles().find(b => b.filePath.endsWith('.js') && b.filePath.includes('index')).filePath.split('.')[1];\n      let slowBarFS = new Proxy(overlayFS, waitHandler('bar.js', 'foo.js'));\n      let b2 = await bundle(path.join(testDir, 'index.html'), {\n        inputFS: slowBarFS,\n        outputFS: slowBarFS,\n        shouldDisableCache: true,\n        workerFarm\n      });\n      let bundleHashDelayBar = b2.getBundles().find(b => b.filePath.endsWith('.js') && b.filePath.includes('index')).filePath.split('.')[1];\n      assert.strictEqual(bundleHashDelayFoo, bundleHashDelayBar);\n    } finally {\n      await workerFarm.end();\n    }\n    it('should not deduplicate an asset if it will become unreachable', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/sibling-deduplicate-unreachable/index.js'), {\n        mode: 'production'\n      });\n      let res = await run(b);\n      assert.equal(res, 'target');\n    });\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not deduplicate an asset if it will become unreachable","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2975,"column":69,"index":137975},"line":2975,"code":"    it('should not deduplicate an asset if it will become unreachable', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/sibling-deduplicate-unreachable/index.js'), {\n        mode: 'production'\n      });\n      let res = await run(b);\n      assert.equal(res, 'target');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should serve files","suites":["server"],"updatePoint":{"line":17,"column":24,"index":651},"line":17,"code":"  it('should serve files', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/commonjs/index.js'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let data = await get('/index.js', port);\n    let distFile = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert.equal(data, distFile);\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should include content length for HEAD requests","suites":["server"],"updatePoint":{"line":36,"column":53,"index":1244},"line":36,"code":"  it('should include content length for HEAD requests', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/commonjs/index.js'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let result = await getRaw('/index.js', port, {\n      method: 'HEAD'\n    });\n    let distFile = await outputFS.readFile(path.join(distDir, 'index.js'));\n    assert.strictEqual(result.res.headers['content-length'], String(distFile.byteLength));\n    assert.strictEqual(result.data, '');\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should serve source files","suites":["server"],"updatePoint":{"line":58,"column":31,"index":1940},"line":58,"code":"  it('should serve source files', async function () {\n    let port = await getPort();\n    let inputPath = path.join(__dirname, '/integration/commonjs/index.js');\n    let b = bundler(inputPath, {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let data = await get('/__parcel_source_root/integration/commonjs/index.js', port);\n    let inputFile = await inputFS.readFile(inputPath, 'utf8');\n    assert.equal(data, inputFile);\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should serve sourcemaps","suites":["server"],"updatePoint":{"line":78,"column":29,"index":2562},"line":78,"code":"  it('should serve sourcemaps', async function () {\n    let port = await getPort();\n    let inputPath = path.join(__dirname, '/integration/commonjs/index.js');\n    let b = bundler(inputPath, {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let data = await get('/index.js.map', port);\n    let distFile = await outputFS.readFile(path.join(distDir, 'index.js.map'), 'utf8');\n    assert.equal(data, distFile);\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should serve a default page if the main bundle is an HTML asset","suites":["server"],"updatePoint":{"line":98,"column":69,"index":3210},"line":98,"code":"  it('should serve a default page if the main bundle is an HTML asset', async function () {\n    let port = await getPort();\n    let b = bundler([path.join(__dirname, '/integration/html/other.html'), path.join(__dirname, '/integration/html/index.html')], {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let rootIndexFile = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    let data = await get('/', port);\n    assert.equal(data, rootIndexFile);\n    let fooIndexFile = await outputFS.readFile(path.join(distDir, 'foo/index.html'), 'utf8');\n    data = await get('/foo', port);\n    assert.equal(data, fooIndexFile);\n    data = await get('/foo/bar', port);\n    assert.equal(data, fooIndexFile);\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should serve a default page if the main bundle is an HTML asset even if it is not called index","suites":["server"],"updatePoint":{"line":122,"column":100,"index":4154},"line":122,"code":"  it('should serve a default page if the main bundle is an HTML asset even if it is not called index', async function () {\n    let port = await getPort();\n    let inputPath = path.join(__dirname, '/integration/html/other.html');\n    let b = bundler(inputPath, {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let rootIndexFile = await outputFS.readFile(path.join(distDir, 'other.html'), 'utf8');\n    let data = await get('/', port);\n    assert.equal(data, rootIndexFile);\n    data = await get('/foo', port);\n    assert.equal(data, rootIndexFile);\n    data = await get('/foo/bar', port);\n    assert.equal(data, rootIndexFile);\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should serve a default page if the main bundle is an HTML asset with package.json#source","suites":["server"],"updatePoint":{"line":146,"column":94,"index":4975},"line":146,"code":"  it('should serve a default page if the main bundle is an HTML asset with package.json#source', async function () {\n    let port = await getPort();\n    let inputPath = path.join(__dirname, '/integration/html-pkg-source/');\n    let b = bundler(inputPath, {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    let event = await getNextBuild(b);\n    invariant(event.type === 'buildSuccess');\n    let bundleGraph = event.bundleGraph;\n    let outputFile = await outputFS.readFile(bundleGraph.getBundles()[0].filePath, 'utf8');\n    let data = await get('/', port);\n    assert.equal(data, outputFile);\n    data = await get('/foo/bar', port);\n    assert.equal(data, outputFile);\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should serve a 404 if the file does not exist","suites":["server"],"updatePoint":{"line":170,"column":51,"index":5773},"line":170,"code":"  it('should serve a 404 if the file does not exist', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/commonjs/index.js'), {\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let statusCode = 200;\n    try {\n      await get('/fake.js', port);\n    } catch (err) {\n      statusCode = err.statusCode;\n    }\n    assert.equal(statusCode, 404);\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should serve a 500 if the bundler errored","suites":["server"],"updatePoint":{"line":190,"column":47,"index":6309},"line":190,"code":"  it('should serve a 500 if the bundler errored', async function () {\n    let port = await getPort();\n    let inputDir = path.join(__dirname, '/input/server-500');\n    await ncp(path.join(__dirname, '/integration/babel'), inputDir);\n    let entry = path.join(inputDir, 'index.js');\n    let b = bundler(entry, {\n      defaultTargetOptions: {\n        distDir\n      },\n      inputFS: overlayFS,\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    await outputFS.writeFile(path.join(inputDir, 'foo.js'), 'syntax\\\\error');\n\n    // Await the second build failing (which means resolving with\n    // a buildFailure event)\n    await getNextBuild(b);\n    let statusCode = 200;\n    try {\n      await get('/index.js', port);\n    } catch (err) {\n      statusCode = err.statusCode;\n      assert(err.data.includes('Expected unicode escape'));\n    }\n    assert.equal(statusCode, 500);\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support HTTPS","suites":["server"],"updatePoint":{"line":223,"column":26,"index":7298},"line":223,"code":"  it('should support HTTPS', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/commonjs/index.js'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: true,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let data = await get('/index.js', port, https);\n    assert.equal(data, await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8'));\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support HTTPS via custom certificate","suites":["server"],"updatePoint":{"line":241,"column":49,"index":7864},"line":241,"code":"  it('should support HTTPS via custom certificate', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/commonjs/index.js'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: {\n          key: path.join(__dirname, '/integration/https/private.pem'),\n          cert: path.join(__dirname, '/integration/https/primary.crt')\n        },\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let data = await get('/index.js', port, https);\n    assert.equal(data, await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8'));\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support setting a public url","suites":["server"],"updatePoint":{"line":262,"column":41,"index":8571},"line":262,"code":"  it('should support setting a public url', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/commonjs/index.js'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost',\n        publicUrl: '/dist'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let data = await get('/dist/index.js', port);\n    assert.equal(data, await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8'));\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with query parameters that contain a dot","suites":["server"],"updatePoint":{"line":281,"column":58,"index":9173},"line":281,"code":"  it('should work with query parameters that contain a dot', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/commonjs/index.js'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let data = await get('/index.js?foo=bar.baz', port);\n    assert.equal(data, await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8'));\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with paths that contain a dot","suites":["server"],"updatePoint":{"line":299,"column":47,"index":9743},"line":299,"code":"  it('should work with paths that contain a dot', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/html/index.html'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let data = await get('/bar.baz', port);\n    assert.equal(data, await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8'));\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support lazy bundling","suites":["server"],"updatePoint":{"line":317,"column":34,"index":10287},"line":317,"code":"  it('should support lazy bundling', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/html/index.html'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      },\n      shouldBuildLazily: true,\n      shouldContentHash: false\n    });\n    await outputFS.mkdirp(distDir);\n    let builds = [];\n    subscription = await b.watch((err, buildEvent) => {\n      builds.push(buildEvent);\n    });\n    let build = await getNextBuild(b);\n    invariant(build.type === 'buildSuccess');\n    assertBundles(build.bundleGraph, [{\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n\n    // Bundle should exist in the graph, but not written to disk as it is just a placeholder\n    let dir = await outputFS.readdir(distDir);\n    assert.deepEqual(dir, []);\n    let data = await get('/index.html', port);\n    assert.equal(data, await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8'));\n    assert.equal(builds.length, 2);\n    build = builds[1];\n    invariant(build?.type === 'buildSuccess');\n    assertBundles(build.bundleGraph, [{\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      // index.html\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      // foo/index.html\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      name: 'other.html',\n      assets: ['other.html']\n    }, {\n      type: 'svg',\n      assets: ['icons.svg']\n    }, {\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }, {\n      type: 'css',\n      assets: ['index.css']\n    }]);\n\n    // Sibling bundles should have been fully written to disk, but not async bundles.\n    dir = await outputFS.readdir(distDir);\n    assert.deepEqual(dir.length, 8);\n    assert(!dir.includes('other.html'));\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support lazy bundling sibling css files of dynamic import","suites":["server"],"updatePoint":{"line":388,"column":70,"index":12311},"line":388,"code":"  it('should support lazy bundling sibling css files of dynamic import', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/dynamic-css/index.js'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      },\n      shouldBuildLazily: true,\n      shouldContentHash: false\n    });\n    await outputFS.mkdirp(distDir);\n    let builds = [];\n    subscription = await b.watch((err, buildEvent) => {\n      builds.push(buildEvent);\n    });\n    let build = await getNextBuild(b);\n    invariant(build.type === 'buildSuccess');\n    assertBundles(build.bundleGraph, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }]);\n\n    // Bundle should exist in the graph, but not written to disk as it is just a placeholder\n    let dir = await outputFS.readdir(distDir);\n    assert.deepEqual(dir, []);\n    let data = await get(`/index.js`, port);\n    assert.equal(data, await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8'));\n    assert.equal(builds.length, 2);\n    build = builds[1];\n    invariant(build?.type === 'buildSuccess');\n    assertBundles(build.bundleGraph, [{\n      name: 'index.js',\n      assets: ['bundle-url.js', 'cacheLoader.js', 'css-loader.js', 'index.js', 'js-loader.js']\n    }, {\n      name: /local\\.[0-9a-f]{8}\\.js/,\n      assets: ['local.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.css']\n    }]);\n\n    // local.js should exist in the graph, but not written to disk\n    dir = await outputFS.readdir(distDir);\n    assert.deepEqual(dir.sort(), ['index.js', 'index.css', 'index.js.map', 'index.css.map'].sort());\n    let local = build.bundleGraph.getBundles().find(b => b.type === 'js' && path.basename(b.filePath).startsWith('local'));\n    invariant(local);\n    data = await get(`/${path.basename(local.filePath)}`, port);\n    assert.equal(data, await outputFS.readFile(path.join(distDir, path.basename(local.filePath)), 'utf8'));\n    assert.equal(builds.length, 3);\n    build = builds[2];\n    invariant(build?.type === 'buildSuccess');\n    assertBundles(build.bundleGraph, [{\n      name: 'index.js',\n      assets: ['bundle-url.js', 'cacheLoader.js', 'css-loader.js', 'index.js', 'js-loader.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.css']\n    }, {\n      name: /local\\.[0-9a-f]{8}\\.js/,\n      assets: ['local.js']\n    }, {\n      name: /local\\.[0-9a-f]{8}\\.css/,\n      assets: ['local.css']\n    }]);\n    dir = await outputFS.readdir(distDir);\n    assert.deepEqual(dir.length, 8); // bundles + source maps\n\n    let localCSS = build.bundleGraph.getBundles().find(b => b.type === 'css' && path.basename(b.filePath).startsWith('local'));\n    invariant(localCSS);\n    assert(data.includes(path.basename(localCSS.filePath)));\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should create a basic browser sourcemap","suites":["sourcemaps"],"updatePoint":{"line":87,"column":45,"index":3354},"line":87,"code":"  it('Should create a basic browser sourcemap', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap/index.js');\n    await bundle(sourceFilename);\n    let distDir = path.join(__dirname, '/integration/sourcemap/dist/');\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[0]), 'utf8');\n    let sourcePath = 'index.js';\n    let name = raw.match(/function (\\$.*\\$var\\$helloWorld)/)[1];\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'function helloWorld',\n      generatedStr: 'function ' + name,\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'module.exports = helloWorld;',\n      generatedStr: 'module.exports = ' + name + ';',\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: '\"hello world\"',\n      sourcePath\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should create a basic browser sourcemap when serving","suites":["sourcemaps"],"updatePoint":{"line":127,"column":58,"index":4738},"line":127,"code":"  it('Should create a basic browser sourcemap when serving', async function () {\n    let fixture = path.join(__dirname, '/integration/sourcemap');\n    let sourceFilename = path.join(fixture, 'index.js');\n    await bundle(sourceFilename, {\n      serveOptions: {\n        port: 1234\n      }\n    });\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    assert.strictEqual(map.sourceRoot, '/__parcel_source_root/');\n    let input = await inputFS.readFile(path.join(fixture, map.sources[0]), 'utf8');\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'function helloWorld',\n      sourcePath: map.sources[0]\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'module.exports = helloWorld;',\n      sourcePath: map.sources[0]\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: '\"hello world\"',\n      sourcePath: map.sources[0]\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should create a basic node sourcemap","suites":["sourcemaps"],"updatePoint":{"line":168,"column":42,"index":6024},"line":168,"code":"  it('Should create a basic node sourcemap', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap-node/index.js');\n    await bundle(sourceFilename);\n    let distDir = path.join(__dirname, '/integration/sourcemap-node/dist/');\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceRoot = map.sourceRoot;\n    assert.equal(sourceRoot, '../', 'sourceRoot should be the root of the source files, relative to the output directory.');\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let input = await inputFS.readFile(sourceFilename, 'utf8');\n    let sourcePath = 'index.js';\n    let mapData = sourceMap.getMap();\n    assert.equal(mapData.sources.length, 1);\n    assert(await inputFS.exists(path.resolve(distDir + sourceRoot + sourcePath)), 'combining sourceRoot and sources object should resolve to the original file');\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'function helloWorld',\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'module.exports = helloWorld;',\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: '\"hello world\"',\n      sourcePath\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap for a js file with requires","suites":["sourcemaps"],"updatePoint":{"line":210,"column":65,"index":7622},"line":210,"code":"  it('should create a valid sourcemap for a js file with requires', async function () {\n    let sourceDir = path.join(__dirname, '/integration/sourcemap-nested/');\n    let sourceFilename = path.join(sourceDir, '/index.js');\n    await bundle(sourceFilename);\n    let distDir = path.join(__dirname, '/integration/sourcemap-nested/dist/');\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceRoot = map.sourceRoot;\n    assert.equal(sourceRoot, '../', 'sourceRoot should be the root of the source files, relative to the output directory.');\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let mapData = sourceMap.getMap();\n    assert.equal(mapData.sources.length, 3);\n    for (let source of mapData.sources) {\n      assert(await inputFS.exists(path.resolve(distDir + sourceRoot + source)), 'combining sourceRoot and sources object should resolve to the original file');\n    }\n    let inputs = [await inputFS.readFile(sourceFilename, 'utf8'), await inputFS.readFile(path.join(sourceDir, 'local.js'), 'utf8'), await inputFS.readFile(path.join(sourceDir, 'utils/util.js'), 'utf8')];\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[0],\n      generated: raw,\n      str: 'const local',\n      sourcePath: 'index.js'\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[0],\n      generated: raw,\n      str: 'local.a',\n      sourcePath: 'index.js'\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[1],\n      generated: raw,\n      str: 'exports.a',\n      sourcePath: 'local.js'\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[2],\n      generated: raw,\n      str: 'exports.count = function(a, b) {',\n      generatedStr: 'exports.count = function(a, b) {',\n      sourcePath: 'utils/util.js'\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[2],\n      generated: raw,\n      str: 'return a + b',\n      sourcePath: 'utils/util.js'\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap for a minified js bundle with requires","suites":["sourcemaps"],"updatePoint":{"line":269,"column":76,"index":9852},"line":269,"code":"  it('should create a valid sourcemap for a minified js bundle with requires', async function () {\n    let sourceDir = path.join(__dirname, '/integration/sourcemap-nested-minified/');\n    let sourceFilename = path.join(sourceDir, '/index.js');\n    await bundle(sourceFilename, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    let distDir = path.join(__dirname, '/integration/sourcemap-nested-minified/dist/');\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceRoot = map.sourceRoot;\n    assert.equal(sourceRoot, '../', 'sourceRoot should be the root of the source files, relative to the output directory.');\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let mapData = sourceMap.getMap();\n    assert.equal(mapData.sources.length, 4);\n    for (let source of mapData.sources) {\n      if (source === '<anon>') {\n        continue;\n      }\n      assert(await inputFS.exists(path.resolve(distDir + sourceRoot + source)), 'combining sourceRoot and sources object should resolve to the original file');\n    }\n    let inputs = [await inputFS.readFile(sourceFilename, 'utf8'), await inputFS.readFile(path.join(sourceDir, 'local.js'), 'utf8'), await inputFS.readFile(path.join(sourceDir, 'utils/util.js'), 'utf8')];\n\n    // TODO: Figure out a way to tests these without relying on generatedStr as much\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[0],\n      generated: raw,\n      str: 'const local',\n      generatedStr: 'let o',\n      sourcePath: 'index.js'\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[0],\n      generated: raw,\n      str: 'local.a',\n      generatedStr: 'o.a',\n      sourcePath: 'index.js'\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[1],\n      generated: raw,\n      str: 'exports.a',\n      generatedStr: 't.a',\n      sourcePath: 'local.js'\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[2],\n      generated: raw,\n      str: 'exports.count = function(a, b) {',\n      generatedStr: 't.count=function(e,n){',\n      sourcePath: 'utils/util.js'\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap as a child of a TS bundle","suites":["sourcemaps"],"updatePoint":{"line":333,"column":63,"index":12218},"line":333,"code":"  it('should create a valid sourcemap as a child of a TS bundle', async function () {\n    let inputFilePath = path.join(__dirname, '/integration/sourcemap-typescript/index.ts');\n    await bundle(inputFilePath);\n    let distDir = path.join(__dirname, '../dist/');\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    assert.equal(map.file, 'index.js.map');\n    assert(raw.includes('//# sourceMappingURL=index.js.map'));\n    // assert.equal(map.sourceRoot, '/__parcel_source_root/');\n\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let mapData = sourceMap.getMap();\n    assert.equal(mapData.sources.length, 2);\n    assert.deepEqual(mapData.sources, ['index.ts', '../../../../../transformers/js/src/esmodule-helpers.js']);\n    let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[0]), 'utf8');\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'function env()',\n      sourcePath: 'index.ts'\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap as a child of a nested TS bundle","suites":["sourcemaps"],"updatePoint":{"line":362,"column":70,"index":13482},"line":362,"code":"  it('should create a valid sourcemap as a child of a nested TS bundle', async function () {\n    let inputFilePath = path.join(__dirname, '/integration/sourcemap-typescript-nested/index.ts');\n    await bundle(inputFilePath);\n    let distDir = path.join(__dirname, '../dist/');\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    assert.equal(map.file, 'index.js.map');\n    assert(raw.includes('//# sourceMappingURL=index.js.map'));\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let mapData = sourceMap.getMap();\n    assert.equal(mapData.sources.length, 3);\n    assert.deepEqual(mapData.sources, ['index.ts', 'local.ts', '../../../../../transformers/js/src/esmodule-helpers.js']);\n    let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[0]), 'utf8');\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'function env()',\n      sourcePath: 'index.ts'\n    });\n    let local = await inputFS.readFile(path.join(__dirname, '/integration/sourcemap-typescript-nested/local.ts'), 'utf-8');\n    checkSourceMapping({\n      map: sourceMap,\n      source: local,\n      generated: raw,\n      str: 'exports.local',\n      sourcePath: 'local.ts'\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap when using the Typescript tsc transformer","suites":["sourcemaps"],"updatePoint":{"line":397,"column":79,"index":14989},"line":397,"code":"  it('should create a valid sourcemap when using the Typescript tsc transformer', async function () {\n    let inputFilePath = path.join(__dirname, '/integration/sourcemap-typescript-tsc/src/index.ts');\n    let b = await bundle(inputFilePath);\n    let filename = b.getBundles()[0].filePath;\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    assert.equal(map.file, 'index.js.map');\n    assert(raw.includes('//# sourceMappingURL=index.js.map'));\n    // assert.equal(map.sourceRoot, '/__parcel_source_root/');\n\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let mapData = sourceMap.getMap();\n    assert.deepEqual(mapData.sources, ['src/index.ts']);\n    assert(map.sourcesContent.every(s => s));\n    let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[0]), 'utf8');\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'nonExistsFunc',\n      sourcePath: 'src/index.ts'\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap for a CSS bundle","suites":["sourcemaps"],"updatePoint":{"line":425,"column":54,"index":16147},"line":425,"code":"  it('should create a valid sourcemap for a CSS bundle', async function () {\n    async function test(minify) {\n      let inputFilePath = path.join(__dirname, '/integration/sourcemap-css/style.css');\n      await bundle(inputFilePath, {\n        defaultTargetOptions: {\n          shouldOptimize: minify\n        }\n      });\n      let distDir = path.join(__dirname, '../dist/');\n      let filename = path.join(distDir, 'style.css');\n      let raw = await outputFS.readFile(filename, 'utf8');\n      let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n      if (!mapUrlData) {\n        throw new Error('Could not load map');\n      }\n      let map = mapUrlData.map;\n      assert.equal(map.file, 'style.css.map');\n      assert(raw.includes('/*# sourceMappingURL=style.css.map */'));\n      let sourceMap = new SourceMap('/');\n      sourceMap.addVLQMap(map);\n      let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[0]), 'utf8');\n      let mapData = sourceMap.getMap();\n      assert.equal(mapData.sources.length, 1);\n      assert.deepEqual(mapData.sources, ['style.css']);\n      checkSourceMapping({\n        map: sourceMap,\n        source: input,\n        generated: raw,\n        str: 'body',\n        sourcePath: 'style.css',\n        msg: ' ' + (minify ? 'with' : 'without') + ' minification'\n      });\n    }\n    await test(false);\n    await test(true);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap for a CSS bundle with imports","suites":["sourcemaps"],"updatePoint":{"line":461,"column":67,"index":17567},"line":461,"code":"  it('should create a valid sourcemap for a CSS bundle with imports', async function () {\n    async function test(minify) {\n      let inputFilePath = path.join(__dirname, '/integration/sourcemap-css-import/style.css');\n      await bundle(inputFilePath, {\n        defaultTargetOptions: {\n          shouldOptimize: minify\n        }\n      });\n      let distDir = path.join(__dirname, '../dist/');\n      let filename = path.join(distDir, 'style.css');\n      let raw = await outputFS.readFile(filename, 'utf8');\n      let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n      if (!mapUrlData) {\n        throw new Error('Could not load map');\n      }\n      let map = mapUrlData.map;\n      assert.equal(map.file, 'style.css.map');\n      assert(raw.includes('/*# sourceMappingURL=style.css.map */'));\n      let sourceMap = new SourceMap('/');\n      sourceMap.addVLQMap(map);\n      let mapData = sourceMap.getMap();\n      let sources = minify ? ['style.css', 'other-style.css', 'another-style.css'] : ['other-style.css', 'another-style.css', 'style.css'];\n      assert.deepEqual(mapData.sources, sources);\n      let otherStyle = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[sources.indexOf('other-style.css')]), 'utf-8');\n      let anotherStyle = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[sources.indexOf('another-style.css')]), 'utf-8');\n      let style = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[sources.indexOf('style.css')]), 'utf8');\n      checkSourceMapping({\n        map: sourceMap,\n        source: style,\n        generated: raw,\n        str: 'body',\n        sourcePath: 'style.css',\n        msg: ' ' + (minify ? 'with' : 'without') + ' minification'\n      });\n      checkSourceMapping({\n        map: sourceMap,\n        source: otherStyle,\n        generated: raw,\n        str: 'div',\n        sourcePath: 'other-style.css',\n        msg: ' ' + (minify ? 'with' : 'without') + ' minification'\n      });\n      checkSourceMapping({\n        map: sourceMap,\n        source: anotherStyle,\n        generated: raw,\n        str: 'main',\n        sourcePath: 'another-style.css',\n        msg: ' ' + (minify ? 'with' : 'without') + ' minification'\n      });\n    }\n    await test(false);\n    await test(true);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap for a Sass asset","suites":["sourcemaps"],"updatePoint":{"line":515,"column":54,"index":19894},"line":515,"code":"  it('should create a valid sourcemap for a Sass asset', async function () {\n    async function test(shouldOptimize) {\n      let inputFilePath = path.join(__dirname, '/integration/sourcemap-sass/style.scss');\n      await bundle(inputFilePath, {\n        defaultTargetOptions: {\n          shouldOptimize\n        }\n      });\n      let distDir = path.join(__dirname, '../dist/');\n      let filename = path.join(distDir, 'style.css');\n      let raw = await outputFS.readFile(filename, 'utf8');\n      let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n      if (!mapUrlData) {\n        throw new Error('Could not load map');\n      }\n      let map = mapUrlData.map;\n      assert.equal(map.file, 'style.css.map');\n      assert(raw.includes('/*# sourceMappingURL=style.css.map */'));\n      let sourceMap = new SourceMap('/');\n      sourceMap.addVLQMap(map);\n      let mapData = sourceMap.getMap();\n      assert.equal(mapData.sources.length, shouldOptimize ? 2 : 1);\n      let index = mapData.sources.indexOf('style.scss');\n      assert.strictEqual(mapData.sources[index], 'style.scss');\n      let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[index]), 'utf-8');\n      checkSourceMapping({\n        map: sourceMap,\n        source: input,\n        generated: raw,\n        str: 'body',\n        sourcePath: 'style.scss',\n        msg: ' ' + (shouldOptimize ? 'with' : 'without') + ' minification'\n      });\n    }\n    await test(false);\n    await test(true);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap for a Sass asset w/ imports","suites":["sourcemaps"],"updatePoint":{"line":552,"column":65,"index":21414},"line":552,"code":"  it('should create a valid sourcemap for a Sass asset w/ imports', async function () {\n    let inputFilePath = path.join(__dirname, '/integration/scss-sourcemap-imports/style.scss');\n    await bundle(inputFilePath);\n    let distDir = path.join(__dirname, '../dist/');\n    let filename = path.join(distDir, 'style.css');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    assert.equal(map.file, 'style.css.map');\n    assert(raw.includes('/*# sourceMappingURL=style.css.map */'));\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let mapData = sourceMap.getMap();\n    // This should actually just be `./integration/scss-sourcemap-imports/with_url.scss`\n    // but this is a small bug in the extend utility of the source-map library\n    assert.deepEqual(mapData.sources, ['integration/scss-sourcemap-imports/style.scss', 'integration/scss-sourcemap-imports/with_url.scss']);\n    let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[1]), 'utf-8');\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'body',\n      sourcePath: 'integration/scss-sourcemap-imports/with_url.scss'\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap when for a CSS asset importing Sass","suites":["sourcemaps"],"updatePoint":{"line":580,"column":73,"index":22812},"line":580,"code":"  it('should create a valid sourcemap when for a CSS asset importing Sass', async function () {\n    async function test(shouldOptimize) {\n      let inputFilePath = path.join(__dirname, '/integration/sourcemap-sass-imported/style.css');\n      await bundle(inputFilePath, {\n        defaultTargetOptions: {\n          shouldOptimize\n        }\n      });\n      let distDir = path.join(__dirname, '../dist/');\n      let filename = path.join(distDir, 'style.css');\n      let raw = await outputFS.readFile(filename, 'utf8');\n      let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n      if (!mapUrlData) {\n        throw new Error('Could not load map');\n      }\n      let map = mapUrlData.map;\n      assert.equal(map.file, 'style.css.map');\n      assert(raw.includes('/*# sourceMappingURL=style.css.map */'));\n      let sourceMap = new SourceMap('/');\n      sourceMap.addVLQMap(map);\n      let mapData = sourceMap.getMap();\n      // TODO: htmlnano inserts `./<input css 1>`\n      assert(mapData.sources.includes('other.scss'));\n      assert(mapData.sources.includes('style.css'));\n      let style = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, 'style.css'), 'utf-8');\n      let other = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, 'other.scss'), 'utf-8');\n      checkSourceMapping({\n        map: sourceMap,\n        source: style,\n        generated: raw,\n        str: 'body',\n        sourcePath: 'style.css',\n        msg: ' ' + (shouldOptimize ? 'with' : 'without') + ' minification'\n      });\n      checkSourceMapping({\n        map: sourceMap,\n        source: other,\n        generated: raw,\n        str: 'div',\n        sourcePath: 'other.scss',\n        msg: ' ' + (shouldOptimize ? 'with' : 'without') + ' minification'\n      });\n    }\n    await test(false);\n    await test(true);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap for a LESS asset","suites":["sourcemaps"],"updatePoint":{"line":626,"column":54,"index":24642},"line":626,"code":"  it('should create a valid sourcemap for a LESS asset', async function () {\n    async function test(shouldOptimize) {\n      let inputFilePath = path.join(__dirname, '/integration/sourcemap-less/style.less');\n      await bundle(inputFilePath, {\n        defaultTargetOptions: {\n          shouldOptimize\n        }\n      });\n      let distDir = path.join(__dirname, '../dist/');\n      let filename = path.join(distDir, 'style.css');\n      let raw = await outputFS.readFile(filename, 'utf8');\n      let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n      if (!mapUrlData) {\n        throw new Error('Could not load map');\n      }\n      let map = mapUrlData.map;\n      assert.equal(map.file, 'style.css.map');\n      assert(raw.includes('/*# sourceMappingURL=style.css.map */'));\n      let sourceMap = new SourceMap('/');\n      sourceMap.addVLQMap(map);\n      let mapData = sourceMap.getMap();\n      assert(mapData.sources.includes('style.less'));\n      let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, 'style.less'), 'utf-8');\n      checkSourceMapping({\n        map: sourceMap,\n        source: input,\n        generated: raw,\n        str: 'div',\n        sourcePath: 'style.less',\n        msg: ' ' + (shouldOptimize ? 'with' : 'without') + ' minification'\n      });\n    }\n    await test(false);\n    await test(true);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should be able to create a sourcemap with inlined sources","suites":["sourcemaps"],"updatePoint":{"line":661,"column":63,"index":26018},"line":661,"code":"  it('Should be able to create a sourcemap with inlined sources', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap-inline-sources/index.js');\n    await bundle(sourceFilename);\n    let distDir = path.join(__dirname, '/integration/sourcemap-inline-sources/dist/');\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapData) {\n      throw new Error('Could not load map');\n    }\n    let sourceContent = await inputFS.readFile(sourceFilename, 'utf-8');\n    let map = mapData.map;\n    assert.equal(map.file, 'index.js.map');\n    assert.deepEqual(map.sources, ['index.js', '../../../../../transformers/js/src/esmodule-helpers.js']);\n    assert.equal(map.sourcesContent[0], sourceContent);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should be able to create inline sourcemaps","suites":["sourcemaps"],"updatePoint":{"line":677,"column":48,"index":26866},"line":677,"code":"  it('Should be able to create inline sourcemaps', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap-generate-inline/index.js');\n    await bundle(sourceFilename);\n    let distDir = path.join(__dirname, '/integration/sourcemap-generate-inline/dist/');\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    assert(mapUrlData.url.startsWith('data:application/json;charset=utf-8;base64,'), 'inline sourcemap bundles should have a base64 url');\n    let map = mapUrlData.map;\n    assert.equal(map.file, 'index.js.map');\n    assert.deepEqual(map.sources, ['index.js', '../../../../../transformers/js/src/esmodule-helpers.js']);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should respect --no-source-maps","suites":["sourcemaps"],"updatePoint":{"line":692,"column":37,"index":27724},"line":692,"code":"  it('should respect --no-source-maps', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/sourcemap/index.js'), {\n      defaultTargetOptions: {\n        sourceMaps: false\n      }\n    });\n    assert.deepStrictEqual(await outputFS.readdir(path.dirname(b.getBundles()[0].filePath)), ['index.js']);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should just skip invalid inlined sourcemaps","suites":["sourcemaps"],"updatePoint":{"line":700,"column":49,"index":28066},"line":700,"code":"  it('Should just skip invalid inlined sourcemaps', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap-invalid-existing/index.js');\n    let b = await bundle(sourceFilename);\n    let filename = b.getBundles()[0].filePath;\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let sourcemapData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!sourcemapData) {\n      throw new Error('Could not load map');\n    }\n    let map = sourcemapData.map;\n    assert.equal(map.sourceRoot, '../test/');\n    assert.equal(map.sources.length, 2);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should load existing sourcemaps of libraries","suites":["sourcemaps"],"updatePoint":{"line":713,"column":50,"index":28660},"line":713,"code":"  it('should load existing sourcemaps of libraries', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap-existing/index.js');\n    let b = await bundle(sourceFilename);\n    let filename = b.getBundles()[0].filePath;\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let sourcemapData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!sourcemapData) {\n      throw new Error('Could not load map');\n    }\n    let map = sourcemapData.map;\n    assert.equal(map.sourceRoot, '../test/');\n    assert.equal(map.sources.length, 3);\n    for (let source of map.sources) {\n      if (path.extname(source) !== '.coffee') {\n        assert(await inputFS.exists(path.join(path.basename(filename), map.sourceRoot, source)), `Source File ${source} should exist`);\n      }\n    }\n    assert.equal(map.sourcesContent[2], 'module.exports = (a, b) => a + b');\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should load inline sourcemaps of libraries","suites":["sourcemaps"],"updatePoint":{"line":732,"column":48,"index":29557},"line":732,"code":"  it('should load inline sourcemaps of libraries', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap-inline/index.js');\n    let b = await bundle(sourceFilename);\n    let filename = b.getBundles()[0].filePath;\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let sourcemapData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!sourcemapData) {\n      throw new Error('Could not load map');\n    }\n    let map = sourcemapData.map;\n    assert.equal(map.sourceRoot, '../test/');\n    assert.equal(map.sources.length, 3);\n    for (let source of map.sources) {\n      if (path.extname(source) !== '.coffee') {\n        assert(await inputFS.exists(path.join(path.basename(filename), map.sourceRoot, source)), `Source File ${source} should exist`);\n      }\n    }\n    assert.equal(map.sourcesContent[2], 'module.exports = (a, b) => a + b\\n');\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should load referenced contents of sourcemaps","suites":["sourcemaps"],"updatePoint":{"line":751,"column":51,"index":30457},"line":751,"code":"  it('should load referenced contents of sourcemaps', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap-external-contents/index.js');\n    let b = await bundle(sourceFilename);\n    let filename = b.getBundles()[0].filePath;\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let sourcemapData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!sourcemapData) {\n      throw new Error('Could not load map');\n    }\n    let map = sourcemapData.map;\n    assert.equal(map.sourceRoot, '../test/');\n    assert.equal(map.sources.length, 3);\n    for (let source of map.sources) {\n      assert(await inputFS.exists(path.join(path.basename(filename), map.sourceRoot, source)), `Source File ${source} should exist`);\n    }\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should load existing sourcemaps for CSS files","suites":["sourcemaps"],"line":767,"code":"  it.skip('should load existing sourcemaps for CSS files', async function () {","file":"sourcemaps.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should handle comments correctly in sourcemaps","suites":["sourcemaps"],"updatePoint":{"line":835,"column":52,"index":33461},"line":835,"code":"  it('should handle comments correctly in sourcemaps', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap-comments/index.js');\n    let b = await bundle(sourceFilename, {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let filename = b.getBundles()[0].filePath;\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[0]), 'utf8');\n    let sourcePath = 'index.js';\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: \"console.log('foo')\",\n      generatedStr: `console.log(\"foo\")`,\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: \"console.log('bar')\",\n      generatedStr: `console.log(\"bar\")`,\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: \"console.log('baz')\",\n      generatedStr: `console.log(\"baz\")`,\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: \"console.log('idhf')\",\n      generatedStr: `console.log(\"idhf\")`,\n      sourcePath\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"carries sourcesContent from the original sources through multiple transformations (babel and swc)","suites":["sourcemaps"],"updatePoint":{"line":886,"column":103,"index":35062},"line":886,"code":"  it('carries sourcesContent from the original sources through multiple transformations (babel and swc)', async () => {\n    let b = await bundle(path.join(__dirname, 'integration/sourcemap-original-sourcecontents/index.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let filename = b.getBundles()[0].filePath;\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let sourcePath = 'index.js';\n    let sourceContent = nullthrows(sourceMap.getSourceContent(sourcePath));\n    checkSourceMapping({\n      map: sourceMap,\n      source: sourceContent,\n      generated: raw,\n      str: 'bar=\"bar\"' /* from jsx: <App bar=\"bar\" /> */,\n      generatedStr: 'bar: \"bar\"',\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: sourceContent,\n      generated: raw,\n      str: 'document.getElementById(',\n      sourcePath\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"carries sourcesContent from the original sources (tsx) through multiple transformations (babel and swc)","suites":["sourcemaps"],"updatePoint":{"line":919,"column":109,"index":36212},"line":919,"code":"  it('carries sourcesContent from the original sources (tsx) through multiple transformations (babel and swc)', async () => {\n    let b = await bundle(path.join(__dirname, 'integration/sourcemap-original-sourcecontents-ts/index.tsx'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let filename = b.getBundles()[0].filePath;\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let sourcePath = 'index.tsx';\n    let sourceContent = nullthrows(sourceMap.getSourceContent(sourcePath));\n    checkSourceMapping({\n      map: sourceMap,\n      source: sourceContent,\n      generated: raw,\n      str: 'bar=\"bar\"' /* from tsx: <App bar=\"bar\" /> */,\n      generatedStr: 'bar: \"bar\"',\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: sourceContent,\n      generated: raw,\n      str: 'document.getElementById(',\n      sourcePath\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"retains sourcesContent from the original sources from a large text file","suites":["sourcemaps"],"updatePoint":{"line":952,"column":77,"index":37335},"line":952,"code":"  it('retains sourcesContent from the original sources from a large text file', async () => {\n    let testDir = path.join(__dirname, 'integration/sourcemap-original-sourcecontents-large');\n    await outputFS.mkdirp(testDir);\n    await Promise.all([outputFS.writeFile(path.join(testDir, 'index.js'), 'const foo = ' + `'${\n    // Generate ~6MB of text to exceed the stream threshold\n    'Lorem ipsum dolor sit amet '.repeat(245000)}';`), outputFS.writeFile(path.join(testDir, 'yarn.lock'), '')]);\n    let b = await bundle(path.join(testDir, 'index.js'), {\n      inputFS: overlayFS,\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let filename = b.getBundles()[0].filePath;\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let sourceContent = map.sourcesContent[0];\n    let sourcePath = 'index.js';\n    checkSourceMapping({\n      map: sourceMap,\n      source: sourceContent,\n      generated: raw,\n      str: `foo = 'Lorem ipsum`,\n      generatedStr: `foo = \"Lorem ipsum`,\n      sourcePath\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring stylus files","suites":["stylus"],"updatePoint":{"line":5,"column":43,"index":215},"line":5,"code":"  it('should support requiring stylus files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/stylus/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.styl']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.index'));\n  });","file":"stylus.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring stylus files with dependencies","suites":["stylus"],"updatePoint":{"line":20,"column":61,"index":755},"line":20,"code":"  it('should support requiring stylus files with dependencies', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/stylus-deps/index.js'));\n\n    // a.styl shouldn't be included as a dependency that we can see.\n    // stylus takes care of inlining it.\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.styl']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.index'));\n    assert(css.includes('.a'));\n    assert(css.includes('.b'));\n    assert(css.includes('-webkit-box'));\n    assert(css.includes('.foo'));\n  });","file":"stylus.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support linking to assets with url() from stylus","suites":["stylus"],"updatePoint":{"line":42,"column":61,"index":1550},"line":42,"code":"  it('should support linking to assets with url() from stylus', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/stylus-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.styl']\n    }, {\n      type: 'woff2',\n      assets: ['test.woff2']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(/url\\(\"?test\\.[0-9a-f]+\\.woff2\"?\\)/.test(css));\n    assert(/url\\(\"?http:\\/\\/google.com\"?\\)/.test(css));\n    assert(css.includes('.index'));\n    assert(await outputFS.exists(path.join(distDir, css.match(/url\\(\"?(test\\.[0-9a-f]+\\.woff2)\"?\\)/)[1])));\n  });","file":"stylus.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore paths starting with \"#\" when resolving with stylus url()","suites":["stylus"],"updatePoint":{"line":63,"column":76,"index":2391},"line":63,"code":"  it('should ignore paths starting with \"#\" when resolving with stylus url()', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/stylus-id-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.styl']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('#clip-path'));\n    assert(css.includes('.svg-background'));\n  });","file":"stylus.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming stylus with css modules","suites":["stylus"],"updatePoint":{"line":79,"column":57,"index":2983},"line":79,"code":"  it('should support transforming stylus with css modules', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/stylus-postcss/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'index.module.styl']\n    }, {\n      name: 'index.css',\n      assets: ['index.module.styl']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert(output().endsWith('_index'));\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(/\\.[_0-9a-zA-Z]+_index/.test(css));\n  });","file":"stylus.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring stylus files with glob dependencies","suites":["stylus"],"updatePoint":{"line":94,"column":66,"index":3585},"line":94,"code":"  it('should support requiring stylus files with glob dependencies', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/stylus-glob-import/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.styl']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.index'));\n    assert(css.includes('.main'));\n    assert(css.includes('.foo'));\n    assert(css.includes('.bar'));\n  });","file":"stylus.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the stylus package exports condition","suites":["stylus"],"updatePoint":{"line":112,"column":57,"index":4236},"line":112,"code":"  it('should support the stylus package exports condition', async function () {\n    await bundle(path.join(__dirname, '/integration/stylus-exports/index.styl'));\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.a'));\n  });","file":"stylus.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly parse SugarSS asset","suites":["sugarss"],"updatePoint":{"line":5,"column":42,"index":210},"line":5,"code":"  it('should correctly parse SugarSS asset', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/sugarss/index.sss'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.sss']\n    }]);\n    let cssContent = await outputFS.readFile(path.join(distDir, '/index.css'), 'utf8');\n    assert(cssContent.includes('{'));\n  });","file":"sugarss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming SVGs to react components","suites":["svg-react"],"updatePoint":{"line":5,"column":58,"index":204},"line":5,"code":"  it('should support transforming SVGs to react components', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/svg-react/react.js'), {\n      defaultConfig: path.join(__dirname, 'integration/custom-configs/.parcelrc-svg-react')\n    });\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf-8');\n    assert(!file.includes('inkscape'));\n    assert(file.includes('const SvgIcon ='));\n    assert(file.includes('_react.createElement(\"svg\"'));\n  });","file":"svg-react.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming SVGs to typescript react components","suites":["svg-react"],"updatePoint":{"line":14,"column":69,"index":706},"line":14,"code":"  it('should support transforming SVGs to typescript react components', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/svg-react-typescript/react.ts'), {\n      defaultConfig: path.join(__dirname, 'integration/custom-configs/.parcelrc-svg-react')\n    });\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf-8');\n    let types = await outputFS.readFile(b.getBundles()[1].filePath, 'utf-8');\n    assert(!file.includes('inkscape'));\n    assert(file.includes('react.createElement(\"svg\"'));\n    assert(types.includes('const Icon: SVGRComponent'));\n  });","file":"svg-react.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should find and use a .svgrrc and .svgorc config file","suites":["svg-react"],"updatePoint":{"line":24,"column":59,"index":1297},"line":24,"code":"  it('should find and use a .svgrrc and .svgorc config file', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/svg-react-config/react.js'), {\n      defaultConfig: path.join(__dirname, 'integration/custom-configs/.parcelrc-svg-react')\n    });\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf-8');\n    assert(!file.includes('inkscape'));\n    assert(!/\\d\\.\\d/.test(file));\n    assert(file.includes('const SvgIcon ='));\n    assert(file.includes('(0, _preact.h)(\"svg\"'));\n    assert(file.includes('width: \"1em\"'));\n  });","file":"svg-react.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling SVG","suites":["svg"],"updatePoint":{"line":5,"column":33,"index":197},"line":5,"code":"  it('should support bundling SVG', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/svg/circle.svg'));\n    assertBundles(b, [{\n      name: 'circle.svg',\n      assets: ['circle.svg']\n    }, {\n      name: 'other1.html',\n      assets: ['other1.html']\n    }, {\n      type: 'svg',\n      assets: ['square.svg']\n    }, {\n      name: 'other2.html',\n      assets: ['other2.html']\n    }, {\n      type: 'svg',\n      assets: ['path.svg']\n    }, {\n      type: 'svg',\n      assets: ['gradient.svg']\n    }, {\n      type: 'js',\n      assets: ['script.js']\n    }, {\n      type: 'js',\n      assets: ['module.js', 'script.js']\n    }, {\n      type: 'css',\n      assets: ['style.css']\n    }]);\n    let file = await outputFS.readFile(b.getBundles().find(b => b.type === 'svg').filePath, 'utf-8');\n    assert(file.includes('<a href=\"/other1.html\">'));\n    assert(file.includes('<use href=\"#circle\"'));\n    assert(file.includes(`<use xlink:href=\"/${path.basename(b.getBundles().find(b => b.name.startsWith('square')).filePath)}#square\"`));\n    assert(file.includes(`fill=\"url('/${path.basename(b.getBundles().find(b => b.name.startsWith('gradient')).filePath)}#myGradient')\"`));\n    assert(file.includes(`<script xlink:href=\"/${path.basename(b.getBundles().find(b => b.type === 'js' && b.env.sourceType === 'script').filePath)}\"`));\n    assert(file.includes(`<script href=\"/${path.basename(b.getBundles().find(b => b.type === 'js' && b.env.sourceType === 'module').filePath)}\"`));\n    assert(file.includes(`<?xml-stylesheet href=\"/${path.basename(b.getBundles().find(b => b.type === 'css').filePath)}\"?>`));\n  });","file":"svg.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify SVG bundles","suites":["svg"],"updatePoint":{"line":44,"column":31,"index":1811},"line":44,"code":"  it('should minify SVG bundles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/svg/circle.svg'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    let file = await outputFS.readFile(b.getBundles().find(b => b.type === 'svg').filePath, 'utf-8');\n    assert(!file.includes('comment'));\n  });","file":"svg.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"support SVGO config files","suites":["svg"],"updatePoint":{"line":53,"column":31,"index":2167},"line":53,"code":"  it('support SVGO config files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/svgo-config/index.html'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    let file = await outputFS.readFile(b.getBundles().find(b => b.type === 'svg').filePath, 'utf-8');\n    assert(!file.includes('inkscape'));\n    assert(file.includes('comment'));\n  });","file":"svg.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect xml-stylesheet processing instructions","suites":["svg"],"updatePoint":{"line":63,"column":58,"index":2597},"line":63,"code":"  it('should detect xml-stylesheet processing instructions', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/svg-xml-stylesheet/img.svg'));\n    assertBundles(b, [{\n      name: 'img.svg',\n      assets: ['img.svg']\n    }, {\n      type: 'css',\n      assets: ['style1.css']\n    }, {\n      type: 'css',\n      assets: ['style3.css']\n    }]);\n    let file = await outputFS.readFile(b.getBundles().find(b => b.type === 'svg').filePath, 'utf-8');\n    assert(file.includes('<?xml-stylesheet'));\n    assert(file.includes('<?xml-not-a-stylesheet'));\n  });","file":"svg.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle inline CSS with @imports","suites":["svg"],"updatePoint":{"line":79,"column":44,"index":3159},"line":79,"code":"  it('should handle inline CSS with @imports', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/svg-inline-css-import/img.svg'));\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['img.svg', 'test.css']\n    }, {\n      type: 'css',\n      assets: ['img.svg']\n    }, {\n      name: 'img.svg',\n      assets: ['img.svg']\n    }, {\n      type: 'svg',\n      assets: ['gradient.svg']\n    }, {\n      type: 'js',\n      assets: ['img.svg', 'script.js']\n    }]);\n    const svg = await outputFS.readFile(path.join(distDir, 'img.svg'), 'utf8');\n    assert(!svg.includes('@import'));\n    assert(svg.includes(':root {\\n  fill: red;\\n}'));\n    assert(svg.includes(`\"fill: url(&quot;${path.basename(b.getBundles().find(b => b.name.startsWith('gradient')).filePath)}#myGradient&quot;)`));\n    assert(svg.includes('<script>'));\n    assert(svg.includes(`console.log(\"script\")`));\n    assert(!svg.includes('import '));\n  });","file":"svg.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should process inline styles using lang","suites":["svg"],"updatePoint":{"line":105,"column":45,"index":4102},"line":105,"code":"  it('should process inline styles using lang', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/svg-inline-sass/img.svg'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['img.svg']\n    }, {\n      name: 'img.svg',\n      assets: ['img.svg']\n    }]);\n    const svg = await outputFS.readFile(path.join(distDir, 'img.svg'), 'utf8');\n    assert(svg.includes('<style>:root{fill:red}</style>'));\n  });","file":"svg.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should be in separate bundles","suites":["svg"],"updatePoint":{"line":121,"column":35,"index":4608},"line":121,"code":"  it('should be in separate bundles', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/svg-multiple/index.js'));\n    assertBundles(b, [{\n      assets: ['index.js', 'bundle-url.js']\n    }, {\n      assets: ['circle.svg']\n    }, {\n      assets: ['square.svg']\n    }]);\n  });","file":"svg.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support tailwind from SCSS","suites":["tailwind"],"updatePoint":{"line":5,"column":39,"index":184},"line":5,"code":"  it('should support tailwind from SCSS', async function () {\n    let fixture = path.join(__dirname, '/integration/tailwind-scss');\n    let b = await bundle(path.join(fixture, 'index.html'));\n    let css = await outputFS.readFile(b.getBundles().find(b => b.type === 'css').filePath, 'utf8');\n    assert(css.includes('.p-2'));\n    assert(!css.includes('.m-2'));\n  });","file":"tailwind-tests.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not transpile if no targets are defined","suites":["transpilation"],"updatePoint":{"line":8,"column":52,"index":367},"line":8,"code":"  it('should not transpile if no targets are defined', async function () {\n    await bundle(path.join(__dirname, '/integration/babel-default/index.js'), {\n      defaultTargetOptions: {\n        engines: undefined,\n        shouldOptimize: false\n      }\n    });\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('class Foo'));\n    assert(file.includes('class Bar'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transpiling using browserlist","suites":["transpilation"],"updatePoint":{"line":19,"column":50,"index":790},"line":19,"code":"  it('should support transpiling using browserlist', async function () {\n    await bundle(path.join(__dirname, '/integration/babel-browserslist/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('function Foo'));\n    assert(file.includes('function Bar'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transpiling when engines have semver ranges","suites":["transpilation"],"updatePoint":{"line":25,"column":64,"index":1133},"line":25,"code":"  it('should support transpiling when engines have semver ranges', async () => {\n    let fixtureDir = path.join(__dirname, '/integration/babel-semver-engine');\n    await bundle(path.join(fixtureDir, 'index.js'));\n    let legacy = await outputFS.readFile(path.join(fixtureDir, 'dist', 'legacy.js'), 'utf8');\n    assert(legacy.includes('function Foo'));\n    assert(legacy.includes('function Bar'));\n    let modern = await outputFS.readFile(path.join(fixtureDir, 'dist', 'modern.js'), 'utf8');\n    assert(modern.includes('class Foo'));\n    assert(modern.includes('class Bar'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should transpile node_modules by default","suites":["transpilation"],"updatePoint":{"line":35,"column":46,"index":1696},"line":35,"code":"  it('should transpile node_modules by default', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/babel-node-modules/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!/class \\S+ \\{/.test(file));\n    assert(file.includes('function Bar'));\n    let res = await run(b);\n    assert.equal(res.t, 'function');\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not support JSX in node_modules","suites":["transpilation"],"updatePoint":{"line":43,"column":44,"index":2089},"line":43,"code":"  it('should not support JSX in node_modules', async function () {\n    // $FlowFixMe\n    await assert.rejects(() => bundle(path.join(__dirname, '/integration/babel-node-modules-jsx/index.js')));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile node_modules with a source field in package.json when not symlinked","suites":["transpilation"],"updatePoint":{"line":47,"column":88,"index":2334},"line":47,"code":"  it('should compile node_modules with a source field in package.json when not symlinked', async function () {\n    await bundle(path.join(__dirname, '/integration/babel-node-modules-source-unlinked/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('function Foo'));\n    assert(file.includes('function Bar'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX","suites":["transpilation"],"updatePoint":{"line":53,"column":34,"index":2663},"line":53,"code":"  it('should support compiling JSX', async function () {\n    await bundle(path.join(__dirname, '/integration/jsx/index.jsx'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('React.createElement(\"div\"'));\n    assert(file.includes('fileName: \"integration/jsx/index.jsx\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX correctly with member expression type","suites":["transpilation"],"updatePoint":{"line":59,"column":72,"index":3038},"line":59,"code":"  it('should support compiling JSX correctly with member expression type', async function () {\n    await bundle(path.join(__dirname, '/integration/jsx-member/index.jsx'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('React.createElement(S.Foo'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX in JS files with React dependency","suites":["transpilation"],"updatePoint":{"line":64,"column":68,"index":3348},"line":64,"code":"  it('should support compiling JSX in JS files with React dependency', async function () {\n    await bundle(path.join(__dirname, '/integration/jsx-react/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('React.createElement(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX with pure annotations","suites":["transpilation"],"updatePoint":{"line":69,"column":56,"index":3644},"line":69,"code":"  it('should support compiling JSX with pure annotations', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-react/pure-comment.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'pure-comment.js'), 'utf8');\n    assert(file.includes('/*#__PURE__*/ (0, _reactDefault.default).createElement'));\n    let res = await run(b);\n    assert(res.Foo());\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX in JS files with React aliased to Preact","suites":["transpilation"],"updatePoint":{"line":76,"column":75,"index":4061},"line":76,"code":"  it('should support compiling JSX in JS files with React aliased to Preact', async function () {\n    await bundle(path.join(__dirname, '/integration/jsx-react-alias/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('React.createElement(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX in JS files with Preact dependency","suites":["transpilation"],"updatePoint":{"line":81,"column":69,"index":4376},"line":81,"code":"  it('should support compiling JSX in JS files with Preact dependency', async function () {\n    await bundle(path.join(__dirname, '/integration/jsx-preact/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('h(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX in JS files with Preact url dependency","suites":["transpilation"],"updatePoint":{"line":86,"column":73,"index":4672},"line":86,"code":"  it('should support compiling JSX in JS files with Preact url dependency', async function () {\n    await bundle(path.join(__dirname, '/integration/jsx-preact-with-url/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('h(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX in TS files with Preact dependency","suites":["transpilation"],"updatePoint":{"line":91,"column":69,"index":4973},"line":91,"code":"  it('should support compiling JSX in TS files with Preact dependency', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-preact-ts/index.tsx'));\n    assert(typeof (await run(b)) === 'object');\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX in JS files with Nerv dependency","suites":["transpilation"],"updatePoint":{"line":95,"column":67,"index":5205},"line":95,"code":"  it('should support compiling JSX in JS files with Nerv dependency', async function () {\n    await bundle(path.join(__dirname, '/integration/jsx-nervjs/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('Nerv.createElement(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX in JS files with Hyperapp dependency","suites":["transpilation"],"updatePoint":{"line":100,"column":71,"index":5516},"line":100,"code":"  it('should support compiling JSX in JS files with Hyperapp dependency', async function () {\n    await bundle(path.join(__dirname, '/integration/jsx-hyperapp/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('h(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not transpile spread in JSX with modern targets","suites":["transpilation"],"updatePoint":{"line":105,"column":60,"index":5801},"line":105,"code":"  it('should not transpile spread in JSX with modern targets', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-spread/index.jsx'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('React.createElement(\"div\"'));\n    assert(file.includes('...a'));\n    assert(!file.includes('@swc/helpers'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the automatic JSX runtime with React >= 17","suites":["transpilation"],"updatePoint":{"line":112,"column":63,"index":6189},"line":112,"code":"  it('should support the automatic JSX runtime with React >= 17', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-automatic/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('react/jsx-dev-runtime'));\n    assert(file.includes('(0, _jsxDevRuntime.jsxDEV)(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the automatic JSX runtime with preact >= 10.5","suites":["transpilation"],"updatePoint":{"line":118,"column":66,"index":6562},"line":118,"code":"  it('should support the automatic JSX runtime with preact >= 10.5', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-automatic-preact/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('preact/jsx-dev-runtime'));\n    assert(file.includes('(0, _jsxDevRuntime.jsxDEV)(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the automatic JSX runtime with React ^16.14.0","suites":["transpilation"],"updatePoint":{"line":124,"column":66,"index":6943},"line":124,"code":"  it('should support the automatic JSX runtime with React ^16.14.0', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-automatic-16/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('react/jsx-dev-runtime'));\n    assert(file.includes('(0, _jsxDevRuntime.jsxDEV)(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the automatic JSX runtime with React 18 prereleases","suites":["transpilation"],"updatePoint":{"line":130,"column":72,"index":7325},"line":130,"code":"  it('should support the automatic JSX runtime with React 18 prereleases', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-automatic-18/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('react/jsx-dev-runtime'));\n    assert(file.includes('(0, _jsxDevRuntime.jsxDEV)(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the automatic JSX runtime with experimental React versions","suites":["transpilation"],"updatePoint":{"line":136,"column":79,"index":7714},"line":136,"code":"  it('should support the automatic JSX runtime with experimental React versions', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-automatic-experimental/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('react/jsx-dev-runtime'));\n    assert(file.includes('(0, _jsxDevRuntime.jsxDEV)(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the automatic JSX runtime with preact with alias","suites":["transpilation"],"updatePoint":{"line":142,"column":69,"index":8103},"line":142,"code":"  it('should support the automatic JSX runtime with preact with alias', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-automatic-preact-with-alias/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(/\\Wreact\\/jsx-dev-runtime\\W/.test(file));\n    assert(file.includes('(0, _jsxDevRuntime.jsxDEV)(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the automatic JSX runtime with explicit tsconfig.json","suites":["transpilation"],"updatePoint":{"line":148,"column":74,"index":8503},"line":148,"code":"  it('should support the automatic JSX runtime with explicit tsconfig.json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-automatic-tsconfig/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('preact/jsx-dev-runtime'));\n    assert(file.includes('(0, _jsxDevRuntime.jsxDEV)(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support explicit JSX pragma in tsconfig.json","suites":["transpilation"],"updatePoint":{"line":154,"column":57,"index":8877},"line":154,"code":"  it('should support explicit JSX pragma in tsconfig.json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-pragma-tsconfig/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('JSX(JSXFragment'));\n    assert(file.includes('JSX(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support explicitly enabling JSX in tsconfig.json","suites":["transpilation"],"updatePoint":{"line":160,"column":61,"index":9222},"line":160,"code":"  it('should support explicitly enabling JSX in tsconfig.json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-tsconfig/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('React.createElement(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support enabling decorators in tsconfig.json","suites":["transpilation"],"updatePoint":{"line":165,"column":57,"index":9526},"line":165,"code":"  it('should support enabling decorators in tsconfig.json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/decorators/index.ts'));\n    let output = [];\n    await run(b, {\n      output(o) {\n        output.push(o);\n      }\n    });\n    assert.deepEqual(output, ['first(): factory evaluated', 'second(): factory evaluated', 'second(): called', 'first(): called']);\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support enabling decorators and setting useDefineForClassFields in tsconfig.json","suites":["transpilation"],"updatePoint":{"line":175,"column":93,"index":9962},"line":175,"code":"  it('should support enabling decorators and setting useDefineForClassFields in tsconfig.json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/decorators-useDefineForClassFields/index.ts'));\n    let output = [];\n    await run(b, {\n      output(...o) {\n        output.push(...o);\n      }\n    });\n    assert.deepEqual(output, ['foo 15', 'foo 16']);\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transpiling optional chaining","suites":["transpilation"],"updatePoint":{"line":185,"column":50,"index":10305},"line":185,"code":"  it('should support transpiling optional chaining', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/babel-optional-chaining/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!file.includes('?.'));\n    let output = await run(b);\n    assert.equal(typeof output, 'object');\n    assert.deepEqual(output.default, [undefined, undefined]);\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should only include necessary parts of core-js using browserlist","suites":["transpilation"],"updatePoint":{"line":193,"column":70,"index":10747},"line":193,"code":"  it('should only include necessary parts of core-js using browserlist', async function () {\n    await bundle(path.join(__dirname, '/integration/babel-core-js/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    // console.log(file)\n    assert(file.includes('async function Bar() {'));\n    // Check that core-js's globalThis polyfill is referenced.\n    // NOTE: This may change if core-js internals change.\n    assert(file.includes('esnext.global-this'));\n    assert(!file.includes('es.array.concat'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve @swc/helpers and regenerator-runtime relative to parcel","suites":["transpilation"],"updatePoint":{"line":203,"column":76,"index":11306},"line":203,"code":"  it('should resolve @swc/helpers and regenerator-runtime relative to parcel', async function () {\n    let dir = path.join('/tmp/' + Math.random().toString(36).slice(2));\n    await outputFS.mkdirp(dir);\n    await ncp(path.join(__dirname, '/integration/swc-helpers'), dir);\n    await bundle(path.join(dir, 'index.js'), {\n      mode: 'production',\n      inputFS: overlayFS,\n      defaultTargetOptions: {\n        engines: {\n          browsers: '>= 0.25%'\n        }\n      }\n    });\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs and esm versions of @swc/helpers","suites":["transpilation"],"updatePoint":{"line":217,"column":62,"index":11776},"line":217,"code":"  it('should support commonjs and esm versions of @swc/helpers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/swc-helpers-library/index.js'));\n    let file = await outputFS.readFile(nullthrows(b.getBundles().find(b => b.env.outputFormat === 'commonjs')).filePath, 'utf8');\n    assert(file.includes('@swc/helpers/cjs/_class_call_check.cjs'));\n    file = await outputFS.readFile(nullthrows(b.getBundles().find(b => b.env.outputFormat === 'esmodule')).filePath, 'utf8');\n    assert(file.includes('@swc/helpers/_/_class_call_check'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs versions of @swc/helpers without scope hoisting","suites":["transpilation"],"updatePoint":{"line":224,"column":77,"index":12363},"line":224,"code":"  it('should support commonjs versions of @swc/helpers without scope hoisting', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/swc-helpers-library/index.js'), {\n      targets: {\n        test: {\n          distDir,\n          isLibrary: true,\n          scopeHoist: false\n        }\n      }\n    });\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('@swc/helpers/cjs/_class_call_check.cjs'));\n    await run(b);\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should print errors from transpilation","suites":["transpilation"],"updatePoint":{"line":238,"column":44,"index":12826},"line":238,"code":"  it('should print errors from transpilation', async function () {\n    let source = path.join(__dirname, '/integration/transpilation-invalid/index.js');\n    // $FlowFixMe\n    await assert.rejects(() => bundle(source), {\n      name: 'BuildError',\n      diagnostics: [{\n        codeFrames: [{\n          codeHighlights: [{\n            message: null,\n            start: {\n              column: 1,\n              line: 1\n            },\n            end: {\n              column: 12,\n              line: 1\n            }\n          }],\n          filePath: source\n        }],\n        hints: null,\n        message: 'pragma cannot be set when runtime is automatic',\n        origin: '@parcel/transformer-js'\n      }, {\n        codeFrames: [{\n          codeHighlights: [{\n            message: null,\n            start: {\n              column: 4,\n              line: 9\n            },\n            end: {\n              column: 4,\n              line: 9\n            }\n          }],\n          filePath: source\n        }],\n        hints: null,\n        message: 'duplicate private name #x.',\n        origin: '@parcel/transformer-js'\n      }]\n    });\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile node_modules when symlinked with a source field in package.json","suites":["transpilation","tests needing the real filesystem"],"updatePoint":{"line":294,"column":86,"index":14284},"line":294,"code":"    it('should compile node_modules when symlinked with a source field in package.json', async function () {\n      if (process.platform === 'win32') {\n        this.skip();\n        return;\n      }\n      const inputDir = path.join(__dirname, '/input');\n      await fs.rimraf(inputDir);\n      await fs.mkdirp(path.join(inputDir, 'node_modules'));\n      await fs.ncp(path.join(path.join(__dirname, '/integration/babel-node-modules-source')), inputDir);\n\n      // Create the symlink here to prevent cross platform and git issues\n      symlinkSync(path.join(inputDir, 'packages/foo'), path.join(inputDir, 'node_modules/foo'), 'dir');\n      await bundle(inputDir + '/index.js', {\n        outputFS: fs\n      });\n      let file = await fs.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(file.includes('function Foo'));\n      assert(file.includes('function Bar'));\n    });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate a typescript declaration file","suites":["typescript types"],"updatePoint":{"line":6,"column":51,"index":285},"line":6,"code":"  it('should generate a typescript declaration file', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/ts-types/main/index.ts'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.ts']\n    }, {\n      type: 'ts',\n      assets: ['index.ts']\n    }]);\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/main/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/main/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate ts declarations with imports","suites":["typescript types"],"updatePoint":{"line":19,"column":50,"index":875},"line":19,"code":"  it('should generate ts declarations with imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/ts-types/importing/index.ts'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.ts', 'namespace.ts']\n    }, {\n      type: 'ts',\n      assets: ['index.ts']\n    }]);\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/importing/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/importing/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate ts declarations with imports and naming collisions","suites":["typescript types"],"updatePoint":{"line":32,"column":72,"index":1518},"line":32,"code":"  it('should generate ts declarations with imports and naming collisions', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/ts-types/importing-collision/index.ts'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.ts', 'other1.ts', 'other2.ts']\n    }, {\n      type: 'ts',\n      assets: ['index.ts']\n    }]);\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/importing-collision/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/importing-collision/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate ts declarations with exports","suites":["typescript types"],"updatePoint":{"line":45,"column":50,"index":2179},"line":45,"code":"  it('should generate ts declarations with exports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/ts-types/exporting/index.ts'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.ts', 'message.ts', 'other.ts', 'test.ts']\n    }, {\n      type: 'ts',\n      assets: ['index.ts']\n    }]);\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/exporting/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/exporting/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate ts declarations with export of an overloaded function signature","suites":["typescript types"],"updatePoint":{"line":58,"column":85,"index":2856},"line":58,"code":"  it('should generate ts declarations with export of an overloaded function signature', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/ts-types/exporting-overload/index.ts'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.ts']\n    }, {\n      type: 'ts',\n      assets: ['index.ts']\n    }]);\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/exporting-overload/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/exporting-overload/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate ts declarations with externals","suites":["typescript types"],"updatePoint":{"line":71,"column":52,"index":3490},"line":71,"code":"  it('should generate ts declarations with externals', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/ts-types/externals/index.tsx'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.tsx', 'other.tsx']\n    }, {\n      type: 'ts',\n      assets: ['index.tsx']\n    }]);\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/externals/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/externals/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate ts declarations with externals that conflict with exported names","suites":["typescript types"],"updatePoint":{"line":84,"column":86,"index":4147},"line":84,"code":"  it('should generate ts declarations with externals that conflict with exported names', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/ts-types/import-export-collision/index.ts'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.ts']\n    }, {\n      type: 'ts',\n      assets: ['index.ts']\n    }]);\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/import-export-collision/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/import-export-collision/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove private properties","suites":["typescript types"],"updatePoint":{"line":97,"column":38,"index":4782},"line":97,"code":"  it('should remove private properties', async function () {\n    await bundle(path.join(__dirname, '/integration/ts-types/private/index.ts'));\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/private/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/private/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not throw errors on typing of a callback which returns a promise or value","suites":["typescript types"],"updatePoint":{"line":103,"column":86,"index":5277},"line":103,"code":"  it('should not throw errors on typing of a callback which returns a promise or value', async function () {\n    await bundle(path.join(__dirname, '/integration/ts-types/promise-or-value/index.ts'));\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/promise-or-value/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/promise-or-value/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly reference unbuilt monorepo packages","suites":["typescript types"],"updatePoint":{"line":109,"column":58,"index":5771},"line":109,"code":"  it('should correctly reference unbuilt monorepo packages', async function () {\n    let fixtureDir = path.join(__dirname, 'integration/ts-types/monorepo');\n    await outputFS.mkdirp(path.join(fixtureDir, 'node_modules'));\n    await ncp(fixtureDir, fixtureDir);\n    await outputFS.symlink(path.join(fixtureDir, 'b'), path.join(fixtureDir, 'node_modules/b'));\n    let b = await bundle(path.join(fixtureDir, 'a'), {\n      inputFS: overlayFS\n    });\n    assertBundles(b, [{\n      type: 'ts',\n      assets: ['index.ts']\n    }]);\n    let dist = (await outputFS.readFile(b.getBundles()[0].filePath, 'utf8')).replace(/\\r\\n/g, '\\n');\n    assert(/import\\s*{\\s*B\\s*}\\s*from\\s*\"b\";/.test(dist));\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate a typescript declaration file even when composite and incremental are true","suites":["typescript types"],"updatePoint":{"line":124,"column":96,"index":6500},"line":124,"code":"  it('should generate a typescript declaration file even when composite and incremental are true', async function () {\n    await bundle(path.join(__dirname, '/integration/ts-types/composite/index.ts'));\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/composite/dist/index.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/composite/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw a diagnostic on fatal errors","suites":["typescript types"],"updatePoint":{"line":130,"column":47,"index":6962},"line":130,"code":"  it('should throw a diagnostic on fatal errors', async function () {\n    let message = md`Return type of exported function has or is using name 'Snapshot' from external module \"${path.join(__dirname, '/integration/ts-types/error/file2')}\" but cannot be named.`;\n    await assert.rejects(() => bundle(path.join(__dirname, '/integration/ts-types/error/index.ts')), {\n      name: 'BuildError',\n      message,\n      diagnostics: [{\n        message,\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/ts-types/error/index.ts'),\n          code: await inputFS.readFile(path.join(__dirname, '/integration/ts-types/error/index.ts'), 'utf8'),\n          codeHighlights: [{\n            start: {\n              line: 13,\n              column: 17\n            },\n            end: {\n              line: 13,\n              column: 32\n            },\n            message\n          }]\n        }],\n        origin: '@parcel/transformer-typescript-types'\n      }]\n    });\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with module augmentation","suites":["typescript types"],"updatePoint":{"line":156,"column":42,"index":7938},"line":156,"code":"  it('should work with module augmentation', async function () {\n    let fixtureDir = path.join(__dirname, 'integration/ts-types/augmentation');\n    await outputFS.mkdirp(path.join(fixtureDir, 'node_modules'));\n    await ncp(fixtureDir, fixtureDir);\n    await outputFS.symlink(path.join(fixtureDir, 'original'), path.join(fixtureDir, 'node_modules/original'));\n    let b = await bundle(path.join(fixtureDir, 'augmenter'), {\n      inputFS: overlayFS\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      type: 'js',\n      assets: ['index.ts']\n    }, {\n      name: 'index.d.ts',\n      type: 'ts',\n      assets: ['index.ts']\n    }]);\n    let dist = (await outputFS.readFile(path.join(fixtureDir, 'augmenter/dist/index.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(fixtureDir, 'augmenter/src/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle re-exporting aggregating correctly","suites":["typescript types"],"updatePoint":{"line":177,"column":54,"index":8859},"line":177,"code":"  it('should handle re-exporting aggregating correctly', async function () {\n    await bundle(path.join(__dirname, '/integration/ts-types/re-exporting-aggregating/index.ts'));\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/re-exporting-aggregating/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/re-exporting-aggregating/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle a tsconfig file with paths on windows","suites":["typescript types"],"updatePoint":{"line":183,"column":57,"index":9376},"line":183,"code":"  it('should handle a tsconfig file with paths on windows', async function () {\n    await bundle(path.join(__dirname, '/integration/ts-types/windows-paths/index.ts'));\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/windows-paths/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/windows-paths/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw validation error on typescript typing errors across multiple files","suites":["ts-validator"],"updatePoint":{"line":13,"column":85,"index":540},"line":13,"code":"  it('should throw validation error on typescript typing errors across multiple files', async function () {\n    let didThrow = false;\n    let entry = normalizeFilePath(path.join(__dirname, '/integration/ts-validation-error/index.ts'));\n    let testFile = normalizeFilePath(path.join(__dirname, '/integration/ts-validation-error/test.ts'));\n    try {\n      await bundle(entry, {\n        defaultConfig: config\n      });\n    } catch (e) {\n      assert.equal(e.name, 'BuildError');\n      assert(!!Array.isArray(e.diagnostics));\n      assert(e.diagnostics.length === 2);\n      let entryDiagnostic = e.diagnostics.find(diagnostic => diagnostic.codeFrames[0].filePath === entry);\n      assert(!!entryDiagnostic);\n      assert(!!entryDiagnostic.codeFrames);\n      assert.equal(entryDiagnostic.origin, '@parcel/validator-typescript');\n      assert.equal(entryDiagnostic.message, `Argument of type 'string' is not assignable to parameter of type 'Params'.`);\n      assert.equal(entryDiagnostic.codeFrames[0].filePath, entry);\n      let testFileDiagnostic = e.diagnostics.find(diagnostic => diagnostic.codeFrames[0].filePath === testFile);\n      assert(!!testFileDiagnostic);\n      assert(!!testFileDiagnostic.codeFrames);\n      assert.equal(testFileDiagnostic.origin, '@parcel/validator-typescript');\n      assert.equal(testFileDiagnostic.message, `Property 'world' does not exist on type 'Params'.`);\n      didThrow = true;\n    }\n    assert(didThrow);\n  });","file":"ts-validation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should re-run when .ts files change","suites":["ts-validator"],"updatePoint":{"line":40,"column":41,"index":1945},"line":40,"code":"  it('should re-run when .ts files change', async function () {\n    // We to try to avoid conflicts between tests using the same in-memory file system, we're creating a separate folder.\n    // During the first test pass, this is unnecessary, but because fileSystems won't be re-created when running in 'watch' mode, this is safer.\n    const inputDir = path.join(__dirname, '/ts-validator-change');\n    await outputFS.mkdirp(inputDir);\n    await outputFS.writeFile(path.join(inputDir, '/tsconfig.json'), `{}`);\n    await outputFS.writeFile(path.join(inputDir, '/index.ts'), `export const message: number = \"This is a type error!\"`);\n    let b = bundler(path.join(inputDir, '/index.ts'), {\n      inputFS: overlayFS,\n      defaultConfig: config\n    });\n    subscription = await b.watch();\n    let buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildFailure');\n    assert.equal(buildEvent.diagnostics.length, 1);\n    assert.equal(buildEvent.diagnostics[0].message, \"Type 'string' is not assignable to type 'number'.\");\n    await outputFS.writeFile(path.join(inputDir, '/index.ts'), `export const message: string = \"The type error is fixed!\"`);\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    let output = await run(buildEvent.bundleGraph);\n    assert.equal(output.message, 'The type error is fixed!');\n    await outputFS.writeFile(path.join(inputDir, '/index.ts'), `export const message: boolean = {}`);\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildFailure');\n    assert.equal(buildEvent.diagnostics.length, 1);\n    assert.equal(buildEvent.diagnostics[0].message, \"Type '{}' is not assignable to type 'boolean'.\");\n  });","file":"ts-validation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should report correct errors when multiple .ts files change at the same time - no errors","suites":["ts-validator"],"updatePoint":{"line":67,"column":94,"index":3721},"line":67,"code":"  it('should report correct errors when multiple .ts files change at the same time - no errors', async function () {\n    // We to try to avoid conflicts between tests using the same in-memory file system, we're creating a separate folder.\n    // During the first test pass, this is unnecessary, but because fileSystems won't be re-created when running in 'watch' mode, this is safer.\n    const inputDir = path.join(__dirname, '/ts-validator-multi-change');\n    await outputFS.mkdirp(inputDir);\n    await outputFS.writeFile(path.join(inputDir, '/tsconfig.json'), `{}`);\n    await outputFS.writeFile(path.join(inputDir, '/index.ts'), `import { returnMessage } from \"./returnMessage\";\n      const message: string = \"My Message!\";\n      export const output = returnMessage(message);`);\n    await outputFS.writeFile(path.join(inputDir, '/returnMessage.ts'), `export function returnMessage(message: string): string { return message; }`);\n    let b = bundler([path.join(inputDir, '/index.ts')], {\n      inputFS: overlayFS,\n      defaultConfig: config\n    });\n    subscription = await b.watch();\n    let buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    let output = await run(buildEvent.bundleGraph);\n    assert.equal(output.output, 'My Message!');\n    await outputFS.writeFile(path.join(inputDir, '/index.ts'), `import { returnMessage } from \"./returnMessage\";\n      const message: number = 123456;\n      export const output = returnMessage(message);`);\n    await outputFS.writeFile(path.join(inputDir, '/returnMessage.ts'), `export function returnMessage(message: number): number { return message; }`);\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    output = await run(buildEvent.bundleGraph);\n    assert.equal(output.output, 123456);\n  });","file":"ts-validation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should report correct errors when multiple .ts files change at the same time - with errors","suites":["ts-validator"],"updatePoint":{"line":95,"column":96,"index":5548},"line":95,"code":"  it('should report correct errors when multiple .ts files change at the same time - with errors', async function () {\n    // We to try to avoid conflicts between tests using the same in-memory file system, we're creating a separate folder.\n    // During the first test pass, this is unnecessary, but because fileSystems won't be re-created when running in 'watch' mode, this is safer.\n    const inputDir = path.join(__dirname, '/ts-validator-multi-change-errors');\n    await outputFS.mkdirp(inputDir);\n    await outputFS.writeFile(path.join(inputDir, '/tsconfig.json'), `{}`);\n    await outputFS.writeFile(path.join(inputDir, '/index.ts'), `import { returnMessage } from \"./returnMessage\";\n      const message: string = \"My Message!\";\n      export const output: string = returnMessage(message);`);\n    await outputFS.writeFile(path.join(inputDir, '/returnMessage.ts'), `export function returnMessage(message: number): number { return message; }`);\n    let b = bundler([path.join(inputDir, '/index.ts')], {\n      inputFS: overlayFS,\n      defaultConfig: config\n    });\n    subscription = await b.watch();\n    let buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildFailure');\n    assert.equal(buildEvent.diagnostics.length, 2);\n    assert.equal(buildEvent.diagnostics[1].message, \"Argument of type 'string' is not assignable to parameter of type 'number'.\");\n    await outputFS.writeFile(path.join(inputDir, '/index.ts'), `import { returnMessage } from \"./returnMessage\";\n      const message: boolean = true;\n      export const output: boolean = returnMessage(message);`);\n    await outputFS.writeFile(path.join(inputDir, '/returnMessage.ts'), `export function returnMessage(message: null): null { return message; }`);\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildFailure');\n    assert.equal(buildEvent.diagnostics.length, 1);\n    assert.equal(buildEvent.diagnostics[0].message, \"Argument of type 'true' is not assignable to parameter of type 'null'.\");\n  });","file":"ts-validation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should report correct errors when .ts dependencies change in a way that breaks a contract","suites":["ts-validator"],"updatePoint":{"line":123,"column":95,"index":7566},"line":123,"code":"  it('should report correct errors when .ts dependencies change in a way that breaks a contract', async function () {\n    // We to try to avoid conflicts between tests using the same in-memory file system, we're creating a separate folder.\n    // During the first test pass, this is unnecessary, but because fileSystems won't be re-created when running in 'watch' mode, this is safer.\n    const inputDir = path.join(__dirname, '/ts-validator-dependencies-change');\n    await outputFS.mkdirp(inputDir);\n    await outputFS.writeFile(path.join(inputDir, '/tsconfig.json'), `{}`);\n    await outputFS.writeFile(path.join(inputDir, '/index.ts'), `import { returnMessage } from \"./returnMessage\";\n      const message: string = \"My Message!\";\n      export const output = returnMessage(message);`);\n    await outputFS.writeFile(path.join(inputDir, '/returnMessage.ts'), `export function returnMessage(message: string): string { return message; }`);\n    let b = bundler([path.join(inputDir, '/index.ts')], {\n      inputFS: overlayFS,\n      defaultConfig: config\n    });\n    subscription = await b.watch();\n    let buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    let output = await run(buildEvent.bundleGraph);\n    assert.equal(output.output, 'My Message!');\n    await outputFS.writeFile(path.join(inputDir, '/returnMessage.ts'), `export function returnMessage(message: number): number { return message; }`);\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildFailure');\n    assert.equal(buildEvent.diagnostics.length, 1);\n    assert.equal(buildEvent.diagnostics[0].message, \"Argument of type 'string' is not assignable to parameter of type 'number'.\");\n  });","file":"ts-validation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support loading tsconfig.json","suites":["typescript tsc"],"updatePoint":{"line":6,"column":42,"index":303},"line":6,"code":"  it('should support loading tsconfig.json', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/typescript-config/index.ts'), {\n      config\n    });\n    let output = await run(b);\n    assert.equal(output, 2);\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!js.includes('/* test comment */'));\n  });","file":"typescript-tsc.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support loading tsconfig.json with extends","suites":["typescript tsc"],"updatePoint":{"line":15,"column":55,"index":680},"line":15,"code":"  it('should support loading tsconfig.json with extends', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/typescript-config-extends/index.ts'), {\n      config\n    });\n    let output = await run(b);\n    assert.equal(output, 2);\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!js.includes('/* test comment */'));\n  });","file":"typescript-tsc.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a type declaration file when overriding the ts pipeline","suites":["typescript tsc"],"updatePoint":{"line":24,"column":76,"index":1086},"line":24,"code":"  it('should produce a type declaration file when overriding the ts pipeline', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/typescript-types-parcelrc/index.ts'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.ts']\n    }, {\n      name: 'index.d.ts',\n      assets: ['index.ts']\n    }]);\n    let output = await run(b);\n    assert.equal(new output.Foo().run(), 'bar');\n  });","file":"typescript-tsc.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a ts bundle using ES6 imports","suites":["typescript"],"updatePoint":{"line":15,"column":52,"index":847},"line":15,"code":"    it('should produce a ts bundle using ES6 imports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/typescript/index.ts'), {\n        config\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['index.ts', 'Local.ts', 'esmodule-helpers.js']\n      }]);\n      let output = await run(b);\n      assert.equal(typeof output.count, 'function');\n      assert.equal(output.count(), 3);\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a ts bundle using commonJS require","suites":["typescript"],"updatePoint":{"line":27,"column":57,"index":1293},"line":27,"code":"    it('should produce a ts bundle using commonJS require', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/typescript-require/index.ts'), {\n        config\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['index.ts', 'Local.ts', 'esmodule-helpers.js']\n      }]);\n      let output = await run(b);\n      assert.equal(typeof output.count, 'function');\n      assert.equal(output.count(), 3);\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support json require","suites":["typescript"],"updatePoint":{"line":39,"column":35,"index":1725},"line":39,"code":"    it('should support json require', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/typescript-json/index.ts'));\n\n      // assert.equal(b.assets.size, 2);\n      // assert.equal(b.childBundles.size, 1);\n\n      let output = await run(b);\n      assert.equal(typeof output.count, 'function');\n      assert.equal(output.count(), 3);\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support env variables","suites":["typescript"],"updatePoint":{"line":49,"column":36,"index":2098},"line":49,"code":"    it('should support env variables', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/typescript-env/index.ts'), {\n        config\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['index.ts', 'esmodule-helpers.js']\n      }]);\n      let output = await run(b);\n      assert.equal(typeof output.env, 'function');\n      assert.equal(output.env(), 'test');\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing a URL to a raw asset","suites":["typescript"],"updatePoint":{"line":61,"column":53,"index":2533},"line":61,"code":"    it('should support importing a URL to a raw asset', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/typescript-raw/index.ts'), {\n        config\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.ts', 'bundle-url.js', 'esmodule-helpers.js']\n      }, {\n        type: 'txt',\n        assets: ['test.txt']\n      }]);\n      let output = await run(b);\n      assert.equal(typeof output.getRaw, 'function');\n      assert(/http:\\/\\/localhost\\/test\\.[0-9a-f]+\\.txt$/.test(output.getRaw()));\n      assert(await outputFS.exists(path.join(distDir, nullthrows(url.parse(output.getRaw()).pathname))));\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify with minify enabled","suites":["typescript"],"updatePoint":{"line":77,"column":41,"index":3188},"line":77,"code":"    it('should minify with minify enabled', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/typescript-require/index.ts'), {\n        config,\n        defaultTargetOptions: {\n          shouldOptimize: true\n        }\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['index.ts', 'Local.ts', 'esmodule-helpers.js']\n      }]);\n      let output = await run(b);\n      assert.equal(typeof output.count, 'function');\n      assert.equal(output.count(), 3);\n      let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(!js.includes('local.a'));\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX","suites":["typescript"],"updatePoint":{"line":94,"column":36,"index":3814},"line":94,"code":"    it('should support compiling JSX', async function () {\n      await bundle(path.join(__dirname, '/integration/typescript-jsx/index.tsx'), {\n        config\n      });\n      let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(file.includes('React.createElement(\"div\"'));\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should use esModuleInterop by default","suites":["typescript"],"updatePoint":{"line":101,"column":45,"index":4139},"line":101,"code":"    it('should use esModuleInterop by default', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/typescript-interop/index.ts'), {\n        config\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['esmodule-helpers.js', 'index.ts', 'commonjs-module.js']\n      }]);\n      let output = await run(b);\n      assert.equal(typeof output.test, 'function');\n      assert.equal(output.test(), 'test passed');\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"fs.readFileSync should inline a file as a string","suites":["typescript"],"updatePoint":{"line":113,"column":56,"index":4618},"line":113,"code":"    it('fs.readFileSync should inline a file as a string', async function () {\n      if (config != null) {\n        return;\n      }\n      let b = await bundle(path.join(__dirname, '/integration/typescript-fs/index.ts'), {\n        config\n      });\n      const text = 'export default <div>Hello</div>;';\n      let output = await run(b);\n      assert.deepEqual(output, {\n        fromTs: text,\n        fromTsx: text\n      });\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle legacy cast in .ts file","suites":["typescript"],"updatePoint":{"line":127,"column":45,"index":5036},"line":127,"code":"    it('should handle legacy cast in .ts file', async function () {\n      if (config != null) {\n        return;\n      }\n      await bundle(path.join(__dirname, '/integration/typescript-legacy-cast/index.ts'), {\n        config\n      });\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle compile enums correctly","suites":["typescript"],"updatePoint":{"line":135,"column":45,"index":5280},"line":135,"code":"    it('should handle compile enums correctly', async function () {\n      if (config != null) {\n        return;\n      }\n      let b = await bundle(path.join(__dirname, '/integration/typescript-enum/index.ts'), {\n        config\n      });\n      let output = await run(b);\n      assert.deepEqual(output, {\n        A: {\n          X: 'X',\n          Y: 'Y'\n        },\n        B: {\n          X: 'X',\n          Y: 'Y'\n        },\n        C: {\n          X: 'X',\n          Y: 'Y'\n        },\n        z: {\n          a: 'X',\n          c: 'Y'\n        }\n      });\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle simultaneous import type and reexport correctly","suites":["typescript"],"updatePoint":{"line":162,"column":69,"index":5860},"line":162,"code":"    it('should handle simultaneous import type and reexport correctly', async function () {\n      if (config != null) {\n        return;\n      }\n      let b = await bundle(path.join(__dirname, '/integration/typescript-import-type-reexport/index.ts'), {\n        config\n      });\n      let output = await run(b);\n      assert.deepEqual(output, {\n        Bar: 123\n      });\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a basic vue bundle","suites":["vue"],"updatePoint":{"line":5,"column":39,"index":193},"line":5,"code":"  it('should produce a basic vue bundle', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-basic/Basic.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert.deepEqual(output.data(), {\n      msg: 'Hello from Component A!'\n    });\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a vue bundle with dependencies","suites":["vue"],"updatePoint":{"line":13,"column":51,"index":533},"line":13,"code":"  it('should produce a vue bundle with dependencies', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-dependencies/App.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert.deepEqual(output.data(), {\n      msg: 'Welcome to Your Vue.js App!'\n    });\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a vue bundle using preprocessors","suites":["vue"],"updatePoint":{"line":21,"column":53,"index":884},"line":21,"code":"  it('should produce a vue bundle using preprocessors', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-preprocessors/pre-processors.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert.deepEqual(output.data(), {\n      msg: 'Hello from coffee!'\n    });\n    let contents = await outputFS.readFile(path.join(distDir, 'pre-processors.css'), 'utf8');\n    assert(contents.includes('color: #999'));\n    assert(contents.includes('background: red'));\n    assert(contents.includes('color: green'));\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a vue bundle using scoped styles","suites":["vue"],"updatePoint":{"line":33,"column":53,"index":1475},"line":33,"code":"  it('should produce a vue bundle using scoped styles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-scoped/App.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert(/^data-v-[0-9a-h]{6}$/.test(output.__scopeId));\n    assert.deepEqual(output.data(), {\n      ok: true\n    });\n    let contents = await outputFS.readFile(path.join(distDir, 'App.css'), 'utf8');\n    assert(contents.includes(`.test[${output.__scopeId}]`));\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a vue bundle using CSS modules","suites":["vue"],"updatePoint":{"line":44,"column":51,"index":1995},"line":44,"code":"  it('should produce a vue bundle using CSS modules', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-css-modules/App.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    let modules = output.__cssModules;\n    assert.equal(typeof modules.$style.red, 'string');\n    let contents = await outputFS.readFile(path.join(distDir, 'App.css'), 'utf8');\n    assert(contents.includes('.' + modules.$style.red));\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bundle nested components dynamically","suites":["vue"],"updatePoint":{"line":53,"column":49,"index":2488},"line":53,"code":"  it('should bundle nested components dynamically', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-nested-components/testcomp.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert.equal(typeof output.components.InsideComp, 'function');\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should apply custom block preprocessors","suites":["vue"],"updatePoint":{"line":59,"column":45,"index":2821},"line":59,"code":"  it('should apply custom block preprocessors', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-custom-blocks/App.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert.deepEqual(output.data().docs, {\n      standard: '\\nThis component represents the home page of the application.\\n',\n      brief: '\\nHome Page\\n'\n    });\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a basic production vue bundle","suites":["vue"],"updatePoint":{"line":68,"column":50,"index":3246},"line":68,"code":"  it('should produce a basic production vue bundle', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-basic/Basic.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert.deepEqual(output.data(), {\n      msg: 'Hello from Component A!'\n    });\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should load external templates/styles/scripts properly","suites":["vue"],"updatePoint":{"line":76,"column":60,"index":3595},"line":76,"code":"  it('should load external templates/styles/scripts properly', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-external-files/App.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert.deepEqual(output.data(), {\n      msg: 'Hello World'\n    });\n    let contents = await outputFS.readFile(path.join(distDir, 'App.css'), 'utf8');\n    assert(contents.includes('color: #c0ff33'));\n    assert(contents.includes('h2:hover'));\n    assert(contents.includes('.box p'));\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should load <script setup> component files","suites":["vue"],"updatePoint":{"line":88,"column":48,"index":4143},"line":88,"code":"  it('should load <script setup> component files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-script-setup/App.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert.equal(typeof output.setup, 'function');\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should preload a wasm file for a sync require","suites":["wasm","--target="],"updatePoint":{"line":10,"column":55,"index":379},"line":10,"code":"      it('should preload a wasm file for a sync require', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/wasm-sync/index.js'), {\n          target\n        });\n        await assertBundleTree(b, {\n          name: 'index.js',\n          assets: ['index.js', 'bundle-loader.js', 'bundle-url.js', 'wasm-loader.js'],\n          childBundles: [{\n            type: 'wasm',\n            assets: ['add.wasm'],\n            childBundles: []\n          }, {\n            type: 'map'\n          }]\n        });\n        let promise = deferred();\n        await run(b, {\n          output: promise.resolve\n        }, {\n          require: false\n        });\n        assert.equal(await promise, 5);\n      });","file":"wasm.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should load a wasm file asynchronously with dynamic import","suites":["wasm","--target="],"updatePoint":{"line":33,"column":68,"index":1109},"line":33,"code":"      it('should load a wasm file asynchronously with dynamic import', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/wasm-async/index.js'), {\n          target\n        });\n        await assertBundleTree(b, {\n          name: 'index.js',\n          assets: ['index.js', 'bundle-loader.js', 'bundle-url.js', 'wasm-loader.js'],\n          childBundles: [{\n            type: 'wasm',\n            assets: ['add.wasm'],\n            childBundles: []\n          }, {\n            type: 'map'\n          }]\n        });\n        var res = await run(b);\n        assert.equal(await res, 5);\n      });","file":"wasm.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should load a wasm file in parallel with a dynamic JS import","suites":["wasm","--target="],"updatePoint":{"line":51,"column":70,"index":1729},"line":51,"code":"      it('should load a wasm file in parallel with a dynamic JS import', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/wasm-dynamic/index.js'), {\n          target\n        });\n        await assertBundleTree(b, {\n          name: 'index.js',\n          assets: ['index.js', 'bundle-loader.js', 'bundle-url.js', 'js-loader.js', 'wasm-loader.js'],\n          childBundles: [{\n            type: 'js',\n            assets: ['dynamic.js'],\n            childBundles: [{\n              type: 'wasm',\n              assets: ['add.wasm'],\n              childBundles: []\n            }, {\n              type: 'map'\n            }]\n          }, {\n            type: 'map'\n          }]\n        });\n        var res = await run(b);\n        assert.equal(await res, 5);\n      });","file":"wasm.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should rebuild on source file change","suites":["watcher"],"updatePoint":{"line":16,"column":42,"index":616},"line":16,"code":"  it('should rebuild on source file change', async function () {\n    await outputFS.mkdirp(inputDir);\n    await outputFS.writeFile(path.join(inputDir, '/index.js'), 'module.exports = \"hello\"', 'utf8');\n    let b = bundler(path.join(inputDir, '/index.js'), {\n      inputFS: overlayFS\n    });\n    subscription = await b.watch();\n    let buildEvent = await getNextBuild(b);\n    let output = await run(buildEvent.bundleGraph);\n    assert.equal(output, 'hello');\n    await outputFS.writeFile(path.join(inputDir, '/index.js'), 'module.exports = \"something else\"', 'utf8');\n    buildEvent = await getNextBuild(b);\n    output = await run(buildEvent.bundleGraph);\n    assert.equal(output, 'something else');\n  });","file":"watcher.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should rebuild on a source file change after a failed transformation","suites":["watcher"],"updatePoint":{"line":31,"column":74,"index":1353},"line":31,"code":"  it('should rebuild on a source file change after a failed transformation', async () => {\n    await outputFS.mkdirp(inputDir);\n    await outputFS.writeFile(path.join(inputDir, '/index.js'), 'syntax\\\\error', 'utf8');\n    let b = bundler(path.join(inputDir, '/index.js'), {\n      inputFS: overlayFS\n    });\n    subscription = await b.watch();\n    let buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildFailure');\n    await outputFS.writeFile(path.join(inputDir, '/index.js'), 'module.exports = \"hello\"', 'utf8');\n    buildEvent = await getNextBuild(b);\n    let output = await run(buildEvent.bundleGraph);\n    assert.equal(output, 'hello');\n  });","file":"watcher.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should rebuild on a config file change","suites":["watcher"],"updatePoint":{"line":45,"column":44,"index":1993},"line":45,"code":"  it('should rebuild on a config file change', async function () {\n    let inDir = path.join(__dirname, 'integration/parcelrc-custom');\n    let outDir = path.join(inDir, 'dist');\n    await ncp(path.join(__dirname, 'integration/parcelrc-custom'), inDir);\n    await ncp(path.dirname(require.resolve('@parcel/config-default')), path.join(inDir, 'node_modules', '@parcel', 'config-default'));\n    let copyPath = path.join(inDir, 'configCopy');\n    let configPath = path.join(inDir, '.parcelrc');\n    let b = bundler(path.join(inDir, 'index.js'), {\n      inputFS: overlayFS,\n      targets: {\n        main: {\n          distDir: outDir\n        }\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let distFile = await outputFS.readFile(path.join(outDir, 'index.js'), 'utf8');\n    assert(distFile.includes('() => null'));\n    await outputFS.copyFile(copyPath, configPath);\n    await getNextBuild(b);\n    distFile = await outputFS.readFile(path.join(outDir, 'index.js'), 'utf8');\n    assert(distFile.includes('TRANSFORMED CODE'));\n  });","file":"watcher.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should rebuild properly when a dependency is removed","suites":["watcher"],"updatePoint":{"line":69,"column":58,"index":3067},"line":69,"code":"  it('should rebuild properly when a dependency is removed', async function () {\n    await ncp(path.join(__dirname, 'integration/babel-default'), inputDir);\n    let b = bundler(path.join(inputDir, 'index.js'), {\n      inputFS: overlayFS,\n      targets: {\n        main: {\n          engines: {\n            node: '^8.0.0'\n          },\n          distDir\n        }\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let distFile = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(distFile.includes('Foo'));\n    await outputFS.writeFile(path.join(inputDir, 'index.js'), 'console.log(\"no more dependencies\")');\n    await getNextBuild(b);\n    distFile = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!distFile.includes('Foo'));\n  });","file":"watcher.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should re-generate bundle tree when files change","suites":["watcher"],"line":91,"code":"  it.skip('should re-generate bundle tree when files change', async function () {","file":"watcher.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should only re-package bundles that changed","suites":["watcher"],"line":142,"code":"  it.skip('should only re-package bundles that changed', async function () {","file":"watcher.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should unload assets that are orphaned","suites":["watcher"],"line":156,"code":"  it.skip('should unload assets that are orphaned', async function () {","file":"watcher.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should recompile all assets when a config file changes","suites":["watcher"],"line":208,"code":"  it.skip('should recompile all assets when a config file changes', async function () {","file":"watcher.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should rebuild if the file behind a symlink changes","suites":["watcher"],"line":228,"code":"  it.skip('should rebuild if the file behind a symlink changes', async function () {","file":"watcher.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should add and remove necessary runtimes to bundles","suites":["watcher"],"updatePoint":{"line":253,"column":57,"index":9755},"line":253,"code":"  it('should add and remove necessary runtimes to bundles', async () => {\n    await ncp(path.join(__dirname, 'integration/dynamic'), inputDir);\n    let indexPath = path.join(inputDir, 'index.js');\n    let b = bundler(indexPath, {\n      inputFS: overlayFS\n    });\n    let bundleGraph;\n    subscription = await b.watch((err, event) => {\n      assert(event.type === 'buildSuccess');\n      bundleGraph = event.bundleGraph;\n    });\n    await getNextBuild(b);\n    assertBundles(bundleGraph, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['local.js']\n    }]);\n    await outputFS.writeFile(path.join(inputDir, 'other.js'), '');\n    await outputFS.writeFile(indexPath, (await outputFS.readFile(indexPath, 'utf8')) + \"\\nimport('./other.js');\\n\");\n    await getNextBuild(b);\n    assertBundles(bundleGraph, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['local.js']\n    }, {\n      assets: ['other.js']\n    }]);\n    await outputFS.writeFile(indexPath, '');\n    await getNextBuild(b);\n    assertBundles(bundleGraph, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }]);\n  });","file":"watcher.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should rebuild if a missing file is added","suites":["watcher"],"updatePoint":{"line":289,"column":47,"index":10980},"line":289,"code":"  it('should rebuild if a missing file is added', async function () {\n    await outputFS.mkdirp(inputDir);\n    await outputFS.writeFile(path.join(inputDir, '/index.js'), 'import {other} from \"./other\";\\nexport default other;', 'utf8');\n    let b = bundler(path.join(inputDir, 'index.js'), {\n      inputFS: overlayFS\n    });\n    subscription = await b.watch();\n    let buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildFailure');\n    await outputFS.writeFile(path.join(inputDir, '/other.js'), 'export const other = 2;', 'utf8');\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    let res = await run(buildEvent.bundleGraph);\n    assert.equal(res.default, 2);\n  });","file":"watcher.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve a full webextension bundle","suites":["webextension"],"updatePoint":{"line":5,"column":47,"index":220},"line":5,"code":"  it('should resolve a full webextension bundle', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/webextension/manifest.json'));\n    assertBundles(b, [{\n      name: 'tmp.aff',\n      assets: ['tmp.aff']\n    }, {\n      name: 'tmp.dic',\n      assets: ['tmp.dic']\n    }, {\n      name: 'messages.json',\n      assets: ['messages.json']\n    }, {\n      name: 'manifest.json',\n      assets: ['manifest.json']\n    }, {\n      assets: ['background.ts']\n    }, {\n      assets: ['a.txt']\n    }, {\n      assets: ['b.txt']\n    }, {\n      assets: ['foo.png']\n    }, {\n      assets: ['foo-dark.png']\n    }, {\n      assets: ['popup.html']\n    }, {\n      assets: ['devtools.html']\n    }, {\n      assets: ['content.js']\n    }, {\n      assets: ['content.css']\n    }, {\n      assets: ['ruleset_1.json']\n    }]);\n    assert(await outputFS.exists(path.join(distDir, '_locales', 'en_US', 'messages.json')));\n    const manifest = JSON.parse(await outputFS.readFile(b.getBundles().find(b => b.name == 'manifest.json').filePath, 'utf8'));\n    const scripts = manifest.background.scripts;\n    assert.equal(scripts.length, 1);\n    for (const {\n      path: resourcePath\n    } of manifest.declarative_net_request?.rule_resources ?? []) {\n      assert(await outputFS.exists(path.join(distDir, resourcePath)));\n    }\n    assert((await outputFS.readFile(path.join(distDir, scripts[0]), 'utf-8')).includes('Hello Parcel!'));\n  });","file":"webextension.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve the web_accessible_resources globs","suites":["webextension"],"updatePoint":{"line":51,"column":55,"index":1654},"line":51,"code":"  it('should resolve the web_accessible_resources globs', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/webextension-resolve-web-accessible-resources/manifest.json'));\n    assertBundles(b, [{\n      name: 'manifest.json',\n      assets: ['manifest.json']\n    }, {\n      assets: ['index.ts', 'esmodule-helpers.js']\n    }, {\n      assets: ['other.ts', 'esmodule-helpers.js']\n    }, {\n      assets: ['esmodule-helpers.js', 'index-jsx.jsx', 'index.js', 'index.js', 'react.development.js']\n    }, {\n      assets: ['single.js', 'esmodule-helpers.js']\n    }]);\n    const manifest = JSON.parse(await outputFS.readFile(b.getBundles().find(b => b.name == 'manifest.json').filePath, 'utf8'));\n    const war = manifest.web_accessible_resources;\n    assert.equal(war.length, 4);\n  });","file":"webextension.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support web extension manifest v3","suites":["webextension"],"updatePoint":{"line":69,"column":46,"index":2449},"line":69,"code":"  it('should support web extension manifest v3', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/webextension-mv3/manifest.json'));\n    assertBundles(b, [{\n      name: 'manifest.json',\n      assets: ['manifest.json']\n    }, {\n      assets: ['background.js']\n    }, {\n      assets: ['popup.html']\n    }, {\n      assets: ['popup.css']\n    }, {\n      assets: ['popup.js', 'esmodule-helpers.js', 'bundle-url.js']\n    }, {\n      assets: ['content-script.js']\n    }, {\n      assets: ['other-content-script.js']\n    }, {\n      assets: ['injected.css']\n    }]);\n    const manifest = JSON.parse(await outputFS.readFile(path.join(distDir, 'manifest.json'), 'utf-8'));\n    const css = manifest.content_scripts[0].css;\n    assert.equal(css.length, 1);\n    assert((await outputFS.readFile(path.join(distDir, css[0]), 'utf-8')).includes('Comic Sans MS'));\n  });","file":"webextension.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support .webmanifest","suites":["webmanifest"],"updatePoint":{"line":6,"column":33,"index":246},"line":6,"code":"  it('should support .webmanifest', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/webmanifest/index.html'));\n    await assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      name: 'manifest.webmanifest',\n      assets: ['manifest.webmanifest']\n    }, {\n      type: 'png',\n      assets: ['icon.png']\n    }, {\n      type: 'png',\n      assets: ['screenshot.png']\n    }, {\n      type: 'png',\n      assets: ['shortcut-icon.png']\n    }]);\n    const manifest = await outputFS.readFile(b.getBundles().find(b => b.type === 'webmanifest').filePath, 'utf8');\n    assert(/screenshot\\.[0-9a-f]+\\.png/.test(manifest));\n    assert(/icon\\.[0-9a-f]+\\.png/.test(manifest));\n    assert(/shortcut-icon\\.[0-9a-f]+\\.png/.test(manifest));\n  });","file":"webmanifest.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support .json","suites":["webmanifest"],"updatePoint":{"line":29,"column":26,"index":1029},"line":29,"code":"  it('should support .json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/webmanifest-json/index.html'));\n    await assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      name: 'manifest.webmanifest',\n      assets: ['manifest.json']\n    }, {\n      type: 'png',\n      assets: ['icon.png']\n    }, {\n      type: 'png',\n      assets: ['screenshot.png']\n    }, {\n      type: 'png',\n      assets: ['shortcut-icon.png']\n    }]);\n    const manifest = await outputFS.readFile(b.getBundles().find(b => b.type === 'webmanifest').filePath, 'utf8');\n    assert(/screenshot\\.[0-9a-f]+\\.png/.test(manifest));\n    assert(/icon\\.[0-9a-f]+\\.png/.test(manifest));\n    assert(/shortcut-icon\\.[0-9a-f]+\\.png/.test(manifest));\n  });","file":"webmanifest.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw on malformed icons and screenshots","suites":["webmanifest"],"updatePoint":{"line":52,"column":53,"index":1837},"line":52,"code":"  it('should throw on malformed icons and screenshots', async function () {\n    let manifestPath = path.join(__dirname, '/integration/webmanifest-schema/manifest.webmanifest');\n    let manifest = await inputFS.readFileSync(manifestPath, 'utf8');\n    await assert.rejects(() => bundle(path.join(__dirname, '/integration/webmanifest-schema/index.html')), {\n      name: 'BuildError',\n      message: path.normalize('Invalid webmanifest'),\n      diagnostics: [{\n        codeFrames: [{\n          filePath: manifestPath,\n          language: 'json',\n          code: manifest,\n          codeHighlights: [{\n            end: {\n              column: 5,\n              line: 12\n            },\n            message: 'Missing property src',\n            start: {\n              column: 5,\n              line: 9\n            }\n          }, {\n            end: {\n              column: 6,\n              line: 13\n            },\n            message: 'Missing property src',\n            start: {\n              column: 5,\n              line: 13\n            }\n          }, {\n            end: {\n              column: 19,\n              line: 15\n            },\n            message: 'Expected type array',\n            start: {\n              column: 18,\n              line: 15\n            }\n          }, {\n            end: {\n              column: 17,\n              line: 18\n            },\n            message: 'Expected type array',\n            start: {\n              column: 16,\n              line: 18\n            }\n          }, {\n            end: {\n              column: 9,\n              line: 30\n            },\n            message: 'Missing property src',\n            start: {\n              column: 9,\n              line: 27\n            }\n          }, {\n            end: {\n              column: 10,\n              line: 31\n            },\n            message: 'Missing property src',\n            start: {\n              column: 9,\n              line: 31\n            }\n          }]\n        }],\n        message: 'Invalid webmanifest',\n        origin: '@parcel/transformer-webmanifest'\n      }]\n    });\n  });","file":"webmanifest.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw on missing dependency","suites":["webmanifest"],"updatePoint":{"line":130,"column":40,"index":3896},"line":130,"code":"  it('should throw on missing dependency', async function () {\n    let manifestPathRelative = './integration/webmanifest-not-found/manifest.webmanifest';\n    let manifestPath = path.join(__dirname, manifestPathRelative);\n    let manifest = await inputFS.readFileSync(manifestPath, 'utf8');\n    let message = md`Failed to resolve 'icon.png' from '${manifestPathRelative}'`;\n    await assert.rejects(() => bundle(path.join(__dirname, '/integration/webmanifest-not-found/index.html')), {\n      name: 'BuildError',\n      message,\n      diagnostics: [{\n        codeFrames: [{\n          filePath: manifestPath,\n          code: manifest,\n          codeHighlights: [{\n            end: {\n              column: 23,\n              line: 5\n            },\n            start: {\n              column: 14,\n              line: 5\n            }\n          }]\n        }],\n        message,\n        origin: '@parcel/core'\n      }, {\n        hints: [],\n        message: `Cannot load file './icon.png' in '${path.dirname(manifestPathRelative)}'.`,\n        origin: '@parcel/resolver-default'\n      }]\n    });\n  });","file":"webmanifest.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work when there is a target in package.json","suites":["webmanifest"],"updatePoint":{"line":162,"column":56,"index":5000},"line":162,"code":"  it('should work when there is a target in package.json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/webmanifest-targets/index.html'));\n    await assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      name: 'manifest.webmanifest',\n      assets: ['manifest.json']\n    }]);\n  });","file":"webmanifest.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should transform an atom feed","suites":["xml"],"updatePoint":{"line":5,"column":35,"index":190},"line":5,"code":"  it('should transform an atom feed', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/xml/atom.xml'), {\n      defaultTargetOptions: {\n        publicUrl: 'http://example.org/'\n      }\n    });\n    assertBundles(b, [{\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'xhtml',\n      assets: ['atom.xml']\n    }, {\n      name: 'post.html',\n      assets: ['post.html']\n    }, {\n      name: 'atom.xml',\n      assets: ['atom.xml']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes(`<img src=\"http://example.org/${path.basename(b.getBundles().find(b => b.type === 'png').filePath)}\"/>`));\n    assert(contents.includes(`<link href=\"http://example.org/post.html\"/>`));\n  });","file":"xml.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should transform an atom feed with namespaced elements","suites":["xml"],"updatePoint":{"line":28,"column":60,"index":999},"line":28,"code":"  it('should transform an atom feed with namespaced elements', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/xml/atom-namespace.xml'), {\n      defaultTargetOptions: {\n        publicUrl: 'http://example.org/'\n      }\n    });\n    assertBundles(b, [{\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'xhtml',\n      assets: ['atom-namespace.xml']\n    }, {\n      name: 'post.html',\n      assets: ['post.html']\n    }, {\n      name: 'atom-namespace.xml',\n      assets: ['atom-namespace.xml']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes(`<img src=\"http://example.org/${path.basename(b.getBundles().find(b => b.type === 'png').filePath)}\"/>`));\n    assert(contents.includes(`<atom:link href=\"http://example.org/post.html\"/>`));\n  });","file":"xml.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should transform an rss feed","suites":["xml"],"updatePoint":{"line":51,"column":34,"index":1827},"line":51,"code":"  it('should transform an rss feed', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/xml/rss.xml'), {\n      defaultTargetOptions: {\n        publicUrl: 'http://example.org/'\n      }\n    });\n    assertBundles(b, [{\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'html',\n      assets: ['rss.xml']\n    }, {\n      type: 'html',\n      assets: ['rss.xml']\n    }, {\n      name: 'post.html',\n      assets: ['post.html']\n    }, {\n      name: 'rss.xml',\n      assets: ['rss.xml']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes(`&lt;img src=\"http://example.org/${path.basename(b.getBundles().find(b => b.type === 'png').filePath)}\">`));\n    assert(contents.includes(`<link>http://example.org/post.html</link>`));\n  });","file":"xml.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"emits log diagnostics with info level","suites":["Logger"],"updatePoint":{"line":14,"column":43,"index":345},"line":14,"code":"  it('emits log diagnostics with info level', () => {\n    let diagnostic = {\n      message: 'hello',\n      origin: 'logger'\n    };\n    Logger.log(diagnostic);\n    assert(onLog.calledWith({\n      level: 'info',\n      diagnostics: [diagnostic],\n      type: 'log'\n    }));\n  });","file":"Logger.test.js","skipped":false,"dir":"packages/core/logger/test"},{"name":"emits warn diagnostic with warn level","suites":["Logger"],"updatePoint":{"line":26,"column":43,"index":621},"line":26,"code":"  it('emits warn diagnostic with warn level', () => {\n    let diagnostic = {\n      message: 'zomg',\n      origin: 'logger'\n    };\n    Logger.warn(diagnostic);\n    assert(onLog.calledWith({\n      level: 'warn',\n      diagnostics: [diagnostic],\n      type: 'log'\n    }));\n  });","file":"Logger.test.js","skipped":false,"dir":"packages/core/logger/test"},{"name":"emits error messages with error level","suites":["Logger"],"updatePoint":{"line":38,"column":43,"index":897},"line":38,"code":"  it('emits error messages with error level', () => {\n    let diagnostic = {\n      message: 'oh noes',\n      origin: 'logger'\n    };\n    Logger.error(diagnostic);\n    assert(onLog.calledWith({\n      level: 'error',\n      diagnostics: [diagnostic],\n      type: 'log'\n    }));\n  });","file":"Logger.test.js","skipped":false,"dir":"packages/core/logger/test"},{"name":"emits progress messages with progress level","suites":["Logger"],"updatePoint":{"line":50,"column":49,"index":1184},"line":50,"code":"  it('emits progress messages with progress level', () => {\n    Logger.progress('update');\n    assert(onLog.calledWith({\n      level: 'progress',\n      message: 'update',\n      type: 'log'\n    }));\n  });","file":"Logger.test.js","skipped":false,"dir":"packages/core/logger/test"},{"name":"should support asteriks for bold and italic","suites":["markdown-ansi"],"updatePoint":{"line":7,"column":49,"index":248},"line":7,"code":"  it('should support asteriks for bold and italic', () => {\n    let res = mdAnsi('**bold** *italic*');\n    assert.equal(res, '\\u001b[1mbold\\u001b[22m \\u001b[3mitalic\\u001b[23m');\n  });","file":"markdown-ansi.js","skipped":false,"dir":"packages/core/markdown-ansi/test"},{"name":"should support underscores for underlined and italic","suites":["markdown-ansi"],"updatePoint":{"line":11,"column":58,"index":442},"line":11,"code":"  it('should support underscores for underlined and italic', () => {\n    let res = mdAnsi('__underline__ _italic_');\n    assert.equal(res, '\\u001b[4munderline\\u001b[24m \\u001b[3mitalic\\u001b[23m');\n  });","file":"markdown-ansi.js","skipped":false,"dir":"packages/core/markdown-ansi/test"},{"name":"should support combination of bold and underline","suites":["markdown-ansi"],"updatePoint":{"line":15,"column":54,"index":642},"line":15,"code":"  it('should support combination of bold and underline', () => {\n    let res = mdAnsi('**bold _italic_**');\n    assert.equal(res, '\\u001b[1mbold \\u001b[3mitalic\\u001b[23m\\u001b[22m');\n  });","file":"markdown-ansi.js","skipped":false,"dir":"packages/core/markdown-ansi/test"},{"name":"should support strikethrough","suites":["markdown-ansi"],"updatePoint":{"line":19,"column":34,"index":812},"line":19,"code":"  it('should support strikethrough', () => {\n    let res = mdAnsi('~~strikethrough~~');\n    assert.equal(res, '\\u001b[9mstrikethrough\\u001b[29m');\n  });","file":"markdown-ansi.js","skipped":false,"dir":"packages/core/markdown-ansi/test"},{"name":"should support escape character","suites":["markdown-ansi"],"updatePoint":{"line":23,"column":37,"index":968},"line":23,"code":"  it('should support escape character', () => {\n    let res = mdAnsi('\\\\*\\\\*bold\\\\*\\\\* \\\\\\\\escape\\\\\\\\');\n    assert.equal(res, '**bold** \\\\escape\\\\');\n  });","file":"markdown-ansi.js","skipped":false,"dir":"packages/core/markdown-ansi/test"},{"name":"should support italic with escape character","suites":["markdown-ansi"],"updatePoint":{"line":27,"column":49,"index":1137},"line":27,"code":"  it('should support italic with escape character', () => {\n    let res = mdAnsi('\\\\__italic_\\\\_');\n    assert.equal(res, '_\\u001b[3mitalic\\u001b[23m_');\n  });","file":"markdown-ansi.js","skipped":false,"dir":"packages/core/markdown-ansi/test"},{"name":"resolves packages that exist","suites":["NodePackageManager"],"updatePoint":{"line":31,"column":34,"index":1057},"line":31,"code":"  it('resolves packages that exist', async () => {\n    assert.deepEqual(await packageManager.resolve('foo', path.join(FIXTURES_DIR, 'has-foo/index.js')), {\n      pkg: {\n        version: '1.1.0'\n      },\n      resolved: path.join(FIXTURES_DIR, 'has-foo/node_modules/foo/index.js'),\n      invalidateOnFileChange: new Set([path.join(FIXTURES_DIR, 'has-foo/node_modules/foo/package.json')]),\n      invalidateOnFileCreate: [{\n        fileName: 'node_modules/foo',\n        aboveFilePath: path.join(FIXTURES_DIR, 'has-foo')\n      }]\n    });\n  });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"requires packages that exist","suites":["NodePackageManager"],"updatePoint":{"line":44,"column":34,"index":1597},"line":44,"code":"  it('requires packages that exist', async () => {\n    assert.deepEqual(await packageManager.require('foo', path.join(FIXTURES_DIR, 'has-foo/index.js')), 'foobar');\n  });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"autoinstalls packages that don't exist","suites":["NodePackageManager"],"updatePoint":{"line":47,"column":44,"index":1778},"line":47,"code":"  it(\"autoinstalls packages that don't exist\", async () => {\n    packageInstaller.register('a', fs, path.join(FIXTURES_DIR, 'packages/a'));\n    assert.deepEqual(await packageManager.resolve('a', path.join(FIXTURES_DIR, 'has-foo/index.js'), {\n      shouldAutoInstall: true\n    }), {\n      pkg: {\n        name: 'a'\n      },\n      resolved: path.join(FIXTURES_DIR, 'has-foo/node_modules/a/index.js'),\n      invalidateOnFileChange: new Set([path.join(FIXTURES_DIR, 'has-foo/node_modules/a/package.json')]),\n      invalidateOnFileCreate: [{\n        fileName: 'node_modules/a',\n        aboveFilePath: path.join(FIXTURES_DIR, 'has-foo')\n      }]\n    });\n  });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"does not autoinstall packages that are already listed in package.json","suites":["NodePackageManager"],"updatePoint":{"line":63,"column":75,"index":2462},"line":63,"code":"  it('does not autoinstall packages that are already listed in package.json', async () => {\n    packageInstaller.register('a', fs, path.join(FIXTURES_DIR, 'packages/a'));\n\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => packageManager.resolve('a', path.join(FIXTURES_DIR, 'has-a-not-yet-installed/index.js'), {\n      shouldAutoInstall: true\n    }), err => {\n      invariant(err instanceof ThrowableDiagnostic);\n      assert(err.message.includes('Run your package manager'));\n      return true;\n    });\n  });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"does not autoinstall peer dependencies that are already listed in package.json","suites":["NodePackageManager"],"updatePoint":{"line":75,"column":84,"index":3007},"line":75,"code":"  it('does not autoinstall peer dependencies that are already listed in package.json', async () => {\n    packageInstaller.register('peers', fs, path.join(FIXTURES_DIR, 'packages/peers'));\n    let spy = sinon.spy(packageInstaller, 'install');\n    await packageManager.resolve('peers', path.join(FIXTURES_DIR, 'has-foo/index.js'), {\n      shouldAutoInstall: true\n    });\n    assert.deepEqual(spy.args, [[{\n      cwd: path.join(FIXTURES_DIR, 'has-foo'),\n      packagePath: path.join(FIXTURES_DIR, 'has-foo/package.json'),\n      fs,\n      saveDev: true,\n      modules: [{\n        name: 'peers',\n        range: undefined\n      }]\n    }]]);\n  });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"autoinstalls peer dependencies that are not listed in package.json","suites":["NodePackageManager"],"updatePoint":{"line":92,"column":72,"index":3636},"line":92,"code":"  it('autoinstalls peer dependencies that are not listed in package.json', async () => {\n    packageInstaller.register('foo', fs, path.join(FIXTURES_DIR, 'packages/foo-2.0'));\n    packageInstaller.register('peers', fs, path.join(FIXTURES_DIR, 'packages/peers-2.0'));\n    let spy = sinon.spy(packageInstaller, 'install');\n    await packageManager.resolve('peers', path.join(FIXTURES_DIR, 'empty/index.js'), {\n      shouldAutoInstall: true\n    });\n    assert.deepEqual(spy.args, [[{\n      cwd: path.join(FIXTURES_DIR, 'empty'),\n      packagePath: path.join(FIXTURES_DIR, 'empty/package.json'),\n      fs,\n      saveDev: true,\n      modules: [{\n        name: 'peers',\n        range: undefined\n      }]\n    }], [{\n      cwd: path.join(FIXTURES_DIR, 'empty'),\n      packagePath: path.join(FIXTURES_DIR, 'empty/package.json'),\n      fs,\n      saveDev: true,\n      modules: [{\n        name: 'foo',\n        range: '^2.0.0'\n      }]\n    }]]);\n  });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"cannot autoinstall if there's a local requirement","suites":["NodePackageManager","range mismatch"],"updatePoint":{"line":120,"column":57,"index":4597},"line":120,"code":"    it(\"cannot autoinstall if there's a local requirement\", async () => {\n      packageManager.invalidate('foo', path.join(FIXTURES_DIR, 'has-foo/index.js'));\n\n      // $FlowFixMe assert.rejects is Node 10+\n      await assert.rejects(() => packageManager.resolve('foo', path.join(FIXTURES_DIR, 'has-foo/index.js'), {\n        range: '^2.0.0'\n      }), err => {\n        invariant(err instanceof ThrowableDiagnostic);\n        assert.equal(err.message, 'Could not find module \"foo\" satisfying ^2.0.0.');\n        return true;\n      });\n    });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"can autoinstall into local package if there isn't a local requirement","suites":["NodePackageManager","range mismatch"],"updatePoint":{"line":132,"column":77,"index":5156},"line":132,"code":"    it(\"can autoinstall into local package if there isn't a local requirement\", async () => {\n      packageInstaller.register('foo', fs, path.join(FIXTURES_DIR, 'packages/foo-2.0'));\n      let spy = sinon.spy(packageInstaller, 'install');\n      assert.deepEqual(await packageManager.resolve('foo', path.join(FIXTURES_DIR, 'has-foo/subpackage/index.js'), {\n        range: '^2.0.0',\n        shouldAutoInstall: true\n      }), {\n        pkg: {\n          name: 'foo',\n          version: '2.0.0'\n        },\n        resolved: path.join(FIXTURES_DIR, 'has-foo/subpackage/node_modules/foo/index.js'),\n        invalidateOnFileChange: new Set([path.join(FIXTURES_DIR, 'has-foo/subpackage/node_modules/foo/package.json')]),\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/foo',\n          aboveFilePath: path.join(FIXTURES_DIR, 'has-foo/subpackage')\n        }]\n      });\n      assert.deepEqual(spy.args, [[{\n        cwd: path.join(FIXTURES_DIR, 'has-foo/subpackage'),\n        packagePath: path.join(FIXTURES_DIR, 'has-foo/subpackage/package.json'),\n        fs,\n        saveDev: true,\n        modules: [{\n          name: 'foo',\n          range: '^2.0.0'\n        }]\n      }]]);\n    });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"cannot autoinstall peer dependencies if there's an incompatible local requirement","suites":["NodePackageManager","range mismatch"],"updatePoint":{"line":161,"column":89,"index":6360},"line":161,"code":"    it(\"cannot autoinstall peer dependencies if there's an incompatible local requirement\", async () => {\n      packageManager.invalidate('peers', path.join(FIXTURES_DIR, 'has-foo/index.js'));\n      packageInstaller.register('foo', fs, path.join(FIXTURES_DIR, 'packages/foo-2.0'));\n      packageInstaller.register('peers', fs, path.join(FIXTURES_DIR, 'packages/peers-2.0'));\n\n      // $FlowFixMe assert.rejects is Node 10+\n      await assert.rejects(() => packageManager.resolve('peers', path.join(FIXTURES_DIR, 'has-foo/index.js'), {\n        range: '^2.0.0',\n        shouldAutoInstall: true\n      }), err => {\n        assert(err instanceof ThrowableDiagnostic);\n        assert.equal(err.message, 'Could not install the peer dependency \"foo\" for \"peers\", installed version 1.1.0 is incompatible with ^2.0.0');\n        return true;\n      });\n    });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"Validate Module Specifiers","suites":["Validate Module Specifiers"],"updatePoint":{"line":4,"column":32,"index":179},"line":4,"code":"  it('Validate Module Specifiers', () => {\n    let modules = ['@parcel/transformer-posthtml/package.json', '@some-org/package@v1.0.0', '@org/some-package@v1.0.0-alpha.1', 'something.js/something/index.js', '@some.org/something.js/index.js', 'lodash/something/index.js'];\n    assert.deepEqual(modules.map(module => validateModuleSpecifier(module)), ['@parcel/transformer-posthtml', '@some-org/package@v1.0.0', '@org/some-package@v1.0.0-alpha.1', 'something.js', '@some.org/something.js', 'lodash']);\n  });","file":"validateModuleSpecifiers.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"Return empty on invalid modules","suites":["Validate Module Specifiers"],"updatePoint":{"line":8,"column":37,"index":689},"line":8,"code":"  it('Return empty on invalid modules', () => {\n    let modules = ['./somewhere.js', './hello/world.js', '~/hello/world.js'];\n    assert.deepEqual(modules.map(module => validateModuleSpecifier(module)), ['', '', '']);\n  });","file":"validateModuleSpecifiers.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"cloneEmpty should return an empty set","suites":["BitSet"],"updatePoint":{"line":12,"column":43,"index":486},"line":12,"code":"  it('cloneEmpty should return an empty set', () => {\n    let set1 = BitSet.from([1, 2, 3, 4, 5]);\n    set1.add(1);\n    set1.add(3);\n    let set2 = set1.cloneEmpty();\n    assertValues(set2, []);\n  });","file":"BitSet.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"clone should return a set with the same values","suites":["BitSet"],"updatePoint":{"line":19,"column":52,"index":696},"line":19,"code":"  it('clone should return a set with the same values', () => {\n    let set1 = BitSet.from([1, 2, 3, 4, 5]);\n    set1.add(1);\n    set1.add(3);\n    let set2 = set1.clone();\n    assertValues(set2, [1, 3]);\n  });","file":"BitSet.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"clear should remove all values from the set","suites":["BitSet"],"updatePoint":{"line":26,"column":49,"index":902},"line":26,"code":"  it('clear should remove all values from the set', () => {\n    let set1 = BitSet.from([1, 2, 3, 4, 5]);\n    set1.add(1);\n    set1.add(3);\n    set1.clear();\n    assertValues(set1, []);\n  });","file":"BitSet.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"delete should remove values from the set","suites":["BitSet"],"updatePoint":{"line":33,"column":46,"index":1090},"line":33,"code":"  it('delete should remove values from the set', () => {\n    let set1 = BitSet.from([1, 2, 3, 4, 5]);\n    set1.add(1);\n    set1.add(3);\n    set1.add(5);\n    set1.delete(3);\n    assertValues(set1, [1, 5]);\n  });","file":"BitSet.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should intersect with another BitSet","suites":["BitSet"],"updatePoint":{"line":41,"column":42,"index":1297},"line":41,"code":"  it('should intersect with another BitSet', () => {\n    let set1 = BitSet.from([1, 2, 3, 4, 5]);\n    set1.add(1);\n    set1.add(3);\n    let set2 = set1.cloneEmpty();\n    set2.add(3);\n    set2.add(5);\n    set1.intersect(set2);\n    assertValues(set1, [3]);\n  });","file":"BitSet.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should union with another BitSet","suites":["BitSet"],"updatePoint":{"line":51,"column":38,"index":1554},"line":51,"code":"  it('should union with another BitSet', () => {\n    let set1 = BitSet.from([1, 2, 3, 4, 5]);\n    set1.add(1);\n    set1.add(3);\n    let set2 = set1.cloneEmpty();\n    set2.add(3);\n    set2.add(5);\n    set1.union(set2);\n    assertValues(set1, [1, 3, 5]);\n  });","file":"BitSet.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"BitSet.union should create a new BitSet with the union","suites":["BitSet"],"updatePoint":{"line":61,"column":60,"index":1835},"line":61,"code":"  it('BitSet.union should create a new BitSet with the union', () => {\n    let set1 = BitSet.from([1, 2, 3, 4, 5]);\n    set1.add(1);\n    set1.add(3);\n    let set2 = set1.cloneEmpty();\n    set2.add(3);\n    set2.add(5);\n    let set3 = BitSet.union(set1, set2);\n    assertValues(set1, [1, 3]);\n    assertValues(set2, [3, 5]);\n    assertValues(set3, [1, 3, 5]);\n  });","file":"BitSet.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"returns an array of all values","suites":["BitSet"],"updatePoint":{"line":73,"column":36,"index":2175},"line":73,"code":"  it('returns an array of all values', () => {\n    let set = BitSet.from([1, 2, 3, 4]);\n    set.add(1);\n    set.add(3);\n    assertValues(set, [3, 1]);\n  });","file":"BitSet.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should return an error if a new item is added","suites":["BitSet"],"updatePoint":{"line":79,"column":51,"index":2347},"line":79,"code":"  it('should return an error if a new item is added', () => {\n    let set = BitSet.from([1, 2, 3, 4]);\n    assert.throws(() => set.add(5), /Item is missing from BitSet/);\n  });","file":"BitSet.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"returns a sorted list of key/value tuples","suites":["objectSortedEntries"],"updatePoint":{"line":4,"column":47,"index":214},"line":4,"code":"  it('returns a sorted list of key/value tuples', () => {\n    assert.deepEqual(objectSortedEntries({\n      foo: 'foo',\n      baz: 'baz',\n      bar: 'bar'\n    }), [['bar', 'bar'], ['baz', 'baz'], ['foo', 'foo']]);\n  });","file":"collection.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"returns a deeply sorted list of key/value tuples","suites":["objectSortedEntriesDeep"],"updatePoint":{"line":13,"column":54,"index":488},"line":13,"code":"  it('returns a deeply sorted list of key/value tuples', () => {\n    assert.deepEqual(objectSortedEntriesDeep({\n      foo: 'foo',\n      baz: ['d', 'c'],\n      bar: {\n        g: 'g',\n        b: 'b'\n      }\n    }), [['bar', [['b', 'b'], ['g', 'g']]], ['baz', ['d', 'c']], ['foo', 'foo']]);\n  });","file":"collection.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"returns a setDifference of two sets of T type","suites":["setDifference"],"updatePoint":{"line":25,"column":51,"index":817},"line":25,"code":"  it('returns a setDifference of two sets of T type', () => {\n    assert.deepEqual(setDifference(new Set([1, 2, 3]), new Set([3, 4, 5])), new Set([1, 2, 4, 5]));\n  });","file":"collection.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"load config with json","suites":["loadConfig"],"updatePoint":{"line":6,"column":27,"index":209},"line":6,"code":"  it('load config with json', async () => {\n    assert.deepEqual((await loadConfig(fs, path.join(__dirname, './input/config/config.json'), ['config.json'], path.join(__dirname, './input/config/')))?.config, {\n      hoge: 'fuga'\n    });\n  });","file":"config.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should throw error with empty string json","suites":["loadConfig"],"updatePoint":{"line":11,"column":47,"index":471},"line":11,"code":"  it('should throw error with empty string json', async () => {\n    // $FlowFixMe[prop-missing]\n    await assert.rejects(async () => {\n      await loadConfig(fs, path.join(__dirname, './input/config/empty.json'), ['empty.json'], path.join(__dirname, './input/config/'));\n    });\n  });","file":"config.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should load with empty string config toml","suites":["loadConfig"],"updatePoint":{"line":17,"column":47,"index":756},"line":17,"code":"  it('should load with empty string config toml', async () => {\n    assert.deepEqual((await loadConfig(fs, path.join(__dirname, './input/config/empty.toml'), ['empty.toml'], path.join(__dirname, './input/config/')))?.config, {});\n  });","file":"config.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should load with js","suites":["loadConfig"],"updatePoint":{"line":20,"column":25,"index":970},"line":20,"code":"  it('should load with js', async () => {\n    assert.deepEqual((await loadConfig(fs, path.join(__dirname, './input/config/config.js'), ['config.js'], path.join(__dirname, './input/config/')))?.config, {\n      hoge: 'fuga'\n    });\n  });","file":"config.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should load with cjs","suites":["loadConfig"],"updatePoint":{"line":25,"column":26,"index":1207},"line":25,"code":"  it('should load with cjs', async () => {\n    assert.deepEqual((await loadConfig(fs, path.join(__dirname, './input/config/config.cjs'), ['config.cjs'], path.join(__dirname, './input/config/')))?.config, {\n      hoge: 'fuga'\n    });\n  });","file":"config.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should load without an extension as json","suites":["loadConfig"],"updatePoint":{"line":30,"column":46,"index":1466},"line":30,"code":"  it('should load without an extension as json', async () => {\n    assert.deepEqual((await loadConfig(fs, path.join(__dirname, './input/config/.testrc'), ['.testrc'], path.join(__dirname, './input/config/')))?.config, {\n      hoge: 'fuga'\n    });\n  });","file":"config.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"constructs with entries just like Map","suites":["DefaultMap"],"updatePoint":{"line":4,"column":43,"index":152},"line":4,"code":"  it('constructs with entries just like Map', () => {\n    let map = new DefaultMap(k => k, [[1, 3], [2, 27]]);\n    assert.equal(map.get(1), 3);\n    assert.deepEqual(Array.from(map.entries()), [[1, 3], [2, 27]]);\n  });","file":"DefaultMap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"returns a default value based on a key if it doesn't exist","suites":["DefaultMap"],"updatePoint":{"line":9,"column":64,"index":391},"line":9,"code":"  it(\"returns a default value based on a key if it doesn't exist\", () => {\n    let map = new DefaultMap(k => k);\n    assert.equal(map.get(3), 3);\n  });","file":"DefaultMap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"sets a default value based on a key if it doesn't exist","suites":["DefaultMap"],"updatePoint":{"line":13,"column":61,"index":540},"line":13,"code":"  it(\"sets a default value based on a key if it doesn't exist\", () => {\n    let map = new DefaultMap(k => k);\n    map.get(3);\n    assert.deepEqual(Array.from(map.entries()), [[3, 3]]);\n  });","file":"DefaultMap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"respects undefined/null if it already existed in the map","suites":["DefaultMap"],"updatePoint":{"line":18,"column":62,"index":732},"line":18,"code":"  it('respects undefined/null if it already existed in the map', () => {\n    let map = new DefaultMap(k => k);\n    map.set(3, undefined);\n    assert.equal(map.get(3), undefined);\n    map.set(4, null);\n    assert.equal(map.get(4), null);\n  });","file":"DefaultMap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"calculates the same hash for two different but deep equal objects","suites":["objectHash"],"updatePoint":{"line":4,"column":71,"index":176},"line":4,"code":"  it('calculates the same hash for two different but deep equal objects', () => {\n    const obj1 = {\n      foo: {\n        foo: 'foo',\n        baz: ['foo', 'baz', 'bar'],\n        bar: 'bar'\n      },\n      baz: 'baz',\n      bar: 'bar'\n    };\n    const obj2 = {\n      foo: {\n        foo: 'foo',\n        baz: ['foo', 'baz', 'bar'],\n        bar: 'bar'\n      },\n      baz: 'baz',\n      bar: 'bar'\n    };\n    assert.equal(objectHash(obj1), objectHash(obj2));\n  });","file":"objectHash.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"calculates a unique hash for two deep equal objects","suites":["objectHash"],"updatePoint":{"line":25,"column":57,"index":620},"line":25,"code":"  it('calculates a unique hash for two deep equal objects', () => {\n    const obj1 = {\n      baz: 'baz',\n      bar: 'ba'\n    };\n    const obj2 = {\n      baz: 'baz',\n      bar: 'bar'\n    };\n    assert.notEqual(objectHash(obj1), objectHash(obj2));\n  });","file":"objectHash.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should format numbers less than 1000 as ms","suites":["prettifyTime"],"updatePoint":{"line":4,"column":48,"index":159},"line":4,"code":"  it('should format numbers less than 1000 as ms', () => {\n    assert.equal(prettifyTime(888), '888ms');\n    assert.equal(prettifyTime(50), '50ms');\n    assert.equal(prettifyTime(0), '0ms');\n  });","file":"prettifyTime.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should format numbers greater than 1000 as s with 2 fractional digits","suites":["prettifyTime"],"updatePoint":{"line":9,"column":75,"index":383},"line":9,"code":"  it('should format numbers greater than 1000 as s with 2 fractional digits', () => {\n    assert.equal(prettifyTime(4000), '4.00s');\n    assert.equal(prettifyTime(90000), '90.00s');\n    assert.equal(prettifyTime(45678), '45.68s');\n  });","file":"prettifyTime.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"run() should resolve when all async functions in queue have completed","suites":["PromiseQueue"],"updatePoint":{"line":5,"column":75,"index":222},"line":5,"code":"  it('run() should resolve when all async functions in queue have completed', async () => {\n    let queue = new PromiseQueue();\n    let someBooleanToBeChanged = false;\n    queue.add(() => Promise.resolve().then(() => {\n      someBooleanToBeChanged = true;\n    }));\n    await queue.run();\n    assert(someBooleanToBeChanged);\n  });","file":"PromiseQueue.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"run() should reject if any of the async functions in the queue failed","suites":["PromiseQueue"],"updatePoint":{"line":14,"column":75,"index":552},"line":14,"code":"  it('run() should reject if any of the async functions in the queue failed', async () => {\n    let error = new Error('some failure');\n    try {\n      let queue = new PromiseQueue();\n      queue.add(() => Promise.reject(error)).catch( /* catch this to prevent an unhandled promise rejection*/() => {});\n      await queue.run();\n    } catch (e) {\n      assert.equal(e, error);\n    }\n  });","file":"PromiseQueue.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":".run() should instantly resolve when the queue is empty","suites":["PromiseQueue"],"updatePoint":{"line":24,"column":61,"index":926},"line":24,"code":"  it('.run() should instantly resolve when the queue is empty', async () => {\n    let queue = new PromiseQueue();\n    await queue.run();\n    // no need to assert, test will hang or throw an error if condition fails\n  });","file":"PromiseQueue.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":".add() should resolve with the same result when the passed in function's promise resolves","suites":["PromiseQueue"],"updatePoint":{"line":30,"column":95,"index":1182},"line":30,"code":"  it(\".add() should resolve with the same result when the passed in function's promise resolves\", async () => {\n    let queue = new PromiseQueue();\n    let promise = queue.add(() => Promise.resolve(42));\n    await queue.run();\n    let result = await promise;\n    assert.equal(result, 42);\n  });","file":"PromiseQueue.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":".add() should reject with the same error when the passed in function's promise rejects","suites":["PromiseQueue"],"updatePoint":{"line":37,"column":92,"index":1474},"line":37,"code":"  it(\".add() should reject with the same error when the passed in function's promise rejects\", async () => {\n    let queue = new PromiseQueue();\n    let error = new Error('Oh no!');\n    let promise = queue.add(() => Promise.reject(error));\n    await queue.run().catch(() => null);\n    await promise.then(null, e => assert.equal(e, error));\n  });","file":"PromiseQueue.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"constructor() should allow for configuration of max concurrent running functions","suites":["PromiseQueue"],"updatePoint":{"line":44,"column":86,"index":1814},"line":44,"code":"  it('constructor() should allow for configuration of max concurrent running functions', async () => {\n    const maxConcurrent = 5;\n    const queue = new PromiseQueue({\n      maxConcurrent\n    });\n    let running = 0;\n    new Array(100).fill(0).map(() => queue.add(async () => {\n      running++;\n      assert(queue._numRunning === running);\n      assert(running <= maxConcurrent);\n      await Promise.resolve(randomInt(1, 10)); //sleep(randomInt(1, 10));\n      running--;\n    }));\n    await queue.run();\n  });","file":"PromiseQueue.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Query params and named pipeline, relative","suites":["replace bundle references"],"updatePoint":{"line":4,"column":47,"index":191},"line":4,"code":"  it('Query params and named pipeline, relative', () => {\n    // $FlowFixMe\n    let fromBundle = {\n      filePath: '/user/dist/reformat.html',\n      name: 'reformat.html',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: '/'\n      }\n    };\n\n    // $FlowFixMe\n    let toBundle = {\n      filePath: '/user/dist/image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp',\n      name: 'image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: '/'\n      }\n    };\n\n    // $FlowFixMe\n    let dependency = {\n      id: '074b36596e3147e900a8ad17ceb5c90b',\n      specifier: 'url:./image.jpg?as=webp',\n      specifierType: 'esm'\n    };\n    let result = getURLReplacement({\n      dependency,\n      fromBundle,\n      toBundle,\n      relative: true\n    });\n    assert.equal(result.to, 'image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp');\n    assert.equal(result.from, '074b36596e3147e900a8ad17ceb5c90b');\n  });","file":"replaceBundleReferences.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Query params and named pipeline, absolute","suites":["replace bundle references"],"updatePoint":{"line":42,"column":47,"index":1206},"line":42,"code":"  it('Query params and named pipeline, absolute', () => {\n    // $FlowFixMe\n    let fromBundle = {\n      filePath: '/user/dist/reformat.html',\n      name: 'reformat.html',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: '/'\n      }\n    };\n\n    // $FlowFixMe\n    let toBundle = {\n      filePath: '/user/dist/image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp',\n      name: 'image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: '/'\n      }\n    };\n\n    // $FlowFixMe\n    let dependency = {\n      id: '074b36596e3147e900a8ad17ceb5c90b',\n      specifier: 'url:./image.jpg?as=webp',\n      specifierType: 'esm'\n    };\n    let result = getURLReplacement({\n      dependency,\n      fromBundle,\n      toBundle,\n      relative: false\n    });\n    assert.equal(result.to, '/image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp');\n    assert.equal(result.from, '074b36596e3147e900a8ad17ceb5c90b');\n  });","file":"replaceBundleReferences.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Custom Public URL","suites":["replace bundle references"],"updatePoint":{"line":80,"column":23,"index":2199},"line":80,"code":"  it('Custom Public URL', () => {\n    // $FlowFixMe\n    let fromBundle = {\n      filePath: '/user/dist/reformat.html',\n      name: 'reformat.html',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: 'https://test.com/static'\n      }\n    };\n\n    // $FlowFixMe\n    let toBundle = {\n      filePath: '/user/dist/image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp',\n      name: 'image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: 'https://test.com/static'\n      }\n    };\n\n    // $FlowFixMe\n    let dependency = {\n      id: '074b36596e314797845a8ad17ceb5c9b',\n      specifier: './image.jpg',\n      specifierType: 'esm'\n    };\n    let result = getURLReplacement({\n      dependency,\n      fromBundle,\n      toBundle,\n      relative: false\n    });\n    assert.equal(result.to, 'https://test.com/static/image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp');\n    assert.equal(result.from, '074b36596e314797845a8ad17ceb5c9b');\n  });","file":"replaceBundleReferences.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Relative with folders in between","suites":["replace bundle references"],"updatePoint":{"line":118,"column":38,"index":3262},"line":118,"code":"  it('Relative with folders in between', () => {\n    // $FlowFixMe\n    let fromBundle = {\n      filePath: '/user/dist/reformat.html',\n      name: 'reformat.html',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: 'https://test.com/static'\n      }\n    };\n\n    // $FlowFixMe\n    let toBundle = {\n      filePath: '/user/dist/assets/image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp',\n      name: 'image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist/assets',\n        publicUrl: 'https://test.com/static'\n      }\n    };\n\n    // $FlowFixMe\n    let dependency = {\n      id: '074b36596e3147e900a8ad17ceb5c90b',\n      specifier: 'url:./image.jpg?as=webp',\n      specifierType: 'esm'\n    };\n    let result = getURLReplacement({\n      dependency,\n      fromBundle,\n      toBundle,\n      relative: true\n    });\n    assert.equal(result.to, 'assets/image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp');\n    assert.equal(result.from, '074b36596e3147e900a8ad17ceb5c90b');\n  });","file":"replaceBundleReferences.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should work with bundle names with colons, relative","suites":["replace bundle references"],"updatePoint":{"line":156,"column":57,"index":4352},"line":156,"code":"  it('should work with bundle names with colons, relative', () => {\n    // $FlowFixMe\n    let fromBundle = {\n      filePath: '/user/dist/reformat.html',\n      name: 'reformat.html',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: '/'\n      }\n    };\n\n    // $FlowFixMe\n    let toBundle = {\n      filePath: '/user/dist/a:b:c.html',\n      name: 'a:b:c.html',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: '/'\n      }\n    };\n\n    // $FlowFixMe\n    let dependency = {\n      id: '074b36596e3147e900a8ad17ceb5c90b',\n      specifier: './a:b:c.html',\n      specifierType: 'esm'\n    };\n    let result = getURLReplacement({\n      dependency,\n      fromBundle,\n      toBundle,\n      relative: true\n    });\n    assert.equal(result.to, './a:b:c.html');\n  });","file":"replaceBundleReferences.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should work with bundle names with colons, absolute","suites":["replace bundle references"],"updatePoint":{"line":193,"column":57,"index":5175},"line":193,"code":"  it('should work with bundle names with colons, absolute', () => {\n    // $FlowFixMe\n    let fromBundle = {\n      filePath: '/user/dist/reformat.html',\n      name: 'reformat.html',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: '/'\n      }\n    };\n\n    // $FlowFixMe\n    let toBundle = {\n      filePath: '/user/dist/a:b:c.html',\n      name: 'a:b:c.html',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: '/'\n      }\n    };\n\n    // $FlowFixMe\n    let dependency = {\n      id: '074b36596e3147e900a8ad17ceb5c90b',\n      specifier: './a:b:c.html',\n      specifierType: 'esm'\n    };\n    let result = getURLReplacement({\n      dependency,\n      fromBundle,\n      toBundle,\n      relative: false\n    });\n    assert.equal(result.to, '/a:b:c.html');\n  });","file":"replaceBundleReferences.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should not match sourceMappingURL when not at the end of the bundle","suites":["loadSourceMap"],"updatePoint":{"line":7,"column":73,"index":315},"line":7,"code":"  it('should not match sourceMappingURL when not at the end of the bundle', () => {\n    // Code example taken from livescript.js (issue #2408 in parcel-bundler)\n    // This snippet lead to JSAsset.js being mislead and incorrectly trying to\n    // load (due to false-positive match) sourcemap before fix was introduced\n    let code = fs.readFileSync(path.join(__dirname, './input/sourcemap/no-sourcemap.js'), 'utf-8');\n    assert(!matchSourceMappingURL(code));\n  });","file":"sourcemap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should match referenced-min sourceMappingURL when correctly inserted at end of the bundle","suites":["loadSourceMap"],"updatePoint":{"line":14,"column":95,"index":803},"line":14,"code":"  it('should match referenced-min sourceMappingURL when correctly inserted at end of the bundle', () => {\n    let code = fs.readFileSync(path.join(__dirname, './input/sourcemap/referenced-min.js'), 'utf-8');\n    assert(!!matchSourceMappingURL(code));\n  });","file":"sourcemap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should match inline sourceMappingURL when correctly inserted at end of the bundle","suites":["loadSourceMap"],"updatePoint":{"line":18,"column":87,"index":1052},"line":18,"code":"  it('should match inline sourceMappingURL when correctly inserted at end of the bundle', () => {\n    // inline source map taken from https://github.com/thlorenz/inline-source-map\n    let code = fs.readFileSync(path.join(__dirname, './input/sourcemap/inline.js'), 'utf-8');\n    assert(!!matchSourceMappingURL(code));\n  });","file":"sourcemap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should be able to load sourcemap data from a url reference","suites":["loadSourceMap"],"updatePoint":{"line":23,"column":64,"index":1352},"line":23,"code":"  it('Should be able to load sourcemap data from a url reference', async () => {\n    let filename = path.join(__dirname, './input/sourcemap/referenced-min.js');\n    let contents = fs.readFileSync(filename, 'utf-8');\n    let foundMap = await loadSourceMapUrl(fs, filename, contents);\n    assert.equal(foundMap.url, 'file://referenced-min.js.map');\n    assert.equal(foundMap.filename, path.join(__dirname, 'input/sourcemap/referenced-min.js.map'));\n    assert.deepEqual(foundMap.map, {\n      version: 3,\n      sources: ['./referenced.js'],\n      names: ['hello', 'l', 'o', 'console', 'log'],\n      mappings: 'AAAA,SAASA,QACP,IAAIC,EAAI,QACNC,EAAI,QACNC,QAAQC,IAAIH,EAAI,IAAMC,EAAI,KAE5BF'\n    });\n  });","file":"sourcemap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should be able to load sourcemap data from an inline url reference","suites":["loadSourceMap"],"updatePoint":{"line":36,"column":72,"index":2061},"line":36,"code":"  it('Should be able to load sourcemap data from an inline url reference', async () => {\n    let filename = path.join(__dirname, './input/sourcemap/inline.js');\n    let contents = fs.readFileSync(filename, 'utf-8');\n    let foundMap = await loadSourceMapUrl(fs, filename, contents);\n    assert.equal(foundMap.url, 'data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiIiwic291cmNlcyI6WyJmb28uanMiLCJiYXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O1VBQ0c7Ozs7Ozs7Ozs7Ozs7O3NCQ0RIO3NCQUNBIn0=');\n    assert.equal(foundMap.filename, filename);\n    assert.deepEqual(foundMap.map, {\n      version: 3,\n      file: '',\n      sources: ['foo.js', 'bar.js'],\n      names: [],\n      mappings: ';;;;;;;;;UACG;;;;;;;;;;;;;;sBCDH;sBACA'\n    });\n  });","file":"sourcemap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should be able to load a SourceMap instance from a file","suites":["loadSourceMap"],"updatePoint":{"line":50,"column":61,"index":2811},"line":50,"code":"  it('Should be able to load a SourceMap instance from a file', async () => {\n    let filename = path.join(__dirname, './input/sourcemap/referenced-min.js');\n    let contents = fs.readFileSync(filename, 'utf-8');\n    let map = await loadSourceMap(filename, contents, {\n      fs,\n      projectRoot: __dirname\n    });\n    assert(!!map);\n    let parsedMap = map.getMap();\n    assert.deepEqual(parsedMap.sources, ['input/sourcemap/referenced.js']);\n    assert.deepEqual(parsedMap.names, ['hello', 'l', 'o', 'console', 'log']);\n    assert.deepEqual(parsedMap.mappings, [{\n      generated: {\n        line: 1,\n        column: 0\n      },\n      original: {\n        line: 1,\n        column: 0\n      },\n      source: 0\n    }, {\n      generated: {\n        line: 1,\n        column: 9\n      },\n      original: {\n        line: 1,\n        column: 9\n      },\n      source: 0,\n      name: 0\n    }, {\n      generated: {\n        line: 1,\n        column: 17\n      },\n      original: {\n        line: 2,\n        column: 2\n      },\n      source: 0\n    }, {\n      generated: {\n        line: 1,\n        column: 21\n      },\n      original: {\n        line: 2,\n        column: 6\n      },\n      source: 0,\n      name: 1\n    }, {\n      generated: {\n        line: 1,\n        column: 23\n      },\n      original: {\n        line: 2,\n        column: 10\n      },\n      source: 0\n    }, {\n      generated: {\n        line: 1,\n        column: 31\n      },\n      original: {\n        line: 3,\n        column: 4\n      },\n      source: 0,\n      name: 2\n    }, {\n      generated: {\n        line: 1,\n        column: 33\n      },\n      original: {\n        line: 3,\n        column: 8\n      },\n      source: 0\n    }, {\n      generated: {\n        line: 1,\n        column: 41\n      },\n      original: {\n        line: 4,\n        column: 2\n      },\n      source: 0,\n      name: 3\n    }, {\n      generated: {\n        line: 1,\n        column: 49\n      },\n      original: {\n        line: 4,\n        column: 10\n      },\n      source: 0,\n      name: 4\n    }, {\n      generated: {\n        line: 1,\n        column: 53\n      },\n      original: {\n        line: 4,\n        column: 14\n      },\n      source: 0,\n      name: 1\n    }, {\n      generated: {\n        line: 1,\n        column: 55\n      },\n      original: {\n        line: 4,\n        column: 18\n      },\n      source: 0\n    }, {\n      generated: {\n        line: 1,\n        column: 59\n      },\n      original: {\n        line: 4,\n        column: 24\n      },\n      source: 0,\n      name: 2\n    }, {\n      generated: {\n        line: 1,\n        column: 61\n      },\n      original: {\n        line: 4,\n        column: 28\n      },\n      source: 0\n    }, {\n      generated: {\n        line: 1,\n        column: 66\n      },\n      original: {\n        line: 6,\n        column: 0\n      },\n      source: 0,\n      name: 0\n    }]);\n  });","file":"sourcemap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should remap sources when using sourceRoot","suites":["loadSourceMap"],"updatePoint":{"line":211,"column":48,"index":5609},"line":211,"code":"  it('Should remap sources when using sourceRoot', async () => {\n    let filename = path.join(__dirname, './input/sourcemap/referenced-min.js');\n    let contents = fs.readFileSync(filename, 'utf-8');\n    let map = await loadSourceMap(filename, contents, {\n      fs,\n      projectRoot: __dirname\n    });\n    assert(!!map);\n    let parsedMap = map.getMap();\n    assert.deepEqual(parsedMap.sources, ['input/sourcemap/referenced.js']);\n  });","file":"sourcemap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should remap sources when using sourceRoot","suites":["loadSourceMap"],"updatePoint":{"line":222,"column":48,"index":6047},"line":222,"code":"  it('Should remap sources when using sourceRoot', async () => {\n    let filename = path.join(__dirname, './input/sourcemap/source-root.js');\n    let contents = fs.readFileSync(filename, 'utf-8');\n    let map = await loadSourceMap(filename, contents, {\n      fs,\n      projectRoot: __dirname\n    });\n    assert(!!map);\n    let parsedMap = map.getMap();\n    assert.deepEqual(parsedMap.sources, ['input/source.js']);\n  });","file":"sourcemap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"doesn't invoke a function more than once in a given interval","suites":["throttle"],"updatePoint":{"line":5,"column":66,"index":192},"line":5,"code":"  it(\"doesn't invoke a function more than once in a given interval\", () => {\n    let spy = sinon.spy();\n    let throttled = throttle(spy, 100);\n    throttled(1);\n    throttled(2);\n    throttled(3);\n    assert(spy.calledOnceWithExactly(1));\n  });","file":"throttle.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"calls the underlying function again once the interval has passed","suites":["throttle"],"updatePoint":{"line":13,"column":70,"index":442},"line":13,"code":"  it('calls the underlying function again once the interval has passed', () => {\n    let time = sinon.useFakeTimers();\n    let spy = sinon.spy();\n    let throttled = throttle(spy, 100);\n    throttled(1);\n    throttled(2);\n    throttled(3);\n    time.tick(100);\n    throttled(4);\n    assert.deepEqual(spy.args, [[1], [4]]);\n    time.restore();\n  });","file":"throttle.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"preserves the `this` when throttled functions are invoked","suites":["throttle"],"updatePoint":{"line":25,"column":63,"index":783},"line":25,"code":"  it('preserves the `this` when throttled functions are invoked', () => {\n    let result;\n    let throttled = throttle(function () {\n      result = this.bar;\n    }, 100);\n    throttled.call({\n      bar: 'baz'\n    });\n    assert(result === 'baz');\n  });","file":"throttle.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should join two paths","suites":["urlJoin"],"updatePoint":{"line":4,"column":27,"index":123},"line":4,"code":"  it('Should join two paths', () => {\n    let joinedUrl = urlJoin('/', './image.jpeg?test=test');\n    assert.equal(joinedUrl, '/image.jpeg?test=test');\n  });","file":"urlJoin.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should join two paths with longer publicUrl","suites":["urlJoin"],"updatePoint":{"line":8,"column":49,"index":303},"line":8,"code":"  it('Should join two paths with longer publicUrl', () => {\n    let joinedUrl = urlJoin('/static', './image.jpeg?test=test');\n    assert.equal(joinedUrl, '/static/image.jpeg?test=test');\n  });","file":"urlJoin.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should join two paths with longer publicUrl","suites":["urlJoin"],"updatePoint":{"line":12,"column":49,"index":496},"line":12,"code":"  it('Should join two paths with longer publicUrl', () => {\n    let joinedUrl = urlJoin('/static', 'image.jpeg?test=test');\n    assert.equal(joinedUrl, '/static/image.jpeg?test=test');\n  });","file":"urlJoin.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should turn windows path into posix","suites":["urlJoin"],"updatePoint":{"line":16,"column":41,"index":679},"line":16,"code":"  it('Should turn windows path into posix', () => {\n    let joinedUrl = urlJoin('/static', '.\\\\image.jpeg?test=test');\n    assert.equal(joinedUrl, '/static/image.jpeg?test=test');\n  });","file":"urlJoin.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should support paths with colons","suites":["urlJoin"],"updatePoint":{"line":20,"column":38,"index":862},"line":20,"code":"  it('should support paths with colons', () => {\n    let joinedUrl = urlJoin('/static', 'a:b:c.html');\n    assert.equal(joinedUrl, '/static/a:b:c.html');\n    joinedUrl = urlJoin('/static', '/a:b:c.html');\n    assert.equal(joinedUrl, '/static/a:b:c.html');\n    joinedUrl = urlJoin('/static', './a:b:c.html');\n    assert.equal(joinedUrl, '/static/a:b:c.html');\n  });","file":"urlJoin.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should be able to detect real cpu count","suites":["cpuCount"],"updatePoint":{"line":5,"column":45,"index":192},"line":5,"code":"  it('Should be able to detect real cpu count', () => {\n    // Windows not supported as getting the cpu count takes a couple seconds...\n    if (os.platform() === 'win32') return;\n    let cores = detectRealCores();\n    assert(cores > 0);\n  });","file":"cpuCount.test.js","skipped":false,"dir":"packages/core/workers/test"},{"name":"getCores should return more than 0","suites":["cpuCount"],"updatePoint":{"line":11,"column":40,"index":430},"line":11,"code":"  it('getCores should return more than 0', () => {\n    let cores = getCores(true);\n    assert(cores > 0);\n  });","file":"cpuCount.test.js","skipped":false,"dir":"packages/core/workers/test"},{"name":"identifies requires","suites":["utils","isRequire"],"updatePoint":{"line":21,"column":27,"index":478},"line":21,"code":"    it('identifies requires', () => {\n      assert.equal(isStaticRequire(getFirstExpression(parse(\"require('@parcel/core')\"))), true);\n    });","file":"utils.test.js","skipped":false,"dir":"packages/dev/eslint-plugin/test"},{"name":"doesn't handle dynamic requires","suites":["utils","isRequire"],"updatePoint":{"line":24,"column":39,"index":633},"line":24,"code":"    it(\"doesn't handle dynamic requires\", () => {\n      assert.equal(isStaticRequire(getFirstExpression(parse('require(dynamic)'))), false);\n    });","file":"utils.test.js","skipped":false,"dir":"packages/dev/eslint-plugin/test"},{"name":"identifies built-in require.resolve","suites":["utils","isResolve"],"updatePoint":{"line":29,"column":43,"index":824},"line":29,"code":"    it('identifies built-in require.resolve', () => {\n      assert.equal(isStaticResolve(getFirstExpression(parse(\"require.resolve('@parcel/core')\"))), true);\n    });","file":"utils.test.js","skipped":false,"dir":"packages/dev/eslint-plugin/test"},{"name":"behaves identically as path.relative on unix","suites":["utils","relativePathForRequire"],"updatePoint":{"line":34,"column":52,"index":1051},"line":34,"code":"    it('behaves identically as path.relative on unix', () => {\n      let sep = path.sep;\n      path.sep = '/';\n      assert.equal(relativePathForRequire({\n        origin: __filename,\n        request: '@parcel/eslint-plugin/',\n        pkgName,\n        pkgPath\n      }), '../');\n      path.sep = sep;\n    });","file":"utils.test.js","skipped":false,"dir":"packages/dev/eslint-plugin/test"},{"name":"uses / to separate paths even when path.sep is not /","suites":["utils","relativePathForRequire"],"updatePoint":{"line":45,"column":60,"index":1366},"line":45,"code":"    it('uses / to separate paths even when path.sep is not /', () => {\n      let sep = path.sep;\n      path.sep = '\\\\';\n      assert.equal(relativePathForRequire({\n        origin: __filename,\n        request: '@parcel/eslint-plugin/',\n        pkgName,\n        pkgPath\n      }), '../');\n      path.sep = sep;\n    });","file":"utils.test.js","skipped":false,"dir":"packages/dev/eslint-plugin/test"},{"name":"leaves absolute paths alone","suites":["utils","relativePathForRequire"],"updatePoint":{"line":56,"column":35,"index":1657},"line":56,"code":"    it('leaves absolute paths alone', () => {\n      assert.equal(relativePathForRequire({\n        origin: __filename,\n        request: '/a/b',\n        pkgName,\n        pkgPath\n      }), '/a/b');\n    });","file":"utils.test.js","skipped":false,"dir":"packages/dev/eslint-plugin/test"},{"name":"prepends ./ to peer paths","suites":["utils","relativePathForRequire"],"updatePoint":{"line":64,"column":33,"index":1858},"line":64,"code":"    it('prepends ./ to peer paths', () => {\n      assert.equal(relativePathForRequire({\n        origin: __filename,\n        request: '@parcel/eslint-plugin/test/baz',\n        pkgName,\n        pkgPath\n      }), './baz');\n    });","file":"utils.test.js","skipped":false,"dir":"packages/dev/eslint-plugin/test"},{"name":"writes log, info, success, and verbose log messages to stdout","suites":["CLIReporter"],"updatePoint":{"line":58,"column":67,"index":1730},"line":58,"code":"  it('writes log, info, success, and verbose log messages to stdout', async () => {\n    let options = {\n      ...EMPTY_OPTIONS,\n      logLevel: 'verbose'\n    };\n    await _report({\n      type: 'log',\n      level: 'info',\n      diagnostics: [{\n        origin: 'test',\n        message: 'info'\n      }]\n    }, options);\n    await _report({\n      type: 'log',\n      level: 'success',\n      message: 'success'\n    }, options);\n    await _report({\n      type: 'log',\n      level: 'verbose',\n      diagnostics: [{\n        origin: 'test',\n        message: 'verbose'\n      }]\n    }, options);\n    assert.equal(stdoutOutput, 'test: info\\nsuccess\\ntest: verbose\\n');\n  });","file":"CLIReporter.test.js","skipped":false,"dir":"packages/reporters/cli/test"},{"name":"writes errors and warnings to stderr","suites":["CLIReporter"],"updatePoint":{"line":86,"column":42,"index":2367},"line":86,"code":"  it('writes errors and warnings to stderr', async () => {\n    await _report({\n      type: 'log',\n      level: 'error',\n      diagnostics: [{\n        origin: 'test',\n        message: 'error'\n      }]\n    }, EMPTY_OPTIONS);\n    await _report({\n      type: 'log',\n      level: 'warn',\n      diagnostics: [{\n        origin: 'test',\n        message: 'warn'\n      }]\n    }, EMPTY_OPTIONS);\n    assert.equal(stdoutOutput, '\\n\\n');\n    assert.equal(stderrOutput, 'test: error\\ntest: warn\\n');\n  });","file":"CLIReporter.test.js","skipped":false,"dir":"packages/reporters/cli/test"},{"name":"prints errors nicely","suites":["CLIReporter"],"updatePoint":{"line":106,"column":26,"index":2843},"line":106,"code":"  it('prints errors nicely', async () => {\n    await _report({\n      type: 'log',\n      level: 'error',\n      diagnostics: [{\n        origin: 'test',\n        message: 'error'\n      }]\n    }, EMPTY_OPTIONS);\n    await _report({\n      type: 'log',\n      level: 'warn',\n      diagnostics: [{\n        origin: 'test',\n        message: 'warn'\n      }]\n    }, EMPTY_OPTIONS);\n    assert.equal(stdoutOutput, '\\n\\n');\n    assert(stderrOutput.includes('test: error\\n'));\n    assert(stderrOutput.includes('test: warn\\n'));\n  });","file":"CLIReporter.test.js","skipped":false,"dir":"packages/reporters/cli/test"},{"name":"writes buildProgress messages to stdout on the default loglevel","suites":["CLIReporter"],"updatePoint":{"line":127,"column":69,"index":3404},"line":127,"code":"  it('writes buildProgress messages to stdout on the default loglevel', async () => {\n    await _report({\n      type: 'buildProgress',\n      phase: 'bundling'\n    }, EMPTY_OPTIONS);\n    assert.equal(stdoutOutput, 'Bundling...\\n');\n  });","file":"CLIReporter.test.js","skipped":false,"dir":"packages/reporters/cli/test"},{"name":"writes buildSuccess messages to stdout on the default loglevel","suites":["CLIReporter"],"updatePoint":{"line":134,"column":68,"index":3640},"line":134,"code":"  it('writes buildSuccess messages to stdout on the default loglevel', async () => {\n    await _report({\n      type: 'buildProgress',\n      phase: 'bundling'\n    }, EMPTY_OPTIONS);\n    assert.equal(stdoutOutput, 'Bundling...\\n');\n  });","file":"CLIReporter.test.js","skipped":false,"dir":"packages/reporters/cli/test"},{"name":"should parse unquoted url()","suites":["parseFuncIRI"],"updatePoint":{"line":4,"column":33,"index":148},"line":4,"code":"  it('should parse unquoted url()', () => {\n    assert.deepEqual(parseFuncIRI('url(test)'), ['test', '']);\n    assert.deepEqual(parseFuncIRI('url(test hi)'), null);\n    assert.deepEqual(parseFuncIRI('url(test\"hi)'), null);\n    assert.deepEqual(parseFuncIRI('url(test\\\\ hi)'), ['test hi', '']);\n    assert.deepEqual(parseFuncIRI('url(test\\\\\"hi)'), ['test\"hi', '']);\n    assert.deepEqual(parseFuncIRI('url(test\\nhi)'), null);\n    assert.deepEqual(parseFuncIRI('url(test\\\\\\nhi)'), ['test\\nhi', '']);\n  });","file":"parseFuncIRI.test.js","skipped":false,"dir":"packages/transformers/svg/test"},{"name":"should parse quoted url()","suites":["parseFuncIRI"],"updatePoint":{"line":13,"column":31,"index":649},"line":13,"code":"  it('should parse quoted url()', () => {\n    assert.deepEqual(parseFuncIRI('url(\"test\")'), ['test', '']);\n    assert.deepEqual(parseFuncIRI(\"url('test')\"), ['test', '']);\n    assert.deepEqual(parseFuncIRI('url(\\'test\")'), null);\n    assert.deepEqual(parseFuncIRI('url(\"test\\')'), null);\n    assert.deepEqual(parseFuncIRI('url(\"test)'), null);\n    assert.deepEqual(parseFuncIRI('url(\"test\" hi)'), ['test', ' hi']);\n    assert.deepEqual(parseFuncIRI('url(\"te\\\\\"st\" hi)'), ['te\"st', ' hi']);\n  });","file":"parseFuncIRI.test.js","skipped":false,"dir":"packages/transformers/svg/test"},{"name":"compiles against targets passed through caller with env = esmodule","suites":["@parcel/plugin-transform-runtime"],"updatePoint":{"line":12,"column":72,"index":373},"line":12,"code":"  it('compiles against targets passed through caller with env = esmodule', () => {\n    let {\n      code: transformed\n    } = babel.transformSync(input, {\n      configFile: false,\n      presets: [preset],\n      plugins: [plugin],\n      caller: {\n        name: 'parcel',\n        version: '2.0.0',\n        targets: JSON.stringify({\n          browsers: ['last 1 Chrome version']\n        }),\n        env: 'esmodule'\n      }\n    });\n    assert(transformed.includes('function Foo'));\n    assert(transformed.includes('...x'));\n  });","file":"babel-plugin-transform-runtime.test.js","skipped":false,"dir":"packages/utils/babel-plugin-transform-runtime/test"},{"name":"compiles against targets passed through caller with no env","suites":["@parcel/plugin-transform-runtime"],"updatePoint":{"line":31,"column":64,"index":890},"line":31,"code":"  it('compiles against targets passed through caller with no env', () => {\n    let {\n      code: transformed\n    } = babel.transformSync(input, {\n      configFile: false,\n      presets: [preset],\n      plugins: [plugin],\n      caller: {\n        name: 'parcel',\n        version: '2.0.0',\n        targets: JSON.stringify({\n          browsers: ['last 1 Chrome version']\n        })\n      }\n    });\n    assert(transformed.includes('function Foo'));\n    assert(transformed.includes('...x'));\n  });","file":"babel-plugin-transform-runtime.test.js","skipped":false,"dir":"packages/utils/babel-plugin-transform-runtime/test"},{"name":"compiles against targets passed through caller when the caller is parcel 2.x","suites":["@parcel/babel-preset-env"],"updatePoint":{"line":20,"column":82,"index":403},"line":20,"code":"  it('compiles against targets passed through caller when the caller is parcel 2.x', () => {\n    let {\n      code: transformed\n    } = babel.transformSync(input, {\n      configFile: false,\n      presets: [preset],\n      caller: {\n        name: 'parcel',\n        version: '2.0.0',\n        targets: JSON.stringify({\n          browsers: ['last 1 Chrome version']\n        })\n      }\n    });\n    assert(transformed.includes('class Foo'));\n    assert(transformed.includes('this.x ** 2'));\n    assert(transformed.includes('export default'));\n  });","file":"preset-env.test.js","skipped":false,"dir":"packages/utils/babel-preset-env/test"},{"name":"does not compile against targets passed through caller when the caller is not parcel","suites":["@parcel/babel-preset-env"],"updatePoint":{"line":38,"column":90,"index":952},"line":38,"code":"  it('does not compile against targets passed through caller when the caller is not parcel', () => {\n    let {\n      code: transformed\n    } = babel.transformSync(input, {\n      configFile: false,\n      presets: [preset],\n      caller: {\n        name: 'foo',\n        version: '2.0.0',\n        targets: JSON.stringify({\n          browsers: ['last 1 Chrome version']\n        })\n      }\n    });\n    assert(!transformed.includes('class Foo'));\n    assert(!transformed.includes('this.x ** 2'));\n    assert(!transformed.includes('export default'));\n  });","file":"preset-env.test.js","skipped":false,"dir":"packages/utils/babel-preset-env/test"},{"name":"does not compile against targets passed through caller when the caller is not present","suites":["@parcel/babel-preset-env"],"updatePoint":{"line":56,"column":91,"index":1502},"line":56,"code":"  it('does not compile against targets passed through caller when the caller is not present', () => {\n    let {\n      code: transformed\n    } = babel.transformSync(input, {\n      configFile: false,\n      presets: [preset]\n    });\n    assert(!transformed.includes('class Foo'));\n    assert(!transformed.includes('this.x ** 2'));\n    assert(!transformed.includes('export default'));\n  });","file":"preset-env.test.js","skipped":false,"dir":"packages/utils/babel-preset-env/test"},{"name":"can wrap an IDisposable","suites":["Disposable"],"updatePoint":{"line":5,"column":29,"index":188},"line":5,"code":"  it('can wrap an IDisposable', () => {\n    let disposed;\n    new Disposable({\n      dispose() {\n        disposed = true;\n      }\n    }).dispose();\n    assert.equal(disposed, true);\n  });","file":"Disposable.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"can wrap a function to dispose","suites":["Disposable"],"updatePoint":{"line":14,"column":36,"index":383},"line":14,"code":"  it('can wrap a function to dispose', () => {\n    let disposed;\n    new Disposable(() => {\n      disposed = true;\n    }).dispose();\n    assert.equal(disposed, true);\n  });","file":"Disposable.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"can wrap many disposable-likes","suites":["Disposable"],"updatePoint":{"line":21,"column":36,"index":556},"line":21,"code":"  it('can wrap many disposable-likes', () => {\n    let disposed1;\n    let disposed2;\n    new Disposable({\n      dispose() {\n        disposed1 = true;\n      }\n    }, () => {\n      disposed2 = true;\n    }).dispose();\n    assert.equal(disposed1, true);\n    assert.equal(disposed2, true);\n  });","file":"Disposable.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"can add disposables after construction","suites":["Disposable"],"updatePoint":{"line":34,"column":44,"index":855},"line":34,"code":"  it('can add disposables after construction', () => {\n    let disposed1;\n    let disposed2;\n    let disposed3;\n    let disposed4;\n    let disposable = new Disposable({\n      dispose() {\n        disposed1 = true;\n      }\n    }, () => {\n      disposed2 = true;\n    });\n    disposable.add(() => {\n      disposed3 = true;\n    }, {\n      dispose() {\n        disposed4 = true;\n      }\n    });\n    assert.notEqual(disposed1, true);\n    assert.notEqual(disposed2, true);\n    assert.notEqual(disposed3, true);\n    assert.notEqual(disposed4, true);\n    disposable.dispose();\n    assert.equal(disposed1, true);\n    assert.equal(disposed2, true);\n    assert.equal(disposed3, true);\n    assert.equal(disposed4, true);\n  });","file":"Disposable.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"throws if `add` is called after it has been disposed","suites":["Disposable"],"updatePoint":{"line":75,"column":58,"index":1922},"line":75,"code":"  it('throws if `add` is called after it has been disposed', () => {\n    let disposable = new Disposable();\n    disposable.dispose();\n    assert.throws(() => {\n      disposable.add(() => {});\n    }, AlreadyDisposedError);\n  });","file":"Disposable.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"can be checked for disposal state","suites":["Disposable"],"updatePoint":{"line":82,"column":39,"index":2131},"line":82,"code":"  it('can be checked for disposal state', () => {\n    let disposable = new Disposable();\n    assert.equal(disposable.disposed, false);\n    disposable.dispose();\n    assert.equal(disposable.disposed, true);\n  });","file":"Disposable.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"registers new listeners and can dispose of them","suites":["ValueEmitter"],"updatePoint":{"line":17,"column":53,"index":429},"line":17,"code":"  it('registers new listeners and can dispose of them', () => {\n    let disposable = emitter.addListener(numberListener);\n    assert.deepEqual(emitter._listeners, [numberListener]);\n    disposable.dispose();\n    assert.deepEqual(emitter._listeners, []);\n  });","file":"ValueEmitter.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"emits values to registered listeners","suites":["ValueEmitter"],"updatePoint":{"line":23,"column":42,"index":678},"line":23,"code":"  it('emits values to registered listeners', () => {\n    let disposable = emitter.addListener(numberListener);\n    emitter.emit(42);\n    assert.deepEqual(values, [42]);\n    disposable.dispose();\n  });","file":"ValueEmitter.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"does not emit to listeners that were just registered","suites":["ValueEmitter"],"updatePoint":{"line":29,"column":58,"index":895},"line":29,"code":"  it('does not emit to listeners that were just registered', () => {\n    let innerDisposable;\n    let disposable = emitter.addListener(() => {\n      innerDisposable = emitter.addListener(numberListener);\n    });\n    emitter.emit(42);\n    assert.deepEqual(values, []);\n    emitter.emit(27);\n    assert.deepEqual(values, [27]);\n    disposable.dispose();\n    innerDisposable && innerDisposable.dispose();\n  });","file":"ValueEmitter.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"finishes emitting even if a listener disposes of the emitter mid-emit","suites":["ValueEmitter"],"updatePoint":{"line":41,"column":75,"index":1320},"line":41,"code":"  it('finishes emitting even if a listener disposes of the emitter mid-emit', () => {\n    let disposableA = emitter.addListener(() => {\n      emitter.dispose();\n    });\n    let disposableB = emitter.addListener(numberListener);\n    emitter.emit(42);\n    assert.deepEqual(values, [42]);\n    disposableA.dispose();\n    disposableB.dispose();\n  });","file":"ValueEmitter.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"clears listeners when disposed","suites":["ValueEmitter"],"updatePoint":{"line":51,"column":36,"index":1627},"line":51,"code":"  it('clears listeners when disposed', () => {\n    let disposable = emitter.addListener(numberListener);\n    assert.deepEqual(emitter._listeners, [numberListener]);\n    emitter.dispose();\n    assert.deepEqual(emitter._listeners, []);\n    disposable.dispose();\n  });","file":"ValueEmitter.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"throws when adding a listener when already disposed","suites":["ValueEmitter"],"updatePoint":{"line":58,"column":57,"index":1914},"line":58,"code":"  it('throws when adding a listener when already disposed', () => {\n    emitter.dispose();\n    assert.throws(() => {\n      emitter.addListener(numberListener);\n    }, AlreadyDisposedError);\n  });","file":"ValueEmitter.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"throws when emitting when already disposed","suites":["ValueEmitter"],"updatePoint":{"line":64,"column":48,"index":2101},"line":64,"code":"  it('throws when emitting when already disposed', () => {\n    emitter.dispose();\n    assert.throws(() => {\n      emitter.emit(42);\n    }, AlreadyDisposedError);\n  });","file":"ValueEmitter.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"can be disposed multiple times","suites":["ValueEmitter"],"updatePoint":{"line":70,"column":36,"index":2257},"line":70,"code":"  it('can be disposed multiple times', () => {\n    emitter.dispose();\n    assert.doesNotThrow(() => {\n      emitter.dispose();\n    });\n  });","file":"ValueEmitter.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"should resolve a relative path with an extension","suites":["resolver","file paths"],"updatePoint":{"line":65,"column":56,"index":3003},"line":65,"code":"    it('should resolve a relative path with an extension', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './bar.js',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'bar.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a relative path without an extension","suites":["resolver","file paths"],"updatePoint":{"line":74,"column":59,"index":3361},"line":74,"code":"    it('should resolve a relative path without an extension', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'bar.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve an absolute path from the root module","suites":["resolver","file paths"],"updatePoint":{"line":83,"column":60,"index":3717},"line":83,"code":"    it('should resolve an absolute path from the root module', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '/bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'nested', 'test.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'bar.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve an absolute path from a node_modules folder","suites":["resolver","file paths"],"updatePoint":{"line":92,"column":66,"index":4089},"line":92,"code":"    it('should resolve an absolute path from a node_modules folder', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '/bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'foo', 'index.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'bar.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a tilde path from the root module","suites":["resolver","file paths"],"updatePoint":{"line":101,"column":56,"index":4465},"line":101,"code":"    it('should resolve a tilde path from the root module', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '~/bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'nested', 'test.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'bar.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a tilde path from the root module without a slash","suites":["resolver","file paths"],"updatePoint":{"line":110,"column":72,"index":4844},"line":110,"code":"    it('should resolve a tilde path from the root module without a slash', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '~bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'nested', 'test.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'bar.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a tilde path from a node_modules folder","suites":["resolver","file paths"],"updatePoint":{"line":119,"column":62,"index":5212},"line":119,"code":"    it('should resolve a tilde path from a node_modules folder', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '~/bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'foo', 'nested', 'baz.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'node_modules', 'foo', 'bar.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve an index file in a directory","suites":["resolver","file paths"],"updatePoint":{"line":128,"column":51,"index":5615},"line":128,"code":"    it('should resolve an index file in a directory', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './nested',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'nested', 'index.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not resolve an index file in a directory for URL specifiers","suites":["resolver","file paths"],"updatePoint":{"line":137,"column":74,"index":6000},"line":137,"code":"    it('should not resolve an index file in a directory for URL specifiers', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './nested',\n        specifierType: 'url',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(nullthrows(resolved).diagnostics, [{\n        message: \"Cannot load file './nested' in './'.\",\n        hints: []\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a file with a question mark with CommonJS specifiers","suites":["resolver","file paths"],"updatePoint":{"line":149,"column":75,"index":6439},"line":149,"code":"    it('should resolve a file with a question mark with CommonJS specifiers', async function () {\n      // Windows filenames cannot contain question marks.\n      if (process.platform === 'win32') {\n        return;\n      }\n      await overlayFS.writeFile(path.join(rootDir, 'a?b.js'), '');\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './a?b.js',\n        specifierType: 'commonjs',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'a?b.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not resolve a file with a question mark with ESM specifiers","suites":["resolver","file paths"],"updatePoint":{"line":163,"column":74,"index":7008},"line":163,"code":"    it('should not resolve a file with a question mark with ESM specifiers', async function () {\n      // Windows filenames cannot contain question marks.\n      if (process.platform === 'win32') {\n        return;\n      }\n      await overlayFS.writeFile(path.join(rootDir, 'a?b.js'), '');\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './a?b.js',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(nullthrows(resolved).diagnostics, [{\n        message: \"Cannot load file './a' in './'.\",\n        hints: []\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a file with an encoded question mark with ESM specifiers","suites":["resolver","file paths"],"updatePoint":{"line":180,"column":79,"index":7637},"line":180,"code":"    it('should resolve a file with an encoded question mark with ESM specifiers', async function () {\n      // Windows filenames cannot contain question marks.\n      if (process.platform === 'win32') {\n        return;\n      }\n      await overlayFS.writeFile(path.join(rootDir, 'a?b.js'), '');\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './a%3Fb.js',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'a?b.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not support percent encoding in CommonJS specifiers","suites":["resolver","file paths"],"updatePoint":{"line":194,"column":66,"index":8195},"line":194,"code":"    it('should not support percent encoding in CommonJS specifiers', async function () {\n      // Windows filenames cannot contain question marks.\n      if (process.platform === 'win32') {\n        return;\n      }\n      await overlayFS.writeFile(path.join(rootDir, 'a?b.js'), '');\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './a%3Fb.js',\n        specifierType: 'commonjs',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(nullthrows(resolved).diagnostics, [{\n        message: \"Cannot load file './a%3Fb.js' in './'.\",\n        hints: [\"Did you mean '__./a?b.js__'?\"]\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should support query params for ESM specifiers","suites":["resolver","file paths"],"updatePoint":{"line":211,"column":54,"index":8843},"line":211,"code":"    it('should support query params for ESM specifiers', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './nested?foo=bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'nested', 'index.js'));\n      // assert.deepEqual(nullthrows(resolved).query?.toString(), 'foo=bar');\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not support query params for CommonJS specifiers","suites":["resolver","file paths"],"updatePoint":{"line":222,"column":63,"index":9304},"line":222,"code":"    it('should not support query params for CommonJS specifiers', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './nested?foo=bar',\n        specifierType: 'commonjs',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(nullthrows(resolved).diagnostics, [{\n        message: \"Cannot load file './nested?foo=bar' in './'.\",\n        hints: []\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve node builtin modules","suites":["resolver","builtins"],"updatePoint":{"line":236,"column":43,"index":9775},"line":236,"code":"    it('should resolve node builtin modules', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'zlib',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: require.resolve('browserify-zlib'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/browserify-zlib',\n          aboveFilePath: rootDir\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.dirname(require.resolve('browserify-zlib/lib'))\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), require.resolve('browserify-zlib/package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"Should be able to handle node: prefixes","suites":["resolver","builtins"],"updatePoint":{"line":257,"column":47,"index":10596},"line":257,"code":"    it('Should be able to handle node: prefixes', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'node:zlib',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: require.resolve('browserify-zlib'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/browserify-zlib',\n          aboveFilePath: rootDir\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.dirname(require.resolve('browserify-zlib/lib'))\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), require.resolve('browserify-zlib/package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve unimplemented node builtin modules to an empty file","suites":["resolver","builtins"],"updatePoint":{"line":278,"column":74,"index":11449},"line":278,"code":"    it('should resolve unimplemented node builtin modules to an empty file', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'fs',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(__dirname, '..', 'src', '_empty.js'),\n        sideEffects: undefined,\n        query: undefined\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should exclude node builtin modules with --target=node","suites":["resolver","builtins"],"updatePoint":{"line":291,"column":62,"index":11880},"line":291,"code":"    it('should exclude node builtin modules with --target=node', async function () {\n      let resolved = await resolver.resolve({\n        env: NODE_ENV,\n        filename: 'zlib',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        isExcluded: true\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should exclude the electron module in electron environments","suites":["resolver","builtins"],"updatePoint":{"line":302,"column":67,"index":12217},"line":302,"code":"    it('should exclude the electron module in electron environments', async function () {\n      let resolved = await resolver.resolve({\n        env: new Environment(createEnvironment({\n          context: 'electron-main',\n          isLibrary: true,\n          includeNodeModules: true\n        }), DEFAULT_OPTIONS),\n        filename: 'electron',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js'),\n        sourcePath: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        isExcluded: true\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a node_modules index.js","suites":["resolver","node_modules"],"updatePoint":{"line":320,"column":46,"index":12788},"line":320,"code":"    it('should resolve a node_modules index.js', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'foo', 'index.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/foo',\n          aboveFilePath: rootDir\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'foo', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a node_modules package.main","suites":["resolver","node_modules"],"updatePoint":{"line":338,"column":50,"index":13501},"line":338,"code":"    it('should resolve a node_modules package.main', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-main',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-main', 'main.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/package-main',\n          aboveFilePath: rootDir\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'package-main', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a node_modules package.module","suites":["resolver","node_modules"],"updatePoint":{"line":356,"column":52,"index":14251},"line":356,"code":"    it('should resolve a node_modules package.module', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-module',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-module', 'module.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/package-module',\n          aboveFilePath: rootDir\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'package-module', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a node_modules package.browser main field","suites":["resolver","node_modules"],"updatePoint":{"line":374,"column":64,"index":15023},"line":374,"code":"    it('should resolve a node_modules package.browser main field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-browser',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-browser', 'browser.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/package-browser',\n          aboveFilePath: rootDir\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'package-browser', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not resolve a node_modules package.browser main field with --target=node","suites":["resolver","node_modules"],"updatePoint":{"line":392,"column":87,"index":15823},"line":392,"code":"    it('should not resolve a node_modules package.browser main field with --target=node', async function () {\n      let resolved = await resolver.resolve({\n        env: NODE_INCLUDE_ENV,\n        filename: 'package-browser',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-browser', 'main.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/package-browser',\n          aboveFilePath: rootDir\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'package-browser', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should fall back to index.js when it cannot find package.main","suites":["resolver","node_modules"],"updatePoint":{"line":410,"column":69,"index":16607},"line":410,"code":"    it('should fall back to index.js when it cannot find package.main', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-fallback',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-fallback', 'index.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/package-fallback',\n          aboveFilePath: rootDir\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-fallback', 'main.js')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-fallback', 'main.js.cjs')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-fallback', 'main.js.mjs')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-fallback', 'main.js.jsx')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-fallback', 'main.js.ts')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-fallback', 'main.js.tsx')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-fallback', 'main.js.js')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-fallback', 'main.js.json')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-fallback', 'main.js/package.json')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'package-fallback', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a node_module package.main pointing to a directory","suites":["resolver","node_modules"],"updatePoint":{"line":446,"column":73,"index":18326},"line":446,"code":"    it('should resolve a node_module package.main pointing to a directory', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-main-directory',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-main-directory', 'nested', 'index.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/package-main-directory',\n          aboveFilePath: rootDir\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-main-directory', 'nested', 'package.json')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-main-directory', 'nested')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-main-directory', 'nested')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-main-directory', 'nested.js')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-main-directory', 'nested.json')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-main-directory', 'nested.jsx')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-main-directory', 'nested.cjs')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-main-directory', 'nested.mjs')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-main-directory', 'nested.ts')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-main-directory', 'nested.tsx')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'package-main-directory', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a file inside a node_modules folder","suites":["resolver","node_modules"],"updatePoint":{"line":485,"column":58,"index":20257},"line":485,"code":"    it('should resolve a file inside a node_modules folder', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'foo/nested/baz',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'foo', 'nested', 'baz.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/foo',\n          aboveFilePath: rootDir\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'foo', 'nested')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'foo', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a scoped module","suites":["resolver","node_modules"],"updatePoint":{"line":506,"column":38,"index":21103},"line":506,"code":"    it('should resolve a scoped module', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '@scope/pkg',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.resolve(rootDir, 'node_modules/@scope/pkg/index.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/@scope/pkg',\n          aboveFilePath: rootDir\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', '@scope', 'pkg', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a file inside a scoped module","suites":["resolver","node_modules"],"updatePoint":{"line":524,"column":52,"index":21846},"line":524,"code":"    it('should resolve a file inside a scoped module', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '@scope/pkg/foo/bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.resolve(rootDir, 'node_modules/@scope/pkg/foo/bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/@scope/pkg',\n          aboveFilePath: rootDir\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', '@scope', 'pkg', 'foo')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', '@scope', 'pkg', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (file)","suites":["resolver","node_modules","sideEffects: false"],"updatePoint":{"line":546,"column":55,"index":22784},"line":546,"code":"      it('should determine sideEffects correctly (file)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false/src/index.js',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        check(resolved, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false/src/index.js'),\n          sideEffects: false,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'node_modules/side-effects-false',\n            aboveFilePath: rootDir\n          }, {\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'node_modules', 'side-effects-false', 'src')\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'side-effects-false', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (extensionless file)","suites":["resolver","node_modules","sideEffects: false"],"updatePoint":{"line":567,"column":69,"index":23764},"line":567,"code":"      it('should determine sideEffects correctly (extensionless file)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false/src/index',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        check(resolved, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false/src/index.js'),\n          sideEffects: false,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'node_modules/side-effects-false',\n            aboveFilePath: rootDir\n          }, {\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'node_modules', 'side-effects-false', 'src')\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'side-effects-false', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (sub folder)","suites":["resolver","node_modules","sideEffects: false"],"updatePoint":{"line":588,"column":61,"index":24733},"line":588,"code":"      it('should determine sideEffects correctly (sub folder)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false/src/',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        check(resolved, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false/src/index.js'),\n          sideEffects: false,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'node_modules/side-effects-false',\n            aboveFilePath: rootDir\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-false', 'src', 'package.json')\n          }, {\n            aboveFilePath: path.join(rootDir, 'node_modules', 'side-effects-false', 'src'),\n            fileName: 'package.json'\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'side-effects-false', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (main field)","suites":["resolver","node_modules","sideEffects: false"],"updatePoint":{"line":611,"column":61,"index":25814},"line":611,"code":"      it('should determine sideEffects correctly (main field)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false/src/',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        check(resolved, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false/src/index.js'),\n          sideEffects: false,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'node_modules/side-effects-false',\n            aboveFilePath: rootDir\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-false', 'src', 'package.json')\n          }, {\n            aboveFilePath: path.join(rootDir, 'node_modules', 'side-effects-false', 'src'),\n            fileName: 'package.json'\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'side-effects-false', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (main field exists in upward package)","suites":["resolver","node_modules","sideEffects: false"],"updatePoint":{"line":634,"column":86,"index":26920},"line":634,"code":"      it('should determine sideEffects correctly (main field exists in upward package)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-package-redirect-up/foo/bar',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        check(resolved, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-package-redirect-up/foo/real-bar.js'),\n          sideEffects: false,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'node_modules/side-effects-package-redirect-up',\n            aboveFilePath: rootDir\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-up', 'foo', 'bar')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-up', 'foo', 'bar.js')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-up', 'foo', 'bar.json')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-up', 'foo', 'bar.jsx')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-up', 'foo', 'bar.cjs')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-up', 'foo', 'bar.mjs')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-up', 'foo', 'bar.ts')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-up', 'foo', 'bar.tsx')\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'side-effects-package-redirect-up', 'package.json'), path.join(rootDir, 'node_modules', 'side-effects-package-redirect-up', 'foo', 'bar', 'package.json'), path.join(rootDir, 'node_modules', 'side-effects-package-redirect-up', 'foo', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (main field exists in downward package)","suites":["resolver","node_modules","sideEffects: false"],"updatePoint":{"line":668,"column":88,"index":29029},"line":668,"code":"      it('should determine sideEffects correctly (main field exists in downward package)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-package-redirect-down/foo/bar',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        check(resolved, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-package-redirect-down/foo/bar/baz/real-bar.js'),\n          sideEffects: false,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'node_modules/side-effects-package-redirect-down',\n            aboveFilePath: rootDir\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-down', 'foo', 'bar')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-down', 'foo', 'bar.js')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-down', 'foo', 'bar.jsx')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-down', 'foo', 'bar.json')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-down', 'foo', 'bar.ts')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-down', 'foo', 'bar.tsx')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-down', 'foo', 'bar.cjs')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-down', 'foo', 'bar.mjs')\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'side-effects-package-redirect-down', 'package.json'), path.join(rootDir, 'node_modules', 'side-effects-package-redirect-down', 'foo', 'bar', 'package.json'), path.join(rootDir, 'node_modules', 'side-effects-package-redirect-down', 'foo', 'bar', 'baz', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (matched)","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":704,"column":58,"index":31215},"line":704,"code":"      it('should determine sideEffects correctly (matched)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false-glob/a/index',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        check({\n          filePath: resolved?.filePath,\n          sideEffects: resolved?.sideEffects\n        }, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false-glob/a/index.js'),\n          sideEffects: undefined\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (unmatched)","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":719,"column":60,"index":31783},"line":719,"code":"      it('should determine sideEffects correctly (unmatched)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false-glob/b/index.js',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        check({\n          filePath: resolved?.filePath,\n          sideEffects: resolved?.sideEffects\n        }, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false-glob/b/index.js'),\n          sideEffects: false\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (matched dotslash)","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":734,"column":67,"index":32357},"line":734,"code":"      it('should determine sideEffects correctly (matched dotslash)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false-glob/sub/index.js',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        check({\n          filePath: resolved?.filePath,\n          sideEffects: resolved?.sideEffects\n        }, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false-glob/sub/index.js'),\n          sideEffects: undefined\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (unmatched, prefix in subdir)","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":749,"column":78,"index":32950},"line":749,"code":"      it('should determine sideEffects correctly (unmatched, prefix in subdir)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false-glob/sub/a/index.js',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        check({\n          filePath: resolved?.filePath,\n          sideEffects: resolved?.sideEffects\n        }, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false-glob/sub/a/index.js'),\n          sideEffects: false\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (only name)","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":764,"column":60,"index":33525},"line":764,"code":"      it('should determine sideEffects correctly (only name)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false-glob/sub/index.json',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        check({\n          filePath: resolved?.filePath,\n          sideEffects: resolved?.sideEffects\n        }, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false-glob/sub/index.json'),\n          sideEffects: undefined\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not resolve a node module for URL dependencies","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":780,"column":61,"index":34113},"line":780,"code":"    it('should not resolve a node module for URL dependencies', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '@scope/pkg',\n        specifierType: 'url',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(nullthrows(resolved).diagnostics, [{\n        message: \"Cannot load file './@scope/pkg' in './'.\",\n        hints: []\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a node module for URL dependencies with the npm: prefix","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":792,"column":78,"index":34561},"line":792,"code":"    it('should resolve a node module for URL dependencies with the npm: prefix', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'npm:@scope/pkg',\n        specifierType: 'url',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(nullthrows(resolved).filePath, path.join(rootDir, 'node_modules', '@scope', 'pkg', 'index.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should support query params for bare ESM specifiers","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":801,"column":59,"index":34964},"line":801,"code":"    it('should support query params for bare ESM specifiers', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '@scope/pkg?foo=2',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.resolve(rootDir, 'node_modules/@scope/pkg/index.js'));\n      assert.deepEqual(nullthrows(resolved).query?.toString(), 'foo=2');\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not support query params for bare CommonJS specifiers","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":811,"column":68,"index":35441},"line":811,"code":"    it('should not support query params for bare CommonJS specifiers', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '@scope/pkg?foo=2',\n        specifierType: 'commonjs',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(nullthrows(resolved).diagnostics, [{\n        message: `Cannot find module '@scope/pkg?foo=2'`,\n        hints: [\"Did you mean '__@scope/pkg__'?\"]\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should support query params for npm: specifiers","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":823,"column":55,"index":35906},"line":823,"code":"    it('should support query params for npm: specifiers', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'npm:@scope/pkg?foo=2',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.resolve(rootDir, 'node_modules/@scope/pkg/index.js'));\n      assert.deepEqual(nullthrows(resolved).query?.toString(), 'foo=2');\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should alias the main file using the package.browser field","suites":["resolver","aliases"],"updatePoint":{"line":835,"column":66,"index":36427},"line":835,"code":"    it('should alias the main file using the package.browser field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-browser-alias',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-browser-alias', 'browser.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/package-browser-alias',\n          aboveFilePath: rootDir\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'package-browser-alias', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should alias a sub-file using the package.browser field","suites":["resolver","aliases"],"updatePoint":{"line":853,"column":63,"index":37227},"line":853,"code":"    it('should alias a sub-file using the package.browser field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-browser-alias/foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-browser-alias', 'bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/package-browser-alias',\n          aboveFilePath: rootDir\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'package-browser-alias', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should alias a relative file using the package.browser field","suites":["resolver","aliases"],"updatePoint":{"line":871,"column":68,"index":38032},"line":871,"code":"    it('should alias a relative file using the package.browser field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'package-browser-alias', 'browser.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-browser-alias', 'bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-browser-alias', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not alias using the package.browser field with --target=node","suites":["resolver","aliases"],"updatePoint":{"line":886,"column":75,"index":38730},"line":886,"code":"    it('should not alias using the package.browser field with --target=node', async function () {\n      let resolved = await resolver.resolve({\n        env: NODE_INCLUDE_ENV,\n        filename: 'package-browser-alias/foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-browser-alias', 'foo.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/package-browser-alias',\n          aboveFilePath: rootDir\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'package-browser-alias', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should alias a deep nested relative file using the package.browser field","suites":["resolver","aliases"],"updatePoint":{"line":904,"column":80,"index":39552},"line":904,"code":"    it('should alias a deep nested relative file using the package.browser field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './nested',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'package-browser-alias', 'browser.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-browser-alias', 'subfolder1/subfolder2/subfile.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-browser-alias', 'subfolder1', 'subfolder2')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-browser-alias', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should alias a sub-file using the package.alias field","suites":["resolver","aliases"],"updatePoint":{"line":922,"column":61,"index":40425},"line":922,"code":"    it('should alias a sub-file using the package.alias field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-alias/foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-alias', 'bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/package-alias',\n          aboveFilePath: rootDir\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'package-alias', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should alias a relative file using the package.alias field","suites":["resolver","aliases"],"updatePoint":{"line":940,"column":66,"index":41196},"line":940,"code":"    it('should alias a relative file using the package.alias field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'package-alias', 'browser.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-alias', 'bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-alias', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should alias a glob using the package.alias field","suites":["resolver","aliases"],"updatePoint":{"line":955,"column":57,"index":41852},"line":955,"code":"    it('should alias a glob using the package.alias field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './lib/test',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'package-alias-glob', 'index.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-alias-glob', 'src', 'test.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-alias-glob', 'lib')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-alias-glob', 'src')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-alias-glob', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply a module alias using the package.alias field in the root package","suites":["resolver","aliases"],"updatePoint":{"line":976,"column":85,"index":42836},"line":976,"code":"    it('should apply a module alias using the package.alias field in the root package', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliased',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'foo', 'index.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/foo',\n          aboveFilePath: rootDir\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'foo', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply a global module alias using the package.alias field in the root package","suites":["resolver","aliases"],"updatePoint":{"line":994,"column":92,"index":43558},"line":994,"code":"    it('should apply a global module alias using the package.alias field in the root package', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliased',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'package-alias', 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'foo', 'index.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/foo',\n          aboveFilePath: rootDir\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'foo', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply a global module alias to a sub-file in a package","suites":["resolver","aliases"],"updatePoint":{"line":1012,"column":69,"index":44290},"line":1012,"code":"    it('should apply a global module alias to a sub-file in a package', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliased/bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'package-alias', 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'foo', 'bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/foo',\n          aboveFilePath: rootDir\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'foo', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply a module alias pointing to a file using the package.alias field","suites":["resolver","aliases"],"updatePoint":{"line":1030,"column":84,"index":45039},"line":1030,"code":"    it('should apply a module alias pointing to a file using the package.alias field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliased-file',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply a global module alias pointing to a file using the package.alias field","suites":["resolver","aliases"],"updatePoint":{"line":1045,"column":91,"index":45597},"line":1045,"code":"    it('should apply a global module alias pointing to a file using the package.alias field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliased-file',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'package-alias', 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply an alias for a virtual module folder (relative to project dir)","suites":["resolver","aliases"],"updatePoint":{"line":1060,"column":83,"index":46180},"line":1060,"code":"    it('should apply an alias for a virtual module folder (relative to project dir)', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliasedfolder/test.js',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'nested', 'test.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply an alias for a virtual module folder only (relative to project dir)","suites":["resolver","aliases"],"updatePoint":{"line":1078,"column":88,"index":46856},"line":1078,"code":"    it('should apply an alias for a virtual module folder only (relative to project dir)', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliasedfolder',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'nested', 'index.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested')\n        }, {\n          filePath: path.join(rootDir, 'nested')\n        }, {\n          filePath: path.join(rootDir, 'nested.js')\n        }, {\n          filePath: path.join(rootDir, 'nested.jsx')\n        }, {\n          filePath: path.join(rootDir, 'nested.cjs')\n        }, {\n          filePath: path.join(rootDir, 'nested.mjs')\n        }, {\n          filePath: path.join(rootDir, 'nested.ts')\n        }, {\n          filePath: path.join(rootDir, 'nested.tsx')\n        }, {\n          filePath: path.join(rootDir, 'nested', 'package.json')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply an alias for a virtual module folder (relative to root dir)","suites":["resolver","aliases"],"updatePoint":{"line":1112,"column":80,"index":48051},"line":1112,"code":"    it('should apply an alias for a virtual module folder (relative to root dir)', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliasedabsolute/test.js',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'nested', 'test.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply an alias for a virtual module folder only (relative to root dir)","suites":["resolver","aliases"],"updatePoint":{"line":1130,"column":85,"index":48726},"line":1130,"code":"    it('should apply an alias for a virtual module folder only (relative to root dir)', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliasedabsolute',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'nested', 'index.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested')\n        }, {\n          filePath: path.join(rootDir, 'nested')\n        }, {\n          filePath: path.join(rootDir, 'nested.js')\n        }, {\n          filePath: path.join(rootDir, 'nested.jsx')\n        }, {\n          filePath: path.join(rootDir, 'nested.cjs')\n        }, {\n          filePath: path.join(rootDir, 'nested.mjs')\n        }, {\n          filePath: path.join(rootDir, 'nested.ts')\n        }, {\n          filePath: path.join(rootDir, 'nested.tsx')\n        }, {\n          filePath: path.join(rootDir, 'nested', 'package.json')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply an alias for a virtual module folder sub-path","suites":["resolver","aliases"],"updatePoint":{"line":1164,"column":66,"index":49909},"line":1164,"code":"    it('should apply an alias for a virtual module folder sub-path', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'foo/bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply an alias for a virtual module folder glob sub-path","suites":["resolver","aliases"],"updatePoint":{"line":1179,"column":71,"index":50442},"line":1179,"code":"    it('should apply an alias for a virtual module folder glob sub-path', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'glob/bar/test',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'nested', 'test.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply an alias for a virtual module","suites":["resolver","aliases"],"updatePoint":{"line":1197,"column":50,"index":51072},"line":1197,"code":"    it('should apply an alias for a virtual module', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'something',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'nested', 'test.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply a global alias for a virtual module","suites":["resolver","aliases"],"updatePoint":{"line":1215,"column":56,"index":51704},"line":1215,"code":"    it('should apply a global alias for a virtual module', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'something',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'package-alias', 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(rootDir, 'nested', 'test.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve to an empty file when package.browser resolves to false","suites":["resolver","aliases"],"updatePoint":{"line":1233,"column":78,"index":52391},"line":1233,"code":"    it('should resolve to an empty file when package.browser resolves to false', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-browser-exclude',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(__dirname, '..', 'src', '_empty.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/package-browser-exclude',\n          aboveFilePath: rootDir\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'package-browser-exclude', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve to an empty file when package.alias resolves to false","suites":["resolver","aliases"],"updatePoint":{"line":1251,"column":76,"index":53183},"line":1251,"code":"    it('should resolve to an empty file when package.alias resolves to false', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-alias-exclude',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        filePath: path.join(__dirname, '..', 'src', '_empty.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/package-alias-exclude',\n          aboveFilePath: rootDir\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'package-alias-exclude', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should use the source field, when its realpath is not under `node_modules`","suites":["resolver","source field","package behind symlinks"],"updatePoint":{"line":1272,"column":84,"index":54078},"line":1272,"code":"      it('should use the source field, when its realpath is not under `node_modules`', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'source',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        check(resolved, {\n          filePath: path.join(rootDir, 'packages', 'source', 'source.js'),\n          sideEffects: undefined,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'node_modules/source',\n            aboveFilePath: rootDir\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'source', 'package.json'), path.join(rootDir, 'packages', 'source', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should prioritize the source field over exports","suites":["resolver","source field","package behind symlinks"],"updatePoint":{"line":1290,"column":57,"index":54899},"line":1290,"code":"      it('should prioritize the source field over exports', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'source-exports',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        check(resolved, {\n          filePath: path.join(rootDir, 'packages', 'source-exports', 'source.js'),\n          sideEffects: undefined,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'node_modules/source-exports',\n            aboveFilePath: rootDir\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'source-exports', 'package.json'), path.join(rootDir, 'packages', 'source-exports', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not use the source field, when its realpath is under `node_modules`","suites":["resolver","source field","package behind symlinks"],"updatePoint":{"line":1308,"column":84,"index":55787},"line":1308,"code":"      it('should not use the source field, when its realpath is under `node_modules`', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'source-pnpm',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        check(resolved, {\n          filePath: path.join(rootDir, 'node_modules', '.pnpm', 'source-pnpm@1.0.0', 'node_modules', 'source-pnpm', 'dist.js'),\n          sideEffects: undefined,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'node_modules/source-pnpm',\n            aboveFilePath: rootDir\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'source-pnpm', 'package.json'), path.join(rootDir, 'node_modules', '.pnpm', 'source-pnpm@1.0.0', 'node_modules', 'source-pnpm', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not use the source field","suites":["resolver","source field","package not behind symlinks"],"updatePoint":{"line":1328,"column":41,"index":56781},"line":1328,"code":"      it('should not use the source field', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'source-not-symlinked',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        check(resolved, {\n          filePath: path.join(rootDir, 'node_modules', 'source-not-symlinked', 'dist.js'),\n          sideEffects: undefined,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'node_modules/source-not-symlinked',\n            aboveFilePath: rootDir\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'tsconfig.json'), path.join(rootDir, 'node_modules', 'source-not-symlinked', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a browser development import","suites":["resolver","package exports"],"updatePoint":{"line":1349,"column":51,"index":57654},"line":1349,"code":"    it('should resolve a browser development import', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-conditions',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(resolved?.filePath, path.join(rootDir, 'node_modules/package-conditions/browser-import-dev.mjs'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a browser development require","suites":["resolver","package exports"],"updatePoint":{"line":1358,"column":52,"index":58052},"line":1358,"code":"    it('should resolve a browser development require', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-conditions',\n        specifierType: 'commonjs',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(resolved?.filePath, path.join(rootDir, 'node_modules/package-conditions/browser-require-dev.cjs'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a browser production import","suites":["resolver","package exports"],"updatePoint":{"line":1367,"column":50,"index":58454},"line":1367,"code":"    it('should resolve a browser production import', async function () {\n      let resolved = await prodResolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-conditions',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(resolved?.filePath, path.join(rootDir, 'node_modules/package-conditions/browser-import-prod.mjs'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a browser development require","suites":["resolver","package exports"],"updatePoint":{"line":1376,"column":52,"index":58857},"line":1376,"code":"    it('should resolve a browser development require', async function () {\n      let resolved = await prodResolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-conditions',\n        specifierType: 'commonjs',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(resolved?.filePath, path.join(rootDir, 'node_modules/package-conditions/browser-require-prod.cjs'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a node import","suites":["resolver","package exports"],"updatePoint":{"line":1385,"column":36,"index":59250},"line":1385,"code":"    it('should resolve a node import', async function () {\n      let resolved = await resolver.resolve({\n        env: NODE_INCLUDE_ENV,\n        filename: 'package-conditions',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(resolved?.filePath, path.join(rootDir, 'node_modules/package-conditions/node-import.mjs'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a node require","suites":["resolver","package exports"],"updatePoint":{"line":1394,"column":37,"index":59631},"line":1394,"code":"    it('should resolve a node require', async function () {\n      let resolved = await resolver.resolve({\n        env: NODE_INCLUDE_ENV,\n        filename: 'package-conditions',\n        specifierType: 'commonjs',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(resolved?.filePath, path.join(rootDir, 'node_modules/package-conditions/node-require.cjs'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve symlinked files to their realpath","suites":["resolver","symlinks"],"updatePoint":{"line":1405,"column":56,"index":60080},"line":1405,"code":"    it('should resolve symlinked files to their realpath', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './baz.js',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'bar.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve symlinked directories to their realpath","suites":["resolver","symlinks"],"updatePoint":{"line":1414,"column":62,"index":60441},"line":1414,"code":"    it('should resolve symlinked directories to their realpath', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './symlinked-nested',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'nested', 'index.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should return diagnostics when package.module does not exist","suites":["resolver","error handling"],"updatePoint":{"line":1425,"column":68,"index":60879},"line":1425,"code":"    it('should return diagnostics when package.module does not exist', async function () {\n      let result = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-module-fallback',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(nullthrows(result).diagnostics)[0].message, `Could not load './module.js' from module 'package-module-fallback' found in package.json#module`);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should throw when a relative path cannot be resolved","suites":["resolver","error handling"],"updatePoint":{"line":1434,"column":60,"index":61344},"line":1434,"code":"    it('should throw when a relative path cannot be resolved', async function () {\n      let result = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './xyz.js',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(nullthrows(result).diagnostics)[0].message, `Cannot load file './xyz.js' in './'.`);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should throw when a node_module cannot be resolved","suites":["resolver","error handling"],"updatePoint":{"line":1443,"column":58,"index":61733},"line":1443,"code":"    it('should throw when a node_module cannot be resolved', async function () {\n      let result = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'food',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(nullthrows(nullthrows(result).diagnostics)[0], {\n        message: `Cannot find module 'food'`,\n        hints: [`Did you mean '__foo__'?`]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should throw when a subfile of a node_module cannot be resolved","suites":["resolver","error handling"],"updatePoint":{"line":1455,"column":71,"index":62187},"line":1455,"code":"    it('should throw when a subfile of a node_module cannot be resolved', async function () {\n      let result = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'foo/bark',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(nullthrows(nullthrows(result).diagnostics)[0], {\n        message: `Cannot load file './bark' from module 'foo'`,\n        hints: [`Did you mean '__foo/bar__'?`]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should error when a library is missing an external dependency","suites":["resolver","error handling"],"updatePoint":{"line":1467,"column":69,"index":62665},"line":1467,"code":"    it('should error when a library is missing an external dependency', async function () {\n      let result = await resolver.resolve({\n        env: new Environment(createEnvironment({\n          context: 'browser',\n          isLibrary: true,\n          includeNodeModules: false\n        }), DEFAULT_OPTIONS),\n        filename: 'test',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js'),\n        sourcePath: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(result?.diagnostics?.[0].message, 'External dependency \"test\" is not declared in package.json.');\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not error when external dependencies are declared","suites":["resolver","error handling"],"updatePoint":{"line":1481,"column":64,"index":63254},"line":1481,"code":"    it('should not error when external dependencies are declared', async function () {\n      let result = await resolver.resolve({\n        env: new Environment(createEnvironment({\n          context: 'browser',\n          isLibrary: true,\n          includeNodeModules: false\n        }), DEFAULT_OPTIONS),\n        filename: 'foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js'),\n        sourcePath: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(result, {\n        isExcluded: true,\n        invalidateOnFileChange: [],\n        invalidateOnFileCreate: []\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not error when external dependencies are declared in peerDependencies","suites":["resolver","error handling"],"updatePoint":{"line":1499,"column":84,"index":63885},"line":1499,"code":"    it('should not error when external dependencies are declared in peerDependencies', async function () {\n      let result = await resolver.resolve({\n        env: new Environment(createEnvironment({\n          context: 'browser',\n          isLibrary: true,\n          includeNodeModules: false\n        }), DEFAULT_OPTIONS),\n        filename: 'bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js'),\n        sourcePath: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(result, {\n        isExcluded: true,\n        invalidateOnFileChange: [],\n        invalidateOnFileCreate: []\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not error on missing dependencies for environment builtins","suites":["resolver","error handling"],"updatePoint":{"line":1517,"column":73,"index":64505},"line":1517,"code":"    it('should not error on missing dependencies for environment builtins', async function () {\n      let result = await resolver.resolve({\n        env: new Environment(createEnvironment({\n          context: 'browser',\n          isLibrary: true,\n          includeNodeModules: false\n        }), DEFAULT_OPTIONS),\n        filename: 'atom',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'env-dep/foo.js'),\n        sourcePath: path.join(rootDir, 'env-dep/foo.js')\n      });\n      assert.deepEqual(result, {\n        isExcluded: true,\n        invalidateOnFileChange: [],\n        invalidateOnFileCreate: []\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not error on builtin node modules","suites":["resolver","error handling"],"updatePoint":{"line":1535,"column":48,"index":65117},"line":1535,"code":"    it('should not error on builtin node modules', async function () {\n      let result = await resolver.resolve({\n        env: new Environment(createEnvironment({\n          context: 'browser',\n          isLibrary: true,\n          includeNodeModules: false\n        }), DEFAULT_OPTIONS),\n        filename: 'buffer',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'env-dep/foo.js'),\n        sourcePath: path.join(rootDir, 'env-dep/foo.js')\n      });\n      assert.deepEqual(result, {\n        isExcluded: true\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should error when a library has an incorrect external dependency version","suites":["resolver","error handling"],"updatePoint":{"line":1551,"column":80,"index":65691},"line":1551,"code":"    it('should error when a library has an incorrect external dependency version', async function () {\n      let result = await resolver.resolve({\n        env: new Environment(createEnvironment({\n          context: 'browser',\n          isLibrary: true,\n          includeNodeModules: false\n        }), DEFAULT_OPTIONS),\n        filename: 'foo',\n        specifierType: 'esm',\n        range: '^0.4.0',\n        parent: path.join(rootDir, 'foo.js'),\n        sourcePath: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(result?.diagnostics?.[0].message, 'External dependency \"foo\" does not satisfy required semver range \"^0.4.0\".');\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should error when package.json is invalid","suites":["resolver","error handling"],"updatePoint":{"line":1566,"column":49,"index":66304},"line":1566,"code":"    it('should error when package.json is invalid', async function () {\n      let result = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'json-error',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      let file = path.join(rootDir, 'node_modules', 'json-error', 'package.json');\n      assert.deepEqual(result?.diagnostics, [{\n        message: 'Error parsing JSON',\n        codeFrames: [{\n          language: 'json',\n          filePath: file,\n          code: await overlayFS.readFile(file, 'utf8'),\n          codeHighlights: [{\n            message: 'expected `,` or `}` at line 3 column 3',\n            start: {\n              line: 3,\n              column: 3\n            },\n            end: {\n              line: 3,\n              column: 3\n            }\n          }]\n        }]\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should error on an invalid empty specifier","suites":["resolver","error handling"],"updatePoint":{"line":1594,"column":50,"index":67164},"line":1594,"code":"    it('should error on an invalid empty specifier', async function () {\n      let result = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(result?.diagnostics, [{\n        message: 'Invalid empty specifier'\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should error on unknown URL schemes","suites":["resolver","error handling"],"updatePoint":{"line":1605,"column":43,"index":67516},"line":1605,"code":"    it('should error on unknown URL schemes', async function () {\n      let result = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'http://parceljs.org',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js'),\n        loc: {\n          filePath: path.join(rootDir, 'foo.js'),\n          start: {\n            line: 1,\n            column: 1\n          },\n          end: {\n            line: 1,\n            column: 10\n          }\n        }\n      });\n      assert.deepEqual(result?.diagnostics, [{\n        message: `Unknown url scheme or pipeline 'http:'`\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should error on non-exported package paths","suites":["resolver","error handling"],"updatePoint":{"line":1627,"column":50,"index":68133},"line":1627,"code":"    it('should error on non-exported package paths', async function () {\n      let result = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-exports/internal',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      let file = path.join(rootDir, 'node_modules/package-exports/package.json');\n      assert.deepEqual(result?.diagnostics, [{\n        message: `Module 'package-exports/internal' is not exported from the 'package-exports' package`,\n        codeFrames: [{\n          language: 'json',\n          filePath: file,\n          code: await overlayFS.readFile(file, 'utf8'),\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 4,\n              column: 14\n            },\n            end: {\n              line: 13,\n              column: 3\n            }\n          }]\n        }]\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should error when export does not exist","suites":["resolver","error handling"],"updatePoint":{"line":1655,"column":47,"index":69040},"line":1655,"code":"    it('should error when export does not exist', async function () {\n      let result = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-exports/missing',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(result?.diagnostics, [{\n        message: `Cannot load file './missing.mjs' from module 'package-exports'`,\n        hints: []\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should error on undefined package imports","suites":["resolver","error handling"],"updatePoint":{"line":1667,"column":49,"index":69479},"line":1667,"code":"    it('should error on undefined package imports', async function () {\n      let result = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '#foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      let file = path.join(rootDir, 'package.json');\n      assert.deepEqual(result?.diagnostics, [{\n        message: `Package import '#foo' is not defined in the 'resolver' package`,\n        codeFrames: [{\n          language: 'json',\n          filePath: file,\n          code: await overlayFS.readFile(file, 'utf8'),\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 15,\n              column: 14\n            },\n            end: {\n              line: 17,\n              column: 3\n            }\n          }]\n        }]\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should error when package.json doesn't define imports field","suites":["resolver","error handling"],"updatePoint":{"line":1695,"column":67,"index":70336},"line":1695,"code":"    it(\"should error when package.json doesn't define imports field\", async function () {\n      let result = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '#foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'foo', 'foo.js')\n      });\n      let file = path.join(rootDir, 'node_modules', 'foo', 'package.json');\n      assert.deepEqual(result?.diagnostics, [{\n        message: `Package import '#foo' is not defined in the 'foo' package`,\n        codeFrames: [{\n          language: 'json',\n          filePath: file,\n          code: await overlayFS.readFile(file, 'utf8'),\n          codeHighlights: []\n        }]\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should error when a package.json couldn't be found","suites":["resolver","error handling"],"updatePoint":{"line":1713,"column":58,"index":71014},"line":1713,"code":"    it(\"should error when a package.json couldn't be found\", async function () {\n      let result = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '#foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'tsconfig-not-used', 'foo.js')\n      });\n      assert.deepEqual(result?.diagnostics, [{\n        message: `Cannot find a package.json above './node\\\\_modules/tsconfig-not-used'`\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should error when a tsconfig.json extends couldn't be found","suites":["resolver","error handling"],"updatePoint":{"line":1724,"column":67,"index":71477},"line":1724,"code":"    it(\"should error when a tsconfig.json extends couldn't be found\", async function () {\n      let result = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'tsconfig', 'extends-not-found', 'index.js')\n      });\n      let file = path.join(rootDir, 'tsconfig', 'extends-not-found', 'tsconfig.json');\n      assert.deepEqual(result?.diagnostics, [{\n        message: 'Could not find extended tsconfig',\n        codeFrames: [{\n          language: 'json',\n          filePath: file,\n          code: await overlayFS.readFile(file, 'utf8'),\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 2,\n              column: 14\n            },\n            end: {\n              line: 2,\n              column: 26\n            }\n          }]\n        }]\n      }, {\n        message: \"Cannot load file './not-found' in './tsconfig/extends-not-found'.\",\n        hints: []\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should ignore protocol relative urls","suites":["resolver","urls"],"updatePoint":{"line":1757,"column":44,"index":72504},"line":1757,"code":"    it('should ignore protocol relative urls', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '//example.com/foo.png',\n        specifierType: 'url',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        isExcluded: true\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should ignore hash urls","suites":["resolver","urls"],"updatePoint":{"line":1768,"column":31,"index":72825},"line":1768,"code":"    it('should ignore hash urls', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '#hash',\n        specifierType: 'url',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        isExcluded: true\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should ignore http: urls","suites":["resolver","urls"],"updatePoint":{"line":1779,"column":32,"index":73131},"line":1779,"code":"    it('should ignore http: urls', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'http://example.com/foo.png',\n        specifierType: 'url',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      check(resolved, {\n        isExcluded: true\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"supports custom extensions","suites":["resolver","options"],"updatePoint":{"line":1792,"column":34,"index":73502},"line":1792,"code":"    it('supports custom extensions', async function () {\n      let resolver = new NodeResolver({\n        fs: overlayFS,\n        projectRoot: rootDir,\n        mode: 'development',\n        extensions: ['html']\n      });\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.ts')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'bar.html'));\n      resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.ts')\n      });\n      assert.equal(nullthrows(resolved).filePath, null);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"supports custom mainFields","suites":["resolver","options"],"updatePoint":{"line":1814,"column":34,"index":74232},"line":1814,"code":"    it('supports custom mainFields', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-types',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.ts')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'node_modules', 'package-types', 'main.js'));\n      let typesResolver = new NodeResolver({\n        fs: overlayFS,\n        projectRoot: rootDir,\n        mode: 'development',\n        mainFields: ['types', 'main']\n      });\n      resolved = await typesResolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-types',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.ts')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'node_modules', 'package-types', 'types.d.ts'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"}]}