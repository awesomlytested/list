{"repo":"pubkey/rxdb","url":"https://github.com/pubkey/rxdb","branch":"master","configs":[{"package":"angular","lang":"ts","dir":"examples/angular/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"rxdb-example-electron-remote","lang":"js","dir":"examples/electron-remote/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"rxdb-example-electron","lang":"js","dir":"examples/electron/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"graphql","lang":"js","dir":"examples/graphql/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"rxdb-example-react","lang":"js","dir":"examples/react/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"svelte-app","lang":"js","dir":"examples/svelte/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"vue2","lang":"js","dir":"examples/vue/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"rxdb","lang":"ts","dir":"test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"wait for first request until the server has bootet","suites":["ssr.test.ts"],"updatePoint":{"line":18,"column":58},"line":18,"code":"    it('wait for first request until the server has bootet', async () => {\n        await waitUntil(\n            async () => {\n                try {\n                    await getHtml(baseUrl);\n                    return true;\n                } catch (err) {\n                    console.log('-- waiting for server to start');\n                    return false;\n                }\n            },\n            undefined,\n            1000\n        );\n    });","file":"ssr.test.ts","skipped":false,"dir":"examples/angular/test"},{"name":"should get some html","suites":["ssr.test.ts"],"updatePoint":{"line":34,"column":28},"line":34,"code":"    it('should get some html', async () => {\n        console.log('run first request');\n        const html = await getHtml(baseUrl);\n        console.log('run first request DONE');\n        assert.ok(html);\n    });","file":"ssr.test.ts","skipped":false,"dir":"examples/angular/test"},{"name":"should contain data from the rxdb instance","suites":["ssr.test.ts"],"updatePoint":{"line":40,"column":50},"line":40,"code":"    it('should contain data from the rxdb instance', async function () {\n        /**\n         * If the timeout of 5 seconds is not enough,\n         * there is likely something wrong with RxDB.\n         * For example an open setTimeout prevents ssr from knowing the page is loaded\n         */\n        this.timeout(1000 * 5);\n        const html = await getHtml(baseUrl);\n        assert.ok(html.includes('Gandalf'));\n    });","file":"ssr.test.ts","skipped":false,"dir":"examples/angular/test"},{"name":"reach couchdb server","suites":["couchdb-db-integration.test.js"],"updatePoint":{"line":31,"column":28},"line":31,"code":"    it('reach couchdb server', async function () {\n        /**\n         * After the couchdb container is started,\n         * it can take some time until the replication endpoint is reachable\n         */\n        this.timeout(1000 * 60);\n\n        await waitUntil(async () => {\n            try {\n                const gotJson = await request(COUCHDB_URL);\n                // ensure json is parseable\n                JSON.parse(gotJson);\n                return true;\n            } catch (err) {\n                console.error('could not reach couchdb server at ' + COUCHDB_URL);\n                return false;\n            }\n        }, 1000 * 60, 1000);\n    });","file":"couch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"sync to couchdb","suites":["couchdb-db-integration.test.js"],"updatePoint":{"line":51,"column":23},"line":51,"code":"    it('sync to couchdb', async () => {\n        const col = await humansCollection.create(0);\n\n        const couchName = COUCHDB_URL + randomCouchString(12);\n        const replicationState = await col.syncCouchDB({\n            remote: couchName,\n            waitForLeadership: false,\n            direction: {\n                pull: true,\n                push: true\n            }\n        });\n        replicationState.docs$.subscribe(docData => console.dir(docData));\n\n        // add 3 docs\n        await Promise.all(\n            new Array(3)\n                .fill(0)\n                .map(() => col.insert(schemaObjects.human()))\n        );\n        const docs1 = await col.find().exec();\n        assert.strictEqual(docs1.length, 3);\n\n\n        // create a new collection\n        const col2 = await humansCollection.create(0);\n        await col2.syncCouchDB({\n            remote: couchName,\n            waitForLeadership: false,\n            direction: {\n                pull: true,\n                push: true\n            }\n        });\n\n        await waitUntil(async () => {\n            const docs = await col2.find().exec();\n            return docs.length === 3;\n        });\n\n        col.database.destroy();\n        col2.database.destroy();\n    });","file":"couch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"clear stuff","suites":["performance.test.js"],"updatePoint":{"line":191,"column":23},"line":191,"code":"        it('clear stuff', async () => {\n            await clearStuff();\n        });","file":"performance.test.ts","skipped":false,"dir":"test"},{"name":"spawnDatabases","suites":["performance.test.js"],"updatePoint":{"line":199,"column":26},"line":199,"code":"        it('spawnDatabases', async () => {\n            // create databases with some collections each\n            const dbs: RxDatabase[] = [];\n\n            /**\n             * Reuse the same instance of RxStorage\n             * to measure database creation time,\n             * not storage instantiation.\n             */\n            const useStorage = STORAGE.getStorage();\n\n            const startTime = nowTime();\n            for (let i = 0; i < benchmark.spawnDatabases.amount; i++) {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    eventReduce: true,\n                    /**\n                     * A RxStorage implementation (like LokiJS)\n                     * might need a full leader election cycle to be useable.\n                     * So we disable multiInstance here because it would make no sense\n                     * to measure the leader election time instead of the database\n                     * creation time.\n                     */\n                    multiInstance: false,\n                    storage: useStorage\n                });\n                dbs.push(db);\n\n                const collectionData: any = {};\n                new Array(benchmark.spawnDatabases.collections)\n                    .fill(0)\n                    .forEach(() => {\n                        const name = 'human' + randomCouchString(10);\n                        collectionData[name] = {\n                            schema: schemas.averageSchema(),\n                            statics: ormMethods\n                        };\n                    });\n                await db.addCollections(collectionData);\n            }\n            const elapsed = elapsedTime(startTime);\n            benchmark.spawnDatabases.total = benchmark.spawnDatabases.total + elapsed;\n            benchmark.spawnDatabases.perInstance = elapsed / benchmark.spawnDatabases.amount;\n\n            await Promise.all(dbs.map(db => db.destroy()));\n            await afterTest();\n        });","file":"performance.test.ts","skipped":false,"dir":"test"},{"name":"clear stuff","suites":["performance.test.js"],"updatePoint":{"line":246,"column":23},"line":246,"code":"        it('clear stuff', async () => {\n            await clearStuff();\n        });","file":"performance.test.ts","skipped":false,"dir":"test"},{"name":"insertDocuments","suites":["performance.test.js"],"updatePoint":{"line":250,"column":27},"line":250,"code":"        it('insertDocuments', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                eventReduce: true,\n                multiInstance: false,\n                storage: STORAGE.getStorage()\n            });\n            const cols = await db.addCollections({\n                human: {\n                    schema: schemas.averageSchema(),\n                    methods: ormMethods\n                }\n            });\n            const col = cols.human;\n            let lastDoc;\n\n            const docsData = new Array(benchmark.insertDocuments.blocks * benchmark.insertDocuments.blockSize)\n                .fill(0)\n                .map(() => schemaObjects.averageSchema());\n\n            const startTime = nowTime();\n            for (let i = 0; i < benchmark.insertDocuments.blocks; i++) {\n                await Promise.all(\n                    new Array(benchmark.insertDocuments.blockSize)\n                        .fill(0)\n                        .map(async () => {\n                            const doc = await col.insert(docsData.pop());\n                            lastDoc = doc;\n                        })\n                );\n            }\n            const elapsed = elapsedTime(startTime);\n            assert.ok(lastDoc);\n            benchmark.insertDocuments.total = benchmark.insertDocuments.total + elapsed;\n            benchmark.insertDocuments.perBlock = elapsed / benchmark.insertDocuments.blocks;\n\n            await db.destroy();\n            await afterTest();\n        });","file":"performance.test.ts","skipped":false,"dir":"test"},{"name":"findDocuments","suites":["performance.test.js"],"updatePoint":{"line":290,"column":25},"line":290,"code":"        it('findDocuments', async () => {\n            const dbName = path.join(\n                __dirname,\n                '../',\n                'test_tmp',\n                randomCouchString(10)\n            );\n\n            const schema = schemas.averageSchema();\n\n            const db = await createRxDatabase({\n                name: dbName,\n                eventReduce: true,\n                multiInstance: true,\n                storage: STORAGE.getPersistendStorage()\n            });\n            const cols = await db.addCollections({\n                human: {\n                    schema,\n                    methods: ormMethods\n                }\n            });\n            const col = cols.human;\n\n            await col.bulkInsert(\n                new Array(benchmark.findDocuments.amount)\n                    .fill(0)\n                    .map(() => schemaObjects.averageSchema())\n            );\n            await db.destroy();\n\n            const db2 = await createRxDatabase({\n                name: dbName,\n                storage: STORAGE.getPersistendStorage(),\n                eventReduce: true,\n                multiInstance: true,\n                ignoreDuplicate: true\n            });\n\n            const cols2 = await db2.addCollections({\n                human: {\n                    schema,\n                    methods: ormMethods\n                }\n            });\n            const col2 = cols2.human;\n\n\n            const startTime = nowTime();\n            const allDocs = await col2.find().exec();\n            const elapsed = elapsedTime(startTime);\n\n            assert.strictEqual(allDocs.length, benchmark.findDocuments.amount);\n            benchmark.findDocuments.total = benchmark.findDocuments.total + elapsed;\n            benchmark.findDocuments.perDocument = elapsed / benchmark.findDocuments.amount;\n\n            await db2.destroy();\n            await afterTest();\n        });","file":"performance.test.ts","skipped":false,"dir":"test"},{"name":"migrateDocuments","suites":["performance.test.js"],"updatePoint":{"line":350,"column":28},"line":350,"code":"        it('migrateDocuments', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                eventReduce: true,\n                storage: STORAGE.getStorage()\n            });\n            const cols = await db.addCollections({\n                human: {\n                    schema: schemas.averageSchema()\n                }\n            });\n            const col = cols.human;\n\n            // insert into old collection\n            await Promise.all(\n                new Array(benchmark.migrateDocuments.amount)\n                    .fill(0)\n                    .map(() => schemaObjects.averageSchema())\n                    .map(docData => col.insert(docData))\n            );\n\n            const db2 = await createRxDatabase({\n                name,\n                eventReduce: true,\n                storage: STORAGE.getStorage(),\n                ignoreDuplicate: true\n            });\n            const newSchema = schemas.averageSchema();\n            newSchema.version = 1;\n            newSchema.properties.var2.type = 'string';\n            const cols2 = await db2.addCollections({\n                human: {\n                    schema: newSchema,\n                    migrationStrategies: {\n                        1: (oldDoc: any) => {\n                            oldDoc.var2 = oldDoc.var2 + '';\n                            return oldDoc;\n                        }\n                    },\n                    autoMigrate: false\n                }\n            });\n            const col2 = cols2.human;\n\n            const startTime = nowTime();\n\n            await col2.migratePromise();\n            const elapsed = elapsedTime(startTime);\n            benchmark.migrateDocuments.total = benchmark.migrateDocuments.total + elapsed;\n\n            await db.destroy();\n            await db2.destroy();\n            await afterTest();\n        });","file":"performance.test.ts","skipped":false,"dir":"test"},{"name":"writeWhileSubscribe","suites":["performance.test.js"],"updatePoint":{"line":405,"column":31},"line":405,"code":"        it('writeWhileSubscribe', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                eventReduce: true,\n                storage: STORAGE.getStorage()\n            });\n            const cols = await db.addCollections({\n                human: {\n                    schema: schemas.averageSchema()\n                }\n            });\n            const col = cols.human;\n\n            const query = col.find({\n                selector: {\n                    var2: {\n                        $gt: 1\n                    }\n                },\n                sort: [\n                    { var1: 'asc' }\n                ]\n            });\n\n            let t = 0;\n            let lastResult: any[] = [];\n            const startTime = nowTime();\n\n            await new Promise(res => {\n                const obs$ = query.$.pipe(\n                    mergeMap(async (result) => {\n                        if (t <= benchmark.writeWhileSubscribe.amount) {\n                            t++;\n                            await col.insert(schemaObjects.averageSchema());\n                        } else {\n                            // TODO why does this test fail when we directly unsubscribe?\n                            // sub.unsubscribe();\n                            res(null);\n                        }\n                        return result;\n                    })\n                );\n                obs$.subscribe(result => {\n                    lastResult = result;\n                });\n            });\n\n            const elapsed = elapsedTime(startTime);\n\n            await AsyncTestUtil.wait(500);\n\n            benchmark.writeWhileSubscribe.total = benchmark.writeWhileSubscribe.total + elapsed;\n            assert.strictEqual(lastResult.length, benchmark.writeWhileSubscribe.amount);\n            await db.destroy();\n\n            await afterTest();\n        });","file":"performance.test.ts","skipped":false,"dir":"test"},{"name":"show results:","suites":["performance.test.js"],"updatePoint":{"line":464,"column":25},"line":464,"code":"        it('show results:', async () => {\n            await afterTest();\n            console.log(JSON.stringify(benchmark, null, 2));\n        });","file":"performance.test.ts","skipped":false,"dir":"test"},{"name":"should sucess on basic test","suites":["typings.test.js"],"updatePoint":{"line":87,"column":39},"line":87,"code":"        it('should sucess on basic test', async () => {\n            await transpileCode('console.log(\"Hello, world!\")');\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should fail on broken code","suites":["typings.test.js"],"updatePoint":{"line":90,"column":38},"line":90,"code":"        it('should fail on broken code', async () => {\n            const brokenCode = `\n                let x: string = 'foo';\n                x = 1337;\n            `;\n            let thrown = false;\n            try {\n                const code = await transpileCode(brokenCode);\n                console.dir(code);\n            } catch (err) {\n                thrown = true;\n            }\n            assert.ok(thrown);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"import * with strict:true","suites":["typings.test.js"],"updatePoint":{"line":106,"column":37},"line":106,"code":"        it('import * with strict:true', async () => {\n            const code = `\n                import { addPouchPlugin } from '${pouchdbPluginPath}';\n                import * as PouchMemAdapter from 'pouchdb-adapter-memory';\n                addPouchPlugin(PouchMemAdapter);\n            `;\n            await transpileCode(code);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should create the database and use its methods","suites":["typings.test.js","positive"],"updatePoint":{"line":117,"column":62},"line":117,"code":"            it('should create the database and use its methods', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const databaseCreator: RxDatabaseCreator = {\n                            name: 'mydb',\n                            storage: getRxStoragePouch('memory'),\n                            multiInstance: false,\n                            ignoreDuplicate: false\n                        };\n                        const myDb: RxDatabase = await createRxDatabase(databaseCreator);\n                        await myDb.destroy();\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"allow to type-define the collections","suites":["typings.test.js","positive"],"updatePoint":{"line":132,"column":52},"line":132,"code":"            it('allow to type-define the collections', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const db: RxDatabase<{\n                            foobar: RxCollection\n                        }> = {} as RxDatabase<{\n                            foobar: RxCollection\n                        }>;\n                        const col: RxCollection = db.foobar;\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"a collection-untyped database should allow all collection-getters","suites":["typings.test.js","positive"],"updatePoint":{"line":145,"column":81},"line":145,"code":"            it('a collection-untyped database should allow all collection-getters', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const db: RxDatabase = {} as RxDatabase;\n                        const col: RxCollection = db.foobar;\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"an collection-TYPED database should allow to access methods","suites":["typings.test.js","positive"],"updatePoint":{"line":154,"column":75},"line":154,"code":"            it('an collection-TYPED database should allow to access methods', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const db: RxDatabase = {} as RxDatabase;\n                        const col: RxCollection = db.foobar;\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"an allow to use a custom extends type","suites":["typings.test.js","positive"],"updatePoint":{"line":163,"column":53},"line":163,"code":"            it('an allow to use a custom extends type', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        type RxHeroesDatabase = RxDatabase<{\n                            hero: RxCollection;\n                        }>;\n                        const db: RxHeroesDatabase = await createRxDatabase<{\n                            hero: RxCollection;\n                        }>({\n                            name: 'heroes',\n                            storage: getRxStoragePouch('memory')\n                        });\n                        const col: RxCollection = db.hero;\n                        await db.destroy();\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should not allow additional parameters","suites":["typings.test.js","negative"],"updatePoint":{"line":183,"column":54},"line":183,"code":"            it('should not allow additional parameters', async () => {\n                const brokenCode = codeBase + `\n                    const databaseCreator: RxDatabaseCreator = {\n                        name: 'mydb',\n                        storage: getRxStoragePouch('memory'),\n                        multiInstance: false,\n                        ignoreDuplicate: false,\n                        foo: 'bar'\n                    };\n                `;\n                let thrown = false;\n                try {\n                    await transpileCode(brokenCode);\n                } catch (err) {\n                    thrown = true;\n                }\n                assert.ok(thrown);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"an collection-TYPED database should only allow known collection-getters","suites":["typings.test.js","negative"],"updatePoint":{"line":201,"column":87},"line":201,"code":"            it('an collection-TYPED database should only allow known collection-getters', async () => {\n                const brokenCode = codeBase + `\n                    (async() => {\n                        const db: RxDatabase<{\n                            foobar: RxCollection\n                        }> = {} as RxDatabase;\n                        const col: RxCollection = db.foobar;\n                        const col2: RxCollection = db.foobar2;\n                        db.destroy();\n                    })();\n                `;\n                let thrown = false;\n                try {\n                    await transpileCode(brokenCode);\n                } catch (err) {\n                    thrown = true;\n                }\n                assert.ok(thrown);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should work with DocType = any","suites":["typings.test.js","positive"],"updatePoint":{"line":226,"column":46},"line":226,"code":"            it('should work with DocType = any', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const schema: RxJsonSchema<any> = ${JSON.stringify(schemas.humanMinimal)};\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should allow creating generic schema based on a model","suites":["typings.test.js","positive"],"updatePoint":{"line":234,"column":69},"line":234,"code":"            it('should allow creating generic schema based on a model', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const databaseCreator: RxDatabaseCreator = {\n                            name: 'mydb',\n                            storage: getRxStoragePouch('memory'),\n                            multiInstance: false,\n                            ignoreDuplicate: false\n                        };\n                        const myDb: RxDatabase = await createRxDatabase(databaseCreator);\n                        const minimalHuman: RxJsonSchema<DefaultDocType> = ${JSON.stringify(schemas.humanMinimal)};\n                        const myCollections = await myDb.addCollections({\n                            humans: {\n                                schema: minimalHuman,\n                            }\n                        });\n                        await myDb.destroy();\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should not allow wrong properties when passing a model","suites":["typings.test.js","negative"],"updatePoint":{"line":257,"column":70},"line":257,"code":"            it('should not allow wrong properties when passing a model', async () => {\n                const brokenCode = codeBase + `\n                    (async() => {\n                        const databaseCreator: RxDatabaseCreator = {\n                            name: 'mydb',\n                            storage: getRxStoragePouch('memory'),\n                            multiInstance: false,\n                            ignoreDuplicate: false\n                        };\n                        const myDb: RxDatabase = await createRxDatabase(databaseCreator);\n\n                        const minimalHuman: RxJsonSchema<DefaultDocType> = ${JSON.stringify(schemas.humanMinimalBroken)};\n                        const myCollections = await myDb.addCollections({\n                            humans: {\n                                schema: minimalHuman,\n                            }\n                        });\n\n                        await myDb.destroy();\n                    })();\n                `;\n                let thrown = false;\n                try {\n                    await transpileCode(brokenCode);\n                } catch (err) {\n                    thrown = true;\n                }\n                assert.ok(thrown);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"collection-creation","suites":["typings.test.js","positive"],"updatePoint":{"line":292,"column":35},"line":292,"code":"            it('collection-creation', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const myDb: RxDatabase = await createRxDatabase({\n                            name: 'mydb',\n                            storage: getRxStoragePouch('memory'),\n                            multiInstance: false,\n                            ignoreDuplicate: false\n                        });\n                        const mySchema: RxJsonSchema<any> = ${JSON.stringify(schemas.human)};\n                        const cols = await myDb.addCollections({\n                            humans: {\n                                schema: mySchema,\n                                autoMigrate: false,\n                            }\n                        });\n                        const myCollections: RxCollection<any> = cols.humans;\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"typed collection should know its static orm methods","suites":["typings.test.js","positive"],"updatePoint":{"line":313,"column":67},"line":313,"code":"            it('typed collection should know its static orm methods', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const myDb: RxDatabase = await createRxDatabase({\n                            name: 'mydb',\n                            storage: getRxStoragePouch('memory'),\n                            multiInstance: false,\n                            ignoreDuplicate: false\n                        });\n                        const mySchema: RxJsonSchema<any> = ${JSON.stringify(schemas.human)};\n\n                        type staticMethods = {\n                            countAllDocuments: () => Promise<number>;\n                        }\n                        const myCollections = await myDb.addCollections({\n                            humans: {\n                                schema: mySchema,\n                                autoMigrate: false,\n                                statics: {\n                                    countAllDocuments: () => Promise.resolve(1)\n                                }\n                            }\n                        });\n                        const myCollection: RxCollection<any, any, staticMethods> = myCollections.humans as any;\n\n                        await myCollection.countAllDocuments();\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"use options","suites":["typings.test.js","positive"],"updatePoint":{"line":343,"column":27},"line":343,"code":"            it('use options', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const myDb: RxDatabase = await createRxDatabase({\n                            name: 'mydb',\n                            storage: getRxStoragePouch('memory'),\n                            multiInstance: false,\n                            ignoreDuplicate: false,\n                            options: {\n                                foo1: 'bar1'\n                            }\n                        });\n                        const mySchema: RxJsonSchema<any> = ${JSON.stringify(schemas.human)};\n                        const myCollections = await myDb.addCollections({\n                            humans: {\n                                schema: mySchema,\n                                autoMigrate: false,\n                                options: {\n                                    foo2: 'bar2'\n                                }\n                            }\n                        });\n                        const x: string = myDb.options.foo1;\n                        const y: string = myCollections.humans.options.foo2;\n                        myDb.destroy();\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"use underlaying pouchdb","suites":["typings.test.js","positive"],"updatePoint":{"line":372,"column":39},"line":372,"code":"            it('use underlaying pouchdb', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const myDb: RxDatabase = await createRxDatabase({\n                            name: 'mydb',\n                            storage: getRxStoragePouch('memory'),\n                            multiInstance: false,\n                            ignoreDuplicate: false,\n                            options: {\n                                foo1: 'bar1'\n                            }\n                        });\n                        const mySchema: RxJsonSchema<any> = ${JSON.stringify(schemas.human)};\n                        type docType = {\n                                foo: string\n                        };\n                        const cols = await myDb.addCollections({\n                            humans: {\n                                schema: mySchema,\n                                autoMigrate: false,\n                                options: {\n                                    foo2: 'bar2'\n                                }\n                            }\n                        });\n                        const myCollection: RxCollection<docType> = cols.humans;\n                        const result = await myCollection.storageInstance.internals.pouch.put({\n                            _id: 'foobar',\n                            foo: 'bar'\n                        });\n                        const docs = await myCollection.storageInstance.internals.pouch.allDocs();\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should not allow wrong collection-settings","suites":["typings.test.js","negative"],"updatePoint":{"line":409,"column":58},"line":409,"code":"            it('should not allow wrong collection-settings', async () => {\n                const brokenCode = codeBase + `\n                    (async() => {\n                        const myDb: RxDatabase = await createRxDatabase({\n                            name: 'mydb',\n                            storage: getRxStoragePouch('memory'),\n                            multiInstance: false,\n                            ignoreDuplicate: false\n                        });\n                        const mySchema: RxJsonSchema<any> = ${JSON.stringify(schemas.human)};\n                        await myDb.addCollections({\n                            humans: {\n                                schema: {}, // wrong schema format\n                                autoMigrate: false,\n                            }\n                        });\n                    })();\n                `;\n                let thrown = false;\n                try {\n                    await transpileCode(brokenCode);\n                } catch (err) {\n                    thrown = true;\n                }\n                assert.ok(thrown);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":".insert$ .update$ .remove$","suites":["typings.test.js","negative"],"updatePoint":{"line":438,"column":38},"line":438,"code":"        it('.insert$ .update$ .remove$', async () => {\n            const code = codeBase + `\n                (async() => {\n                    const myDb: RxDatabase = await createRxDatabase({\n                        name: 'mydb',\n                        storage: getRxStoragePouch('memory'),\n                        multiInstance: false,\n                        ignoreDuplicate: false\n                    });\n                    type docType = {\n                        firstName: string,\n                        lastName: string\n                    }\n                    const mySchema: RxJsonSchema<any> = ${JSON.stringify(schemas.human)};\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: mySchema,\n                            autoMigrate: false,\n                        }\n                    });\n\n                    const names: string[] = [];\n                    const revs: string[] = [];\n                    const sub1 = myCollections.humans.insert$.subscribe(cE => {\n                        names.push(cE.documentData.firstName);\n                        revs.push(cE.documentData._rev);\n                    });\n                })();\n            `;\n            await transpileCode(code);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should know the fields of the document","suites":["typings.test.js","negative"],"updatePoint":{"line":471,"column":50},"line":471,"code":"        it('should know the fields of the document', async () => {\n            const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n\n                    type DocType = {\n                        age: number,\n                        firstName: string,\n                        lastName: string,\n                        passportId: string\n                    };\n\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {},\n                            autoMigrate: false,\n                        }\n                    });\n\n                    const result = await myCollections.humans.findOne().exec();\n                    if(result === null) throw new Error('got no document');\n                    const oneDoc: RxDocument<DocType> = result;\n                    const id: string = oneDoc.passportId;\n                    const prim: string = oneDoc.primary;\n\n                    const otherResult = await myCollections.humans.findOne().exec();\n                    if(otherResult === null) throw new Error('got no other document');\n                    const otherDoc: RxDocument<DocType> = otherResult;\n                    const id2 = otherDoc.passportId;\n                });\n            `;\n            await transpileCode(code);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":".putAttachment()","suites":["typings.test.js","negative"],"updatePoint":{"line":504,"column":28},"line":504,"code":"        it('.putAttachment()', async () => {\n            const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n\n                    type DocType = {\n                        age: number,\n                        firstName: string,\n                        lastName: string,\n                        passportId: string\n                    };\n\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {},\n                            autoMigrate: false,\n                        }\n                    });\n\n                    const result = await myCollections.humans.findOne().exec(true);\n                    const oneDoc: RxDocument<DocType> = result;\n                    const attachment: RxAttachment<DocType> = await oneDoc.putAttachment({\n                        id: 'cat.txt',\n                        data: blobBufferUtil.createBlobBuffer('foo bar', 'text/plain'),\n                        type: 'text/plain'\n                    });\n                });\n            `;\n            await transpileCode(code);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":".toJSON() should have _rev","suites":["typings.test.js","negative"],"updatePoint":{"line":534,"column":38},"line":534,"code":"        it('.toJSON() should have _rev', async () => {\n            const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n\n                    type DocType = {\n                        age: number,\n                        firstName: string,\n                        lastName: string,\n                        passportId: string\n                    };\n\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {},\n                            autoMigrate: false,\n                        }\n                    });\n\n                    const result = await myCollections.humans.findOne().exec(true);\n                    const rev: string = result.toJSON(true)._rev;\n                });\n            `;\n            await transpileCode(code);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":".toJSON(false) should not have _rev","suites":["typings.test.js","negative"],"updatePoint":{"line":559,"column":47},"line":559,"code":"        it('.toJSON(false) should not have _rev', async () => {\n            const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n\n                    type DocType = {\n                        age: number,\n                        firstName: string,\n                        lastName: string,\n                        passportId: string\n                    };\n\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {},\n                            autoMigrate: false,\n                        }\n                    });\n                    const collection: RxCollection<{}> = myCollections.humans;\n\n                    const result = await collection.findOne().exec(true);\n                    const rev: string = result.toJSON(false)._rev;\n                });\n            `;\n            await AsyncTestUtil.assertThrows(\n                () => transpileCode(code),\n                Error,\n                '_rev'\n            );\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":".atomicUpdate()","suites":["typings.test.js","negative"],"updatePoint":{"line":589,"column":27},"line":589,"code":"        it('.atomicUpdate()', async () => {\n            const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n                    type DocType = {\n                        age: number,\n                        firstName: string,\n                        lastName: string,\n                        passportId: string\n                    };\n\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {},\n                            autoMigrate: false,\n                        }\n                    });\n                    const collection: RxCollection<DocType> = myCollections.humans;\n                    const doc = await collection.findOne().exec(true);\n                    await doc.atomicUpdate(docData => {\n                        const newData = {\n                            age: 23,\n                            firstName: 'bar',\n                            lastName: 'steve',\n                            passportId: 'lolol'\n                        };\n                        return newData;\n                    });\n                });\n            `;\n            await transpileCode(code);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should allow to type input data","suites":["typings.test.js","negative"],"updatePoint":{"line":623,"column":43},"line":623,"code":"        it('should allow to type input data', async () => {\n            const code = codeBase + `\n            (async() => {\n                const myDb: RxDatabase = {} as any;\n                const typedLocalDoc = await myDb.getLocal<{foo: string;}>('foobar');\n                const typedLocalDocInsert = await myDb.insertLocal<{foo: string;}>('foobar', { bar: 'foo' });\n\n                if (!typedLocalDoc) {\n                    throw new Error('local doc missing');\n                }\n\n                const x: string = typedLocalDoc.data.foo;\n                const x2: string = typedLocalDocInsert.data.foo;\n            });\n            `;\n            await AsyncTestUtil.assertThrows(\n                () => transpileCode(code),\n                Error\n            );\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should allow to type the return data","suites":["typings.test.js","negative"],"updatePoint":{"line":643,"column":48},"line":643,"code":"        it('should allow to type the return data', async () => {\n            const code = codeBase + `\n            (async() => {\n                const myDb: RxDatabase = {} as any;\n                const typedLocalDoc = await myDb.getLocal<{foo: string;}>('foobar');\n                const typedLocalDocUpsert = await myDb.upsertLocal<{foo: string;}>('foobar', { foo: 'bar' });\n\n                if (!typedLocalDoc) {\n                    throw new Error('local doc missing');\n                }\n\n                const x: string = typedLocalDoc.get('data').foo;\n                const x2: string = typedLocalDocUpsert.get('data').foo;\n            });\n            `;\n            await transpileCode(code);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should allow to access different property","suites":["typings.test.js","negative"],"updatePoint":{"line":660,"column":53},"line":660,"code":"        it('should allow to access different property', async () => {\n            const code = codeBase + `\n            (async() => {\n                const myDb: RxDatabase = {} as any;\n                const typedLocalDoc = await myDb.getLocal<{foo: string;}>('foobar');\n                const x: string = typedLocalDoc.data.bar;\n            });\n            `;\n            await AsyncTestUtil.assertThrows(\n                () => transpileCode(code),\n                Error\n            );\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should correctly recognize orm-methods","suites":["typings.test.js","orm"],"updatePoint":{"line":676,"column":54},"line":676,"code":"            it('should correctly recognize orm-methods', async () => {\n                const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {},\n                            methods: {\n                                foobar(){\n                                    return 'foobar';\n                                }\n                            }\n                        }\n                    });\n                    const myCollection: RxCollection<DefaultDocType, DefaultOrmMethods, {}> = myCollections.humans;\n\n                    // via insert\n                    const doc = await myCollection.insert({\n                        passportId: 'asdf',\n                        age: 10\n                    });\n                    const x: string = doc.foobar();\n\n                    // via query findOne()\n                    const doc2 = await myCollection.findOne('asdf').exec(true);\n                    const x2: string = doc.foobar();\n                });\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should know the types","suites":["typings.test.js","hooks"],"updatePoint":{"line":709,"column":37},"line":709,"code":"            it('should know the types', async () => {\n                const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {}\n                        }\n                    });\n                    const myCollection: RxCollection<DefaultDocType, DefaultOrmMethods> = myCollections.humans;\n                    let myNumber: number;\n                    let myString: string;\n                    myCollection.postInsert((data, doc) => {\n                            myNumber = doc.age;\n                            myNumber = data.age;\n                            myString = doc.foobar();\n                            return Promise.resolve();\n                    }, true);\n                });\n            `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should know the where-fields","suites":["typings.test.js","query"],"updatePoint":{"line":733,"column":44},"line":733,"code":"            it('should know the where-fields', async () => {\n                const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n\n                    type DocType = {\n                        age: number,\n                        firstName: string,\n                        lastName: string,\n                        passportId: string,\n                        nestedObject: {\n                            foo: string,\n                            bar: number\n                        }\n                    };\n\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {},\n                            autoMigrate: false,\n                        }\n                    });\n                    const myCollection: RxCollection<DocType> = myCollections.humans;\n\n                    const query = myCollection.findOne().where('nestedObject.foo').eq('foobar');\n                });\n            `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should know the parameters of the error","suites":["typings.test.js","rx-error"],"updatePoint":{"line":764,"column":55},"line":764,"code":"            it('should know the parameters of the error', async () => {\n                const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {},\n                            autoMigrate: false,\n                        }\n                    });\n\n                    try{\n                        await myCollections.humans.insert({ age: 4});\n                    } catch(err) {\n                        if ((err as any).rxdb) {\n                            (err as RxError).parameters.errors;\n                        } else {\n                            // handle regular Error class\n                        }\n                    }\n                });\n            `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should be a valid RxPlugin","suites":["typings.test.js","addRxPlugin"],"updatePoint":{"line":790,"column":42},"line":790,"code":"            it('should be a valid RxPlugin', async () => {\n                const code = codeBase + `\n                (async() => {\n                    const myPlugin: RxPlugin = {\n                        name: 'my-plugin',\n                        rxdb: true,\n                        prototypes: {\n                            RxDocument: () => {}\n                        }\n                    }\n                    addRxPlugin(myPlugin);\n                });\n            `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should be able to import and add a plugin","suites":["typings.test.js","addRxPlugin"],"updatePoint":{"line":805,"column":57},"line":805,"code":"            it('should be able to import and add a plugin', async () => {\n                const code = codeBase + `\n                import { RxDBReplicationGraphQLPlugin } from '${config.rootPath}plugins/replication-graphql';\n                addRxPlugin(RxDBReplicationGraphQLPlugin);\n            `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"via gitter at 2018 Mai 22 19:20","suites":["typings.test.js","addRxPlugin"],"updatePoint":{"line":815,"column":43},"line":815,"code":"        it('via gitter at 2018 Mai 22 19:20', async () => {\n            const code = codeBase + `\n                (async() => {\n                    const db: RxDatabase = {} as RxDatabase;\n                    const heroSchema = {\n                        version: 0,\n                        type: 'object',\n                        primaryKey: 'id',\n                        properties: {\n                            id: {\n                                type: 'string'\n                            }\n                        },\n                        required: ['color']\n                    }\n                    const colCreator: RxCollectionCreator = {\n                        schema: heroSchema\n                    };\n                })();\n            `;\n            await transpileCode(code);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should be true on memory","suites":["outcome"],"updatePoint":{"line":23,"column":36},"line":23,"code":"        it('should be true on memory', async () => {\n            const ok2 = await checkAdapter('memory');\n            assert.ok(ok2);\n        });","file":"unit/adapter-check.test.ts","skipped":false,"dir":"test"},{"name":"should be false on invalid string","suites":["outcome"],"updatePoint":{"line":27,"column":45},"line":27,"code":"        it('should be false on invalid string', async () => {\n            const ok = await checkAdapter('foobar');\n            assert.strictEqual(ok, false);\n        });","file":"unit/adapter-check.test.ts","skipped":false,"dir":"test"},{"name":"should be true on memdown (leveldb-adapter)","suites":["outcome"],"updatePoint":{"line":31,"column":55},"line":31,"code":"        it('should be true on memdown (leveldb-adapter)', async () => {\n            const ok = await checkAdapter(memdown);\n            assert.ok(ok);\n        });","file":"unit/adapter-check.test.ts","skipped":false,"dir":"test"},{"name":"localstorage should be true on browser","suites":["outcome"],"updatePoint":{"line":35,"column":50},"line":35,"code":"        it('localstorage should be true on browser', async () => {\n            const should = config.platform.isNode() ? false : true;\n            const ok = await checkAdapter('idb');\n            assert.strictEqual(should, ok);\n        });","file":"unit/adapter-check.test.ts","skipped":false,"dir":"test"},{"name":"#715 Cleanup checkAdapter test databases after use","suites":["ISSUES"],"updatePoint":{"line":42,"column":62},"line":42,"code":"        it('#715 Cleanup checkAdapter test databases after use', async () => {\n            const ok = await checkAdapter(memdown);\n            assert.ok(ok);\n\n            // ensure the test-document is removed\n            const pouch = new (PouchDB as any)(\n                POUCHDB_LOCATION,\n                adapterObject(memdown) as any,\n                {\n                    auto_compaction: false, // no compaction because this only stores local documents\n                    revs_limit: 1\n                }\n            );\n\n            const found = await pouch.find({\n                selector: {}\n            });\n\n            assert.strictEqual(found.docs.length, 0);\n        });","file":"unit/adapter-check.test.ts","skipped":false,"dir":"test"},{"name":"should insert one attachment","suites":[".putAttachment()"],"updatePoint":{"line":28,"column":40},"line":28,"code":"        it('should insert one attachment', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            const attachment = await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow', 'text/plain'),\n                type: 'text/plain'\n            });\n            assert.ok(attachment);\n            assert.strictEqual(attachment.id, 'cat.txt');\n            assert.strictEqual(attachment.type, 'text/plain');\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should insert two attachments","suites":[".putAttachment()"],"updatePoint":{"line":41,"column":41},"line":41,"code":"        it('should insert two attachments', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow', 'text/plain'),\n                type: 'text/plain'\n            });\n            await doc.putAttachment({\n                id: 'cat2.txt',\n                data: blobBufferUtil.createBlobBuffer('meowmeow', 'text/plain'),\n                type: 'text/plain'\n            });\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should insert 4 attachments in parallel","suites":[".putAttachment()"],"updatePoint":{"line":56,"column":51},"line":56,"code":"        it('should insert 4 attachments in parallel', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            const attachments = await Promise.all(\n                new Array(4)\n                    .fill(0)\n                    .map(() => doc.putAttachment({\n                        id: AsyncTestUtil.randomString(5) + '.txt',\n                        data: blobBufferUtil.createBlobBuffer('meow I am a kitty with a knife ' + AsyncTestUtil.randomString(5), 'text/plain'),\n                        type: 'text/plain'\n                    }))\n            );\n            assert.strictEqual(attachments.length, 4);\n            assert.ok(attachments[1].id);\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should insert an attachment with a big content","suites":[".putAttachment()"],"updatePoint":{"line":72,"column":58},"line":72,"code":"        it('should insert an attachment with a big content', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'cat2.txt',\n                data: blobBufferUtil.createBlobBuffer([\n                    AsyncTestUtil.randomString(100),\n                    AsyncTestUtil.randomString(100),\n                    AsyncTestUtil.randomString(100)\n                ].join(' '), 'text/plain'), // use space here\n                type: 'text/plain'\n            });\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should not update the document if skipIfSame=true and same data","suites":[".putAttachment()"],"updatePoint":{"line":86,"column":75},"line":86,"code":"        it('should not update the document if skipIfSame=true and same data', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            const data = blobBufferUtil.createBlobBuffer(AsyncTestUtil.randomString(100), 'text/plain');\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data,\n                type: 'text/plain'\n            }, true);\n            const revBefore = doc.revision;\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data,\n                type: 'text/plain'\n            }, true);\n            await wait(50);\n            assert.strictEqual(\n                revBefore,\n                doc.revision\n            );\n\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should update the document if skipIfSame=true and different data","suites":[".putAttachment()"],"updatePoint":{"line":109,"column":76},"line":109,"code":"        it('should update the document if skipIfSame=true and different data', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer(AsyncTestUtil.randomString(100), 'text/plain'),\n                type: 'text/plain'\n            }, true);\n            const revBefore = doc.revision;\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer(AsyncTestUtil.randomString(100), 'text/plain'),\n                type: 'text/plain'\n            }, false);\n            await wait(50);\n            assert.notStrictEqual(\n                revBefore,\n                doc.revision\n            );\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should get the attachment","suites":[".getAttachment()"],"updatePoint":{"line":132,"column":37},"line":132,"code":"        it('should get the attachment', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow I am a kitty with a knife', 'text/plain'),\n                type: 'text/plain'\n            });\n            const attachment: any = doc.getAttachment('cat.txt');\n            assert.ok(attachment);\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should find the attachment after another doc-update","suites":[".getAttachment()"],"updatePoint":{"line":144,"column":63},"line":144,"code":"        it('should find the attachment after another doc-update', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow I am a kitty with a knife', 'text/plain'),\n                type: 'text/plain'\n            });\n\n            await doc.atomicPatch({\n                age: 7\n            });\n\n            const attachment: any = doc.getAttachment('cat.txt');\n            assert.ok(attachment);\n            assert.strictEqual(attachment.type, 'text/plain');\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should find the attachment after database is re-created","suites":[".getAttachment()"],"updatePoint":{"line":162,"column":67},"line":162,"code":"        it('should find the attachment after database is re-created', async () => {\n            if (!config.storage.hasPersistence) {\n                return;\n            }\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                multiInstance: false,\n                ignoreDuplicate: true\n            });\n            const schemaJson = AsyncTestUtil.clone(schemas.human);\n            schemaJson.attachments = {};\n            const collections = await db.addCollections({\n                humans: {\n                    schema: schemaJson\n                }\n            });\n            await collections.humans.insert(schemaObjects.human());\n            const doc = await collections.humans.findOne().exec(true);\n            const docAge = doc.age;\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow I am a kitty with a knife', 'text/plain'),\n                type: 'text/plain'\n            });\n            await db.destroy();\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                multiInstance: false,\n                ignoreDuplicate: true\n            });\n            const cols2 = await db2.addCollections({\n                humans: {\n                    schema: schemaJson\n                }\n            });\n            const c2 = cols2.humans;\n            const doc2 = await c2.findOne().exec();\n            assert.strictEqual(docAge, doc2.age);\n            const attachment = doc2.getAttachment('cat.txt');\n            assert.ok(attachment);\n            assert.strictEqual(attachment.type, 'text/plain');\n            c2.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should remove all attachments when a document gets deleted","suites":[".getAttachment()"],"updatePoint":{"line":208,"column":70},"line":208,"code":"        it('should remove all attachments when a document gets deleted', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            const attachmentId = 'cat.txt';\n            await doc.putAttachment({\n                id: attachmentId,\n                data: blobBufferUtil.createBlobBuffer('meow I am a kitty with a knife', 'text/plain'),\n                type: 'text/plain'\n            });\n            await c.storageInstance.getAttachmentData(doc.primary, attachmentId);\n\n            await doc.remove();\n            let hasThrown = false;\n            try {\n                await c.storageInstance.getAttachmentData(doc.primary, attachmentId);\n            } catch (err) {\n                hasThrown = true;\n            }\n            assert.ok(hasThrown);\n\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should get the data","suites":["RxAttachment.getData()"],"updatePoint":{"line":232,"column":31},"line":232,"code":"        it('should get the data', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            const dat = AsyncTestUtil.randomString(100) + ' ' + AsyncTestUtil.randomString(100);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer(dat, 'text/plain'),\n                type: 'text/plain'\n            });\n            const attachment: any = doc.getAttachment('cat.txt');\n            const data = await attachment.getData();\n            const dataString = await blobBufferUtil.toString(data);\n            assert.strictEqual(dataString, dat);\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should get the data as string","suites":["RxAttachment.getStringData()"],"updatePoint":{"line":249,"column":41},"line":249,"code":"        it('should get the data as string', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            const dat = AsyncTestUtil.randomString(100) + ' ' + AsyncTestUtil.randomString(100);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer(dat, 'text/plain'),\n                type: 'text/plain'\n            });\n            const attachment: any = doc.getAttachment('cat.txt');\n            const data = await attachment.getStringData();\n            assert.strictEqual(data, dat);\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should remove the attachment","suites":["RxAttachment.remove()"],"updatePoint":{"line":265,"column":40},"line":265,"code":"        it('should remove the attachment', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow I am a kitty with a knife', 'text/plain'),\n                type: 'text/plain'\n            });\n            const attachment: any = doc.getAttachment('cat.txt');\n            assert.ok(attachment);\n\n            await attachment.remove();\n\n            // ensure it does not exist\n            const shouldBeNull = doc.getAttachment('cat.txt');\n            assert.strictEqual(null, shouldBeNull);\n\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should find all attachments","suites":[".allAttachments()"],"updatePoint":{"line":286,"column":39},"line":286,"code":"        it('should find all attachments', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            await Promise.all(\n                new Array(10)\n                    .fill(0)\n                    .map(() => doc.putAttachment({\n                        id: AsyncTestUtil.randomString(5) + '.txt',\n                        data: blobBufferUtil.createBlobBuffer('meow I am a kitty with a knife ' + AsyncTestUtil.randomString(500), 'text/plain'),\n                        type: 'text/plain'\n                    }))\n            );\n            const attachments = doc.allAttachments();\n            assert.strictEqual(attachments.length, 10);\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should lazy-load the data for the attachment","suites":[".allAttachments()"],"updatePoint":{"line":302,"column":56},"line":302,"code":"        it('should lazy-load the data for the attachment', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'janosch.txt',\n                data: blobBufferUtil.createBlobBuffer('foo bar', 'text/plain'),\n                type: 'text/plain'\n            });\n            const attachments = doc.allAttachments();\n            const attachment = attachments[0];\n\n            const data = await attachment.getData();\n            const dataString = await blobBufferUtil.toString(data);\n            assert.deepStrictEqual(dataString, 'foo bar');\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should throw when attachments not defined in the schema","suites":["schema"],"updatePoint":{"line":320,"column":67},"line":320,"code":"        it('should throw when attachments not defined in the schema', async () => {\n            const c = await humansCollection.create(1);\n            const doc: any = await c.findOne().exec();\n            await AsyncTestUtil.assertThrows(\n                () => doc.putAttachment({\n                    id: AsyncTestUtil.randomString(5) + '.txt',\n                    data: blobBufferUtil.createBlobBuffer('meow I am a kitty with a knife ', 'text/plain'),\n                    type: 'text/plain'\n                }),\n                'RxError',\n                'schema'\n            );\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should store the data encrypted","suites":["encryption"],"updatePoint":{"line":336,"column":43},"line":336,"code":"        it('should store the data encrypted', async () => {\n            const c = await humansCollection.createEncryptedAttachments(1);\n            const doc = await c.findOne().exec(true);\n            const attachment = await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('foo bar aaa', 'text/plain'),\n                type: 'text/plain'\n            });\n\n            // the data stored in the storage must be encrypted\n            if (config.storage.name === 'pouchdb') {\n                const encryptedData = await doc.collection.storageInstance.internals.pouch.getAttachment(doc.primary, 'cat.txt');\n                const dataString = await blobBufferUtil.toString(encryptedData);\n                assert.notStrictEqual(dataString, 'foo bar aaa');\n            }\n\n            // getting the data again must be decrypted\n            const data = await attachment.getStringData();\n            assert.strictEqual(data, 'foo bar aaa');\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should emit on subscription","suites":[".allAttachments$"],"updatePoint":{"line":359,"column":39},"line":359,"code":"        it('should emit on subscription', async () => {\n            const c = await humansCollection.createEncryptedAttachments(1);\n            const doc = await c.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('foo bar', 'text/plain'),\n                type: 'text/plain'\n            });\n\n            const emited: any[] = [];\n            const sub = doc.allAttachments$\n                .subscribe((attachments: any[]) => emited.push(attachments));\n            await AsyncTestUtil.waitUntil(() => emited.length === 1);\n\n            assert.strictEqual(emited[0].length, 1);\n            assert.ok(emited[0][0].doc);\n\n            sub.unsubscribe();\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should emit on other instance","suites":["multiInstance"],"updatePoint":{"line":384,"column":41},"line":384,"code":"        it('should emit on other instance', async () => {\n            const name = randomCouchString(10);\n            type Collections = { humans: RxCollection<HumanDocumentType, {}, {}> };\n            type Document = RxDocument<HumanDocumentType>;\n            const db = await createRxDatabase<Collections>({\n                name,\n                storage: config.storage.getStorage(),\n                multiInstance: true,\n                ignoreDuplicate: true\n            });\n            const schemaJson: RxJsonSchema<HumanDocumentType> = AsyncTestUtil.clone(schemas.human);\n            schemaJson.attachments = {};\n\n\n            const c = await db.addCollections<Collections>({\n                humans: {\n                    schema: schemaJson\n                }\n            });\n\n            const db2 = await createRxDatabase<Collections>({\n                name,\n                storage: config.storage.getStorage(),\n                multiInstance: true,\n                ignoreDuplicate: true\n            });\n            const c2 = await db2.addCollections<Collections>({\n                humans: {\n                    schema: schemaJson\n                }\n            });\n\n            await c.humans.insert(schemaObjects.human());\n            const doc: Document = await c.humans.findOne().exec(true);\n            const doc2: Document = await c2.humans.findOne().exec(true);\n            assert.strictEqual(doc.age, doc2.age);\n\n            const doc2Streamed: any[] = [];\n            const sub = doc2.allAttachments$\n                .subscribe(atc => {\n                    doc2Streamed.push(atc);\n                });\n\n            const putAttachment = await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow I am a kitty', 'text/plain'),\n                type: 'text/plain'\n            });\n\n            await AsyncTestUtil.waitUntil(() => {\n                return doc2Streamed.length === 2;\n            }, 10 * 1000, 100);\n            const attachment = doc2Streamed[1][0];\n            const data = await attachment.getStringData();\n            assert.strictEqual(data, 'meow I am a kitty');\n\n            // remove again\n            await putAttachment.remove();\n\n            await AsyncTestUtil.waitUntil(\n                () => doc2Streamed.length === 3\n            );\n\n            assert.strictEqual(doc2Streamed[2].length, 0);\n            sub.unsubscribe();\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should keep the attachments during migration","suites":["migration"],"updatePoint":{"line":457,"column":56},"line":457,"code":"        it('should keep the attachments during migration', async () => {\n            const dbName = randomCouchString(10);\n            type DocData = {\n                id: string;\n            };\n            const schema0: RxJsonSchema<DocData> = {\n                version: 0,\n                type: 'object',\n                primaryKey: 'id',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    }\n                },\n                attachments: {},\n                required: ['id']\n            };\n            const schema1: RxJsonSchema<DocData> = clone(schema0);\n            schema1.version = 1;\n\n            const db = await createRxDatabase({\n                name: dbName,\n                storage: config.storage.getStorage(),\n            });\n            const col = await db.addCollections({\n                heroes: {\n                    schema: schema0\n                }\n            });\n            const doc: RxDocument<DocData> = await col.heroes.insert({\n                id: 'alice'\n            });\n            await doc.putAttachment({\n                id: 'foobar',\n                data: blobBufferUtil.createBlobBuffer('barfoo', 'text/plain'),\n                type: 'text/plain'\n            });\n            await db.destroy();\n\n            const db2 = await createRxDatabase({\n                name: dbName,\n                storage: config.storage.getStorage(),\n            });\n\n            const migrationStrategies: MigrationStrategies = {\n                1: (oldDoc: WithAttachmentsData<DocData>) => {\n                    const attachmentData = oldDoc._attachments;\n                    assert.ok(attachmentData);\n                    return oldDoc;\n                }\n            };\n\n            const col2 = await db2.addCollections({\n                heroes: {\n                    schema: schema1,\n                    migrationStrategies\n                }\n            });\n\n            const doc2: RxDocument<DocData> = await col2.heroes.findOne().exec();\n\n            assert.strictEqual(doc2.allAttachments().length, 1);\n            const firstAttachment = doc2.allAttachments()[0];\n            const data = await firstAttachment.getStringData();\n            assert.strictEqual(data, 'barfoo');\n\n            db2.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should delete the attachment during migration","suites":["migration"],"updatePoint":{"line":526,"column":57},"line":526,"code":"        it('should delete the attachment during migration', async () => {\n            const dbName = randomCouchString(10);\n            type DocData = {\n                id: string;\n            };\n            const schema0: RxJsonSchema<DocData> = {\n                version: 0,\n                primaryKey: 'id',\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    }\n                },\n                attachments: {},\n                required: ['id']\n            };\n            const schema1: RxJsonSchema<DocData> = clone(schema0);\n            schema1.version = 1;\n\n            const db = await createRxDatabase({\n                name: dbName,\n                storage: config.storage.getStorage(),\n            });\n            const col = await db.addCollections({\n                heroes: {\n                    schema: schema0\n                }\n            });\n            const doc: RxDocument<DocData> = await col.heroes.insert({\n                id: 'alice'\n            });\n            await doc.putAttachment({\n                id: 'foobar',\n                data: blobBufferUtil.createBlobBuffer('barfoo', 'text/plain'),\n                type: 'text/plain'\n            });\n            await db.destroy();\n\n            const db2 = await createRxDatabase({\n                name: dbName,\n                storage: config.storage.getStorage(),\n            });\n            const migrationStrategies: MigrationStrategies = {\n                1: (oldDoc: WithAttachmentsData<DocData>) => {\n                    oldDoc._attachments = {};\n                    return oldDoc;\n                }\n            };\n            const col2 = await db2.addCollections({\n                heroes: {\n                    schema: schema1,\n                    migrationStrategies\n                }\n            });\n            const doc2: RxDocument<DocData> = await col2.heroes.findOne().exec();\n            assert.strictEqual(doc2.allAttachments().length, 0);\n\n            db2.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should be able to change the attachment data during migration","suites":["migration"],"updatePoint":{"line":587,"column":73},"line":587,"code":"        it('should be able to change the attachment data during migration', async () => {\n            const dbName = randomCouchString(10);\n            type DocData = {\n                id: string;\n            };\n            const schema0: RxJsonSchema<DocData> = {\n                version: 0,\n                primaryKey: 'id',\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    }\n                },\n                attachments: {},\n                required: ['id']\n            };\n            const schema1: RxJsonSchema<DocData> = clone(schema0);\n            schema1.version = 1;\n\n            const db = await createRxDatabase({\n                name: dbName,\n                storage: config.storage.getStorage(),\n            });\n            const col = await db.addCollections({\n                heroes: {\n                    schema: schema0\n                }\n            });\n            const doc: RxDocument<DocData> = await col.heroes.insert({\n                id: 'alice'\n            });\n            await doc.putAttachment({\n                id: 'foobar',\n                data: blobBufferUtil.createBlobBuffer('barfoo1', 'text/plain'),\n                type: 'text/plain'\n            });\n            await db.destroy();\n\n            const db2 = await createRxDatabase({\n                name: dbName,\n                storage: config.storage.getStorage(),\n            });\n            const migrationStrategies: MigrationStrategies = {\n                1: async (oldDoc: RxDocumentWriteData<DocData>) => {\n                    if (!oldDoc._attachments) {\n                        throw new Error('oldDoc._attachments missing');\n                    }\n                    const myAttachment = oldDoc._attachments.foobar;\n                    const blobBuffer = await blobBufferUtil.createBlobBuffer(\n                        'barfoo2',\n                        myAttachment.type\n                    );\n                    (myAttachment as any).data = await blobBufferUtil.toBase64String(blobBuffer);\n\n                    oldDoc._attachments = {\n                        foobar: myAttachment\n                    };\n                    return oldDoc;\n                }\n            };\n            const col2 = await db2.addCollections({\n                heroes: {\n                    schema: schema1,\n                    migrationStrategies\n                }\n            });\n\n            const doc2: RxDocument<DocData> = await col2.heroes.findOne().exec();\n            assert.strictEqual(doc2.allAttachments().length, 1);\n            const firstAttachment = doc2.allAttachments()[0];\n            const data = await firstAttachment.getStringData();\n            assert.strictEqual(data, 'barfoo2');\n\n\n            db2.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should be able to call the defined function","suites":["orm"],"updatePoint":{"line":667,"column":55},"line":667,"code":"        it('should be able to call the defined function', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage(),\n                multiInstance: false,\n                ignoreDuplicate: true\n            });\n            const schemaJson = AsyncTestUtil.clone(schemas.human);\n            schemaJson.attachments = {};\n            const c = await db.addCollections({\n                humans: {\n                    schema: schemaJson,\n                    attachments: {\n                        foobar() {\n                            return 'foobar ' + this.type;\n                        }\n                    }\n                }\n            });\n            await c.humans.insert(schemaObjects.human());\n            const doc = await c.humans.findOne().exec();\n            const attachment = await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow I am a kitty', 'text/plain'),\n                type: 'text/plain'\n            });\n\n            assert.strictEqual(attachment.foobar(), 'foobar text/plain');\n            db.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"#455 attachments not working","suites":["issues"],"updatePoint":{"line":699,"column":40},"line":699,"code":"        it('#455 attachments not working', async () => {\n            const myschema = {\n                version: 0,\n                primaryKey: 'name',\n                type: 'object',\n                properties: {\n                    name: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                },\n                attachments: {\n                    encrypted: false,\n                },\n            };\n            const myDB = await createRxDatabase({\n                name: 'mylocaldb' + randomCouchString(10),\n                storage: config.storage.getStorage(),\n                multiInstance: true\n            });\n            const myCollections = await myDB.addCollections({\n                mycollection: {\n                    schema: myschema\n                }\n            });\n            const myCollection = myCollections.mycollection;\n            const mydoc = myCollection.newDocument({\n                name: 'mydoc'\n            });\n            await mydoc.save();\n            const doc = await myCollection.findOne('mydoc').exec();\n            await doc.putAttachment({\n                id: 'sampledata',\n                data: blobBufferUtil.createBlobBuffer('foo bar', 'text/plain'),\n                type: 'application/octet-stream'\n            });\n\n            const doc2 = await myCollection.findOne('mydoc').exec();\n            const attachment2 = doc2.getAttachment('sampledata');\n            const data = await attachment2.getStringData();\n            assert.strictEqual(data, 'foo bar');\n            await myDB.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"calling allAttachments() fails when document has none","suites":["issues"],"updatePoint":{"line":742,"column":65},"line":742,"code":"        it('calling allAttachments() fails when document has none', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                multiInstance: false,\n                ignoreDuplicate: true\n            });\n            const schemaJson = AsyncTestUtil.clone(schemas.human);\n            schemaJson.attachments = {};\n            const c = await db.addCollections({\n                humans: {\n                    schema: schemaJson\n                }\n            });\n            await c.humans.insert(schemaObjects.human());\n            const doc = await c.humans.findOne().exec();\n\n            const attachments = await doc.allAttachments();\n            assert.strictEqual(attachments.length, 0);\n\n            db.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should backup a single document","suites":["backup.test.ts",".backupSingleDocument()"],"updatePoint":{"line":45,"column":43},"line":45,"code":"        it('should backup a single document', async () => {\n            if (!config.storage.hasAttachments) {\n                return;\n            }\n            const collection = await createAttachments(1);\n            const firstDoc = await collection.findOne().exec(true);\n            await firstDoc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('lol', 'text/plain'),\n                type: 'text/plain'\n            });\n\n            const directory = getBackupDir();\n\n            await backupSingleDocument(\n                firstDoc as any,\n                {\n                    directory,\n                    attachments: true,\n                    live: false\n                }\n            );\n\n            assert.ok(fs.existsSync(path.join(directory, firstDoc.primary)));\n            assert.ok(fs.existsSync(path.join(directory, firstDoc.primary, 'attachments', 'cat.txt')));\n            assert.ok(\n                require(\n                    path.join(directory, firstDoc.primary, 'document.json')\n                )\n            );\n\n            collection.database.destroy();\n        });","file":"unit/backup.test.ts","skipped":false,"dir":"test"},{"name":"should backup all docs with attachments","suites":["backup.test.ts","RxDatabase.backup() live=false"],"updatePoint":{"line":80,"column":51},"line":80,"code":"        it('should backup all docs with attachments', async () => {\n            if (!config.storage.hasAttachments) {\n                return;\n            }\n            const collection = await createAttachments(1);\n            const firstDoc = await collection.findOne().exec(true);\n            await firstDoc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('lol', 'text/plain'),\n                type: 'text/plain'\n            });\n            const directory = getBackupDir();\n            const options = {\n                live: false,\n                directory,\n                attachments: true\n            };\n\n            const backupState = collection.database.backup(options);\n            await backupState.awaitInitialBackup();\n\n            assert.ok(fs.existsSync(path.join(directory, firstDoc.primary)));\n            assert.ok(fs.existsSync(path.join(directory, firstDoc.primary, 'attachments', 'cat.txt')));\n            assert.ok(\n                require(\n                    path.join(directory, firstDoc.primary, 'document.json')\n                )\n            );\n\n            const meta: BackupMetaFileContent = await getMeta(options);\n            assert.ok(meta.collectionStates.human.checkpoint);\n\n            collection.database.destroy();\n        });","file":"unit/backup.test.ts","skipped":false,"dir":"test"},{"name":"should emit write events","suites":["backup.test.ts","RxDatabase.backup() live=false"],"updatePoint":{"line":114,"column":36},"line":114,"code":"        it('should emit write events', async () => {\n            if (!config.storage.hasAttachments) {\n                return;\n            }\n            const collection = await createAttachments(1);\n            const directory = getBackupDir();\n            const options = {\n                live: false,\n                directory,\n                attachments: true\n            };\n            const emitted: RxBackupWriteEvent[] = [];\n            const backupState: RxBackupState = collection.database.backup(options);\n            const sub = backupState.writeEvents$.subscribe(ev => emitted.push(ev));\n            await backupState.awaitInitialBackup();\n\n            await waitUntil(() => emitted.length > 0);\n            assert.strictEqual(emitted[0].deleted, false);\n\n            collection.database.destroy();\n            sub.unsubscribe();\n        });","file":"unit/backup.test.ts","skipped":false,"dir":"test"},{"name":"should backup ongoing writes","suites":["backup.test.ts","RxDatabase.backup() live=true"],"updatePoint":{"line":138,"column":40},"line":138,"code":"        it('should backup ongoing writes', async () => {\n            if (!config.storage.hasAttachments) {\n                return;\n            }\n            const collection = await createAttachments(1);\n            const firstDoc = await collection.findOne().exec(true);\n            await firstDoc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('lol', 'text/plain'),\n                type: 'text/plain'\n            });\n            const directory = getBackupDir();\n            const backupState = collection.database.backup({\n                live: true,\n                directory,\n                attachments: true\n            });\n            await backupState.awaitInitialBackup();\n\n            const doc2 = await collection.insert(schemaObjects.human());\n\n            await waitUntil(async () => {\n                return fs.existsSync(path.join(directory, doc2.primary));\n            });\n\n            assert.ok(fs.existsSync(path.join(directory, doc2.primary)));\n            assert.ok(\n                require(\n                    path.join(directory, doc2.primary, 'document.json')\n                )\n            );\n\n            await collection.database.destroy();\n            // backupState should be stopped\n            assert.strictEqual(backupState.isStopped, true);\n        });","file":"unit/backup.test.ts","skipped":false,"dir":"test"},{"name":"should fail because it reproduces the bug","suites":["bug-report.test.js"],"updatePoint":{"line":21,"column":49},"line":21,"code":"    it('should fail because it reproduces the bug', async () => {\n\n        /**\n         * If your test should only run in nodejs or only run in the browser,\n         * you should comment in the return operator and addapt the if statement.\n         */\n        if (\n            !config.platform.isNode() // runs only in node\n            // config.platform.isNode() // runs only in the browser\n        ) {\n            // return;\n        }\n\n        if (!config.storage.hasMultiInstance) {\n            return;\n        }\n\n        // create a schema\n        const mySchema = {\n            version: 0,\n            primaryKey: 'passportId',\n            type: 'object',\n            properties: {\n                passportId: {\n                    type: 'string',\n                    maxLength: 100\n                },\n                firstName: {\n                    type: 'string'\n                },\n                lastName: {\n                    type: 'string'\n                },\n                age: {\n                    type: 'integer',\n                    minimum: 0,\n                    maximum: 150\n                }\n            }\n        };\n\n        // generate a random database-name\n        const name = randomCouchString(10);\n\n        // create a database\n        const db = await createRxDatabase({\n            name,\n            /**\n             * By calling config.storage.getStorage(),\n             * we can ensure that all variations of RxStorage are tested in the CI.\n             */\n            storage: config.storage.getStorage(),\n            eventReduce: true,\n            ignoreDuplicate: true\n        });\n        // create a collection\n        const collections = await db.addCollections({\n            mycollection: {\n                schema: mySchema\n            }\n        });\n\n        // insert a document\n        await collections.mycollection.insert({\n            passportId: 'foobar',\n            firstName: 'Bob',\n            lastName: 'Kelso',\n            age: 56\n        });\n\n        /**\n         * to simulate the event-propagation over multiple browser-tabs,\n         * we create the same database again\n         */\n        const dbInOtherTab = await createRxDatabase({\n            name,\n            storage: config.storage.getStorage(),\n            eventReduce: true,\n            ignoreDuplicate: true\n        });\n        // create a collection\n        const collectionInOtherTab = await dbInOtherTab.addCollections({\n            mycollection: {\n                schema: mySchema\n            }\n        });\n\n        // find the document in the other tab\n        const myDocument = await collectionInOtherTab.mycollection\n            .findOne()\n            .where('firstName')\n            .eq('Bob')\n            .exec();\n\n        /*\n         * assert things,\n         * here your tests should fail to show that there is a bug\n         */\n        assert.strictEqual(myDocument.age, 56);\n\n        // you can also wait for events\n        const emitted = [];\n        const sub = collectionInOtherTab.mycollection\n            .findOne().$\n            .subscribe(doc => emitted.push(doc));\n        await AsyncTestUtil.waitUntil(() => emitted.length === 1);\n\n        // clean up afterwards\n        sub.unsubscribe();\n        db.destroy();\n        dbInOtherTab.destroy();\n    });","file":"unit/bug-report.test.ts","skipped":false,"dir":"test"},{"name":"should still get the correct results on exec","suites":["uncached RxQuery"],"updatePoint":{"line":26,"column":56},"line":26,"code":"        it('should still get the correct results on exec', async () => {\n            const col = await humansCollection.create(0);\n            const uncachedQuery = col.find();\n            await uncachedQuery.exec();\n            clearQueryCache(col);\n\n            await col.insert(schemaObjects.human());\n            const res = await uncachedQuery.exec();\n            assert.strictEqual(res.length, 1);\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"should still emit on new results","suites":["uncached RxQuery"],"updatePoint":{"line":37,"column":44},"line":37,"code":"        it('should still emit on new results', async () => {\n            const col = await humansCollection.create(0);\n            const uncachedQuery = col.find();\n            await uncachedQuery.exec();\n\n            const emitted: any[][] = [];\n            const sub = uncachedQuery.$.subscribe((x: any) => emitted.push(x));\n            clearQueryCache(col);\n\n            await AsyncTestUtil.waitUntil(() => emitted.length === 1);\n            await col.insert(schemaObjects.human());\n            await AsyncTestUtil.waitUntil(() => emitted.length === 2);\n            sub.unsubscribe();\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"should have the correct amount","suites":[".countRxQuerySubscribers()"],"updatePoint":{"line":54,"column":42},"line":54,"code":"        it('should have the correct amount', async () => {\n            const col = await humansCollection.create(0);\n            const subs: Subscription[] = [];\n\n            const noSub = col.find({\n                selector: {\n                    foo: 'bar1'\n                }\n            });\n            const oneSub = col.find({\n                selector: {\n                    foo: 'bar2'\n                }\n            });\n            subs.push(oneSub.$.subscribe());\n            const twoSub = col.find({\n                selector: {\n                    foo: 'bar3'\n                }\n            });\n            subs.push(twoSub.$.subscribe());\n            subs.push(twoSub.$.subscribe());\n\n            const stillOneSub = col.find({\n                selector: {\n                    foo: 'bar4'\n                }\n            });\n            subs.push(stillOneSub.$.subscribe());\n            const removeAgain = stillOneSub.$.subscribe();\n            removeAgain.unsubscribe();\n\n            const noMoreSub = col.find({\n                selector: {\n                    foo: 'bar5'\n                }\n            });\n            const removeMe = noMoreSub.$.subscribe();\n            removeMe.unsubscribe();\n\n\n            assert.strictEqual(countRxQuerySubscribers(noSub), 0);\n            assert.strictEqual(countRxQuerySubscribers(oneSub), 1);\n            assert.strictEqual(countRxQuerySubscribers(twoSub), 2);\n            assert.strictEqual(countRxQuerySubscribers(stillOneSub), 1);\n            assert.strictEqual(countRxQuerySubscribers(noMoreSub), 0);\n\n            subs.forEach(sub => sub.unsubscribe());\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"BUG wrong count when used with switch map","suites":[".countRxQuerySubscribers()"],"updatePoint":{"line":104,"column":53},"line":104,"code":"        it('BUG wrong count when used with switch map', async () => {\n            const col = await humansCollection.create(0);\n            const root$ = new BehaviorSubject(1);\n            let query: RxQuery | null = null;\n            const nested = root$.pipe(\n                mergeMap(async (id: number) => {\n                    return id;\n                }),\n                switchMap(() => {\n                    query = col.findOne('foobar');\n                    return query.$;\n                }),\n                /**\n                 * This shareReplay made\n                 * having countRxQuerySubscribers() return more then 0\n                 * we have to set refCount: true so it will unsubscribe from the root\n                 * when has no longer any subscribing children.\n                 * @link https://cartant.medium.com/rxjs-whats-changed-with-sharereplay-65c098843e95\n                 */\n                shareReplay({\n                    bufferSize: 1,\n                    refCount: true\n                })\n            );\n            let emitted = 0;\n            const sub = nested.subscribe(() => emitted++);\n            await waitUntil(() => !!query && emitted === 1);\n\n            if (!query) {\n                throw new Error('query undefined');\n            }\n\n            sub.unsubscribe();\n            assert.strictEqual(countRxQuerySubscribers(query), 0);\n\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"should not crash","suites":[".defaultCacheReplacementPolicyMonad()"],"updatePoint":{"line":143,"column":28},"line":143,"code":"        it('should not crash', async () => {\n            const col = await humansCollection.create(0);\n            // exec one query\n            await col.find().exec();\n            // have one unexecuted\n            col.find({\n                selector: {\n                    foo: 'bar'\n                }\n            });\n            // have one with subscription\n            const sub = col.find({\n                selector: {\n                    foo: 'bar2'\n                }\n            }).$.subscribe();\n\n            defaultCacheReplacementPolicyMonad(0, 0)(col, col._queryCache);\n\n            sub.unsubscribe();\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"should not remove queries that have subscribers","suites":[".defaultCacheReplacementPolicyMonad()"],"updatePoint":{"line":165,"column":59},"line":165,"code":"        it('should not remove queries that have subscribers', async () => {\n            const amount = 4;\n            const col = await humansCollection.create(0);\n            const subs: Subscription[] = new Array(amount).fill(0).map((_v, i) => {\n                return col.find({\n                    selector: {\n                        foo: 'bar' + i\n                    }\n                }).$.subscribe();\n            });\n\n            defaultCacheReplacementPolicyMonad(0, 0)(col, col._queryCache);\n\n            const cachedQueries = Array.from(col._queryCache._map.values());\n            assert.strictEqual(cachedQueries.length, amount);\n\n\n            subs.forEach(sub => sub.unsubscribe());\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"should remove the unexecuted ones after unExecutedLifetime","suites":[".defaultCacheReplacementPolicyMonad()"],"updatePoint":{"line":185,"column":70},"line":185,"code":"        it('should remove the unexecuted ones after unExecutedLifetime', async () => {\n            const amount = 4;\n            const col = await humansCollection.create(0);\n\n            new Array(amount).fill(0).map((_v, i) => {\n                return col.find({\n                    selector: {\n                        foo: 'bar' + i\n                    }\n                });\n            });\n\n            await wait(10);\n            defaultCacheReplacementPolicyMonad(0, 0)(col, col._queryCache);\n            const cachedQueries = Array.from(col._queryCache._map.values());\n            assert.strictEqual(cachedQueries.length, 0);\n\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"should remove the oldest ones","suites":[".defaultCacheReplacementPolicyMonad()"],"updatePoint":{"line":204,"column":41},"line":204,"code":"        it('should remove the oldest ones', async () => {\n            const col = await humansCollection.create(0);\n            const amount = 10;\n            await Promise.all(\n                new Array(amount).fill(0)\n                    .map(async (_v, i) => {\n                        const q = col.find({\n                            selector: {\n                                passportId: 'old-bar' + i\n                            }\n                        });\n                        await q.exec();\n                        return q;\n                    })\n            );\n            await wait(10);\n            const newerQueries = await Promise.all(\n                new Array(amount).fill(0).map(async (_v, i) => {\n                    const q = col.find({\n                        selector: {\n                            passportId: 'new-bar' + i\n                        }\n                    });\n                    await q.exec();\n                    return q;\n                })\n            );\n\n            defaultCacheReplacementPolicyMonad(amount, 0)(col, col._queryCache);\n            const cachedQueries = Array.from(col._queryCache._map.values());\n            assert.deepStrictEqual(cachedQueries, newerQueries);\n            assert.strictEqual(cachedQueries.length, amount);\n\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"should run exactly once","suites":[".triggerCacheReplacement()"],"updatePoint":{"line":241,"column":35},"line":241,"code":"        it('should run exactly once', async () => {\n            const col = await humansCollection.create(0);\n\n            let runs = 0;\n            const policy = defaultCacheReplacementPolicyMonad(0, 0);\n            function trackingPolicy(\n                collection: RxCollection,\n                queryCache: QueryCache\n            ) {\n                runs = runs + 1;\n                policy(collection, queryCache);\n            }\n            col.cacheReplacementPolicy = trackingPolicy;\n\n            new Array(5).fill(0).forEach(() => {\n                triggerCacheReplacement(col);\n            });\n\n            await waitUntil(() => {\n                if (runs > 1) {\n                    throw new Error('too many runs ' + runs);\n                }\n                if (runs === 1) {\n                    return true;\n                } else {\n                    return false;\n                }\n            });\n            assert.strictEqual(runs, 1);\n\n            // run again when first was done\n            triggerCacheReplacement(col);\n            await waitUntil(() => {\n                if (runs > 2) {\n                    throw new Error('too many runs ' + runs);\n                }\n                if (runs === 2) {\n                    return true;\n                } else {\n                    return false;\n                }\n            });\n            assert.strictEqual(runs, 2);\n\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"should contains some events","suites":["basic"],"updatePoint":{"line":10,"column":39},"line":10,"code":"        it('should contains some events', async () => {\n            const col = await humansCollection.create(10);\n            assert.strictEqual(col._changeEventBuffer.buffer.length, 10);\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"should delete older events when buffer get over limit","suites":["basic"],"updatePoint":{"line":15,"column":65},"line":15,"code":"        it('should delete older events when buffer get over limit', async () => {\n            const col = await humansCollection.create(0);\n            col._changeEventBuffer.limit = 10;\n            await Promise.all(\n                new Array(11).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n            assert.strictEqual(col._changeEventBuffer.buffer.length, 10);\n\n            await Promise.all(\n                new Array(11).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n            assert.strictEqual(col._changeEventBuffer.buffer.length, 10);\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"check if correct events get removed","suites":["basic"],"updatePoint":{"line":30,"column":47},"line":30,"code":"        it('check if correct events get removed', async () => {\n            const col = await humansCollection.create(0);\n            col._changeEventBuffer.limit = 10;\n\n            await Promise.all(\n                new Array(11).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n\n            const last = schemaObjects.human();\n            await col.insert(last);\n            const lastBufferEvent = col._changeEventBuffer.buffer[col._changeEventBuffer.buffer.length - 1];\n            assert.strictEqual(last.passportId, lastBufferEvent.documentData.passportId);\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"return null if pointer is no more in buffer (too low)","suites":[".getArrayIndexByPointer()"],"updatePoint":{"line":47,"column":65},"line":47,"code":"        it('return null if pointer is no more in buffer (too low)', async () => {\n            const col = await humansCollection.create(0);\n            col._changeEventBuffer.limit = 10;\n            await Promise.all(\n                new Array(11).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n\n            const pointer = col._changeEventBuffer.getArrayIndexByPointer(0);\n            assert.strictEqual(pointer, null);\n\n            await Promise.all(\n                new Array(11).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n\n            const pointer2 = col._changeEventBuffer.getArrayIndexByPointer(10);\n            assert.strictEqual(pointer2, null);\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"return the right pointer","suites":[".getArrayIndexByPointer()"],"updatePoint":{"line":66,"column":36},"line":66,"code":"        it('return the right pointer', async () => {\n            const col = await humansCollection.create(0);\n            let got;\n            col._changeEventBuffer.limit = 10;\n\n            await Promise.all(\n                new Array(10).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n\n            const pointer = col._changeEventBuffer.getArrayIndexByPointer(0);\n            assert.strictEqual(pointer, null);\n\n            await Promise.all(\n                new Array(10).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n\n            got = col._changeEventBuffer.getArrayIndexByPointer(15);\n            assert.strictEqual(got, 4);\n\n            await Promise.all(\n                new Array(10).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n            got = col._changeEventBuffer.getArrayIndexByPointer(25);\n            assert.strictEqual(got, 4);\n\n            got = col._changeEventBuffer.getArrayIndexByPointer(21);\n            assert.strictEqual(got, 0);\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"return the correct pointer","suites":[".getArrayIndexByPointer()"],"updatePoint":{"line":96,"column":38},"line":96,"code":"        it('return the correct pointer', async () => {\n            const col = await humansCollection.create(10);\n            col._changeEventBuffer.limit = 10;\n\n            const lastDoc = schemaObjects.human();\n            await col.insert(lastDoc);\n\n            const gotIndex: any = col._changeEventBuffer.getArrayIndexByPointer(col._changeEventBuffer.counter);\n            assert.strictEqual(col._changeEventBuffer.buffer[gotIndex].documentData.firstName, lastDoc.firstName);\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"should run from correctly","suites":[".runFrom()"],"updatePoint":{"line":110,"column":37},"line":110,"code":"        it('should run from correctly', async () => {\n            const col = await humansCollection.create(0);\n            col._changeEventBuffer.limit = 10;\n\n            await Promise.all(\n                new Array(10).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n\n            const evs: any[] = [];\n            col._changeEventBuffer.runFrom(1, function (cE: any) {\n                evs.push(cE);\n            });\n            assert.strictEqual(evs.length, 10);\n            evs.forEach(cE => assert.ok(cE.documentId));\n\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"should throw if pointer to low","suites":[".runFrom()"],"updatePoint":{"line":128,"column":42},"line":128,"code":"        it('should throw if pointer to low', async () => {\n            const col = await humansCollection.create(0);\n            col._changeEventBuffer.limit = 10;\n\n            await Promise.all(\n                new Array(30).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n\n            const evs = [];\n            assert.throws(() => col._changeEventBuffer.runFrom(5, function (cE: any) {\n                evs.push(cE);\n            }), Error);\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"should getFrom correctly","suites":[".getFrom()"],"updatePoint":{"line":145,"column":36},"line":145,"code":"        it('should getFrom correctly', async () => {\n            const col = await humansCollection.create(0);\n            col._changeEventBuffer.limit = 10;\n\n            await Promise.all(\n                new Array(10).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n\n            const evs: any[] = col._changeEventBuffer.getFrom(1) as any;\n            assert.strictEqual(evs.length, 10);\n            evs.forEach((cE: any) => assert.ok(cE.documentId));\n\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"should run correct on remove","suites":[".getFrom()"],"updatePoint":{"line":160,"column":40},"line":160,"code":"        it('should run correct on remove', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find();\n            await q.exec();\n            await col.insert(schemaObjects.human());\n            await q.exec();\n\n            // remove the doc\n            const doc: any = await col.findOne().exec();\n            await doc.remove();\n            await AsyncTestUtil.waitUntil(() => col._changeEventBuffer.counter === 2);\n\n            const evs: any[] = col._changeEventBuffer.getFrom(q._latestChangeEvent + 1) as any;\n            assert.strictEqual(evs.length, 1);\n            assert.strictEqual(evs[0].operation, 'DELETE');\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"should only have the last changeEvent for the doc","suites":[".reduceByLastOfDoc()"],"updatePoint":{"line":180,"column":61},"line":180,"code":"        it('should only have the last changeEvent for the doc', async () => {\n            return; // TODO see reduceByLastOfDoc() implementation\n            const col = await humansCollection.create(5);\n            const q = col.find();\n            await q.exec();\n            const oneDoc: any = await col.findOne().exec();\n            let newVal = 0;\n            while (newVal < 5) {\n                newVal++;\n                await oneDoc.atomicPatch({age: newVal});\n            }\n\n            const allEvents: any[] = q.collection._changeEventBuffer.getFrom(1) as any;\n            const reduced = q.collection._changeEventBuffer.reduceByLastOfDoc(allEvents);\n\n            assert.strictEqual(reduced.length, 5);\n            const lastEvent: any = reduced.find(cE => cE.documentId === oneDoc.primary);\n            assert.strictEqual(lastEvent.documentData.age, 5);\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"should clean up the deleted documents","suites":[],"updatePoint":{"line":32,"column":45},"line":32,"code":"    it('should clean up the deleted documents', async () => {\n        const db = await createRxDatabase({\n            name: randomCouchString(10),\n            storage: config.storage.getStorage(),\n            cleanupPolicy: {\n                awaitReplicationsInSync: false,\n                minimumCollectionAge: 0,\n                minimumDeletedTime: 0,\n                runEach: 10,\n                waitForLeadership: false\n            }\n        });\n        const cols = await db.addCollections({\n            humans: {\n                schema: schemas.human\n            }\n        });\n        const collection: RxCollection<HumanDocumentType> = cols.humans;\n        const notDeleted = await collection.insert(schemaObjects.human());\n        const doc = await collection.insert(schemaObjects.human());\n        await doc.remove();\n\n        await waitUntil(async () => {\n            const deletedDocInStorage = await collection.storageInstance.findDocumentsById(\n                [\n                    doc.primary,\n                    notDeleted.primary\n                ],\n                true\n            );\n            assert.ok(deletedDocInStorage[notDeleted.primary]);\n            const deletedDocStillInStorage = !!deletedDocInStorage[doc.primary];\n            return !deletedDocStillInStorage;\n        });\n\n        db.destroy();\n    });","file":"unit/cleanup.test.ts","skipped":false,"dir":"test"},{"name":"should pause the cleanup when a replication is not in sync","suites":[],"updatePoint":{"line":69,"column":66},"line":69,"code":"    it('should pause the cleanup when a replication is not in sync', async () => {\n        const db = await createRxDatabase({\n            name: randomCouchString(10),\n            storage: config.storage.getStorage(),\n            cleanupPolicy: {\n                awaitReplicationsInSync: true,\n                minimumCollectionAge: 0,\n                minimumDeletedTime: 0,\n                runEach: 10,\n                waitForLeadership: false\n            }\n        });\n        const cols = await db.addCollections({\n            humans: {\n                schema: schemas.human\n            }\n        });\n\n        const collection: RxCollection<HumanDocumentType> = cols.humans;\n        replicateRxCollection({\n            collection,\n            replicationIdentifier: 'my-rep',\n            deletedFlag: '_deleted',\n            pull: {\n                async handler() {\n                    await wait(50);\n                    throw new Error('never sucess');\n                }\n            },\n            live: true\n        });\n\n        const doc = await collection.insert(schemaObjects.human());\n        await doc.remove();\n        await wait(config.isFastMode() ? 200 : 500);\n\n        /**\n         * The deleted document still be there\n         * because the errored replication\n         * blocks the cleanup\n         */\n        const deletedDocInStorage = await collection.storageInstance.findDocumentsById(\n            [doc.primary],\n            true\n        );\n        assert.ok(deletedDocInStorage[doc.primary]);\n\n        db.destroy();\n    });","file":"unit/cleanup.test.ts","skipped":false,"dir":"test"},{"name":"create a multiInstance database","suites":["create database"],"updatePoint":{"line":30,"column":43},"line":30,"code":"        it('create a multiInstance database', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage(),\n                multiInstance: true\n            });\n            assert.ok(isRxDatabase(db));\n            db.destroy();\n        });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"create a 2 multiInstance databases","suites":["create database"],"updatePoint":{"line":39,"column":46},"line":39,"code":"        it('create a 2 multiInstance databases', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: getRxStoragePouch('memory'),\n                multiInstance: true,\n                ignoreDuplicate: true\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: getRxStoragePouch('memory'),\n                multiInstance: true,\n                ignoreDuplicate: true\n            });\n            assert.ok(isRxDatabase(db));\n            assert.ok(isRxDatabase(db2));\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"get event on db2 when db1 fires","suites":["RxDatabase.$","positive"],"updatePoint":{"line":61,"column":47},"line":61,"code":"            it('get event on db2 when db1 fires', async () => {\n                const name = randomCouchString(10);\n                const c1 = await humansCollection.createMultiInstance(name);\n                const c2 = await humansCollection.createMultiInstance(name);\n                const db1: RxDatabase = c1.database;\n                const db2: RxDatabase = c2.database;\n\n                let received = 0;\n                db2.$.subscribe(cEvent => {\n                    received++;\n                    assert.ok(cEvent.operation);\n                });\n                await c1.insert(schemaObjects.human());\n                await AsyncTestUtil.waitUntil(async () => {\n                    return received > 0;\n                });\n\n                db1.destroy();\n                db2.destroy();\n            });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"should not get the same events twice","suites":["RxDatabase.$","negative"],"updatePoint":{"line":83,"column":52},"line":83,"code":"            it('should not get the same events twice', async () => {\n\n                const name = randomCouchString(10);\n                const c1 = await humansCollection.createMultiInstance(name);\n                const c2 = await humansCollection.createMultiInstance(name);\n                const db1: RxDatabase = c1.database;\n                const db2: RxDatabase = c2.database;\n\n                const emitted: any[] = [];\n                db2.$.subscribe(cEvent => {\n                    emitted.push(cEvent);\n                    assert.ok(cEvent.operation);\n                });\n                await c1.insert(schemaObjects.human());\n                await wait(100);\n\n                await AsyncTestUtil.waitUntil(async () => {\n                    if (emitted.length > 1) {\n                        throw new Error('got too many events ' + emitted.length);\n                    }\n                    return emitted.length === 1;\n                });\n\n                db1.destroy();\n                db2.destroy();\n            });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"get event on db2 when db1 fires","suites":["Collection.$"],"updatePoint":{"line":112,"column":43},"line":112,"code":"        it('get event on db2 when db1 fires', async () => {\n            const name = randomCouchString(10);\n            const c1 = await humansCollection.createMultiInstance(name);\n            const c2 = await humansCollection.createMultiInstance(name);\n            let received = 0;\n            c2.$.subscribe(cEvent => {\n                received++;\n                assert.ok(cEvent.operation);\n            });\n            await c1.insert(schemaObjects.human());\n\n            await AsyncTestUtil.waitUntil(async () => {\n                return received > 0;\n            });\n\n            c1.database.destroy();\n            c2.database.destroy();\n        });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"get no changes via pouchdb on different dbs","suites":["Collection.$"],"updatePoint":{"line":130,"column":55},"line":130,"code":"        it('get no changes via pouchdb on different dbs', async () => {\n            if (config.storage.name !== 'pouchdb') {\n                return;\n            }\n            const c1 = await humansCollection.create(0);\n            const c2 = await humansCollection.create(0);\n            let got;\n            c2.storageInstance.internals.pouch.changes({\n                since: 'now',\n                live: true,\n                include_docs: true\n            }).on('change', function (change: any) {\n                if (!change.id.startsWith('_'))\n                    got = change;\n            });\n            await c1.insert(schemaObjects.human());\n\n            await promiseWait(50);\n            assert.strictEqual(got, undefined);\n            c1.database.destroy();\n            c2.database.destroy();\n        });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"get event on doc2 when doc1 is changed","suites":["Document.$"],"updatePoint":{"line":155,"column":50},"line":155,"code":"        it('get event on doc2 when doc1 is changed', async () => {\n            const name = randomCouchString(10);\n            const c1 = await humansCollection.createMultiInstance(name);\n            const c2 = await humansCollection.createMultiInstance(name);\n            await c1.insert(schemaObjects.human());\n\n            const doc1 = await c1.findOne().exec(true);\n            const doc2 = await c2.findOne().exec(true);\n\n            let received = 0;\n            doc2.$.subscribe(() => {\n                received = received + 1;\n            });\n\n            let firstNameAfter: any;\n            doc2.get$('firstName').subscribe((newValue: any) => {\n                firstNameAfter = newValue;\n            });\n\n            await doc1.atomicPatch({ firstName: 'foobar' });\n\n            await promiseWait(10);\n            await AsyncTestUtil.waitUntil(() => firstNameAfter === 'foobar');\n\n            assert.strictEqual(firstNameAfter, 'foobar');\n            c1.database.destroy();\n            c2.database.destroy();\n        });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"should work with encrypted fields","suites":["Document.$"],"updatePoint":{"line":183,"column":45},"line":183,"code":"        it('should work with encrypted fields', async () => {\n            const name = randomCouchString(10);\n            const password = randomCouchString(10);\n            const db1 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                password,\n                multiInstance: true,\n                ignoreDuplicate: true\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                password,\n                multiInstance: true,\n                ignoreDuplicate: true\n            });\n            const c1 = await db1.addCollections({\n                human: {\n                    schema: schemas.encryptedHuman\n                }\n            });\n            const c2 = await db2.addCollections({\n                human: {\n                    schema: schemas.encryptedHuman\n                }\n            });\n            await c1.human.insert(schemaObjects.encryptedHuman());\n\n            const doc1 = await c1.human.findOne().exec(true);\n            const doc2 = await c2.human.findOne().exec(true);\n\n            let receivedCollection = 0;\n            c2.human.$.subscribe(() => {\n                receivedCollection = receivedCollection + 1;\n            });\n\n            let received = 0;\n            doc2.$.subscribe(() => {\n                received = received + 1;\n            });\n\n            let secretAfter: any;\n            doc2.get$('secret').subscribe((newValue: any) => {\n                secretAfter = newValue;\n            });\n\n            await doc1.atomicPatch({ secret: 'foobar' });\n\n            await AsyncTestUtil.waitUntil(() => secretAfter === 'foobar');\n            assert.strictEqual(secretAfter, 'foobar');\n\n            db1.destroy();\n            db2.destroy();\n        });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"should work with nested encrypted fields","suites":["Document.$"],"updatePoint":{"line":238,"column":52},"line":238,"code":"        it('should work with nested encrypted fields', async () => {\n            const name = randomCouchString(10);\n            const password = randomCouchString(10);\n            const db1 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                password,\n                multiInstance: true,\n                ignoreDuplicate: true\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                password,\n                multiInstance: true,\n                ignoreDuplicate: true\n            });\n            const c1 = await db1.addCollections({\n                human: {\n                    schema: schemas.encryptedObjectHuman\n                }\n            });\n            const c2 = await db2.addCollections({\n                human: {\n                    schema: schemas.encryptedObjectHuman\n                }\n            });\n            await c1.human.insert(schemaObjects.encryptedObjectHuman());\n\n            const doc1 = await c1.human.findOne().exec(true);\n            const doc2 = await c2.human.findOne().exec(true);\n\n            let receivedCollection = 0;\n            c2.human.$.subscribe(() => {\n                receivedCollection = receivedCollection + 1;\n            });\n\n            let received = 0;\n            doc2.$.subscribe(() => {\n                received = received + 1;\n            });\n\n            let secretAfter: any;\n            doc2.get$('secret').subscribe((newValue: any) => {\n                secretAfter = newValue;\n            });\n\n            await doc1.atomicPatch({\n                secret: {\n                    name: 'foo',\n                    subname: 'bar'\n                }\n            });\n\n            await AsyncTestUtil.waitUntil(() => secretAfter.name === 'foo');\n            assert.deepStrictEqual(secretAfter, {\n                name: 'foo',\n                subname: 'bar'\n            });\n\n            db1.destroy();\n            db2.destroy();\n        });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"should recieve events on the other side","suites":["AutoPull","positive"],"updatePoint":{"line":304,"column":55},"line":304,"code":"            it('should recieve events on the other side', async () => {\n                const name = randomCouchString(10);\n                const c1 = await humansCollection.createMultiInstance(name);\n                const c2 = await humansCollection.createMultiInstance(name);\n\n                const emitted = [];\n                c2.$.subscribe(ev => emitted.push(ev));\n\n                await c1.insert(schemaObjects.human());\n\n                await waitUntil(() => emitted.length >= 1);\n\n                c1.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"should recieve 2 events","suites":["AutoPull","positive"],"updatePoint":{"line":319,"column":39},"line":319,"code":"            it('should recieve 2 events', async () => {\n                const name = randomCouchString(10);\n                const c1 = await humansCollection.createMultiInstance(name);\n                const c2 = await humansCollection.createMultiInstance(name);\n\n                let received = 0;\n                c2.$.subscribe(cEvent => {\n                    received++;\n                    assert.ok(cEvent.operation);\n                });\n\n                await c1.insert(schemaObjects.human());\n                await c1.insert(schemaObjects.human());\n\n                await AsyncTestUtil.waitUntil(() => received === 2);\n                assert.strictEqual(received, 2);\n                c1.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"should calculate the correct length","suites":[".getStringLengthOfIndexNumber()"],"updatePoint":{"line":78,"column":47},"line":78,"code":"        it('should calculate the correct length', () => {\n            const parsed = getStringLengthOfIndexNumber({\n                type: 'number',\n                minimum: 0.1,\n                maximum: 110.5,\n                multipleOf: 0.01\n            });\n            assert.strictEqual(parsed.decimals, 2);\n            assert.strictEqual(parsed.nonDecimals, 3);\n        });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"should get a correct string","suites":[".getIndexableStringMonad()","index-type: string"],"updatePoint":{"line":91,"column":43},"line":91,"code":"            it('should get a correct string', () => {\n                const index = ['id'];\n                const docs = [\n                    getIndexTestDoc({ id: 'bb' }),\n                    getIndexTestDoc({ id: 'aa' })\n                ];\n                const sorted = docs.sort((a, b) => {\n                    const strA = getIndexableStringMonad(\n                        schema,\n                        index\n                    )(a);\n                    const strB = getIndexableStringMonad(\n                        schema,\n                        index\n                    )(b);\n                    assert.strictEqual(strA.length, schema.properties.id.maxLength);\n                    assert.strictEqual(strB.length, schema.properties.id.maxLength);\n                    return strA < strB ? -1 : 1;\n                });\n                assert.strictEqual(sorted[0].id, 'aa');\n            });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"should get a correct string","suites":[".getIndexableStringMonad()","index-type: boolean"],"updatePoint":{"line":114,"column":43},"line":114,"code":"            it('should get a correct string', () => {\n                const index = ['bool'];\n                const docs = [\n                    getIndexTestDoc({ bool: true }),\n                    getIndexTestDoc({ bool: false })\n                ];\n                const sorted = docs.sort((a, b) => {\n                    const strA = getIndexableStringMonad(\n                        schema,\n                        index\n                    )(a);\n                    const strB = getIndexableStringMonad(\n                        schema,\n                        index\n                    )(b);\n                    assert.strictEqual(strA.length, 1);\n                    assert.strictEqual(strB.length, 1);\n                    return strA < strB ? -1 : 1;\n                });\n                assert.strictEqual(sorted[0].bool, false);\n            });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"should get a valid string","suites":[".getIndexableStringMonad()","index-type: number"],"updatePoint":{"line":137,"column":41},"line":137,"code":"            it('should get a valid string', () => {\n                const index = ['num'];\n                const docData = getIndexTestDoc({ num: 24.02 });\n                const indexString = getIndexableStringMonad(\n                    schema,\n                    index\n                )(docData);\n                const parsed = getStringLengthOfIndexNumber(schema.properties.num);\n                assert.strictEqual(indexString.length, parsed.decimals + parsed.nonDecimals);\n            });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"should get the correct sort order","suites":[".getIndexableStringMonad()","index-type: number"],"updatePoint":{"line":147,"column":49},"line":147,"code":"            it('should get the correct sort order', () => {\n                const index = ['num'];\n                const docs = [\n                    getIndexTestDoc({ num: 11 }),\n                    getIndexTestDoc({ num: 10.02 })\n                ];\n                const sorted = docs.sort((a, b) => {\n                    const strA = getIndexableStringMonad(\n                        schema,\n                        index\n                    )(a);\n                    const strB = getIndexableStringMonad(\n                        schema,\n                        index\n                    )(b);\n                    assert.strictEqual(strA.length, strB.length);\n                    return strA < strB ? -1 : 1;\n                });\n                assert.strictEqual(sorted[0].num, 10.02);\n            });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"indexing a optional field must work","suites":[".getIndexableStringMonad()","special cases"],"updatePoint":{"line":169,"column":51},"line":169,"code":"            it('indexing a optional field must work', () => {\n                const schema: RxJsonSchema<RxDocumentData<{ id: string; optional?: string; }>> = fillWithDefaultSettings({\n                    primaryKey: 'id',\n                    version: 0,\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        optional: {\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    },\n                    required: [\n                        'id'\n                    ],\n                    indexes: [\n                        ['id'],\n                        ['optional']\n                    ]\n                });\n                const doc = {\n                    id: 'foo'\n                };\n                const strA: string = getIndexableStringMonad<{ id: string; optional?: string; }>(\n                    schema,\n                    ['optional']\n                )(doc as any);\n                assert.ok(strA);\n                strA.split('').forEach(char => assert.strictEqual(char, ' '));\n            });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"should find the correct docs when comparing with the index","suites":[".getStartIndexStringFromLowerBound()"],"updatePoint":{"line":205,"column":70},"line":205,"code":"        it('should find the correct docs when comparing with the index', () => {\n            const docs = new Array(100).fill(0).map(() => getIndexTestDoc());\n            const index = ['bool', 'num'];\n\n            const lowerBoundString = getStartIndexStringFromLowerBound(\n                schema,\n                index,\n                [\n                    true,\n                    30\n                ]\n            );\n\n            const matchingDocs = docs.filter(doc => {\n                const isIndexStr = getIndexableStringMonad(\n                    schema,\n                    index\n                )(doc);\n                return isIndexStr >= lowerBoundString;\n            });\n\n            matchingDocs.forEach(doc => {\n                assert.ok(doc.bool);\n                assert.ok(doc.num >= 30);\n            });\n        });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"should match the correct docs","suites":[".getStartIndexStringFromUpperBound()"],"updatePoint":{"line":233,"column":41},"line":233,"code":"        it('should match the correct docs', () => {\n            const docs = new Array(100).fill(0).map(() => getIndexTestDoc());\n            const index = ['bool', 'num'];\n\n            const upperBoundString = getStartIndexStringFromUpperBound(\n                schema,\n                index,\n                [\n                    false,\n                    30\n                ]\n            );\n            const matchingDocs = docs.filter(doc => {\n                const isIndexStr = getIndexableStringMonad(\n                    schema,\n                    index\n                )(doc);\n                return isIndexStr <= upperBoundString;\n            });\n\n            matchingDocs.forEach(doc => {\n                assert.strictEqual(doc.bool, false);\n                assert.ok(doc.num <= 30);\n            });\n        });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"should match the correct docs if bound is undefined","suites":[".getStartIndexStringFromUpperBound()"],"updatePoint":{"line":258,"column":63},"line":258,"code":"        it('should match the correct docs if bound is undefined', () => {\n            const docs = new Array(100).fill(0).map(() => getIndexTestDoc());\n            const index = ['id'];\n\n            const upperBoundString = getStartIndexStringFromUpperBound(\n                schema,\n                index,\n                [\n                    undefined\n                ]\n            );\n\n            const matchingDocs = docs.filter(doc => {\n                const isIndexStr = getIndexableStringMonad(\n                    schema,\n                    index\n                )(doc);\n                return isIndexStr <= upperBoundString;\n            });\n\n            /**\n             * Because the bound was 'undefined',\n             * all docs must match.\n             */\n            assert.strictEqual(\n                docs.length,\n                matchingDocs.length\n            );\n        });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"should find the correct string for the _deleted+_meta.lwt index","suites":[".getStartIndexStringFromUpperBound()"],"updatePoint":{"line":291,"column":75},"line":291,"code":"        it('should find the correct string for the _deleted+_meta.lwt index', () => {\n            const useSchema = clone(schema);\n            const index = ['_deleted', '_meta.lwt'];\n            useSchema.indexes.push(index);\n\n            const lowerBoundString = getStartIndexStringFromLowerBound(\n                useSchema,\n                index,\n                [\n                    true,\n                    1\n                ]\n            );\n\n            const doc = getIndexTestDoc();\n            doc._deleted = true;\n            doc._meta.lwt = now();\n            const docIndexString = getIndexableStringMonad(\n                useSchema,\n                index\n            )(doc);\n            assert.ok(lowerBoundString < docIndexString);\n            const upperBoundString = getStartIndexStringFromUpperBound(\n                useSchema,\n                index,\n                [\n                    true,\n                    now() + 1000 * 10\n                ]\n            );\n            assert.ok(upperBoundString.startsWith('1'));\n            assert.ok(docIndexString < upperBoundString);\n            const upperBoundString2 = getStartIndexStringFromUpperBound(\n                useSchema,\n                index,\n                [\n                    true,\n                    now() + 1000 * 100\n                ]\n            );\n            assert.ok(upperBoundString2 > upperBoundString);\n        });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"ok to create with strategies","suites":[".create() with migrationStrategies","positive"],"updatePoint":{"line":60,"column":44},"line":60,"code":"            it('ok to create with strategies', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                });\n                await db.addCollections({\n                    foobar: {\n                        schema: schemas.simpleHumanV3,\n                        autoMigrate: false,\n                        migrationStrategies: {\n                            1: () => { },\n                            2: () => { },\n                            3: () => { }\n                        }\n                    }\n                });\n                db.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"create same collection with different schema-versions","suites":[".create() with migrationStrategies","positive"],"updatePoint":{"line":78,"column":69},"line":78,"code":"            it('create same collection with different schema-versions', async () => {\n                const colName = 'human';\n                const name = randomCouchString(10);\n                const db = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n                await db.addCollections({\n                    [colName]: {\n                        schema: schemas.human,\n                        autoMigrate: false\n                    }\n                });\n\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n                await db2.addCollections({\n                    [colName]: {\n                        schema: schemas.simpleHumanV3,\n                        autoMigrate: false,\n                        migrationStrategies: {\n                            1: () => { },\n                            2: () => { },\n                            3: () => { }\n                        }\n                    }\n                });\n                db.destroy();\n                db2.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should throw when array","suites":[".create() with migrationStrategies","negative"],"updatePoint":{"line":114,"column":39},"line":114,"code":"            it('should throw when array', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        foobar: {\n                            schema: schemas.human,\n                            autoMigrate: false,\n                            migrationStrategies: [] as any\n                        }\n                    }),\n                    'RxTypeError'\n                );\n                db.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should throw when property no number","suites":[".create() with migrationStrategies","negative"],"updatePoint":{"line":131,"column":52},"line":131,"code":"            it('should throw when property no number', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        foobar: {\n                            schema: schemas.human,\n                            autoMigrate: false,\n                            migrationStrategies: {\n                                foo: function () { }\n                            }\n                        }\n                    } as any),\n                    'RxError'\n                );\n                db.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should throw when property no non-float-number","suites":[".create() with migrationStrategies","negative"],"updatePoint":{"line":150,"column":62},"line":150,"code":"            it('should throw when property no non-float-number', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        foobar: {\n                            schema: schemas.human,\n                            autoMigrate: false,\n                            migrationStrategies: {\n                                '1.1': function () { }\n                            }\n                        }\n                    }),\n                    'RxError'\n                );\n                db.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should throw when property-value no function","suites":[".create() with migrationStrategies","negative"],"updatePoint":{"line":169,"column":60},"line":169,"code":"            it('should throw when property-value no function', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        foobar: {\n                            schema: schemas.human,\n                            autoMigrate: false,\n                            migrationStrategies: {\n                                1: 'foobar'\n                            }\n                        }\n                    } as any),\n                    'RxError'\n                );\n                db.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"throw when strategy missing","suites":[".create() with migrationStrategies","negative"],"updatePoint":{"line":188,"column":43},"line":188,"code":"            it('throw when strategy missing', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        foobar: {\n                            schema: schemas.simpleHumanV3,\n                            autoMigrate: false,\n                            migrationStrategies: {\n                                1: () => { },\n                                3: () => { }\n                            }\n                        }\n                    }),\n                    'RxError'\n                );\n                db.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should NOT get an older version","suites":["DataMigrator.js","_getOldCollections()"],"updatePoint":{"line":212,"column":47},"line":212,"code":"            it('should NOT get an older version', async () => {\n                const colName = 'human';\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                });\n                const cols = await db.addCollections({\n                    [colName]: {\n                        schema: schemas.simpleHumanV3,\n                        autoMigrate: false,\n                        migrationStrategies: {\n                            1: () => { },\n                            2: () => { },\n                            3: () => { }\n                        }\n                    }\n                });\n                const col = cols[colName];\n                const old = await _getOldCollections(col.getDataMigrator());\n                assert.deepStrictEqual(old, []);\n                db.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should get an older version","suites":["DataMigrator.js","_getOldCollections()"],"updatePoint":{"line":234,"column":43},"line":234,"code":"            it('should get an older version', async () => {\n                const name = randomCouchString(10);\n                const colName = 'human';\n                const db = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n                await db.addCollections({\n                    [colName]: {\n                        schema: schemas.simpleHuman,\n                        autoMigrate: false\n                    }\n                });\n\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n                const cols2 = await db2.addCollections({\n                    [colName]: {\n                        schema: schemas.simpleHumanV3,\n                        autoMigrate: false,\n                        migrationStrategies: {\n                            1: () => { },\n                            2: () => { },\n                            3: () => { }\n                        }\n                    }\n                });\n                const col2 = cols2[colName];\n                const oldCollections = await _getOldCollections(col2.getDataMigrator());\n                assert.ok(Array.isArray(oldCollections));\n                assert.strictEqual(oldCollections.length, 1);\n\n                // ensure it is an OldCollection\n                assert.ok(oldCollections[0].newestCollection);\n\n                oldCollections.forEach(c => c.storageInstance.close());\n                db.destroy();\n                db2.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"create","suites":["DataMigrator.js","OldCollection","create"],"updatePoint":{"line":280,"column":26},"line":280,"code":"                it('create', async () => {\n                    const col = await humansCollection.createMigrationCollection();\n\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const oldCol: any = lastOfArray(oldCollections);\n\n                    assert.strictEqual(oldCol.schema.constructor.name, 'RxSchema');\n                    assert.strictEqual(oldCol.version, 0);\n                    oldCollections.forEach(c => c.storageInstance.close());\n                    col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"get a valid migrated document","suites":["DataMigrator.js","OldCollection",".migrateDocumentData()"],"updatePoint":{"line":293,"column":49},"line":293,"code":"                it('get a valid migrated document', async () => {\n                    const col = await humansCollection.createMigrationCollection(1, {\n                        3: (doc: any) => {\n                            doc.age = parseInt(doc.age, 10);\n                            return doc;\n                        }\n                    });\n\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const oldCol: any = lastOfArray(oldCollections);\n\n                    const oldDocs = await getBatchOfOldCollection(oldCol, 10);\n                    const newDoc = await migrateDocumentData(oldCol, oldDocs[0]);\n                    assert.deepStrictEqual(newDoc.age, parseInt(oldDocs[0].age, 10));\n                    oldCollections.forEach(c => c.storageInstance.close());\n                    col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"get a valid migrated document from async strategy","suites":["DataMigrator.js","OldCollection",".migrateDocumentData()"],"updatePoint":{"line":310,"column":69},"line":310,"code":"                it('get a valid migrated document from async strategy', async () => {\n                    const col = await humansCollection.createMigrationCollection(1, {\n                        3: async (doc: any) => {\n                            await promiseWait(10);\n                            doc.age = parseInt(doc.age, 10);\n                            return doc;\n                        }\n                    });\n\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const oldCol: any = lastOfArray(oldCollections);\n\n                    const oldDocs = await getBatchOfOldCollection(oldCol, 10);\n                    const newDoc = await migrateDocumentData(oldCol, oldDocs[0]);\n                    assert.deepStrictEqual(newDoc.age, parseInt(oldDocs[0].age, 10));\n                    oldCollections.forEach(c => c.storageInstance.close());\n                    col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should delete the pouchdb with all its content","suites":["DataMigrator.js","OldCollection",".remove()"],"updatePoint":{"line":330,"column":66},"line":330,"code":"                it('should delete the pouchdb with all its content', async () => {\n                    if (!config.storage.name.includes('pouchdb')) {\n                        return;\n                    }\n                    const dbName = randomCouchString(10);\n                    const col = await humansCollection.createMigrationCollection(10, {}, dbName);\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const old = lastOfArray(oldCollections);\n                    if (!old) {\n                        throw new Error('this should never happen');\n                    }\n\n                    function pouchCountAllUndeleted(\n                        pouchdb: PouchDBInstance\n                    ): Promise<number> {\n                        return pouchdb\n                            .allDocs({\n                                include_docs: false,\n                                attachments: false\n                            })\n                            .then(docs => (docs.rows as any[])\n                                .filter(row => !row.id.startsWith('_design/'))\n                                .length\n                            );\n                    }\n\n                    const undeleted = await getAllDocuments(\n                        old.schema.primaryPath,\n                        old.storageInstance\n                    );\n                    const amount = undeleted.length;\n                    assert.strictEqual(amount, 10);\n\n                    const pouchLocation = old.storageInstance.internals.pouch.name;\n                    const checkPouch = new PouchDB(pouchLocation, {\n                        adapter: 'memory'\n                    });\n                    const amountPlain = await pouchCountAllUndeleted(checkPouch as any);\n                    assert.strictEqual(amountPlain, 10);\n\n                    // check that internal doc exists\n                    let docId = 'collection|' + _collectionNamePrimary(col.name, old.schema.jsonSchema);\n                    let iDoc = await old.database.internalStore.internals.pouch.get(docId);\n                    assert.strictEqual(typeof iDoc.data.schemaHash, 'string');\n\n\n                    await deleteOldCollection(old);\n\n                    // check that all docs deleted\n                    const checkPouch2 = new PouchDB(pouchLocation, {\n                        adapter: 'memory'\n                    });\n                    const amountPlain2 = await pouchCountAllUndeleted(checkPouch2 as any);\n                    assert.strictEqual(amountPlain2, 0);\n\n                    // check that internal doc deleted\n                    let has = true;\n                    docId = 'collection|' + _collectionNamePrimary(col.name, old.schema.jsonSchema);\n                    try {\n                        iDoc = await old.database.internalStore.internals.pouch.get(docId);\n                    } catch (e) {\n                        has = false;\n                    }\n                    assert.strictEqual(has, false);\n                    oldCollections.forEach(c => c.storageInstance.close());\n                    col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should not crash when doc already at new collection","suites":["DataMigrator.js","OldCollection","._migrateDocuments()"],"updatePoint":{"line":407,"column":71},"line":407,"code":"                it('should not crash when doc already at new collection', async () => {\n                    const col = await humansCollection.createMigrationCollection(10, {\n                        3: (doc: any) => {\n                            doc.age = parseInt(doc.age, 10);\n                            return doc;\n                        }\n                    });\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const oldCol = lastOfArray(oldCollections);\n\n                    // simluate prerun of migrate()\n                    const oldDocs = await getBatchOfOldCollection(oldCol as any, 10);\n                    const tryDoc = oldDocs.shift();\n                    const actions = await _migrateDocuments(oldCol as any, [tryDoc]);\n                    assert.strictEqual(actions[0].type, 'success');\n\n                    // this should no crash because existing doc will be overwritten\n                    await _migrateDocuments(oldCol as any, [tryDoc]);\n\n                    await Promise.all(\n                        oldCollections.map(c => c.storageInstance.close())\n                    );\n                    await col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should resolve finished when no docs","suites":["DataMigrator.js","OldCollection",".migrate()"],"updatePoint":{"line":433,"column":56},"line":433,"code":"                it('should resolve finished when no docs', async () => {\n                    const col = await humansCollection.createMigrationCollection(0);\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const oldCol = lastOfArray(oldCollections);\n\n                    await migratePromise(oldCol as any);\n                    await Promise.all(\n                        oldCollections.map(c => c.storageInstance.close())\n                    );\n                    await col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should resolve finished when some docs are in the collection","suites":["DataMigrator.js","OldCollection",".migrate()"],"updatePoint":{"line":444,"column":80},"line":444,"code":"                it('should resolve finished when some docs are in the collection', async () => {\n                    if (!config.storage.name.includes('pouchdb')) {\n                        return;\n                    }\n                    const col = await humansCollection.createMigrationCollection(10, {\n                        3: (doc: any) => {\n                            doc.age = parseInt(doc.age, 10);\n                            return doc;\n                        }\n                    });\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const oldCol = lastOfArray(oldCollections);\n\n                    const docsPrev = await col.storageInstance.internals.pouch.allDocs({\n                        include_docs: false,\n                        attachments: false\n                    });\n                    const preFiltered = docsPrev.rows.filter((doc: any) => !doc.id.startsWith('_design'));\n                    assert.strictEqual(preFiltered.length, 0);\n\n                    await migratePromise(oldCol as any);\n\n                    // check if in new collection\n                    const docs = await col.find().exec();\n                    assert.strictEqual(docs.length, 10);\n                    await Promise.all(\n                        oldCollections.map(c => c.storageInstance.close())\n                    );\n                    await col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should emit status for every handled document","suites":["DataMigrator.js","OldCollection",".migrate()"],"updatePoint":{"line":474,"column":65},"line":474,"code":"                it('should emit status for every handled document', async () => {\n                    const col = await humansCollection.createMigrationCollection(10, {\n                        3: async (doc: any) => {\n                            await promiseWait(10);\n                            doc.age = parseInt(doc.age, 10);\n                            return doc;\n                        }\n                    });\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const oldCol = lastOfArray(oldCollections);\n\n                    const pw8 = AsyncTestUtil.waitResolveable(1000);\n\n                    // batchSize is doc.length / 2 to make sure it takes a bit\n                    const state$ = migrateOldCollection(oldCol as any, 5);\n                    const states = [];\n                    state$.subscribe((state: any) => {\n                        assert.strictEqual(state.type, 'success');\n                        assert.ok(state.doc.passportId);\n                        states.push(state);\n                    }, () => {\n                        throw new Error('this test should not call error');\n                    }, () => pw8.resolve());\n\n                    await pw8.promise;\n                    assert.strictEqual(states.length, 10);\n                    await Promise.all(\n                        oldCollections.map(c => c.storageInstance.close())\n                    );\n                    await col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should emit \"deleted\" when migration-strategy returns null","suites":["DataMigrator.js","OldCollection",".migrate()"],"updatePoint":{"line":506,"column":78},"line":506,"code":"                it('should emit \"deleted\" when migration-strategy returns null', async () => {\n                    const col = await humansCollection.createMigrationCollection(10, {\n                        3: async () => {\n                            return null;\n                        }\n                    });\n                    const olds = await _getOldCollections(col.getDataMigrator());\n                    const oldCol = olds.pop();\n\n                    // batchSize is doc.length / 2 to make sure it takes a bit\n                    const state$ = migrateOldCollection(oldCol as any, 5);\n                    const states = [];\n                    state$.subscribe((state: any) => {\n                        assert.strictEqual(state.type, 'deleted');\n                        states.push(state);\n                    });\n\n                    await AsyncTestUtil.waitUntil(() => states.length === 10);\n                    col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should throw when document cannot be migrated","suites":["DataMigrator.js","OldCollection",".migrate()"],"updatePoint":{"line":526,"column":65},"line":526,"code":"                it('should throw when document cannot be migrated', async () => {\n                    const col = await humansCollection.createMigrationCollection(10, {\n                        3: () => {\n                            throw new Error('foobar');\n                        }\n                    });\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const oldCol = lastOfArray(oldCollections);\n                    await AsyncTestUtil.assertThrows(\n                        () => migratePromise(oldCol as any),\n                        Error\n                    );\n                    await Promise.all(\n                        oldCollections.map(c => c.storageInstance.close())\n                    );\n                    await col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should not crash when nothing to migrate","suites":["DataMigrator.js",".migrate()","positive"],"updatePoint":{"line":548,"column":60},"line":548,"code":"                it('should not crash when nothing to migrate', async () => {\n                    const col = await humansCollection.createMigrationCollection(0, {});\n                    const pw8 = AsyncTestUtil.waitResolveable(5000); // higher than test-timeout\n                    const states: any[] = [];\n                    const state$ = col.migrate();\n                    state$['subscribe'](s => {\n                        states.push(s);\n                    }, null, pw8.resolve as any);\n\n                    await pw8.promise;\n                    assert.strictEqual(states[0].done, false);\n                    assert.strictEqual(states[0].percent, 0);\n                    assert.strictEqual(states[0].total, 0);\n\n                    assert.strictEqual(states[1].done, true);\n                    assert.strictEqual(states[1].percent, 100);\n                    assert.strictEqual(states[1].total, 0);\n                    col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should not crash when migrating data","suites":["DataMigrator.js",".migrate()","positive"],"updatePoint":{"line":568,"column":56},"line":568,"code":"                it('should not crash when migrating data', async () => {\n                    const col = await humansCollection.createMigrationCollection(5, {\n                        3: (doc: any) => {\n                            doc.age = parseInt(doc.age, 10);\n                            return doc;\n                        }\n                    });\n                    const pw8 = AsyncTestUtil.waitResolveable(5000); // higher than test-timeout\n                    const states: any[] = [];\n                    const state$ = col.migrate();\n                    state$['subscribe'](s => {\n                        states.push(s);\n                    }, null, pw8.resolve as any);\n\n                    await pw8.promise;\n\n                    assert.strictEqual(states.length, 7);\n\n                    assert.strictEqual(states[0].done, false);\n                    assert.strictEqual(states[0].percent, 0);\n                    assert.strictEqual(states[0].total, 5);\n\n                    const midState = states[4];\n                    assert.strictEqual(midState.done, false);\n                    assert.strictEqual(midState.percent, 80);\n                    assert.strictEqual(midState.handled, 4);\n                    assert.strictEqual(midState.success, 4);\n\n                    const lastState = states.pop();\n                    assert.strictEqual(lastState.done, true);\n                    assert.strictEqual(lastState.percent, 100);\n                    assert.strictEqual(lastState.total, 5);\n                    assert.strictEqual(lastState.success, 5);\n                    col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should .error when strategy fails","suites":["DataMigrator.js",".migrate()","negative"],"updatePoint":{"line":605,"column":53},"line":605,"code":"                it('should .error when strategy fails', async () => {\n                    const col = await humansCollection.createMigrationCollection(5, {\n                        3: () => {\n                            throw new Error('foobar');\n                        }\n                    });\n                    const pw8 = AsyncTestUtil.waitResolveable(5000); // higher than test-timeout\n                    const state$ = col.migrate();\n                    state$.subscribe(undefined, pw8.resolve as any, undefined);\n\n                    await pw8.promise;\n                    col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should resolve when nothing to migrate","suites":["DataMigrator.js",".migratePromise()","positive"],"updatePoint":{"line":622,"column":58},"line":622,"code":"                it('should resolve when nothing to migrate', async () => {\n                    const col = await humansCollection.createMigrationCollection(0, {});\n                    await col.migratePromise();\n                    col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should resolve when migrating data","suites":["DataMigrator.js",".migratePromise()","positive"],"updatePoint":{"line":628,"column":54},"line":628,"code":"                it('should resolve when migrating data', async () => {\n                    const col = await humansCollection.createMigrationCollection(5, {\n                        3: (doc: any) => {\n                            doc.age = parseInt(doc.age, 10);\n                            return doc;\n                        }\n                    });\n                    await col.migratePromise();\n                    col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should reject when migration fails","suites":["DataMigrator.js",".migratePromise()","negative"],"updatePoint":{"line":640,"column":54},"line":640,"code":"                it('should reject when migration fails', async () => {\n                    const col = await humansCollection.createMigrationCollection(5, {\n                        3: () => {\n                            throw new Error('foobar');\n                        }\n                    });\n                    let failed = false;\n                    await col.migratePromise().catch(() => failed = true);\n                    assert.ok(failed);\n                    col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should contain the schema validation error in the thrown object","suites":["DataMigrator.js",".migratePromise()","negative"],"updatePoint":{"line":651,"column":83},"line":651,"code":"                it('should contain the schema validation error in the thrown object', async () => {\n                    const col = await humansCollection.createMigrationCollection(5, {\n                        3: (docData: SimpleHumanV3DocumentType) => {\n                            /**\n                             * Delete required age-field\n                             * to provoke schema validation error\n                             */\n                            delete (docData as any).age;\n                            return docData;\n                        }\n                    });\n\n                    let hasThrown = false;\n                    try {\n                        await col.migratePromise();\n                    } catch (err) {\n                        hasThrown = true;\n                        /**\n                         * Should contain the validation errors\n                         */\n                        assert.ok(JSON.stringify((err as RxError).parameters.errors).includes('data.age'));\n                    }\n                    assert.ok(hasThrown);\n\n                    col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should auto-run on creation","suites":["integration into collection","run"],"updatePoint":{"line":682,"column":43},"line":682,"code":"            it('should auto-run on creation', async () => {\n                const col = await humansCollection.createMigrationCollection(\n                    10,\n                    {\n                        3: (doc: any) => {\n                            doc.age = parseInt(doc.age, 10);\n                            return doc;\n                        }\n                    },\n                    randomCouchString(10),\n                    true\n                );\n                const docs = await col.find().exec();\n                assert.strictEqual(docs.length, 10);\n                assert.strictEqual(typeof (docs.pop() as any).age, 'number');\n                col.database.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should be able to change the primary key during migration","suites":["integration into collection","run"],"updatePoint":{"line":699,"column":73},"line":699,"code":"            it('should be able to change the primary key during migration', async () => {\n                const dbName = randomCouchString(10);\n                const schema0 = {\n                    version: 0,\n                    primaryKey: 'id',\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    },\n                    required: ['id']\n                };\n                const schema1 = {\n                    version: 1,\n                    primaryKey: 'id',\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        name: {\n                            type: 'string'\n                        }\n                    },\n                    required: ['id', 'name']\n                };\n                const db = await createRxDatabase({\n                    name: dbName,\n                    storage: config.storage.getStorage(),\n                });\n                const cols = await db.addCollections({\n                    heroes: {\n                        schema: schema0\n                    }\n                });\n                const col = cols.heroes;\n                await col.insert({\n                    id: 'niven'\n                });\n                await db.destroy();\n\n                const db2 = await createRxDatabase({\n                    name: dbName,\n                    storage: config.storage.getStorage(),\n                });\n                const cols2 = await db2.addCollections({\n                    heroes: {\n                        schema: schema1,\n                        migrationStrategies: {\n                            1: (oldDoc: any) => {\n                                oldDoc.name = (oldDoc.id as string).toUpperCase();\n                                return oldDoc;\n                            }\n                        }\n                    }\n                });\n                const col2 = cols2.heroes;\n\n                const doc = await col2.findOne().exec();\n\n                assert.ok(doc);\n                assert.strictEqual(doc.id, 'niven');\n                assert.strictEqual(doc.name, 'NIVEN');\n                db2.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should auto-run on creation (async)","suites":["integration into collection","run"],"updatePoint":{"line":768,"column":51},"line":768,"code":"            it('should auto-run on creation (async)', async () => {\n                const col = await humansCollection.createMigrationCollection(\n                    10, {\n                    3: async (doc: any) => {\n                        promiseWait(10);\n                        doc.age = parseInt(doc.age, 10);\n                        return doc;\n                    }\n                },\n                    randomCouchString(10),\n                    true\n                );\n                const docs = await col.find().exec();\n                assert.strictEqual(docs.length, 10);\n                assert.strictEqual(typeof (docs.pop() as any).age, 'number');\n                col.database.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should increase revision height when the strategy changed the documents data","suites":["integration into collection","run"],"updatePoint":{"line":785,"column":92},"line":785,"code":"            it('should increase revision height when the strategy changed the documents data', async () => {\n                const dbName = randomCouchString(10);\n\n                const nonChangedKey = 'not-changed-data';\n                const changedKey = 'changed-data';\n\n                const db = await createRxDatabase({\n                    name: dbName,\n                    storage: config.storage.getStorage(),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.humanFinal\n                    }\n                });\n                const col = cols.humans;\n                await col.bulkInsert([\n                    {\n                        passportId: changedKey,\n                        firstName: 'foo',\n                        lastName: 'bar',\n                        age: 20\n                    },\n                    {\n                        passportId: nonChangedKey,\n                        firstName: 'foo',\n                        lastName: 'bar',\n                        age: 21\n                    }\n                ]);\n\n                const revBeforeMigration = (await col.findOne(nonChangedKey).exec(true)).toJSON(true)._rev;\n                await db.destroy();\n\n                const db2 = await createRxDatabase({\n                    name: dbName,\n                    storage: config.storage.getStorage(),\n                });\n                const schema2 = clone(schemas.humanFinal);\n                schema2.version = 1;\n\n                const cols2 = await db2.addCollections({\n                    humans: {\n                        schema: schema2,\n                        migrationStrategies: {\n                            1: function (docData: HumanDocumentType) {\n                                if (docData.passportId === changedKey) {\n                                    docData.age = 100;\n                                }\n                                return docData;\n                            }\n                        }\n                    }\n                });\n                const col2 = cols2.humans;\n\n                /**\n                 * If document data was not changed by migration, it should have kept the same revision\n                 */\n                const revAfterMigration = (await col2.findOne(nonChangedKey).exec(true)).toJSON(true)._rev;\n                assert.strictEqual(revBeforeMigration, revAfterMigration);\n\n                /**\n                 * If document was changed, we should have an increased revision height\n                 * to ensure that replicated instances use our new data.\n                 */\n                const revChangedAfterMigration = (await col2.findOne(changedKey).exec(true)).toJSON(true)._rev;\n                const afterHeight = getHeightOfRevision(revChangedAfterMigration);\n                assert.strictEqual(afterHeight, 2);\n\n                db2.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"return true if schema-version is 0","suites":["integration into collection",".migrationNeeded()"],"updatePoint":{"line":859,"column":50},"line":859,"code":"            it('return true if schema-version is 0', async () => {\n                const col = await humansCollection.create();\n                const needed = await col.migrationNeeded();\n                assert.strictEqual(needed, false);\n                col.database.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"return false if nothing to migrate","suites":["integration into collection",".migrationNeeded()"],"updatePoint":{"line":865,"column":50},"line":865,"code":"            it('return false if nothing to migrate', async () => {\n                const col = await humansCollection.createMigrationCollection(5, {\n                    3: (doc: any) => {\n                        doc.age = parseInt(doc.age, 10);\n                        return doc;\n                    }\n                });\n                await col.migratePromise();\n                const needed = await col.migrationNeeded();\n                assert.strictEqual(needed, false);\n                col.database.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"return true if something to migrate","suites":["integration into collection",".migrationNeeded()"],"updatePoint":{"line":877,"column":51},"line":877,"code":"            it('return true if something to migrate', async () => {\n                const col = await humansCollection.createMigrationCollection(5, {\n                    3: (doc: any) => {\n                        doc.age = parseInt(doc.age, 10);\n                        return doc;\n                    }\n                });\n                const needed = await col.migrationNeeded();\n                assert.strictEqual(needed, true);\n                col.database.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should emit the ongoing migration state","suites":["RxDatabase.migrationStates()"],"updatePoint":{"line":891,"column":51},"line":891,"code":"        it('should emit the ongoing migration state', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage(),\n            });\n            const migrationStrategies = {\n                1: () => { },\n                2: () => { },\n                3: () => { }\n            };\n\n            const emitted: any[] = [];\n            db.migrationStates().subscribe(x => emitted.push(x));\n\n            await db.addCollections({\n                foobar: {\n                    schema: schemas.simpleHumanV3,\n                    autoMigrate: false,\n                    migrationStrategies\n                },\n                foobar2: {\n                    schema: schemas.simpleHumanV3,\n                    autoMigrate: false,\n                    migrationStrategies\n                }\n            });\n\n            await Promise.all([\n                db.foobar.migrate().toPromise(),\n                db.foobar2.migrate().toPromise()\n            ]);\n\n            assert.ok(emitted.length >= 2);\n\n            const endStates = emitted.map(list => list.map((i: any) => i.state)).pop();\n            if (!endStates) {\n                throw new Error('endStates missing');\n            }\n            assert.strictEqual(endStates.length, 2);\n            endStates.forEach((s: any) => {\n                assert.strictEqual(s.done, true);\n            });\n\n            db.destroy();\n        });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should add the _meta field if it is missing","suites":["major versions","12.0.0"],"updatePoint":{"line":945,"column":59},"line":945,"code":"            it('should add the _meta field if it is missing', async () => {\n                const dbName = randomCouchString(10);\n                const docId = 'foobar';\n                const db = await createRxDatabase({\n                    name: dbName,\n                    storage: config.storage.getStorage(),\n                });\n                await db.addCollections<{\n                    foobar: RxCollection<SimpleHumanV3DocumentType>\n                }>({\n                    foobar: {\n                        schema: schemas.simpleHuman\n                    }\n                });\n                const collection: RxCollection<SimpleHumanV3DocumentType> = db.foobar;\n\n                // insert a document without the _meta field\n                const insertDocData = Object.assign(\n                    simpleHumanV3(docId),\n                    {\n                        _deleted: false,\n                        _attachments: {},\n                        // DO NOT ADD THE META FIELD HERE\n                        // _meta: {\n                        //     lwt: 3\n                        // }\n                    } as any\n                );\n                await collection.storageInstance.bulkWrite([{\n                    document: insertDocData\n                }]);\n                await db.destroy();\n\n                const db2 = await createRxDatabase({\n                    name: dbName,\n                    storage: config.storage.getStorage(),\n                });\n                const schemaV2 = clone(schemas.simpleHuman);\n                schemaV2.version = 1;\n                await db2.addCollections<{\n                    foobar: RxCollection<SimpleHumanV3DocumentType>\n                }>({\n                    foobar: {\n                        schema: schemaV2,\n                        migrationStrategies: {\n                            1: (oldDoc: SimpleHumanV3DocumentType) => {\n                                (oldDoc as any).age = '99';\n                                return oldDoc;\n                            }\n                        }\n                    }\n                });\n                const collection2: RxCollection<SimpleHumanV3DocumentType> = db2.foobar;\n\n                const doc = await collection2.findOne(docId).exec(true);\n                const docData = doc.toJSON(true);\n\n                assert.ok(docData._meta);\n                assert.ok(docData._meta.lwt);\n\n                db2.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"reproduce and fix","suites":["issues","#212 migration runs into infinity-loop"],"updatePoint":{"line":1011,"column":33},"line":1011,"code":"            it('reproduce and fix', async () => {\n                const dbName = randomCouchString(10);\n                const schema0 = {\n                    title: 'hero schema',\n                    description: 'describes a simple hero',\n                    version: 0,\n                    primaryKey: 'name',\n                    type: 'object',\n                    properties: {\n                        name: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        color: {\n                            type: 'string'\n                        }\n                    },\n                    required: ['color']\n                };\n                const schema1 = {\n                    title: 'hero schema',\n                    description: 'describes a simple hero',\n                    version: 1,\n                    primaryKey: 'name',\n                    type: 'object',\n                    properties: {\n                        name: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        color: {\n                            type: 'string'\n                        },\n                        level: {\n                            type: 'string'\n                        }\n                    },\n                    required: ['color']\n                };\n                const db = await createRxDatabase({\n                    name: dbName,\n                    storage: config.storage.getStorage(),\n                });\n                const cols = await db.addCollections({\n                    heroes: {\n                        schema: schema0\n                    }\n                });\n                const col = cols.heroes;\n                await col.insert({\n                    name: 'Niven',\n                    color: 'black'\n                });\n                await db.destroy();\n\n                const db2 = await createRxDatabase({\n                    name: dbName,\n                    storage: config.storage.getStorage(),\n                });\n                const cols2 = await db2.addCollections({\n                    heroes: {\n                        schema: schema1,\n                        migrationStrategies: {\n                            1: (oldDoc: any) => {\n                                oldDoc.level = 'ss';\n                                return oldDoc;\n                            }\n                        }\n                    }\n                });\n                const col2 = cols2.heroes;\n\n                const docs = await col2.find().exec();\n                assert.strictEqual(docs.length, 1);\n                assert.strictEqual(docs[0].level, 'ss');\n                assert.strictEqual(docs[0].name, 'Niven');\n                assert.strictEqual(docs[0].color, 'black');\n                db2.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"#3460 migrate attachments","suites":["issues","#212 migration runs into infinity-loop"],"updatePoint":{"line":1091,"column":37},"line":1091,"code":"        it('#3460 migrate attachments', async () => {\n            const attachmentData = AsyncTestUtil.randomString(20);\n            const dataBlobBuffer = blobBufferUtil.createBlobBuffer(\n                attachmentData,\n                'text/plain'\n            );\n\n            const statics = config.storage.getStorage().statics;\n            const attachmentHash = await statics.hash(dataBlobBuffer);\n\n            const col = await humansCollection.createMigrationCollection(10, {\n                3: (doc: any) => {\n                    doc.age = parseInt(doc.age, 10);\n                    return doc;\n                }\n            }, randomCouchString(10), false, {\n                id: 'foo',\n                data: dataBlobBuffer,\n                type: 'text/plain'\n            });\n            const olds = await _getOldCollections(col.getDataMigrator());\n            const oldCol = lastOfArray(olds);\n\n            const oldDocs = await getBatchOfOldCollection(oldCol as any, 10);\n            const tryDoc = oldDocs.shift();\n            const actions = await _migrateDocuments(oldCol as any, [tryDoc]);\n            assert.strictEqual(actions[0].type, 'success');\n\n            const docs = await col.find().exec();\n            const attachment = docs[0].getAttachment('foo');\n            assert.ok(attachment);\n            assert.strictEqual(attachment.type, 'text/plain');\n            assert.strictEqual(attachment.digest, statics.hashKey + '-' + attachmentHash);\n            assert.strictEqual(attachment.length, attachmentData.length);\n\n            olds.forEach(oldCol => oldCol.storageInstance.close());\n            col.database.destroy();\n        });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should convert unsupported IndexedDB key","suites":[".fromStorageToDexie()"],"updatePoint":{"line":27,"column":52},"line":27,"code":"        it('should convert unsupported IndexedDB key', () => {\n            const result = fromStorageToDexie(\n                {\n                    '|key': 'value',\n                    '|objectArray': [{['|id']: '1'}],\n                    '|nestedObject': {\n                        key: 'value2',\n                        '|objectArray': [{'|id': '2'}],\n                        stringArray: ['415', '51'],\n                        '|numberArray': [1, 2, 3],\n                        '|falsyValue': null\n                    }\n                }\n            );\n            assert.deepStrictEqual(result, {\n                '__key': 'value',\n                '__objectArray': [{['__id']: '1'}],\n                '__nestedObject': {\n                    key: 'value2',\n                    '__objectArray': [{'__id': '2'}],\n                    stringArray: ['415', '51'],\n                    '__numberArray': [1, 2, 3],\n                    '__falsyValue': null\n                }\n            });\n        });","file":"unit/dexie-helper.test.ts","skipped":false,"dir":"test"},{"name":"should revert escaped unsupported IndexedDB key","suites":[".fromDexieToStorage()"],"updatePoint":{"line":55,"column":59},"line":55,"code":"        it('should revert escaped unsupported IndexedDB key', () => {\n            const result = fromDexieToStorage({\n                    '__key': 'value',\n                    '__objectArray': [{['__id']: '1'}],\n                    '__nestedObject': {\n                        key: 'value2',\n                        '__objectArray': [{'__id': '2'}],\n                        stringArray: ['415', '51'],\n                        '__numberArray': [1, 2, 3],\n                        '__falsyValue': null\n                    }\n                }\n            );\n            assert.deepStrictEqual(result,\n                {\n                    '|key': 'value',\n                    '|objectArray': [{['|id']: '1'}],\n                    '|nestedObject': {\n                        key: 'value2',\n                        '|objectArray': [{'|id': '2'}],\n                        stringArray: ['415', '51'],\n                        '|numberArray': [1, 2, 3],\n                        '|falsyValue': null\n                    }\n                });\n        });","file":"unit/dexie-helper.test.ts","skipped":false,"dir":"test"},{"name":"string","suites":["basics",".encryptString()"],"updatePoint":{"line":25,"column":22},"line":25,"code":"            it('string', () => {\n                const value = 'foobar';\n                const encrypted = encryptString(value, 'mypw');\n                assert.strictEqual(typeof encrypted, 'string');\n                assert.ok(!encrypted.includes(value));\n                assert.ok(encrypted.length > value.length);\n            });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"string","suites":["basics",".decryptString()"],"updatePoint":{"line":34,"column":22},"line":34,"code":"            it('string', () => {\n                const value = 'foobar';\n                const encrypted = encryptString(value, 'mypw');\n                const decrypted = decryptString(encrypted, 'mypw');\n                assert.deepStrictEqual(decrypted, value);\n            });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"should encrypt and decrypt an extremly long string","suites":["basics",".decryptString()"],"updatePoint":{"line":40,"column":66},"line":40,"code":"            it('should encrypt and decrypt an extremly long string', () => {\n                const value = randomCouchString(5000);\n                const pwd = 'pwd';\n                const encrypted = encryptString(value, pwd);\n                const decrypted = decryptString(encrypted, pwd);\n                assert.notStrictEqual(value, encrypted);\n                assert.ok(encrypted.length > value.length);\n                assert.strictEqual(typeof encrypted, 'string');\n                assert.strictEqual(value, decrypted);\n            });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"should encrypt and decrypt an extremly long password","suites":["basics",".decryptString()"],"updatePoint":{"line":50,"column":68},"line":50,"code":"            it('should encrypt and decrypt an extremly long password', () => {\n                const value = 'foobar';\n                const pwd = randomCouchString(5000);\n                const encrypted = encryptString(value, pwd);\n                const decrypted = decryptString(encrypted, pwd);\n                assert.notStrictEqual(value, encrypted);\n                assert.ok(encrypted.length > value.length);\n                assert.strictEqual(typeof encrypted, 'string');\n                assert.strictEqual(value, decrypted);\n            });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"should insert one encrypted value (string)","suites":["Collection.insert()","positive"],"updatePoint":{"line":64,"column":58},"line":64,"code":"            it('should insert one encrypted value (string)', async () => {\n                const c = await humansCollection.createEncrypted(0);\n                const agent = schemaObjects.encryptedHuman();\n                await c.insert(agent);\n                const doc = await c.findOne().exec(true);\n                const secret = doc.get('secret');\n                assert.strictEqual(agent.secret, secret);\n                c.database.destroy();\n            });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"should insert one encrypted value (object)","suites":["Collection.insert()","positive"],"updatePoint":{"line":73,"column":58},"line":73,"code":"            it('should insert one encrypted value (object)', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    password: randomCouchString(10)\n                });\n                const c = await db.addCollections({\n                    enchuman: {\n                        schema: schemas.encryptedObjectHuman\n                    }\n                });\n                const agent = schemaObjects.encryptedObjectHuman();\n                await c.enchuman.insert(agent);\n                const doc = await c.enchuman.findOne().exec();\n                const secret = doc.get('secret');\n                assert.strictEqual(agent.secret.name, secret.name);\n                assert.strictEqual(agent.secret.subname, secret.subname);\n                db.destroy();\n            });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"should save one encrypted value (string)","suites":["RxDocument.save()","positive"],"updatePoint":{"line":97,"column":56},"line":97,"code":"            it('should save one encrypted value (string)', async () => {\n                const c = await humansCollection.createEncrypted(0);\n                const agent = schemaObjects.encryptedHuman();\n                await c.insert(agent);\n                const doc = await c.findOne().exec(true);\n                const secret = doc.get('secret');\n                assert.strictEqual(agent.secret, secret);\n                const newSecret = randomCouchString(10);\n\n                await doc.atomicPatch({ secret: newSecret });\n                const docNew = await c.findOne().exec(true);\n                assert.strictEqual(newSecret, docNew.get('secret'));\n                c.database.destroy();\n            });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"should save one encrypted value (object)","suites":["RxDocument.save()","positive"],"updatePoint":{"line":111,"column":56},"line":111,"code":"            it('should save one encrypted value (object)', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    password: randomCouchString(10)\n                });\n                const c = await db.addCollections({\n                    enchuman: {\n                        schema: schemas.encryptedObjectHuman\n                    }\n                });\n                const agent = schemaObjects.encryptedObjectHuman();\n                await c.enchuman.insert(agent);\n                const newSecret = {\n                    name: randomCouchString(10),\n                    subname: randomCouchString(10)\n                };\n                const doc = await c.enchuman.findOne().exec(true);\n                const secret = doc.get('secret');\n\n                assert.strictEqual(agent.secret.name, secret.name);\n                assert.strictEqual(agent.secret.subname, secret.subname);\n\n                await doc.atomicPatch({ secret: newSecret });\n                const docNew = await c.enchuman.findOne().exec(true);\n\n                assert.strictEqual(newSecret.name, docNew.get('secret.name'));\n                assert.strictEqual(newSecret.subname, docNew.get('secret.subname'));\n                db.destroy();\n            });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"#837 Recover from wrong database password","suites":["ISSUES"],"updatePoint":{"line":146,"column":53},"line":146,"code":"        it('#837 Recover from wrong database password', async () => {\n            const name = randomCouchString(10) + '837';\n            const password = randomCouchString(10);\n\n            // 1. create and destroy encrypted db\n            const db1 = await createRxDatabase({\n                name,\n                storage: getRxStoragePouch('memory'),\n                password\n            });\n            await db1.destroy();\n\n            // 2. reopen with wrong password\n            await AsyncTestUtil.assertThrows(\n                () => createRxDatabase({\n                    name,\n                    storage: getRxStoragePouch('memory'),\n                    password: 'foobarfoobar'\n                }),\n                'RxError',\n                'different password'\n            );\n\n            // 3. reopen with correct password\n            const db2 = await createRxDatabase({\n                name,\n                storage: getRxStoragePouch('memory'),\n                password\n            });\n            assert.ok(db2);\n            await db2.destroy();\n        });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"#917 Unexpected end of JSON input","suites":["ISSUES"],"updatePoint":{"line":178,"column":45},"line":178,"code":"        it('#917 Unexpected end of JSON input', async () => {\n            const schema: RxJsonSchema<{ name: string; color: string; happy: boolean; }> = {\n                title: 'hero schema',\n                description: 'describes a simple hero',\n                version: 0,\n                primaryKey: 'name',\n                type: 'object',\n                properties: {\n                    name: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    color: {\n                        type: 'string'\n                    },\n                    happy: {\n                        type: 'boolean'\n                    }\n                },\n                required: ['color'],\n                encrypted: [\n                    'color',\n                    'happy'\n                ]\n            };\n            const dbName = randomCouchString(10);\n\n            const db = await createRxDatabase({\n                name: dbName,\n                storage: config.storage.getStorage(),\n                password: 'myLongAndStupidPassword'\n            });\n\n            const collections = await db.addCollections({\n                heroes: {\n                    schema\n                }\n            });\n            const collection = collections.heroes;\n\n            // insert a document\n            const record = await collection.findOne().exec();\n            if (!record) {\n                await collection.upsert({\n                    name: 'big-billy',\n                    color: 'arugula',\n                });\n            }\n\n            // will throw exception\n            await collection.findOne().exec();\n\n            db.destroy();\n        });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"should have the same results on given data","suites":["event-reduce.test.js"],"updatePoint":{"line":62,"column":50},"line":62,"code":"    it('should have the same results on given data', async () => {\n        const queries: MangoQuery<any>[] = [\n            { selector: { age: { '$gt': 20 } }, sort: [{ passportId: 'asc' }] }\n        ];\n        const writeData = [\n            {\n                passportId: 's90j6hhznefj',\n                firstName: 'Freeman',\n                lastName: 'Rogahn',\n                age: 25\n            },\n            {\n                passportId: '6eu7byz49iq9',\n                firstName: 'Eugenia',\n                lastName: 'Dare',\n                age: 16\n            }\n        ];\n\n        const colNoEventReduce = await createCollection(false);\n        const colWithEventReduce = await createCollection(true);\n\n        await Promise.all(\n            writeData\n                .map(async (docData) => {\n                    await colNoEventReduce.insert(docData);\n                    await colWithEventReduce.insert(docData);\n                })\n        );\n\n        await testQueryResultForEqualness(\n            colNoEventReduce,\n            colWithEventReduce,\n            queries\n        );\n\n        // update one so it must now be in query results\n        await Promise.all(\n            [\n                colNoEventReduce,\n                colWithEventReduce\n            ].map(async (col) => {\n                const docToUpdate = await col\n                    .findOne('6eu7byz49iq9')\n                    .exec(true);\n                await docToUpdate.atomicPatch({ age: 50 });\n            })\n        );\n\n        await testQueryResultForEqualness(\n            colNoEventReduce,\n            colWithEventReduce,\n            queries\n        );\n\n        colNoEventReduce.database.destroy();\n        colWithEventReduce.database.destroy();\n    });","file":"unit/event-reduce.test.ts","skipped":false,"dir":"test"},{"name":"random data: should have the same results as without event-reduce","suites":["event-reduce.test.js"],"updatePoint":{"line":127,"column":77},"line":127,"code":"        it('random data: should have the same results as without event-reduce', async () => {\n            const colNoEventReduce = await createCollection(false);\n            const colWithEventReduce = await createCollection(true);\n\n            const queries: MangoQuery[] = [\n                {\n                    selector: {},\n                    sort: [{\n                        passportId: 'asc'\n                    }]\n                },\n                {\n                    selector: {\n                        age: {\n                            $gt: 20\n                        }\n                    },\n                    // TODO it should also work without the sorting\n                    // because RxDB should add predicatble sort if primary not used in sorting\n                    sort: [{\n                        passportId: 'asc'\n                    }]\n                }\n\n            ];\n\n            await testQueryResultForEqualness(\n                colNoEventReduce,\n                colWithEventReduce,\n                queries\n            );\n\n            // add some\n            await Promise.all(\n                new Array(3)\n                    .fill(0)\n                    .map(async () => {\n                        const doc = schemaObjects.human();\n                        await colNoEventReduce.insert(doc);\n                        await colWithEventReduce.insert(doc);\n                    })\n            );\n\n            await testQueryResultForEqualness(\n                colNoEventReduce,\n                colWithEventReduce,\n                queries\n            );\n\n            // update one\n            await Promise.all(\n                [\n                    colNoEventReduce,\n                    colWithEventReduce\n                ].map(async (col) => {\n                    const docToUpdate = await col\n                        .findOne()\n                        .sort('lastName')\n                        .exec(true);\n                    await docToUpdate.atomicPatch({ age: 50 });\n                })\n            );\n\n            await testQueryResultForEqualness(\n                colNoEventReduce,\n                colWithEventReduce,\n                queries\n            );\n\n            // remove one\n            await Promise.all(\n                [\n                    colNoEventReduce,\n                    colWithEventReduce\n                ].map(async (col) => {\n                    const doc = await col\n                        .findOne()\n                        .sort('age')\n                        .exec(true);\n                    await doc.remove();\n                })\n            );\n\n            await testQueryResultForEqualness(\n                colNoEventReduce,\n                colWithEventReduce,\n                queries\n            );\n\n            // remove another one\n            await Promise.all(\n                [\n                    colNoEventReduce,\n                    colWithEventReduce\n                ].map(async (col) => {\n                    const doc = await col\n                        .findOne()\n                        .sort('age')\n                        .exec(true);\n                    await doc.remove();\n                })\n            );\n\n            await testQueryResultForEqualness(\n                colNoEventReduce,\n                colWithEventReduce,\n                queries\n            );\n\n            // clean up\n            colNoEventReduce.database.destroy();\n            colWithEventReduce.database.destroy();\n        });","file":"unit/event-reduce.test.ts","skipped":false,"dir":"test"},{"name":"should set a hook","suites":["get/set"],"updatePoint":{"line":22,"column":29},"line":22,"code":"        it('should set a hook', async () => {\n            const c = await humansCollection.create(0);\n            c.preSave(function () { }, false);\n            c.database.destroy();\n        });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should get a hook","suites":["get/set"],"updatePoint":{"line":27,"column":29},"line":27,"code":"        it('should get a hook', async () => {\n            const c = await humansCollection.create(0);\n            c.preSave(function () { }, false);\n            const hooks = c.getHooks('pre', 'save');\n            assert.ok(Array.isArray(hooks.series));\n            assert.strictEqual(hooks.series.length, 1);\n            c.database.destroy();\n        });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should get a parallel hook","suites":["get/set"],"updatePoint":{"line":35,"column":38},"line":35,"code":"        it('should get a parallel hook', async () => {\n            const c = await humansCollection.create(0);\n            c.preSave(function () { }, true);\n            const hooks = c.getHooks('pre', 'save');\n            assert.ok(Array.isArray(hooks.parallel));\n            assert.strictEqual(hooks.parallel.length, 1);\n            c.database.destroy();\n        });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"series","suites":["insert","pre","positive"],"updatePoint":{"line":47,"column":26},"line":47,"code":"                it('series', async () => {\n                    const c = await humansCollection.create(0);\n                    const human = schemaObjects.human();\n                    let count = 0;\n                    c.preInsert((data, instance) => {\n                        assert.strictEqual(typeof instance, 'undefined');\n                        count++;\n                    }, false);\n                    await c.insert(human);\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"parallel","suites":["insert","pre","positive"],"updatePoint":{"line":59,"column":28},"line":59,"code":"                it('parallel', async () => {\n                    const c = await humansCollection.create(0);\n                    const human = schemaObjects.human();\n                    let count = 0;\n                    c.preInsert(function (doc, instance) {\n                        assert.strictEqual(typeof instance, 'undefined');\n                        count++;\n                    }, false);\n                    let countp = 0;\n                    c.preInsert(function (doc, instance) {\n                        assert.strictEqual(typeof instance, 'undefined');\n                        countp++;\n                    }, true);\n                    await c.insert(human);\n                    assert.strictEqual(count, 1);\n                    assert.strictEqual(countp, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should save a modified document","suites":["insert","pre","positive"],"updatePoint":{"line":77,"column":51},"line":77,"code":"                it('should save a modified document', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n\n                    c.preInsert(function (d, instance) {\n                        assert.strictEqual(typeof instance, 'undefined');\n                        d.lastName = 'foobar';\n                    }, false);\n\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    assert.strictEqual(doc.get('lastName'), 'foobar');\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"async: should save a modified document","suites":["insert","pre","positive"],"updatePoint":{"line":91,"column":58},"line":91,"code":"                it('async: should save a modified document', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n\n                    c.preInsert(async function (d, instance) {\n                        assert.strictEqual(typeof instance, 'undefined');\n                        await promiseWait(10);\n                        d.lastName = 'foobar';\n                    }, false);\n\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    assert.strictEqual(doc.get('lastName'), 'foobar');\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should not insert if hook throws","suites":["insert","pre","positive"],"updatePoint":{"line":106,"column":52},"line":106,"code":"                it('should not insert if hook throws', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    c.preInsert(() => {\n                        throw new Error('foobar');\n                    }, false);\n\n                    let failC = 0;\n                    try {\n                        await c.insert(human);\n                    } catch (e) {\n                        failC++;\n                    }\n                    assert.strictEqual(failC, 1);\n                    const doc = await c.findOne(human.passportId).exec();\n                    assert.strictEqual(doc, null);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should have the collection bound to the this-scope","suites":["insert","pre","positive"],"updatePoint":{"line":124,"column":70},"line":124,"code":"                it('should have the collection bound to the this-scope', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    (c as any).foo = 'bar';\n                    let hasRun = false;\n                    c.preInsert(function (this: any) {\n                        hasRun = true;\n                        assert.strictEqual(this.foo, 'bar');\n                    }, false);\n\n                    await c.insert(schemaObjects.simpleHuman());\n\n                    assert.ok(hasRun);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should throw if hook invalidates schema","suites":["insert","pre","negative"],"updatePoint":{"line":140,"column":59},"line":140,"code":"                it('should throw if hook invalidates schema', async () => {\n                    const c = await humansCollection.create(0);\n                    const human = schemaObjects.human();\n\n                    c.preInsert(function (doc: any) {\n                        doc.lastName = 1337;\n                    }, false);\n\n                    await AsyncTestUtil.assertThrows(\n                        () => c.insert(human),\n                        'RxError',\n                        'not match'\n                    );\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"series","suites":["insert","post","positive"],"updatePoint":{"line":159,"column":26},"line":159,"code":"                it('series', async () => {\n                    const c = await humansCollection.create(0);\n                    const human = schemaObjects.human();\n                    let count = 0;\n                    c.postInsert(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, false);\n                    await c.insert(human);\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"parallel","suites":["insert","post","positive"],"updatePoint":{"line":171,"column":28},"line":171,"code":"                it('parallel', async () => {\n                    const c = await humansCollection.create(0);\n                    const human = schemaObjects.human();\n                    let count = 0;\n                    c.postInsert(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        assert.ok(data.age);\n                        count++;\n                    }, true);\n                    await c.insert(human);\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should call post insert hook after bulkInsert","suites":["insert","post","positive"],"updatePoint":{"line":184,"column":65},"line":184,"code":"                it('should call post insert hook after bulkInsert', async () => {\n                    const c = await humansCollection.create(0);\n                    const human = schemaObjects.human();\n                    let count = 0;\n                    c.postInsert((data, instance) => {\n                        assert.ok(data.age);\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, false);\n                    await c.bulkInsert([human]);\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"series","suites":["save","pre","positive"],"updatePoint":{"line":203,"column":26},"line":203,"code":"                it('series', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    let count = 0;\n                    c.preSave(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, false);\n                    await doc.atomicPatch({ firstName: 'foobar' });\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"parallel","suites":["save","pre","positive"],"updatePoint":{"line":217,"column":28},"line":217,"code":"                it('parallel', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    let count = 0;\n                    c.preSave(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, true);\n                    await doc.atomicPatch({ firstName: 'foobar' });\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should save a modified document","suites":["save","pre","positive"],"updatePoint":{"line":231,"column":51},"line":231,"code":"                it('should save a modified document', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n\n                    let hasRun = false;\n                    c.preSave(function () {\n                        hasRun = true;\n                    }, false);\n\n                    await doc.atomicPatch({ firstName: 'foobar' });\n                    assert.ok(hasRun);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"async: should save a modified document","suites":["save","pre","positive"],"updatePoint":{"line":246,"column":58},"line":246,"code":"                it('async: should save a modified document', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n\n                    let hasRun = false;\n                    c.preSave(async function () {\n                        await promiseWait(10);\n                        hasRun = true;\n                    }, false);\n                    await doc.atomicPatch({ firstName: 'foobar' });\n                    assert.ok(hasRun);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should not save if hook throws","suites":["save","pre","positive"],"updatePoint":{"line":261,"column":50},"line":261,"code":"                it('should not save if hook throws', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    human.firstName = 'test';\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n\n                    c.preSave(function () {\n                        throw new Error('fail');\n                    }, false);\n\n                    let failC = 0;\n                    try {\n                        await doc.atomicPatch({ firstName: 'foobar' });\n                    } catch (e) {\n                        failC++;\n                    }\n                    assert.strictEqual(failC, 1);\n                    const syncValue = await (doc as any).firstName$.pipe(first()).toPromise();\n                    assert.strictEqual(syncValue, 'test');\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"series","suites":["save","post","positive"],"updatePoint":{"line":287,"column":26},"line":287,"code":"                it('series', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    let count = 0;\n                    c.postSave(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, false);\n                    await doc.atomicPatch({ firstName: 'foobar' });\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"parallel","suites":["save","post","positive"],"updatePoint":{"line":301,"column":28},"line":301,"code":"                it('parallel', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    let count = 0;\n                    c.postSave(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, true);\n                    await doc.atomicPatch({ firstName: 'foobar' });\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"series","suites":["remove","pre","positive"],"updatePoint":{"line":322,"column":26},"line":322,"code":"                it('series', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    let count = 0;\n                    c.preRemove(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, false);\n                    await doc.remove();\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"parallel","suites":["remove","pre","positive"],"updatePoint":{"line":336,"column":28},"line":336,"code":"                it('parallel', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    let count = 0;\n                    c.preRemove(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, true);\n                    await doc.remove();\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should not remove if hook throws","suites":["remove","pre","positive"],"updatePoint":{"line":350,"column":52},"line":350,"code":"                it('should not remove if hook throws', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n\n                    c.preRemove(function () {\n                        throw new Error('fail');\n                    }, false);\n\n                    let failC = 0;\n                    try {\n                        await doc.remove();\n                    } catch (e) {\n                        failC++;\n                    }\n                    assert.strictEqual(failC, 1);\n                    const doc2 = await c.findOne(human.passportId).exec(true);\n                    assert.strictEqual(doc2.get('passportId'), human.passportId);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should call pre remove hook before bulkRemove","suites":["remove","pre","positive"],"updatePoint":{"line":371,"column":65},"line":371,"code":"                it('should call pre remove hook before bulkRemove', async () => {\n                    const c = await humansCollection.create(5);\n                    const docList = await c.find().exec();\n                    const primaryList = docList.map(doc => doc.primary);\n\n                    let count = 0;\n                    c.preRemove((data, instance) => {\n                        assert.ok(isRxDocument(instance));\n                        assert.ok(data.age);\n                        count++;\n                    }, true);\n\n                    await c.bulkRemove(primaryList);\n                    assert.strictEqual(count, 5);\n\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"series","suites":["remove","post","positive"],"updatePoint":{"line":393,"column":26},"line":393,"code":"                it('series', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    let count = 0;\n                    c.postRemove(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, false);\n                    await doc.remove();\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"parallel","suites":["remove","post","positive"],"updatePoint":{"line":407,"column":28},"line":407,"code":"                it('parallel', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    let count = 0;\n                    c.postRemove(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, true);\n                    await doc.remove();\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should have the collection bound to the this-scope","suites":["remove","post","positive"],"updatePoint":{"line":421,"column":70},"line":421,"code":"                it('should have the collection bound to the this-scope', async () => {\n                    const c = await humansCollection.createPrimary(1);\n                    (c as any).foo2 = 'bar2';\n                    let hasRun = false;\n\n                    c.postRemove(function (this: any) {\n                        hasRun = true;\n                        assert.strictEqual(this.foo2, 'bar2');\n                    }, true);\n\n                    const doc = await c.findOne().exec(true);\n                    await doc.remove();\n\n                    assert.ok(hasRun);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should call post remove hook after bulkRemove","suites":["remove","post","positive"],"updatePoint":{"line":437,"column":65},"line":437,"code":"                it('should call post remove hook after bulkRemove', async () => {\n                    const c = await humansCollection.create(5);\n                    const docList = await c.find().exec();\n                    const primaryList = docList.map(doc => doc.primary);\n\n                    let count = 0;\n                    c.postRemove((data, instance) => {\n                        assert.ok(isRxDocument(instance));\n                        assert.ok(data.age);\n                        count++;\n                    }, true);\n                    await c.bulkRemove(primaryList);\n                    assert.strictEqual(count, 5);\n\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should define a getter","suites":["postCreate","positive"],"updatePoint":{"line":459,"column":38},"line":459,"code":"            it('should define a getter', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    multiInstance: true\n                });\n                const collections = await db.addCollections({\n                    myhumans: {\n                        schema: schemas.primaryHuman\n                    }\n                });\n                const collection = collections.myhumans;\n                collection.postCreate(function (_data, instance) {\n                    assert.ok(isRxDocument(instance));\n                    Object.defineProperty(instance, 'myField', {\n                        get: () => 'foobar',\n                    });\n                });\n\n                const human = schemaObjects.simpleHuman();\n                await collection.insert(human);\n                const doc = await collection.findOne().exec();\n                assert.strictEqual('foobar', doc.myField);\n\n                db.destroy();\n            });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should throw when adding an async-hook","suites":["postCreate","negative"],"updatePoint":{"line":487,"column":54},"line":487,"code":"            it('should throw when adding an async-hook', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    multiInstance: true\n                });\n                const collections = await db.addCollections({\n                    myhumans: {\n                        schema: schemas.primaryHuman\n                    }\n                });\n                const collection = collections.myhumans;\n\n                const hookFun = function (doc: any) {\n                    Object.defineProperty(doc, 'myField', {\n                        get: () => 'foobar',\n                    });\n                };\n\n                assert.throws(() => (collection as any).postCreate(hookFun, true));\n                db.destroy();\n            });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"ISSUE #158 : Throwing error in async preInsert does not prevent insert","suites":["issues"],"updatePoint":{"line":512,"column":82},"line":512,"code":"        it('ISSUE #158 : Throwing error in async preInsert does not prevent insert', async () => {\n            const c = await humansCollection.create(0);\n            c.preInsert(async function () {\n                await promiseWait(1);\n                throw new Error('This throw should prevent the insert');\n            }, false);\n            let hasThrown = false;\n            try {\n                await c.insert(schemaObjects.human());\n            } catch (e) {\n                hasThrown = true;\n            }\n            assert.ok(hasThrown);\n            await promiseWait(10);\n            const allDocs = await c.find().exec();\n            assert.strictEqual(allDocs.length, 0);\n            c.database.destroy();\n        });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should be able to call queue on database","suites":["integration"],"updatePoint":{"line":9,"column":52},"line":9,"code":"        it('should be able to call queue on database', async () => {\n            const c = await humansCollection.create(0);\n            await c.database.requestIdlePromise();\n            c.database.destroy();\n        });","file":"unit/idle-queue.test.ts","skipped":false,"dir":"test"},{"name":"inserts should always be faster than idle-call","suites":["integration"],"updatePoint":{"line":14,"column":58},"line":14,"code":"        it('inserts should always be faster than idle-call', async () => {\n            const c = await humansCollection.create(0);\n            const data = new Array(10).fill(0).map(() => schemaObjects.human());\n            const order: any[] = [];\n\n            Promise.all(data.map(\n                doc => c.insert(doc)\n            )).then(() => order.push(0));\n            c.database.requestIdlePromise().then(() => order.push(1));\n\n            await AsyncTestUtil.waitUntil(() => order.length === 2);\n            assert.deepStrictEqual(order, [0, 1]);\n\n            c.database.destroy();\n        });","file":"unit/idle-queue.test.ts","skipped":false,"dir":"test"},{"name":"export the collection","suites":["Collection",".exportJSON()"],"updatePoint":{"line":24,"column":37},"line":24,"code":"            it('export the collection', async () => {\n                const col = await humansCollection.create(5);\n                const json = await col.exportJSON();\n                assert.strictEqual(json.name, 'human');\n                assert.strictEqual(typeof json.schemaHash, 'string');\n                assert.strictEqual(json.docs.length, 5);\n                json.docs.map(doc => assert.strictEqual(typeof doc, 'object'));\n                col.database.destroy();\n            });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"export encrypted as decrypted","suites":["Collection",".exportJSON()"],"updatePoint":{"line":33,"column":45},"line":33,"code":"            it('export encrypted as decrypted', async () => {\n                const db = await createRxDatabase<{ enchuman: RxCollection<schemaObjects.EncryptedObjectHumanDocumentType> }>({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    password: randomCouchString(10)\n                });\n                const cols = await db.addCollections({\n                    enchuman: {\n                        schema: schemas.encryptedObjectHuman\n                    }\n                });\n                const col = cols.enchuman;\n\n                const fns = [];\n                for (let i = 0; i < 10; i++)\n                    fns.push(col.insert(schemaObjects.encryptedObjectHuman()));\n                await Promise.all(fns);\n\n                const json = await col.exportJSON();\n\n\n                assert.strictEqual(json.docs.length, 10);\n                json.docs.map(doc => {\n                    assert.strictEqual(typeof doc.secret, 'object');\n                    assert.strictEqual(typeof doc.secret.name, 'string');\n                    assert.strictEqual(typeof doc.secret.subname, 'string');\n                });\n                db.destroy();\n            });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"import json","suites":["Collection",".importJSON()","positive"],"updatePoint":{"line":66,"column":31},"line":66,"code":"                it('import json', async () => {\n                    const col = await humansCollection.createMultiInstance(\n                        randomCouchString(10),\n                        5\n                    );\n                    const json = await col.exportJSON();\n                    const emptyCol = await humansCollection.createMultiInstance(\n                        randomCouchString(10),\n                        0\n                    );\n                    const noDocs = await emptyCol.find().exec();\n                    assert.strictEqual(noDocs.length, 0);\n\n                    await emptyCol.importJSON(json);\n                    const docs = await emptyCol.find().exec();\n                    assert.strictEqual(docs.length, 5);\n\n                    col.database.destroy();\n                    emptyCol.database.destroy();\n                });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"should not import if schema is different","suites":["Collection",".importJSON()","negative"],"updatePoint":{"line":88,"column":60},"line":88,"code":"                it('should not import if schema is different', async () => {\n                    const col = await humansCollection.createMultiInstance('pref1', 5);\n                    const json = await col.exportJSON();\n                    const differentSchemaCol = await humansCollection.createNested();\n                    await AsyncTestUtil.assertThrows(\n                        // Explicitly typed as any because TS will catch this error\n                        () => differentSchemaCol.importJSON(json as any),\n                        'RxError'\n                    );\n                    col.database.destroy();\n                    differentSchemaCol.database.destroy();\n                });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"should not import if schema not matching","suites":["Collection",".importJSON()","negative"],"updatePoint":{"line":100,"column":60},"line":100,"code":"                it('should not import if schema not matching', async () => {\n                    const db = await createRxDatabase<{ enchuman: RxCollection<schemaObjects.EncryptedObjectHumanDocumentType> }>({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                        password: randomCouchString(10)\n                    });\n                    const cols = await db.addCollections({\n                        enchuman: {\n                            schema: schemas.encryptedObjectHuman\n                        }\n                    });\n                    const col = cols.enchuman;\n\n\n                    const fns = [];\n                    for (let i = 0; i < 5; i++)\n                        fns.push(col.insert(schemaObjects.encryptedObjectHuman()));\n                    await Promise.all(fns);\n\n                    // empty collection with same schema\n                    const cols2 = await db.addCollections({\n                        enchuman2: {\n                            schema: schemas.encryptedObjectHuman\n                        }\n                    });\n                    const col2 = cols2.enchuman2;\n\n                    const json = await col.exportJSON();\n                    // add one with broken schema\n                    json.docs.push({\n                        foo: 'bar',\n                        _id: '0fg89sm5ui:1478730736884'\n                    } as any); // Explicitly set to 'any' because TS will catch this error\n                    await AsyncTestUtil.assertThrows(\n                        () => col2.importJSON(json),\n                        'RxError',\n                        [\n                            'firstName',\n                            'required'\n                        ]\n                    );\n                    db.destroy();\n                });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"should export a valid dump","suites":["Database",".exportJSON()"],"updatePoint":{"line":148,"column":42},"line":148,"code":"            it('should export a valid dump', async () => {\n                const col = await humansCollection.createMultiInstance(randomCouchString(10), 5);\n                const json = await col.database.exportJSON();\n\n                assert.strictEqual(typeof json.name, 'string');\n                assert.strictEqual(typeof json.instanceToken, 'string');\n                assert.strictEqual(typeof json.collections, 'object');\n                assert.strictEqual(json.collections.length, 1);\n\n                const colDump = json.collections[0];\n                assert.strictEqual(colDump.name, 'human');\n                assert.strictEqual(typeof colDump.schemaHash, 'string');\n                assert.strictEqual(colDump.docs.length, 5);\n                colDump.docs.map((doc: any) => assert.strictEqual(typeof doc, 'object'));\n                col.database.destroy();\n            });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"export encrypted as decrypted","suites":["Database",".exportJSON()"],"updatePoint":{"line":164,"column":45},"line":164,"code":"            it('export encrypted as decrypted', async () => {\n                const db = await createRxDatabase<{ enchuman: RxCollection<schemaObjects.EncryptedObjectHumanDocumentType> }>({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    password: randomCouchString(10)\n                });\n                const cols = await db.addCollections({\n                    enchuman: {\n                        schema: schemas.encryptedObjectHuman\n                    }\n                });\n                const col = cols.enchuman;\n                await Promise.all(\n                    new Array(10).fill(0)\n                        .map(() => col.insert(schemaObjects.encryptedObjectHuman()))\n                );\n                const json = await db.exportJSON();\n\n                json.collections[0].docs\n                    .forEach(docData => {\n                        assert.strictEqual(typeof docData.secret, 'object');\n                        assert.strictEqual(typeof docData.secret.name, 'string');\n                        assert.strictEqual(typeof docData.secret.subname, 'string');\n                    });\n                db.destroy();\n            });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"export with multiple collections","suites":["Database",".exportJSON()"],"updatePoint":{"line":190,"column":48},"line":190,"code":"            it('export with multiple collections', async () => {\n                const db = await createRxDatabase<{ enchuman: RxCollection<schemaObjects.EncryptedObjectHumanDocumentType> }>({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    password: randomCouchString(10)\n                });\n                const cols = await db.addCollections({\n                    enchuman: {\n                        schema: schemas.encryptedObjectHuman\n                    }\n                });\n                const col = cols.enchuman;\n                const cols2 = await db.addCollections({\n                    enchuman2: {\n                        schema: schemas.encryptedObjectHuman\n                    }\n                });\n                const col2 = cols2.enchuman2;\n\n                const fns = [];\n                for (let i = 0; i < 10; i++) {\n                    fns.push(col.insert(schemaObjects.encryptedObjectHuman()));\n                    fns.push(col2.insert(schemaObjects.encryptedObjectHuman()));\n                }\n                await Promise.all(fns);\n\n                const json = await col.database.exportJSON();\n                assert.strictEqual(json.collections.length, 2);\n                json.collections\n                    .forEach((c: any) => assert.strictEqual(c.docs.length, 10));\n                db.destroy();\n            });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"export 1 of 2 collections","suites":["Database",".exportJSON()"],"updatePoint":{"line":222,"column":41},"line":222,"code":"            it('export 1 of 2 collections', async () => {\n                const db = await createRxDatabase<{ enchuman: RxCollection<schemaObjects.EncryptedObjectHumanDocumentType> }>({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    password: randomCouchString(10)\n                });\n                const cols = await db.addCollections({\n                    enchuman: {\n                        schema: schemas.encryptedObjectHuman\n                    },\n                    enchuman2: {\n                        schema: schemas.encryptedObjectHuman\n                    }\n                });\n                const col = cols.enchuman;\n                const col2 = cols.enchuman2;\n\n                const fns = [];\n                for (let i = 0; i < 10; i++) {\n                    fns.push(col.insert(schemaObjects.encryptedObjectHuman()));\n                    fns.push(col2.insert(schemaObjects.encryptedObjectHuman()));\n                }\n                await Promise.all(fns);\n\n                const json = await col.database.exportJSON(['enchuman']);\n                assert.strictEqual(json.collections.length, 1);\n                json.collections\n                    .forEach((c: any) => assert.strictEqual(c.docs.length, 10));\n                db.destroy();\n            });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"import dump","suites":["Database",".importJSON()","positive"],"updatePoint":{"line":255,"column":31},"line":255,"code":"                it('import dump', async () => {\n                    const col = await humansCollection.create(5);\n                    const db = col.database;\n                    const json = await db.exportJSON();\n\n                    const col2 = await humansCollection.create(0);\n                    const db2 = col2.database;\n                    await db2.importJSON(json);\n\n                    const docs = await col2.find().exec();\n                    assert.strictEqual(docs.length, 5);\n                    db.destroy();\n                    db2.destroy();\n                });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"should not import if schema is different","suites":["Database",".importJSON()","negative"],"updatePoint":{"line":271,"column":60},"line":271,"code":"                it('should not import if schema is different', async () => {\n\n                    const db = await createRxDatabase<{ human: RxCollection<HumanDocumentType> }>({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                        password: null,\n                        multiInstance: true\n                    });\n                    const cols = await db.addCollections({\n                        human: {\n                            schema: schemas.human\n                        }\n                    });\n                    const col = cols.human;\n\n                    const db2 = await createRxDatabase<{ human: RxCollection<schemaObjects.NestedHumanDocumentType> }>({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                        password: null,\n                        multiInstance: true\n                    });\n                    const cols2 = await db2.addCollections({\n                        human: {\n                            schema: schemas.nestedHuman\n                        }\n                    });\n                    const col2 = cols2.human;\n\n                    const fns = [];\n                    for (let i = 0; i < 5; i++)\n                        fns.push(col.insert(schemaObjects.human()));\n                    await Promise.all(fns);\n\n                    const json = await db.exportJSON();\n                    await AsyncTestUtil.assertThrows(\n                        // Explicitly typed as any because TS will catch this error\n                        () => db2.importJSON(json as any),\n                        'RxError'\n                    );\n\n                    const docs = await col2.find().exec();\n                    assert.strictEqual(docs.length, 0);\n\n                    db.destroy();\n                    db2.destroy();\n                });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"should not import if schema not matching","suites":["Database",".importJSON()","negative"],"updatePoint":{"line":317,"column":60},"line":317,"code":"                it('should not import if schema not matching', async () => {\n                    const db = await createRxDatabase<{ enchuman: RxCollection<schemaObjects.NestedHumanDocumentType> }>({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                        multiInstance: true\n                    });\n                    const cols = await db.addCollections({\n                        enchuman: {\n                            schema: schemas.nestedHuman\n                        }\n                    });\n                    const col = cols.enchuman;\n\n                    const db2 = await createRxDatabase<{ enchuman: RxCollection<schemaObjects.NestedHumanDocumentType> }>({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                        multiInstance: true\n                    });\n                    await db2.addCollections({\n                        enchuman: {\n                            schema: schemas.nestedHuman\n                        }\n                    });\n\n                    const fns = [];\n                    for (let i = 0; i < 5; i++)\n                        fns.push(col.insert(schemaObjects.nestedHuman()));\n                    await Promise.all(fns);\n\n                    const json = await db.exportJSON();\n\n                    // add one with broken schema\n                    json.collections[0].docs.push({\n                        foo: 'bar',\n                        _id: '0fg89sm5ui:1478730736884'\n                    } as any); // Explicitly set to 'any' because TS will catch this error\n\n                    await AsyncTestUtil.assertThrows(\n                        () => db2.importJSON(json),\n                        'RxError',\n                        [\n                            'firstName',\n                            'required'\n                        ]\n                    );\n                    db.destroy();\n                    db2.destroy();\n                });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"#319 collections must be created before importDump","suites":["issues"],"updatePoint":{"line":369,"column":62},"line":369,"code":"        it('#319 collections must be created before importDump', async () => {\n            const docSchema = {\n                name: 'demo',\n                version: 0,\n                primaryKey: 'firstName',\n                type: 'object',\n                properties: {\n                    firstName: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    time: {\n                        type: 'string'\n                    }\n                }\n            };\n\n            const db = await createRxDatabase({\n                name: 'aaa',\n                storage: config.storage.getStorage(),\n            });\n            const db2 = await createRxDatabase({\n                name: 'aaa1',\n                storage: config.storage.getStorage(),\n            });\n            const cols = await db.addCollections({\n                demo: {\n                    schema: docSchema\n                }\n            });\n            const col = cols.demo;\n            await col.insert({\n                firstName: 'nnnn'\n            });\n            const json = await db.exportJSON();\n\n            // should throw when the collection does not exist\n            await AsyncTestUtil.assertThrows(\n                () => db2.importJSON(json),\n                'RxError',\n                'create the collections'\n            );\n\n            // should work when the collection exists\n            const cols2 = await db2.addCollections({\n                demo: {\n                    schema: docSchema\n                }\n            });\n            const col2 = cols2.demo;\n            await db2.importJSON(json);\n            const docs = await col2.find().exec();\n            assert.strictEqual(docs.length, 1);\n\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"#1396 import/export should work with attachments","suites":["issues"],"updatePoint":{"line":426,"column":60},"line":426,"code":"        it('#1396 import/export should work with attachments', async () => {\n            if (!config.storage.hasAttachments) {\n                return;\n            }\n            const sourceCol = await humansCollection.createAttachments(1);\n            const doc = await sourceCol.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow', 'text/plain'),\n                type: 'text/plain'\n            });\n            const json = await sourceCol.exportJSON();\n\n            const destCol = await humansCollection.createAttachments(0);\n\n            const noDocs = await destCol.find().exec();\n            assert.strictEqual(noDocs.length, 0);\n\n            // this line triggers an error\n            await destCol.importJSON(json);\n\n            const docs = await destCol.find().exec();\n            assert.strictEqual(docs.length, 1);\n\n            const importedDoc = await destCol.findOne().exec();\n            assert.ok(importedDoc);\n\n            sourceCol.database.destroy();\n            destCol.database.destroy();\n        });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"clear BroadcastChannel tmp folder","suites":["init.test.js"],"updatePoint":{"line":64,"column":41},"line":64,"code":"    it('clear BroadcastChannel tmp folder', async () => {\n        await clearNodeFolder();\n    });","file":"unit/init.test.ts","skipped":false,"dir":"test"},{"name":"positive","suites":[],"updatePoint":{"line":14,"column":16},"line":14,"code":"    it('positive', async () => {\n        const c = await humansCollection.create(1);\n        const query = c.findOne();\n        const doc = await query.exec();\n        assert.ok(isRxDatabase(c.database));\n        assert.ok(isRxCollection(c));\n        assert.ok(isRxQuery(query));\n        assert.ok(isRxDocument(doc));\n        assert.ok(isRxSchema(c.schema));\n\n        c.database.destroy();\n    });","file":"unit/instance-of-check.test.ts","skipped":false,"dir":"test"},{"name":"negative","suites":[],"updatePoint":{"line":26,"column":16},"line":26,"code":"    it('negative', () => {\n        const anyObj = {};\n        assert.strictEqual(false, isRxDatabase(anyObj));\n        assert.strictEqual(false, isRxCollection(anyObj));\n        assert.strictEqual(false, isRxQuery(anyObj));\n        assert.strictEqual(false, isRxDocument(anyObj));\n        assert.strictEqual(false, isRxSchema(anyObj));\n    });","file":"unit/instance-of-check.test.ts","skipped":false,"dir":"test"},{"name":"transform basic search keys","suites":["RxQuery().keyCompress()"],"updatePoint":{"line":26,"column":39},"line":26,"code":"        it('transform basic search keys', async () => {\n            const c = await humansCollection.create(0);\n            const query: any = c.find()\n                .where('firstName').eq('myFirstName')\n                .getPreparedQuery();\n            const jsonString = JSON.stringify(query);\n            assert.ok(!jsonString.includes('firstName'));\n            assert.ok(jsonString.includes('myFirstName'));\n            c.database.destroy();\n        });","file":"unit/key-compression.test.ts","skipped":false,"dir":"test"},{"name":"primary","suites":["RxQuery().keyCompress()"],"updatePoint":{"line":36,"column":19},"line":36,"code":"        it('primary', async () => {\n            if (config.storage.name !== 'pouchdb') {\n                return;\n            }\n            const c = await humansCollection.createPrimary(0);\n            const query: any = c.find()\n                .where('passportId').eq('myPassportId')\n                .getPreparedQuery();\n            const jsonString = JSON.stringify(query);\n\n            assert.ok(!jsonString.includes('passportId'));\n            assert.ok(jsonString.includes('myPassportId'));\n            assert.strictEqual(query.selector._id, 'myPassportId');\n            c.database.destroy();\n        });","file":"unit/key-compression.test.ts","skipped":false,"dir":"test"},{"name":"additional attribute","suites":["RxQuery().keyCompress()"],"updatePoint":{"line":51,"column":32},"line":51,"code":"        it('additional attribute', async () => {\n            if (config.storage.name !== 'pouchdb') {\n                return;\n            }\n            const c = await humansCollection.create(0);\n            const query: any = c.find()\n                .where('age').eq(5)\n                .getPreparedQuery();\n\n            assert.strictEqual(query.selector.age, 5);\n            c.database.destroy();\n        });","file":"unit/key-compression.test.ts","skipped":false,"dir":"test"},{"name":"should have saved a compressed document","suites":["integration into pouchDB"],"updatePoint":{"line":65,"column":51},"line":65,"code":"        it('should have saved a compressed document', async () => {\n            if (config.storage.name !== 'pouchdb') {\n                return;\n            }\n\n            const c = await humansCollection.createPrimary(0);\n            const docData = schemaObjects.simpleHuman();\n            await c.insert(docData);\n\n            const pouchDoc = await c.internalStorageInstance.internals.pouch.get(docData.passportId);\n            const doc = pouchDocumentDataToRxDocumentData<SimpleHumanDocumentType>(c.schema.primaryPath, pouchDoc);\n            Object.keys(doc)\n                .filter(key => !key.startsWith('_'))\n                .filter(key => key !== c.schema.primaryPath)\n                .forEach(key => {\n                    assert.ok(key.length <= 3);\n                    assert.strictEqual(typeof (doc as any)[key], 'string');\n                });\n            assert.strictEqual(doc[c.schema.primaryPath], docData.passportId);\n            assert.strictEqual((doc as any)['|a'], docData.firstName);\n            c.database.destroy();\n        });","file":"unit/key-compression.test.ts","skipped":false,"dir":"test"},{"name":"should properly run the compressed query","suites":["query"],"updatePoint":{"line":89,"column":52},"line":89,"code":"        it('should properly run the compressed query', async () => {\n            const col = await humansCollection.create(0);\n            assert.ok(col.schema.jsonSchema.keyCompression);\n\n            // add one matching and one non-matching doc\n            await col.bulkInsert([\n                {\n                    firstName: 'aaa',\n                    lastName: 'aaa',\n                    passportId: 'aaa',\n                    age: 0\n                },\n                {\n                    firstName: 'bbb',\n                    lastName: 'bbb',\n                    passportId: 'bbb',\n                    age: 0\n                }\n            ]);\n            const query = col.find({\n                selector: {\n                    firstName: {\n                        $ne: 'aaa'\n                    }\n                }\n            });\n            const docs = await query.exec();\n            const doc = docs[0];\n            if (!doc) {\n                throw new Error('doc missing');\n            }\n\n            assert.strictEqual(doc.passportId, 'bbb');\n\n            col.database.destroy();\n        });","file":"unit/key-compression.test.ts","skipped":false,"dir":"test"},{"name":"#50 compress string array properly","suites":["issues"],"updatePoint":{"line":127,"column":46},"line":127,"code":"        it('#50 compress string array properly', async () => {\n            const mySchema: RxJsonSchema<{ likes: any[], id: string }> = {\n                title: 'hero schema',\n                version: 0,\n                description: 'describes a simple hero',\n                primaryKey: 'id',\n                required: [\n                    'id'\n                ],\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    likes: {\n                        type: 'array',\n                        items: {\n                            type: 'string'\n                        }\n                    }\n                }\n            };\n\n            const db = await createRxDatabase({\n                name: 'heroesdb',\n                storage: config.storage.getStorage()\n            });\n            const collections = await db.addCollections({\n                mycollection: {\n                    schema: mySchema\n                }\n            });\n            const collection = collections.mycollection;\n            const docData = {\n                id: randomCouchString(12),\n                likes: ['abc', '8']\n            };\n            await collection.insert(docData);\n            const doc = await collection.findOne().exec();\n            assert.ok(isRxDocument(doc));\n            assert.deepStrictEqual(doc.likes, docData.likes);\n            db.destroy();\n        });","file":"unit/key-compression.test.ts","skipped":false,"dir":"test"},{"name":"error on nested null","suites":["issues"],"updatePoint":{"line":171,"column":32},"line":171,"code":"        it('error on nested null', async () => {\n            const mySchema = {\n                title: 'hero schema',\n                version: 0,\n                description: 'describes a simple hero',\n                primaryKey: 'key',\n                required: ['key'],\n                type: 'object',\n                properties: {\n                    key: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    nested: {\n                        type: 'object'\n                    }\n                }\n            };\n\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage()\n            });\n            const collections = await db.addCollections({\n                mycollection: {\n                    schema: mySchema\n                }\n            });\n            const collection = collections.mycollection;\n\n            const docData = {\n                key: 'foobar',\n                nested: {\n                    lastProvider: null,\n                    providers: 0,\n                    sync: false,\n                    other: {}\n                }\n            };\n            await collection.insert(docData);\n\n            db.destroy();\n        });","file":"unit/key-compression.test.ts","skipped":false,"dir":"test"},{"name":"query over compressed index","suites":["issues"],"updatePoint":{"line":219,"column":39},"line":219,"code":"        it('query over compressed index', async () => {\n            type RxMessageDocumentType = {\n                id: string;\n                text: string;\n                createdAt: number;\n                read: boolean;\n                sender: string;\n                reciever: string;\n            };\n            const schema: RxJsonSchema<RxMessageDocumentType> = {\n                title: 'messages schema',\n                description: 'describes a message',\n                version: 0,\n                keyCompression: true,\n                primaryKey: 'id',\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 40\n                    },\n                    text: {\n                        type: 'string'\n                    },\n                    createdAt: {\n                        type: 'number',\n                        minimum: 0,\n                        maximum: 100000000000000,\n                        multipleOf: 1\n                    },\n                    read: {\n                        description: 'true if was read by the reciever',\n                        type: 'boolean'\n                    },\n                    sender: {\n                        type: 'string',\n                        ref: 'users',\n                        maxLength: 40\n                    },\n                    reciever: {\n                        type: 'string',\n                        ref: 'users',\n                        maxLength: 40\n                    }\n                },\n                indexes: [\n                    'createdAt'\n                ],\n                required: [\n                    'text',\n                    'createdAt',\n                    'read',\n                    'sender',\n                    'reciever'\n                ]\n            };\n\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage()\n            });\n\n            const collections = await db.addCollections({\n                messages: {\n                    schema\n                }\n            });\n            const collection: RxCollection<RxMessageDocumentType> = collections.messages;\n            await collection.insert({\n                id: 'xxx',\n                text: 'foobar',\n                createdAt: 100,\n                read: false,\n                sender: 'a',\n                reciever: 'b'\n            });\n            const query = collection.findOne({\n                selector: {\n                    $or: [\n                        {\n                            sender: 'a',\n                            reciever: 'b'\n                        },\n                        {\n                            sender: 'b',\n                            reciever: 'a'\n                        }\n                    ]\n                },\n                sort: [\n                    { createdAt: 'asc' },\n                    { id: 'asc' }\n                ]\n            });\n\n\n            const result = await query.exec(true);\n            assert.strictEqual(result.id, 'xxx');\n\n\n            db.destroy();\n        });","file":"unit/key-compression.test.ts","skipped":false,"dir":"test"},{"name":"ensure every db is cleaned up","suites":[],"updatePoint":{"line":10,"column":37},"line":10,"code":"    it('ensure every db is cleaned up', () => {\n        assert.strictEqual(dbCount(), 0);\n    });","file":"unit/last.test.ts","skipped":false,"dir":"test"},{"name":"ensure every storage instance is cleaned up","suites":[],"updatePoint":{"line":13,"column":51},"line":13,"code":"    it('ensure every storage instance is cleaned up', async () => {\n        try {\n            // for performance, we do not await db closing, so it might take some time\n            // until everything is closed.\n            await waitUntil(() => {\n                return OPEN_POUCHDB_STORAGE_INSTANCES.size === 0;\n            }, 5 * 1000, 500);\n        } catch (err) {\n            console.dir(OPEN_POUCHDB_STORAGE_INSTANCES);\n            throw new Error('no all storage instances have been closed');\n        }\n    });","file":"unit/last.test.ts","skipped":false,"dir":"test"},{"name":"other instance applies on death of leader","suites":[".die()"],"updatePoint":{"line":26,"column":53},"line":26,"code":"        it('other instance applies on death of leader', async () => {\n            const name = randomCouchString(10);\n            const c = await humansCollection.createMultiInstance(name);\n            const leaderElector = c.database.leaderElector();\n\n            await c.database.waitForLeadership();\n            await leaderElector.die();\n\n            const c2 = await humansCollection.createMultiInstance(name);\n            await c2.database.waitForLeadership();\n\n            c.database.destroy();\n            c2.database.destroy();\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"a single instance should always elect itself as leader","suites":["election"],"updatePoint":{"line":43,"column":66},"line":43,"code":"        it('a single instance should always elect itself as leader', async () => {\n            const c1 = await humansCollection.createMultiInstance(randomCouchString(10));\n            const db1 = c1.database;\n            await db1.waitForLeadership();\n            c1.database.destroy();\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"should not elect as leader if other instance is leader","suites":["election"],"updatePoint":{"line":49,"column":66},"line":49,"code":"        it('should not elect as leader if other instance is leader', async () => {\n            const name = randomCouchString(10);\n            const c1 = await humansCollection.createMultiInstance(name);\n            const c2 = await humansCollection.createMultiInstance(name);\n            const db1 = c1.database;\n            const db2 = c2.database;\n\n            await db1.waitForLeadership();\n            await AsyncTestUtil.wait(150);\n            assert.strictEqual(db2.isLeader(), false);\n\n            c1.database.destroy();\n            c2.database.destroy();\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"when 2 instances apply at the same time, one should win","suites":["election"],"updatePoint":{"line":63,"column":67},"line":63,"code":"        it('when 2 instances apply at the same time, one should win', async () => {\n            if (!config.platform.isNode()) return;\n\n            // run often\n            let tries = 0;\n            while (tries < 3) {\n                tries++;\n                const name = randomCouchString(10);\n                const c1 = await humansCollection.createMultiInstance(name);\n                const c2 = await humansCollection.createMultiInstance(name);\n                const le1 = c1.database.leaderElector();\n                const le2 = c2.database.leaderElector();\n\n                c1.database.waitForLeadership();\n                c2.database.waitForLeadership();\n\n                await AsyncTestUtil.waitUntil(() => {\n                    const leaders = [\n                        le1.isLeader,\n                        le2.isLeader\n                    ].filter(x => x);\n                    return leaders.length === 1;\n                });\n                await AsyncTestUtil.wait(50);\n\n                assert.notStrictEqual(le1.isLeader, le2.isLeader);\n\n                await c1.database.destroy();\n                await c2.database.destroy();\n            }\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"when many instances apply, one should win","suites":["election"],"updatePoint":{"line":94,"column":53},"line":94,"code":"        it('when many instances apply, one should win', async () => {\n            const name = randomCouchString(10);\n            const dbs: any[] = [];\n            while (dbs.length < 10) {\n                const c = await humansCollection.createMultiInstance(name);\n                dbs.push(c.database);\n            }\n            dbs.forEach(db => db.waitForLeadership());\n\n            await AsyncTestUtil.waitUntil(() => {\n                const count = dbs\n                    .map(db => db.leaderElector().isLeader)\n                    .filter(is => is === true)\n                    .length;\n                return count === 1;\n            });\n            await AsyncTestUtil.wait(100);\n\n            const leaderCount = dbs\n                .map(db => db.leaderElector().isLeader)\n                .filter(is => is === true)\n                .length;\n            assert.strictEqual(leaderCount, 1);\n            await Promise.all(dbs.map(db => db.destroy()));\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"when the leader dies, a new one should be elected","suites":["election"],"updatePoint":{"line":119,"column":61},"line":119,"code":"        it('when the leader dies, a new one should be elected', async function () {\n            this.timeout(5 * 1000);\n            const name = randomCouchString(10);\n            const dbs: any[] = [];\n            while (dbs.length < 6) {\n                const c = await humansCollection.createMultiInstance(name);\n                dbs.push(c.database);\n            }\n            dbs.forEach(db => db.waitForLeadership());\n\n            await AsyncTestUtil.waitUntil(async () => {\n                const count = dbs\n                    .filter(db => db.leaderElector().isLeader === true)\n                    .length;\n                return count === 1;\n            });\n            await AsyncTestUtil.wait(100);\n            const leaderCount = dbs\n                .filter(db => db.leaderElector().isLeader === true)\n                .length;\n            assert.strictEqual(leaderCount, 1);\n\n            // let leader die\n            const leader = dbs\n                .filter(db => db.leaderElector().isLeader === true)[0];\n            const leaderToken = leader.token;\n            await leader.destroy();\n            const nonDeadDbs = dbs.filter(db => db !== leader);\n\n            await AsyncTestUtil.waitUntil(async () => {\n                const count = nonDeadDbs\n                    .filter(db => db.leaderElector().isLeader === true)\n                    .length;\n                return count === 1;\n            });\n            const leaderCount2 = nonDeadDbs\n                .filter(db => db.leaderElector().isLeader === true)\n                .length;\n            assert.strictEqual(leaderCount2, 1);\n\n            const leader2 = nonDeadDbs\n                .filter(db => db.token !== leaderToken)\n                .filter(db => db.leaderElector().isLeader === true)[0];\n            const leaderToken2 = leader2.token;\n\n            assert.notStrictEqual(leaderToken, leaderToken2);\n            await Promise.all(nonDeadDbs.map(db => db.destroy()));\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"non-multiInstance should always be leader","suites":["integration"],"updatePoint":{"line":169,"column":53},"line":169,"code":"        it('non-multiInstance should always be leader', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n                multiInstance: false\n            });\n            // setTimeout(() => db.destroy(), dbLifetime);\n            await db.addCollections({\n                human: {\n                    schema: schemas.human\n                }\n            });\n            assert.strictEqual(db.isLeader(), true);\n            await db.destroy();\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"non-multiInstance: waitForLeadership should instant","suites":["integration"],"updatePoint":{"line":184,"column":63},"line":184,"code":"        it('non-multiInstance: waitForLeadership should instant', async () => {\n            const c = await humansCollection.create(0);\n            const db = c.database;\n            await db.waitForLeadership();\n            await db.destroy();\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"waitForLeadership: run once when instance becomes leader","suites":["integration"],"updatePoint":{"line":191,"column":68},"line":191,"code":"        it('waitForLeadership: run once when instance becomes leader', async () => {\n            const name = randomCouchString(10);\n            const cols = await Promise.all(\n                new Array(5)\n                    .fill(0)\n                    .map(() => humansCollection.createMultiInstance(name))\n            );\n            const dbs = cols.map(col => col.database);\n\n            let count = 0;\n            dbs.forEach(db => db.waitForLeadership().then(() => count++));\n            await AsyncTestUtil.waitUntil(() => count === 1);\n\n            // let leader die\n            await dbs\n                .filter(db => db.isLeader())[0]\n                .leaderElector().die();\n\n            await AsyncTestUtil.waitUntil(() => count === 2);\n            await Promise.all(dbs.map(db => db.destroy()));\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"should create a local document","suites":[".insertLocal()","positive"],"updatePoint":{"line":44,"column":46},"line":44,"code":"            it('should create a local document', async () => {\n                const c = await humansCollection.create(0);\n                const doc = await c.insertLocal('foobar', {\n                    foo: 'bar'\n                });\n                assert.ok(doc);\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should not find the doc because its local","suites":[".insertLocal()","positive"],"updatePoint":{"line":52,"column":57},"line":52,"code":"            it('should not find the doc because its local', async () => {\n                const c = await humansCollection.create(0);\n                await c.insertLocal('foobar', {\n                    foo: 'bar'\n                });\n                const doc2 = await c.findOne().exec();\n                assert.strictEqual(doc2, null);\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should throw if already exists","suites":[".insertLocal()","negative"],"updatePoint":{"line":63,"column":46},"line":63,"code":"            it('should throw if already exists', async () => {\n                const c = await humansCollection.create(0);\n                const doc = await c.insertLocal('foobar', {\n                    foo: 'bar'\n                });\n                assert.ok(doc);\n                let thrown = false;\n                try {\n                    await c.insertLocal('foobar', {\n                        foo: 'bar2'\n                    });\n                } catch (err) {\n                    thrown = true;\n                }\n                assert.ok(thrown);\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should find the document","suites":[".getLocal()","positive"],"updatePoint":{"line":84,"column":40},"line":84,"code":"            it('should find the document', async () => {\n                const c = await humansCollection.create(0);\n                await c.insertLocal('foobar', {\n                    foo: 'bar'\n                });\n                const doc = await c.getLocal('foobar');\n                assert.ok(doc);\n                assert.strictEqual(doc.get('foo'), 'bar');\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should find the document twice (doc-cache)","suites":[".getLocal()","positive"],"updatePoint":{"line":94,"column":58},"line":94,"code":"            it('should find the document twice (doc-cache)', async () => {\n                const c = await humansCollection.create(0);\n                await c.insertLocal('foobar', {\n                    foo: 'bar'\n                });\n                const doc = await c.getLocal('foobar');\n                const doc2 = await c.getLocal('foobar');\n                assert.ok(doc);\n                assert.ok(doc === doc2);\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should not find non-existing","suites":[".getLocal()","negative"],"updatePoint":{"line":107,"column":44},"line":107,"code":"            it('should not find non-existing', async () => {\n                const c = await humansCollection.create(0);\n                const doc = await c.getLocal('foobar');\n                assert.strictEqual(doc, null);\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should modify the data","suites":["atomic mutation functions",".atomicPatch()"],"updatePoint":{"line":121,"column":38},"line":121,"code":"            it('should modify the data', async () => {\n                const c = await humansCollection.create(0);\n                const doc = await c.upsertLocal<LocalDocType>(\n                    'foobar',\n                    {\n                        foo: 'bar'\n                    }\n                );\n\n                await doc.atomicPatch({\n                    added: 'foo'\n                });\n\n                assert.strictEqual(doc.get('foo'), 'bar');\n                assert.strictEqual(doc.get('added'), 'foo');\n\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should modify the data","suites":["atomic mutation functions",".atomicUpdate()"],"updatePoint":{"line":141,"column":38},"line":141,"code":"            it('should modify the data', async () => {\n                const c = await humansCollection.create(0);\n                const doc: RxLocalDocument<RxCollection<any>, LocalDocType> = await c.upsertLocal<LocalDocType>('foobar', {\n                    foo: 'bar'\n                });\n\n                await doc.atomicUpdate(data => {\n                    data.added = 'foo';\n                    return data;\n                });\n\n                assert.strictEqual(doc.get('foo'), 'bar');\n                assert.strictEqual(doc.get('added'), 'foo');\n\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should emit null when not exists","suites":[".getLocal$()"],"updatePoint":{"line":161,"column":44},"line":161,"code":"        it('should emit null when not exists', async () => {\n            const c = await humansCollection.create(0);\n            const cData = await c.getLocal$(id).pipe(first()).toPromise();\n            const dbData = await c.database.getLocal$(id).pipe(first()).toPromise();\n\n            assert.strictEqual(cData, null);\n            assert.strictEqual(dbData, null);\n\n            c.database.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should emit the document when exists","suites":[".getLocal$()"],"updatePoint":{"line":171,"column":48},"line":171,"code":"        it('should emit the document when exists', async () => {\n            const c = await humansCollection.create(0);\n\n            await c.insertLocal(id, {\n                foo: 'bar'\n            });\n            await c.database.insertLocal(id, {\n                foo: 'bar'\n            });\n\n            const cDoc = await c.getLocal$(id).pipe(first()).toPromise();\n            const dbDoc = await c.database.getLocal$(id).pipe(first()).toPromise();\n\n            assert.strictEqual(ensureNotFalsy(cDoc).get('foo'), 'bar');\n            assert.strictEqual(ensureNotFalsy(dbDoc).get('foo'), 'bar');\n\n            c.database.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"collection: should emit again when state changed","suites":[".getLocal$()"],"updatePoint":{"line":189,"column":60},"line":189,"code":"        it('collection: should emit again when state changed', async () => {\n            const c = await humansCollection.create(0);\n            const cEmits: any[] = [];\n            const sub = c.getLocal$(id).subscribe((x: any) => {\n                cEmits.push(x ? x.toJSON() : null);\n            });\n\n            await waitUntil(() => cEmits.length === 1);\n            assert.strictEqual(cEmits[0], null);\n\n            // insert\n            await c.insertLocal(id, { foo: 'bar' });\n            await waitUntil(() => cEmits.length === 2);\n            assert.strictEqual(cEmits[1].data.foo, 'bar');\n\n            // update\n            await c.upsertLocal(id, { foo: 'bar2' });\n            await waitUntil(() => cEmits.length === 3);\n            assert.strictEqual(cEmits[2].data.foo, 'bar2');\n\n            sub.unsubscribe();\n            c.database.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"database: should emit again when state changed","suites":[".getLocal$()"],"updatePoint":{"line":212,"column":58},"line":212,"code":"        it('database: should emit again when state changed', async () => {\n            const c = await humansCollection.create(0);\n            const db = c.database;\n\n            const cEmits: any[] = [];\n            const sub = db.getLocal$(id).subscribe((x) => {\n                cEmits.push(x ? x.toJSON() : null);\n            });\n\n            await waitUntil(() => cEmits.length === 1);\n            assert.strictEqual(cEmits[0], null);\n\n            // insert\n            await db.insertLocal(id, { foo: 'bar' });\n            await waitUntil(() => cEmits.length === 2);\n            assert.strictEqual(cEmits[1].data.foo, 'bar');\n\n            // update\n            await db.upsertLocal(id, { foo: 'bar2' });\n            await waitUntil(() => cEmits.length === 3);\n            assert.strictEqual(cEmits[2].data.foo, 'bar2');\n\n            sub.unsubscribe();\n            c.database.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should insert when not exists","suites":[".upsertLocal()","positive"],"updatePoint":{"line":240,"column":45},"line":240,"code":"            it('should insert when not exists', async () => {\n                const c = await humansCollection.create(0);\n                const doc: RxLocalDocument<any, { foo: string; }> = await c.upsertLocal<{ foo: string; }>('foobar', {\n                    foo: 'bar'\n                });\n                assert.ok(doc);\n                assert.strictEqual(doc.get('foo'), 'bar');\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should update when exists","suites":[".upsertLocal()","positive"],"updatePoint":{"line":249,"column":41},"line":249,"code":"            it('should update when exists', async () => {\n                const c = await humansCollection.create(0);\n                const doc = await c.upsertLocal('foobar', {\n                    foo: 'bar'\n                });\n                const doc2 = await c.upsertLocal('foobar', {\n                    foo: 'bar2'\n                });\n\n                assert.ok(doc === doc2);\n                assert.strictEqual(doc.get('foo'), 'bar2');\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should invoke subscription once","suites":[".upsertLocal()","positive"],"updatePoint":{"line":265,"column":47},"line":265,"code":"            it('should invoke subscription once', async () => {\n                const c = await humansCollection.create(0);\n                const emitted: any[] = [];\n                const doc = await c.upsertLocal('foobar', {\n                    foo: 'barOne',\n                });\n                await wait(50);\n                const docSub = doc.$.subscribe(x => {\n                    emitted.push(x);\n                });\n                await c.upsertLocal('foobar', {\n                    foo: 'barTwo',\n                });\n\n                assert.strictEqual(emitted.length, 2);\n                // first 'barOne' is emitted because.$ is a BehaviorSubject\n                assert.strictEqual(emitted[0].data.foo, 'barOne');\n                // second after the change, barTwo is emitted\n                assert.strictEqual(emitted[1].data.foo, 'barTwo');\n\n                docSub.unsubscribe();\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should remove the document","suites":[".remove()"],"updatePoint":{"line":292,"column":38},"line":292,"code":"        it('should remove the document', async () => {\n            const c = await humansCollection.create(0);\n            const doc = await c.upsertLocal('foobar', {\n                foo: 'bar'\n            });\n            await doc.remove();\n            const doc2 = await c.getLocal('foobar');\n            assert.strictEqual(doc2, null);\n            c.database.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should be able to use local documents directly on the database","suites":["with database"],"updatePoint":{"line":304,"column":74},"line":304,"code":"        it('should be able to use local documents directly on the database', async () => {\n            const c = await humansCollection.create(0);\n            const db = c.database;\n\n            const doc1 = await db.insertLocal('foobar', {\n                foo: 'bar'\n            });\n            const doc2 = await db.getLocal('foobar');\n            assert.strictEqual(doc1, doc2);\n            db.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should stream events over multi-instance","suites":["multi-instance"],"updatePoint":{"line":320,"column":52},"line":320,"code":"        it('should stream events over multi-instance', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                localDocuments: true\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                ignoreDuplicate: true,\n                localDocuments: true\n            });\n\n            const doc1 = await db.insertLocal('foobar', {\n                foo: 'bar'\n            });\n            const doc2 = await db2.getLocal('foobar');\n            assert.ok(doc2);\n\n            await doc1.atomicPatch({ foo: 'bar2' });\n            await AsyncTestUtil.waitUntil(() => {\n                return doc2.get('foo') === 'bar2';\n            }, 1000, 50);\n\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should emit deleted","suites":["multi-instance"],"updatePoint":{"line":348,"column":31},"line":348,"code":"        it('should emit deleted', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                localDocuments: true\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                ignoreDuplicate: true,\n                localDocuments: true\n            });\n\n            const doc1 = await db.insertLocal('foobar', {\n                foo: 'bar'\n            });\n            const doc2 = await db2.getLocal('foobar');\n            assert.ok(doc2);\n\n            doc1.remove();\n\n            await doc2.deleted$\n                .pipe(\n                    filter(d => d === true),\n                    first()\n                )\n                .toPromise();\n\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should emit changes (database)","suites":["multi-instance"],"updatePoint":{"line":380,"column":42},"line":380,"code":"        it('should emit changes (database)', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                localDocuments: true\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                ignoreDuplicate: true,\n                localDocuments: true\n            });\n\n            const doc1 = await db.insertLocal('foobar', {\n                foo: 'bar'\n            });\n            const doc2 = await db2.getLocal<TestDocType>('foobar');\n\n            await doc1.atomicPatch({ foo: 'bar2' });\n\n            await waitUntil(() => doc2 && doc2.toJSON().data.foo === 'bar2');\n\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should emit changes (collection)","suites":["multi-instance"],"updatePoint":{"line":406,"column":44},"line":406,"code":"        it('should emit changes (collection)', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                ignoreDuplicate: true\n            });\n            const c1 = await db.addCollections({\n                humans: {\n                    schema: schemas.primaryHuman,\n                    localDocuments: true\n                }\n            });\n\n            const c2 = await db2.addCollections({\n                humans: {\n                    schema: schemas.primaryHuman,\n                    localDocuments: true\n                }\n            });\n\n            // insert on instance #1\n            const doc1 = await c1.humans.insertLocal('foobar', {\n                foo: 'bar'\n            });\n\n            const emitted: any[] = [];\n            const sub = c1.humans.getLocal$('foobar').subscribe((x: any) => {\n                emitted.push(x ? x.toJSON(true) : null);\n            });\n            await waitUntil(() => emitted.length === 1);\n\n\n            // update on instance #2\n            const doc2 = await c2.humans.getLocal<TestDocType>('foobar');\n            await doc1.atomicPatch({ foo: 'bar2' });\n\n            await waitUntil(() => doc2 && doc2.toJSON().data.foo === 'bar2');\n            await waitUntil(() => {\n                return emitted.length >= 2;\n            });\n\n            sub.unsubscribe();\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"BUG insertLocal not send to other instance","suites":["multi-instance"],"updatePoint":{"line":456,"column":54},"line":456,"code":"        it('BUG insertLocal not send to other instance', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                localDocuments: true\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                ignoreDuplicate: true,\n                localDocuments: true\n            });\n\n            const emitted: any[] = [];\n            const sub = db2.getLocal$<TestDocType>('foobar').subscribe(x => {\n                emitted.push(x);\n            });\n\n            /**\n             * Before inserting, we must await that the empty result set\n             * was emitted. Otherwise we might miss the initial emit\n             * because creating the db2 can take a long time\n             * on some storages. So not awaiting here would make the test\n             * timing dependend.\n             */\n            await waitUntil(() => emitted.length === 1);\n\n            await db.insertLocal<TestDocType>('foobar', {\n                foo: 'bar'\n            });\n\n            await waitUntil(() => {\n                return emitted.length === 2;\n            }, 2000, 50);\n            assert.ok(emitted.pop());\n\n            const doc = await db2.getLocal<TestDocType>('foobar');\n            assert.strictEqual(doc && doc.toJSON().data.foo, 'bar');\n\n            sub.unsubscribe();\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should not conflict with non-local-doc that has same id","suites":["multi-instance"],"updatePoint":{"line":500,"column":67},"line":500,"code":"        it('should not conflict with non-local-doc that has same id', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                localDocuments: true\n            });\n            const c1 = await db.addCollections({\n                humans: {\n                    schema: schemas.primaryHuman,\n                    localDocuments: true\n                }\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                ignoreDuplicate: true,\n                localDocuments: true\n            });\n            const c2 = await db2.addCollections({\n                humans: {\n                    schema: schemas.primaryHuman,\n                    localDocuments: true\n                }\n            });\n            const docData = schemaObjects.human();\n            docData.passportId = 'foobar';\n            docData.age = 40;\n            const doc = await c1.humans.insert(docData);\n            const localDoc = await c1.humans.insertLocal('foobar', {\n                foo: 'bar',\n                age: 10\n            });\n\n            const doc2 = await c2.humans.findOne().exec();\n            const localDoc2 = await c2.humans.getLocal('foobar');\n            if (!localDoc2) {\n                throw new Error('localDoc2 missing');\n            }\n            await doc.atomicPatch({ age: 50 });\n\n            await AsyncTestUtil.waitUntil(() => doc2.age === 50);\n            await AsyncTestUtil.wait(20);\n            assert.strictEqual(localDoc2.get('age'), 10);\n            await localDoc.atomicPatch({ age: 66, foo: 'bar' });\n\n            await AsyncTestUtil.waitUntil(() => localDoc2.get('age') === 66);\n            await AsyncTestUtil.wait(20);\n            assert.strictEqual(doc2.get('age'), 50);\n\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"#661 LocalDocument Observer field error","suites":["issues"],"updatePoint":{"line":555,"column":51},"line":555,"code":"        it('#661 LocalDocument Observer field error', async () => {\n            const myCollection = await humansCollection.create(0);\n            await myCollection.upsertLocal(\n                'foobar', {\n                foo: 'bar'\n            }\n            );\n\n            const emitted: any[] = [];\n            const localDoc = await myCollection.getLocal('foobar');\n            ensureNotFalsy(localDoc).get$('foo').subscribe((val: any) => emitted.push(val));\n\n            await AsyncTestUtil.waitUntil(() => emitted.length === 1);\n            assert.strictEqual(emitted[0], 'bar');\n\n            myCollection.database.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"#663 Document conflicts with LocalDocument in the same Collection","suites":["issues"],"updatePoint":{"line":572,"column":77},"line":572,"code":"        it('#663 Document conflicts with LocalDocument in the same Collection', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n            });\n\n            type DocData = { id: string; boudariesGrp: { bndrPlnId: string; bndrPlnNm: string; }[] };\n            const boundaryMgmtSchema: RxJsonSchema<DocData> = {\n                version: 0,\n                type: 'object',\n                primaryKey: 'id',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    boudariesGrp: {\n                        type: 'array',\n                        uniqueItems: false,\n                        items: {\n                            type: 'object',\n                            properties: {\n                                bndrPlnId: {\n                                    type: 'string',\n                                },\n                                bndrPlnNm: {\n                                    type: 'string',\n                                }\n                            }\n                        },\n                        default: [],\n                    },\n                }\n            };\n            const boundaryMgmtCols = await db.addCollections({\n                human: {\n                    schema: boundaryMgmtSchema,\n                    localDocuments: true\n                }\n            });\n            const boundaryMgmtCol = boundaryMgmtCols.human;\n\n            const groups = {\n                bndrPlnId: 'mygroup',\n                bndrPlnNm: 'other'\n            };\n\n            // insert non-local\n            await boundaryMgmtCol.insert({\n                id: randomCouchString(12),\n                boudariesGrp: [groups]\n            });\n\n            await boundaryMgmtCol.insertLocal('metadata', {\n                userData: {},\n                selectedBndrPlnId: 'foobar1',\n                actionRev: 0,\n                bndrId: 'foobar2',\n                direction: 'foobar3',\n            });\n\n            // save localgrpId\n            const grpId = 'foobar';\n            const metadata = await boundaryMgmtCol.getLocal('metadata');\n\n            await ensureNotFalsy(metadata).atomicUpdate(docData => {\n                docData.selectedBndrPlnId = grpId;\n                return docData;\n            });\n\n            const data = await boundaryMgmtCol.findOne().exec(true);\n            const json = data.toJSON();\n\n            assert.deepStrictEqual(json.boudariesGrp[0], groups);\n\n            db.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"local documents not persistent on db restart","suites":["issues"],"updatePoint":{"line":650,"column":56},"line":650,"code":"        it('local documents not persistent on db restart', async () => {\n            addPouchPlugin(require('pouchdb-adapter-leveldb'));\n            if (!config.platform.isNode()) {\n                return;\n            }\n            const dbName: string = config.rootPath + 'test_tmp/' + randomCouchString(10);\n\n            const localDocId = 'foobar';\n            const localDocData = {\n                foo: 'bar'\n            };\n\n            const db = await createRxDatabase({\n                name: dbName,\n                storage: getRxStoragePouch(leveldown),\n                multiInstance: false,\n                localDocuments: true\n            });\n            const cols = await db.addCollections({\n                humans: {\n                    schema: schemas.human,\n                    localDocuments: true\n                }\n            });\n\n            await db.insertLocal(localDocId, localDocData);\n            await cols.humans.insertLocal(localDocId, localDocData);\n\n            await db.destroy();\n\n            const db2 = await createRxDatabase({\n                name: dbName,\n                storage: getRxStoragePouch(leveldown),\n                multiInstance: false,\n                localDocuments: true\n            });\n            const col2 = await db2.addCollections({\n                humans: {\n                    schema: schemas.human,\n                    localDocuments: true\n                }\n            });\n\n            const docDb = await db2.getLocal(localDocId);\n            const docCol = await col2.humans.getLocal(localDocId);\n\n            assert.ok(docDb);\n            assert.ok(docCol);\n\n            assert.strictEqual(docDb.get('foo'), 'bar');\n            assert.strictEqual(docCol.get('foo'), 'bar');\n\n            await db2.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"doing many upsertLocal() can cause a 404 document not found","suites":["issues"],"updatePoint":{"line":704,"column":71},"line":704,"code":"        it('doing many upsertLocal() can cause a 404 document not found', async () => {\n            if (!config.platform.isNode()) {\n                return;\n            }\n            const dbName: string = config.rootPath + 'test_tmp/' + randomCouchString(10);\n            const db = await createRxDatabase({\n                name: dbName,\n                storage: getRxStoragePouch('leveldb'),\n                multiInstance: false,\n                localDocuments: true\n            });\n\n            const key = 'foobar';\n            let doc = await db.getLocal(key);\n            doc = await db.insertLocal(key, {\n                foo: 'bar'\n            });\n            assert.ok(doc);\n\n            let t = 0;\n            while (t < 50) {\n                await db.upsertLocal(key, {\n                    foo: randomString(10)\n                });\n                t++;\n            }\n\n            db.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"create a collection with static-methods","suites":["statics","create","positive"],"updatePoint":{"line":25,"column":59},"line":25,"code":"                it('create a collection with static-methods', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    await db.addCollections({\n                        humans: {\n                            schema: schemas.human,\n                            statics: {\n                                foobar: function () {\n                                    return 'test';\n                                }\n                            }\n                        }\n                    });\n                    db.destroy();\n                });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"crash when name not allowed (startsWith(_))","suites":["statics","create","negative"],"updatePoint":{"line":44,"column":63},"line":44,"code":"                it('crash when name not allowed (startsWith(_))', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    await AsyncTestUtil.assertThrows(\n                        () => db.addCollections({\n                            humans: {\n                                schema: schemas.human,\n                                statics: {\n                                    _foobar: function () {\n                                        return 'test';\n                                    }\n                                }\n                            }\n                        }),\n                        'RxTypeError',\n                        'cannot start'\n                    );\n                    db.destroy();\n                });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"crash when name not allowed (name reserved)","suites":["statics","create","negative"],"updatePoint":{"line":65,"column":63},"line":65,"code":"                it('crash when name not allowed (name reserved)', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const reserved = [\n                        'synced',\n                        'migrate',\n                        'insert',\n                        'preInsert'\n                    ];\n                    let t = 0;\n                    while (t < reserved.length) {\n                        const statics: any = {};\n                        statics[reserved[t]] = function () { };\n                        await AsyncTestUtil.assertThrows(\n                            () => db.addCollections({\n                                humans: {\n                                    schema: schemas.human,\n                                    statics\n                                }\n                            }),\n                            'RxError',\n                            reserved[t]\n                        );\n                        t++;\n                    }\n                    db.destroy();\n                });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"should be able to run the method","suites":["statics","run"],"updatePoint":{"line":97,"column":48},"line":97,"code":"            it('should be able to run the method', async () => {\n                const db = await createRxDatabase<{\n                    humans: RxCollection<HumanDocumentType, {}, { foobar(): string; }>\n                }>({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: schemas.human,\n                        statics: {\n                            foobar: function () {\n                                return 'test';\n                            }\n                        }\n                    }\n                });\n                const res = (collections.humans as any).foobar();\n                assert.strictEqual(res, 'test');\n                db.destroy();\n            });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"should have the right this-context","suites":["statics","run"],"updatePoint":{"line":118,"column":50},"line":118,"code":"            it('should have the right this-context', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: schemas.human,\n                        statics: {\n                            foobar: function () {\n                                return this.name;\n                            }\n                        }\n                    }\n                });\n                const collection = collections.humans;\n                const res = (collection as any).foobar();\n                assert.strictEqual(res, 'humans');\n                db.destroy();\n            });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"should be able to use this.insert()","suites":["statics","run"],"updatePoint":{"line":138,"column":51},"line":138,"code":"            it('should be able to use this.insert()', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: schemas.human,\n                        statics: {\n                            foobar: function (obj: any) {\n                                return this.insert(obj);\n                            }\n                        }\n                    }\n                });\n                const collection = collections.humans;\n                const res = (collection as any).foobar(schemaObjects.human());\n                assert.strictEqual(res.constructor.name, 'Promise');\n                await res;\n                db.destroy();\n            });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"create a collection with instance-methods","suites":["instance-methods","create","positive"],"updatePoint":{"line":164,"column":61},"line":164,"code":"                it('create a collection with instance-methods', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    await db.addCollections({\n                        humans: {\n                            schema: schemas.human,\n                            methods: {\n                                foobar: function () {\n                                    return 'test';\n                                }\n                            }\n                        }\n                    });\n                    db.destroy();\n                });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"this-scope should be bound to document","suites":["instance-methods","create","positive"],"updatePoint":{"line":181,"column":58},"line":181,"code":"                it('this-scope should be bound to document', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const cols = await db.addCollections({\n                        humans: {\n                            schema: schemas.human,\n                            methods: {\n                                myMethod: function () {\n                                    return 'test:' + this.firstName;\n                                }\n                            }\n                        }\n                    });\n                    const col = cols.humans;\n\n                    // add one to ensure it does not overwrite\n                    await col.insert(schemaObjects.human());\n\n                    const docData = schemaObjects.human();\n                    docData.firstName = 'foobar';\n                    const doc = await col.insert(docData);\n\n                    // add another one to ensure it does not overwrite\n                    await col.insert(schemaObjects.human());\n\n                    const val = doc.myMethod();\n                    assert.strictEqual(val, 'test:foobar');\n\n                    db.destroy();\n                });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"crash when name not allowed (startsWith(_))","suites":["instance-methods","create","negative"],"updatePoint":{"line":215,"column":63},"line":215,"code":"                it('crash when name not allowed (startsWith(_))', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    await AsyncTestUtil.assertThrows(\n                        () => db.addCollections({\n                            humans: {\n                                schema: schemas.human,\n                                methods: {\n                                    _foobar: function () {\n                                        return 'test';\n                                    }\n                                }\n                            }\n                        }),\n                        'RxTypeError'\n                    );\n                    db.destroy();\n                });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"crash when name not allowed (name reserved)","suites":["instance-methods","create","negative"],"updatePoint":{"line":235,"column":63},"line":235,"code":"                it('crash when name not allowed (name reserved)', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const reserved = [\n                        'primaryPath',\n                        'get',\n                        'toJSON',\n                    ];\n                    let t = 0;\n                    while (t < reserved.length) {\n                        const methods: any = {};\n                        methods[reserved[t]] = function () { };\n                        await AsyncTestUtil.assertThrows(\n                            () => db.addCollections({\n                                humans: {\n                                    schema: schemas.human,\n                                    methods\n                                }\n                            }),\n                            'RxError',\n                            reserved[t]\n                        );\n                        t++;\n                    }\n                    db.destroy();\n                });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"crash when name not allowed (name is top-level field in schema)","suites":["instance-methods","create","negative"],"updatePoint":{"line":263,"column":83},"line":263,"code":"                it('crash when name not allowed (name is top-level field in schema)', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const reserved = [\n                        'passportId',\n                        'firstName',\n                        'lastName',\n                        'age',\n                    ];\n                    let t = 0;\n                    while (t < reserved.length) {\n                        const methods: any = {};\n                        methods[reserved[t]] = function () { };\n                        await AsyncTestUtil.assertThrows(\n                            () => db.addCollections({\n                                humans: {\n                                    schema: schemas.human,\n                                    methods\n                                }\n                            }),\n                            'RxError',\n                            reserved[t]\n                        );\n                        t++;\n                    }\n                    db.destroy();\n                });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"should be able to run the method","suites":["instance-methods","run"],"updatePoint":{"line":296,"column":48},"line":296,"code":"            it('should be able to run the method', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: schemas.human,\n                        methods: {\n                            foobar: function () {\n                                return 'test';\n                            }\n                        }\n                    }\n                });\n                const collection = collections.humans;\n                await collection.insert(schemaObjects.human());\n                const doc = await collection.findOne().exec();\n                const res = doc.foobar();\n                assert.strictEqual(res, 'test');\n                db.destroy();\n            });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"should have the right this-context","suites":["instance-methods","run"],"updatePoint":{"line":318,"column":50},"line":318,"code":"            it('should have the right this-context', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: schemas.human,\n                        methods: {\n                            foobar: function () {\n                                return this.passportId;\n                            }\n                        }\n                    }\n                });\n                const collection = collections.humans;\n                const obj = schemaObjects.human();\n                await collection.insert(obj);\n                const doc = await collection.findOne().exec();\n                const res = doc.foobar();\n                assert.strictEqual(res, obj.passportId);\n                db.destroy();\n            });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"should not be confused with many collections","suites":["instance-methods","run"],"updatePoint":{"line":341,"column":60},"line":341,"code":"            it('should not be confused with many collections', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: schemas.human,\n                        methods: {\n                            foobar: () => '1'\n                        }\n                    },\n                    humans2: {\n                        schema: schemas.human,\n                        methods: {\n                            foobar: () => '2'\n                        }\n                    }\n                });\n                const collection = collections.humans;\n                const collection2 = collections.humans2;\n\n                const docData = schemaObjects.human();\n                const doc1 = await collection.insert(docData);\n                const doc2 = await collection2.insert(docData);\n\n                assert.strictEqual('1', doc1.foobar());\n                assert.strictEqual('2', doc2.foobar());\n\n                db.destroy();\n            });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"#791 Document methods are not bind() to the document","suites":["ISSUES"],"updatePoint":{"line":375,"column":64},"line":375,"code":"        it('#791 Document methods are not bind() to the document', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(),\n                storage: getRxStoragePouch('memory'),\n                multiInstance: false\n            });\n\n            const schema: RxJsonSchema<{ name: string; nested: { foo: string }; }> = {\n                version: 0,\n                type: 'object',\n                primaryKey: 'name',\n                properties: {\n                    name: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    nested: {\n                        type: 'object',\n                        properties: {\n                            foo: {\n                                type: 'string'\n                            }\n                        }\n                    }\n                }\n            };\n\n            const collections = await db.addCollections({\n                person: {\n                    schema: schema,\n                    methods: {\n                        hello: function () {\n                            return this.name;\n                        }\n                    }\n                }\n            });\n\n            const doc = await collections.person.insert({\n                name: 'hi',\n                nested: {\n                    foo: 'bar'\n                }\n            });\n\n            // orm-method\n            const hello = doc.hello;\n            assert.strictEqual(hello(), 'hi');\n\n            // prototype-method\n            const get = doc.get;\n            assert.strictEqual(get('name'), 'hi');\n\n            // nested\n            const nestedObj = doc.nested;\n            assert.strictEqual(nestedObj.foo, 'bar');\n\n            // nested getter-method\n            const obs = nestedObj.foo$;\n            const emitted: any[] = [];\n            const sub = obs.subscribe((v: any) => emitted.push(v));\n            await AsyncTestUtil.waitUntil(() => emitted.length === 1);\n            assert.strictEqual(emitted[0], 'bar');\n            sub.unsubscribe();\n\n            db.destroy();\n        });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"run the performance test","suites":["unit/performance.test.ts"],"updatePoint":{"line":17,"column":32},"line":17,"code":"    it('run the performance test', async function () {\n        if (config.isFastMode()) {\n            return;\n        }\n        this.timeout(120 * 1000);\n\n        const perfStorage = config.storage.getPerformanceStorage();\n\n        const totalTimeSums: { [k: string]: number } = {};\n\n        const runs = 5;\n        const collectionsAmount = 4;\n        const docsAmount = 300;\n\n        let runsDone = 0;\n        while (runsDone < runs) {\n            /**\n             * Wait a bit to ensure nothing else is running\n             * that would influence the performance.\n             */\n            await wait(200);\n\n            console.log('---------------- ' + runsDone);\n            runsDone++;\n\n            let time = performance.now();\n            const updateTime = (flag?: string) => {\n                if (!flag) {\n                    time = performance.now();\n                    return;\n                }\n                const diff = performance.now() - time;\n                if (!totalTimeSums[flag]) {\n                    totalTimeSums[flag] = diff;\n                } else {\n                    totalTimeSums[flag] = totalTimeSums[flag] + diff;\n                }\n                time = performance.now();\n            }\n\n            updateTime();\n\n            // create database\n            const db = await createRxDatabase({\n                name: 'test-db-performance-' + randomCouchString(10),\n                eventReduce: true,\n                /**\n                 * A RxStorage implementation (like LokiJS)\n                 * might need a full leader election cycle to be useable.\n                 * So we disable multiInstance here because it would make no sense\n                 * to measure the leader election time instead of the database\n                 * creation time.\n                 */\n                multiInstance: false,\n                storage: perfStorage.storage\n            });\n\n            // create collections\n            const collectionData: any = {};\n            let firstCollectionName: string = '';\n            new Array(collectionsAmount)\n                .fill(0)\n                .forEach((_v, idx) => {\n                    const name = randomCouchString(10) + '_' + idx;\n                    if (!firstCollectionName) {\n                        firstCollectionName = name;\n                    }\n                    collectionData[name] = {\n                        schema: schemas.averageSchema(),\n                        statics: {}\n                    };\n                });\n            const collections = await db.addCollections(collectionData);\n            const collection = collections[firstCollectionName];\n\n\n            /**\n             * Many storages have a lazy initialization.\n             * So it makes no sense to measure the time of database/collection creation.\n             * Insert we do a single insert an measure the time to the first insert.\n             */\n            await collection.insert(schemaObjects.averageSchema());\n            updateTime('time-to-first-insert');\n\n            // insert documents\n            const docIds: string[] = [];\n            const docsData = new Array(docsAmount)\n                .fill(0)\n                .map(() => {\n                    const data = schemaObjects.averageSchema();\n                    docIds.push(data.id);\n                    return data;\n                });\n            updateTime();\n            await collection.bulkInsert(docsData);\n            updateTime('insert-documents');\n\n            /**\n             * Find by id,\n             * here we run the query agains the storage because\n             * if we would do collection.findByIds(), it would\n             * just return the documents from the cache.\n             * \n             */\n            const idsResult = await collection.storageInstance.findDocumentsById(docIds, false);\n            updateTime('find-by-ids');\n            assert.strictEqual(Object.keys(idsResult).length, docsAmount);\n\n            // find by query\n            updateTime();\n            const queryResult = await collection.find({\n                selector: {\n                    var1: {\n                        $gt: ''\n                    }\n                }\n            }).exec();\n            updateTime('find-by-query');\n            assert.strictEqual(queryResult.length, docsAmount + 1);\n\n            await db.remove();\n        }\n\n\n        const timeToLog: any = {\n            description: perfStorage.description\n        };\n        Object.entries(totalTimeSums).forEach(([key, totalTime]) => {\n            timeToLog[key] = totalTime / runs;\n        });\n\n        console.log('Performance test for ' + perfStorage.description);\n        console.log(JSON.stringify(timeToLog, null, 4));\n    });","file":"unit/performance.test.ts","skipped":false,"dir":"test"},{"name":"should not crash when a new plugin is added","suites":[".addRxPlugin()","positive"],"updatePoint":{"line":31,"column":59},"line":31,"code":"            it('should not crash when a new plugin is added', () => {\n                addRxPlugin({\n                    rxdb: true,\n                    name: randomCouchString(12)\n                });\n            });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"should crash when dev-mode is added multiple times","suites":[".addRxPlugin()","positive"],"updatePoint":{"line":43,"column":66},"line":43,"code":"            it('should crash when dev-mode is added multiple times', async () => {\n                await assertThrows(\n                    () => addRxPlugin(RxDBDevModePlugin),\n                    'RxError',\n                    'DEV1'\n                );\n            });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"should not crash when pouch plugin is added","suites":[".addPouchPlugin()"],"updatePoint":{"line":53,"column":55},"line":53,"code":"        it('should not crash when pouch plugin is added', () => {\n            addPouchPlugin(require('pouchdb-adapter-memory'));\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"should crash when rxdb plugin is added via addPouchPlugin","suites":[".addPouchPlugin()"],"updatePoint":{"line":56,"column":69},"line":56,"code":"        it('should crash when rxdb plugin is added via addPouchPlugin', async () => {\n            await assertThrows(\n                () => addPouchPlugin(RxDBDevModePlugin),\n                'RxTypeError',\n                'PL2'\n            );\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"core.node.ts: should run without errors","suites":["core.node.ts"],"updatePoint":{"line":65,"column":51},"line":65,"code":"        it('core.node.ts: should run without errors', async function () {\n            this.timeout(10000);\n            if (!config.platform.isNode())\n                return;\n\n            const spawn = REQUIRE_FUN('child-process-promise').spawn;\n            const stdout: any[] = [];\n            const stderr: any[] = [];\n            const promise = spawn('mocha', [config.rootPath + 'test_tmp/unit/core.node.js']);\n            const childProcess = promise.childProcess;\n            childProcess.stdout.on('data', (data: any) => {\n                // comment in to debug\n                //               console.log(':: ' + data.toString());\n                stdout.push(data.toString());\n            });\n            childProcess.stderr.on('data', (data: any) => stderr.push(data.toString()));\n            try {\n                await promise;\n            } catch (err) {\n                console.error('errrrr');\n                console.dir(stdout);\n                throw new Error(`could not run Core.node.js.\n                    # Error: ${err}\n                    # Output: ${stdout}\n                    # ErrOut: ${stderr}\n                    `);\n            }\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"full.node.ts should run without errors","suites":["full.node.ts"],"updatePoint":{"line":95,"column":50},"line":95,"code":"        it('full.node.ts should run without errors', async () => {\n            if (!config.platform.isNode())\n                return;\n\n            const spawn = REQUIRE_FUN('child-process-promise').spawn;\n            const stdout: any[] = [];\n            const stderr: any[] = [];\n            const promise = spawn('mocha', [config.rootPath + 'test_tmp/unit/full.node.js']);\n            const childProcess = promise.childProcess;\n            childProcess.stdout.on('data', (data: any) => stdout.push(data.toString()));\n            childProcess.stderr.on('data', (data: any) => stderr.push(data.toString()));\n            try {\n                await promise;\n            } catch (err) {\n                console.error('errrrr');\n                console.dir(stdout);\n                throw new Error(`could not run full.node.js.\n                    # Error: ${err}\n                    # Output: ${stdout}\n                    # ErrOut: ${stderr}\n                    `);\n            }\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"ajv-validate.node.ts: should allow everything","suites":["ajv-validate.node.ts"],"updatePoint":{"line":120,"column":57},"line":120,"code":"        it('ajv-validate.node.ts: should allow everything', async () => {\n            if (!config.platform.isNode())\n                return;\n\n            const spawn = REQUIRE_FUN('child-process-promise').spawn;\n            const stdout: any[] = [];\n            const stderr: any[] = [];\n            const promise = spawn('mocha', [config.rootPath + 'test_tmp/unit/ajv-validate.node.js']);\n            const childProcess = promise.childProcess;\n            childProcess.stdout.on('data', (data: any) => {\n                // comment in to debug\n                // console.log(':: ' + data.toString());\n                stdout.push(data.toString());\n            });\n            childProcess.stderr.on('data', (data: any) => stderr.push(data.toString()));\n            try {\n                await promise;\n            } catch (err) {\n                console.error('errrrr');\n                console.dir(stdout);\n                throw new Error(`could not run ajv-validate.node.js.\n                            # Error: ${err}\n                            # Output: ${stdout}\n                            # ErrOut: ${stderr}\n                            `);\n            }\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"validate-z-schema.node.ts: should allow everything","suites":["validate-z-schema.node.tes"],"updatePoint":{"line":149,"column":62},"line":149,"code":"        it('validate-z-schema.node.ts: should allow everything', async () => {\n            if (!config.platform.isNode())\n                return;\n\n            const spawn = REQUIRE_FUN('child-process-promise').spawn;\n            const stdout: any[] = [];\n            const stderr: any[] = [];\n            const promise = spawn('mocha', [config.rootPath + 'test_tmp/unit/validate-z-schema.node.js']);\n            const childProcess = promise.childProcess;\n            childProcess.stdout.on('data', (data: any) => {\n                // comment in to debug\n                // console.log(':: ' + data.toString());\n                stdout.push(data.toString());\n            });\n            childProcess.stderr.on('data', (data: any) => stderr.push(data.toString()));\n            try {\n                await promise;\n            } catch (err) {\n                console.error('errrrr');\n                console.dir(stdout);\n                throw new Error(`could not run validate-z-schema.node.js.\n                            # Error: ${err}\n                            # Output: ${stdout}\n                            # ErrOut: ${stderr}\n                            `);\n            }\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"no-validate.node.ts: should allow everything","suites":["no-validate.node.ts"],"updatePoint":{"line":178,"column":56},"line":178,"code":"        it('no-validate.node.ts: should allow everything', async () => {\n            if (!config.platform.isNode())\n                return;\n\n            const spawn = REQUIRE_FUN('child-process-promise').spawn;\n            const stdout: any[] = [];\n            const stderr: any[] = [];\n            const promise = spawn('mocha', [config.rootPath + 'test_tmp/unit/no-validate.node.js']);\n            const childProcess = promise.childProcess;\n            childProcess.stdout.on('data', (data: any) => {\n                // comment in to debug\n                // console.log(':: ' + data.toString());\n                stdout.push(data.toString());\n            });\n            childProcess.stderr.on('data', (data: any) => {\n                stderr.push(data.toString());\n            });\n            try {\n                await promise;\n            } catch (err) {\n                console.error('errrrr');\n                console.dir(stdout);\n                throw new Error(`could not run no-validate.node.js.\n                            # Error: ${err}\n                            # Output: ${stdout}\n                            # ErrOut: ${stderr}\n                            `);\n            }\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"createRxDatabase","suites":["hooks"],"updatePoint":{"line":209,"column":28},"line":209,"code":"        it('createRxDatabase', async () => {\n\n            const createRxDatabase = (args: any) => {\n                args.database.foo = 'bar_createRxDatabase';\n            };\n            const plugin: RxPlugin = {\n                rxdb: true,\n                name: randomCouchString(12),\n                hooks: {\n                    createRxDatabase: {\n                        after: createRxDatabase\n                    }\n                }\n            };\n            addRxPlugin(plugin);\n            const col = await humansCollection.create();\n            assert.strictEqual(col.database.foo, 'bar_createRxDatabase');\n            col.database.destroy();\n\n            _clearHook('createRxDatabase', createRxDatabase);\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"createRxCollection","suites":["hooks"],"updatePoint":{"line":230,"column":30},"line":230,"code":"        it('createRxCollection', async () => {\n            const createRxCollection = (args: any) => {\n                args.collection.foo = 'bar_createRxCollection';\n            };\n            const plugin: RxPlugin = {\n                rxdb: true,\n                name: randomCouchString(12),\n                hooks: {\n                    createRxCollection: {\n                        after: createRxCollection\n                    }\n                }\n            };\n            addRxPlugin(plugin);\n            const col = await humansCollection.create();\n            assert.strictEqual((col as any).foo, 'bar_createRxCollection');\n            col.database.destroy();\n            _clearHook('createRxCollection', createRxCollection);\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"createRxSchema","suites":["hooks"],"updatePoint":{"line":249,"column":26},"line":249,"code":"        it('createRxSchema', async () => {\n            const createRxSchema = (c: any) => {\n                c.foo = 'bar_createRxSchema';\n            };\n            const plugin: RxPlugin = {\n                rxdb: true,\n                name: randomCouchString(12),\n                hooks: {\n                    createRxSchema: {\n                        after: createRxSchema\n                    }\n                }\n            };\n            addRxPlugin(plugin);\n            const col: any = await humansCollection.create();\n            assert.strictEqual(col.schema['foo'], 'bar_createRxSchema');\n            col.database.destroy();\n            _clearHook('createRxSchema', createRxSchema);\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"createRxQuery","suites":["hooks"],"updatePoint":{"line":268,"column":25},"line":268,"code":"        it('createRxQuery', async () => {\n            const createRxQuery = (c: any) => {\n                c.foo = 'bar_createRxQuery';\n            };\n            const plugin: RxPlugin = {\n                rxdb: true,\n                name: randomCouchString(12),\n                hooks: {\n                    createRxQuery: {\n                        after: createRxQuery\n                    }\n                }\n            };\n            addRxPlugin(plugin);\n            const col = await humansCollection.create();\n            const query: any = col.find();\n            assert.strictEqual(query['foo'], 'bar_createRxQuery');\n            col.database.destroy();\n            _clearHook('createRxQuery', createRxQuery);\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"createRxDocument","suites":["hooks"],"updatePoint":{"line":288,"column":28},"line":288,"code":"        it('createRxDocument', async () => {\n            const createRxDocument = (c: any) => {\n                c.foo = 'bar_createRxDocument';\n            };\n            const plugin: RxPlugin = {\n                rxdb: true,\n                name: randomCouchString(12),\n                hooks: {\n                    createRxDocument: {\n                        after: createRxDocument\n                    }\n                }\n            };\n            addRxPlugin(plugin);\n            const col = await humansCollection.create(5);\n            const doc: any = await col.findOne().exec();\n            assert.strictEqual(doc.foo, 'bar_createRxDocument');\n            col.database.destroy();\n            _clearHook('createRxDocument', createRxDocument);\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"postCreateRxDocument","suites":["hooks"],"updatePoint":{"line":308,"column":32},"line":308,"code":"        it('postCreateRxDocument', async () => {\n            const postCreateRxDocument = (c: any) => {\n                c.fooPostCreate = 'bar_postCreateRxDocument';\n            };\n            const plugin: RxPlugin = {\n                rxdb: true,\n                name: randomCouchString(12),\n                hooks: {\n                    postCreateRxDocument: {\n                        after: postCreateRxDocument\n                    }\n                }\n            };\n            addRxPlugin(plugin);\n            const col = await humansCollection.create(5);\n            const doc: any = await col.findOne().exec();\n            assert.strictEqual(doc.fooPostCreate, 'bar_postCreateRxDocument');\n            await col.database.destroy();\n            _clearHook('postCreateRxDocument', postCreateRxDocument);\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"should allow to create a schema with a relation","suites":["createRxSchema","positive"],"updatePoint":{"line":23,"column":63},"line":23,"code":"            it('should allow to create a schema with a relation', () => {\n                const schema = createRxSchema({\n                    version: 0,\n                    primaryKey: 'bestFriend',\n                    type: 'object',\n                    properties: {\n                        bestFriend: {\n                            ref: 'human',\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    }\n                });\n                assert.strictEqual(schema.constructor.name, 'RxSchema');\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"should allow primary as relation key","suites":["createRxSchema","positive"],"updatePoint":{"line":43,"column":52},"line":43,"code":"            it('should allow primary as relation key', () => {\n                const schema = createRxSchema({\n                    version: 0,\n                    primaryKey: 'bestFriend',\n                    type: 'object',\n                    properties: {\n                        bestFriend: {\n                            ref: 'human',\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    }\n                });\n                assert.strictEqual(schema.constructor.name, 'RxSchema');\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"should allow to create a schema with a relation in nested","suites":["createRxSchema","positive"],"updatePoint":{"line":58,"column":73},"line":58,"code":"            it('should allow to create a schema with a relation in nested', () => {\n                const schema = createRxSchema<any>({\n                    version: 0,\n                    primaryKey: 'id',\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        foo: {\n                            type: 'object',\n                            properties: {\n                                bestFriend: {\n                                    ref: 'human',\n                                    type: 'string'\n                                }\n                            }\n                        }\n                    }\n                });\n                assert.strictEqual(schema.constructor.name, 'RxSchema');\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"should allow to create relation of array","suites":["createRxSchema","positive"],"updatePoint":{"line":81,"column":56},"line":81,"code":"            it('should allow to create relation of array', () => {\n                const schema = createRxSchema<any>({\n                    version: 0,\n                    primaryKey: 'id',\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        friends: {\n                            type: 'array',\n                            items: {\n                                ref: 'human',\n                                type: 'string'\n                            }\n                        }\n                    }\n                });\n                assert.strictEqual(schema.constructor.name, 'RxSchema');\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"should allow to create relation with nullable string","suites":["createRxSchema","positive"],"updatePoint":{"line":102,"column":68},"line":102,"code":"            it('should allow to create relation with nullable string', () => {\n                const schema = createRxSchema<any>({\n                    version: 0,\n                    primaryKey: 'id',\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        friends: {\n                            type: 'array',\n                            items: {\n                                ref: 'human',\n                                type: ['string', 'null']\n                            }\n                        }\n                    }\n                });\n                assert.strictEqual(schema.constructor.name, 'RxSchema');\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"throw if ref-type is no string","suites":["createRxSchema","negative"],"updatePoint":{"line":125,"column":46},"line":125,"code":"            it('throw if ref-type is no string', () => {\n                assert.throws(\n                    () => createRxSchema<any>({\n                        version: 0,\n                        primaryKey: 'id',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            bestFriend: {\n                                ref: 'human'\n                            }\n                        }\n                    }),\n                    Error\n                );\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"throw if ref-type is no string (array)","suites":["createRxSchema","negative"],"updatePoint":{"line":144,"column":54},"line":144,"code":"            it('throw if ref-type is no string (array)', () => {\n                assert.throws(\n                    () => createRxSchema<any>({\n                        version: 0,\n                        primaryKey: 'id',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            friends: {\n                                type: 'array',\n                                items: {\n                                    ref: 'human'\n                                }\n                            }\n                        }\n                    }),\n                    Error\n                );\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"populate top-level-field","suites":["RxDocument().populate()","positive"],"updatePoint":{"line":170,"column":40},"line":170,"code":"            it('populate top-level-field', async () => {\n                const col = await humansCollection.createRelated();\n                const doc = await col.findOne().exec(true);\n                const friend = await doc.populate('bestFriend');\n                assert.ok(isRxDocument(friend));\n                assert.strictEqual(friend.name, doc.bestFriend);\n                col.database.destroy();\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"populate nested field","suites":["RxDocument().populate()","positive"],"updatePoint":{"line":178,"column":37},"line":178,"code":"            it('populate nested field', async () => {\n                const col = await humansCollection.createRelatedNested();\n                const doc = await col.findOne().exec(true);\n                const friend = await doc.populate('foo.bestFriend');\n                assert.ok(isRxDocument(friend));\n                assert.strictEqual(friend.name, doc.foo.bestFriend);\n                col.database.destroy();\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"populate string-array","suites":["RxDocument().populate()","positive"],"updatePoint":{"line":186,"column":37},"line":186,"code":"            it('populate string-array', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const cols = await db.addCollections({\n                    human: {\n                        schema: {\n                            version: 0,\n                            primaryKey: 'name',\n                            type: 'object',\n                            properties: {\n                                name: {\n                                    type: 'string',\n                                    maxLength: 100\n                                },\n                                friends: {\n                                    type: 'array',\n                                    ref: 'human',\n                                    items: {\n                                        type: 'string'\n                                    }\n                                }\n                            }\n                        }\n                    }\n                });\n                const col = cols.human;\n                const friends = new Array(5)\n                    .fill(0)\n                    .map(() => {\n                        return {\n                            name: faker.name.firstName() + randomCouchString(5),\n                            friends: []\n                        };\n                    });\n                await Promise.all(friends.map(friend => col.insert(friend)));\n                const oneGuy = {\n                    name: 'Piotr',\n                    friends: friends.map(friend => friend.name)\n                };\n                await col.insert(oneGuy);\n                const doc = await col.findOne(oneGuy.name).exec();\n                const friendDocs = await doc.friends_;\n                friendDocs.forEach((friend: any) => {\n                    assert.ok(isRxDocument(friend));\n                });\n                db.destroy();\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"populate with primary as ref","suites":["RxDocument().populate()","positive"],"updatePoint":{"line":235,"column":44},"line":235,"code":"            it('populate with primary as ref', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const schema: RxJsonSchema<{ name: string; }> = {\n                    version: 0,\n                    primaryKey: 'name',\n                    type: 'object',\n                    properties: {\n                        name: {\n                            type: 'string',\n                            maxLength: 100,\n                            ref: 'human2'\n                        }\n                    }\n                };\n                const cols = await db.addCollections({\n                    human: {\n                        schema\n                    },\n                    human2: {\n                        schema\n                    }\n                });\n                const col = cols.human;\n                const col2 = cols.human2;\n\n                const doc = await col.insert({\n                    name: 'foobar'\n                });\n                await col2.insert({\n                    name: 'foobar'\n                });\n                const doc2 = await doc.populate(doc.primaryPath);\n                assert.ok(doc2.collection === col2);\n\n                db.destroy();\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"populate top-level-field","suites":["RxDocument populate via pseudo-proxy","positive"],"updatePoint":{"line":278,"column":40},"line":278,"code":"            it('populate top-level-field', async () => {\n                const col = await humansCollection.createRelated();\n                const doc = await col.findOne().exec(true);\n                const friend = await (doc as any).bestFriend_;\n                assert.ok(isRxDocument(friend));\n                assert.strictEqual(friend.name, doc.bestFriend);\n                col.database.destroy();\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"populate nested field","suites":["RxDocument populate via pseudo-proxy","positive"],"updatePoint":{"line":286,"column":37},"line":286,"code":"            it('populate nested field', async () => {\n                const col = await humansCollection.createRelatedNested();\n                const doc = await col.findOne().exec(true);\n                const friend = await (doc as any).foo.bestFriend_;\n                assert.ok(isRxDocument(friend));\n                assert.strictEqual(friend.name, doc.foo.bestFriend);\n                col.database.destroy();\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"#222 population not working when multiInstance: false","suites":["issues"],"updatePoint":{"line":297,"column":65},"line":297,"code":"        it('#222 population not working when multiInstance: false', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n                multiInstance: false // this must be false here\n            });\n            const cols = await db.addCollections({\n                doca: {\n                    schema: {\n                        type: 'object',\n                        primaryKey: 'name',\n                        version: 0,\n                        properties: {\n                            name: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            refB: {\n                                ref: 'docb', // refers to collection human\n                                type: 'string' // ref-values must always be string (primary of foreign RxDocument)\n                            }\n                        }\n                    }\n                },\n                docb: {\n                    schema: {\n                        version: 0,\n                        primaryKey: 'name',\n                        type: 'object',\n                        properties: {\n                            name: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            somevalue: {\n                                type: 'string'\n                            }\n                        }\n                    }\n                }\n            });\n            const colA = cols.doca;\n            const colB = cols.docb;\n\n            await colB.insert({\n                name: 'docB-01',\n                somevalue: 'foobar'\n            });\n            await colA.insert({\n                name: 'docA-01',\n                refB: 'docB-01'\n            });\n\n            const docA = await colA.findOne().where('name').eq('docA-01').exec();\n            const docB = await docA.populate('refB');\n\n            assert.ok(isRxDocument(docB));\n            assert.strictEqual(docB.somevalue, 'foobar');\n\n            db.destroy();\n        });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"should export the pouchDB-module","suites":["init"],"updatePoint":{"line":37,"column":44},"line":37,"code":"        it('should export the pouchDB-module', () => {\n            addPouchPlugin(PouchReplicationPlugin);\n            assert.strictEqual(typeof PouchDB, 'function');\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"must be able to insert->update->delete via replication","suites":["assumptions"],"updatePoint":{"line":43,"column":66},"line":43,"code":"        it('must be able to insert->update->delete via replication', async () => {\n            addPouchPlugin(require('pouchdb-adapter-memory'));\n            addPouchPlugin(PouchDBFind);\n\n            const pouch1: PouchDBInstance = new PouchDB('foobar1' + randomCouchString(10), {\n                adapter: 'memory'\n            });\n            const pouch2: PouchDBInstance = new PouchDB('foobar2' + randomCouchString(10), {\n                adapter: 'memory'\n            });\n            const syncHandler = pouch1.sync(pouch2, {\n                live: true\n            });\n\n            const docData: any = {\n                _id: 'syncMe',\n                value: 1\n            };\n            async function getDocsFromPouch2() {\n                const allDocs = await pouch2.find({\n                    selector: {}\n                });\n                return allDocs.docs;\n            }\n\n            // insert\n            const insertResult = await pouch1.put(clone(docData));\n            docData._rev = insertResult.rev;\n\n            await AsyncTestUtil.waitUntil(async () => {\n                const allDocs = await getDocsFromPouch2();\n                return allDocs.length === 1;\n            });\n\n            // update\n            docData.value = 2;\n            const updateResult = await pouch1.put(clone(docData));\n            docData._rev = updateResult.rev;\n\n            await AsyncTestUtil.waitUntil(async () => {\n                const allDocs = await getDocsFromPouch2();\n                return allDocs.length === 1 && (allDocs[0] as any).value === 2;\n            });\n\n            // delete\n            docData._deleted = true;\n            const deleteResult = await pouch1.put(clone(docData));\n            assert.ok(deleteResult);\n            await AsyncTestUtil.waitUntil(async () => {\n                const allDocs = await getDocsFromPouch2();\n                return allDocs.length === 0;\n            });\n\n            // undelete via insert\n            const undeleteResult = await pouch1.put({\n                _id: 'syncMe',\n                value: 5\n            });\n            assert.ok(undeleteResult);\n            await AsyncTestUtil.waitUntil(async () => {\n                const allDocs = await getDocsFromPouch2();\n                return allDocs.length === 1 && (allDocs[0] as any).value === 5;\n            });\n\n            await syncHandler.cancel();\n            await promiseWait(100);\n            await pouch1.close();\n            await pouch2.close();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"must be able to insert->update->delete via new_edits:false","suites":["assumptions"],"updatePoint":{"line":112,"column":70},"line":112,"code":"        it('must be able to insert->update->delete via new_edits:false', async () => {\n            const pouch: PouchDBInstance = new PouchDB('foobar' + randomCouchString(10), {\n                adapter: 'memory'\n            });\n            const docId = 'foobar';\n\n            // insert\n            await pouch.bulkDocs({\n                docs: [{\n                    _id: docId,\n                    value: 1,\n                    _rev: '1-51b2fae5721cc4d3cf7392f19e6cc118'\n                }]\n            }, {\n                new_edits: false\n            });\n\n            // update\n            let getDocs = await pouch.bulkGet({\n                docs: [{ id: docId }],\n                revs: true,\n                latest: true\n            });\n            let useRevs = (getDocs as any).results[0].docs[0].ok._revisions;\n            useRevs.start = useRevs.start + 1;\n            useRevs.ids.unshift('a723631364fbfa906c5ffa8203ac9725');\n\n            await pouch.bulkDocs({\n                docs: [{\n                    _id: docId,\n                    value: 2,\n                    _rev: '2-a723631364fbfa906c5ffa8203ac9725',\n                    _revisions: useRevs\n                }]\n            }, {\n                new_edits: false\n            });\n\n            // delete\n            getDocs = await pouch.bulkGet({\n                docs: [{ id: docId }],\n                revs: true,\n                latest: true\n            });\n            useRevs = (getDocs as any).results[0].docs[0].ok._revisions;\n            useRevs.start = useRevs.start + 1;\n            useRevs.ids.unshift('13af8c9a835820969a8a273b18783a70');\n\n            await pouch.bulkDocs({\n                docs: [{\n                    _id: docId,\n                    value: 2,\n                    _deleted: true,\n                    _rev: '3-13af8c9a835820969a8a273b18783a70',\n                    _revisions: useRevs\n                }]\n            }, {\n                new_edits: false\n            });\n\n            let allDocs = await pouch.find({\n                selector: {}\n            });\n            assert.strictEqual(allDocs.docs.length, 0);\n\n            // undelete via insert\n            getDocs = await pouch.bulkGet({\n                docs: [{ id: docId }],\n                revs: true,\n                latest: true\n            });\n\n            const getDocs2 = await pouch.bulkGet({\n                docs: [{ id: docId, rev: '3-13af8c9a835820969a8a273b18783a70' }],\n                revs: true,\n                latest: true\n            });\n\n            useRevs = (getDocs2 as any).results[0].docs[0].ok._revisions;\n            useRevs.start = 1;\n            useRevs.ids.unshift('14af8c9a835820969a8a273b18783a70');\n            await pouch.bulkDocs({\n                docs: [{\n                    _id: docId,\n                    value: 5,\n                    _deleted: false,\n                    _rev: '1-14af8c9a835820969a8a273b18783a70',\n                    _revisions: useRevs\n                }]\n            }, {\n                new_edits: false\n            });\n\n\n            // must be found via query\n            allDocs = await pouch.find({\n                selector: {\n                    _id: docId\n                },\n                limit: 1\n            });\n            assert.strictEqual(allDocs.docs.length, 1);\n            assert.strictEqual((allDocs.docs[0] as any).value, 5);\n\n            // same via .get\n            const getDoc = await pouch.get(docId);\n            assert.strictEqual(getDoc.value, 5);\n\n            pouch.close();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"should not allow leveldown-adapters without the plugin","suites":["memdown"],"updatePoint":{"line":224,"column":66},"line":224,"code":"        it('should not allow leveldown-adapters without the plugin', async () => {\n            await AsyncTestUtil.assertThrows(\n                () => createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch(memdown)\n                }),\n                'RxError',\n                'leveldb-plugin'\n            );\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"should work after adding the leveldb-plugin","suites":["memdown"],"updatePoint":{"line":234,"column":55},"line":234,"code":"        it('should work after adding the leveldb-plugin', async () => {\n            if (!config.platform.isNode()) {\n                return;\n            }\n            PouchDB.plugin(leveldb);\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch(memdown)\n            });\n            assert.ok(isRxDatabase(db));\n            db.destroy();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"should work when adapter was added","suites":["pouchdb-adapter-memory"],"updatePoint":{"line":248,"column":46},"line":248,"code":"        it('should work when adapter was added', async () => {\n            addPouchPlugin(require('pouchdb-adapter-memory'));\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory')\n            });\n            assert.ok(isRxDatabase(db));\n            db.destroy();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"should crash because nodejs has no localstorage","suites":["localstorage"],"updatePoint":{"line":259,"column":59},"line":259,"code":"        it('should crash because nodejs has no localstorage', async () => {\n            if (!config.platform.isNode()) return;\n            PouchDB.plugin(require('pouchdb-adapter-localstorage'));\n            await AsyncTestUtil.assertThrows(\n                () => createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('localstorage')\n                }),\n                'RxError',\n                'Adapter'\n            );\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"should fail when no adapter was added","suites":["websql","negative"],"updatePoint":{"line":274,"column":53},"line":274,"code":"            it('should fail when no adapter was added', async () => {\n                await AsyncTestUtil.assertThrows(\n                    () => createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('websql')\n                    }),\n                    'RxError',\n                    'Adapter'\n                );\n            });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"should work after adding the adapter","suites":["websql","positive"],"updatePoint":{"line":286,"column":52},"line":286,"code":"            it('should work after adding the adapter', async () => {\n                // test websql on chrome only\n                if (config.platform.name !== 'chrome') return;\n\n                addPouchPlugin(require('pouchdb-adapter-websql'));\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('websql')\n                });\n                assert.ok(isRxDatabase(db));\n                await promiseWait(10);\n                db.destroy();\n            });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"_local documents should not be cached by pouchdb","suites":["BUGS: pouchdb"],"updatePoint":{"line":302,"column":60},"line":302,"code":"        it('_local documents should not be cached by pouchdb', async () => {\n            const name = randomCouchString(10);\n            const _id = '_local/foobar';\n            function createPouch(): PouchDBInstance {\n                const pouch = new PouchDB(\n                    name, {\n                    adapter: 'memory',\n                    auto_compaction: true,\n                    revs_limit: 1\n                }\n                ) as any;\n                return pouch;\n            }\n            const pouch1 = createPouch();\n            const pouch2 = createPouch();\n            await AsyncTestUtil.assertThrows(\n                () => pouch2.get(_id),\n                'PouchError'\n            );\n            // insert\n            await pouch1.put({\n                _id,\n                value: 'foo'\n            });\n            const doc2 = await pouch2.get(_id);\n            assert.strictEqual(doc2.value, 'foo');\n\n            pouch1.destroy();\n            pouch2.destroy();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"pouchdb.find() should not return design-docs","suites":["BUGS: pouchdb"],"updatePoint":{"line":335,"column":56},"line":335,"code":"        it('pouchdb.find() should not return design-docs', async () => {\n            const pouch = new PouchDB(\n                randomCouchString(10), {\n                adapter: 'memory',\n                auto_compaction: true,\n                revs_limit: 1\n            }\n            );\n\n            await pouch.createIndex({\n                index: {\n                    fields: ['foo']\n                }\n            });\n\n            // add one doc\n            await pouch.put({\n                _id: 'asdf',\n                foo: 'bar'\n            });\n\n            // get docs\n            const docs = await pouch.find({\n                selector: {\n                    foo: {\n                        $gt: null\n                    }\n                },\n                sort: ['foo']\n            });\n\n            assert.strictEqual(docs.docs.length, 1);\n\n            pouch.destroy();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"removing via bulkDocs does not work","suites":["BUGS: pouchdb"],"updatePoint":{"line":370,"column":47},"line":370,"code":"        it('removing via bulkDocs does not work', async () => {\n            const pouch: PouchDBInstance = new PouchDB(\n                randomCouchString(10), {\n                adapter: 'memory',\n                auto_compaction: true,\n                revs_limit: 1\n            }\n            ) as any;\n\n            // add one doc\n            await pouch.put({\n                _id: 'foobar',\n                foo: 'bar'\n            });\n\n            // overwrite via bulkDocs\n            const bulkOptions = {\n                new_edits: false\n            };\n            await pouch.bulkDocs({\n                docs: [{\n                    _id: 'foobar',\n                    foo: 'bar',\n                    _rev: '2-6c5d4399ffe848f395069eab42630eee'\n                }]\n            }, bulkOptions);\n\n            // find again\n            const foundAfter = await pouch.find({\n                selector: {}\n            });\n            assert.ok(foundAfter.docs[0]._rev.startsWith('2-')); // ok\n\n            // delete via bulkDocs\n            const x = await pouch.put({\n                _id: 'foobar',\n                foo: 'bar',\n                _rev: '3-13af8c9a835820969a8a273b18783a70',\n                _deleted: true\n            }, bulkOptions);\n            assert.strictEqual((x as any).length, 0);\n\n            /**\n             * If this test ever throws, it means we can remove the hacky workarround in\n             * src/plugins/in-memory.js\n             * Where we add the emitFlag to 'doNotEmitSet'\n             */\n            await AsyncTestUtil.assertThrows(\n                async () => {\n                    const foundAfter2 = await pouch.find({\n                        selector: {}\n                    });\n                    assert.ok(foundAfter2.docs[0]._rev.startsWith('3-'));\n                },\n                'AssertionError'\n            );\n\n            pouch.destroy();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"putting with _deleted does not work","suites":["BUGS: pouchdb"],"updatePoint":{"line":429,"column":47},"line":429,"code":"        it('putting with _deleted does not work', async () => {\n            const pouch: PouchDBInstance = new PouchDB(\n                randomCouchString(10), {\n                adapter: 'memory',\n                auto_compaction: true,\n                revs_limit: 1\n            }\n            ) as any;\n            const bulkOptions = {\n                new_edits: false\n            };\n\n            // subscribe to changes 2 times\n            pouch.changes({\n                since: 'now',\n                live: true,\n                include_docs: true\n            });\n            pouch.changes({\n                since: 'now',\n                live: true,\n                include_docs: true\n            });\n\n            // insert doc via bulkDocs\n            const docs = [{\n                '|c': '0waqyh2xjwtu',\n                '|a': 'foo123',\n                '|b': 'King',\n                age: 1,\n                _id: 'myid',\n                _rev: '1-62080c42d471e3d2625e49dcca3b8e3e'\n            }];\n            await pouch.bulkDocs({\n                docs\n            }, bulkOptions);\n\n            let foundAfter = await pouch.find<{ firstName: string, _deleted: boolean }>({\n                selector: {}\n            });\n            assert.strictEqual(foundAfter.docs.length, 1);\n\n\n            // update via bulkDocs\n            const updateMe = foundAfter.docs[0];\n            updateMe.firstName = 'foobar';\n            await pouch.bulkDocs({\n                docs: [updateMe]\n            }, bulkOptions);\n\n            // remove\n            foundAfter = await pouch.find({\n                selector: {}\n            });\n            const removeMe = foundAfter.docs[0];\n            removeMe._deleted = true;\n            await pouch.get('myid').catch(() => null);\n            await pouch.put(removeMe);\n\n            await AsyncTestUtil.wait(100);\n\n            foundAfter = await pouch.find({\n                selector: {}\n            });\n            assert.strictEqual(foundAfter.docs.length, 0);\n\n\n            pouch.destroy();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"put->delete-put will find the previous document","suites":["BUGS: pouchdb"],"updatePoint":{"line":498,"column":59},"line":498,"code":"        it('put->delete-put will find the previous document', async () => {\n            const pouch: PouchDBInstance = new PouchDB(\n                randomCouchString(10),\n                {\n                    adapter: 'memory'\n                }\n            ) as any;\n            const BULK_DOC_OPTIONS = {\n                new_edits: false\n            };\n\n            const docData: any = schemaObjects.human();\n            docData['_id'] = 'foobar1';\n            const ret = await pouch.put(docData);\n\n            await AsyncTestUtil.wait(100);\n\n            const docData2: any = clone(docData);\n            docData2._rev = ret.rev;\n            docData2._deleted = true;\n\n            await pouch.bulkDocs({\n                docs: [docData2]\n            }, BULK_DOC_OPTIONS);\n\n            await AsyncTestUtil.wait(100);\n\n            /**\n             * If this test ever throws, it means we can remove the hacky workarround in\n             * src/plugins/in-memory.js\n             * Where we add the emitFlag to 'doNotEmitSet'\n             */\n            await AsyncTestUtil.assertThrows(\n                async () => {\n                    const foundAfter2 = await pouch.find({\n                        selector: {}\n                    });\n                    assert.strictEqual(foundAfter2.docs.length, 0);\n                },\n                'AssertionError'\n            );\n\n            pouch.destroy();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"should handle writes before reads (first insert then find)","suites":["BUGS: pouchdb"],"updatePoint":{"line":542,"column":70},"line":542,"code":"        it('should handle writes before reads (first insert then find)', async () => {\n            const amount = 20;\n            const pouches: PouchDBInstance[] = [];\n            const results: any[] = [];\n\n            let t = 0;\n            while (t < amount) {\n                t++;\n                const pouch: PouchDBInstance = new PouchDB(\n                    randomCouchString(10), {\n                    adapter: 'memory'\n                }) as any;\n                pouches.push(pouch);\n\n                // do not await\n                pouch.put({\n                    _id: 'foobar',\n                    passportId: 'z3i7q29g4yr1',\n                    firstName: 'Edison',\n                    lastName: 'Keebler',\n                    age: 24\n                });\n                const res = await pouch.find({\n                    selector: {}\n                });\n                results.push(res);\n            }\n\n            results.forEach(res => {\n                assert.strictEqual(res.docs.length, 1);\n            });\n\n            pouches.forEach(pouch => pouch.destroy());\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"should handle writes before reads (first find then insert)","suites":["BUGS: pouchdb"],"updatePoint":{"line":576,"column":70},"line":576,"code":"        it('should handle writes before reads (first find then insert)', async () => {\n            const amount = 20;\n            const promises: Promise<any>[] = [];\n            const pouches: PouchDBInstance[] = [];\n\n            while (promises.length < amount) {\n                const pouch: PouchDBInstance = new PouchDB(\n                    randomCouchString(10), {\n                    adapter: 'memory'\n                }) as any;\n                pouches.push(pouch);\n\n                promises.push(pouch.find({\n                    selector: {}\n                }));\n                await pouch.put({\n                    _id: 'foobar',\n                    passportId: 'z3i7q29g4yr1',\n                    firstName: 'Edison',\n                    lastName: 'Keebler',\n                    age: 24\n                });\n            }\n\n            const results = await Promise.all(promises);\n\n            results.forEach(res => {\n                assert.strictEqual(res.docs.length, 1);\n            });\n            pouches.forEach(pouch => pouch.destroy());\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"re-saving an attachment fails in browsers","suites":["BUGS: pouchdb"],"updatePoint":{"line":607,"column":53},"line":607,"code":"        it('re-saving an attachment fails in browsers', async () => {\n            const pouch1: PouchDBInstance = new PouchDB(\n                randomCouchString(10),\n                {\n                    adapter: 'memory'\n                }\n            );\n\n            const text = 'lorem ipsum dolor';\n            const mimeType = 'text/plain';\n            const blobBuffer = blobBufferUtil.createBlobBuffer(text, {\n                type: mimeType\n            } as any);\n\n            // insert a document with attachment\n            const docId = 'foobar';\n            const attachmentId = 'myattachment';\n            const putRes = await pouch1.put({ _id: docId });\n            await pouch1.putAttachment(\n                docId,\n                attachmentId,\n                putRes.rev,\n                blobBuffer,\n                mimeType\n            );\n\n\n            const rawAttachmentData = await pouch1.getAttachment(docId, attachmentId);\n\n            const pouch2: PouchDBInstance = new PouchDB(\n                randomCouchString(10),\n                {\n                    adapter: 'memory'\n                }\n            );\n            await pouch2.bulkDocs([\n                {\n                    _attachments: {\n                        [attachmentId]: {\n                            content_type: 'text/plain',\n                            data: rawAttachmentData\n                        }\n                    },\n                    _rev: '2-7a51240884063593468f396a29db001f',\n                    _id: 'foobar2',\n                }\n            ], {\n                new_edits: false\n            });\n\n            pouch1.destroy();\n            pouch2.destroy();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"use in schema","suites":["Schema",".create()","positive"],"updatePoint":{"line":28,"column":33},"line":28,"code":"                it('use in schema', () => {\n                    const schema = createRxSchema(schemas.primaryHuman);\n                    assert.strictEqual(typeof schema.primaryPath, 'string');\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"throw if primary is also index","suites":["Schema",".create()","negative"],"updatePoint":{"line":34,"column":50},"line":34,"code":"                it('throw if primary is also index', () => {\n                    const schemaObj = clone(schemas.primaryHuman);\n                    schemaObj.indexes = [\n                        'passportId'\n                    ];\n                    assert.throws(() => createRxSchema(schemaObj), Error);\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"throw if primary is also unique","suites":["Schema",".create()","negative"],"updatePoint":{"line":41,"column":51},"line":41,"code":"                it('throw if primary is also unique', () => {\n                    const schemaObj: any = clone(schemas.primaryHuman);\n                    schemaObj.properties.passportId['unique'] = true;\n                    assert.throws(() => createRxSchema(schemaObj), Error);\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"throw if primary is no string","suites":["Schema",".create()","negative"],"updatePoint":{"line":46,"column":49},"line":46,"code":"                it('throw if primary is no string', () => {\n                    const schemaObj = clone(schemas.primaryHuman);\n                    schemaObj.properties.passportId.type = 'integer';\n                    assert.throws(() => createRxSchema(schemaObj), Error);\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"throw if primary is encrypted","suites":["Schema",".create()","negative"],"updatePoint":{"line":51,"column":49},"line":51,"code":"                it('throw if primary is encrypted', () => {\n                    const schemaObj = clone(schemas.primaryHuman);\n                    (schemaObj.properties.passportId as any).encrypted = true;\n                    assert.throws(() => createRxSchema(schemaObj), Error);\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"should validate the human","suites":["Schema",".validate()","positive"],"updatePoint":{"line":60,"column":45},"line":60,"code":"                it('should validate the human', () => {\n                    const schema = createRxSchema(schemas.primaryHuman);\n                    const obj = schemaObjects.simpleHuman();\n                    assert.ok(schema.validate(obj));\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"should not validate the human without primary","suites":["Schema",".validate()","negative"],"updatePoint":{"line":68,"column":65},"line":68,"code":"                it('should not validate the human without primary', () => {\n                    const schema = createRxSchema(schemas.primaryHuman);\n                    const obj = {\n                        firstName: randomCouchString(10),\n                        lastName: randomCouchString(10)\n                    };\n                    assert.throws(() => schema.validate(obj), Error);\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"should not validate with primary object","suites":["Schema",".validate()","negative"],"updatePoint":{"line":76,"column":59},"line":76,"code":"                it('should not validate with primary object', () => {\n                    const schema = createRxSchema(schemas.primaryHuman);\n                    const obj = {\n                        passportId: {},\n                        firstName: randomCouchString(10),\n                        lastName: randomCouchString(10)\n                    };\n                    assert.throws(() => schema.validate(obj), Error);\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"should insert a human","suites":["Collection",".insert()","positive"],"updatePoint":{"line":91,"column":41},"line":91,"code":"                it('should insert a human', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const obj = schemaObjects.simpleHuman();\n                    await c.insert(obj);\n                    const docInStorage = await c.storageInstance.findDocumentsById([obj.passportId], false);\n                    const first = getFromObjectOrThrow(docInStorage, obj.passportId);\n                    assert.strictEqual(obj.passportId, first.passportId);\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"throw on duplicate primary","suites":["Collection",".insert()","negative"],"updatePoint":{"line":102,"column":46},"line":102,"code":"                it('throw on duplicate primary', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const obj = schemaObjects.simpleHuman();\n                    await c.insert(obj);\n                    const obj2 = schemaObjects.simpleHuman();\n                    obj2.passportId = obj.passportId;\n                    await AsyncTestUtil.assertThrows(\n                        () => c.insert(obj2),\n                        'RxError',\n                        'conflict'\n                    );\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"do not allow primary==null","suites":["Collection",".insert()","negative"],"updatePoint":{"line":115,"column":46},"line":115,"code":"                it('do not allow primary==null', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const obj: any = schemaObjects.simpleHuman();\n                    obj.passportId = null;\n                    await AsyncTestUtil.assertThrows(\n                        () => c.insert(obj),\n                        'RxError',\n                        'not match'\n                    );\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"find the inserted doc","suites":["Collection",".find()","positive"],"updatePoint":{"line":130,"column":41},"line":130,"code":"                it('find the inserted doc', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const obj = schemaObjects.simpleHuman();\n                    await c.insert(obj);\n                    const docs = await c.find().exec();\n                    assert.strictEqual(docs.length, 1);\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"find by primary","suites":["Collection",".find()","positive"],"updatePoint":{"line":138,"column":35},"line":138,"code":"                it('find by primary', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const obj = schemaObjects.simpleHuman();\n                    await c.insert(obj);\n                    const docs = await c.find({\n                        selector: {\n                            passportId: obj.passportId\n                        }\n                    }).exec();\n                    assert.strictEqual(docs.length, 1);\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"sort by primary","suites":["Collection",".find()","positive"],"updatePoint":{"line":150,"column":35},"line":150,"code":"                it('sort by primary', async () => {\n                    const c = await humansCollection.createPrimary(5);\n                    const docsASC = await c.find().sort({\n                        passportId: 'asc'\n                    }).exec();\n                    const docsDESC = await c.find().sort({\n                        passportId: 'desc'\n                    }).exec();\n                    assert.strictEqual(docsASC.length, 5);\n                    assert.strictEqual(docsDESC.length, 5);\n                    assert.strictEqual(\n                        docsASC[0].firstName,\n                        (docsDESC.pop() as any).firstName\n                    );\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"find the doc","suites":["Collection",".findOne()","positive"],"updatePoint":{"line":171,"column":32},"line":171,"code":"                it('find the doc', async () => {\n                    const c = await humansCollection.createPrimary(6);\n                    const obj = schemaObjects.simpleHuman();\n                    await c.insert(obj);\n                    const doc = await c.findOne(obj.passportId).exec(true);\n                    assert.strictEqual(doc.primary, obj.passportId);\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"find nothing","suites":["Collection",".findOne()","positive"],"updatePoint":{"line":179,"column":32},"line":179,"code":"                it('find nothing', async () => {\n                    const c = await humansCollection.createPrimary(10);\n                    const doc = await c.findOne('foobar').exec();\n                    assert.strictEqual(doc, null);\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"find with more selectors","suites":["Collection",".findOne()","positive"],"updatePoint":{"line":185,"column":44},"line":185,"code":"                it('find with more selectors', async () => {\n                    const c = await humansCollection.createPrimary(6);\n                    const obj = schemaObjects.simpleHuman();\n                    obj.firstName = randomCouchString(10);\n                    await c.insert(obj);\n                    const doc = await c.findOne({\n                        selector: {\n                            firstName: obj.firstName\n                        }\n                    }).exec(true);\n                    assert.strictEqual(doc.primary, obj.passportId);\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"BUG: findOne().where(myPrimary)","suites":["Collection",".findOne()","positive"],"updatePoint":{"line":198,"column":51},"line":198,"code":"                it('BUG: findOne().where(myPrimary)', async () => {\n                    const c = await humansCollection.createPrimary(1);\n                    const doc = await c.findOne().exec(true);\n                    const passportId = doc.passportId;\n                    assert.ok(passportId.length > 4);\n                    const doc2 = await c.findOne().where('passportId').eq(passportId).exec(true);\n                    assert.ok(isRxDocument(doc2));\n                    assert.strictEqual(doc.passportId, doc2.passportId);\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"get the primary value","suites":["Document",".get()","positive"],"updatePoint":{"line":215,"column":41},"line":215,"code":"                it('get the primary value', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const obj = schemaObjects.simpleHuman();\n                    await c.insert(obj);\n                    const doc = await c.findOne().exec(true);\n                    assert.strictEqual(obj.passportId, doc.get('passportId'));\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"save an edited doc with a primary","suites":["Document",".save()","positive"],"updatePoint":{"line":228,"column":53},"line":228,"code":"                it('save an edited doc with a primary', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const obj = schemaObjects.simpleHuman();\n                    await c.insert(obj);\n                    const doc = await c.findOne().exec(true);\n                    await doc.atomicPatch({ firstName: 'foobar' });\n                    const doc2 = await c.findOne().exec(true);\n\n                    assert.strictEqual(doc2.get('firstName'), 'foobar');\n                    assert.strictEqual(doc.get('passportId'), doc2.get('passportId'));\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"subscribe to one field","suites":["Document",".subscribe()","positive"],"updatePoint":{"line":245,"column":42},"line":245,"code":"                it('subscribe to one field', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const obj = schemaObjects.simpleHuman();\n                    await c.insert(obj);\n                    const doc = await c.findOne().exec(true);\n                    let value;\n                    const sub = doc.get$('firstName').subscribe((newVal: any) => value = newVal);\n                    await doc.atomicPatch({ firstName: 'foobar' });\n                    await promiseWait(10);\n                    assert.strictEqual(value, 'foobar');\n                    sub.unsubscribe();\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"subscribe to query","suites":["Document",".subscribe()","positive"],"updatePoint":{"line":258,"column":38},"line":258,"code":"                it('subscribe to query', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    let docs: any[];\n                    const sub = c.find().$.subscribe(newDocs => {\n                        docs = newDocs;\n                    });\n                    await AsyncTestUtil.waitUntil(() => !!docs);\n                    await c.insert(schemaObjects.simpleHuman());\n                    await AsyncTestUtil.waitUntil(() => {\n                        if (docs) {\n                            if (docs.length === 1) {\n                                return true;\n                            }\n                            if (docs.length > 1) {\n                                throw new Error('too many documents');\n                            }\n                        }\n                        return false;\n                    });\n                    sub.unsubscribe();\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"get event on db2 when db1 fires","suites":["Document",".subscribe()","positive"],"updatePoint":{"line":280,"column":51},"line":280,"code":"                it('get event on db2 when db1 fires', async () => {\n                    if (!config.storage.hasMultiInstance) {\n                        return;\n                    }\n                    const name = randomCouchString(10);\n                    const c1 = await humansCollection.createPrimary(0, name);\n                    const c2 = await humansCollection.createPrimary(0, name);\n                    let docs: any[] = [];\n                    c2.find().$.subscribe(newDocs => {\n                        docs = newDocs;\n                    });\n                    await promiseWait(50);\n                    await c1.insert(schemaObjects.simpleHuman());\n                    await promiseWait(1000);\n                    await AsyncTestUtil.waitUntil(() => {\n                        if (docs.length > 1) {\n                            throw new Error('got too much documents');\n                        }\n                        return docs.length === 1\n                    });\n\n                    c1.database.destroy();\n                    c2.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"get new field-value when other db changes","suites":["Document",".subscribe()","positive"],"updatePoint":{"line":304,"column":61},"line":304,"code":"                it('get new field-value when other db changes', async () => {\n                    if (!config.storage.hasMultiInstance) {\n                        return;\n                    }\n                    const name = randomCouchString(10);\n                    const c1 = await humansCollection.createPrimary(0, name);\n                    const c2 = await humansCollection.createPrimary(0, name);\n                    const obj = schemaObjects.simpleHuman();\n\n                    await c1.insert(obj);\n                    const doc = await c1.findOne().exec(true);\n\n                    let value: any;\n                    let count = 0;\n                    const pW8 = AsyncTestUtil.waitResolveable(1000);\n                    (doc as any).firstName$.subscribe((newVal: any) => {\n                        value = newVal;\n                        count++;\n                        if (count >= 2) pW8.resolve();\n                    });\n                    const doc2 = await c2.findOne().exec(true);\n                    await doc2.atomicPatch({ firstName: 'foobar' });\n                    await pW8.promise;\n                    await AsyncTestUtil.waitUntil(() => value === 'foobar');\n                    assert.strictEqual(count, 2);\n                    c1.database.destroy();\n                    c2.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"should not throw when creating a collection with composite primary","suites":["Composite Primary"],"updatePoint":{"line":350,"column":78},"line":350,"code":"        it('should not throw when creating a collection with composite primary', async () => {\n            const col = await getCompositePrimaryCollection();\n            assert.ok(col);\n            col.database.destroy();\n        });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"insert/update/delete a document","suites":["Composite Primary"],"updatePoint":{"line":355,"column":43},"line":355,"code":"        it('insert/update/delete a document', async () => {\n            const col = await getCompositePrimaryCollection();\n            assert.ok(col);\n\n            // insert\n            const doc = await col.insert(humanWithCompositePrimary());\n\n            // update\n            await doc.atomicPatch({ lastName: 'alice' });\n\n            // remove\n            await doc.remove();\n\n\n            col.database.destroy();\n        });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":".atomicUpsert()","suites":["Composite Primary"],"updatePoint":{"line":371,"column":27},"line":371,"code":"        it('.atomicUpsert()', async () => {\n            const col = await getCompositePrimaryCollection();\n            assert.ok(col);\n\n            const data = humanWithCompositePrimary();\n\n            await col.atomicUpsert(data);\n            await col.atomicUpsert(data);\n\n            col.database.destroy();\n        });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":".upsert()","suites":["Composite Primary"],"updatePoint":{"line":382,"column":21},"line":382,"code":"        it('.upsert()', async () => {\n            const col = await getCompositePrimaryCollection();\n            assert.ok(col);\n\n            const data = humanWithCompositePrimary();\n\n            await col.upsert(data);\n            await col.upsert(data);\n\n            col.database.destroy();\n        });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"should throw when a primary related field is changed","suites":["Composite Primary"],"updatePoint":{"line":393,"column":64},"line":393,"code":"        it('should throw when a primary related field is changed', async () => {\n            const col = await getCompositePrimaryCollection();\n            const doc = await col.insert(humanWithCompositePrimary());\n\n            await AsyncTestUtil.assertThrows(\n                () => doc.atomicPatch({ firstName: 'foobar' }),\n                'RxError',\n                'final fields'\n            );\n\n            col.database.destroy();\n        });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"find via composite primary","suites":["Composite Primary"],"updatePoint":{"line":405,"column":38},"line":405,"code":"        it('find via composite primary', async () => {\n            const col = await getCompositePrimaryCollection();\n            assert.ok(col);\n\n            // insert\n            const insertData = humanWithCompositePrimary();\n            const doc = await col.insert(insertData);\n\n            // find\n            const id = col.schema.getPrimaryOfDocumentData({\n                firstName: insertData.firstName,\n                info: {\n                    age: insertData.info.age\n                }\n            });\n\n            const found = await col.findOne(id).exec(true);\n            assert.ok(found === doc);\n\n            col.database.destroy();\n        });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"#3546 Compound primary key migration throws \"Value of primary key(s) cannot be changed\"","suites":["issues"],"updatePoint":{"line":428,"column":99},"line":428,"code":"        it('#3546 Compound primary key migration throws \"Value of primary key(s) cannot be changed\"', async () => {\n            // create a schema\n            const getSchema = (version: number) => {\n                const ret: RxJsonSchema<any> = {\n                    version,\n                    primaryKey: {\n                        key: 'id',\n                        fields: ['b_firstName', 'a_lastName'],\n                        separator: '|',\n                    },\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 200\n                        },\n                        passportId: {\n                            type: 'string',\n                        },\n                        b_firstName: {\n                            type: 'string',\n                        },\n                        a_lastName: {\n                            type: 'string',\n                        },\n                        age: {\n                            type: 'integer',\n                            minimum: 0,\n                            maximum: 150,\n                        }\n                    }\n                };\n                return ret;\n            };\n\n            // generate a random database-name\n            const name = randomCouchString(10);\n\n            // create a database\n            const db = await createRxDatabase({\n                name,\n                storage: getRxStoragePouch('memory'),\n                eventReduce: true,\n                ignoreDuplicate: true,\n            });\n            const collections = await db.addCollections({\n                mycollection: {\n                    schema: getSchema(0),\n                },\n            });\n\n            await collections.mycollection.insert({\n                passportId: 'foobar',\n                b_firstName: 'Bob',\n                a_lastName: 'Kelso',\n                age: 56,\n            });\n\n            const dbInOtherTab = await createRxDatabase({\n                name,\n                storage: getRxStoragePouch('memory'),\n                eventReduce: true,\n                ignoreDuplicate: true,\n            });\n            const collectionInOtherTab = await dbInOtherTab.addCollections({\n                mycollection: {\n                    schema: getSchema(1),\n                    migrationStrategies: {\n                        1: (oldDoc) => oldDoc,\n                    },\n                },\n            });\n\n            // find document after migration\n            await collectionInOtherTab.mycollection\n                .findOne()\n                .where('b_firstName')\n                .eq('Bob')\n                .exec(true);\n\n\n            db.destroy();\n            dbInOtherTab.destroy();\n        });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"#3562 _id must be allowed as primaryKey","suites":["issues"],"updatePoint":{"line":512,"column":51},"line":512,"code":"        it('#3562 _id must be allowed as primaryKey', async () => {\n            const mySchema: RxJsonSchema<any> = {\n                version: 0,\n                primaryKey: '_id',\n                type: 'object',\n                properties: {\n                    _id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    firstName: {\n                        type: 'string'\n                    }\n                }\n            };\n\n            // generate a random database-name\n            const name = randomCouchString(10);\n\n            // create a database\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                eventReduce: true,\n                ignoreDuplicate: true\n            });\n            await db.addCollections({\n                mycollection: {\n                    schema: mySchema\n                }\n            });\n            const collection = db.mycollection;\n            await collection.insert({\n                _id: 'foobar',\n                firstName: 'Alice'\n            });\n            db.destroy();\n        });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"should make a basic roundtrip","suites":["NoSqlQueryBuilder"],"updatePoint":{"line":19,"column":41},"line":19,"code":"        it('should make a basic roundtrip', () => {\n            const startQuery: MangoQuery = {\n                selector: {\n                    age: {\n                        $gt: 4\n                    },\n                    name: {\n                        $ne: 'alice'\n                    }\n                },\n                sort: [{ name: 'asc' }, { lastname: 'desc' }],\n                skip: 3,\n                limit: 2\n            };\n\n            // check initial json\n            const builder: NoSqlQueryBuilder = createQueryBuilder(startQuery);\n            const initialJson = builder.toJSON();\n            assert.deepStrictEqual(startQuery, initialJson.query);\n\n            // check builded json\n            const builder2 = createQueryBuilder();\n            builder2\n                .where('age').gt(4)\n                .where('name').ne('alice')\n                .skip(startQuery.skip as number)\n                .limit(startQuery.limit as number)\n                .sort({ name: 'asc', lastname: 'desc' });\n            const buildedJson = builder2.toJSON();\n            assert.deepStrictEqual(startQuery, buildedJson.query);\n        });","file":"unit/query-builder.test.ts","skipped":false,"dir":"test"},{"name":"should work with only the selector","suites":["NoSqlQueryBuilder"],"updatePoint":{"line":50,"column":46},"line":50,"code":"        it('should work with only the selector', () => {\n            const startQuery: MangoQuery = {\n                selector: {\n                    age: {\n                        $gt: 5\n                    },\n                    name: {\n                        $ne: 'alice'\n                    }\n                }\n            };\n            // check initial json\n            const builder: NoSqlQueryBuilder = createQueryBuilder(startQuery);\n            const initialJson = builder.toJSON();\n            assert.deepStrictEqual(startQuery, initialJson.query);\n\n            // check builded json\n            const builder2 = createQueryBuilder();\n            builder2\n                .where('age').gt(5)\n                .where('name').ne('alice');\n            const buildedJson = builder2.toJSON();\n            assert.deepStrictEqual(startQuery, buildedJson.query);\n        });","file":"unit/query-builder.test.ts","skipped":false,"dir":"test"},{"name":"should have path","suites":["NoSqlQueryBuilder"],"updatePoint":{"line":74,"column":28},"line":74,"code":"        it('should have path', () => {\n            const path = 'foobar';\n            const builder2 = createQueryBuilder();\n            builder2\n                .where('age').gt(6)\n                .where('name').ne('alice')\n                .where(path);\n            const buildedJson = builder2.toJSON();\n            assert.strictEqual(buildedJson.path, path);\n        });","file":"unit/query-builder.test.ts","skipped":false,"dir":"test"},{"name":"should work with big equal number","suites":["NoSqlQueryBuilder"],"updatePoint":{"line":84,"column":45},"line":84,"code":"        it('should work with big equal number', () => {\n            const startQuery: MangoQuery = {\n                selector: {\n                    age: {\n                        $gt: -9999999999999999999999999999\n                    }\n                },\n                sort: [{ age: 'asc' }]\n            };\n            // check initial json\n            const builder: NoSqlQueryBuilder = createQueryBuilder(startQuery);\n            const initialJson = builder.toJSON();\n            assert.deepStrictEqual(startQuery, initialJson.query);\n\n            // check builded json\n            const builder2 = createQueryBuilder();\n            builder2\n                .where('age')\n                .gt(-9999999999999999999999999999)\n                .sort('age');\n            const buildedJson = builder2.toJSON();\n            assert.deepStrictEqual(startQuery, buildedJson.query);\n        });","file":"unit/query-builder.test.ts","skipped":false,"dir":"test"},{"name":"should get a valid event on insert","suites":[".insert()","positive"],"updatePoint":{"line":28,"column":50},"line":28,"code":"            it('should get a valid event on insert', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const colName = 'foobar';\n                const cols = await db.addCollections({\n                    [colName]: {\n                        schema: schemas.human\n                    }\n                });\n                const c = cols[colName];\n\n                c.insert(schemaObjects.human());\n                const changeEvent: RxChangeEvent<HumanDocumentType> = await c.$.pipe(first()).toPromise() as any;\n                assert.strictEqual(changeEvent.collectionName, colName);\n                assert.strictEqual(typeof changeEvent.documentId, 'string');\n                assert.ok(changeEvent.documentData);\n                db.destroy();\n            });","file":"unit/reactive-collection.test.ts","skipped":false,"dir":"test"},{"name":"should get no event on non-succes-insert","suites":[".insert()","negative"],"updatePoint":{"line":50,"column":56},"line":50,"code":"            it('should get no event on non-succes-insert', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const cols = await db.addCollections({\n                    foobar: {\n                        schema: schemas.human\n                    }\n                });\n                const c = cols.foobar;\n\n                let calls = 0;\n                const sub = db.$.subscribe(() => {\n                    calls++;\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => c.insert({\n                        foo: 'baar'\n                    }),\n                    'RxError',\n                    'schema'\n                );\n                assert.strictEqual(calls, 0);\n                sub.unsubscribe();\n                db.destroy();\n            });","file":"unit/reactive-collection.test.ts","skipped":false,"dir":"test"},{"name":"should fire on bulk insert","suites":[".bulkInsert()","positive"],"updatePoint":{"line":81,"column":42},"line":81,"code":"            it('should fire on bulk insert', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const collections = await db.addCollections({\n                    human: {\n                        schema: schemas.primaryHuman\n                    }\n                });\n                const collection = collections.human;\n\n                const emittedCollection: RxChangeEvent<HumanDocumentType>[] = [];\n                const colSub = collection.insert$.subscribe((ce) => {\n                    emittedCollection.push(ce);\n                });\n\n                const docs = new Array(1).fill(0).map(() => schemaObjects.human());\n\n                await collection.bulkInsert(docs);\n\n                const changeEvent = emittedCollection[0];\n                assert.strictEqual(changeEvent.operation, 'INSERT');\n                assert.strictEqual(changeEvent.collectionName, 'human');\n                assert.strictEqual(changeEvent.documentId, docs[0].passportId);\n                assert.ok(changeEvent.documentData);\n\n                colSub.unsubscribe();\n                db.destroy();\n            });","file":"unit/reactive-collection.test.ts","skipped":false,"dir":"test"},{"name":"should fire on bulk remove","suites":[".bulkRemove()","positive"],"updatePoint":{"line":115,"column":42},"line":115,"code":"            it('should fire on bulk remove', async () => {\n                const c = await humansCollection.create(10);\n\n                const emittedCollection: RxChangeEvent<HumanDocumentType>[] = [];\n                const colSub = c.remove$.subscribe((ce) => {\n                    emittedCollection.push(ce);\n                });\n\n                const docList = await c.find().exec();\n                const primaryList = docList.map(doc => doc.primary);\n\n                await c.bulkRemove(primaryList);\n\n                const changeEvent = emittedCollection[0];\n\n                assert.strictEqual(changeEvent.operation, 'DELETE');\n                assert.strictEqual(changeEvent.collectionName, 'human');\n                assert.strictEqual(changeEvent.documentId, docList[0].primary);\n                assert.ok(!changeEvent.documentData);\n                assert.ok(changeEvent.previousDocumentData);\n\n                colSub.unsubscribe();\n                c.database.destroy();\n            });","file":"unit/reactive-collection.test.ts","skipped":false,"dir":"test"},{"name":"should fire on remove","suites":[".remove()","positive"],"updatePoint":{"line":143,"column":37},"line":143,"code":"            it('should fire on remove', async () => {\n                const c = await humansCollection.create(0);\n                const q = c.find();\n                const ar: any[] = [];\n                const sub = q.$\n                    .subscribe(docs => {\n                        ar.push(docs);\n                    });\n\n                // nothing is fired until no results\n                assert.strictEqual(ar.length, 0);\n\n                // empty array since no documents\n                await AsyncTestUtil.waitUntil(() => ar.length === 1);\n\n                assert.deepStrictEqual(ar[0], []);\n\n                await c.insert(schemaObjects.human());\n                await AsyncTestUtil.waitUntil(() => ar.length === 2);\n\n                const doc: any = await c.findOne().exec();\n                await doc.remove();\n                await AsyncTestUtil.waitUntil(() => ar.length === 3);\n                sub.unsubscribe();\n\n                c.database.destroy();\n            });","file":"unit/reactive-collection.test.ts","skipped":false,"dir":"test"},{"name":"should only emit inserts","suites":[".insert$"],"updatePoint":{"line":173,"column":36},"line":173,"code":"        it('should only emit inserts', async () => {\n            const c = await humansCollection.create(0);\n\n            const emitted: RxChangeEvent<HumanDocumentType>[] = [];\n            c.insert$.subscribe(cE => emitted.push(cE as any));\n\n            await c.insert(schemaObjects.human());\n            const doc = await c.insert(schemaObjects.human());\n            await c.insert(schemaObjects.human());\n            await doc.remove();\n\n            await c.insert(schemaObjects.human());\n\n            await AsyncTestUtil.waitUntil(() => {\n                return emitted.length === 4;\n            });\n            emitted.forEach(cE => assert.strictEqual(cE.operation, 'INSERT'));\n            c.database.destroy();\n        });","file":"unit/reactive-collection.test.ts","skipped":false,"dir":"test"},{"name":"should only emit updates","suites":[".update$"],"updatePoint":{"line":194,"column":36},"line":194,"code":"        it('should only emit updates', async () => {\n            const c = await humansCollection.create(0);\n\n            const emitted: RxChangeEvent<HumanDocumentType>[] = [];\n            c.update$.subscribe(cE => emitted.push(cE as any));\n\n            const doc1 = await c.insert(schemaObjects.human());\n            const doc2 = await c.insert(schemaObjects.human());\n            const doc3 = await c.insert(schemaObjects.human());\n            await c.insert(schemaObjects.human());\n            await doc3.remove();\n\n            await doc1.atomicPatch({ firstName: 'foobar1' });\n            await doc2.atomicPatch({ firstName: 'foobar2' });\n\n            await AsyncTestUtil.waitUntil(() => emitted.length === 2);\n            emitted.forEach(cE => assert.strictEqual(cE.operation, 'UPDATE'));\n            c.database.destroy();\n        });","file":"unit/reactive-collection.test.ts","skipped":false,"dir":"test"},{"name":"should only emit removes","suites":[".remove$"],"updatePoint":{"line":215,"column":36},"line":215,"code":"        it('should only emit removes', async () => {\n            const c = await humansCollection.create(0);\n\n            const emitted: RxChangeEvent<HumanDocumentType>[] = [];\n            c.remove$.subscribe(cE => emitted.push(cE as any));\n            await c.insert(schemaObjects.human());\n            const doc1 = await c.insert(schemaObjects.human());\n            const doc2 = await c.insert(schemaObjects.human());\n            await doc1.remove();\n            await c.insert(schemaObjects.human());\n            await doc2.remove();\n\n\n            await AsyncTestUtil.waitUntil(() => emitted.length === 2);\n            emitted.forEach(cE => assert.strictEqual(cE.operation, 'DELETE'));\n            c.database.destroy();\n        });","file":"unit/reactive-collection.test.ts","skipped":false,"dir":"test"},{"name":"should fire on save","suites":[".save()","positive"],"updatePoint":{"line":34,"column":35},"line":34,"code":"            it('should fire on save', async () => {\n                const c = await humansCollection.create(1);\n                const doc = await c.findOne().exec(true);\n\n                const oldName = doc.firstName;\n                const newName = randomCouchString(8);\n\n                const emittedCollection: RxChangeEvent<HumanDocumentType>[] = [];\n                const colSub = c.$.subscribe(cE => {\n                    emittedCollection.push(cE);\n                });\n\n                await doc.atomicPatch({ firstName: newName });\n                await AsyncTestUtil.waitUntil(() => {\n                    const count = emittedCollection.length;\n                    if (count > 1) {\n                        throw new Error('too many events');\n                    } else {\n                        return emittedCollection.length === 1;\n                    }\n                });\n                const docDataAfter = await doc.$.pipe(first()).toPromise();\n                const changeEvent: any = emittedCollection[0];\n                assert.strictEqual(changeEvent.documentData.firstName, newName);\n                assert.strictEqual(changeEvent.previousDocumentData.firstName, oldName);\n\n\n                assert.strictEqual(docDataAfter.passportId, doc.primary);\n                assert.strictEqual(docDataAfter.passportId, doc.primary);\n                colSub.unsubscribe();\n                c.database.destroy();\n            });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"should observe a single field","suites":[".save()","positive"],"updatePoint":{"line":66,"column":45},"line":66,"code":"            it('should observe a single field', async () => {\n                const c = await humansCollection.create();\n                const doc: any = await c.findOne().exec();\n                const valueObj = {\n                    v: doc.get('firstName')\n                };\n                doc.get$('firstName').subscribe((newVal: any) => {\n                    valueObj.v = newVal;\n                });\n                const setName = randomCouchString(10);\n                await doc.atomicPatch({ firstName: setName });\n                await promiseWait(5);\n                assert.strictEqual(valueObj.v, setName);\n                c.database.destroy();\n            });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"should observe a nested field","suites":[".save()","positive"],"updatePoint":{"line":81,"column":45},"line":81,"code":"            it('should observe a nested field', async () => {\n                const c = await humansCollection.createNested();\n                const doc = await c.findOne().exec(true);\n                const valueObj = {\n                    v: doc.get('mainSkill.name')\n                };\n                doc.get$('mainSkill.name').subscribe((newVal: any) => {\n                    valueObj.v = newVal;\n                });\n                const setName = randomCouchString(10);\n                await doc.atomicPatch({\n                    mainSkill: {\n                        name: setName,\n                        level: 10\n                    }\n                });\n                promiseWait(5);\n                assert.strictEqual(valueObj.v, setName);\n                c.database.destroy();\n            });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"get equal values when subscribing again later","suites":[".save()","positive"],"updatePoint":{"line":101,"column":61},"line":101,"code":"            it('get equal values when subscribing again later', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec();\n                let v1;\n                const sub = doc.get$('firstName').subscribe((newVal: any) => v1 = newVal);\n                await promiseWait(5);\n\n                await doc.atomicPatch({ firstName: 'foobar' });\n\n                let v2;\n                doc.get$('firstName').subscribe((newVal: any) => v2 = newVal);\n\n                assert.strictEqual(v1, v2);\n                assert.strictEqual(v1, 'foobar');\n                sub.unsubscribe();\n                c.database.destroy();\n            });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"cannot observe non-existend field","suites":[".save()","negative"],"updatePoint":{"line":120,"column":49},"line":120,"code":"            it('cannot observe non-existend field', async () => {\n                const c = await humansCollection.create();\n                const doc: any = await c.findOne().exec();\n                await AsyncTestUtil.assertThrows(\n                    () => doc.get$('foobar').subscribe((newVal: any) => newVal),\n                    'RxError',\n                    'observe'\n                );\n                c.database.destroy();\n            });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"deleted$ is true, on delete","suites":[".deleted$","positive"],"updatePoint":{"line":134,"column":43},"line":134,"code":"            it('deleted$ is true, on delete', async () => {\n                const c = await humansCollection.create();\n                const doc: any = await c.findOne().exec();\n                let deleted = null;\n                doc.deleted$.subscribe((v: any) => deleted = v);\n                promiseWait(5);\n                assert.deepStrictEqual(deleted, false);\n                await doc.remove();\n                promiseWait(5);\n                assert.deepStrictEqual(deleted, true);\n                c.database.destroy();\n            });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"primary cannot be observed","suites":[".get$()","negative"],"updatePoint":{"line":154,"column":42},"line":154,"code":"            it('primary cannot be observed', async () => {\n                const c = await humansCollection.createPrimary();\n                const doc = await c.findOne().exec(true);\n                await AsyncTestUtil.assertThrows(\n                    () => doc.get$('passportId'),\n                    'RxError',\n                    'primary path'\n                );\n                c.database.destroy();\n            });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"final fields cannot be observed","suites":[".get$()","negative"],"updatePoint":{"line":164,"column":47},"line":164,"code":"            it('final fields cannot be observed', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.humanFinal\n                    }\n                });\n                const col = cols.humans;\n                const docData = schemaObjects.human();\n                await col.insert(docData);\n                const doc = await col.findOne().exec();\n                await AsyncTestUtil.assertThrows(\n                    () => doc.get$('age'),\n                    'RxError',\n                    'final fields'\n                );\n                db.destroy();\n            });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"#3434 event data must not be mutateable","suites":["issues"],"updatePoint":{"line":188,"column":51},"line":188,"code":"        it('#3434 event data must not be mutateable', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n                eventReduce: true,\n                ignoreDuplicate: true\n            });\n            const collections = await db.addCollections({\n                mycollection: {\n                    schema: schemas.humanDefault\n                }\n            });\n            await collections.mycollection.insert({\n                passportId: 'foobar',\n                firstName: 'Bob',\n                lastName: 'Kelso',\n                age: 56\n            });\n\n            const person: RxDocument<HumanDocumentType> = await db.mycollection.findOne().exec();\n\n\n            let hasThrown = false;\n            person.$.subscribe(data => {\n                try {\n                    // mutating the document data is not allowed and should throw\n                    delete data['_rev'];\n                } catch (err) {\n                    hasThrown = true;\n                }\n            });\n\n            await person.atomicUpdate(state => {\n                state.age = 50;\n                return state\n            });\n\n            assert.strictEqual(person.age, 50);\n            assert.ok(hasThrown);\n\n            db.destroy();\n        });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"get results of array when .subscribe() and filled array later","suites":["positive"],"updatePoint":{"line":32,"column":73},"line":32,"code":"        it('get results of array when .subscribe() and filled array later', async () => {\n            const c = await humansCollection.create(1);\n            const query = c.find();\n            let lastValue: any = null;\n            let count = 0;\n            query.$.subscribe(newResults => {\n                count++;\n                lastValue = newResults;\n            });\n            await AsyncTestUtil.waitUntil(() => count === 1);\n            assert.ok(lastValue);\n            assert.strictEqual(lastValue.length, 1);\n            assert.strictEqual(count, 1);\n            c.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"get the updated docs on Collection.insert()","suites":["positive"],"updatePoint":{"line":47,"column":55},"line":47,"code":"        it('get the updated docs on Collection.insert()', async () => {\n            const c = await humansCollection.create(1);\n            const query = c.find();\n            let lastValue: any[] = [];\n            const emitted: any[] = [];\n            query.$.subscribe(newResults => {\n                lastValue = newResults;\n                emitted.push(newResults);\n            });\n            await waitUntil(() => emitted.length === 1);\n            assert.strictEqual(lastValue.length, 1);\n\n            const addHuman = schemaObjects.human();\n            const newPromiseWait = AsyncTestUtil.waitResolveable(500);\n            await c.insert(addHuman);\n            await newPromiseWait.promise;\n            assert.strictEqual(lastValue.length, 2);\n\n            let isHere = false;\n            lastValue.map(doc => {\n                if (doc.get('passportId') === addHuman.passportId)\n                    isHere = true;\n            });\n            assert.ok(isHere);\n            c.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"get the value twice when subscribing 2 times","suites":["positive"],"updatePoint":{"line":73,"column":56},"line":73,"code":"        it('get the value twice when subscribing 2 times', async () => {\n            const c = await humansCollection.create(1);\n            const query = c.find();\n            let lastValue: any[] = [];\n            query.$.subscribe(newResults => {\n                lastValue = newResults;\n            });\n            let lastValue2: any[] = [];\n            query.$.subscribe(newResults => {\n                lastValue2 = newResults;\n            });\n            await promiseWait(100);\n\n            await AsyncTestUtil.waitUntil(() => lastValue2 && lastValue2.length === 1);\n            assert.deepStrictEqual(lastValue, lastValue2);\n            c.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"get the base-value when subscribing again later","suites":["positive"],"updatePoint":{"line":90,"column":59},"line":90,"code":"        it('get the base-value when subscribing again later', async () => {\n            const c = await humansCollection.create(1);\n            const query = c.find();\n            let lastValue: any[] = [];\n            query.$.subscribe(newResults => {\n                lastValue = newResults;\n            });\n            await AsyncTestUtil.waitUntil(() => lastValue.length > 0);\n            let lastValue2: any[] = [];\n            query.$.subscribe(newResults => {\n                lastValue2 = newResults;\n            });\n            await AsyncTestUtil.waitUntil(() => lastValue2.length > 0);\n            await promiseWait(10);\n            assert.strictEqual(lastValue2.length, 1);\n            assert.deepStrictEqual(lastValue, lastValue2);\n            c.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"get new values on RxDocument.save","suites":["positive"],"updatePoint":{"line":108,"column":45},"line":108,"code":"        it('get new values on RxDocument.save', async () => {\n            const c = await humansCollection.create(1);\n            const doc: any = await c.findOne().exec(true);\n\n            let values: any;\n            const emitted: any[] = [];\n            const querySub = c.find({\n                selector: {\n                    firstName: doc.get('firstName')\n                }\n            }).$.subscribe(newV => {\n                values = newV;\n                if (newV) {\n                    emitted.push(newV);\n                }\n            });\n            await waitUntil(() => emitted.length === 1);\n            assert.strictEqual(values.length, 1);\n\n            // change doc so query does not match\n            const newPromiseWait = AsyncTestUtil.waitResolveable(500);\n            await doc.atomicPatch({ firstName: 'foobar' });\n            await newPromiseWait.promise;\n            assert.strictEqual(values.length, 0);\n            querySub.unsubscribe();\n            c.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"subscribing many times should not result in many database-requests","suites":["positive"],"updatePoint":{"line":135,"column":78},"line":135,"code":"        it('subscribing many times should not result in many database-requests', async () => {\n            const c = await humansCollection.create(1);\n            const query = c.find({\n                selector: {\n                    passportId: {\n                        $ne: 'foobar'\n                    }\n                }\n            });\n            await query.exec();\n            const countBefore = query._execOverDatabaseCount;\n            await Promise.all(\n                new Array(10).fill(0).map(() => {\n                    return query.$.pipe(first()).toPromise();\n                })\n            );\n            const countAfter = query._execOverDatabaseCount;\n\n            assert.strictEqual(countBefore, countAfter);\n\n            c.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"get no change when nothing happens","suites":["negative"],"updatePoint":{"line":159,"column":46},"line":159,"code":"        it('get no change when nothing happens', async () => {\n            const c = await humansCollection.create(1);\n            const query = c.find();\n            let received = 0;\n            const querySub = query.$.subscribe(() => {\n                received++;\n            });\n            await AsyncTestUtil.waitUntil(() => received === 1);\n            querySub.unsubscribe();\n            c.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"ISSUE: should have the document in DocCache when getting it from observe","suites":["ISSUES"],"updatePoint":{"line":233,"column":84},"line":233,"code":"        it('ISSUE: should have the document in DocCache when getting it from observe', async () => {\n            if (!config.storage.hasMultiInstance) {\n                return;\n            }\n            const name = randomCouchString(10);\n            const c = await humansCollection.createPrimary(1, name);\n            const c2 = await humansCollection.createPrimary(0, name);\n            const doc = await c.findOne().exec(true);\n            const docId = doc.primary;\n\n            assert.deepStrictEqual(c2._docCache.get(docId), undefined);\n\n            const results = [];\n            const sub = c2.find().$.subscribe(docs => results.push(docs));\n            await AsyncTestUtil.waitUntil(() => results.length >= 1);\n\n            assert.strictEqual((c2._docCache.get(docId) as any).primary, docId);\n\n            sub.unsubscribe();\n            c.database.destroy();\n            c2.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"#136 : findOne(string).$ streams all documents (_id as primary)","suites":["ISSUES"],"updatePoint":{"line":255,"column":75},"line":255,"code":"        it('#136 : findOne(string).$ streams all documents (_id as primary)', async () => {\n            const subs = [];\n            const col = await humansCollection.create(3);\n            const docData = schemaObjects.human();\n            const doc: any = await col.insert(docData);\n            const _id = doc._id;\n            const streamed: any[] = [];\n            subs.push(\n                col.findOne(_id).$\n                    .pipe(\n                        filter(d => d !== null)\n                    )\n                    .subscribe(d => {\n                        streamed.push(d);\n                    })\n            );\n            await AsyncTestUtil.waitUntil(() => streamed.length === 1);\n            assert.ok(isRxDocument(streamed[0]));\n            assert.strictEqual(streamed[0]._id, _id);\n\n            const streamed2: any[] = [];\n            subs.push(\n                col.findOne().where('_id').eq(_id).$\n                    .pipe(\n                        filter(d => d !== null)\n                    )\n                    .subscribe(d => {\n                        streamed2.push(d);\n                    })\n            );\n            await AsyncTestUtil.waitUntil(() => streamed2.length === 1);\n            assert.strictEqual(streamed2.length, 1);\n            assert.ok(isRxDocument(streamed2[0]));\n            assert.strictEqual(streamed2[0]._id, _id);\n\n            subs.forEach(sub => sub.unsubscribe());\n            col.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"#138 : findOne().$ returns every doc if no id given","suites":["ISSUES"],"updatePoint":{"line":293,"column":63},"line":293,"code":"        it('#138 : findOne().$ returns every doc if no id given', async () => {\n            const col = await humansCollection.create(3);\n            const streamed: any[] = [];\n            const sub = col.findOne().$\n                .pipe(\n                    filter(doc => doc !== null)\n                )\n                .subscribe(doc => {\n                    streamed.push(doc);\n                });\n            await AsyncTestUtil.waitUntil(() => streamed.length === 1);\n            assert.strictEqual(streamed.length, 1);\n            assert.ok(isRxDocument(streamed[0]));\n            sub.unsubscribe();\n            col.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"ISSUE emitted-order working when doing many atomicUpserts","suites":["ISSUES"],"updatePoint":{"line":309,"column":69},"line":309,"code":"        it('ISSUE emitted-order working when doing many atomicUpserts', async () => {\n            const crawlStateSchema = {\n                version: 0,\n                type: 'object',\n                primaryKey: 'key',\n                properties: {\n                    key: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    state: {\n                        type: 'object'\n                    }\n                },\n                required: ['state']\n            };\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: getRxStoragePouch('memory'),\n                ignoreDuplicate: true\n            });\n            await db.addCollections({\n                crawlstate: {\n                    schema: crawlStateSchema\n                }\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: getRxStoragePouch('memory'),\n                ignoreDuplicate: true\n            });\n            await db2.addCollections({\n                crawlstate: {\n                    schema: crawlStateSchema\n                }\n            });\n\n            const emitted: any[] = [];\n            const sub = db.crawlstate\n                .findOne('registry').$\n                .pipe(\n                    filter(doc => doc !== null),\n                    map(doc => (doc as RxDocument).toJSON())\n                ).subscribe(data => emitted.push(data));\n\n            const emittedOwn = [];\n            const sub2 = db2.crawlstate\n                .findOne('registry').$\n                .pipe(\n                    filter(doc => doc !== null),\n                    map(doc => (doc as RxDocument).toJSON())\n                ).subscribe(data => emittedOwn.push(data));\n\n            const baseData = {\n                lastProvider: null,\n                providers: 0,\n                sync: false,\n                other: {}\n            };\n            let count = 0;\n            const getData = () => {\n                const d2 = clone(baseData);\n                d2.providers = count;\n                count++;\n                return d2;\n            };\n\n            await Promise.all(\n                new Array(5)\n                    .fill(0)\n                    .map(() => ({\n                        key: 'registry',\n                        state: getData()\n                    }))\n                    .map(data => {\n                        return db2.crawlstate.atomicUpsert(data);\n                    })\n            );\n\n            await AsyncTestUtil.waitUntil(() => emitted.length > 0);\n            await AsyncTestUtil.waitUntil(() => {\n                const lastEmitted = emitted[emitted.length - 1];\n                return lastEmitted.state.providers === 4;\n            }, 0, 300);\n\n            await Promise.all(\n                new Array(5)\n                    .fill(0)\n                    .map(() => ({\n                        key: 'registry',\n                        state: getData()\n                    }))\n                    .map(data => db2.crawlstate.atomicUpsert(data))\n            );\n\n            await AsyncTestUtil.waitUntil(() => {\n                if (!emitted.length) return false;\n                const lastEmitted = emitted[emitted.length - 1];\n                return lastEmitted.state.providers === 9;\n            });\n\n            // TODO this fails for unknown reasons on slow devices\n            // await AsyncTestUtil.waitUntil(() => emittedOwn.length === 10);\n\n            const last = emitted[emitted.length - 1];\n            assert.strictEqual(last.state.providers, 9);\n\n            // on own collection, all events should have propagated\n            // TODO this fails for unkonwn reason on slow device\n            // assert.strictEqual(emittedOwn.length, 10);\n\n            sub.unsubscribe();\n            sub2.unsubscribe();\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"#749 RxQuery subscription returns null as first result when ran immediately after another subscription or exec()","suites":["ISSUES"],"updatePoint":{"line":427,"column":125},"line":426,"code":"        it(\n            '#749 RxQuery subscription returns null as first result when ran immediately after another subscription or exec()',\n            async () => {\n                const name = randomCouchString(10);\n                const db = await createRxDatabase({\n                    name,\n                    storage: getRxStoragePouch('memory'),\n                    ignoreDuplicate: true\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: schemas.human\n                    }\n                });\n                const collection = collections.humans;\n\n                await collection.insert(schemaObjects.human());\n\n                const results: any[] = [];\n\n                const subs1 = collection.find().$.subscribe(x => {\n                    results.push(x);\n                    subs1.unsubscribe();\n                });\n\n                const subs2 = collection.find().$.subscribe(x => {\n                    results.push(x);\n                    subs2.unsubscribe();\n                });\n\n                // Let's try with a different query\n                collection\n                    .find()\n                    .sort('passportId')\n                    .exec()\n                    .then((x) => {\n                        results.push(x);\n                    });\n\n                const subs3 = collection\n                    .find()\n                    .sort('passportId')\n                    .$.subscribe(x => {\n                        results.push(x);\n                        subs3.unsubscribe();\n                    });\n\n                await AsyncTestUtil.waitUntil(() => results.length === 4);\n                results.forEach(res => {\n                    assert.strictEqual(res.length, 1);\n                });\n\n                db.destroy();\n            });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"spawn and reach a server","suites":["replication-couchdb.test.js","spawn-server.js"],"updatePoint":{"line":63,"column":36},"line":63,"code":"        it('spawn and reach a server', async () => {\n            const server = await SpawnServer.spawn();\n            let path = server.url.split('/');\n            path.pop();\n            path.pop();\n            path = path.join('/');\n            const res = await request(path);\n            const json = JSON.parse(res);\n            assert.strictEqual(typeof json.uuid, 'string');\n            server.close();\n        });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"spawn again","suites":["replication-couchdb.test.js","spawn-server.js"],"updatePoint":{"line":74,"column":23},"line":74,"code":"        it('spawn again', async () => {\n            const server = await SpawnServer.spawn();\n            let path = server.url.split('/');\n            path.pop();\n            path.pop();\n            path = path.join('/');\n            const res = await request(path);\n            const json = JSON.parse(res);\n            assert.strictEqual(typeof json.uuid, 'string');\n            server.close();\n        });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"sync two collections over server","suites":["replication-couchdb.test.js","positive"],"updatePoint":{"line":88,"column":48},"line":88,"code":"            it('sync two collections over server', async function () {\n                const server = await SpawnServer.spawn();\n                const c = await humansCollection.create(0);\n                const c2 = await humansCollection.create(0);\n\n                const pw8 = AsyncTestUtil.waitResolveable(1000);\n                c.storageInstance.internals.pouch.sync(server.url, {\n                    live: true\n                }).on('error', function (err: Error) {\n                    console.error('error:');\n                    console.log(JSON.stringify(err));\n                    throw err;\n                });\n                c2.storageInstance.internals.pouch.sync(server.url, {\n                    live: true\n                });\n                let count = 0;\n                c2.storageInstance.internals.pouch.changes({\n                    since: 'now',\n                    live: true,\n                    include_docs: true\n                }).on('change', () => {\n                    count++;\n                    if (count === 2) pw8.resolve();\n                });\n\n                const obj = schemaObjects.human();\n                const doc = await c.insert(obj);\n                await pw8.promise;\n\n                await AsyncTestUtil.waitUntil(async () => {\n                    const ds = await c2.find().exec();\n                    return ds.length === 1;\n                });\n                const docs = await c2.find().exec();\n                assert.strictEqual(docs.length, 1);\n\n                assert.strictEqual(docs[0].get('firstName'), obj.firstName);\n\n\n                /**\n                 * Also try a delete\n                 */\n                await doc.remove();\n\n\n                await wait(1000);\n                const ds = await c2.find({\n                    selector: {\n                        age: {\n                            $gt: 0\n                        }\n                    }\n                }).exec();\n                assert.strictEqual(ds.length, 0);\n\n\n                c.database.destroy();\n                c2.database.destroy();\n                server.close();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"Observable.fromEvent should fire on sync-change","suites":["replication-couchdb.test.js","positive"],"updatePoint":{"line":149,"column":63},"line":149,"code":"            it('Observable.fromEvent should fire on sync-change', async () => {\n                const server = await SpawnServer.spawn();\n                const c = await humansCollection.create(0, undefined, false);\n                const c2 = await humansCollection.create(0, undefined, false);\n                c.storageInstance.internals.pouch.sync(server.url, {\n                    live: true\n                });\n                c2.storageInstance.internals.pouch.sync(server.url, {\n                    live: true\n                });\n\n                const e1 = [];\n                const pouch$ =\n                    fromEvent(\n                        c.storageInstance.internals.pouch.changes({\n                            since: 'now',\n                            live: true,\n                            include_docs: true\n                        }), 'change')\n                        .pipe(\n                            map((ar: any) => ar[0]),\n                            filter(e => !e.id.startsWith('_'))\n                        ).subscribe(e => e1.push(e));\n                const e2 = [];\n                const pouch2$ =\n                    fromEvent(c2.storageInstance.internals.pouch.changes({\n                        since: 'now',\n                        live: true,\n                        include_docs: true\n                    }), 'change').pipe(\n                        map((ar: any) => ar[0]),\n                        filter(e => !e.id.startsWith('_'))\n                    ).subscribe(e => e2.push(e));\n\n                const obj = schemaObjects.human();\n                await c.insert(obj);\n\n                await AsyncTestUtil.waitUntil(() => e1.length === 1);\n                await AsyncTestUtil.waitUntil(() => e2.length === 1);\n                assert.strictEqual(e1.length, e2.length);\n\n                pouch$.unsubscribe();\n                pouch2$.unsubscribe();\n                c.database.destroy();\n                c2.database.destroy();\n                server.close();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"push-only-sync","suites":["replication-couchdb.test.js","sync-directions","positive"],"updatePoint":{"line":200,"column":30},"line":200,"code":"            it('push-only-sync', async () => {\n                const c = await humansCollection.create(10, undefined, false);\n                const c2 = await humansCollection.create(10, undefined, false);\n                const replicationState = c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false,\n                    direction: {\n                        pull: false,\n                        push: true\n                    }\n                });\n                assert.ok(isRxCollection(replicationState.collection));\n                await AsyncTestUtil.waitUntil(async () => {\n                    const docs = await c2.find().exec();\n                    return docs.length === 20;\n                });\n                await AsyncTestUtil.wait(10);\n                const nonSyncedDocs = await c.find().exec();\n                assert.strictEqual(nonSyncedDocs.length, 10);\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"pull-only-sync","suites":["replication-couchdb.test.js","sync-directions","positive"],"updatePoint":{"line":223,"column":30},"line":223,"code":"            it('pull-only-sync', async () => {\n                const c = await humansCollection.create(10, undefined, false);\n                const c2 = await humansCollection.create(10, undefined, false);\n                c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false,\n                    direction: {\n                        pull: true,\n                        push: false\n                    }\n                });\n                await AsyncTestUtil.waitUntil(async () => {\n                    const docs = await c.find().exec();\n                    return docs.length === 20;\n                });\n                await promiseWait(10);\n                const nonSyncedDocs = await c2.find().exec();\n                assert.strictEqual(nonSyncedDocs.length, 10);\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should not allow non-way-sync","suites":["replication-couchdb.test.js","sync-directions","negative"],"updatePoint":{"line":247,"column":45},"line":247,"code":"            it('should not allow non-way-sync', async () => {\n                const c = await humansCollection.create(0);\n                const c2 = await humansCollection.create(10, undefined, false);\n                await AsyncTestUtil.assertThrows(\n                    () => c.syncCouchDB({\n                        remote: c2,\n                        direction: {\n                            push: false,\n                            pull: false\n                        }\n                    }),\n                    'RxError',\n                    'direction'\n                );\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should only sync documents that match the query","suites":["replication-couchdb.test.js","query-based sync","positive"],"updatePoint":{"line":268,"column":63},"line":268,"code":"            it('should only sync documents that match the query', async () => {\n                const c = await humansCollection.create(0, undefined, false);\n                const c2 = await humansCollection.create(10, undefined, false);\n                const query = c.find().where('firstName').eq('foobar');\n\n                const matchingDoc = schemaObjects.human();\n                matchingDoc.firstName = 'foobar';\n                await c2.insert(matchingDoc);\n\n                c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false,\n                    query: query\n                });\n\n                await AsyncTestUtil.waitUntil(async () => {\n                    const ds = await c.find().exec();\n                    return ds.length === 1;\n                });\n                await promiseWait(10);\n                const docs = await c.find().exec();\n\n                assert.strictEqual(docs.length, 1);\n                assert.strictEqual(docs[0].firstName, 'foobar');\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should not allow queries from other collection","suites":["replication-couchdb.test.js","query-based sync","negative"],"updatePoint":{"line":298,"column":62},"line":298,"code":"            it('should not allow queries from other collection', async () => {\n                const c = await humansCollection.create(0, undefined, false);\n                const c2 = await humansCollection.create(10, undefined, false);\n                const otherCollection = await humansCollection.create(0, undefined, false);\n\n                const query = otherCollection.find().where('firstName').eq('foobar');\n                await AsyncTestUtil.assertThrows(\n                    () => c.syncCouchDB({\n                        remote: c2,\n                        query\n                    }),\n                    'RxError',\n                    'same'\n                );\n\n                c.database.destroy();\n                c2.database.destroy();\n                otherCollection.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should be able to get the event-emitter after some time","suites":["replication-couchdb.test.js","._pouchEventEmitterObject"],"updatePoint":{"line":321,"column":71},"line":321,"code":"            it('should be able to get the event-emitter after some time', async () => {\n                const c = await humansCollection.create(0);\n                const c2 = await humansCollection.create(10);\n                const repState = await c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false\n                });\n\n                await AsyncTestUtil.waitUntil(\n                    () => !!repState._pouchEventEmitterObject\n                );\n                const pouchEventEmitter: any = repState._pouchEventEmitterObject;\n                assert.ok(pouchEventEmitter);\n                assert.strictEqual(typeof pouchEventEmitter.on, 'function');\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should emit change-events","suites":["replication-couchdb.test.js","change$"],"updatePoint":{"line":341,"column":41},"line":341,"code":"            it('should emit change-events', async () => {\n                const c = await humansCollection.create(0);\n                const c2 = await humansCollection.create(10);\n                const repState = await c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false\n                });\n                const emited = [];\n                repState.change$.subscribe(cE => emited.push(cE));\n                await AsyncTestUtil.waitUntil(() => emited.length >= 1);\n                await c2.insert(schemaObjects.human());\n                await AsyncTestUtil.waitUntil(() => emited.length >= 2);\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should be active","suites":["replication-couchdb.test.js","active$"],"updatePoint":{"line":359,"column":32},"line":359,"code":"            it('should be active', async () => {\n                const c = await humansCollection.create();\n                const c2 = await humansCollection.create(10);\n                const repState = await c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false\n                });\n                const emited: any[] = [];\n                repState.active$.subscribe(cE => emited.push(cE));\n                await AsyncTestUtil.waitUntil(() => emited.pop() === true);\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should not be alive","suites":["replication-couchdb.test.js","alive$"],"updatePoint":{"line":375,"column":35},"line":375,"code":"            it('should not be alive', async () => {\n                const server = await SpawnServer.spawn();\n                server.close(true);\n                const c = await humansCollection.create(0);\n\n                const repState = c.syncCouchDB({\n                    remote: server.url\n                });\n\n                const emited: any[] = [];\n                repState.alive$.subscribe(cE => emited.push(cE));\n\n                assert.strictEqual(emited[emited.length - 1], false);\n\n                c.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should be alive and transit to not alive","suites":["replication-couchdb.test.js","alive$"],"updatePoint":{"line":391,"column":56},"line":391,"code":"            it('should be alive and transit to not alive', async () => {\n                const server = await SpawnServer.spawn();\n                const c = await humansCollection.create(0);\n\n                const repState = c.syncCouchDB({\n                    remote: server.url\n                });\n\n                const emited: any[] = [];\n                repState.alive$.subscribe(cE => emited.push(cE));\n                await AsyncTestUtil.waitUntil(() => !!emited[emited.length - 1]);\n\n                assert.strictEqual(emited[emited.length - 1], true);\n\n                server.close(true);\n                const obj = schemaObjects.human();\n                await c.insert(obj);\n\n                await AsyncTestUtil.waitUntil(() => !emited[emited.length - 1]);\n                assert.strictEqual(emited[emited.length - 1], false);\n\n                c.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should always be false on live-replication","suites":["replication-couchdb.test.js","complete$"],"updatePoint":{"line":416,"column":58},"line":416,"code":"            it('should always be false on live-replication', async () => {\n                const c = await humansCollection.create();\n                const c2 = await humansCollection.create(10);\n                const repState = await c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false\n                });\n                const beFalse = await repState.complete$.pipe(first()).toPromise();\n                assert.strictEqual(beFalse, false);\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should emit true on non-live-replication when done","suites":["replication-couchdb.test.js","complete$"],"updatePoint":{"line":429,"column":66},"line":429,"code":"            it('should emit true on non-live-replication when done', async () => {\n                const c = await humansCollection.create(10);\n                const c2 = await humansCollection.create(10);\n                const repState = await c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: true,\n                    direction: {\n                        pull: true,\n                        push: true\n                    },\n                    options: {\n                        live: false,\n                        retry: true\n                    }\n                });\n\n                const emited: any[] = [];\n                const sub = repState.complete$.subscribe(ev => emited.push(ev));\n                await AsyncTestUtil.waitUntil(() => {\n                    const lastEv = emited[emited.length - 1];\n                    let ret = false;\n                    try {\n                        if (\n                            lastEv.push.ok === true &&\n                            lastEv.pull.ok === true\n                        ) ret = true;\n                    } catch (e) { }\n                    return ret;\n                });\n                sub.unsubscribe();\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should emit one event per doc","suites":["replication-couchdb.test.js","docs$"],"updatePoint":{"line":465,"column":45},"line":465,"code":"            it('should emit one event per doc', async () => {\n                const c = await humansCollection.create(0);\n                const c2 = await humansCollection.create(10);\n                const repState = await c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false\n                });\n                const emitedDocs: any[] = [];\n                repState.docs$.subscribe(doc => emitedDocs.push(doc));\n\n                await AsyncTestUtil.waitUntil(() => emitedDocs.length === 10);\n                emitedDocs.forEach(doc => assert.ok(doc.firstName));\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should not emit","suites":["replication-couchdb.test.js","denied$"],"updatePoint":{"line":483,"column":31},"line":483,"code":"            it('should not emit', async () => {\n                const c = await humansCollection.create(0);\n                const c2 = await humansCollection.create(10);\n                const repState = await c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false\n                });\n                const emitted = [];\n                repState.denied$.subscribe(doc => emitted.push(doc));\n\n                await AsyncTestUtil.wait(100);\n                assert.strictEqual(emitted.length, 0);\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should have the full data when resolved","suites":["replication-couchdb.test.js",".awaitInitialReplication()"],"updatePoint":{"line":501,"column":55},"line":501,"code":"            it('should have the full data when resolved', async () => {\n                const c = await humansCollection.create(0);\n                const c2 = await humansCollection.create(10);\n                const repState = await c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false,\n                    options: {\n                        live: false\n                    }\n                });\n                await repState.awaitInitialReplication();\n                const docs = await c.find().exec();\n                assert.strictEqual(docs.length, 10);\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"collection: should get an event when a doc syncs","suites":["replication-couchdb.test.js","positive"],"updatePoint":{"line":522,"column":64},"line":522,"code":"            it('collection: should get an event when a doc syncs', async () => {\n                const syncC = await humansCollection.create(0);\n                const syncPouch = syncC;\n\n                const c = await humansCollection.create(0, 'colsource' + randomCouchString(5));\n                const c2 = await humansCollection.create(0, 'colsync' + randomCouchString(5));\n                c.syncCouchDB({\n                    remote: syncPouch\n                });\n                c2.syncCouchDB({\n                    remote: syncPouch\n                });\n\n                const pw8 = AsyncTestUtil.waitResolveable(1700);\n                const events: any[] = [];\n                c2.$.subscribe(e => {\n                    events.push(e);\n                    pw8.resolve();\n                });\n\n                const obj = schemaObjects.human();\n                await c.insert(obj);\n                await pw8.promise;\n                await AsyncTestUtil.waitUntil(() => {\n                    const amount = events.length;\n                    if (amount > 1) {\n                        throw new Error('too many events');\n                    }\n                    return amount === 1;\n                });\n                assert.ok(events[0]);\n\n                syncC.database.destroy();\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"query: should re-find when a docs syncs","suites":["replication-couchdb.test.js","positive"],"updatePoint":{"line":559,"column":55},"line":559,"code":"            it('query: should re-find when a docs syncs', async () => {\n                const syncC = await humansCollection.create(0);\n                const syncPouch = syncC;\n\n                const c = await humansCollection.create(0, 'colsource' + randomCouchString(5));\n                const c2 = await humansCollection.create(0, 'colsync' + randomCouchString(5));\n                c.syncCouchDB({\n                    remote: syncPouch\n                });\n                c2.syncCouchDB({\n                    remote: syncPouch\n                });\n\n                const pw8 = AsyncTestUtil.waitResolveable(10000);\n                const results = [];\n                c2.find().$.subscribe(res => {\n                    results.push(res);\n                    if (results.length === 2) pw8.resolve();\n                });\n                assert.strictEqual(results.length, 0);\n                await promiseWait(5);\n\n\n                const obj = schemaObjects.human();\n                await c.insert(obj);\n                await pw8.promise;\n\n                assert.strictEqual(results.length, 2);\n\n                syncC.database.destroy();\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"document: should change field when doc saves","suites":["replication-couchdb.test.js","positive"],"updatePoint":{"line":592,"column":60},"line":592,"code":"            it('document: should change field when doc saves', async () => {\n                const syncC = await humansCollection.create(0);\n                const syncPouch = syncC;\n\n                const c = await humansCollection.create(0, 'colsource' + randomCouchString(5));\n                const c2 = await humansCollection.create(0, 'colsync' + randomCouchString(5));\n                c.syncCouchDB({\n                    remote: syncPouch\n                });\n                c2.syncCouchDB({\n                    remote: syncPouch\n                });\n\n                // insert and w8 for sync\n                const pw8 = AsyncTestUtil.waitResolveable(1400);\n                let results = null;\n                c2.find().$.subscribe(res => {\n                    results = res;\n                    if (results && results.length > 0) pw8.resolve();\n                });\n\n                const obj = schemaObjects.human();\n                await c.insert(obj);\n                await pw8.promise;\n\n                const doc: any = await c.findOne().exec();\n                const doc2: any = await c2.findOne().exec();\n\n\n                const patchPromise = doc.atomicPatch({ firstName: 'foobar' });\n                await waitUntil(() => doc2.firstName === 'foobar');\n\n                await patchPromise;\n\n                assert.strictEqual(doc2.firstName, 'foobar');\n                assert.strictEqual(doc.firstName, 'foobar');\n\n                syncC.database.destroy();\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should get the correct event when an attachment is replicated","suites":["replication-couchdb.test.js","positive"],"updatePoint":{"line":633,"column":77},"line":633,"code":"            it('should get the correct event when an attachment is replicated', async () => {\n                const remoteCollection = await humansCollection.createAttachments(1);\n                const collection = await humansCollection.createAttachments(0, randomCouchString(5));\n                collection.syncCouchDB({\n                    remote: remoteCollection\n                });\n\n                const emitted: RxChangeEvent<HumanDocumentType>[] = [];\n                const sub = collection.$.subscribe(cE => {\n                    emitted.push(cE);\n                });\n\n                const doc = await remoteCollection.findOne().exec(true);\n                await doc.putAttachment({\n                    id: 'cat.txt',\n                    data: blobBufferUtil.createBlobBuffer('meow', 'text/plain'),\n                    type: 'text/plain'\n                });\n\n                await waitUntil(() => flattenEvents(emitted).length >= 1);\n                if (flattenEvents(emitted).length > 1) {\n                    throw new Error('too much events emitted');\n                }\n\n                const firstEvent = flattenEvents(emitted)[0];\n                if (!firstEvent || !firstEvent.documentData) {\n                    throw new Error('firstEvent event missing');\n                }\n                assert.strictEqual(\n                    firstEvent.documentData._attachments['cat.txt'].type,\n                    'text/plain'\n                );\n\n                sub.unsubscribe();\n                remoteCollection.database.destroy();\n                collection.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"#630 Query cache is not being invalidated by replication","suites":["replication-couchdb.test.js","ISSUES"],"updatePoint":{"line":674,"column":68},"line":674,"code":"        it('#630 Query cache is not being invalidated by replication', async () => {\n            // create a schema\n            const mySchema = {\n                version: 0,\n                primaryKey: 'passportId',\n                type: 'object',\n                properties: {\n                    passportId: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    firstName: {\n                        type: 'string'\n                    },\n                    lastName: {\n                        type: 'string'\n                    },\n                    age: {\n                        type: 'integer',\n                        minimum: 0,\n                        maximum: 150\n                    }\n                }\n            };\n\n            // create a database\n            const db1 = await createRxDatabase({\n                name: randomCouchString(12),\n                storage: getRxStoragePouch('memory'),\n            });\n            // create a collection\n            const collections1 = await db1.addCollections({\n                crawlstate: {\n                    schema: mySchema\n                }\n            });\n            const collection1 = collections1.crawlstate;\n\n            // insert a document\n            await collection1.insert({\n                passportId: 'foobar',\n                firstName: 'Bob',\n                lastName: 'Kelso',\n                age: 56\n            });\n\n            // create another database\n            const db2 = await createRxDatabase({\n                name: randomCouchString(12),\n                storage: getRxStoragePouch('memory'),\n            });\n            // create a collection\n            const collections2 = await db2.addCollections({\n                crawlstate: {\n                    schema: mySchema\n                }\n            });\n            const collection2 = collections2.crawlstate;\n\n            // query for all documents on db2-collection2 (query will be cached)\n            const documents = await collection2.find().exec();\n            assert.ok(documents);\n\n            // Replicate from db1-collection1 to db2-collection2\n            const pullstate: RxCouchDBReplicationState = collection2.syncCouchDB({\n                remote: collection1,\n                direction: {\n                    pull: true,\n                    push: false\n                },\n                options: {\n                    live: false\n                }\n            });\n\n            // Wait for replication to complete\n            await pullstate.complete$\n                .pipe(\n                    filter(completed => completed.ok === true),\n                    first()\n                ).toPromise();\n\n\n\n            await waitUntil(async () => {\n                // query for all documents on db2-collection2 again (result is read from cache which doesnt contain replicated doc)\n                // collection2._queryCache.destroy();\n                const newDocs = await collection2.find().exec();\n                return newDocs.length === 1;\n            });\n\n            // clean up afterwards\n            db1.destroy();\n            db2.destroy();\n        });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"#641 using a collections internal pouch for replication should be prevented","suites":["replication-couchdb.test.js","ISSUES"],"updatePoint":{"line":769,"column":87},"line":769,"code":"        it('#641 using a collections internal pouch for replication should be prevented', async () => {\n            const colA = await humansCollection.create(0);\n            const colB = await humansCollection.create(0);\n\n            await AsyncTestUtil.assertThrows(\n                () => colA.syncCouchDB({\n                    remote: colB.storageInstance.internals.pouch,\n                    direction: {\n                        pull: true,\n                        push: false\n                    },\n                    options: {\n                        live: false\n                    }\n                }),\n                'RxError',\n                'pouchdb as remote'\n            );\n\n            colA.database.destroy();\n            colB.database.destroy();\n        });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should auto-cancel non-live replications when completed to not cause memory leak","suites":["replication-couchdb.test.js","ISSUES"],"updatePoint":{"line":791,"column":92},"line":791,"code":"        it('should auto-cancel non-live replications when completed to not cause memory leak', async () => {\n            const collection = await humansCollection.create(10, randomCouchString(10), false);\n            const syncCollection = await humansCollection.create(0, randomCouchString(10), false);\n\n            const syncOptions: SyncOptions = {\n                remote: syncCollection,\n                direction: {\n                    pull: true,\n                    push: true\n                },\n                options: {\n                    live: false\n                }\n            };\n\n            const syncState = collection.syncCouchDB(syncOptions);\n            await syncState.awaitInitialReplication();\n\n            await waitUntil(() => syncState.canceled === true);\n\n            collection.database.destroy();\n            syncCollection.database.destroy();\n        });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"spawn, reach and close a server","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":136,"column":47},"line":136,"code":"            it('spawn, reach and close a server', async () => {\n                const server = await SpawnServer.spawn();\n                const res = await server.client.query(`{\n                 info\n            }`);\n                assert.strictEqual(res.data.info, 1);\n                server.close();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"server.setDocument()","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":144,"column":36},"line":144,"code":"            it('server.setDocument()', async () => {\n                const server = await SpawnServer.spawn<WithDeleted<HumanWithTimestampDocumentType>>();\n                const doc = getTestData(1).pop();\n                if (!doc) {\n                    throw new Error('missing doc');\n                }\n                const res = await server.setDocument(doc);\n                assert.strictEqual(res.data.setHumans.id, doc.id);\n                server.close();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should be able to use the ws-subscriptions","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":154,"column":58},"line":154,"code":"            it('should be able to use the ws-subscriptions', async () => {\n                const server = await SpawnServer.spawn();\n\n                const endpointUrl = 'ws://localhost:' + server.wsPort + '/subscriptions';\n                const client = new SubscriptionClient(\n                    endpointUrl,\n                    {\n                        reconnect: true,\n                    },\n                    ws\n                );\n\n                const query = `subscription onHumanChanged {\n                    humanChanged {\n                        id\n                    }\n                }`;\n\n                const ret = client.request({ query });\n                const emitted: any[] = [];\n                const emittedError = [];\n                ret.subscribe({\n                    next(data: any) {\n                        emitted.push(data);\n                    },\n                    error(error: any) {\n                        emittedError.push(error);\n                    }\n                });\n\n                // we have to wait here until the connection is established\n                await AsyncTestUtil.wait(300);\n\n                const doc = getTestData(1).pop();\n                await server.setDocument(doc);\n\n                await AsyncTestUtil.waitUntil(() => emitted.length === 1);\n                assert.ok(emitted[0].data.humanChanged.id);\n                assert.strictEqual(emittedError.length, 0);\n\n                server.close();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should pull all documents in one batch","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":198,"column":54},"line":198,"code":"            it('should pull all documents in one batch', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(getTestData(batchSize))\n                ]);\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    live: false,\n                    deletedFlag: 'deleted'\n                });\n                assert.strictEqual(replicationState.isStopped(), false);\n\n                await AsyncTestUtil.waitUntil(async () => {\n                    const docs = await c.find().exec();\n                    return docs.length === batchSize;\n                });\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should pull all documents in multiple batches","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":222,"column":61},"line":222,"code":"            it('should pull all documents in multiple batches', async () => {\n                const amount = batchSize * 4;\n                const testData = getTestData(amount);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(testData)\n                ]);\n\n                c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    live: false,\n                    deletedFlag: 'deleted'\n                });\n\n\n                await AsyncTestUtil.waitUntil(async () => {\n                    const ds = await c.find().exec();\n                    return ds.length === amount;\n                });\n\n                // all of test-data should be in the database\n                const docs = await c.find().exec();\n                const ids = docs.map((d: any) => d.primary);\n                const notInDb = testData.find(doc => !ids.includes(doc.id));\n                if (notInDb) throw new Error('not in db: ' + notInDb.id);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should pull documents from a custom dataPath if one is specified","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":255,"column":80},"line":255,"code":"            it('should pull documents from a custom dataPath if one is specified', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(getTestData(batchSize))\n                ]);\n\n                const collectionQueryBuilder = (doc: any) => {\n                    if (!doc) {\n                        doc = {\n                            id: '',\n                            updatedAt: 0\n                        };\n                    }\n\n                    const query = `query($lastId: String!, $updatedAt: Int!, $batchSize: Int!)\n                    {\n                        collectionFeedForRxDBReplication(lastId: $lastId, minUpdatedAt: $updatedAt, limit: $batchSize) {\n                            collection {\n                                id\n                                name\n                                age\n                                updatedAt\n                                deleted\n                            }\n                        }\n                    }`;\n\n                    const variables = {\n                        lastId: doc.id,\n                        updatedAt: doc.updatedAt,\n                        batchSize\n                    };\n\n                    return {\n                        query,\n                        variables\n                    };\n                };\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: collectionQueryBuilder,\n                        dataPath: 'data.collectionFeedForRxDBReplication.collection'\n                    },\n                    deletedFlag: 'deleted'\n                });\n                assert.strictEqual(replicationState.isStopped(), false);\n\n                await AsyncTestUtil.waitUntil(async () => {\n                    const docs = await c.find().exec();\n                    return docs.length === batchSize;\n                });\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should pull all documents when they have the same timestamp because they are also sorted by id","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":313,"column":110},"line":313,"code":"            it('should pull all documents when they have the same timestamp because they are also sorted by id', async () => {\n                const amount = batchSize * 2;\n                const testData = getTestData(amount);\n                const timestamp = getTimestamp();\n                testData.forEach(d => d.updatedAt = timestamp);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(testData)\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    live: false,\n                    deletedFlag: 'deleted'\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docsInDb = await c.find().exec();\n                assert.strictEqual(docsInDb.length, amount);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should handle deleted documents","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":341,"column":47},"line":341,"code":"            it('should handle deleted documents', async () => {\n                const doc: any = schemaObjects.humanWithTimestamp();\n                doc['deleted'] = true;\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn([doc])\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    deletedFlag: 'deleted'\n                });\n                await replicationState.awaitInitialReplication();\n                const docs = await c.find().exec();\n\n                assert.strictEqual(docs.length, 0);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should handle truthy deleted flag values","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":365,"column":56},"line":365,"code":"            it('should handle truthy deleted flag values', async () => {\n                const doc: any = schemaObjects.humanWithTimestamp();\n                doc['deletedAt'] = Math.floor(new Date().getTime() / 1000);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn([doc])\n                ]);\n\n                const deletedAtQueryBuilder = (doc: any) => {\n                    if (!doc) {\n                        doc = {\n                            id: '',\n                            updatedAt: 0\n                        };\n                    }\n\n                    const query = `query($lastId: String!, $updatedAt: Int!, $batchSize: Int!)\n                    {\n                        collectionFeedForRxDBReplication(lastId: $lastId, minUpdatedAt: $updatedAt, limit: $batchSize) {\n                            collection {\n                                id\n                                name\n                                age\n                                updatedAt\n                                deletedAt\n                            }\n                        }\n                    }`;\n\n                    const variables = {\n                        lastId: doc.id,\n                        updatedAt: doc.updatedAt,\n                        batchSize\n                    };\n\n                    return {\n                        query,\n                        variables\n                    };\n                }\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: deletedAtQueryBuilder,\n                        dataPath: 'data.collectionFeedForRxDBReplication.collection'\n                    },\n                    deletedFlag: 'deletedAt'\n                });\n                replicationState.error$.subscribe((err: any) => console.error('REPLICATION ERROR', err))\n                await replicationState.awaitInitialReplication();\n                const docs = await c.find().exec();\n                assert.strictEqual(docs.length, 0);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should retry on errors","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":423,"column":38},"line":423,"code":"            it('should retry on errors', async () => {\n                const amount = batchSize * 4;\n                const testData = getTestData(amount);\n\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(testData)\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: ERROR_URL,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    deletedFlag: 'deleted'\n                });\n                replicationState.replicationState.retryTime = 100;\n\n\n                // on the first error, we switch out the graphql-client\n                await replicationState.error$.pipe(\n                    first()\n                ).toPromise().then(() => {\n                    const client = GraphQLClient({\n                        url: server.url\n                    });\n                    replicationState.clientState.client = client;\n                });\n\n                await replicationState.awaitInitialReplication();\n                const docs = await c.find().exec();\n                assert.strictEqual(docs.length, amount);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should not save pulled documents that do not match the schema","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":460,"column":77},"line":460,"code":"            it('should not save pulled documents that do not match the schema', async () => {\n                const testData = getTestData(1);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(testData)\n                ]);\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder,\n                        modifier: (docData: any) => {\n                            // delete name which is required in the schema\n                            delete docData.name;\n                            return docData;\n                        }\n                    },\n                    deletedFlag: 'deleted'\n                });\n\n                const errors: any[] = [];\n                const errorSub = replicationState.error$.subscribe((err: any) => {\n                    errors.push(err);\n                });\n                await AsyncTestUtil.waitUntil(() => errors.length === 1);\n\n                const firstError = errors[0];\n                assert.strictEqual(firstError.code, 'VD2');\n\n                errorSub.unsubscribe();\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should also get documents that come in afterwards with active .run()","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":495,"column":84},"line":495,"code":"            it('should also get documents that come in afterwards with active .run()', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(getTestData(1))\n                ]);\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    live: true,\n                    deletedFlag: 'deleted'\n                });\n\n\n                // wait until first replication is done\n                await replicationState.awaitInitialReplication();\n\n                // add document & trigger pull\n                const doc = getTestData(1).pop();\n                if (!doc) {\n                    throw new Error('doc missing');\n                }\n                await server.setDocument(doc);\n                await replicationState.run();\n\n                const docs = await c.find().exec();\n                assert.strictEqual(docs.length, 2);\n\n                server.close();\n                await c.database.destroy();\n\n                // replication should be canceled when collection is destroyed\n                assert.ok(replicationState.isStopped());\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should also get documents that come in afterwards with interval .run()","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":531,"column":86},"line":531,"code":"            it('should also get documents that come in afterwards with interval .run()', async () => {\n                // TODO this test randomly fails some times\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(getTestData(1))\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    live: true,\n                    liveInterval: 50,\n                    deletedFlag: 'deleted'\n                });\n\n                const errorSub = replicationState.error$.subscribe((err: any) => {\n                    console.error('got error while replication');\n                    console.dir(err);\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                // add document & trigger pull\n                const doc = getTestData(1).pop();\n                if (!doc) {\n                    throw new Error('doc missing');\n                }\n                await server.setDocument(doc);\n\n                await AsyncTestUtil.waitUntil(async () => {\n                    const docs = await c.find().exec();\n                    if (docs.length > 2) {\n                        throw new Error('got too many documents');\n                    }\n                    return docs.length === 2;\n                }, 10 * 1000, 100);\n\n                server.close();\n                errorSub.unsubscribe();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should overwrite the local doc if the remote gets deleted","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":575,"column":73},"line":575,"code":"            it('should overwrite the local doc if the remote gets deleted', async () => {\n                const amount = 3;\n\n                const testData = getTestData(amount);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(testData)\n                ]);\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    live: true,\n                    deletedFlag: 'deleted'\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docs = await c.find().exec();\n                assert.strictEqual(docs.length, amount);\n                await wait(250);\n\n                const firstDoc = AsyncTestUtil.clone(testData[0]);\n                firstDoc.deleted = true;\n\n                await server.setDocument(firstDoc);\n                await replicationState.run();\n\n                const docs2 = await c.find().exec();\n\n                assert.strictEqual(docs2.length, amount - 1);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should overwrite the local doc if it was deleted locally before synced from the server","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":612,"column":102},"line":612,"code":"            it('should overwrite the local doc if it was deleted locally before synced from the server', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(0);\n                const localDoc: any = schemaObjects.humanWithTimestamp();\n                const rxDoc = await c.insert(localDoc);\n                await rxDoc.remove();\n\n                const docs = await c.find().exec();\n                assert.strictEqual(docs.length, 0);\n\n                const server = await SpawnServer.spawn();\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    live: true,\n                    deletedFlag: 'deleted'\n                });\n                localDoc['deleted'] = false;\n                await server.setDocument(localDoc);\n\n                await replicationState.run();\n\n                const docsAfter = await c.find().exec();\n                assert.strictEqual(docsAfter.length, 1);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should fail because initial replication never resolves","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":642,"column":70},"line":642,"code":"            it('should fail because initial replication never resolves', async () => {\n                if (config.isFastMode()) {\n                    // this test takes too long, do not run in fast mode\n                    return;\n                }\n                const liveInterval = 4000;\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn()\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: ERROR_URL,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    deletedFlag: 'deleted',\n                    live: true,\n                    liveInterval: liveInterval,\n                });\n\n                let timeoutId: any;\n                const timeout = new Promise((_, reject) => {\n                    timeoutId = setTimeout(() => {\n                        clearTimeout(timeoutId);\n                        reject(new Error('Timeout reached'));\n                    },\n                        // small buffer until the promise rejects\n                        liveInterval + 5000);\n                });\n\n                const raceProm = Promise.race([\n                    replicationState.awaitInitialReplication(),\n                    timeout\n                ]).then(_ => clearTimeout(timeoutId));\n\n                // error should be thrown because awaitInitialReplication() should never resolve\n                await AsyncTestUtil.assertThrows(() => raceProm, Error, 'Timeout');\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should send all documents in one batch","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":688,"column":54},"line":688,"code":"            it('should send all documents in one batch', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(batchSize),\n                    SpawnServer.spawn()\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: false,\n                    deletedFlag: 'deleted'\n                });\n                const errSub = replicationState.error$.subscribe((err) => {\n                    console.dir(err);\n                    throw new Error('The replication threw an error');\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, batchSize);\n\n                server.close();\n                errSub.unsubscribe();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should send all documents in multiple batches","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":717,"column":61},"line":717,"code":"            it('should send all documents in multiple batches', async () => {\n                const amount = batchSize * 3;\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(amount),\n                    SpawnServer.spawn()\n                ]);\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: false,\n                    deletedFlag: 'deleted'\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, amount);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should send deletions","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":741,"column":37},"line":741,"code":"            it('should send deletions', async () => {\n                const amount = batchSize;\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(amount),\n                    SpawnServer.spawn<WithDeleted<HumanWithTimestampDocumentType>>()\n                ]);\n\n                const doc = await c.findOne().exec(true);\n                await doc.remove();\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: false,\n                    deletedFlag: 'deleted'\n                });\n\n                await replicationState.awaitInitialReplication();\n                const docsOnServer = server.getDocuments();\n\n                const shouldBeDeleted = docsOnServer.find((d: any) => d.id === doc.primary);\n                assert.strictEqual((shouldBeDeleted as any).deleted, true);\n\n                server.close();\n                await c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should trigger push on db-changes that have not resulted from the replication","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":770,"column":93},"line":770,"code":"            it('should trigger push on db-changes that have not resulted from the replication', async () => {\n                const amount = batchSize;\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(amount),\n                    SpawnServer.spawn()\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: true,\n                    liveInterval: 1000 * 60, // height\n                    deletedFlag: 'deleted'\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, amount);\n\n                // check for inserts\n                await c.insert(schemaObjects.humanWithTimestamp());\n                await AsyncTestUtil.waitUntil(async () => {\n                    const docsOnServer2 = server.getDocuments();\n                    return docsOnServer2.length === amount + 1;\n                });\n\n                // check for deletes\n                await c.findOne().remove();\n                await AsyncTestUtil.waitUntil(async () => {\n                    const docsOnServer2 = server.getDocuments();\n                    const oneShouldBeDeleted = docsOnServer2.find((d: any) => d.deleted === true);\n                    return !!oneShouldBeDeleted;\n                });\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should not send index-documents","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":811,"column":47},"line":811,"code":"            it('should not send index-documents', async () => {\n                const server = await SpawnServer.spawn();\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n\n                const schema = clone(schemas.humanWithTimestamp);\n                schema.indexes = ['name'];\n                const collections = await db.addCollections({\n                    humans: {\n                        schema\n                    }\n                });\n                const collection = collections.humans;\n\n                const replicationState = collection.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: false,\n                    deletedFlag: 'deleted'\n                });\n\n                const emitted = [];\n                replicationState.error$.subscribe((err: any) => {\n                    emitted.push(err);\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, 0);\n                assert.strictEqual(emitted.length, 0);\n\n                server.close();\n                db.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should push and pull all docs; live: false","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":854,"column":58},"line":854,"code":"            it('should push and pull all docs; live: false', async () => {\n                const amount = batchSize * 4;\n                const testData = getTestData(amount);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(amount),\n                    SpawnServer.spawn(testData)\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    live: false,\n                    deletedFlag: 'deleted'\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, amount * 2);\n\n                const docsOnDb = await c.find().exec();\n                assert.strictEqual(docsOnDb.length, amount * 2);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should allow asynchronous push and pull queryBuilders","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":887,"column":69},"line":887,"code":"            it('should allow asynchronous push and pull queryBuilders', async () => {\n                const amount = batchSize * 4;\n                const testData = getTestData(amount);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(amount),\n                    SpawnServer.spawn(testData)\n                ]);\n\n                const asyncPushQueryBuilder = async (doc: any): Promise<any> => {\n                    return pushQueryBuilder(doc);\n                };\n                const asyncQueryBuilder = async (doc: any): Promise<any> => {\n                    return queryBuilder(doc);\n                };\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: asyncPushQueryBuilder\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder: asyncQueryBuilder\n                    },\n                    live: false,\n                    deletedFlag: 'deleted'\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, amount * 2);\n\n                const docsOnDb = await c.find().exec();\n                assert.strictEqual(docsOnDb.length, amount * 2);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should allow asynchronous push and pull modifiers","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":927,"column":65},"line":927,"code":"            it('should allow asynchronous push and pull modifiers', async () => {\n                const amount = batchSize * 4;\n                const testData = getTestData(amount);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(amount),\n                    SpawnServer.spawn(testData)\n                ]);\n\n                const asyncModifier = async (d: any) => {\n                    await wait(10);\n                    return d;\n                };\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder,\n                        modifier: asyncModifier\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder: queryBuilder,\n                        modifier: asyncModifier\n                    },\n                    live: false,\n                    deletedFlag: 'deleted'\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, amount * 2);\n\n                const docsOnDb = await c.find().exec();\n                assert.strictEqual(docsOnDb.length, amount * 2);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should push and pull some docs; live: true","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":967,"column":58},"line":967,"code":"            it('should push and pull some docs; live: true', async () => {\n                const amount = batchSize * 1;\n                const testData = getTestData(amount);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(amount),\n                    SpawnServer.spawn(testData)\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    live: true,\n                    deletedFlag: 'deleted',\n                    liveInterval: 60 * 1000\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, amount * 2);\n\n                const docsOnDb = await c.find().exec();\n                assert.strictEqual(docsOnDb.length, amount * 2);\n\n\n                // insert one on local and one on server\n                const doc: any = schemaObjects.humanWithTimestamp({\n                    name: 'some1local'\n                });\n                doc['deleted'] = false;\n                await server.setDocument(doc);\n\n                const insertData = schemaObjects.humanWithTimestamp({\n                    name: 'some1server'\n                });\n                await c.insert(insertData);\n\n                await AsyncTestUtil.waitUntil(async () => {\n                    /**\n                     * we have to do replicationState.run() each time\n                     * because pouchdb takes a while until the update_seq is increased\n                     */\n                    await replicationState.run();\n                    const docsOnServer2 = server.getDocuments();\n                    const shouldBe = (amount * 2) + 2;\n                    return docsOnServer2.length === shouldBe;\n                });\n                await AsyncTestUtil.waitUntil(async () => {\n                    const docsOnDb2 = server.getDocuments();\n                    return docsOnDb2.length === (amount * 2) + 2;\n                });\n                await server.close();\n                await c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should push and pull many docs; live: true","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1028,"column":58},"line":1028,"code":"            it('should push and pull many docs; live: true', async () => {\n                const amount = batchSize * 4;\n                const testData = getTestData(amount);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(amount),\n                    SpawnServer.spawn(testData)\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    live: true,\n                    deletedFlag: 'deleted',\n                    liveInterval: 60 * 1000\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, amount * 2);\n\n                const docsOnDb = await c.find().exec();\n                assert.strictEqual(docsOnDb.length, amount * 2);\n\n\n                // insert one on local and one on server\n                const doc: any = schemaObjects.humanWithTimestamp({\n                    name: 'many1local'\n                });\n                doc['deleted'] = false;\n                await server.setDocument(doc);\n                await c.insert(schemaObjects.humanWithTimestamp({\n                    name: 'many1server'\n                }));\n\n                await AsyncTestUtil.waitUntil(async () => {\n                    /**\n                     * we have to do replicationState.run() each time\n                     * because pouchdb takes a while until the update_seq is increased\n                     */\n                    await replicationState.run();\n                    const docsOnServer2 = server.getDocuments();\n                    const shouldBe = (amount * 2) + 2;\n                    return docsOnServer2.length === shouldBe;\n                });\n                await AsyncTestUtil.waitUntil(async () => {\n                    const docsOnDb2 = server.getDocuments();\n                    return docsOnDb2.length === (amount * 2) + 2;\n                });\n\n                await server.close();\n                await c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should work with multiInstance","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1088,"column":46},"line":1088,"code":"            it('should work with multiInstance', async () => {\n                if (!config.storage.hasMultiInstance) {\n                    return;\n                }\n                if (config.isFastMode()) {\n                    // TODO this test randomly fails in fast mode with lokijs storage.\n                    return;\n                }\n                const name = randomCouchString(10);\n                const server = await SpawnServer.spawn();\n\n                const db1 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n\n                const collections1 = await db1.addCollections({\n                    humansmulti: {\n                        schema: schemas.humanWithTimestamp\n                    }\n                });\n                const collection1 = collections1.humansmulti;\n                const collections2 = await db2.addCollections({\n                    humansmulti: {\n                        schema: schemas.humanWithTimestamp\n                    }\n                });\n                const collection2 = collections2.humansmulti;\n\n                collection1.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    deletedFlag: 'deleted',\n                    live: true\n                });\n                collection2.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    deletedFlag: 'deleted',\n                    live: false\n                });\n\n\n                // insert to collection1\n                await collection1.insert(schemaObjects.humanWithTimestamp({\n                    name: 'mt1'\n                }));\n                await AsyncTestUtil.waitUntil(async () => {\n                    const docs = await collection2.find().exec();\n                    return docs.length === 1;\n                });\n\n                // insert to collection2\n                await collection2.insert(schemaObjects.humanWithTimestamp({\n                    name: 'mt2'\n                }));\n                await AsyncTestUtil.waitUntil(async () => {\n                    const docs = await collection1.find().exec();\n                    return docs.length === 2;\n                });\n\n                await db1.destroy();\n                await db2.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should push and pull with modifier filter","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1172,"column":57},"line":1172,"code":"            it('should push and pull with modifier filter', async () => {\n                const amount = batchSize * 1;\n\n                const serverData = getTestData(amount);\n                const serverDoc: any = getTestData(1)[0];\n                serverDoc.age = 101;\n                serverData.push(serverDoc);\n                const server = await SpawnServer.spawn(serverData);\n\n                const name = randomCouchString(10);\n                const db = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: schemas.humanWithTimestamp\n                    }\n                });\n                const collection = collections.humans;\n\n                for (let i = 0; i < amount; i++) {\n                    const insertDocsData = schemaObjects.humanWithTimestamp();\n                    insertDocsData.name = insertDocsData.name + '-client';\n                    await collection.insert(insertDocsData);\n                }\n                const localDoc: any = schemaObjects.humanWithTimestamp();\n                localDoc.name = localDoc.name + '-client';\n                localDoc.age = 102;\n                await collection.insert(localDoc);\n\n                const replicationState = collection.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder,\n                        modifier: (doc: any) => {\n                            if (doc.age > 100) {\n                                return null;\n                            }\n                            return doc;\n                        }\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder,\n                        modifier: (doc: any) => {\n                            if (doc.age > 100) {\n                                return null;\n                            }\n                            return doc;\n                        }\n                    },\n                    live: false,\n                    deletedFlag: 'deleted'\n                });\n                const errSub = replicationState.error$.subscribe((err) => {\n                    console.dir(err);\n                    throw new Error('The replication threw an error');\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                const docsOnDb = await collection.find().exec();\n\n                assert.strictEqual(docsOnServer.length, 2 * amount + 1);\n                assert.strictEqual(docsOnDb.length, 2 * amount + 1);\n\n                errSub.unsubscribe();\n                server.close();\n                db.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should not do more requests then needed","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1245,"column":55},"line":1245,"code":"            it('should not do more requests then needed', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn()\n                ]);\n\n                let pullCount = 0;\n                let pushCount = 0;\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize: 20,\n                        queryBuilder: args => {\n                            pushCount++;\n                            return pushQueryBuilder(args);\n                        }\n                    },\n                    pull: {\n                        batchSize: 20,\n                        queryBuilder: args => {\n                            pullCount++;\n                            return queryBuilder(args);\n                        }\n                    },\n                    live: true,\n                    deletedFlag: 'deleted',\n                    liveInterval: 60 * 1000\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                // pullCount should be exactly 1 because pull was started on replication start\n                assert.strictEqual(pullCount, 1);\n                assert.strictEqual(pushCount, 0);\n\n                // insert one document at the client\n                await c.insert(schemaObjects.humanWithTimestamp());\n\n                /**\n                 * After the insert,\n                 * exactly one push must be triggered\n                 * and then one pull should have happened afterwards\n                 */\n                await waitUntil(() => pushCount === 1);\n                await waitUntil(() => pullCount === 2);\n\n                /**\n                 * Even after some time,\n                 * no more requests should have happened\n                 */\n                await wait(250);\n                assert.strictEqual(pullCount, 2);\n                assert.strictEqual(pushCount, 1);\n\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should emit the received documents when pulling","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1306,"column":63},"line":1306,"code":"            it('should emit the received documents when pulling', async () => {\n                const testData = getTestData(batchSize);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(testData)\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    deletedFlag: 'deleted'\n                });\n\n                const emitted: RxDocumentData<HumanWithTimestampDocumentType>[] = [];\n                const sub = replicationState.received$.subscribe((doc: any) => emitted.push(doc));\n\n                await replicationState.awaitInitialReplication();\n                assert.strictEqual(emitted.length, batchSize);\n\n                testData.forEach((testDoc, idx) => {\n                    const isDoc = emitted[idx];\n                    assert.deepStrictEqual(testDoc.id, isDoc.id);\n                    assert.deepStrictEqual(testDoc.deleted, isDoc._deleted);\n                });\n\n                sub.unsubscribe();\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should emit the send documents when pushing","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1338,"column":59},"line":1338,"code":"            it('should emit the send documents when pushing', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(batchSize),\n                    SpawnServer.spawn()\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        queryBuilder: pushQueryBuilder,\n                        batchSize\n                    },\n                    live: false,\n                    deletedFlag: 'deleted'\n                });\n\n                const emitted: any[] = [];\n                const sub = replicationState.send$.subscribe((doc: any) => emitted.push(doc));\n                await replicationState.awaitInitialReplication();\n\n                assert.strictEqual(emitted.length, batchSize);\n\n                const docs = await c.find().exec();\n                assert.deepStrictEqual(\n                    emitted.map(d => d.id).sort(),\n                    docs.map(d => d.primary).sort()\n                );\n\n                sub.unsubscribe();\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should emit the correct amount of active-changes","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1370,"column":64},"line":1370,"code":"            it('should emit the correct amount of active-changes', async () => {\n                const amount = batchSize * 2;\n                const testData = getTestData(amount);\n\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(testData)\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    deletedFlag: 'deleted'\n                });\n\n                const emitted: any[] = [];\n                const sub = replicationState.active$.subscribe(d => emitted.push(d));\n\n                await replicationState.awaitInitialReplication();\n\n                assert.strictEqual(emitted.length, 3);\n                const last = emitted.pop();\n                assert.strictEqual(last, false);\n\n                sub.unsubscribe();\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should emit an error when the server is not reachable","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1401,"column":69},"line":1401,"code":"            it('should emit an error when the server is not reachable', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(0);\n                const replicationState = c.syncGraphQL({\n                    url: ERROR_URL,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    deletedFlag: 'deleted'\n                });\n\n                const error = await replicationState.error$.pipe(\n                    first()\n                ).toPromise();\n\n                assert.ok(ensureNotFalsy(error).toString().includes('foobar'));\n\n                replicationState.cancel();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should contain include replication action data in pull request failure","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1421,"column":86},"line":1421,"code":"            it('should contain include replication action data in pull request failure', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(0);\n                const replicationState = c.syncGraphQL({\n                    url: ERROR_URL,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    deletedFlag: 'deleted'\n                });\n\n                const error = await replicationState.error$.pipe(\n                    first()\n                ).toPromise();\n\n                assert.strictEqual(ensureNotFalsy(error).type, 'pull');\n\n                replicationState.cancel();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should contain include replication action data in push request failure","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1441,"column":86},"line":1441,"code":"            it('should contain include replication action data in push request failure', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(0);\n                const replicationState = c.syncGraphQL({\n                    url: ERROR_URL,\n                    push: {\n                        queryBuilder: pushQueryBuilder,\n                    },\n                    deletedFlag: 'deleted'\n                });\n\n                const localDoc = schemaObjects.humanWithTimestamp();\n                await c.insert(localDoc);\n\n                const error = ensureNotFalsy(\n                    await replicationState.error$.pipe(\n                        first()\n                    ).toPromise()\n                );\n\n                if (error.type === 'pull') {\n                    throw new Error('wrong error type');\n                }\n\n                const documentsData = ensureNotFalsy(error).documentsData;\n\n                assert.strictEqual(ensureNotFalsy(error).type, 'push');\n                assert.strictEqual(documentsData[0].id, localDoc.id);\n                assert.strictEqual(documentsData[0].name, localDoc.name);\n                assert.strictEqual(documentsData[0].age, localDoc.age);\n                assert.strictEqual(documentsData[0].updatedAt, localDoc.updatedAt);\n\n                replicationState.cancel();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should not exit .run() before the batch is inserted and its events have been emitted","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1475,"column":100},"line":1475,"code":"            it('should not exit .run() before the batch is inserted and its events have been emitted', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(0);\n                const server = await SpawnServer.spawn(getTestData(1));\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    live: true,\n                    deletedFlag: 'deleted'\n                });\n                await replicationState.run();\n\n                await AsyncTestUtil.waitUntil(async () => {\n                    const docsAfter2 = await c.find().exec();\n                    return docsAfter2.length === 1;\n                });\n\n                const doc: any = schemaObjects.humanWithTimestamp();\n                doc['deleted'] = false;\n                await server.setDocument(doc);\n\n                await replicationState.run();\n                // directly after .run(), the doc must be available\n                const docsAfter = await c.find().exec();\n                assert.strictEqual(docsAfter.length, 2);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"assumption: buildSchema() fails on non-graphql input","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1510,"column":68},"line":1510,"code":"            it('assumption: buildSchema() fails on non-graphql input', () => {\n                assert.throws(\n                    () => buildSchema('foobar')\n                );\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should create a valid output","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1515,"column":44},"line":1515,"code":"            it('should create a valid output', () => {\n                const output = graphQLSchemaFromRxSchema({\n                    human: {\n                        schema: schemas.humanWithTimestamp,\n                        feedKeys: [\n                            'id',\n                            'updatedAt'\n                        ],\n                        deletedFlag: 'deleted'\n                    },\n                    deepNestedHuman: {\n                        schema: schemas.deepNestedHuman,\n                        feedKeys: [\n                            'passportId'\n                        ],\n                        deletedFlag: 'deleted'\n                    }\n                });\n\n                const build = buildSchema(output.asString);\n\n                assert.ok(build);\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should create a valid output with subscription params","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1538,"column":69},"line":1538,"code":"            it('should create a valid output with subscription params', () => {\n                const output = graphQLSchemaFromRxSchema({\n                    human: {\n                        schema: schemas.humanWithTimestamp,\n                        feedKeys: [\n                            'id',\n                            'updatedAt'\n                        ],\n                        deletedFlag: 'deleted'\n                    },\n                    deepNestedHuman: {\n                        schema: schemas.deepNestedHuman,\n                        feedKeys: [\n                            'passportId'\n                        ],\n                        deletedFlag: 'deleted',\n                        subscriptionParams: {\n                            foo: 'ID!'\n                        }\n                    }\n                });\n                const build = buildSchema(output.asString);\n                assert.ok(build);\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"assumption: parseQuery() fails on non-graphql input","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1564,"column":67},"line":1564,"code":"            it('assumption: parseQuery() fails on non-graphql input', () => {\n                assert.throws(\n                    () => parseQuery('foobar')\n                );\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should create a valid builder","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1569,"column":45},"line":1569,"code":"            it('should create a valid builder', async () => {\n                const builder = pullQueryBuilderFromRxSchema(\n                    'human', {\n                    schema: schemas.humanWithTimestamp,\n                    feedKeys: [\n                        'id',\n                        'updatedAt'\n                    ],\n                    deletedFlag: 'deleted',\n                }, batchSize);\n\n                const output = await builder({\n                    id: 'foo',\n                    updatedAt: 12343\n                });\n\n                const parsed = parseQuery(output.query);\n                assert.ok(parsed);\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"builder should work on null-document","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1588,"column":52},"line":1588,"code":"            it('builder should work on null-document', async () => {\n                const builder = pullQueryBuilderFromRxSchema(\n                    'human', {\n                    schema: schemas.humanWithTimestamp,\n                    feedKeys: [\n                        'id',\n                        'updatedAt'\n                    ],\n                    deletedFlag: 'deleted',\n                }, batchSize);\n\n                const output = await builder(null);\n                const parsed = parseQuery(output.query);\n                assert.ok(parsed);\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should create a valid builder","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1605,"column":45},"line":1605,"code":"            it('should create a valid builder', async () => {\n                const builder = pushQueryBuilderFromRxSchema(\n                    'human', {\n                    schema: schemas.humanWithTimestamp,\n                    feedKeys: [\n                        'id',\n                        'updatedAt'\n                    ],\n                    deletedFlag: 'deleted'\n                });\n\n                // build valid output for insert document\n                const output = await builder([{\n                    id: 'foo',\n                    name: 'foo',\n                    age: 1234,\n                    updatedAt: 12343,\n                    _attachments: {},\n                    _rev: '1-foobar'\n                }]);\n                const parsed = parseQuery(output.query);\n\n                const variable: HumanWithTimestampDocumentType = output.variables.human;\n\n                // should not have added internal properties\n                assert.ok(!variable.hasOwnProperty('_rev'));\n                assert.ok(!variable.hasOwnProperty('_attachments'));\n                assert.ok(!variable.hasOwnProperty('_deleted'));\n\n                // build valid output for deleted document\n                const outputDeleted = await builder([{\n                    id: 'foo',\n                    _deleted: true\n                }]);\n                parseQuery(outputDeleted.query);\n\n                // should not have added internal properties\n                const variableDeleted: HumanWithTimestampDocumentType = outputDeleted.variables.human;\n                assert.ok(!variableDeleted.hasOwnProperty('_rev'));\n                assert.ok(!variableDeleted.hasOwnProperty('_attachments'));\n                assert.ok(!variableDeleted.hasOwnProperty('_deleted'));\n\n                assert.ok(parsed);\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should keep the deleted value","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1649,"column":45},"line":1649,"code":"            it('should keep the deleted value', async () => {\n                const docData: any = schemaObjects.humanWithTimestamp();\n                /**\n                 * The GraphQL replication will\n                 * internally switch out _deleted with the deleted flag.\n                 * So the pushQueryBuilder MUST NOT switch out again.\n                 */\n                docData.deleted = true;\n                const ownPushQueryBuilder = pushQueryBuilderFromRxSchema(\n                    'human',\n                    {\n                        deletedFlag: 'deleted',\n                        feedKeys: [\n                            'id',\n                            'updatedAt'\n                        ],\n                        schema: schemas.humanWithTimestamp\n                    }\n                );\n                const pushData = await ownPushQueryBuilder([docData]);\n                const pushDoc = pushData.variables.human[0];\n                assert.ok(pushDoc.deleted);\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should work with encryption","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1674,"column":43},"line":1674,"code":"            it('should work with encryption', async () => {\n                if (config.storage.name !== 'pouchdb') {\n                    return;\n                }\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    multiInstance: true,\n                    eventReduce: true,\n                    ignoreDuplicate: true,\n                    password: randomCouchString(10)\n                });\n                const schema: RxJsonSchema<HumanWithTimestampDocumentType> = clone(schemas.humanWithTimestamp);\n                schema.encrypted = ['name'];\n                const collections = await db.addCollections({\n                    humans: {\n                        schema\n                    }\n                });\n                const collection = collections.humans;\n\n                const testData = getTestData(1);\n                testData[0].name = 'Alice';\n                const server = await SpawnServer.spawn(testData);\n\n                const replicationState: RxGraphQLReplicationState<HumanWithTimestampDocumentType> = collection.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    deletedFlag: 'deleted'\n                });\n                await replicationState.awaitInitialReplication();\n\n                const docs = await collection.find().exec();\n                assert.strictEqual(docs.length, 1);\n                assert.strictEqual(docs[0].name, 'Alice');\n\n                const pouchDocs = await collection.storageInstance.internals.pouch.find({\n                    selector: {}\n                });\n                assert.ok(pouchDocs.docs[0].name !== 'Alice');\n\n                db.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"pull should work with keyCompression","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1720,"column":52},"line":1720,"code":"            it('pull should work with keyCompression', async () => {\n                if (config.storage.name !== 'pouchdb') {\n                    return;\n                }\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    multiInstance: true,\n                    eventReduce: true,\n                    ignoreDuplicate: true,\n                    password: randomCouchString(10)\n                });\n                const schema = clone(schemas.humanWithTimestamp);\n                schema.keyCompression = true;\n                const collections = await db.addCollections({\n                    humans: {\n                        schema\n                    }\n                });\n                const collection = collections.humans;\n\n                const testData = getTestData(1);\n                testData[0].name = 'Alice';\n                const server = await SpawnServer.spawn(testData);\n\n                const replicationState = collection.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    deletedFlag: 'deleted'\n                });\n                await replicationState.awaitInitialReplication();\n\n                const docs = await collection.find().exec();\n                assert.strictEqual(docs.length, 1);\n                assert.strictEqual(docs[0].name, 'Alice');\n\n                const pouchDocs = await collection.storageInstance.internals.pouch.find({\n                    selector: {}\n                });\n\n                // first key must be compressed\n                assert.ok(Object.keys(pouchDocs.docs[0])[0].startsWith('|'));\n\n                server.close();\n                db.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"push should work with keyCompression","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1769,"column":52},"line":1769,"code":"            it('push should work with keyCompression', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    multiInstance: true,\n                    eventReduce: true,\n                    ignoreDuplicate: true,\n                    password: randomCouchString(10)\n                });\n                const schema = clone(schemas.humanWithTimestamp);\n                schema.keyCompression = true;\n                const collections = await db.addCollections({\n                    humans: {\n                        schema\n                    }\n                });\n                const collection = collections.humans;\n                await collection.insert(schemaObjects.humanWithTimestamp());\n\n                const server = await SpawnServer.spawn<HumanWithTimestampDocumentType>([]);\n\n                const replicationState = collection.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        /**\n                         * TODO for whatever reason this test\n                         * does not work with batchSize=1\n                         */\n                        batchSize: 10,\n                        queryBuilder: doc => {\n                            const ret = pushQueryBuilder(doc);\n                            return ret;\n                        }\n                    },\n                    deletedFlag: 'deleted'\n                });\n                const errorSub = replicationState.error$.subscribe(err => {\n                    console.dir(err);\n                });\n                await replicationState.awaitInitialReplication();\n\n\n\n                const serverDocs = server.getDocuments();\n                assert.strictEqual(serverDocs.length, 1);\n                assert.ok(serverDocs[0].age);\n\n                errorSub.unsubscribe();\n                server.close();\n                db.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should work with headers","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1820,"column":40},"line":1820,"code":"            it('should work with headers', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(getTestData(1))\n                ]);\n\n                server.requireHeader('Authorization', 'password');\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    headers: {\n                        Authorization: 'password'\n                    },\n                    live: true,\n                    deletedFlag: 'deleted'\n                });\n                await replicationState.awaitInitialReplication();\n\n                const docs = await c.find().exec();\n                assert.strictEqual(docs.length, 1);\n\n                server.close();\n                await c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should work after headers change","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1847,"column":48},"line":1847,"code":"            it('should work after headers change', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(getTestData(1))\n                ]);\n\n                server.requireHeader('Authorization', 'password');\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    headers: {\n                        Authorization: 'password'\n                    },\n                    live: true,\n                    deletedFlag: 'deleted'\n                });\n                await replicationState.awaitInitialReplication();\n\n                server.requireHeader('Authorization', '1234');\n                const doc = getTestData(1).pop();\n                if (!doc) {\n                    throw new Error('missing doc');\n                }\n                await server.setDocument(doc);\n\n                replicationState.setHeaders({\n                    'Authorization': '1234'\n                });\n                await replicationState.run();\n\n                const docs = await c.find().exec();\n                assert.strictEqual(docs.length, 2);\n\n                server.close();\n                await c.database.destroy();\n\n                // replication should be canceled when collection is destroyed\n                assert.ok(replicationState.isStopped());\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should not lose error information","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1889,"column":49},"line":1889,"code":"            it('should not lose error information', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(getTestData(1))\n                ]);\n\n                server.requireHeader('Authorization', 'password');\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    headers: {\n                        Authorization: 'wrong-password'\n                    },\n                    live: true,\n                    deletedFlag: 'deleted'\n                });\n                const replicationError = await replicationState.error$.pipe(first()).toPromise();\n                assert.notStrictEqual(ensureNotFalsy(replicationError).message, '[object Object]');\n\n                server.close();\n                await c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should not create push checkpoints unnecessarily [PR: #3627]","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1917,"column":76},"line":1917,"code":"            it('should not create push checkpoints unnecessarily [PR: #3627]', async () => {\n                if (config.storage.name !== 'pouchdb') {\n                    return;\n                }\n                const amount = batchSize * 4;\n                const testData = getTestData(amount);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(amount),\n                    SpawnServer.spawn(testData),\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder,\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder,\n                    },\n                    live: true,\n                    deletedFlag: 'deleted',\n                    liveInterval: 60 * 1000,\n                });\n\n                await replicationState.awaitInitialReplication();\n                await replicationState.run();\n\n                const originalCheckpoint = await getLastPushCheckpoint(\n                    replicationState.collection,\n                    replicationState.replicationState.replicationIdentifierHash\n                );\n\n                // call .run() often\n                for (let i = 0; i < 3; i++) {\n                    await replicationState.run();\n                }\n\n                const newCheckpoint = await getLastPushCheckpoint(\n                    replicationState.collection,\n                    replicationState.replicationState.replicationIdentifierHash\n                );\n                assert.strictEqual(originalCheckpoint.sequence, newCheckpoint.sequence);\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"push not working on slow db","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1964,"column":43},"line":1964,"code":"            it('push not working on slow db', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    multiInstance: true,\n                    eventReduce: true,\n                    ignoreDuplicate: true,\n                    password: randomCouchString(10)\n                });\n                const schema: RxJsonSchema<any> = clone(schemas.humanWithTimestampAllIndex);\n                schema.encrypted = ['name'];\n                const collections = await db.addCollections({\n                    humans: {\n                        schema\n                    }\n                });\n                const collection = collections.humans;\n\n                // insert data to slow down the db\n                const amount = 30;\n                await Promise.all(\n                    new Array(amount).fill(0)\n                        .map(() => schemaObjects.humanWithTimestamp())\n                        .map(d => collection.insert(d))\n                );\n\n                const server = await SpawnServer.spawn(getTestData(0));\n\n                const replicationState = collection.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: true,\n                    deletedFlag: 'deleted'\n                });\n                await replicationState.awaitInitialReplication();\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, amount);\n\n                // insert one which will trigger an auto push\n                await collection.insert(schemaObjects.humanWithTimestamp());\n\n                await AsyncTestUtil.waitUntil(async () => {\n                    const docs = await server.getDocuments();\n                    return docs.length === (amount + 1);\n                });\n\n                server.close();\n                db.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"push not working when big amount of docs was pulled before","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":2016,"column":74},"line":2016,"code":"            it('push not working when big amount of docs was pulled before', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    multiInstance: true,\n                    eventReduce: true,\n                    ignoreDuplicate: true,\n                    password: randomCouchString(10)\n                });\n                const schema: RxJsonSchema<any> = clone(schemas.humanWithTimestampAllIndex);\n                schema.encrypted = ['name'];\n                const collections = await db.addCollections({\n                    humans: {\n                        schema\n                    }\n                });\n                const collection = collections.humans;\n\n                const amount = 50;\n                const testData = getTestData(amount);\n                const server = await SpawnServer.spawn(testData);\n\n                const replicationState = collection.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    live: true,\n                    deletedFlag: 'deleted'\n                });\n                replicationState.error$.subscribe((err: any) => console.error('REPLICATION ERROR', err));\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, amount);\n\n                // insert one which will trigger an auto push\n                const insertedDoc = await collection.insert(schemaObjects.humanWithTimestamp());\n                assert.ok(insertedDoc);\n\n                await AsyncTestUtil.waitUntil(async () => {\n                    const docs = await server.getDocuments();\n                    if (docs.length > (amount + 1)) {\n                        throw new Error('too many docs');\n                    }\n                    return docs.length === (amount + 1);\n                });\n\n                server.close();\n                db.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"#1812 updates fail when graphql is enabled","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":2072,"column":58},"line":2072,"code":"            it('#1812 updates fail when graphql is enabled', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    multiInstance: false,\n                    eventReduce: true,\n                    password: randomCouchString(10)\n                });\n                const schema: RxJsonSchema<any> = clone(schemas.humanWithTimestampAllIndex);\n                const collections = await db.addCollections({\n                    humans: {\n                        schema\n                    }\n                });\n                const collection = collections.humans;\n\n                const server = await SpawnServer.spawn();\n                assert.strictEqual(server.getDocuments().length, 0);\n\n                // start live replication\n                const replicationState = collection.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder\n                    },\n                    live: true,\n                    deletedFlag: 'deleted'\n                });\n\n                // ensure we are in sync even when there are no doc in the db at this moment\n                await replicationState.awaitInitialReplication();\n\n                // add one doc to the client database\n                const testData = getTestData(1).pop();\n                delete (testData as any).deleted;\n                await collection.insert(testData);\n\n                // sync\n                await replicationState.run();\n\n\n                assert.strictEqual(server.getDocuments().length, 1);\n\n                // update document\n                const newAge = 1111;\n                const doc = await collection.findOne().exec(true);\n                await doc.atomicPatch({ age: newAge });\n\n                const docAfter = await collection.findOne().exec(true);\n                assert.strictEqual(docAfter.age, newAge);\n\n                // check server\n                await replicationState.run();\n\n                await AsyncTestUtil.waitUntil(() => {\n                    const serverDocs = server.getDocuments();\n                    const notUpdated = serverDocs.find((d: any) => d.age !== newAge);\n                    return !notUpdated;\n                });\n\n                server.close();\n                db.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"#2048 GraphQL .run() fires exponentially on push errors","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":2140,"column":71},"line":2140,"code":"            it('#2048 GraphQL .run() fires exponentially on push errors', async () => {\n                if (config.isFastMode()) {\n                    // this test takes too long, do not run in fast mode\n                    return;\n                }\n\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(batchSize),\n                    SpawnServer.spawn()\n                ]);\n                const pushQueryBuilderFailing = (doc: any) => {\n                    // Note: setHumanFail will error out\n                    const query = `\n                    mutation CreateHuman($human: HumanInput) {\n                        setHumanFail(human: $human) {\n                            id,\n                            updatedAt\n                        }\n                    }\n                    `;\n                    const variables = {\n                        human: doc\n                    };\n\n                    return {\n                        query,\n                        variables\n                    };\n                };\n\n                const graphqlReplicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilderFailing\n                    },\n                    live: true,\n                    deletedFlag: 'deleted',\n                    retryTime: 500,\n                    liveInterval: 0\n                });\n                const replicationState = graphqlReplicationState.replicationState;\n\n                // We sleep 5000 seconds with retry time set to 500 sec\n                await AsyncTestUtil.wait(5000);\n\n                // Since push will error out we expect it there to be around 5000/500 = 10 retries\n                assert.ok(replicationState.runCount >= 9, replicationState.runCount.toString());\n                assert.ok(replicationState.runCount <= 11, replicationState.runCount.toString());\n\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"#2336 liveInterval-retries should not stack up","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":2192,"column":62},"line":2192,"code":"            it('#2336 liveInterval-retries should not stack up', async () => {\n                if (config.isFastMode()) {\n                    // this test takes too long, do not run in fast mode\n                    return;\n                }\n\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(batchSize),\n                    SpawnServer.spawn()\n                ]);\n                const pullQueryBuilderFailing = (doc: any) => {\n                    // Note: setHumanFail will error out\n                    const query = `\n                    mutation CreateHuman($humans: [HumanInput]) {\n                        setHumansFail(humans: $humans) {  }\n                    }\n                    `;\n                    const variables = {\n                        human: doc\n                    };\n\n                    return {\n                        query,\n                        variables\n                    };\n                };\n\n                const graphqlReplicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilderFailing\n                    },\n                    live: true,\n                    deletedFlag: 'deleted',\n                    retryTime: 1000,\n                    liveInterval: 500\n                });\n                const replicationState = graphqlReplicationState.replicationState;\n\n                /**\n                 * Since push will error out,\n                 * we expect it there to be around 5000/500 = 10 runs with some retries.\n                 */\n                await AsyncTestUtil.wait(5000);\n                assert.ok(replicationState.runCount < 20, replicationState.runCount.toString());\n\n                c.database.destroy();\n                server.close();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"#3319 database.remove() should delete the last-pull document","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":2242,"column":76},"line":2242,"code":"            it('#3319 database.remove() should delete the last-pull document', async () => {\n                const dbName = randomCouchString(12);\n                const c = await humansCollection.createHumanWithTimestamp(1, dbName);\n                const doc = await c.findOne().exec(true);\n                let docData = doc.toJSON(true);\n                docData = clone(docData); // clone to make it mutateable\n                (docData as any).name = 'foobar';\n\n                await setLastPullDocument(c, endpointHash, docData as any);\n                await c.database.remove();\n\n                // recreate the same collection again\n                const c2 = await humansCollection.createHumanWithTimestamp(1, dbName);\n                // there should be no pull document now\n                const ret = await getLastPullDocument(c2, endpointHash);\n                assert.strictEqual(ret, null);\n\n                await c.database.destroy();\n                await c2.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"push not working on slow db","suites":["replication-graphql.test.ts","browser","issues"],"updatePoint":{"line":2267,"column":43},"line":2267,"code":"            it('push not working on slow db', async () => {\n                const dbName = randomCouchString(10);\n                const db = await createRxDatabase({\n                    name: dbName,\n                    storage: getRxStoragePouch('idb'),\n                    multiInstance: true,\n                    eventReduce: true,\n                    ignoreDuplicate: true\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: schemas.humanWithTimestampAllIndex\n                    }\n                });\n                const collection = collections.humans;\n\n                // insert data to slow down the db\n                const amount = 30;\n                await Promise.all(\n                    new Array(amount).fill(0)\n                        .map(() => schemaObjects.humanWithTimestamp())\n                        .map(d => collection.insert(d))\n                );\n\n                const replicationState = collection.syncGraphQL({\n                    url: browserServerUrl,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: false,\n                    deletedFlag: 'deleted'\n                });\n                await replicationState.awaitInitialReplication();\n\n                const docsStart = await getDocsOnServer(replicationState);\n\n                // amount might be bigger if 2 browser run parallel\n                assert.ok(docsStart.length >= amount);\n\n                await db.destroy();\n\n                // insert one in new instance of same db\n                // which will trigger an auto push\n                const db2 = await createRxDatabase({\n                    name: dbName,\n                    storage: getRxStoragePouch('idb'),\n                    multiInstance: true,\n                    eventReduce: true,\n                    ignoreDuplicate: true\n                });\n                const collections2 = await db2.addCollections({\n                    humans: {\n                        schema: schemas.humanWithTimestampAllIndex\n                    }\n                });\n                const collection2 = collections2.humans;\n                const replicationState2 = collection2.syncGraphQL({\n                    url: browserServerUrl,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: true,\n                    deletedFlag: 'deleted'\n                });\n                await replicationState2.awaitInitialReplication();\n                const addDoc = schemaObjects.humanWithTimestamp();\n                await collection2.insert(addDoc);\n\n                await AsyncTestUtil.waitUntil(async () => {\n                    const docsEnd = await getDocsOnServer(replicationState);\n                    const found = docsEnd.find(d => d.id === addDoc.id);\n                    return !!found;\n                });\n                db2.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should be false on non-set flag","suites":["replication.test.js",".wasLastWriteFromPullReplication()"],"updatePoint":{"line":132,"column":47},"line":132,"code":"            it('should be false on non-set flag', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(1);\n                const doc = await c.findOne().exec(true);\n\n                const wasFromPull = wasLastWriteFromPullReplication(\n                    REPLICATION_IDENTIFIER_TEST_HASH,\n                    doc.toJSON(true)\n                );\n                assert.strictEqual(wasFromPull, false);\n\n                c.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should be true for pulled revision","suites":["replication.test.js",".wasLastWriteFromPullReplication()"],"updatePoint":{"line":144,"column":50},"line":144,"code":"            it('should be true for pulled revision', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(0);\n                const toStorage: RxDocumentData<HumanWithTimestampDocumentType> = Object.assign(\n                    schemaObjects.humanWithTimestamp(),\n                    {\n                        _rev: '1-62080c42d471e3d2625e49dcca3b8e3e',\n                        _attachments: {},\n                        _deleted: false,\n                        _meta: {\n                            lwt: now(),\n                            [getPullReplicationFlag(REPLICATION_IDENTIFIER_TEST_HASH)]: 1\n                        }\n                    }\n                );\n\n                const wasFromPull = wasLastWriteFromPullReplication(\n                    REPLICATION_IDENTIFIER_TEST_HASH,\n                    toStorage\n                );\n                assert.strictEqual(wasFromPull, true);\n\n                c.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should set the last push sequence","suites":["replication.test.js",".setLastPushCheckpoint()"],"updatePoint":{"line":171,"column":49},"line":171,"code":"            it('should set the last push sequence', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(0);\n                const ret = await setLastPushCheckpoint(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST,\n                    1\n                );\n                assert.ok(ret.id.includes(REPLICATION_IDENTIFIER_TEST));\n                c.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should be able to run multiple times","suites":["replication.test.js",".setLastPushCheckpoint()"],"updatePoint":{"line":181,"column":52},"line":181,"code":"            it('should be able to run multiple times', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(0);\n                await setLastPushCheckpoint(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST,\n                    1\n                );\n                await setLastPushCheckpoint(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST,\n                    2\n                );\n                c.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should get undefined if not set before","suites":["replication.test.js",".getLastPushCheckpoint()"],"updatePoint":{"line":197,"column":54},"line":197,"code":"            it('should get undefined if not set before', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(0);\n                const ret = await getLastPushCheckpoint(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST\n                );\n                assert.strictEqual(typeof ret, 'undefined');\n                c.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should get the value if set before","suites":["replication.test.js",".getLastPushCheckpoint()"],"updatePoint":{"line":206,"column":50},"line":206,"code":"            it('should get the value if set before', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(0);\n                await setLastPushCheckpoint(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST,\n                    5\n                );\n                const ret = await getLastPushCheckpoint(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST\n                );\n                assert.strictEqual(ret, 5);\n                c.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should get the value if set multiple times","suites":["replication.test.js",".getLastPushCheckpoint()"],"updatePoint":{"line":220,"column":58},"line":220,"code":"            it('should get the value if set multiple times', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(0);\n                await setLastPushCheckpoint(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST,\n                    5\n                );\n                const ret = await getLastPushCheckpoint(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST\n                );\n                assert.strictEqual(ret, 5);\n\n                await setLastPushCheckpoint(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST,\n                    10\n                );\n                const ret2 = await getLastPushCheckpoint(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST\n                );\n                assert.strictEqual(ret2, 10);\n                c.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should get all changes","suites":["replication.test.js",".getChangesSinceLastPushCheckpoint()"],"updatePoint":{"line":247,"column":38},"line":247,"code":"            it('should get all changes', async () => {\n                const amount = 5;\n                const c = await humansCollection.createHumanWithTimestamp(amount);\n                const changesResult = await getChangesSinceLastPushCheckpoint(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST_HASH,\n                    () => false,\n                    10\n                );\n                assert.strictEqual(changesResult.changedDocs.size, amount);\n                const firstChange = Array.from(changesResult.changedDocs.values())[0];\n                assert.ok(firstChange.doc.name);\n                c.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should get only the newest update to documents","suites":["replication.test.js",".getChangesSinceLastPushCheckpoint()"],"updatePoint":{"line":261,"column":62},"line":261,"code":"            it('should get only the newest update to documents', async () => {\n                const amount = 5;\n                const c = await humansCollection.createHumanWithTimestamp(amount);\n                const oneDoc = await c.findOne().exec(true);\n                await oneDoc.atomicPatch({ age: 1 });\n                const changesResult = await getChangesSinceLastPushCheckpoint(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST_HASH,\n                    () => false,\n                    10\n                );\n                assert.strictEqual(changesResult.changedDocs.size, amount);\n                c.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should not get more changes then the limit","suites":["replication.test.js",".getChangesSinceLastPushCheckpoint()"],"updatePoint":{"line":275,"column":58},"line":275,"code":"            it('should not get more changes then the limit', async () => {\n                const amount = 30;\n                const c = await humansCollection.createHumanWithTimestamp(amount);\n                const changesResult = await getChangesSinceLastPushCheckpoint(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST_HASH,\n                    () => false,\n                    10\n                );\n                /**\n                 * The returned size can be lower then the batchSize\n                 * because we skip internal changes like index documents.\n                 */\n                assert.ok(changesResult.changedDocs.size <= 10);\n                c.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should get deletions","suites":["replication.test.js",".getChangesSinceLastPushCheckpoint()"],"updatePoint":{"line":291,"column":36},"line":291,"code":"            it('should get deletions', async () => {\n                const amount = 5;\n                const c = await humansCollection.createHumanWithTimestamp(amount);\n                const oneDoc = await c.findOne().exec(true);\n                await oneDoc.remove();\n                const changesResult = await getChangesSinceLastPushCheckpoint(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST_HASH,\n                    () => false,\n                    10\n                );\n                assert.strictEqual(changesResult.changedDocs.size, amount);\n                const deleted = Array.from(changesResult.changedDocs.values()).find((change) => {\n                    return change.doc._deleted === true;\n                });\n\n                if (!deleted) {\n                    throw new Error('deleted missing');\n                }\n\n                assert.ok(deleted.doc._deleted);\n                assert.ok(deleted.doc.age);\n\n                c.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should have resolved the primary","suites":["replication.test.js",".getChangesSinceLastPushCheckpoint()"],"updatePoint":{"line":316,"column":48},"line":316,"code":"            it('should have resolved the primary', async () => {\n                const amount = 5;\n                const c = await humansCollection.createHumanWithTimestamp(amount);\n                const changesResult = await getChangesSinceLastPushCheckpoint(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST_HASH,\n                    () => false,\n                    10\n                );\n                const firstChange = Array.from(changesResult.changedDocs.values())[0];\n\n                assert.ok(firstChange.doc.id);\n                c.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should have filtered out documents that are already replicated from the remote","suites":["replication.test.js",".getChangesSinceLastPushCheckpoint()"],"updatePoint":{"line":330,"column":94},"line":330,"code":"            it('should have filtered out documents that are already replicated from the remote', async () => {\n                const amount = 5;\n                const c = await humansCollection.createHumanWithTimestamp(amount);\n                const toStorageInstance: RxDocumentWriteData<HumanWithTimestampDocumentType> = Object.assign(\n                    schemaObjects.humanWithTimestamp(),\n                    {\n                        _attachments: {},\n                        _deleted: false,\n                        _meta: {\n                            lwt: now()\n                        },\n                        _rev: EXAMPLE_REVISION_1\n                    }\n                );\n                setLastWritePullReplication(\n                    REPLICATION_IDENTIFIER_TEST_HASH,\n                    toStorageInstance,\n                    1\n                );\n                const docId = toStorageInstance.id;\n\n                await c.storageInstance.bulkWrite([{\n                    document: toStorageInstance\n                }]);\n\n                const allDocs = await c.find().exec();\n\n                assert.strictEqual(allDocs.length, amount + 1);\n                const changesResult = await getChangesSinceLastPushCheckpoint(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST_HASH,\n                    () => false,\n                    10\n                );\n\n                assert.strictEqual(changesResult.changedDocs.size, amount);\n                const shouldNotBeFound = Array.from(changesResult.changedDocs.values()).find((change) => change.id === docId);\n                assert.ok(!shouldNotBeFound);\n\n                c.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should set the document","suites":["replication.test.js",".setLastPullDocument()"],"updatePoint":{"line":373,"column":39},"line":373,"code":"            it('should set the document', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(1);\n                const doc = await c.findOne().exec(true);\n                const docData = doc.toJSON(true);\n                const ret = await setLastPullDocument(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST_HASH,\n                    docData\n                );\n                assert.ok(ret.id.includes(REPLICATION_IDENTIFIER_TEST_HASH));\n                c.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should be able to run multiple times","suites":["replication.test.js",".setLastPullDocument()"],"updatePoint":{"line":385,"column":52},"line":385,"code":"            it('should be able to run multiple times', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(1);\n                const doc = await c.findOne().exec(true);\n                const docData = doc.toJSON(true);\n                await setLastPullDocument(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST_HASH,\n                    docData\n                );\n                const ret = await setLastPullDocument(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST_HASH,\n                    docData\n                );\n                assert.ok(ret.id.includes(REPLICATION_IDENTIFIER_TEST_HASH));\n                c.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should return null if no doc set","suites":["replication.test.js",".getLastPullDocument()"],"updatePoint":{"line":404,"column":48},"line":404,"code":"            it('should return null if no doc set', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(0);\n                const ret = await getLastPullDocument(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST_HASH\n                );\n                assert.strictEqual(ret, null);\n                c.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should return the doc if it was set","suites":["replication.test.js",".getLastPullDocument()"],"updatePoint":{"line":413,"column":51},"line":413,"code":"            it('should return the doc if it was set', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(1);\n                const doc = await c.findOne().exec(true);\n                let docData = doc.toJSON(true);\n                docData = clone(docData); // clone to make it mutateable\n                (docData as any).name = 'foobar';\n\n                await setLastPullDocument(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST_HASH,\n                    docData\n                );\n                const ret = await getLastPullDocument(\n                    c,\n                    REPLICATION_IDENTIFIER_TEST_HASH\n                );\n                if (!ret) {\n                    throw new Error('last pull document missing');\n                }\n                assert.strictEqual(ret.name, 'foobar');\n                c.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should replicate both sides","suites":["replication.test.js",".getLastPullDocument()"],"updatePoint":{"line":438,"column":39},"line":438,"code":"        it('should replicate both sides', async () => {\n            const { localCollection, remoteCollection } = await getTestCollections({ local: 5, remote: 5 });\n\n            const replicationState = replicateRxCollection({\n                collection: localCollection,\n                replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                live: false,\n                pull: {\n                    handler: getPullHandler(remoteCollection)\n                },\n                push: {\n                    handler: getPushHandler(remoteCollection)\n                }\n            });\n            replicationState.error$.subscribe(err => {\n                console.log('got error :');\n                console.dir(err);\n            });\n            await replicationState.awaitInitialReplication();\n\n            const docsLocal = await localCollection.find().exec();\n            const docsRemote = await remoteCollection.find().exec();\n\n            assert.strictEqual(\n                docsLocal.length,\n                docsRemote.length\n            );\n            assert.strictEqual(\n                docsLocal.length,\n                10\n            );\n\n            localCollection.database.destroy();\n            remoteCollection.database.destroy();\n        });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should replicate all writes","suites":["replication.test.js",".getLastPullDocument()"],"updatePoint":{"line":475,"column":39},"line":475,"code":"        it('should replicate all writes', async () => {\n            const { localCollection, remoteCollection } = await getTestCollections({ local: 0, remote: 0 });\n\n            const replicationState = replicateRxCollection({\n                collection: localCollection,\n                replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                live: true,\n                pull: {\n                    handler: getPullHandler(remoteCollection)\n                },\n                push: {\n                    handler: getPushHandler(remoteCollection)\n                }\n            });\n            replicationState.error$.subscribe(err => {\n                console.log('got error :');\n                console.dir(err);\n            });\n            await replicationState.awaitInitialReplication();\n\n            const docsRemoteQuery = await remoteCollection.findOne();\n\n            // insert\n            const id = 'foobar';\n            const docData = schemaObjects.humanWithTimestamp({\n                id\n            });\n            const doc = await localCollection.insert(docData);\n            await waitUntil(async () => {\n                const remoteDoc = await docsRemoteQuery.exec();\n                return !!remoteDoc;\n            });\n\n            // UPDATE\n            await doc.atomicPatch({\n                age: 100\n            });\n            await waitUntil(async () => {\n                const remoteDoc = await docsRemoteQuery.exec(true);\n                return remoteDoc.age === 100;\n            });\n\n            // DELETE\n            await wait(100);\n            await doc.remove();\n            await waitUntil(async () => {\n                const remoteDoc = await docsRemoteQuery.exec();\n                return !remoteDoc;\n            });\n\n            localCollection.database.destroy();\n            remoteCollection.database.destroy();\n        });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should allow 0 value for liveInterval","suites":["replication.test.js",".getLastPullDocument()"],"updatePoint":{"line":528,"column":49},"line":528,"code":"        it('should allow 0 value for liveInterval', async () => {\n            const { localCollection, remoteCollection } = await getTestCollections({ local: 0, remote: 0 });\n            assert.doesNotThrow(async () => {\n                const replicationState = replicateRxCollection({\n                    collection: localCollection,\n                    replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                    live: true,\n                    liveInterval: 0,\n                    pull: {\n                        handler: getPullHandler(remoteCollection)\n                    },\n                    push: {\n                        handler: getPushHandler(remoteCollection)\n                    }\n                });\n                await replicationState.awaitInitialReplication();\n            });\n            localCollection.database.destroy();\n            remoteCollection.database.destroy();\n        });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should push data even if liveInterval is set to 0","suites":["replication.test.js",".getLastPullDocument()"],"updatePoint":{"line":548,"column":61},"line":548,"code":"        it('should push data even if liveInterval is set to 0', async () => {\n            const { localCollection, remoteCollection } = await getTestCollections({ local: 0, remote: 0 });\n            let callProof: string | null = null;\n            replicateRxCollection({\n                collection: localCollection,\n                replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                live: true,\n                liveInterval: 0,\n                autoStart: false,\n                push: {\n                    handler() {\n                        callProof = 'yeah';\n                        return Promise.resolve();\n                    }\n                },\n            });\n            // ensure proof is still null once replicateRxCollection()\n            assert.strictEqual(callProof, null, 'replicateRxCollection should not trigger a push on init.');\n\n            // insert a new doc to trigger a push\n            await localCollection.insert(schemaObjects.humanWithTimestamp());\n\n            /**\n             * At some time,\n             * the push handler should be called\n             */\n            await waitUntil(() => callProof === 'yeah');\n\n            localCollection.database.destroy();\n            remoteCollection.database.destroy();\n        });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should only make a request to the remote when the last pull time is older","suites":["replication.test.js",".notifyAboutRemoteChange()"],"updatePoint":{"line":581,"column":85},"line":581,"code":"        it('should only make a request to the remote when the last pull time is older', async () => {\n            const { localCollection, remoteCollection } = await getTestCollections({ local: 0, remote: 0 });\n\n            const replicationState = replicateRxCollection({\n                collection: localCollection,\n                replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                live: true,\n                liveInterval: 0,\n                pull: {\n                    handler: getPullHandler(remoteCollection)\n                },\n                push: {\n                    handler: async (docs) => {\n                        /**\n                         * When document data would be send to a remote server,\n                         * the server would emit an event over the websocket,\n                         * which should trigger a call to notifyAboutRemoteChange()\n                         * which is simulated here.\n                         */\n                        replicationState.notifyAboutRemoteChange();\n                        await wait(10);\n                        return getPushHandler(remoteCollection)(docs);\n                    }\n                }\n            });\n            await replicationState.awaitInitialReplication();\n\n            /**\n             * When notifyAboutRemoteChange() is called when no run is happening,\n             * it should trigger a new run() cycle. \n             */\n            let runCountBefore = replicationState.runCount;\n            await replicationState.notifyAboutRemoteChange();\n            assert.strictEqual(runCountBefore + 1, replicationState.runCount);\n\n            /**\n             * When notifyAboutRemoteChange() is called because\n             * the remote has emitted an event, it should not trigger a\n             * new run() cycle.\n             */\n            runCountBefore = replicationState.runCount;\n            await localCollection.insert(schemaObjects.humanWithTimestamp());\n            await wait(50);\n            /**\n             * Exactly 1 runCount should be added\n             * because notifyAboutRemoteChange() must not have triggered an additional new run() cycle.\n             */\n            assert.strictEqual(runCountBefore + 1, replicationState.runCount);\n\n            localCollection.database.destroy();\n            remoteCollection.database.destroy();\n        });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should run first replication by default","suites":["replication.test.js","autoStart"],"updatePoint":{"line":636,"column":55},"line":636,"code":"            it('should run first replication by default', async () => {\n                const replicationState = replicateRxCollection({\n                    collection: {\n                        database: {},\n                        onDestroy: { then() { } }\n                    } as RxCollection,\n                    replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                    live: false,\n                    autoStart: true,\n                    waitForLeadership: false\n                });\n                await replicationState.awaitInitialReplication();\n                assert.strictEqual(replicationState.runCount, 1);\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should not run first replication when autoStart is set to false","suites":["replication.test.js","autoStart"],"updatePoint":{"line":650,"column":79},"line":650,"code":"            it('should not run first replication when autoStart is set to false', async () => {\n                const replicationState = replicateRxCollection({\n                    collection: {\n                        database: {},\n                        onDestroy: { then() { } }\n                    } as RxCollection,\n                    replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                    live: false,\n                    autoStart: false,\n                    waitForLeadership: false\n                });\n\n                await wait(100);\n\n                // by definition awaitInitialReplication would be infinite\n                assert.strictEqual(replicationState.runCount, 0);\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should resolve after some time","suites":["replication.test.js",".awaitInSync()"],"updatePoint":{"line":669,"column":46},"line":669,"code":"            it('should resolve after some time', async () => {\n                const { localCollection, remoteCollection } = await getTestCollections({ local: 5, remote: 5 });\n\n                const replicationState = replicateRxCollection({\n                    collection: localCollection,\n                    replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                    live: false,\n                    pull: {\n                        handler: getPullHandler(remoteCollection)\n                    },\n                    push: {\n                        handler: getPushHandler(remoteCollection)\n                    }\n                });\n                await replicationState.awaitInSync();\n\n                localCollection.database.destroy();\n                remoteCollection.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should never resolve when offline","suites":["replication.test.js",".awaitInSync()"],"updatePoint":{"line":688,"column":49},"line":688,"code":"            it('should never resolve when offline', async () => {\n                const { localCollection, remoteCollection } = await getTestCollections({ local: 5, remote: 5 });\n\n                const replicationState = replicateRxCollection({\n                    collection: localCollection,\n                    replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                    live: false,\n                    pull: {\n                        handler: async () => {\n                            await wait(100);\n                            throw new Error('always error');\n                        }\n                    },\n                    push: {\n                        handler: getPushHandler(remoteCollection)\n                    }\n                });\n                let resolved = false;\n                replicationState.awaitInSync().then(() => {\n                    resolved = true;\n                });\n                await wait(config.isFastMode() ? 100 : 400);\n                assert.strictEqual(resolved, false);\n\n                localCollection.database.destroy();\n                remoteCollection.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should not create push checkpoints unnecessarily [PR: #3627]","suites":["replication.test.js",".awaitInSync()"],"updatePoint":{"line":718,"column":72},"line":718,"code":"        it('should not create push checkpoints unnecessarily [PR: #3627]', async () => {\n            const { localCollection, remoteCollection } =\n                await getTestCollections({ local: 5, remote: 5 });\n\n            const replicationState = replicateRxCollection({\n                collection: localCollection,\n                replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                live: false,\n                pull: {\n                    handler: getPullHandler(remoteCollection),\n                },\n                push: {\n                    handler: getPushHandler(remoteCollection),\n                },\n            });\n            replicationState.error$.subscribe((err) => {\n                console.log('got error :');\n                console.dir(err);\n            });\n\n            await replicationState.awaitInitialReplication();\n            await replicationState.run();\n\n            const originalSequence = await getLastPushCheckpoint(\n                localCollection,\n                REPLICATION_IDENTIFIER_TEST\n            );\n            // call .run() often\n            for (let i = 0; i < 3; i++) {\n                await replicationState.run()\n            }\n\n            const newSequence = await getLastPushCheckpoint(\n                localCollection,\n                REPLICATION_IDENTIFIER_TEST\n            );\n            assert.strictEqual(originalSequence, newSequence);\n            localCollection.database.destroy();\n            remoteCollection.database.destroy();\n        });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should re-run push if a local write happend between push and pull","suites":["replication.test.js",".awaitInSync()"],"updatePoint":{"line":764,"column":77},"line":764,"code":"        it('should re-run push if a local write happend between push and pull', async () => {\n            const { localCollection, remoteCollection } = await getTestCollections({ local: 0, remote: 0 });\n\n            // write to this document to track pushed and pulled data\n            const docData = schemaObjects.humanWithTimestamp();\n            docData.age = 0;\n            const doc = await localCollection.insert(docData);\n\n            /**\n             * To speed up this test,\n             * we do some stuff only after the initial replication is done.\n             */\n            let initalReplicationDone = false;\n\n            /**\n             * Track all pushed random values,\n             * so we can later ensure that no local write was non-pushed.\n             */\n            const pushedRandomValues: string[] = [];\n            let writeWhilePull = false;\n\n            const replicationState = replicateRxCollection({\n                collection: localCollection,\n                replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                live: false,\n                pull: {\n                    async handler(latestPulledDocument: RxDocumentData<TestDocType> | null) {\n                        /**\n                         * We simulate a write-while-pull-running\n                         * by just doing the write inside of the pull handler.\n                         */\n                        if (writeWhilePull) {\n                            await doc.atomicUpdate(docData => {\n                                docData.name = 'write-from-pull-handler';\n                                docData.age = docData.age + 1;\n                                return docData;\n                            });\n                            writeWhilePull = false;\n                        }\n                        return getPullHandler(remoteCollection)(latestPulledDocument);\n                    }\n                },\n                push: {\n                    async handler(docs: RxDocumentData<TestDocType>[]) {\n                        if (initalReplicationDone) {\n                            const randomValue = ensureNotFalsy(docs[0]).name;\n                            pushedRandomValues.push(randomValue);\n                        }\n                        return getPushHandler(remoteCollection)(docs);\n                    }\n                }\n            });\n            await replicationState.awaitInitialReplication();\n            initalReplicationDone = true;\n\n            await doc.atomicPatch({\n                name: 'before-run'\n            });\n            writeWhilePull = true;\n            await replicationState.run();\n\n            assert.strictEqual(\n                doc.name,\n                'write-from-pull-handler'\n            );\n\n            localCollection.database.destroy();\n            remoteCollection.database.destroy();\n        });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should not stack up run()-calls more then 2","suites":["replication.test.js",".awaitInSync()"],"updatePoint":{"line":833,"column":55},"line":833,"code":"        it('should not stack up run()-calls more then 2', async () => {\n            const { localCollection, remoteCollection } = await getTestCollections({ local: 0, remote: 0 });\n            const replicationState = replicateRxCollection({\n                collection: localCollection,\n                replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                live: false,\n                retryTime: 50,\n                pull: {\n                    async handler() {\n                        throw new Error('throw on pull');\n                    }\n                },\n                push: {\n                    async handler() {\n                        throw new Error('throw on push');\n                    }\n                }\n            });\n\n            // change replicationState._run to count the calls\n            const oldRun = replicationState._run.bind(replicationState);\n            let count = 0;\n            const newRun = function () {\n                count++;\n                return oldRun();\n            };\n            replicationState._run = newRun.bind(replicationState);\n\n            const amount = 50;\n            // call .run() often\n            await Promise.all(\n                new Array(amount).fill(0).map(\n                    () => replicationState.run()\n                )\n            );\n\n            await waitUntil(\n                () => replicationState.runQueueCount === 0\n            );\n            assert.ok(count < 10);\n\n            localCollection.database.destroy();\n            remoteCollection.database.destroy();\n        });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should not stack up failed runs and then run many times","suites":["replication.test.js",".awaitInSync()"],"updatePoint":{"line":877,"column":67},"line":877,"code":"        it('should not stack up failed runs and then run many times', async () => {\n            const { localCollection, remoteCollection } = await getTestCollections({ local: 0, remote: 0 });\n            let pullCount = 0;\n            let throwOnPull = false;\n            let startTracking = false;\n            const replicationState = replicateRxCollection({\n                collection: localCollection,\n                replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                live: false,\n                retryTime: 50,\n                pull: {\n                    async handler(latestPulledDocument: RxDocumentData<TestDocType> | null) {\n                        if (throwOnPull) {\n                            throw new Error('throwOnPull is true');\n                        }\n                        if (startTracking) {\n                            pullCount = pullCount + 1;\n                        }\n                        return getPullHandler(remoteCollection)(latestPulledDocument);\n                    }\n                },\n                push: {\n                    handler: getPushHandler(remoteCollection)\n                }\n            });\n            await replicationState.awaitInitialReplication();\n\n            // call run() many times but simulate an error on the pull handler.\n            throwOnPull = true;\n\n            let t = 0;\n            while (t < 100) {\n                t++;\n                await replicationState.run();\n            }\n\n            throwOnPull = false;\n            startTracking = true;\n\n\n            await wait(config.isFastMode() ? 200 : 500);\n\n\n            if (pullCount > 2) {\n                throw new Error('pullCount too height ' + pullCount);\n            }\n\n            localCollection.database.destroy();\n            remoteCollection.database.destroy();\n        });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"#3727 should not go into infinite push loop when number of changed requests equals to batchSize","suites":["replication.test.js",".awaitInSync()"],"updatePoint":{"line":930,"column":107},"line":930,"code":"        it('#3727 should not go into infinite push loop when number of changed requests equals to batchSize', async () => {\n            const MAX_PUSH_COUNT = 30 // arbitrary big number\n            const { localCollection, remoteCollection } = await getTestCollections({ local: 0, remote: 4 });\n            let pushCount = 0;\n            const replicationState = replicateRxCollection({\n                collection: localCollection,\n                replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                pull: {\n                    handler: getPullHandler(remoteCollection)\n                },\n                push: {\n                    batchSize: 5,\n                    handler: async (documents) => {\n                        pushCount++;\n\n                        if (pushCount > MAX_PUSH_COUNT) {\n                            // Exit push cycle. Otherwise test will never end\n                            throw new Error('Stop replication');\n                        }\n\n                        const ret = await getPushHandler(remoteCollection)(documents);\n                        return ret;\n                    }\n                }\n            });\n\n            await replicationState.awaitInitialReplication();\n            const docData = schemaObjects.humanWithTimestamp();\n            await localCollection.insert(docData)\n            await replicationState.run();\n\n            if (pushCount > MAX_PUSH_COUNT) {\n                throw new Error('Infinite push loop');\n            }\n\n            localCollection.database.destroy();\n            remoteCollection.database.destroy();\n        });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should not crash","suites":["static",".addCollections()"],"updatePoint":{"line":55,"column":32},"line":55,"code":"            it('should not crash', async () => {\n                const db = await getDb();\n                await db.addCollections({\n                    one: {\n                        schema: schemas.human\n                    },\n                    two: {\n                        schema: schemas.human\n                    }\n                });\n                assert.ok(isRxCollection(db.one));\n                assert.ok(isRxCollection(db.two));\n                db.destroy();\n            });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"human","suites":["static",".create()","positive"],"updatePoint":{"line":72,"column":25},"line":72,"code":"                it('human', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    await db.addCollections({\n                        human: {\n                            schema: schemas.human\n                        }\n                    });\n                    const collection = db.collections.human;\n                    assert.ok(isRxCollection(collection));\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should create compound-indexes (keyCompression: false)","suites":["static",".create()","positive"],"updatePoint":{"line":86,"column":74},"line":86,"code":"                it('should create compound-indexes (keyCompression: false)', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const schemaJSON = clone(schemas.compoundIndex);\n                    schemaJSON.keyCompression = false;\n\n                    await db.addCollections({\n                        human: {\n                            schema: schemaJSON\n                        }\n                    });\n                    const collection = db.collections.human;\n                    const indexes = await collection.storageInstance.internals.pouch.getIndexes();\n                    assert.strictEqual(indexes.indexes.length, 2);\n                    const lastIndexDefFields = indexes.indexes[1].def.fields;\n                    assert.deepStrictEqual(\n                        lastIndexDefFields,\n                        [\n                            { 'age': 'asc' },\n                            { 'passportCountry': 'asc' },\n                            // the primaryKey index will always be added by RxDB\n                            { _id: 'asc' }\n                        ]\n                    );\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should create compound-indexes (keyCompression: true)","suites":["static",".create()","positive"],"updatePoint":{"line":114,"column":73},"line":114,"code":"                it('should create compound-indexes (keyCompression: true)', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    await db.addCollections({\n                        human: {\n                            schema: schemas.compoundIndex\n                        }\n                    });\n                    const collection = db.collections.human;\n                    const indexes = await collection.storageInstance.internals.pouch.getIndexes();\n                    assert.strictEqual(indexes.indexes.length, 2);\n                    const lastIndexDefFields = indexes.indexes[1].def.fields;\n                    assert.deepStrictEqual(\n                        lastIndexDefFields, [\n                        { 'age': 'asc' },\n                        { '|a': 'asc' },\n                        // the primaryKey index will always be added by RxDB\n                        { _id: 'asc' }\n                    ]\n                    );\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should have the version-number in the pouchdb-prefix","suites":["static",".create()","positive"],"updatePoint":{"line":138,"column":72},"line":138,"code":"                it('should have the version-number in the pouchdb-prefix', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    await db.addCollections({\n                        human: {\n                            schema: schemas.human\n                        }\n                    });\n                    const collection = db.collections.human;\n                    assert.deepStrictEqual(schemas.human.version, 0);\n                    assert.ok(collection.storageInstance.internals.pouch.name.includes('-' + schemas.human.version + '-'));\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not forget the options","suites":["static",".create()","positive"],"updatePoint":{"line":153,"column":49},"line":153,"code":"                it('should not forget the options', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.human,\n                            options: {\n                                foo: 'bar'\n                            }\n                        }\n                    });\n                    assert.strictEqual(collections.human.options.foo, 'bar');\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"allow not allow lodash","suites":["static",".checkCollectionName()","positive"],"updatePoint":{"line":173,"column":42},"line":173,"code":"                it('allow not allow lodash', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    await AsyncTestUtil.assertThrows(\n                        () => db.addCollections({\n                            _foobar: {\n                                schema: schemas.human\n                            }\n                        }),\n                        'RxError',\n                        'foobar'\n                    );\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"allow numbers","suites":["static",".checkCollectionName()","positive"],"updatePoint":{"line":189,"column":33},"line":189,"code":"                it('allow numbers', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    await db.addCollections({\n                        fooba4r: {\n                            schema: schemas.human\n                        },\n                        foobar4: {\n                            schema: schemas.human\n                        }\n                    });\n                    assert.ok(isRxCollection(db.collections.fooba4r));\n                    assert.ok(isRxCollection(db.collections.foobar4));\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"not allow starting numbers","suites":["static",".checkCollectionName()","negative"],"updatePoint":{"line":208,"column":46},"line":208,"code":"                it('not allow starting numbers', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    await AsyncTestUtil.assertThrows(\n                        () => db.addCollections({\n                            '0foobar': {\n                                schema: schemas.human\n                            }\n                        }),\n                        'RxError'\n                    );\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"not allow uppercase-letters","suites":["static",".checkCollectionName()","negative"],"updatePoint":{"line":223,"column":47},"line":223,"code":"                it('not allow uppercase-letters', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    await AsyncTestUtil.assertThrows(\n                        () => db.addCollections({\n                            'Foobar': {\n                                schema: schemas.human\n                            }\n                        }),\n                        'RxError'\n                    );\n                    await AsyncTestUtil.assertThrows(\n                        () => db.addCollections({\n                            'fooBar': {\n                                schema: schemas.human\n                            }\n                        }),\n                        'RxError'\n                    );\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should insert a human","suites":["instance",".insert()","positive"],"updatePoint":{"line":252,"column":41},"line":252,"code":"                it('should insert a human', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.human\n                        }\n                    });\n                    await collections.human.insert(schemaObjects.human());\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should insert nested human","suites":["instance",".insert()","positive"],"updatePoint":{"line":265,"column":46},"line":265,"code":"                it('should insert nested human', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        nestedhuman: {\n                            schema: schemas.nestedHuman\n                        }\n                    });\n                    await collections.nestedhuman.insert(schemaObjects.nestedHuman());\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should insert more than once","suites":["instance",".insert()","positive"],"updatePoint":{"line":278,"column":48},"line":278,"code":"                it('should insert more than once', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        nestedhuman: {\n                            schema: schemas.nestedHuman\n                        }\n                    });\n                    for (let i = 0; i < 10; i++) {\n                        await collections.nestedhuman.insert(schemaObjects.nestedHuman());\n                    }\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should set default values","suites":["instance",".insert()","positive"],"updatePoint":{"line":293,"column":45},"line":293,"code":"                it('should set default values', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        nestedhuman: {\n                            schema: schemas.humanDefault\n                        }\n                    });\n\n                    const data = {\n                        passportId: 'foobar',\n                    };\n                    await collections.nestedhuman.insert(data);\n                    const doc = await collections.nestedhuman.findOne().exec(true);\n                    assert.strictEqual((doc as any).age, 20);\n\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not insert broken human (required missing)","suites":["instance",".insert()","negative"],"updatePoint":{"line":315,"column":69},"line":315,"code":"                it('should not insert broken human (required missing)', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.human\n                        }\n                    });\n                    const human: any = schemaObjects.human();\n                    delete human.firstName;\n                    await AsyncTestUtil.assertThrows(\n                        () => collections.human.insert(human),\n                        'RxError',\n                        'not match schema'\n                    );\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not insert human with additional prop","suites":["instance",".insert()","negative"],"updatePoint":{"line":334,"column":64},"line":334,"code":"                it('should not insert human with additional prop', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.human\n                        }\n                    });\n                    const human: any = schemaObjects.human();\n                    human['any'] = randomCouchString(20);\n                    await AsyncTestUtil.assertThrows(\n                        () => collections.human.insert(human),\n                        'RxError',\n                        'not match schema'\n                    );\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not insert when primary is missing","suites":["instance",".insert()","negative"],"updatePoint":{"line":353,"column":61},"line":353,"code":"                it('should not insert when primary is missing', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    await AsyncTestUtil.assertThrows(\n                        () => collections.human.insert({\n                            firstName: 'foo',\n                            lastName: 'bar',\n                            age: 20\n                        }),\n                        'RxError',\n                        'is required'\n                    );\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should throw a conflict-error","suites":["instance",".insert()","negative"],"updatePoint":{"line":374,"column":49},"line":374,"code":"                it('should throw a conflict-error', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    const docData = schemaObjects.human();\n                    await collection.insert(docData);\n\n                    const err: RxError = await AsyncTestUtil.assertThrows(\n                        () => collection.insert(docData),\n                        'RxError',\n                        'conflict'\n                    ) as any;\n                    assert.deepStrictEqual(err.parameters.id, docData.passportId);\n\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should insert some humans","suites":["instance",".bulkInsert()","positive"],"updatePoint":{"line":401,"column":45},"line":401,"code":"                it('should insert some humans', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.human\n                        }\n                    });\n                    const docs = new Array(10).fill(0).map(() => schemaObjects.human());\n                    const ret = await collections.human.bulkInsert(docs);\n\n                    assert.strictEqual(ret.success.length, 10);\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not throw when called with an empty array","suites":["instance",".bulkInsert()","positive"],"updatePoint":{"line":417,"column":68},"line":417,"code":"                it('should not throw when called with an empty array', async () => {\n                    const col = await humansCollection.create(0);\n                    await col.bulkInsert([]);\n                    col.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should throw if one already exists","suites":["instance",".bulkInsert()","negative"],"updatePoint":{"line":424,"column":54},"line":424,"code":"                it('should throw if one already exists', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    const double = schemaObjects.human();\n                    double.passportId = 'foobar';\n                    await collection.insert(double);\n                    const docs = new Array(10).fill(0).map(() => schemaObjects.human());\n                    docs.push(double);\n                    const ret = await collection.bulkInsert(docs);\n\n                    assert.strictEqual(ret.success.length, 10);\n                    assert.strictEqual(ret.error.length, 1);\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find all","suites":["instance",".find()","find all","positive"],"updatePoint":{"line":451,"column":32},"line":451,"code":"                    it('find all', async () => {\n                        const c = await humansCollection.create();\n                        const docs = await c.find().exec();\n                        assert.ok(docs.length >= 10);\n                        for (const doc of docs) {\n                            assert.ok(isRxDocument(doc));\n                        }\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find 2 times","suites":["instance",".find()","find all","positive"],"updatePoint":{"line":460,"column":36},"line":460,"code":"                    it('find 2 times', async () => {\n                        const c = await humansCollection.create();\n                        const docs = await c.find().exec();\n                        const docs2 = await c.find().exec();\n                        assert.ok(docs.length >= 10);\n                        assert.ok(docs2.length >= 10);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find all by empty object","suites":["instance",".find()","find all","positive"],"updatePoint":{"line":481,"column":48},"line":481,"code":"                    it('find all by empty object', async () => {\n                        const c = await humansCollection.create();\n                        const docs = await c.find().exec();\n                        assert.ok(docs.length >= 10);\n                        for (const doc of docs) {\n                            assert.ok(isRxDocument(doc));\n                        }\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find nothing with empty collection","suites":["instance",".find()","find all","positive"],"updatePoint":{"line":490,"column":58},"line":490,"code":"                    it('find nothing with empty collection', async () => {\n                        const db = await createRxDatabase({\n                            name: randomCouchString(10),\n                            storage: getRxStoragePouch('memory'),\n                        });\n                        await db.addCollections({\n                            humanx: {\n                                schema: schemas.human\n                            }\n                        });\n                        const collection = db.humanx;\n                        const docs = await collection.find().exec();\n                        assert.deepStrictEqual(docs, []);\n                        db.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"BUG: insert and find very often","suites":["instance",".find()","find all","positive"],"updatePoint":{"line":505,"column":55},"line":505,"code":"                    it('BUG: insert and find very often', async () => {\n                        const amount = 10;\n                        for (let i = 0; i < amount; i++) {\n                            const db = await createRxDatabase({\n                                name: randomCouchString(10),\n                                storage: getRxStoragePouch('memory'),\n                            });\n                            const collections = await db.addCollections({\n                                human: {\n                                    schema: schemas.human\n                                }\n                            });\n                            const collection = collections.human;\n                            const human = schemaObjects.human();\n                            const passportId = human.passportId;\n                            await collection.insert(human);\n                            const docs = await collection.find().exec();\n                            const doc = docs[0];\n                            assert.strictEqual(passportId, (doc as any)._data.passportId);\n                            db.destroy();\n                        }\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should crash with string as query","suites":["instance",".find()","find all","negative"],"updatePoint":{"line":529,"column":57},"line":529,"code":"                    it('should crash with string as query', async () => {\n                        const c = await humansCollection.create();\n                        await AsyncTestUtil.assertThrows(\n                            () => (c as any).find('foobar').exec(),\n                            'RxError',\n                            'findOne'\n                        );\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should crash with array as query","suites":["instance",".find()","find all","negative"],"updatePoint":{"line":538,"column":56},"line":538,"code":"                    it('should crash with array as query', async () => {\n                        const c = await humansCollection.create();\n                        await AsyncTestUtil.assertThrows(\n                            () => (c as any).find([]).exec(),\n                            'RxTypeError'\n                        );\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find first by passportId","suites":["instance",".find()","$eq","positive"],"updatePoint":{"line":550,"column":48},"line":550,"code":"                    it('find first by passportId', async () => {\n                        const c = await humansCollection.create();\n                        let docs = await c.find().exec();\n                        docs = shuffleArray(docs);\n                        const last: any = docs.pop();\n                        const passportId = last._data.passportId;\n                        let doc: any = await c.find({\n                            selector: {\n                                passportId\n                            }\n                        }).exec();\n                        assert.strictEqual(doc.length, 1);\n                        doc = doc[0];\n                        assert.deepStrictEqual(doc['data'], last.data);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find none with random passportId","suites":["instance",".find()","$eq","positive"],"updatePoint":{"line":566,"column":56},"line":566,"code":"                    it('find none with random passportId', async () => {\n                        const c = await humansCollection.create();\n                        const query = c.find({\n                            selector: {\n                                passportId: randomCouchString(10)\n                            }\n                        });\n                        const docs = await query.exec();\n                        assert.strictEqual(docs.length, 0);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find via $eq","suites":["instance",".find()","$eq","positive"],"updatePoint":{"line":577,"column":36},"line":577,"code":"                    it('find via $eq', async () => {\n                        const c = await humansCollection.create();\n                        let docs = await c.find().exec();\n                        docs = shuffleArray(docs);\n                        const last: any = docs.pop();\n                        const passportId = last._data.passportId;\n                        let doc: any = await c.find({\n                            selector: {\n                                passportId: {\n                                    $eq: passportId\n                                }\n                            }\n                        }).exec();\n                        assert.strictEqual(doc.length, 1);\n                        doc = doc[0];\n                        assert.deepStrictEqual(doc['data'], last.data);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should find the 2 documents with the or-method","suites":["instance",".find()",".or()"],"updatePoint":{"line":599,"column":66},"line":599,"code":"                it('should find the 2 documents with the or-method', async () => {\n                    const c = await humansCollection.create(10);\n                    // add 2 docs to be found\n                    await c.insert({\n                        passportId: randomString(12),\n                        firstName: 'foobarAlice',\n                        lastName: 'aliceLastName',\n                        age: randomNumber(10, 50)\n                    });\n                    await c.insert({\n                        passportId: randomString(12),\n                        firstName: 'foobarBob',\n                        lastName: 'bobLastName',\n                        age: randomNumber(10, 50)\n                    });\n                    const query = c.find().or([{\n                        firstName: 'foobarAlice'\n                    }, {\n                        firstName: 'foobarBob'\n                    }]);\n\n                    const results = await query.exec();\n                    assert.strictEqual(results.length, 2);\n                    const foundFirstNames = results.map(doc => doc.firstName);\n                    assert.ok(foundFirstNames.includes('foobarAlice'));\n                    assert.ok(foundFirstNames.includes('foobarBob'));\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should find the correct documents via $or on the primary key","suites":["instance",".find()",".or()"],"updatePoint":{"line":627,"column":80},"line":627,"code":"                it('should find the correct documents via $or on the primary key', async () => {\n                    const c = await humansCollection.createPrimary(10);\n                    const allDocs = await c.find().exec();\n                    const firstFive = allDocs.slice(0, 5);\n                    const selector = {\n                        $or: firstFive.map(doc => ({ passportId: doc.passportId }))\n                    };\n                    const found = await c.find({\n                        selector\n                    }).exec();\n\n                    assert.strictEqual(firstFive.length, found.length);\n                    const firstId = firstFive[0].passportId;\n                    assert.ok(\n                        found.map(d => d.passportId).includes(firstId)\n                    );\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"sort by age desc (with own index-search)","suites":["instance",".find()",".sort()","positive"],"updatePoint":{"line":648,"column":64},"line":648,"code":"                    it('sort by age desc (with own index-search)', async () => {\n                        const c = await humansCollection.createAgeIndex();\n                        const query = c.find({\n                            selector: {\n                                age: {\n                                    $gt: 0\n                                }\n                            }\n                        }).sort({ age: 'desc' });\n\n                        assert.ok(isRxQuery(query));\n                        const docs = await query.exec();\n                        assert.strictEqual(docs.length, 20);\n                        assert.ok(ensureNotFalsy(docs[0]._data.age) >= ensureNotFalsy(docs[1]._data.age));\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"sort by age desc (with default index-search)","suites":["instance",".find()",".sort()","positive"],"updatePoint":{"line":664,"column":68},"line":664,"code":"                    it('sort by age desc (with default index-search)', async () => {\n                        const c = await humansCollection.createAgeIndex();\n                        const docs = await c.find().sort({\n                            age: 'desc'\n                        }).exec();\n                        assert.strictEqual(docs.length, 20);\n                        assert.ok(ensureNotFalsy(docs[0]._data.age) >= ensureNotFalsy(docs[1]._data.age));\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"sort by age asc","suites":["instance",".find()",".sort()","positive"],"updatePoint":{"line":673,"column":39},"line":673,"code":"                    it('sort by age asc', async () => {\n                        const c = await humansCollection.createAgeIndex();\n                        const docs = await c.find().sort({\n                            age: 'asc'\n                        }).exec();\n                        assert.strictEqual(docs.length, 20);\n                        assert.ok(ensureNotFalsy(docs[0]._data.age) <= ensureNotFalsy(docs[1]._data.age));\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"sort by non-top-level-key as index (no keycompression)","suites":["instance",".find()",".sort()","positive"],"updatePoint":{"line":682,"column":78},"line":682,"code":"                    it('sort by non-top-level-key as index (no keycompression)', async () => {\n                        const db = await createRxDatabase({\n                            name: randomCouchString(10),\n                            storage: getRxStoragePouch('memory'),\n                        });\n                        const schemaObj = clone(schemas.humanSubIndex);\n                        schemaObj.keyCompression = false;\n                        await db.addCollections({\n                            human: {\n                                schema: schemaObj\n                            }\n                        });\n                        const collection = db.human;\n                        const objects = new Array(10).fill(0).map(() => {\n                            return {\n                                passportId: randomCouchString(10),\n                                other: {\n                                    age: randomNumber(10, 50)\n                                }\n                            };\n                        });\n                        await Promise.all(objects.map(o => collection.insert(o)));\n\n                        // do it manually\n                        const all = await collection.storageInstance.internals.pouch.find({\n                            selector: {\n                                'other.age': {\n                                    '$gt': 0\n                                }\n                            },\n                            sort: [\n                                { 'other.age': 'asc' },\n                                { _id: 'asc' }\n                            ]\n                        });\n                        assert.strictEqual(all.docs.length, 10);\n\n                        // with RxQuery\n                        const query = collection.find().sort({\n                            'other.age': 'asc'\n                        });\n                        const docs = await query.exec();\n\n                        let lastAge = 0;\n                        docs.forEach((doc: any) => {\n                            assert.ok(doc.other.age >= lastAge);\n                            lastAge = doc.other.age;\n                        });\n                        db.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"sort by non-top-level-key as index (with keycompression)","suites":["instance",".find()",".sort()","positive"],"updatePoint":{"line":732,"column":80},"line":732,"code":"                    it('sort by non-top-level-key as index (with keycompression)', async () => {\n                        const db = await createRxDatabase({\n                            name: randomCouchString(10),\n                            storage: getRxStoragePouch('memory'),\n                        });\n                        await db.addCollections({\n                            human: {\n                                schema: schemas.humanSubIndex\n                            }\n                        });\n                        const collection = db.human;\n                        const objects = new Array(10).fill(0).map(() => {\n                            return {\n                                passportId: randomCouchString(10),\n                                other: {\n                                    age: randomNumber(10, 50)\n                                }\n                            };\n                        });\n                        await Promise.all(objects.map(o => collection.insert(o)));\n\n                        // with RxQuery\n                        const query = collection.find().sort({\n                            'other.age': 'asc'\n                        });\n                        const docs = await query.exec();\n\n                        let lastAge = 0;\n                        docs.forEach((doc: any) => {\n                            assert.ok(doc.other.age >= lastAge);\n                            lastAge = doc.other.age;\n                        });\n                        db.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"validate results","suites":["instance",".find()",".sort()","positive"],"updatePoint":{"line":766,"column":40},"line":766,"code":"                    it('validate results', async () => {\n                        const c = await humansCollection.createAgeIndex(0);\n                        const docsData = new Array(10)\n                            .fill(0)\n                            .map((_v, idx) => {\n                                const docData = schemaObjects.human();\n                                docData.age = idx + 10;\n                                return docData;\n                            });\n                        await c.bulkInsert(docsData);\n\n                        const desc = await c.find().sort({\n                            age: 'desc'\n                        }).exec();\n                        const asc = await c.find().sort({\n                            age: 'asc'\n                        }).exec();\n                        const ascIds = asc.map(d => d.primary);\n                        const descIds = desc.map(d => d.primary);\n                        const reverseDescIds = descIds.slice(0).reverse();\n\n                        assert.deepStrictEqual(ascIds, reverseDescIds);\n\n                        /**\n                         * TODO Here we have increasing age-values for the test data.\n                         * But we also should include two documents with the same age,\n                         * to ensure the sorting is deterministic. But this fails\n                         * for the pouchdb RxStorage at this point in time.\n                         */\n\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find the same twice","suites":["instance",".find()",".sort()","positive"],"updatePoint":{"line":798,"column":43},"line":798,"code":"                    it('find the same twice', async () => {\n                        const c = await humansCollection.createNested(5);\n                        const doc1 = await c.findOne().sort({\n                            passportId: 'asc'\n                        }).exec(true);\n                        const doc2 = await c.findOne().sort({\n                            passportId: 'asc'\n                        }).exec(true);\n                        assert.strictEqual(doc1._data.passportId, doc2._data.passportId);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"sort by compound index with id","suites":["instance",".find()",".sort()","positive"],"updatePoint":{"line":809,"column":54},"line":809,"code":"                    it('sort by compound index with id', async () => {\n                        const c = await humansCollection.createIdAndAgeIndex();\n                        const query = c.find({\n                            selector: {\n                                age: {\n                                    $gt: 0\n                                }\n                            }\n                        }).sort({\n                            age: 'desc',\n                            id: 'desc'\n                        });\n\n                        assert.ok(isRxQuery(query));\n                        const docs = await query.exec();\n\n                        assert.strictEqual(docs.length, 20);\n                        assert.ok(\n                            docs[0]._data.age > docs[1]._data.age ||\n                            (\n                                docs[0]._data.age === docs[1]._data.age &&\n                                docs[0]._data.id > docs[1]._data.id\n                            )\n                        );\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"throw when sort is not index","suites":["instance",".find()",".sort()","negative"],"updatePoint":{"line":837,"column":52},"line":837,"code":"                    it('throw when sort is not index', async () => {\n                        if (config.storage.name !== 'pouchdb') {\n                            return;\n                        }\n                        const c = await humansCollection.create();\n                        await c.find().exec();\n                        await AsyncTestUtil.assertThrows(\n                            () => c.find({\n                                selector: {\n                                    age: {\n                                        $gt: 0\n                                    }\n                                }\n                            })\n                                .sort({\n                                    age: 'desc'\n                                })\n                                .exec(),\n                            Error\n                        );\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"#146 throw when field not in schema (object)","suites":["instance",".find()",".sort()","negative"],"updatePoint":{"line":859,"column":68},"line":859,"code":"                    it('#146 throw when field not in schema (object)', async () => {\n                        if (config.storage.name !== 'pouchdb') {\n                            return;\n                        }\n                        const c = await humansCollection.createAgeIndex();\n                        await AsyncTestUtil.assertThrows(\n                            () => c.find().sort({\n                                foobar: 'desc'\n                            }).exec(),\n                            'RxError',\n                            'not defined in the schema'\n                        );\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"#146 throw when field not in schema (string)","suites":["instance",".find()",".sort()","negative"],"updatePoint":{"line":873,"column":68},"line":873,"code":"                    it('#146 throw when field not in schema (string)', async () => {\n                        if (config.storage.name !== 'pouchdb') {\n                            return;\n                        }\n                        const c = await humansCollection.createAgeIndex();\n                        await AsyncTestUtil.assertThrows(\n                            () => c.find().sort('foobar').exec(),\n                            'RxError',\n                            'not defined in the schema'\n                        );\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"get first","suites":["instance",".find()",".limit()","positive"],"updatePoint":{"line":889,"column":33},"line":889,"code":"                    it('get first', async () => {\n                        const c = await humansCollection.create();\n                        const docs = await c.find().limit(1).exec();\n                        assert.strictEqual(docs.length, 1);\n                        assert.ok(isRxDocument(docs[0]));\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"get last in order","suites":["instance",".find()",".limit()","positive"],"updatePoint":{"line":896,"column":41},"line":896,"code":"                    it('get last in order', async () => {\n                        const c = await humansCollection.create(10);\n                        const docs = await c.find().sort({\n                            passportId: 'asc'\n                        }).exec();\n                        let firstDoc: any = await c.find().sort({\n                            passportId: 'asc'\n                        }).limit(1).exec();\n                        firstDoc = firstDoc[0];\n\n                        let last: any = await c.find().sort({\n                            passportId: 'desc'\n                        }).limit(1).exec();\n                        last = last[0];\n\n                        assert.strictEqual(last['_data'].passportId, docs[(docs.length - 1)]._data.passportId);\n                        assert.notStrictEqual(firstDoc['_data'].passportId, last['_data'].passportId);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"reset limit with .limit(null)","suites":["instance",".find()",".limit()","positive"],"updatePoint":{"line":915,"column":53},"line":915,"code":"                    it('reset limit with .limit(null)', async () => {\n                        const c = await humansCollection.create();\n                        const docs = await c.find().limit(1).limit(null).exec();\n                        assert.ok(docs.length > 1);\n                        assert.ok(isRxDocument(docs[0]));\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"skip first","suites":["instance",".find()",".skip()","positive"],"updatePoint":{"line":926,"column":34},"line":926,"code":"                    it('skip first', async () => {\n                        const c = await humansCollection.create(\n                            2,\n                            randomCouchString(10),\n                            false,\n                            false\n                        );\n\n                        const query: any = {\n                            selector: {\n                                passportId: {\n                                    /**\n                                     * TODO The skip-query randomly returns wrong results\n                                     * when this $ne is not set.\n                                     * We should create an issue at the pouchdb repo.\n                                     */\n                                    $ne: RANDOM_STRING\n                                }\n                            },\n                            sort: [\n                                { passportId: 'asc' }\n                            ]\n                        };\n\n                        const docs = await c.find(query).exec();\n                        const noFirstQuery = c.find(query).skip(1);\n                        const noFirst = await noFirstQuery.exec();\n\n                        assert.strictEqual(noFirst.length, 1);\n                        assert.strictEqual(noFirst[0]._data.passportId, docs[1]._data.passportId);\n                        c.database.destroy();\n\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"skip first in order","suites":["instance",".find()",".skip()","positive"],"updatePoint":{"line":959,"column":43},"line":959,"code":"                    it('skip first in order', async () => {\n                        /**\n                         * TODO this test fails on pouchdb when the schema contains an index.\n                         * Likely because pouchdb then skips the internal index-document, not the\n                         * human documents, which then returns wrong results.\n                         * Wait for the next pouchdb release and then try again,\n                         * or create an issue at the pouchdb repo.\n                         */\n                        // const c = humansCollection.create(5);\n\n                        const db = await createRxDatabase<{ humans: RxCollection<HumanDocumentType> }>({\n                            name: randomCouchString(10),\n                            storage: config.storage.getStorage(),\n                            eventReduce: true\n                        });\n                        const collections = await db.addCollections({\n                            humans: {\n                                schema: schemas.humanDefault\n                            }\n                        });\n                        const c = collections.humans;\n                        await Promise.all(\n                            new Array(5)\n                                .fill(0)\n                                .map(() => c.insert(schemaObjects.human()))\n                        );\n\n                        const docs = await c.find().sort({\n                            passportId: 'asc'\n                        }).exec();\n                        const noFirst = await c.find().sort({\n                            passportId: 'asc'\n                        }).skip(1).exec();\n\n                        assert.strictEqual(noFirst[0]._data.passportId, docs[1]._data.passportId);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"reset skip with .skip(null)","suites":["instance",".find()",".skip()","positive"],"updatePoint":{"line":1022,"column":51},"line":1022,"code":"                    it('reset skip with .skip(null)', async () => {\n                        const c = await humansCollection.create();\n                        const docs = await c.find().exec();\n                        const noFirst = await c.find().skip(1).skip(null).exec();\n                        assert.notStrictEqual(noFirst[0]._data.passportId, docs[1]._data.passportId);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find the one where the regex matches","suites":["instance",".find()",".regex()","positive"],"updatePoint":{"line":1037,"column":60},"line":1037,"code":"                    it('find the one where the regex matches', async () => {\n                        const c = await humansCollection.create(10);\n                        const matchHuman = schemaObjects.human();\n                        matchHuman.firstName = 'FooMatchBar';\n                        await c.insert(matchHuman);\n                        const docs = await c.find()\n                            .where('firstName').regex(/Match/)\n                            .exec();\n                        assert.strictEqual(docs.length, 1);\n                        const firstDoc = docs[0];\n                        assert.strictEqual(firstDoc.get('firstName'), matchHuman.firstName);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"case sensitive regex","suites":["instance",".find()",".regex()","positive"],"updatePoint":{"line":1050,"column":44},"line":1050,"code":"                    it('case sensitive regex', async () => {\n                        const c = await humansCollection.create(10);\n                        const matchHuman = schemaObjects.human();\n                        matchHuman.firstName = 'FooMatchBar';\n                        await c.insert(matchHuman);\n                        const docs = await c.find()\n                            .where('firstName').regex(/match/i)\n                            .exec();\n\n                        assert.strictEqual(docs.length, 1);\n                        const firstDoc = docs[0];\n                        assert.strictEqual(firstDoc.get('firstName'), matchHuman.firstName);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"regex on index","suites":["instance",".find()",".regex()","positive"],"updatePoint":{"line":1064,"column":38},"line":1064,"code":"                    it('regex on index', async () => {\n                        const c = await humansCollection.create(10);\n                        const matchHuman = schemaObjects.human();\n                        matchHuman.firstName = 'FooMatchBar';\n                        await c.insert(matchHuman);\n                        const docs = await c.find()\n                            .where('firstName').regex(/Match/)\n                            .exec();\n\n                        assert.strictEqual(docs.length, 1);\n                        const firstDoc = docs[0];\n                        assert.strictEqual(firstDoc.get('firstName'), matchHuman.firstName);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"regex on primary should throw","suites":["instance",".find()",".regex()","negative"],"updatePoint":{"line":1083,"column":53},"line":1083,"code":"                    it('regex on primary should throw', async () => {\n                        if (!config.storage.hasRegexSupport) {\n                            return;\n                        }\n\n                        // TODO run this check in dev-mode so it behaves equal on all storage implementations.\n                        if (config.storage.name !== 'pouchdb') {\n                            return;\n                        }\n                        const c = await humansCollection.createPrimary(0);\n                        await AsyncTestUtil.assertThrows(\n                            () => c.find().where('passportId').regex(/Match/).exec(),\n                            'RxError',\n                            'regex'\n                        );\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should remove all documents","suites":["instance",".find()",".remove()"],"updatePoint":{"line":1103,"column":47},"line":1103,"code":"                it('should remove all documents', async () => {\n                    const c = await humansCollection.create(10);\n                    const query = c.find();\n                    const removed = await query.remove();\n                    assert.strictEqual(removed.length, 10);\n                    removed.forEach(doc => {\n                        assert.ok(isRxDocument(doc));\n                        assert.strictEqual(doc.deleted, true);\n                    });\n                    const docsAfter = await c.find().exec();\n                    assert.strictEqual(docsAfter.length, 0);\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should remove only found documents","suites":["instance",".find()",".remove()"],"updatePoint":{"line":1116,"column":54},"line":1116,"code":"                it('should remove only found documents', async () => {\n                    const c = await humansCollection.create(10);\n                    const query = c.find().limit(5);\n                    const removed = await query.remove();\n                    assert.strictEqual(removed.length, 5);\n                    removed.forEach(doc => {\n                        assert.ok(isRxDocument(doc));\n                        assert.strictEqual(doc.deleted, true);\n                    });\n                    const docsAfter = await c.find().exec();\n                    assert.strictEqual(docsAfter.length, 5);\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"remove on findOne","suites":["instance",".find()",".remove()"],"updatePoint":{"line":1129,"column":37},"line":1129,"code":"                it('remove on findOne', async () => {\n                    const c = await humansCollection.create(10);\n                    const query = c.findOne();\n                    const removed: any = await query.remove();\n                    assert.ok(isRxDocument(removed));\n                    assert.strictEqual(removed.deleted, true);\n                    const docsAfter = await c.find().exec();\n                    assert.strictEqual(docsAfter.length, 9);\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"#3785 should work when the collection name contains a dash or other special characters","suites":["instance",".find()",".remove()"],"updatePoint":{"line":1142,"column":106},"line":1142,"code":"                it('#3785 should work when the collection name contains a dash or other special characters', async () => {\n                    if (!config.storage.hasPersistence) {\n                        return;\n                    }\n\n                    const collectionNames: string[] = [\n                        'name_with_a_-_in',\n                        'name_no_dash',\n                        'dollar$collection'\n                    ].sort();\n\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                    });\n\n\n\n                    const collectionsCreator: { [k: string]: RxCollectionCreator } = {};\n                    collectionNames.forEach(collectionName => {\n                        collectionsCreator[collectionName] = {\n                            schema: schemas.human\n                        };\n                    });\n                    await db.addCollections(collectionsCreator);\n\n                    /**\n                     * Add a document to each collection\n                     */\n                    const docData = schemaObjects.simpleHuman();\n                    await Promise.all(\n                        Object.keys(db.collections).map(collectionName => {\n                            return db.collections[collectionName].insert(docData);\n                        })\n                    );\n\n                    const removedCollections = await db.remove();\n\n                    assert.deepStrictEqual(\n                        removedCollections.sort(),\n                        collectionNames\n                    );\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"#3788 removing the collection should also remove all changes","suites":["instance",".find()",".remove()"],"updatePoint":{"line":1188,"column":80},"line":1188,"code":"                it('#3788 removing the collection should also remove all changes', async () => {\n                    if (!config.storage.hasMultiInstance) {\n                        return;\n                    }\n\n                    const dbName = randomCouchString();\n\n                    const createDb = async () => {\n                        const db = await createRxDatabase({\n                            name: dbName,\n                            storage: config.storage.getStorage(),\n                            ignoreDuplicate: true\n                        });\n                        await db.addCollections({\n                            'human-2': { schema: schemas.human }\n                        });\n                        return db;\n                    }\n\n                    const db1 = await createDb();\n                    await db1.collections['human-2'].insert(schemaObjects.simpleHuman());\n                    const db2 = await createDb();\n\n                    // remove the collection on one database\n                    await db1['human-2'].remove();\n\n                    /**\n                     * Getting the changes in the other database should have an empty result.\n                     * This cannot be checked on pouchdb\n                     * because the pouchdb storage will not resolve anytime\n                     * when the storage was removed in the other instance.\n                     */\n                    if (config.storage.name !== 'pouchdb') {\n                        const changesResult = await db2['human-2'].storageInstance.getChangedDocumentsSince(10);\n                        assert.strictEqual(changesResult.length, 0);\n                    }\n\n                    db1.destroy();\n                    db2.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should remove some humans","suites":["instance",".find()",".bulkRemove()","positive"],"updatePoint":{"line":1231,"column":49},"line":1231,"code":"                    it('should remove some humans', async () => {\n                        const amount = 5;\n                        const c = await humansCollection.create(amount);\n                        const docList = await c.find().exec();\n\n                        assert.strictEqual(docList.length, amount);\n\n                        const primaryList = docList.map(doc => doc.primary);\n                        const ret = await c.bulkRemove(primaryList);\n                        assert.strictEqual(ret.success.length, amount);\n\n                        const finalList = await c.find().exec();\n                        assert.strictEqual(finalList.length, 0);\n\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not throw when called with an empty array","suites":["instance",".find()",".bulkRemove()","positive"],"updatePoint":{"line":1247,"column":72},"line":1247,"code":"                    it('should not throw when called with an empty array', async () => {\n                        const col = await humansCollection.create(0);\n                        await col.bulkRemove([]);\n                        col.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"sets a field in all documents","suites":["instance",".find()",".update()"],"updatePoint":{"line":1255,"column":49},"line":1255,"code":"                it('sets a field in all documents', async () => {\n                    const c = await humansCollection.create(2);\n                    const query = c.find();\n                    await query.update({\n                        $set: {\n                            firstName: 'new first name'\n                        }\n                    });\n                    const docsAfterUpdate = await c.find().exec();\n                    for (const doc of docsAfterUpdate) {\n                        assert.strictEqual(doc._data.firstName, 'new first name');\n                    }\n\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"unsets fields in all documents","suites":["instance",".find()",".update()"],"updatePoint":{"line":1270,"column":50},"line":1270,"code":"                it('unsets fields in all documents', async () => {\n                    // TODO should work on all storage implementations\n                    if (config.storage.name !== 'pouchdb') {\n                        return;\n                    }\n                    const c = await humansCollection.create(10);\n                    const query = c.find();\n                    await query.update({\n                        $unset: {\n                            age: ''\n                        }\n                    });\n                    const docsAfterUpdate = await c.find().exec();\n                    for (const doc of docsAfterUpdate) {\n                        assert.strictEqual(doc.age, undefined);\n                    }\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find a single document","suites":["instance",".findOne()","positive"],"updatePoint":{"line":1292,"column":42},"line":1292,"code":"                it('find a single document', async () => {\n                    const c = await humansCollection.create();\n                    const doc = await c.findOne().exec();\n                    assert.ok(isRxDocument(doc));\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"not crash on empty db","suites":["instance",".findOne()","positive"],"updatePoint":{"line":1298,"column":41},"line":1298,"code":"                it('not crash on empty db', async () => {\n                    const c = await humansCollection.create(0);\n                    const docs = await c.find().limit(1).exec();\n                    assert.strictEqual(docs.length, 0);\n                    const doc = await c.findOne().exec();\n                    assert.strictEqual(doc, null);\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find different on .skip()","suites":["instance",".findOne()","positive"],"updatePoint":{"line":1306,"column":45},"line":1306,"code":"                it('find different on .skip()', async () => {\n                    const c = await humansCollection.create();\n                    const doc: any = await c.findOne().exec();\n                    const doc2: any = await c.findOne().skip(2).exec();\n                    assert.ok(isRxDocument(doc));\n                    assert.ok(isRxDocument(doc2));\n                    assert.notStrictEqual(doc._data.passportId, doc2._data.passportId);\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find by primary","suites":["instance",".findOne()","positive"],"updatePoint":{"line":1315,"column":35},"line":1315,"code":"                it('find by primary', async () => {\n                    const c = await humansCollection.create();\n                    const doc: any = await c.findOne().exec();\n                    const _id = doc.primary;\n                    assert.strictEqual(typeof _id, 'string');\n                    const docById: any = await c.findOne(_id).exec();\n                    assert.deepStrictEqual(docById.data, doc.data);\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find by primary in parallel","suites":["instance",".findOne()","positive"],"updatePoint":{"line":1324,"column":47},"line":1324,"code":"                it('find by primary in parallel', async () => {\n                    // TODO should work on all storage implementations\n                    if (config.storage.name !== 'pouchdb') {\n                        return;\n                    }\n\n                    const c = await humansCollection.createPrimary(0);\n\n                    const docData = schemaObjects.simpleHuman();\n                    const primary = docData.passportId;\n\n                    const notExist = await c.findOne(primary).exec();\n                    assert.strictEqual(notExist, null);\n\n                    const insertedDoc = await c.insert(docData);\n                    assert.ok(isRxDocument(insertedDoc));\n\n                    const results = await Promise.all([\n                        c.findOne(primary).exec(true),\n                        c.findOne(primary).exec(true)\n                    ]);\n                    assert.ok(isRxDocument(results[0]));\n\n                    assert.ok(results[0] === results[1]);\n\n                    await results[0].atomicPatch({ firstName: 'foobar' });\n\n                    const results2 = await Promise.all([\n                        c.findOne(primary).exec(),\n                        c.findOne(primary).exec()\n                    ]);\n                    assert.ok(isRxDocument(results2[0]));\n                    assert.ok(results2[0] === results2[1]);\n\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"BUG: insert and find very often","suites":["instance",".findOne()","positive"],"updatePoint":{"line":1360,"column":51},"line":1360,"code":"                it('BUG: insert and find very often', async function () {\n                    this.timeout(5000);\n                    const amount = 10;\n                    for (let i = 0; i < amount; i++) {\n                        const db = await createRxDatabase({\n                            name: randomCouchString(10),\n                            storage: getRxStoragePouch('memory'),\n                        });\n                        const collections = await db.addCollections({\n                            human: {\n                                schema: schemas.human\n                            }\n                        });\n                        const collection = collections.human;\n                        const human = schemaObjects.human();\n                        const passportId = human.passportId;\n                        await collection.insert(human);\n                        const doc = await collection.findOne().exec();\n                        assert.strictEqual(passportId, doc._data.passportId);\n                        db.destroy();\n                    }\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"BUG: should throw when no-string given (number)","suites":["instance",".findOne()","negative"],"updatePoint":{"line":1384,"column":67},"line":1384,"code":"                it('BUG: should throw when no-string given (number)', async () => {\n                    const c = await humansCollection.create();\n                    assert.throws(\n                        () => (c as any).findOne(5),\n                        TypeError\n                    );\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"BUG: should throw when no-string given (array)","suites":["instance",".findOne()","negative"],"updatePoint":{"line":1392,"column":66},"line":1392,"code":"                it('BUG: should throw when no-string given (array)', async () => {\n                    const c = await humansCollection.create();\n                    assert.throws(\n                        () => (c as any).findOne([]),\n                        TypeError\n                    );\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"insert and update","suites":["instance",".bulkUpsert()"],"updatePoint":{"line":1403,"column":33},"line":1403,"code":"            it('insert and update', async () => {\n                const c = await humansCollection.create(0);\n                const amount = 5;\n\n                // insert\n                await c.bulkUpsert(\n                    new Array(amount).fill(0).map(() => schemaObjects.human())\n                );\n                let allDocs = await c.find().exec();\n                assert.strictEqual(allDocs.length, 5);\n\n                // update\n                const docsData = allDocs.map(d => {\n                    const data = d.toMutableJSON();\n                    data.age = 100;\n                    return data;\n                });\n                await c.bulkUpsert(docsData);\n                allDocs = await c.find().exec();\n                assert.strictEqual(allDocs.length, 5);\n                allDocs.forEach(d => assert.strictEqual(d.age, 100));\n\n                c.database.destroy();\n            });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"insert when not exists","suites":["instance",".upsert()","positive"],"updatePoint":{"line":1430,"column":42},"line":1430,"code":"                it('insert when not exists', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    const obj = schemaObjects.simpleHuman();\n                    obj.firstName = 'foobar';\n                    await collection.upsert(obj);\n                    const doc = await collection.findOne().exec();\n                    assert.strictEqual(doc.firstName, 'foobar');\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"overwrite exisiting document","suites":["instance",".upsert()","positive"],"updatePoint":{"line":1448,"column":48},"line":1448,"code":"                it('overwrite exisiting document', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    const obj = schemaObjects.simpleHuman();\n                    await collection.insert(obj);\n                    obj.firstName = 'foobar';\n                    await collection.upsert(obj);\n                    const doc = await collection.findOne().exec();\n                    assert.strictEqual(doc.firstName, 'foobar');\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"overwrite twice","suites":["instance",".upsert()","positive"],"updatePoint":{"line":1467,"column":35},"line":1467,"code":"                it('overwrite twice', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    const obj = schemaObjects.simpleHuman();\n                    await collection.insert(obj);\n                    obj.firstName = 'foobar';\n                    await collection.upsert(obj);\n\n                    obj.firstName = 'foobar2';\n                    await collection.upsert(obj);\n\n                    const doc = await collection.findOne().exec();\n                    assert.strictEqual(doc.firstName, 'foobar2');\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"overwrite deleted","suites":["instance",".upsert()","positive"],"updatePoint":{"line":1490,"column":37},"line":1490,"code":"                it('overwrite deleted', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    const objData = schemaObjects.simpleHuman();\n\n                    const doc = await collection.insert(objData);\n                    await doc.atomicPatch({\n                        firstName: 'alice'\n                    });\n                    await doc.remove();\n\n                    objData.firstName = 'foobar';\n                    await collection.upsert(objData);\n\n                    const docAfter = await collection.findOne(objData.passportId).exec(true);\n                    assert.strictEqual(docAfter.firstName, 'foobar');\n\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"throw when primary missing","suites":["instance",".upsert()","negative"],"updatePoint":{"line":1519,"column":46},"line":1519,"code":"                it('throw when primary missing', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    const obj = schemaObjects.simpleHuman();\n                    await collection.insert(obj);\n                    const cloned: any = clone(obj);\n\n                    cloned.firstName = 'foobar';\n                    delete cloned.passportId;\n                    await AsyncTestUtil.assertThrows(\n                        () => collection.upsert(cloned),\n                        'RxError',\n                        'without primary'\n                    );\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"throw when schema not matching","suites":["instance",".upsert()","negative"],"updatePoint":{"line":1543,"column":50},"line":1543,"code":"                it('throw when schema not matching', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    const obj: any = schemaObjects.simpleHuman();\n                    obj.firstName = 'foobar';\n                    obj['foo'] = 'bar';\n                    await AsyncTestUtil.assertThrows(\n                        () => collection.upsert(obj),\n                        'RxError',\n                        'not match'\n                    );\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should work in serial","suites":["instance",".atomicUpsert()","positive"],"updatePoint":{"line":1568,"column":41},"line":1568,"code":"                it('should work in serial', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const docData = schemaObjects.simpleHuman();\n                    const primary = docData.passportId;\n                    await c.findOne(primary).exec();\n                    await c.atomicUpsert(docData);\n                    await c.findOne(primary).exec();\n                    const docData2 = clone(docData);\n                    docData.firstName = 'foobar';\n\n                    await c.atomicUpsert(docData2);\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not crash when upserting the same doc in parallel","suites":["instance",".atomicUpsert()","positive"],"updatePoint":{"line":1581,"column":76},"line":1581,"code":"                it('should not crash when upserting the same doc in parallel', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const docData = schemaObjects.simpleHuman();\n                    const docs = await Promise.all([\n                        c.atomicUpsert(docData),\n                        c.atomicUpsert(docData)\n                    ]);\n                    assert.ok(docs[0] === docs[1]);\n                    assert.ok(isRxDocument(docs[0]));\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not crash when upserting the same doc in parallel 3 times","suites":["instance",".atomicUpsert()","positive"],"updatePoint":{"line":1592,"column":84},"line":1592,"code":"                it('should not crash when upserting the same doc in parallel 3 times', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const docData = schemaObjects.simpleHuman();\n                    const docs = await Promise.all([\n                        c.atomicUpsert(docData),\n                        c.atomicUpsert(docData),\n                        c.atomicUpsert(docData)\n                    ]);\n                    assert.ok(docs[0] === docs[1]);\n                    assert.ok(isRxDocument(docs[0]));\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not crash when upserting the same doc in parallel many times with random waits","suites":["instance",".atomicUpsert()","positive"],"updatePoint":{"line":1604,"column":105},"line":1604,"code":"                it('should not crash when upserting the same doc in parallel many times with random waits', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const docData = schemaObjects.simpleHuman();\n\n                    let t = 0;\n                    const amount = config.isFastMode() ? 20 : 200;\n                    const docs = await Promise.all(\n                        new Array(amount)\n                            .fill(0)\n                            .map((_v, idx) => {\n                                const upsertData = clone(docData);\n                                upsertData.lastName = idx + '';\n                                const randomWait = randomBoolean() ? wait(randomNumber(0, 30)) : Promise.resolve();\n                                return randomWait\n                                    .then(() => c.atomicUpsert(docData))\n                                    .then(doc => {\n                                        t++;\n                                        return doc;\n                                    });\n                            })\n                    );\n                    assert.strictEqual(t, amount);\n                    assert.ok(docs[0] === docs[1]);\n                    assert.ok(isRxDocument(docs[0]));\n\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should update the value","suites":["instance",".atomicUpsert()","positive"],"updatePoint":{"line":1631,"column":43},"line":1631,"code":"                it('should update the value', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const docData = schemaObjects.simpleHuman();\n\n                    await Promise.all([\n                        c.atomicUpsert(docData),\n                        c.atomicUpsert(docData),\n                        c.atomicUpsert(docData)\n                    ]);\n\n                    const docData2 = clone(docData);\n                    docData2.firstName = 'foobar';\n                    await c.atomicUpsert(docData2);\n                    const doc = await c.findOne().exec(true);\n                    assert.strictEqual(doc.firstName, 'foobar');\n\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should work when upserting to existing document","suites":["instance",".atomicUpsert()","positive"],"updatePoint":{"line":1649,"column":67},"line":1649,"code":"                it('should work when upserting to existing document', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const docData = schemaObjects.simpleHuman();\n                    await c.insert(docData);\n                    const docs = await Promise.all([\n                        c.atomicUpsert(docData),\n                        c.atomicUpsert(docData),\n                        c.atomicUpsert(docData)\n                    ]);\n                    assert.ok(docs[0] === docs[1]);\n                    assert.ok(isRxDocument(docs[0]));\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should process in the given order","suites":["instance",".atomicUpsert()","positive"],"updatePoint":{"line":1662,"column":53},"line":1662,"code":"                it('should process in the given order', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const docData = schemaObjects.simpleHuman();\n                    const order: any[] = [];\n                    await Promise.all([\n                        c.atomicUpsert(docData).then(() => order.push(0)),\n                        c.atomicUpsert(docData).then(() => order.push(1)),\n                        c.atomicUpsert(docData).then(() => order.push(2))\n                    ]);\n                    assert.deepStrictEqual(order, [0, 1, 2]);\n\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should work when inserting on a slow storage","suites":["instance",".atomicUpsert()","positive"],"updatePoint":{"line":1675,"column":64},"line":1675,"code":"                it('should work when inserting on a slow storage', async () => {\n                    if (!config.platform.isNode()) return;\n                    // use a 'slow' adapter because memory might be to fast\n                    const leveldown = require('leveldown');\n                    const db = await createRxDatabase({\n                        name: config.rootPath + 'test_tmp/' + randomCouchString(10),\n                        storage: getRxStoragePouch(leveldown),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const c = collections.human;\n\n                    const docData = schemaObjects.simpleHuman();\n                    await c.atomicUpsert(docData);\n                    await c.atomicUpsert(docData);\n                    const docData2 = clone(docData);\n                    docData2.firstName = 'foobar1';\n                    await c.atomicUpsert(docData2);\n                    const docs = await c.find().exec();\n                    assert.strictEqual(docs.length, 1);\n                    const doc = await c.findOne().exec();\n                    assert.strictEqual(doc.firstName, 'foobar1');\n\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should set correct default values","suites":["instance",".atomicUpsert()","positive"],"updatePoint":{"line":1703,"column":53},"line":1703,"code":"                it('should set correct default values', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n\n                    const schema: RxJsonSchema<HumanDocumentType> = clone(schemas.humanDefault);\n\n                    const defaultValue = schema.properties.age.default;\n                    const collections = await db.addCollections({\n                        nestedhuman: {\n                            schema\n                        }\n                    });\n                    const collection = collections.nestedhuman;\n\n                    const doc = await collection.atomicUpsert({\n                        passportId: 'foobar',\n                        firstName: 'foobar2'\n                    });\n\n                    assert.strictEqual(doc.age, defaultValue);\n\n                    // should also set after atomicUpdate when document exists\n                    const afterUpdate = await collection.atomicUpsert({\n                        passportId: 'foobar',\n                        firstName: 'foobar3'\n                    });\n                    assert.strictEqual(afterUpdate.age, defaultValue);\n\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should completely remove fields that are unset","suites":["instance",".atomicUpsert()","positive"],"updatePoint":{"line":1735,"column":66},"line":1735,"code":"                it('should completely remove fields that are unset', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const schema: RxJsonSchema<HumanDocumentType> = clone(schemas.humanDefault);\n\n                    const collections = await db.addCollections({\n                        nestedhuman: {\n                            schema\n                        }\n                    });\n                    const collection = collections.nestedhuman;\n\n                    const doc = await collection.atomicUpsert({\n                        passportId: 'foobar',\n                        firstName: 'foobar2'\n                    });\n                    assert.strictEqual(doc.firstName, 'foobar2');\n\n                    const afterUpdate = await collection.atomicUpsert({\n                        passportId: 'foobar'\n                    });\n                    assert.strictEqual(typeof afterUpdate.firstName, 'undefined');\n\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should throw when not matching schema","suites":["instance",".atomicUpsert()","negative"],"updatePoint":{"line":1764,"column":57},"line":1764,"code":"                it('should throw when not matching schema', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const docData = schemaObjects.simpleHuman();\n                    await Promise.all([\n                        c.atomicUpsert(docData),\n                        c.atomicUpsert(docData),\n                        c.atomicUpsert(docData)\n                    ]);\n                    const docData2 = clone(docData);\n                    docData2['firstName'] = 1337 as any;\n                    await AsyncTestUtil.assertThrows(\n                        () => c.atomicUpsert(docData2),\n                        'RxError',\n                        'schema'\n                    );\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not crash","suites":["instance",".remove()","positive"],"updatePoint":{"line":1785,"column":36},"line":1785,"code":"                it('should not crash', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    await c.remove();\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should be possible to re-create the collection with different schema","suites":["instance",".remove()","positive"],"updatePoint":{"line":1790,"column":88},"line":1790,"code":"                it('should be possible to re-create the collection with different schema', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n\n                    await collection.remove();\n                    const otherSchema: any = clone(schemas.primaryHuman);\n                    otherSchema.properties['foobar'] = {\n                        type: 'string'\n                    };\n                    await db.addCollections({\n                        human: {\n                            schema: otherSchema\n                        }\n                    });\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not contain document when re-creating","suites":["instance",".remove()","positive"],"updatePoint":{"line":1814,"column":64},"line":1814,"code":"                it('should not contain document when re-creating', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    await Promise.all(\n                        new Array(5).fill(0)\n                            .map(() => collection.insert(schemaObjects.human()))\n                    );\n                    const allDocs = await collection.find().exec();\n                    assert.strictEqual(5, allDocs.length);\n                    await collection.remove();\n\n                    const collections2 = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection2 = collections2.human;\n                    const noDocs = await collection2.find().exec();\n                    assert.strictEqual(0, noDocs.length);\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should have deleted the local documents","suites":["instance",".remove()","positive"],"updatePoint":{"line":1843,"column":59},"line":1843,"code":"                it('should have deleted the local documents', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman,\n                            localDocuments: true\n                        }\n                    });\n                    const collection = collections.human;\n                    const id = 'foobar';\n                    await collection.insertLocal(id, { foo: 'bar' });\n\n                    await collection.remove();\n\n                    const collections2 = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman,\n                            localDocuments: true\n                        }\n                    });\n                    const collection2 = collections2.human;\n                    const hasLocal = await collection2.getLocal(id);\n                    assert.strictEqual(hasLocal, null);\n\n                    await db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should delete when older versions exist","suites":["instance",".remove()","positive"],"updatePoint":{"line":1872,"column":59},"line":1872,"code":"                it('should delete when older versions exist', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n\n                    await Promise.all(\n                        new Array(5).fill(0)\n                            .map(() => collection.insert(schemaObjects.human()))\n                    );\n                    await collection.remove();\n\n                    const otherSchema = clone(schemas.primaryHuman);\n                    otherSchema.version = 1;\n                    const collections2 = await db.addCollections({\n                        human: {\n                            schema: otherSchema,\n                            migrationStrategies: {\n                                1: function (doc: any) {\n                                    return doc;\n                                }\n                            }\n                        }\n                    });\n                    const collection2 = collections2.human;\n\n                    const noDocs = await collection2.find().exec();\n                    assert.strictEqual(noDocs.length, 0);\n                    await Promise.all(\n                        new Array(5).fill(0)\n                            .map(() => collection2.insert(schemaObjects.human()))\n                    );\n                    const fiveDocs = await collection2.find().exec();\n                    assert.strictEqual(fiveDocs.length, 5);\n                    await collection2.remove();\n\n\n                    const collections0Again = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection0Again = collections0Again.human;\n                    const noDocs2 = await collection0Again.find().exec();\n                    assert.strictEqual(noDocs2.length, 0);\n\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not be possible to use the cleared collection","suites":["instance",".remove()","negative"],"updatePoint":{"line":1928,"column":72},"line":1928,"code":"                it('should not be possible to use the cleared collection', async () => {\n                    // TODO should work on all storage implementations\n                    if (config.storage.name !== 'pouchdb') {\n                        return;\n                    }\n                    const c = await humansCollection.createPrimary(0);\n                    await c.remove();\n                    await AsyncTestUtil.assertThrows(\n                        () => c.find().exec(),\n                        Error\n                    );\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not have the collection in the collections-list","suites":["instance",".remove()","negative"],"updatePoint":{"line":1941,"column":74},"line":1941,"code":"                it('should not have the collection in the collections-list', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const db = c.database;\n                    const name = c.name;\n                    await c.remove();\n                    assert.strictEqual(undefined, db[name]);\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not crash","suites":["instance",".findByIds()"],"updatePoint":{"line":1952,"column":32},"line":1952,"code":"            it('should not crash', async () => {\n                const c = await humansCollection.create();\n                const res = await c.findByIds([\n                    'foo',\n                    'bar'\n                ]);\n                assert.ok(res);\n                c.database.destroy();\n            });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should find the documents","suites":["instance",".findByIds()"],"updatePoint":{"line":1961,"column":41},"line":1961,"code":"            it('should find the documents', async () => {\n                const c = await humansCollection.create(5);\n\n                const docs = await c.find().exec();\n                const ids = docs.map(d => d.primary);\n                const res = await c.findByIds(ids);\n\n                assert.ok(res.has(docs[0].primary));\n                assert.strictEqual(res.size, 5);\n\n                c.database.destroy();\n            });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should find the documents when they are not in the docCache","suites":["instance",".findByIds()"],"updatePoint":{"line":1973,"column":75},"line":1973,"code":"            it('should find the documents when they are not in the docCache', async () => {\n                const c = await humansCollection.create(5);\n                const docs = await c.find().exec();\n                const ids = docs.map(d => d.primary);\n\n                // clear docCache\n                ids.forEach(id => c._docCache.delete(id));\n\n                const res = await c.findByIds(ids);\n                assert.strictEqual(res.size, 5);\n                c.database.destroy();\n            });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not crash and emit a map","suites":[".findByIds$()"],"updatePoint":{"line":1988,"column":43},"line":1988,"code":"        it('should not crash and emit a map', async () => {\n            const c = await humansCollection.create(5);\n            const docs = await c.find().exec();\n            const ids = docs.map(d => d.primary);\n            const res = await firstValueFrom(c.findByIds$(ids));\n\n            assert.ok(res);\n            assert.ok(res instanceof Map);\n\n            c.database.destroy();\n        });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should emit the correct initial values","suites":[".findByIds$()"],"updatePoint":{"line":1999,"column":50},"line":1999,"code":"        it('should emit the correct initial values', async () => {\n            const c = await humansCollection.create(5);\n\n            const docs = await c.find().exec();\n            const ids = docs.map(d => d.primary);\n            const res = await firstValueFrom(c.findByIds$(ids));\n\n            assert.ok(res.has(docs[0].primary));\n            assert.strictEqual(res.size, 5);\n\n            c.database.destroy();\n        });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should merge the insert/update/delete event correctly","suites":[".findByIds$()"],"updatePoint":{"line":2011,"column":65},"line":2011,"code":"        it('should merge the insert/update/delete event correctly', async () => {\n            const c = await humansCollection.createPrimary(5);\n            const docs = await c.find().exec();\n            const ids = docs.map(d => d.primary);\n            ids.push('foobar');\n            const obs = c.findByIds$(ids);\n            await firstValueFrom(obs);\n\n            // check insert\n            const addData = schemaObjects.human();\n            addData.passportId = 'foobar';\n            await c.insert(addData);\n            // insert whose id is not in ids-list should not affect anything\n            await c.insert(schemaObjects.human());\n\n            const res2 = await firstValueFrom(obs);\n            assert.strictEqual(res2.size, 6);\n            assert.ok(res2.has('foobar'));\n\n            // check update\n            addData.firstName = 'barfoo';\n            await c.upsert(addData);\n            const res3 = await firstValueFrom(obs);\n            const getDoc = res3.get('foobar');\n            assert.ok(getDoc);\n            assert.strictEqual(getDoc.firstName, 'barfoo');\n\n            // check delete\n            await getDoc.remove();\n            const res4 = await firstValueFrom(obs);\n            assert.strictEqual(false, res4.has('foobar'));\n\n            c.database.destroy();\n        });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"#528  default value ignored when 0","suites":["issues"],"updatePoint":{"line":2048,"column":46},"line":2048,"code":"        it('#528  default value ignored when 0', async () => {\n            const schema = {\n                version: 0,\n                primaryKey: 'passportId',\n                type: 'object',\n                properties: {\n                    passportId: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    weight: {\n                        type: 'number',\n                        default: 0\n                    }\n                }\n            };\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n            });\n            const collections = await db.addCollections({\n                humanx: {\n                    schema\n                }\n            });\n            const collection = collections.humanx;\n            const doc = await collection.insert({\n                passportId: randomCouchString(10)\n            });\n            assert.strictEqual(doc.weight, 0);\n            db.destroy();\n        });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"#596 Default value not applied when value is undefined","suites":["issues"],"updatePoint":{"line":2080,"column":66},"line":2080,"code":"        it('#596 Default value not applied when value is undefined', async () => {\n            const schema = {\n                version: 0,\n                primaryKey: 'passportId',\n                type: 'object',\n                properties: {\n                    passportId: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    firstName: {\n                        type: 'string'\n                    },\n                    lastName: {\n                        type: 'string'\n                    },\n                    age: {\n                        type: 'integer',\n                        minimum: 0,\n                        maximum: 150\n                    },\n                    score: {\n                        type: 'integer',\n                        default: 100\n                    }\n                }\n            };\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n            });\n            const collections = await db.addCollections({\n                humanx: {\n                    schema\n                }\n            });\n            const collection = collections.humanx;\n\n            // insert a document\n            await collection.insert({\n                passportId: 'foobar',\n                firstName: 'Bob',\n                lastName: 'Kelso',\n                age: 56,\n                score: undefined\n            });\n            const myDocument = await collection\n                .findOne()\n                .where('firstName')\n                .eq('Bob')\n                .exec();\n            assert.strictEqual(myDocument.score, 100);\n            db.destroy();\n        });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"auto_compaction not works on collection-level https://gitter.im/pubkey/rxdb?at=5c42f3dd0721b912a5a4366b","suites":["issues"],"updatePoint":{"line":2134,"column":115},"line":2134,"code":"        it('auto_compaction not works on collection-level https://gitter.im/pubkey/rxdb?at=5c42f3dd0721b912a5a4366b', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n            });\n\n            // test with auto_compaction\n            const collections = await db.addCollections({\n                human_compact: {\n                    schema: schemas.primaryHuman,\n                    instanceCreationOptions: {\n                        auto_compaction: true\n                    }\n                }\n            });\n            const collection = collections.human_compact;\n            assert.ok(collection.storageInstance.internals.pouch.auto_compaction);\n            db.destroy();\n        });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"#939 creating a collection mutates the given parameters-object","suites":["issues"],"updatePoint":{"line":2153,"column":74},"line":2153,"code":"        it('#939 creating a collection mutates the given parameters-object', async () => {\n            const schema = {\n                version: 0,\n                primaryKey: 'passportId',\n                type: 'object',\n                properties: {\n                    passportId: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    weight: {\n                        type: 'number',\n                        default: 0\n                    }\n                }\n            };\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n            });\n\n            const collectionParams = {\n                schema,\n                methods: {\n                    foo() {\n                        return 'bar';\n                    }\n                },\n                statics: {\n                    foo2() {\n                        return 'bar2';\n                    }\n                }\n            };\n            const cloned = clone(collectionParams);\n            await db.addCollections({\n                humans: collectionParams\n            });\n            assert.deepStrictEqual(Object.keys(cloned), Object.keys(collectionParams));\n            assert.deepStrictEqual(cloned, collectionParams);\n\n            await db.destroy();\n\n            // recreating with the same params-object should work\n            const db2 = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage(),\n            });\n            await db2.addCollections({\n                humans: collectionParams\n            });\n            assert.deepStrictEqual(cloned, collectionParams);\n\n            db2.destroy();\n        });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"#3661 .findByIds$() fires too often","suites":["issues"],"updatePoint":{"line":2208,"column":47},"line":2208,"code":"        it('#3661 .findByIds$() fires too often', async () => {\n            const collection = await humansCollection.create(0);\n\n            //  Record subscription\n            const emitted: Map<string, RxDocument<HumanDocumentType>>[] = [];\n\n            function createObject(id: string): RxDocumentData<HumanDocumentType> {\n                const ret: RxDocumentData<HumanDocumentType> = Object.assign(\n                    schemaObjects.human(),\n                    {\n                        passportId: id,\n                        _deleted: false,\n                        _attachments: {},\n                        _meta: {\n                            lwt: now()\n                        },\n                        _rev: '1-51b2fae5721cc4d3cf7392f19e6cc118'\n                    }\n                );\n                return ret;\n            }\n\n            const matchingIds = ['a', 'b', 'c', 'd'];\n\n            const sub = collection.findByIds$(matchingIds).subscribe(data => {\n                emitted.push(data);\n            });\n\n            //  test we have a map and no error\n            await AsyncTestUtil.waitUntil(() => emitted.length > 0);\n            await AsyncTestUtil.wait(100);\n\n            /**\n             * Should have emitted exactly once with an empty map\n             * because we have no document at all in the storage.\n             */\n            assert.strictEqual(emitted.length, 1);\n\n            /**\n             * Non-existing documents should not be in the map at all\n             * (also not with undefined value)\n             */\n            assert.strictEqual(emitted[0].size, 0);\n\n\n            //  Simulate a write from a primitive replication\n            await collection.storageInstance.bulkWrite(\n                matchingIds\n                    .map(id => {\n                        const saveMe = createObject(id);\n                        return {\n                            document: saveMe\n                        };\n                    })\n            );\n\n            // Now we should have more updates and at some point all documents\n            // are in the result set.\n            await AsyncTestUtil.waitUntil(() => lastOfArray(emitted).size === matchingIds.length);\n\n            // wait a bit more\n            await AsyncTestUtil.wait(config.isFastMode() ? 50 : 150);\n            assert.strictEqual(lastOfArray(emitted).size, matchingIds.length);\n\n\n            /**\n             * Each emitted result must have a higher amount of documents,\n             * because findByIds$ must only emit when data has actually changed.\n             * We cannot just cound the updates.length here because some RxStorage implementations\n             * might return multiple RxChangeEventBulks for a single bulkWrite() operation.\n             */\n            let lastCount: number;\n            emitted.forEach(oneResult => {\n                if (typeof lastCount === 'undefined') {\n                    lastCount = oneResult.size;\n                } else {\n                    if (oneResult.size <= lastCount) {\n                        throw new Error('emitted data not newer ' + oneResult.size + '- lastCount: ' + lastCount);\n                    }\n                    lastCount = oneResult.size;\n                }\n            });\n\n            // should have the same result set as running findByIds() once.\n            const singleQueryDocs = await collection.findByIds(matchingIds);\n\n            const singleResultPlain = matchingIds.map(id => getFromMapOrThrow(singleQueryDocs, id).toJSON())\n            const observedResultPlain = matchingIds.map(id => getFromMapOrThrow(lastOfArray(emitted), id).toJSON())\n            assert.deepStrictEqual(singleResultPlain, observedResultPlain);\n\n            //  And contains the right data\n            const lastEmit = lastOfArray(emitted);\n            assert.strictEqual(lastEmit.get('a')?.passportId, 'a');\n            assert.strictEqual(lastEmit.get('b')?.passportId, 'b');\n            assert.strictEqual(lastEmit.get('c')?.passportId, 'c');\n            assert.strictEqual(lastEmit.get('d')?.passportId, 'd');\n\n            //  Let's try to update something different that should be ignored\n            const sizeBeforeRandomInserts = lastOfArray(emitted).size;\n            await collection.storageInstance.bulkWrite(\n                [\n                    createObject('e'),\n                    createObject('f'),\n                    createObject('g'),\n                    createObject('h')\n                ].map(document => ({ document }))\n            );\n\n            //  Wait a bit to see if we catch anything\n            await wait(config.isFastMode() ? 100 : 300);\n            const sizeAfterRandomInserts = lastOfArray(emitted).size;\n\n            //  Verify that the subscription has not been triggered and no error has been added\n            assert.strictEqual(sizeBeforeRandomInserts, sizeAfterRandomInserts);\n\n            // clean up afterwards\n            sub.unsubscribe();\n            collection.database.destroy();\n        });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"memdown","suites":[".create()","positive"],"updatePoint":{"line":43,"column":23},"line":43,"code":"            it('memdown', async () => {\n                if (!config.platform.isNode()) return;\n                addPouchPlugin(require('pouchdb-adapter-leveldb'));\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch(memdown)\n                });\n                assert.ok(isRxDatabase(db));\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"leveldown","suites":[".create()","positive"],"updatePoint":{"line":53,"column":25},"line":53,"code":"            it('leveldown', async () => {\n                if (!config.platform.isNode()) return;\n                if (path.join('..', 'x') !== '..\\\\x') { // leveldown does not work on windows\n                    const db = await createRxDatabase({\n                        name: config.rootPath + 'test_tmp/' + randomCouchString(10),\n                        storage: getRxStoragePouch(leveldown)\n                    });\n                    assert.ok(isRxDatabase(db));\n                    db.destroy();\n                }\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"with password","suites":[".create()","positive"],"updatePoint":{"line":64,"column":29},"line":64,"code":"            it('with password', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    password: randomCouchString(12)\n                });\n                assert.ok(isRxDatabase(db));\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"2 instances on same adapter (if ignoreDuplicate is true)","suites":[".create()","positive"],"updatePoint":{"line":73,"column":72},"line":73,"code":"            it('2 instances on same adapter (if ignoreDuplicate is true)', async () => {\n                addPouchPlugin(require('pouchdb-adapter-memory'));\n                const name = randomCouchString(10);\n                const db = await createRxDatabase({\n                    name,\n                    storage: getRxStoragePouch('memory'),\n                    ignoreDuplicate: true\n                });\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: getRxStoragePouch('memory'),\n                    ignoreDuplicate: true\n                });\n                db.destroy();\n                db2.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"2 instances on same adapter -> ignoreDuplicate is false but first db gets destroyed","suites":[".create()","positive"],"updatePoint":{"line":89,"column":99},"line":89,"code":"            it('2 instances on same adapter -> ignoreDuplicate is false but first db gets destroyed', async () => {\n                const name = randomCouchString(10);\n                const db = await createRxDatabase({\n                    name,\n                    storage: getRxStoragePouch('memory')\n                });\n                await db.destroy();\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: getRxStoragePouch('memory')\n                });\n                db2.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"2 password-instances on same adapter","suites":[".create()","positive"],"updatePoint":{"line":102,"column":52},"line":102,"code":"            it('2 password-instances on same adapter', async () => {\n                const name = randomCouchString(10);\n                const password = randomCouchString(12);\n                const db = await createRxDatabase({\n                    name,\n                    storage: getRxStoragePouch('memory'),\n                    password,\n                    ignoreDuplicate: true\n                });\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: getRxStoragePouch('memory'),\n                    password,\n                    ignoreDuplicate: true\n                });\n                db.destroy();\n                db2.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should not forget the options","suites":[".create()","positive"],"updatePoint":{"line":120,"column":45},"line":120,"code":"            it('should not forget the options', async () => {\n                const name = randomCouchString(10);\n                const password = randomCouchString(12);\n                const db = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    password,\n                    ignoreDuplicate: true,\n                    options: {\n                        foo: 'bar'\n                    }\n                });\n                assert.strictEqual(db.options.foo, 'bar');\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should not forget the instanceCreationOptions","suites":[".create()","positive"],"updatePoint":{"line":135,"column":61},"line":135,"code":"            it('should not forget the instanceCreationOptions', async () => {\n                const name = randomCouchString(10);\n                const password = randomCouchString(12);\n                const db = await createRxDatabase({\n                    name,\n                    storage: getRxStoragePouch('memory'),\n                    instanceCreationOptions: {\n                        ajax: 'bar'\n                    },\n                    password,\n                    ignoreDuplicate: true\n                });\n                assert.strictEqual(db.internalStore.options.ajax, 'bar');\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should crash with invalid token","suites":[".create()","negative"],"updatePoint":{"line":152,"column":47},"line":152,"code":"            it('should crash with invalid token', async () => {\n                await AsyncTestUtil.assertThrows(\n                    () => createRxDatabase({\n                        name: null,\n                        storage: config.storage.getStorage(),\n                    } as any),\n                    'RxTypeError',\n                    'null'\n                );\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should crash with and ending slash","suites":[".create()","negative"],"updatePoint":{"line":162,"column":50},"line":162,"code":"            it('should crash with and ending slash', async () => {\n                await AsyncTestUtil.assertThrows(\n                    () => createRxDatabase({\n                        name: '/foo/bar/',\n                        storage: config.storage.getStorage(),\n                    } as any),\n                    'RxError',\n                    'ending'\n                );\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should crash with invalid adapter","suites":[".create()","negative"],"updatePoint":{"line":172,"column":49},"line":172,"code":"            it('should crash with invalid adapter', async () => {\n                await AsyncTestUtil.assertThrows(\n                    () => createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch({}),\n                    }),\n                    'RxError',\n                    'adapter'\n                );\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should crash with invalid password (no string)","suites":[".create()","negative"],"updatePoint":{"line":182,"column":62},"line":182,"code":"            it('should crash with invalid password (no string)', async () => {\n                await AsyncTestUtil.assertThrows(\n                    () => createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                        password: {}\n                    }),\n                    'RxTypeError',\n                    'password'\n                );\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should crash with invalid password (too short)","suites":[".create()","negative"],"updatePoint":{"line":193,"column":62},"line":193,"code":"            it('should crash with invalid password (too short)', async () => {\n                await AsyncTestUtil.assertThrows(\n                    () => createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                        password: randomCouchString(4)\n                    }),\n                    'RxError',\n                    'min-length'\n                );\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"BUG: should have a pwHash-doc after creating the database","suites":[".create()","negative"],"updatePoint":{"line":204,"column":73},"line":204,"code":"            it('BUG: should have a pwHash-doc after creating the database', async () => {\n                const name = randomCouchString(10);\n                const password = randomCouchString(10);\n                const db = await createRxDatabase({\n                    name,\n                    storage: getRxStoragePouch('memory'),\n                    password,\n                    ignoreDuplicate: true\n                });\n                const doc = await getSingleDocument<InternalStorePasswordDocType>(\n                    db.internalStore,\n                    getPrimaryKeyOfInternalDocument(\n                        'pwHash',\n                        INTERNAL_CONTEXT_ENCRYPTION\n                    )\n                );\n                if (!doc) {\n                    throw new Error('error in test this should never happen ' + doc);\n                }\n                assert.strictEqual(typeof doc.data.hash, 'string');\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    password,\n                    ignoreDuplicate: true\n                });\n                const doc2 = await getSingleDocument<InternalStorePasswordDocType>(\n                    db.internalStore,\n                    getPrimaryKeyOfInternalDocument(\n                        'pwHash',\n                        INTERNAL_CONTEXT_ENCRYPTION\n                    )\n                );\n                assert.ok(doc2);\n                assert.strictEqual(typeof doc2.data.hash, 'string');\n\n                db.destroy();\n                db2.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"prevent 2 instances with different passwords on same adapter","suites":[".create()","negative"],"updatePoint":{"line":243,"column":76},"line":243,"code":"            it('prevent 2 instances with different passwords on same adapter', async () => {\n                const name = randomCouchString(10);\n                const db = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    password: randomCouchString(10)\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => createRxDatabase({\n                        name,\n                        storage: config.storage.getStorage(),\n                        password: randomCouchString(10)\n                    }),\n                    'RxError'\n                );\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"do not allow 2 databases with same name and adapter","suites":[".create()","negative"],"updatePoint":{"line":260,"column":67},"line":260,"code":"            it('do not allow 2 databases with same name and adapter', async () => {\n                const name = randomCouchString(10);\n                const db = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage()\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => createRxDatabase({\n                        name,\n                        storage: config.storage.getStorage()\n                    }),\n                    'RxError',\n                    'ignoreDuplicate'\n                );\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"human","suites":[".addCollections()","positive"],"updatePoint":{"line":280,"column":21},"line":280,"code":"            it('human', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                const collections = await db.addCollections({\n                    human0: {\n                        schema: schemas.human\n                    }\n                });\n                const collection = collections.human0;\n                assert.ok(isRxCollection(collection));\n\n                // make sure defineGetter works\n                assert.strictEqual(db.human0, collection);\n\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"the schema-object should be saved in the internal storage instance","suites":[".addCollections()","positive"],"updatePoint":{"line":298,"column":82},"line":298,"code":"            it('the schema-object should be saved in the internal storage instance', async () => {\n                addPouchPlugin(require('pouchdb-adapter-memory'));\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory')\n                });\n                await db.addCollections({\n                    human0: {\n                        schema: schemas.human\n                    }\n                });\n                const colDoc = await (db.internalStore.internals.pouch as any).get('collection|human0-' + schemas.human.version);\n                const compareSchema = createRxSchema(schemas.human);\n                assert.deepStrictEqual(compareSchema.jsonSchema, colDoc.data.schema);\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"use encrypted db","suites":[".addCollections()","positive"],"updatePoint":{"line":314,"column":32},"line":314,"code":"            it('use encrypted db', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    password: randomCouchString(12)\n                });\n                const collections = await db.addCollections({\n                    humanenc: {\n                        schema: schemas.encryptedHuman\n                    }\n                });\n                const collection = collections.humanenc;\n                assert.ok(isRxCollection(collection));\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"collectionsCollection should contain schema.version","suites":[".addCollections()","positive"],"updatePoint":{"line":329,"column":67},"line":329,"code":"            it('collectionsCollection should contain schema.version', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory')\n                });\n                const collections = await db.addCollections({\n                    human: {\n                        schema: schemas.human\n                    }\n                });\n                const collection = collections.human;\n                const version = collection.schema.version;\n                assert.deepStrictEqual(version, 0);\n                const internalDoc = await (db.internalStore.internals.pouch as any).get('collection|human-' + version);\n                assert.deepStrictEqual(internalDoc.data.version, version);\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"create 2 times on same adapter","suites":[".addCollections()","positive"],"updatePoint":{"line":346,"column":46},"line":346,"code":"            it('create 2 times on same adapter', async () => {\n                const name = randomCouchString(10);\n                const collectionName = 'foobar';\n                const db1 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n                await db1.addCollections({\n                    [collectionName]: {\n                        schema: schemas.human\n                    }\n                });\n                await db2.addCollections({\n                    [collectionName]: {\n                        schema: schemas.human\n                    }\n                });\n                db1.destroy();\n                db2.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should not do a write to the internalStore when creating a previous existing collection","suites":[".addCollections()","positive"],"updatePoint":{"line":372,"column":103},"line":372,"code":"            it('should not do a write to the internalStore when creating a previous existing collection', async () => {\n                const name = randomCouchString(10);\n                const collectionName = 'foobar';\n                const db1 = await createRxDatabase({\n                    name,\n                    storage: getRxStoragePouch('memory'),\n                    ignoreDuplicate: true\n                });\n                await db1.addCollections({\n                    [collectionName]: {\n                        schema: schemas.human\n                    }\n                });\n                await db1.destroy();\n\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: getRxStoragePouch('memory'),\n                    ignoreDuplicate: true\n                });\n\n                await db2.addCollections({\n                    [collectionName]: {\n                        schema: schemas.human\n                    }\n                });\n\n                const internalStoreDocs = await db2.internalStore.query(\n                    db2.storage.statics.prepareQuery(\n                        db2.internalStore.schema,\n                        {\n                            selector: {\n                                context: 'collection'\n                            },\n                            sort: [{ id: 'asc' }],\n                            skip: 0\n                        }\n                    )\n                );\n\n                // revision height must still be 1\n                const doc = Object.values(internalStoreDocs.documents)[0];\n                const parsedRev = parseRevision(doc._rev);\n                assert.strictEqual(parsedRev.height, 1);\n\n                await db2.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"broken schema (nostringIndex)","suites":[".addCollections()","negative"],"updatePoint":{"line":421,"column":45},"line":421,"code":"            it('broken schema (nostringIndex)', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        human6: {\n                            schema: schemas.noStringIndex\n                        }\n                    }),\n                    'RxError'\n                );\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"call 2 times on same name","suites":[".addCollections()","negative"],"updatePoint":{"line":436,"column":41},"line":436,"code":"            it('call 2 times on same name', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                await db.addCollections({\n                    human2: {\n                        schema: schemas.human\n                    }\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        human2: {\n                            schema: schemas.human\n                        }\n                    }),\n                    'RxError'\n                );\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"crypt-schema without db-password","suites":[".addCollections()","negative"],"updatePoint":{"line":456,"column":48},"line":456,"code":"            it('crypt-schema without db-password', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        human7: {\n                            schema: schemas.encryptedHuman\n                        }\n                    }),\n                    'RxError'\n                );\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"2 different schemas on same collection","suites":[".addCollections()","negative"],"updatePoint":{"line":471,"column":54},"line":471,"code":"            it('2 different schemas on same collection', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                const cols = await db.addCollections({\n                    human8: {\n                        schema: schemas.human\n                    }\n                });\n                await cols.human8.insert(schemaObjects.human());\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        human8: {\n                            schema: schemas.bigHuman\n                        }\n                    }),\n                    'RxError',\n                    'already exists'\n                );\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"not allow collectionNames starting with lodash","suites":[".addCollections()","negative"],"updatePoint":{"line":493,"column":62},"line":493,"code":"            it('not allow collectionNames starting with lodash', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        _test: {\n                            schema: schemas.human\n                        }\n                    }),\n                    'RxError',\n                    'UT2'\n                );\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"not allow collectionNames which are properties of RxDatabase","suites":[".addCollections()","negative"],"updatePoint":{"line":509,"column":76},"line":509,"code":"            it('not allow collectionNames which are properties of RxDatabase', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                const forbidden = [\n                    'name',\n                    'token',\n                    'isLeader',\n                    '$emit',\n                    'destroy'\n                ];\n                let t = 0;\n                while (t < forbidden.length) {\n                    const colName = forbidden[t];\n                    await AsyncTestUtil.assertThrows(\n                        () => db.addCollections({\n                            [colName]: {\n                                schema: schemas.human\n                            }\n                        }),\n                        'RxError',\n                        'not allowed'\n                    );\n                    t++;\n                }\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"create 2 times on same adapter with different schema","suites":[".addCollections()","negative"],"updatePoint":{"line":537,"column":68},"line":537,"code":"            it('create 2 times on same adapter with different schema', async () => {\n                const name = randomCouchString(10);\n                const collectionName = 'foobar';\n                const db1 = await createRxDatabase({\n                    name,\n                    storage: getRxStoragePouch('memory'),\n                    ignoreDuplicate: true\n                });\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: getRxStoragePouch('memory'),\n                    ignoreDuplicate: true\n                });\n                const col1 = await db1.addCollections({\n                    [collectionName]: {\n                        schema: schemas.human\n                    }\n                });\n                await col1[collectionName].insert(schemaObjects.human());\n                await AsyncTestUtil.assertThrows(\n                    () => db2.addCollections({\n                        [collectionName]: {\n                            schema: schemas.bigHuman\n                        }\n                    }),\n                    'RxError',\n                    'different'\n                );\n                db1.destroy();\n                db2.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should not crash on destroy","suites":[".destroy()","positive"],"updatePoint":{"line":572,"column":43},"line":572,"code":"            it('should not crash on destroy', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                await db.addCollections({\n                    foobar: {\n                        schema: schemas.human\n                    }\n                });\n                await db.destroy();\n                assert.strictEqual(db.destroyed, true);\n                await db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should not crash if destroy is called twice","suites":[".destroy()","positive"],"updatePoint":{"line":586,"column":59},"line":586,"code":"            it('should not crash if destroy is called twice', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                await db.addCollections({\n                    foobar: {\n                        schema: schemas.human\n                    }\n                });\n                await db.destroy();\n                await db.destroy();\n                assert.strictEqual(db.destroyed, true);\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should not crash","suites":[".remove()"],"updatePoint":{"line":603,"column":28},"line":603,"code":"        it('should not crash', async () => {\n            const c = await humansCollection.create(10);\n            await c.database.remove();\n        });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should be possible to recreate the database with other password","suites":[".remove()"],"updatePoint":{"line":607,"column":75},"line":607,"code":"        it('should be possible to recreate the database with other password', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                password: 'fo222222obar'\n            });\n            await db.remove();\n\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                password: 'foo2222333333bar2'\n            });\n            await db2.remove();\n        });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should have deleted the local documents","suites":[".remove()"],"updatePoint":{"line":623,"column":51},"line":623,"code":"        it('should have deleted the local documents', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                localDocuments: true\n            });\n\n            const id = 'foobar';\n            await db.insertLocal(id, { foo: 'bar' });\n\n            await db.remove();\n\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                localDocuments: true\n            });\n\n            const hasLocal = await db2.getLocal(id);\n            assert.strictEqual(hasLocal, null);\n\n            await db2.remove();\n        });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"#677 wrong pouch-location when path as collection-name","suites":["ISSUES"],"updatePoint":{"line":649,"column":66},"line":649,"code":"        it('#677 wrong pouch-location when path as collection-name', () => {\n            const pouchPathNormal = getPouchLocation(\n                'mydb',\n                'humans',\n                5\n            );\n            assert.strictEqual(pouchPathNormal, 'mydb-rxdb-5-humans');\n\n            const pouchPath = getPouchLocation(\n                'mydb',\n                'subfolder/humans',\n                5\n            );\n            assert.strictEqual(pouchPath, 'subfolder/mydb-rxdb-5-humans');\n        });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"w8 a bit","suites":["wait a bit"],"updatePoint":{"line":667,"column":20},"line":667,"code":"        it('w8 a bit', (done) => {\n            setTimeout(done, 30);\n        });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should get an object with all main-fields","suites":["prototype-merge","RxSchema.getDocumentPrototype()"],"updatePoint":{"line":36,"column":57},"line":36,"code":"            it('should get an object with all main-fields', async () => {\n                const schema = createRxSchema(schemas.human);\n                assert.ok(schema);\n                const proto = schema.getDocumentPrototype();\n                assert.ok(proto);\n                const testObjData: any = schemaObjects.human();\n                const testObj: any = {\n                    get(path: string) {\n                        return testObjData[path];\n                    },\n                    get$(path: string) {\n                        return 'Observable:' + path;\n                    },\n                    populate(path: string) {\n                        return 'Promise:' + path;\n                    },\n                    set(path: string, val: any) {\n                        testObjData[path] = val;\n                    }\n                };\n                Object.setPrototypeOf(\n                    testObj,\n                    proto\n                );\n\n                assert.strictEqual(testObj['passportId'], testObjData.passportId);\n                Object.keys(testObjData).forEach(k => {\n                    assert.strictEqual(testObj[k], testObjData[k]); // getter attribute\n                    assert.strictEqual(testObj[k + '$'], 'Observable:' + k); // getter observable\n                    assert.strictEqual(testObj[k + '_'], 'Promise:' + k); // getter populate\n                    // test setter\n                    testObj[k] = 'foo';\n                    assert.strictEqual(testObjData[k], 'foo');\n                });\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should get a prototype with all orm-methods","suites":["prototype-merge","RxCollection.getDocumentOrmPrototype()"],"updatePoint":{"line":73,"column":59},"line":73,"code":"            it('should get a prototype with all orm-methods', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.humanFinal,\n                        methods: {\n                            foo() {\n                                return 'bar';\n                            }\n                        }\n                    }\n                });\n\n                const proto = getDocumentOrmPrototype(cols.humans);\n                const testObj: any = {};\n                Object.setPrototypeOf(\n                    testObj,\n                    proto\n                );\n                assert.strictEqual(testObj['foo'](), 'bar');\n\n                db.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should get a valid prototype","suites":["prototype-merge","RxCollection.getDocumentPrototype()"],"updatePoint":{"line":101,"column":44},"line":101,"code":"            it('should get a valid prototype', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.human,\n                        methods: {\n                            foo() {\n                                return 'bar';\n                            }\n                        }\n                    }\n                });\n                const proto = getDocumentPrototype(cols.humans);\n\n                assert.strictEqual(typeof proto.remove, 'function'); // from baseProto\n                assert.strictEqual(proto.foo(), 'bar'); // from orm-proto\n\n                db.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"get a value","suites":[".get()","positive"],"updatePoint":{"line":128,"column":27},"line":128,"code":"            it('get a value', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec(true);\n                const value = doc.get('passportId');\n                assert.strictEqual(typeof value, 'string');\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"get a nested value","suites":[".get()","positive"],"updatePoint":{"line":135,"column":34},"line":135,"code":"            it('get a nested value', async () => {\n                const c = await humansCollection.createNested(5);\n                const doc = await c.findOne().exec(true);\n                const value = doc.get('mainSkill.name');\n                assert.strictEqual(typeof value, 'string');\n                const value2 = doc.get('mainSkill.level');\n                assert.strictEqual(typeof value2, 'number');\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"get undefined on undefined value","suites":[".get()","positive"],"updatePoint":{"line":144,"column":48},"line":144,"code":"            it('get undefined on undefined value', async () => {\n                const c = await humansCollection.createNested(5);\n                const doc = await c.findOne().exec(true);\n                const value = doc.get('foobar');\n                assert.strictEqual(value, undefined);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should only not work on non-temporary document","suites":[".set()","negative"],"updatePoint":{"line":156,"column":62},"line":156,"code":"            it('should only not work on non-temporary document', async () => {\n                const c = await humansCollection.createNested(5);\n                const doc = await c.findOne().exec(true);\n                const path = {\n                    foo: 'bar'\n                };\n                await AsyncTestUtil.assertThrows(\n                    () => doc.set(path as any, 'foo'),\n                    'RxTypeError',\n                    'temporary RxDocuments'\n                );\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"delete 1 document","suites":[".remove()","positive"],"updatePoint":{"line":173,"column":33},"line":173,"code":"            it('delete 1 document', async () => {\n                const c = await humansCollection.create(5);\n                const docs = await c.find().exec();\n                assert.ok(docs.length > 1);\n                const first = docs[0];\n                await first.remove();\n                const docsAfter = await c.find().exec();\n                docsAfter.map(doc => {\n                    if (doc._data.passportId === first._data.passportId)\n                        throw new Error('still here after remove()');\n                });\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should remove all revisions","suites":[".remove()","positive"],"updatePoint":{"line":186,"column":43},"line":186,"code":"            it('should remove all revisions', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec();\n                assert.ok(doc);\n\n                // update some times to generate revisions\n                await doc.atomicUpdate((docData: any) => {\n                    docData.age++;\n                    return docData;\n                });\n                await doc.atomicUpdate((docData: any) => {\n                    docData.age++;\n                    return docData;\n                });\n                await doc.atomicUpdate((docData: any) => {\n                    docData.age = 100;\n                    return docData;\n                });\n                const doc2: any = await c.findOne().exec();\n                assert.strictEqual(doc2.age, 100);\n\n                await doc2.remove();\n                const doc3 = await c.findOne().exec();\n                assert.strictEqual(doc3, null);\n\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"delete all in parrallel","suites":[".remove()","positive"],"updatePoint":{"line":213,"column":39},"line":213,"code":"            it('delete all in parrallel', async () => {\n                const c = await humansCollection.create(5);\n                const docs = await c.find().exec();\n                const fns: any[] = [];\n                docs.map(doc => fns.push(doc.remove()));\n                await Promise.all(fns);\n                const docsAfter = await c.find().exec();\n                assert.strictEqual(docsAfter.length, 0);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"save and then remove","suites":[".remove()","positive"],"updatePoint":{"line":223,"column":36},"line":223,"code":"            it('save and then remove', async () => {\n                const c = await humansCollection.create(5);\n                const docs = await c.find().exec();\n                assert.ok(docs.length > 1);\n                const first = docs[0];\n\n                await first.atomicPatch({ firstName: 'foobar' });\n\n                await first.remove();\n                const docsAfter = await c.find().exec();\n                docsAfter.map(doc => {\n                    if (doc._data.passportId === first._data.passportId)\n                        throw new Error('still here after remove()');\n                });\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"delete doc twice","suites":[".remove()","negative"],"updatePoint":{"line":241,"column":32},"line":241,"code":"            it('delete doc twice', async () => {\n                const c = await humansCollection.create(5);\n                const doc: any = await c.findOne().exec();\n                await doc.remove();\n                await AsyncTestUtil.assertThrows(\n                    () => doc.remove(),\n                    'RxError',\n                    'already'\n                );\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"$set a value with a mongo like query","suites":[".update()","positive"],"updatePoint":{"line":256,"column":52},"line":256,"code":"            it('$set a value with a mongo like query', async () => {\n                const c = await humansCollection.createPrimary(1);\n                const doc: any = await c.findOne().exec(true);\n                await doc.update({\n                    $set: {\n                        firstName: 'new first name'\n                    }\n                });\n                const updatedDoc = await c.findOne({\n                    selector: {\n                        firstName: 'new first name'\n                    }\n                }).exec(true);\n                assert.strictEqual(updatedDoc.firstName, 'new first name');\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"$unset a value with a mongo like query","suites":[".update()","positive"],"updatePoint":{"line":272,"column":54},"line":272,"code":"            it('$unset a value with a mongo like query', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec(true);\n                await doc.update({\n                    $unset: {\n                        age: ''\n                    }\n                });\n                const updatedDoc: any = await c.findOne().exec(true);\n                assert.strictEqual(updatedDoc.age, undefined);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"$inc a value with a mongo like query","suites":[".update()","positive"],"updatePoint":{"line":284,"column":52},"line":284,"code":"            it('$inc a value with a mongo like query', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec(true);\n                const agePrev = doc.age;\n                await doc.update({\n                    $inc: {\n                        age: 1\n                    }\n                });\n                assert.strictEqual(doc.age, agePrev + 1);\n                await doc.save;\n                const updatedDoc: any = await c.findOne().exec(true);\n                assert.strictEqual(updatedDoc.age, agePrev + 1);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should throw if schema does not match","suites":[".update()","negative"],"updatePoint":{"line":301,"column":53},"line":301,"code":"            it('should throw if schema does not match', async () => {\n                const schema: RxJsonSchema<{ id: string; childProperty: 'A' | 'B' | 'C' }> = {\n                    version: 0,\n                    type: 'object',\n                    primaryKey: 'id',\n                    required: ['id'],\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        childProperty: {\n                            type: 'string',\n                            enum: ['A', 'B', 'C']\n                        }\n                    }\n                };\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema\n                    }\n                });\n\n                // on doc\n                const doc = await cols.humans.insert({\n                    id: randomCouchString(12),\n                    childProperty: 'A'\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => doc.update({\n                        $set: {\n                            childProperty: 'Z'\n                        }\n                    }),\n                    'RxError',\n                    'schema'\n                );\n                db.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should throw when final field is modified","suites":[".update()","negative"],"updatePoint":{"line":344,"column":57},"line":344,"code":"            it('should throw when final field is modified', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.humanFinal,\n                        methods: {\n                            foo() {\n                                return 'bar';\n                            }\n                        }\n                    }\n                });\n                const docData = schemaObjects.human();\n                docData.age = 1;\n                const doc = await cols.humans.insert(docData);\n                await AsyncTestUtil.assertThrows(\n                    () => doc.update({\n                        $inc: {\n                            age: 1\n                        }\n                    }),\n                    'RxError',\n                    'final'\n                );\n                db.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"run one update","suites":[".atomicUpdate()","positive"],"updatePoint":{"line":377,"column":30},"line":377,"code":"            it('run one update', async () => {\n                const c = await humansCollection.createNested(1);\n                const doc = await c.findOne().exec(true);\n\n                const returnedDoc = await doc.atomicUpdate((innerDoc: any) => {\n                    innerDoc.firstName = 'foobar';\n                    return innerDoc;\n                });\n                assert.strictEqual('foobar', doc.firstName);\n                assert.ok(doc === returnedDoc);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"run two updates (last write wins)","suites":[".atomicUpdate()","positive"],"updatePoint":{"line":389,"column":49},"line":389,"code":"            it('run two updates (last write wins)', async () => {\n                const c = await humansCollection.createNested(1);\n                const doc = await c.findOne().exec(true);\n\n                doc.atomicUpdate((innerDoc: any) => {\n                    innerDoc.firstName = 'foobar';\n                    return innerDoc;\n                });\n                await doc.atomicUpdate((innerDoc: any) => {\n                    innerDoc.firstName = 'foobar2';\n                    return innerDoc;\n                });\n                assert.strictEqual('foobar2', doc.firstName);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"do many updates (last write wins)","suites":[".atomicUpdate()","positive"],"updatePoint":{"line":404,"column":49},"line":404,"code":"            it('do many updates (last write wins)', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec(true);\n                let lastPromise;\n                let t = 0;\n                new Array(10).fill(0)\n                    .map(() => {\n                        t++;\n                        return t;\n                    })\n                    .forEach(x => lastPromise = doc.atomicUpdate((innerDoc: any) => {\n                        innerDoc.age = x;\n                        return innerDoc;\n                    }));\n                await lastPromise;\n                assert.strictEqual(t, doc.age);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"run async functions","suites":[".atomicUpdate()","positive"],"updatePoint":{"line":422,"column":35},"line":422,"code":"            it('run async functions', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec();\n                let lastPromise;\n                let t = 0;\n                new Array(10).fill(0)\n                    .map(() => {\n                        t++;\n                        return t;\n                    })\n                    .forEach(x => lastPromise = doc.atomicUpdate(async (innerDoc: any) => {\n                        await promiseWait(1);\n                        innerDoc.age = x;\n                        return innerDoc;\n                    }));\n                await lastPromise;\n                assert.strictEqual(t, doc.age);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should work when inserting on a slow storage","suites":[".atomicUpdate()","positive"],"updatePoint":{"line":441,"column":60},"line":441,"code":"            it('should work when inserting on a slow storage', async () => {\n                if (!config.platform.isNode()) return;\n                // use a 'slow' adapter because memory might be to fast\n                const leveldown = require('leveldown');\n                const db = await createRxDatabase({\n                    name: config.rootPath + 'test_tmp/' + randomCouchString(10),\n                    storage: getRxStoragePouch(leveldown),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.primaryHuman\n                    }\n                });\n                const c = cols.humans;\n                await c.insert(schemaObjects.simpleHuman());\n                const doc = await c.findOne().exec();\n                doc.atomicUpdate((innerDoc: any) => {\n                    innerDoc.firstName = 'foobar';\n                    return innerDoc;\n                });\n                await doc.atomicUpdate((innerDoc: any) => {\n                    innerDoc.firstName = 'foobar2';\n                    return innerDoc;\n                });\n                await AsyncTestUtil.wait(50);\n                await doc.atomicUpdate((innerDoc: any) => {\n                    innerDoc.firstName = 'foobar3';\n                    return innerDoc;\n                });\n                assert.strictEqual('foobar3', doc.firstName);\n\n                db.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should be persistent when re-creating the database","suites":[".atomicUpdate()","positive"],"updatePoint":{"line":474,"column":66},"line":474,"code":"            it('should be persistent when re-creating the database', async () => {\n                if (!config.platform.isNode()) return;\n                // use a 'slow' adapter because memory might be to fast\n                const leveldown = require('leveldown');\n\n                const dbName = config.rootPath + 'test_tmp/' + randomCouchString(10);\n                const db = await createRxDatabase({\n                    name: dbName,\n                    storage: getRxStoragePouch(leveldown),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.primaryHuman\n                    }\n                });\n                const c = cols.humans;\n                await c.insert(schemaObjects.simpleHuman());\n                const doc = await c.findOne().exec();\n                const docData = doc.toJSON();\n                assert.ok(docData);\n                await doc.atomicUpdate((innerDoc: any) => {\n                    innerDoc.firstName = 'foobar';\n                    return innerDoc;\n                });\n                assert.strictEqual(doc.firstName, 'foobar');\n                await db.destroy();\n\n                // same again\n                const db2 = await createRxDatabase({\n                    name: dbName,\n                    storage: getRxStoragePouch(leveldown),\n                });\n                const cols2 = await db2.addCollections({\n                    humans: {\n                        schema: schemas.primaryHuman\n                    }\n                });\n                const c2 = cols2.humans;\n                const doc2 = await c2.findOne().exec();\n                assert.strictEqual(doc.passportId, doc2.passportId);\n                const docData2 = doc2.toJSON();\n                assert.ok(docData2);\n                assert.strictEqual(doc2.firstName, 'foobar');\n                db2.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should retry on conflict errors","suites":[".atomicUpdate()","positive"],"updatePoint":{"line":519,"column":47},"line":519,"code":"            it('should retry on conflict errors', async () => {\n                const dbName = randomCouchString(10);\n                const db = await createRxDatabase({\n                    name: dbName,\n                    storage: getRxStoragePouch('memory'),\n                });\n\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.primaryHuman\n                    }\n                });\n                const c = cols.humans;\n                const doc = await c.insert(schemaObjects.simpleHuman());\n                const db2 = await createRxDatabase({\n                    name: dbName,\n                    storage: getRxStoragePouch('memory'),\n                    ignoreDuplicate: true\n                });\n                const cols2 = await db2.addCollections({\n                    humans: {\n                        schema: schemas.primaryHuman\n                    }\n                });\n                const c2 = cols2.humans;\n                const doc2 = await c2.findOne().exec(true);\n\n                await Promise.all([\n                    doc.atomicUpdate((d: any) => {\n                        d.firstName = 'foobar1';\n                        return d;\n                    }),\n                    doc2.atomicUpdate((d: any) => {\n                        d.firstName = 'foobar2';\n                        return d;\n                    })\n                ]);\n\n                db.destroy();\n                db2.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should throw when not matching schema","suites":[".atomicUpdate()","negative"],"updatePoint":{"line":562,"column":53},"line":562,"code":"            it('should throw when not matching schema', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec();\n                await doc.atomicUpdate((innerDoc: any) => {\n                    innerDoc.age = 50;\n                    return innerDoc;\n                });\n                assert.strictEqual(doc.age, 50);\n                await AsyncTestUtil.assertThrows(\n                    () => doc.atomicUpdate((innerDoc: any) => {\n                        innerDoc.age = 'foobar';\n                        return innerDoc;\n                    }),\n                    'RxError',\n                    'schema'\n                );\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should throw when final field is modified","suites":[".atomicUpdate()","negative"],"updatePoint":{"line":580,"column":57},"line":580,"code":"            it('should throw when final field is modified', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.humanFinal,\n                        methods: {\n                            foo() {\n                                return 'bar';\n                            }\n                        }\n                    }\n                });\n                const col = cols.humans;\n                const docData = schemaObjects.human();\n                docData.age = 1;\n                const doc = await col.insert(docData);\n\n                await AsyncTestUtil.assertThrows(\n                    () => doc.atomicUpdate((data: any) => {\n                        data.age = 100;\n                        return data;\n                    }),\n                    'RxError',\n                    'final'\n                );\n                db.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should still be useable if previous mutation function has thrown","suites":[".atomicUpdate()","negative"],"updatePoint":{"line":610,"column":80},"line":610,"code":"            it('should still be useable if previous mutation function has thrown', async () => {\n                const col = await humansCollection.create(1);\n                const doc = await col.findOne().exec(true);\n\n                try {\n                    await doc.atomicUpdate(() => {\n                        throw new Error('ouch');\n                    });\n                } catch (err) { }\n                // async mutation\n                try {\n                    await doc.atomicUpdate(async () => {\n                        await wait(10);\n                        throw new Error('ouch');\n                    });\n                } catch (err) { }\n\n                await doc.atomicUpdate(d => {\n                    d.age = 150;\n                    return d;\n                });\n\n                assert.strictEqual(doc.age, 150);\n                col.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"run one update","suites":[".atomicPatch()","positive"],"updatePoint":{"line":639,"column":30},"line":639,"code":"            it('run one update', async () => {\n                const c = await humansCollection.createNested(1);\n                const doc = await c.findOne().exec(true);\n\n                const returnedDoc = await doc.atomicPatch({\n                    firstName: 'foobar'\n                });\n                assert.strictEqual('foobar', doc.firstName);\n                assert.ok(doc === returnedDoc);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"unset optional property by assigning undefined","suites":[".atomicPatch()","positive"],"updatePoint":{"line":650,"column":62},"line":650,"code":"            it('unset optional property by assigning undefined', async () => {\n                const c = await humansCollection.createNested(1);\n                const doc = await c.findOne().exec(true);\n\n                assert.ok(doc.mainSkill);\n\n                await doc.atomicPatch({\n                    mainSkill: undefined\n                });\n\n                assert.strictEqual(doc.mainSkill, undefined);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should crash on non document field","suites":[".atomicPatch()","negative"],"updatePoint":{"line":665,"column":50},"line":665,"code":"            it('should crash on non document field', async () => {\n                const c = await humansCollection.createNested(1);\n                const doc = await c.findOne().exec(true);\n                await AsyncTestUtil.assertThrows(\n                    () => doc.atomicPatch({\n                        foobar: 'foobar'\n                    } as any),\n                    'RxError'\n                );\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should get the documents data as json","suites":[".toJSON()"],"updatePoint":{"line":679,"column":49},"line":679,"code":"        it('should get the documents data as json', async () => {\n            const c = await humansCollection.create(1);\n            const doc: any = await c.findOne().exec();\n            const json = doc.toJSON(true);\n\n            assert.ok(json.passportId);\n            assert.ok(json.firstName);\n            assert.ok(json._rev); // when toJSON(true), the _rev field is also returned\n            c.database.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should get a fresh object each time","suites":[".toJSON()"],"updatePoint":{"line":689,"column":47},"line":689,"code":"        it('should get a fresh object each time', async () => {\n            const c = await humansCollection.create(1);\n            const doc = await c.findOne().exec(true);\n            const json = doc.toJSON();\n            const json2 = doc.toJSON();\n            assert.ok(json !== json2);\n            c.database.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should not return meta fields if not wanted","suites":[".toJSON()"],"updatePoint":{"line":697,"column":55},"line":697,"code":"        it('should not return meta fields if not wanted', async () => {\n            const c = await humansCollection.create(0);\n            await c.insert({\n                passportId: 'aatspywninca',\n                firstName: 'Tester',\n                lastName: 'Test',\n                age: 10\n            });\n            const newHuman = await c.findOne('aatspywninca').exec(true);\n            const jsonWithWithoutMetaFields = newHuman.toJSON();\n\n            const metaField = Object.keys(jsonWithWithoutMetaFields).find(key => key.startsWith('_'));\n            if (metaField) {\n                throw new Error('should not contain meta field ' + metaField);\n            }\n\n            c.database.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should not return _attachments if not wanted","suites":[".toJSON()"],"updatePoint":{"line":715,"column":56},"line":715,"code":"        it('should not return _attachments if not wanted', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n                multiInstance: false,\n                ignoreDuplicate: true\n            });\n            const schemaJson = AsyncTestUtil.clone(schemas.human);\n            schemaJson.attachments = {};\n            const cols = await db.addCollections({\n                humans: {\n                    schema: schemaJson\n                }\n            });\n            const c = cols.humans;\n\n            const doc = await c.insert(schemaObjects.human());\n            await doc.putAttachment({\n                id: 'sampledata',\n                data: blobBufferUtil.createBlobBuffer('foo bar', 'application/octet-stream'),\n                type: 'application/octet-stream'\n            });\n\n            const withMeta = doc.toJSON(true);\n            assert.ok(withMeta._rev);\n            assert.ok(withMeta._attachments);\n\n            const withoutMeta = doc.toJSON(false);\n            assert.strictEqual(typeof withoutMeta._rev, 'undefined');\n            assert.strictEqual(typeof withoutMeta._attachments, 'undefined');\n\n            db.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should be able to mutate the output","suites":[".toMutableJSON()"],"updatePoint":{"line":750,"column":47},"line":750,"code":"        it('should be able to mutate the output', async () => {\n            const c = await humansCollection.create(1);\n            const doc = await c.findOne().exec(true);\n            const json = doc.toMutableJSON();\n            json.firstName = 'alice';\n            c.database.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"top-value","suites":["pseudo-Proxy","get"],"updatePoint":{"line":760,"column":25},"line":760,"code":"            it('top-value', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec(true);\n                const passportId = doc.get('passportId');\n                assert.strictEqual(doc.passportId, passportId);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"hidden properties should not show up","suites":["pseudo-Proxy","get"],"updatePoint":{"line":767,"column":52},"line":767,"code":"            it('hidden properties should not show up', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec(true);\n                assert.ok(!Object.keys(doc).includes('lastName_'));\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"nested-value","suites":["pseudo-Proxy","get"],"updatePoint":{"line":773,"column":28},"line":773,"code":"            it('nested-value', async () => {\n                const c = await humansCollection.createNested(1);\n                const doc = await c.findOne().exec(true);\n                const mainSkillLevel = doc.get('mainSkill.level');\n                assert.strictEqual(doc.mainSkill.level, mainSkillLevel);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"deep-nested-value","suites":["pseudo-Proxy","get"],"updatePoint":{"line":780,"column":33},"line":780,"code":"            it('deep-nested-value', async () => {\n                const c = await humansCollection.createDeepNested(1);\n                const doc = await c.findOne().exec(true);\n                const value = doc.get('mainSkill.attack.count');\n                assert.strictEqual(doc.mainSkill.attack.count, value);\n\n                const value2 = doc.get('mainSkill.attack.good');\n                assert.strictEqual(doc.mainSkill.attack.good, value2);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"top-value-observable","suites":["pseudo-Proxy","get"],"updatePoint":{"line":790,"column":36},"line":790,"code":"            it('top-value-observable', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec(true);\n                const obs = doc.firstName$;\n                assert.ok(obs.subscribe);\n\n                let value = null;\n                obs.subscribe((newVal: any) => {\n                    value = newVal;\n                });\n\n                await doc.atomicPatch({ firstName: 'foobar' });\n\n                await promiseWait(5);\n                assert.strictEqual(value, 'foobar');\n\n                // resubscribe should emit again\n                let value2 = null;\n                obs.subscribe((newVal: any) => {\n                    value2 = newVal;\n                });\n                await promiseWait(5);\n                assert.strictEqual(value2, 'foobar');\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"nested-value-observable","suites":["pseudo-Proxy","get"],"updatePoint":{"line":815,"column":39},"line":815,"code":"            it('nested-value-observable', async () => {\n                const c = await humansCollection.createNested(1);\n                const doc = await c.findOne().exec(true);\n                const obs: Observable<any> = (doc.mainSkill as any).level$;\n                assert.ok(obs['subscribe']);\n\n                let value = null;\n                (doc.mainSkill as any).level$.subscribe((newVal: any) => {\n                    value = newVal;\n                });\n\n                await doc.atomicPatch({\n                    mainSkill: {\n                        name: randomCouchString(5),\n                        level: 10\n                    }\n                });\n                await promiseWait(5);\n                assert.strictEqual(value, 10);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"deep-nested-value-observable","suites":["pseudo-Proxy","get"],"updatePoint":{"line":836,"column":44},"line":836,"code":"            it('deep-nested-value-observable', async () => {\n                const c = await humansCollection.createDeepNested(1);\n                const doc = await c.findOne().exec(true);\n                const obs = (doc.mainSkill.attack as any).good$;\n                assert.ok(obs.subscribe);\n\n                let value = null;\n                (doc.mainSkill.attack as any).good$.subscribe((newVal: any) => {\n                    value = newVal;\n                });\n                await doc.atomicPatch({\n                    mainSkill: {\n                        name: 'foobar',\n                        attack: {\n                            good: true,\n                            count: 100\n                        }\n\n                    }\n                });\n                await promiseWait(5);\n                assert.strictEqual(value, true);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should not work on non-temporary document","suites":["pseudo-Proxy","set"],"updatePoint":{"line":862,"column":57},"line":862,"code":"            it('should not work on non-temporary document', async () => {\n                const c = await humansCollection.createPrimary(1);\n                const doc = await c.findOne().exec(true);\n                assert.throws(\n                    () => doc.firstName = 'foobar'\n                );\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"#66 - insert -> remove -> upsert does not give new state","suites":["issues"],"updatePoint":{"line":873,"column":68},"line":873,"code":"        it('#66 - insert -> remove -> upsert does not give new state', async () => {\n            const c = await humansCollection.createPrimary(0);\n            const docData = schemaObjects.simpleHuman();\n            const primary = docData.passportId;\n\n\n            // insert\n            await c.insert(docData);\n            const doc1 = await c.findOne(primary).exec(true);\n            assert.strictEqual(doc1.firstName, docData.firstName);\n\n            // remove\n            await doc1.remove();\n\n            // upsert\n            docData.firstName = 'foobar';\n            await c.upsert(docData);\n            const doc2 = await c.findOne(primary).exec(true);\n            assert.strictEqual(doc2.firstName, 'foobar');\n\n            c.database.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"#76 - deepEqual does not work correctly for Arrays","suites":["issues"],"updatePoint":{"line":919,"column":62},"line":919,"code":"        it('#76 - deepEqual does not work correctly for Arrays', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n            });\n            const cols = await await db.addCollections({\n                heroes: {\n                    schema: schemas.simpleArrayHero\n                }\n            });\n            const col = cols.heroes;\n            const docData = {\n                name: 'foobar',\n                skills: [\n                    'skill1',\n                    'skill2',\n                    'skill3'\n                ]\n            };\n            await col.insert(docData);\n            const doc = await col.findOne().exec();\n            assert.strictEqual(doc.skills.length, 3);\n\n            const newSkill = 'newSikSkill';\n            await doc.atomicPatch({ skills: doc.skills.concat(newSkill) });\n\n            const colDump = await col.exportJSON();\n            const afterSkills = colDump.docs[0].skills;\n            assert.strictEqual(afterSkills.length, 4);\n            assert.ok(afterSkills.includes(newSkill));\n            db.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"#646 Skip defining getter and setter when property not defined in schema","suites":["issues"],"updatePoint":{"line":951,"column":84},"line":951,"code":"        it('#646 Skip defining getter and setter when property not defined in schema', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n            });\n            const schema = {\n                version: 0,\n                primaryKey: 'key',\n                type: 'object',\n                properties: {\n                    key: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    value: {\n                        type: 'object'\n                    }\n                },\n                required: ['key']\n            };\n            const cols = await await db.addCollections({\n                heroes: {\n                    schema\n                }\n            });\n            const col = cols.heroes;\n\n            const doc = await col.insert({\n                key: 'foobar',\n                value: {\n                    x: {\n                        foo: 'bar'\n                    }\n                }\n            });\n\n            const value = doc.get('value.x');\n            assert.strictEqual(value.foo, 'bar');\n\n            db.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"#734 Invalid value persists in document after failed update","suites":["issues"],"updatePoint":{"line":992,"column":71},"line":992,"code":"        it('#734 Invalid value persists in document after failed update', async () => {\n            // create a schema\n            const schemaEnum = ['A', 'B'];\n            const mySchema: RxJsonSchema<{ id: string, children: any[] }> = {\n                version: 0,\n                primaryKey: 'id',\n                required: ['id'],\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    children: {\n                        type: 'array',\n                        items: {\n                            type: 'object',\n                            properties: {\n                                name: {\n                                    type: 'string'\n                                },\n                                abLetter: {\n                                    type: 'string',\n                                    enum: schemaEnum,\n                                },\n                            }\n                        }\n                    }\n                }\n            };\n\n            // generate a random database-name\n            const name = randomCouchString(10);\n\n            // create a database\n            const db = await createRxDatabase({\n                name,\n                storage: getRxStoragePouch('memory'),\n                ignoreDuplicate: true\n            });\n            // create a collection\n            const colName = randomCouchString(10);\n            const collections = await db.addCollections({\n                [colName]: {\n                    schema: mySchema\n                }\n            });\n            const collection = collections[colName];\n\n            // insert a document\n            const child1 = {\n                name: 'foo',\n                abLetter: 'A'\n            };\n            const child2 = {\n                name: 'bar',\n                abLetter: 'B'\n            };\n            const doc = await collection.insert({\n                id: randomCouchString(12),\n                children: [\n                    child1,\n                    child2\n                ],\n            });\n\n            const colDoc = await collection.findOne({\n                selector: {\n                    id: doc.id\n                }\n            }).exec();\n\n\n            try {\n                await colDoc.update({\n                    $set: {\n                        'children.1.abLetter': 'invalidEnumValue',\n                    },\n                });\n            } catch (err) { }\n\n            assert.strictEqual(colDoc.children[1].abLetter, 'B');\n\n\n            // clean up afterwards\n            db.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"#830 should return a rejected promise when already deleted","suites":["issues"],"updatePoint":{"line":1079,"column":70},"line":1079,"code":"        it('#830 should return a rejected promise when already deleted', async () => {\n            const c = await humansCollection.createPrimary(1);\n            const doc = await c.findOne().exec(true);\n            assert.ok(doc);\n            await doc.remove();\n            assert.ok(doc.deleted);\n            const ret = doc.remove();\n            if (!ret) {\n                throw new Error('missing');\n            }\n            assert.strictEqual(typeof ret.then, 'function'); // ensure it's a promise\n            await AsyncTestUtil.assertThrows(\n                () => ret,\n                'RxError',\n                'already deleted'\n            );\n            c.database.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"#1325 populate should return null when value is falsy","suites":["issues"],"updatePoint":{"line":1097,"column":65},"line":1097,"code":"        it('#1325 populate should return null when value is falsy', async () => {\n            const collection = await humansCollection.createRelated();\n            const doc = await collection.findOne({\n                selector: {\n                    bestFriend: { $exists: true }\n                }\n            }).exec(true);\n\n            await doc.update({\n                $set: {\n                    bestFriend: ''\n                }\n            });\n            const populate = await doc.populate('bestFriend');\n\n            assert.strictEqual(populate, null);\n\n            collection.database.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should throw dev-mode error on wrong query object","suites":[".constructor"],"updatePoint":{"line":27,"column":61},"line":27,"code":"        it('should throw dev-mode error on wrong query object', async () => {\n            const col = await humansCollection.create(0);\n\n            await AsyncTestUtil.assertThrows(\n                () => col.find({ foo: 'bar' } as any),\n                'RxTypeError',\n                'no valid query params'\n            );\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should throw error when custom index not in schema indexes","suites":[".constructor"],"updatePoint":{"line":38,"column":70},"line":38,"code":"        it('should throw error when custom index not in schema indexes', async () => {\n            const col = await humansCollection.create(0);\n            await AsyncTestUtil.assertThrows(\n                () => col.find({\n                    selector: {},\n                    index: ['f', 'o', 'b', 'a', 'r']\n                }).getPreparedQuery(),\n                'RxError',\n                'not in schem'\n            );\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should NOT throw error when custom index is in schema indexes","suites":[".constructor"],"updatePoint":{"line":50,"column":73},"line":50,"code":"        it('should NOT throw error when custom index is in schema indexes', async () => {\n            const col = await humansCollection.createAgeIndex(0);\n            col.find({\n                selector: {},\n                index: ['age']\n            }).getPreparedQuery();\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should produce the correct selector-object","suites":[".toJSON()"],"updatePoint":{"line":60,"column":54},"line":60,"code":"        it('should produce the correct selector-object', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age');\n            const queryObj = q.mangoQuery;\n            assert.deepStrictEqual(queryObj, {\n                selector: {\n                    name: {\n                        '$ne': 'Alice'\n                    },\n                    age: {\n                        '$gt': 18,\n                        '$lt': 67\n                    }\n                },\n                sort: [{\n                    age: 'desc'\n                }],\n                limit: 10\n            });\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should get a valid string-representation","suites":[".toString()"],"updatePoint":{"line":87,"column":52},"line":87,"code":"        it('should get a valid string-representation', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age');\n            const str = q.toString();\n            const mustString = '{\"op\":\"find\",\"other\":{\"queryBuilderPath\":\"age\"},\"query\":{\"limit\":10,\"selector\":{\"age\":{\"$gt\":18,\"$lt\":67},\"name\":{\"$ne\":\"Alice\"}},\"sort\":[{\"age\":\"desc\"}]}}';\n            assert.strictEqual(str, mustString);\n            const str2 = q.toString();\n            assert.strictEqual(str2, mustString);\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should get a valid string-representation with two sort params","suites":[".toString()"],"updatePoint":{"line":102,"column":73},"line":102,"code":"        it('should get a valid string-representation with two sort params', async () => {\n            const col = await humansCollection.createAgeIndex();\n            const q = col.find().sort({\n                passportId: 'desc', age: 'desc'\n            });\n            const str = q.toString();\n            const mustString = '{\"op\":\"find\",\"other\":{},\"query\":{\"selector\":{},\"sort\":[{\"passportId\":\"desc\"},{\"age\":\"desc\"}]}}';\n            assert.strictEqual(str, mustString);\n            const str2 = q.toString();\n            assert.strictEqual(str2, mustString);\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"ISSUE #190: should contain the regex","suites":[".toString()"],"updatePoint":{"line":115,"column":48},"line":115,"code":"        it('ISSUE #190: should contain the regex', async () => {\n            if (!config.storage.hasRegexSupport) {\n                return;\n            }\n\n            const col = await humansCollection.create(0);\n            const queryWithoutRegex = col.find();\n            const queryWithRegex = queryWithoutRegex.where('color').regex(new RegExp(/foobar/g));\n            const queryString = queryWithRegex.toString();\n\n            assert.ok(queryString.includes('foobar'));\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"same queries should return the same string","suites":[".toString()"],"updatePoint":{"line":128,"column":54},"line":128,"code":"        it('same queries should return the same string', async () => {\n            const col1 = await humansCollection.create(0);\n            const col2 = await humansCollection.create(0);\n\n            const query1 = col1.find()\n                .where('age').gt(10)\n                .where('name').ne('foobar')\n                .sort('passportId').toString();\n\n            const query2 = col2.find()\n                .where('age').gt(10)\n                .where('name').ne('foobar')\n                .sort('passportId').toString();\n\n            assert.strictEqual(query1, query2);\n            col1.database.destroy();\n            col2.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"same queries should return the same string even if on same collection","suites":[".toString()"],"updatePoint":{"line":146,"column":81},"line":146,"code":"        it('same queries should return the same string even if on same collection', async () => {\n            const col = await humansCollection.create(0);\n\n            const query1 = col.find()\n                .where('age').gt(10)\n                .where('name').ne('foobar')\n                .sort('passportId').toString();\n\n            const query2 = col.find()\n                .where('age').gt(10)\n                .where('name').ne('foobar')\n                .sort('passportId').toString();\n\n            assert.strictEqual(query1, query2);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should not be the same object (sort)","suites":["immutable"],"updatePoint":{"line":164,"column":48},"line":164,"code":"        it('should not be the same object (sort)', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age');\n            const q2 = q.sort('name');\n            assert.ok(isRxQuery(q2));\n            assert.notStrictEqual(q, q2);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should not be the same object (where)","suites":["immutable"],"updatePoint":{"line":176,"column":49},"line":176,"code":"        it('should not be the same object (where)', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age');\n            const q2 = q.where('name').eq('foobar');\n            assert.ok(isRxQuery(q2));\n            assert.notStrictEqual(q, q2);\n            assert.ok(q.id < q2.id);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"return the same object","suites":["QueryCache.js"],"updatePoint":{"line":191,"column":34},"line":191,"code":"        it('return the same object', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age');\n            const q2 = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age');\n\n            assert.deepStrictEqual(q, q2);\n            assert.strictEqual(q.id, q2.id);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should return the same object after exec","suites":["QueryCache.js"],"updatePoint":{"line":208,"column":52},"line":208,"code":"        it('should return the same object after exec', async () => {\n            const col = await humansCollection.createPrimary(0);\n            const docData = schemaObjects.simpleHuman();\n            await col.insert(docData);\n            const query = col.findOne(docData.passportId);\n            await query.exec();\n            const query2 = col.findOne(docData.passportId);\n            await query2.exec();\n            assert.strictEqual(query.id, query2.id);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should have the correct amount of cached queries","suites":["QueryCache.js"],"updatePoint":{"line":219,"column":60},"line":219,"code":"        it('should have the correct amount of cached queries', async () => {\n            const col = await humansCollection.create(0);\n            const q3 = col.find()\n                .where('name').ne('Bob');\n            assert.ok(q3);\n            const q = col.find()\n                .where('name').ne('Alice');\n            assert.ok(q);\n            const q2 = col.find()\n                .where('name').ne('Bob');\n            assert.ok(q2);\n            assert.strictEqual(col._queryCache._map.size, 4);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"return another object","suites":["QueryCache.js"],"updatePoint":{"line":233,"column":33},"line":233,"code":"        it('return another object', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age');\n            const q2 = col.find()\n                .where('name').ne('foobar')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age');\n\n            assert.notStrictEqual(q, q2);\n            assert.notStrictEqual(q.id, q2.id);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"ISSUE: ensure its the same query","suites":["QueryCache.js"],"updatePoint":{"line":250,"column":44},"line":250,"code":"        it('ISSUE: ensure its the same query', async () => {\n            const col = await humansCollection.create(0);\n\n            const query1 = col.find()\n                .where('age').gt(10)\n                .where('name').ne('foobar')\n                .sort('passportId');\n\n            const query2 = col.find()\n                .where('age').gt(10)\n                .where('name').ne('foobar')\n                .sort('passportId');\n\n            assert.ok(query1 === query2);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should distinguish between different sort-orders","suites":["QueryCache.js"],"updatePoint":{"line":267,"column":60},"line":267,"code":"        it('should distinguish between different sort-orders', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age')\n                .sort('name');\n            const q2 = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('name')\n                .sort('-age');\n\n            assert.notStrictEqual(q, q2);\n            assert.notStrictEqual(q.id, q2.id);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should reuse the cached result object in the document","suites":["result caching"],"updatePoint":{"line":294,"column":65},"line":294,"code":"        it('should reuse the cached result object in the document', async () => {\n            const col = await humansCollection.create(1);\n            const query = col.find({\n                selector: {\n                    firstName: {\n                        $ne: 'foobar'\n                    }\n                }\n            });\n            const docs = await query.exec();\n            const doc = docs[0];\n            if (!doc) {\n                throw new Error('doc missing');\n            }\n\n            const docDataObject = doc._dataSync$.getValue();\n            const inQueryCacheObject = ensureNotFalsy(query._result).docsData[0];\n\n            assert.ok(\n                docDataObject === inQueryCacheObject\n            );\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should match","suites":[".doesDocMatchQuery()"],"updatePoint":{"line":320,"column":24},"line":320,"code":"        it('should match', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find().where('firstName').ne('foobar');\n            const docData = schemaObjects.human();\n            assert.ok(q.doesDocumentDataMatch(docData));\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should not match","suites":[".doesDocMatchQuery()"],"updatePoint":{"line":327,"column":28},"line":327,"code":"        it('should not match', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find().where('firstName').ne('foobar');\n            const docData = schemaObjects.human();\n            docData.firstName = 'foobar';\n            assert.strictEqual(false, q.doesDocumentDataMatch(docData));\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should match ($gt)","suites":[".doesDocMatchQuery()"],"updatePoint":{"line":335,"column":30},"line":335,"code":"        it('should match ($gt)', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find().where('age').gt(1);\n            const docData = schemaObjects.human();\n            docData.age = 5;\n            assert.ok(q.doesDocumentDataMatch(docData));\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should not match ($gt)","suites":[".doesDocMatchQuery()"],"updatePoint":{"line":343,"column":34},"line":343,"code":"        it('should not match ($gt)', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find().where('age').gt(100);\n            const docData = schemaObjects.human();\n            docData.age = 5;\n            assert.strictEqual(false, q.doesDocumentDataMatch(docData));\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"BUG: this should match","suites":[".doesDocMatchQuery()"],"updatePoint":{"line":351,"column":34},"line":351,"code":"        it('BUG: this should match', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find();\n\n            const docData = {\n                passportId: 'foobar',\n                color: 'green',\n                hp: 100,\n                maxHP: 767,\n                name: 'asdfsadf',\n                _rev: '1-971bfd0b8749eb33b6aae7f6c0dc2cd4'\n            };\n\n            assert.strictEqual(true, q.doesDocumentDataMatch(docData));\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"BUG should not match regex","suites":[".doesDocMatchQuery()"],"updatePoint":{"line":367,"column":38},"line":367,"code":"        it('BUG should not match regex', async () => {\n            if (!config.storage.hasRegexSupport) {\n                return;\n            }\n            const col = await humansCollection.create(0);\n\n\n            // TODO using $and fails, we have to open an issue at the pouchdb repo\n            /*\n           const q = col.find({\n                selector: {\n                    $and: [{\n                        color: {\n                            $regex: new RegExp('f', 'i')\n                        }\n                    }]\n                }\n            });\n            */\n\n            const q = col.find({\n                selector: {\n                    color: {\n                        $regex: new RegExp('f', 'i')\n                    }\n                }\n            });\n\n            const docData = {\n                _id: 'mydoc',\n                color: 'green',\n                hp: 100,\n                maxHP: 767,\n                name: 'asdfsadf',\n                _rev: '1-971bfd0b8749eb33b6aae7f6c0dc2cd4'\n            };\n\n            assert.strictEqual(false, q.doesDocumentDataMatch(docData));\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should throw if top level field is not known to the schema","suites":[".exec()"],"updatePoint":{"line":409,"column":70},"line":409,"code":"        it('should throw if top level field is not known to the schema', async () => {\n            const col = await humansCollection.create(0);\n\n            await AsyncTestUtil.assertThrows(\n                () => col.find({\n                    selector: {\n                        asdfasdfasdf: 'asdf'\n                    }\n                }).exec(),\n                'RxError',\n                'QU13'\n            );\n\n            // should also detect wrong fields inside of $and\n            await AsyncTestUtil.assertThrows(\n                () => col.find({\n                    selector: {\n                        $and: [\n                            {\n                                asdfasdfasdf: 'asdf'\n                            },\n                            {\n                                asdfasdfasdf: 'asdf'\n                            }\n                        ]\n                    }\n                }).exec(),\n                'RxError',\n                'QU13'\n            );\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"reusing exec should not make a execOverDatabase","suites":[".exec()"],"updatePoint":{"line":442,"column":59},"line":442,"code":"        it('reusing exec should not make a execOverDatabase', async () => {\n            const col = await humansCollection.create(2);\n            const q = col.find().where('passportId').ne('Alice');\n\n\n            let results = await q.exec();\n            assert.strictEqual(results.length, 2);\n            assert.strictEqual(q._execOverDatabaseCount, 1);\n\n            await promiseWait(5);\n            results = await q.exec();\n            assert.strictEqual(results.length, 2);\n            assert.strictEqual(q._execOverDatabaseCount, 1);\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should execOverDatabase when still subscribed and changeEvent comes in","suites":[".exec()"],"updatePoint":{"line":458,"column":82},"line":458,"code":"        it('should execOverDatabase when still subscribed and changeEvent comes in', async () => {\n            const col = await humansCollection.create(2);\n\n            // it is assumed that this query can never handled by event-reduce\n            const query = col.find().sort('-passportId').limit(1);\n\n            const fired: any[] = [];\n            const sub1 = query.$.subscribe(res => {\n                fired.push(res);\n            });\n\n            await AsyncTestUtil.waitUntil(() => fired.length === 1);\n\n            assert.strictEqual(query._execOverDatabaseCount, 1);\n            assert.strictEqual(query._latestChangeEvent, 2);\n\n            const addObj = schemaObjects.human();\n            addObj.passportId = 'zzzzzzzz';\n            await col.insert(addObj);\n            assert.strictEqual(query.collection._changeEventBuffer.counter, 3);\n\n            await AsyncTestUtil.waitUntil(() => query._latestChangeEvent === 3);\n            assert.strictEqual(query._latestChangeEvent, 3);\n\n            await AsyncTestUtil.waitUntil(() => fired.length === 2);\n            assert.strictEqual(fired[1].pop().passportId, addObj.passportId);\n            sub1.unsubscribe();\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"reusing exec should execOverDatabase when change happened that cannot be optimized","suites":[".exec()"],"updatePoint":{"line":487,"column":94},"line":487,"code":"        it('reusing exec should execOverDatabase when change happened that cannot be optimized', async () => {\n            const col = await humansCollection.create(2);\n\n            // it is assumed that this query can never handled by event-reduce\n            const q = col.find()\n                .where('firstName').ne('AliceFoobar')\n                .sort('passportId')\n                .skip(1);\n\n            let results = await q.exec();\n            assert.strictEqual(results.length, 1);\n            assert.strictEqual(q._execOverDatabaseCount, 1);\n            assert.strictEqual(q._latestChangeEvent, 2);\n\n            const addDoc = schemaObjects.human();\n\n            // set _id to first value to force a re-exec-over database\n            addDoc.passportId = '1-aaaaaaaaaaaaaaaaaaaaaaaaaaa';\n            addDoc.firstName = 'NotAliceFoobar';\n\n            await col.insert(addDoc);\n            assert.strictEqual(q.collection._changeEventBuffer.counter, 3);\n\n            assert.strictEqual(q._latestChangeEvent, 2);\n\n            await promiseWait(1);\n            results = await q.exec();\n            assert.strictEqual(results.length, 2);\n            assert.strictEqual(q._execOverDatabaseCount, 2);\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"querying fast should still return the same RxDocument","suites":[".exec()"],"updatePoint":{"line":519,"column":65},"line":519,"code":"        it('querying fast should still return the same RxDocument', async () => {\n            if (!config.platform.isNode()) return;\n            // use a 'slow' adapter because memory might be to fast\n            const leveldown = require('leveldown');\n            const db = await createRxDatabase({\n                name: config.rootPath + 'test_tmp/' + randomCouchString(10),\n                storage: getRxStoragePouch(leveldown),\n            });\n            const cols = await db.addCollections({\n                humans: {\n                    schema: schemas.human\n                }\n            });\n            const c = cols.humans;\n            await c.insert(schemaObjects.human());\n\n            const query1 = c.findOne().where('age').gt(0);\n            const query2 = c.findOne().where('age').gt(1);\n            const docs = await Promise.all([\n                query1.exec(),\n                query2.exec()\n            ]);\n            assert.ok(docs[0] === docs[1]);\n\n            db.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"querying after insert should always return the correct amount","suites":[".exec()"],"updatePoint":{"line":545,"column":73},"line":545,"code":"        it('querying after insert should always return the correct amount', async () => {\n            const col = await humansCollection.create(0);\n\n            const amount = 100;\n            const query = col.find({\n                selector: {\n                    age: {\n                        $gt: 1\n                    }\n                }\n            });\n            let inserted = 0;\n            while (inserted < amount) {\n                const docData = schemaObjects.human();\n                docData.age = 10;\n                await col.insert(docData);\n                inserted = inserted + 1;\n                const results = await query.exec();\n                assert.strictEqual(results.length, inserted);\n            }\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should not make more requests then needed","suites":[".exec()"],"updatePoint":{"line":568,"column":53},"line":568,"code":"        it('should not make more requests then needed', async () => {\n            const col = await humansCollection.createPrimary(0);\n            const docData = schemaObjects.simpleHuman();\n            const otherData = () => {\n                const data = clone(docData);\n                data.firstName = AsyncTestUtil.randomString();\n                return data;\n            };\n            await col.insert(docData);\n\n            const emitted = [];\n            const query = col.findOne(docData.passportId);\n            query.$.subscribe((data: any) => emitted.push(data.toJSON()));\n\n            await AsyncTestUtil.waitUntil(() => emitted.length === 1);\n            assert.strictEqual(query._execOverDatabaseCount, 1);\n\n            const doc = await query.exec();\n            assert.ok(doc);\n            assert.strictEqual(query._execOverDatabaseCount, 1);\n\n            await col.upsert(otherData());\n            await AsyncTestUtil.waitUntil(() => emitted.length === 2);\n            assert.strictEqual(query._execOverDatabaseCount, 1);\n\n            await col.atomicUpsert(otherData());\n            await AsyncTestUtil.waitUntil(() => emitted.length === 3);\n            assert.strictEqual(query._execOverDatabaseCount, 1);\n\n            await Promise.all(\n                new Array(2)\n                    .fill(0)\n                    .map(() => otherData())\n                    .map(data => col.atomicUpsert(data))\n            );\n            await AsyncTestUtil.waitUntil(() => emitted.length === 5);\n            assert.strictEqual(query._execOverDatabaseCount, 1);\n\n            await Promise.all(\n                new Array(10)\n                    .fill(0)\n                    .map(() => otherData())\n                    .map(data => col.atomicUpsert(data))\n            );\n            await AsyncTestUtil.waitUntil(() => emitted.length === 15);\n            assert.strictEqual(query._execOverDatabaseCount, 1);\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should not make more requests then needed on atomic upsert","suites":[".exec()"],"updatePoint":{"line":617,"column":70},"line":617,"code":"        it('should not make more requests then needed on atomic upsert', async () => {\n            const col = await humansCollection.createPrimary(0);\n            const docData = schemaObjects.simpleHuman();\n            let count = 0;\n            const otherData = () => {\n                const data = clone(docData);\n                data.firstName = '' + count;\n                count++;\n                return data;\n            };\n\n            const emitted = [];\n            const query = col.findOne(docData.passportId);\n            query.$.subscribe(doc => {\n                if (!doc) emitted.push(null);\n                else emitted.push(doc.toJSON());\n            });\n\n            await Promise.all(\n                new Array(10)\n                    .fill(0)\n                    .map(() => otherData())\n                    .map(data => col.atomicUpsert(data))\n            );\n\n            assert.strictEqual(query._execOverDatabaseCount, 1);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"exec from other database-instance","suites":[".exec()"],"updatePoint":{"line":645,"column":45},"line":645,"code":"        it('exec from other database-instance', async () => {\n            const dbName = randomCouchString(10);\n            const schema = schemas.averageSchema();\n            const db = await createRxDatabase({\n                name: dbName,\n                eventReduce: true,\n                storage: getRxStoragePouch('memory'),\n            });\n            const cols = await db.addCollections({\n                human: {\n                    schema\n                }\n            });\n            const col = cols.human;\n\n            await Promise.all(\n                new Array(10)\n                    .fill(0)\n                    .map(() => schemaObjects.averageSchema())\n                    .map(data => col.insert(data))\n            );\n\n            await db.destroy();\n\n            const db2 = await createRxDatabase({\n                name: dbName,\n                storage: getRxStoragePouch('memory'),\n                eventReduce: true,\n                ignoreDuplicate: true\n            });\n            const cols2 = await db2.addCollections({\n                human: {\n                    schema\n                }\n            });\n            const col2 = cols2.human;\n\n            const allDocs = await col2.find().exec();\n            assert.strictEqual(allDocs.length, 10);\n\n            db2.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"exec(true) should throw if missing","suites":[".exec()"],"updatePoint":{"line":687,"column":46},"line":687,"code":"        it('exec(true) should throw if missing', async () => {\n            const c = await humansCollection.create(0);\n\n            await AsyncTestUtil.assertThrows(\n                () => c.findOne().exec(true),\n                'RxError',\n                'throwIfMissing'\n            );\n\n            c.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"exec(true) should throw used with non-findOne","suites":[".exec()"],"updatePoint":{"line":698,"column":57},"line":698,"code":"        it('exec(true) should throw used with non-findOne', async () => {\n            const c = await humansCollection.create(0);\n            await AsyncTestUtil.assertThrows(\n                () => c.find().exec(true),\n                'RxError',\n                'findOne'\n            );\n            c.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"isFindOneByIdQuery(): .findOne(documentId) should use RxStorage().findDocumentsById() instead of RxStorage().query()","suites":[".exec()"],"updatePoint":{"line":707,"column":128},"line":707,"code":"        it('isFindOneByIdQuery(): .findOne(documentId) should use RxStorage().findDocumentsById() instead of RxStorage().query()', async () => {\n            const c = await humansCollection.create();\n            const docData = schemaObjects.simpleHuman();\n            const docId = 'foobar';\n            docData.passportId = docId;\n            await c.insert(docData);\n\n\n            // overwrite .query() to track the amount of calls\n            let queryCalls = 0;\n            const queryBefore = c.storageInstance.query.bind(c.storageInstance);\n            c.storageInstance.query = function (preparedQuery) {\n                queryCalls = queryCalls + 1;\n                return queryBefore(preparedQuery);\n            };\n\n            /**\n             * None of these operations should lead to a call to .query()\n             */\n            const operations = [\n                () => c.findOne(docId).exec(true),\n                () => c.find({\n                    selector: {\n                        passportId: docId\n                    },\n                    limit: 1\n                }).exec(),\n                () => c.find({\n                    selector: {\n                        passportId: {\n                            $eq: docId\n                        }\n                    },\n                    limit: 1\n                }).exec(),\n                () => c.find({\n                    selector: {\n                        passportId: {\n                            $eq: docId\n                        }\n                    }\n                    /**\n                     * Even without limit here,\n                     * it should detect that we look for a document that is $eq\n                     * to the primary key, so it can always\n                     * only find one document.\n                     */\n                }).exec()\n            ];\n            for (const operation of operations) {\n                await operation();\n            }\n\n            assert.strictEqual(queryCalls, 0);\n            c.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"updates a value on a query","suites":["update","positive"],"updatePoint":{"line":766,"column":42},"line":766,"code":"            it('updates a value on a query', async () => {\n                const c = await humansCollection.create(2);\n                const query = c.find();\n                await query.update({\n                    $set: {\n                        firstName: 'new first name'\n                    }\n                });\n                const docs = await query.exec();\n                for (const doc of docs)\n                    assert.strictEqual(doc._data.firstName, 'new first name');\n                c.database.destroy();\n            });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"$unset a value on a query","suites":["update","positive"],"updatePoint":{"line":779,"column":41},"line":779,"code":"            it('$unset a value on a query', async () => {\n                const c = await humansCollection.create(2);\n                const query = c.find();\n                await query.update({\n                    $unset: {\n                        age: ''\n                    }\n                });\n                const docs = await query.exec();\n                for (const doc of docs)\n                    assert.strictEqual(doc._data.age, undefined);\n                c.database.destroy();\n            });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"dont crash when findOne with no result","suites":["update","positive"],"updatePoint":{"line":792,"column":54},"line":792,"code":"            it('dont crash when findOne with no result', async () => {\n                const c = await humansCollection.create(2);\n                const query = c.findOne().where('age').gt(1000000);\n                await query.update({\n                    $set: {\n                        firstName: 'new first name'\n                    }\n                });\n                const doc = await query.exec();\n                assert.strictEqual(doc, null);\n                c.database.destroy();\n            });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should throw if schema does not match","suites":["update","negative"],"updatePoint":{"line":806,"column":53},"line":806,"code":"            it('should throw if schema does not match', async () => {\n                const schema: RxJsonSchema<{ id: string; childProperty: 'A' | 'B' | 'C' }> = {\n                    version: 0,\n                    primaryKey: 'id',\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        childProperty: {\n                            type: 'string',\n                            enum: ['A', 'B', 'C']\n                        }\n                    }\n                };\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema\n                    }\n                });\n                const col = cols.humans;\n                await col.insert({\n                    id: randomCouchString(12),\n                    childProperty: 'A'\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => col.find().update({\n                        $set: {\n                            childProperty: 'Z'\n                        }\n                    }),\n                    'RxError',\n                    'schema'\n                );\n                db.destroy();\n            });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"schema example 1","suites":["issues","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":851,"column":32},"line":851,"code":"            it('schema example 1', async () => {\n                const schema: RxJsonSchema<{ user_id: string; user_pwd: string; last_login: number; status: string; }> = {\n                    keyCompression: false,\n                    version: 0,\n                    primaryKey: 'user_id',\n                    type: 'object',\n                    properties: {\n                        user_id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        user_pwd: {\n                            type: 'string',\n                        },\n                        last_login: {\n                            type: 'number'\n                        },\n                        status: {\n                            type: 'string'\n                        }\n                    },\n                    required: ['user_pwd', 'last_login', 'status'],\n                    encrypted: [\n                        'user_pwd'\n                    ]\n                };\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                    password: randomCouchString(20)\n                });\n                const colName = randomCouchString(10);\n                const collections = await db.addCollections({\n                    [colName]: {\n                        schema\n                    }\n                });\n                const collection = collections[colName];\n\n                const query = collection\n                    .findOne()\n                    .where('status')\n                    .eq('foobar');\n\n                const resultDoc = await query.exec();\n                assert.strictEqual(resultDoc, null);\n\n                const queryAll = collection\n                    .find()\n                    .where('status')\n                    .eq('foobar');\n\n                const resultsAll = await queryAll.exec();\n                assert.strictEqual(resultsAll.length, 0);\n                db.destroy();\n            });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"schema example 2","suites":["issues","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":907,"column":32},"line":907,"code":"            it('schema example 2', async () => {\n                const schema: RxJsonSchema<{ id: string; value: number; }> = {\n                    keyCompression: false,\n                    version: 0,\n                    primaryKey: 'id',\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        value: {\n                            type: 'number',\n                            minimum: 0,\n                            maximum: 1000000,\n                            multipleOf: 1\n                        }\n                    },\n                    indexes: ['value']\n                };\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                    password: randomCouchString(20)\n                });\n\n                const colName = randomCouchString(10);\n                const collections = await db.addCollections({\n                    [colName]: {\n                        schema\n                    }\n                });\n                const collection = collections[colName];\n\n                const queryAll = collection\n                    .find()\n                    .sort({\n                        value: 'desc'\n                    });\n\n                const resultsAll = await queryAll.exec();\n                assert.strictEqual(resultsAll.length, 0);\n                db.destroy();\n            });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#267 query for null-fields","suites":["issues","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":952,"column":38},"line":952,"code":"        it('#267 query for null-fields', async () => {\n            if (config.storage.name !== 'pouchdb') {\n                /**\n                 * This test only runs in pouchdb,\n                 * TODO this should run on every RxStorage because it is a valid mongodb query.\n                 * @link https://docs.mongodb.com/manual/tutorial/query-for-null-fields/#faq-developers-query-for-nulls\n                 */\n                return;\n            }\n            const c = await humansCollection.create(2);\n            const foundDocs = await c.find({\n                selector: {\n                    passportId: null\n                }\n            }).exec();\n            assert.ok(Array.isArray(foundDocs));\n            c.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#278 queryCache breaks when pointer out of bounds","suites":["issues","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":970,"column":61},"line":970,"code":"        it('#278 queryCache breaks when pointer out of bounds', async () => {\n            if (!config.platform.isNode()) {\n                // dont do this on browsers because firefox takes too long\n                return;\n            }\n\n            const c = await humansCollection.createPrimary(0);\n\n            // insert 100\n            await c.bulkInsert(\n                new Array(100)\n                    .fill(0)\n                    .map(() => schemaObjects.human())\n            );\n\n            // make and exec query\n            const query = c.find();\n            const docs = await query.exec();\n            assert.strictEqual(docs.length, 100);\n\n            // produces changeEvents\n            await c.bulkInsert(\n                new Array(300) // higher than ChangeEventBuffer.limit\n                    .fill(0)\n                    .map(() => schemaObjects.human())\n            );\n\n\n            // re-exec query\n            const docs2 = await query.exec();\n            assert.strictEqual(docs2.length, 400);\n\n            // try same with upserts\n            const docData = new Array(200)\n                .fill(0)\n                .map(() => schemaObjects.human());\n            await c.bulkInsert(docData);\n\n            const docs3 = await query.exec();\n            assert.strictEqual(docs3.length, 600);\n\n            let docData2 = clone(docData);\n            // because we have no bulkUpsert, we only upsert 10 docs to speed up the test.\n            docData2 = docData2.slice(0, 10);\n            docData2.forEach((doc: any) => doc.lastName = doc.lastName + '1');\n            await Promise.all(\n                docData2.map(doc => c.upsert(doc))\n            );\n\n            const docs4 = await query.exec();\n            assert.strictEqual(docs4.length, 600);\n\n            c.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#585 sort by sub-path not working","suites":["issues","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":1024,"column":45},"line":1024,"code":"        it('#585 sort by sub-path not working', async () => {\n            const schema = {\n                version: 0,\n                type: 'object',\n                primaryKey: 'id',\n                keyCompression: false,\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    info: {\n                        type: 'object',\n                        properties: {\n                            title: {\n                                type: 'string',\n                                maxLength: 1000\n                            },\n                        },\n                    }\n                },\n                indexes: ['info.title']\n            };\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n            });\n            const cols = await db.addCollections({\n                humans: {\n                    schema\n                }\n            });\n            const col = cols.humans;\n\n            await col.storageInstance.internals.pouch.createIndex({\n                name: 'idx-rxdb-info',\n                ddoc: 'idx-rxdb-info',\n                index: {\n                    fields: ['info']\n                }\n            });\n            await col.storageInstance.internals.pouch.createIndex({\n                name: 'idx-rxdb-info.title',\n                ddoc: 'idx-rxdb-info.title',\n                index: {\n                    fields: ['info.title']\n                }\n            });\n\n            await col.insert({\n                id: '1',\n                info: {\n                    title: 'bbtest'\n                }\n            });\n            await col.insert({\n                id: '2',\n                info: {\n                    title: 'aatest'\n                }\n            });\n            await col.insert({\n                id: '3',\n                info: {\n                    title: 'cctest'\n                }\n            });\n\n            const foundDocs = await col\n                .find()\n                .sort('info.title')\n                .exec();\n            assert.strictEqual(foundDocs.length, 3);\n            assert.strictEqual(foundDocs[0].info.title, 'aatest');\n\n            const foundDocsDesc = await col\n                .find()\n                .sort('-info.title')\n                .exec();\n            assert.strictEqual(foundDocsDesc.length, 3);\n            assert.strictEqual(foundDocsDesc[0].info.title, 'cctest');\n\n            db.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#609 default index on primaryKey when better possible","suites":["issues","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":1108,"column":65},"line":1108,"code":"        it('#609 default index on primaryKey when better possible', async () => {\n            if (config.storage.name !== 'pouchdb') {\n                return;\n            }\n\n            const mySchema: RxJsonSchema<{ name: string; passportId: string; }> = {\n                version: 0,\n                keyCompression: false,\n                primaryKey: 'name',\n                type: 'object',\n                properties: {\n                    name: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    passportId: {\n                        type: 'string',\n                        maxLength: 100\n                    }\n                },\n                indexes: ['passportId']\n            };\n            const collection = await humansCollection.createBySchema(mySchema);\n\n            await collection.insert({\n                name: 'abc',\n                passportId: 'foobar'\n            });\n\n            // first query, no sort\n            const q1 = collection.findOne({\n                selector: {\n                    passportId: 'foofbar'\n                },\n                /**\n                 * TODO if we do not set a sorting,\n                 * the primaryKey sorting will still be added by RxDb\n                 * which causes PouchDB to pick the wrong index.\n                 * This looks like a pouchdb bug, create a test there.\n                 */\n                sort: [\n                    { passportId: 'asc' }\n                ]\n            });\n            const explained1 = await collection.storageInstance.internals.pouch.explain(q1.getPreparedQuery());\n\n            assert.ok(explained1.index.ddoc);\n            assert.ok(explained1.index.ddoc.startsWith('_design/idx-'));\n\n            // second query, with sort\n            const q2 = collection.findOne({\n                selector: {\n                    passportId: 'foofbar'\n                }\n            }).sort('passportId');\n            const explained2 = await collection.storageInstance.internals.pouch.explain(q2.getPreparedQuery());\n            assert.ok(explained2.index.ddoc);\n            assert.ok(explained2.index.ddoc.startsWith('_design/idx-'));\n\n            collection.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#698 Same query producing a different result","suites":["issues","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":1169,"column":56},"line":1169,"code":"        it('#698 Same query producing a different result', async () => {\n            const mySchema: RxJsonSchema<{ id: string; event_id: number; user_id: string; created_at: number }> = {\n                version: 0,\n                keyCompression: false,\n                primaryKey: 'id',\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    event_id: {\n                        type: 'number'\n                    },\n                    user_id: {\n                        type: 'string'\n                    },\n                    created_at: {\n                        type: 'number',\n                        minimum: 0,\n                        maximum: 10000000000000000,\n                        multipleOf: 1\n                    }\n                },\n                indexes: ['created_at']\n            };\n            const collection = await humansCollection.createBySchema(mySchema);\n\n            await collection.insert({\n                id: randomCouchString(12),\n                event_id: 1,\n                user_id: '6',\n                created_at: 1337\n            });\n            await collection.insert({\n                id: randomCouchString(12),\n                event_id: 2,\n                user_id: '6',\n                created_at: 1337\n            });\n\n\n            /* eslint-disable */\n            const selector = {\n                $and: [{\n                    event_id: {\n                        $eq: 2\n                    }\n                }, {\n                    user_id: {\n                        $eq: '6'\n                    }\n                },\n                {\n                    created_at: {\n                        $gt: 0\n                    }\n                }, {\n                    user_id: {\n                        $eq: '6'\n                    }\n                },\n                {\n                    created_at: {\n                        $gt: 0\n                    }\n                }\n                ]\n            };\n            /* eslint-enable */\n\n            const resultDocs1 = await collection\n                .find({\n                    selector\n                })\n                .exec();\n            const resultData1: any[] = resultDocs1.map(doc => doc.toJSON());\n\n            const resultDocs2 = await collection\n                .find()\n                .where('event_id').eq(2)\n                .where('user_id').eq('6')\n                .where('created_at').gt(0)\n                .exec();\n            const resultData2 = resultDocs2.map(doc => doc.toJSON());\n\n            assert.strictEqual(resultData1.length, 1);\n            assert.strictEqual(resultData1[0]['event_id'], 2);\n            assert.deepStrictEqual(resultData1, resultData2);\n\n            collection.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"698#issuecomment-402604237 mutating a returned array should not affect exec-calls afterwards","suites":["issues","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":1261,"column":104},"line":1261,"code":"        it('698#issuecomment-402604237 mutating a returned array should not affect exec-calls afterwards', async () => {\n            const c = await humansCollection.create(2);\n            const query = c.find();\n\n            // exec-calls\n            const result1: any = await query.exec();\n            assert.strictEqual(result1.length, 2);\n            result1.push({\n                foo: 'bar'\n            });\n            const result2 = await query.exec();\n            assert.strictEqual(result2.length, 2);\n\n            c.database.destroy();\n\n            // subscriptions\n            const c2 = await humansCollection.create(2);\n            const query2 = c2.find();\n            const res1: any = await firstValueFrom(query2.$);\n            res1.push({\n                foo: 'bar'\n            });\n            const res2 = await firstValueFrom(query2.$);\n            assert.strictEqual(res2.length, 2);\n\n            c2.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#724 find() does not find all matching documents","suites":["issues","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":1288,"column":60},"line":1288,"code":"        it('#724 find() does not find all matching documents', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n            });\n            const schema: RxJsonSchema<{ roomId: string; sessionId: string }> = {\n                version: 0,\n                primaryKey: 'roomId',\n                type: 'object',\n                properties: {\n                    roomId: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    sessionId: {\n                        type: 'string'\n                    }\n                }\n            };\n            const collections = await db.addCollections({\n                roomsession: {\n                    schema\n                }\n            });\n            const roomsession = collections.roomsession;\n            const roomId = 'roomId';\n            const sessionId = 'sessionID';\n            await roomsession.insert({\n                roomId,\n                sessionId\n            });\n\n            const foundByRoomId = await roomsession.findOne({\n                selector: {\n                    roomId\n                }\n            }).exec();\n            const foundByRoomAndSessionId = await roomsession.findOne({\n                selector: {\n                    roomId,\n                    sessionId\n                }\n            }).exec();\n            const foundBySessionId = await roomsession.findOne({\n                selector: {\n                    sessionId\n                }\n            }).exec();\n\n            assert(foundByRoomId !== null); // fail\n            assert(foundByRoomAndSessionId !== null); // fail\n            assert(foundBySessionId !== null); // pass\n            assert(foundBySessionId.roomId === roomId && foundBySessionId.sessionId === sessionId); // pass\n\n            db.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#815 Allow null value for strings","suites":["issues","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":1344,"column":45},"line":1344,"code":"        it('#815 Allow null value for strings', async () => {\n            if (config.storage.name !== 'pouchdb') {\n                return;\n            }\n\n            // create a schema\n            const mySchema = {\n                version: 0,\n                primaryKey: 'passportId',\n                type: 'object',\n                properties: {\n                    passportId: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    firstName: {\n                        type: 'string'\n                    },\n                    lastName: {\n                        type: ['string', 'null']\n                    },\n                    age: {\n                        type: 'integer',\n                        minimum: 0,\n                        maximum: 150\n                    }\n                }\n            };\n\n            // generate a random database-name\n            const name = randomCouchString(10);\n\n            // create a database\n            const db = await createRxDatabase({\n                name,\n                storage: getRxStoragePouch('memory'),\n                eventReduce: true,\n                ignoreDuplicate: true\n            });\n            // create a collection\n            const collections = await db.addCollections({\n                mycollection: {\n                    schema: mySchema\n                }\n            });\n            const collection = collections.mycollection;\n\n            // insert a document\n            await collection.insert({\n                passportId: 'foobar',\n                firstName: 'Bob1',\n                age: 56\n            });\n            await collection.insert({\n                passportId: 'foobaz',\n                firstName: 'Bob2',\n                lastName: null,\n                age: 56\n            });\n\n            const queryOK = collection.find();\n            const docsOK = await queryOK.exec();\n            assert.strictEqual(docsOK.length, 2);\n\n            const selector = {\n                lastName: null\n            };\n\n            const pouchResult = await collection.storageInstance.internals.pouch.find({\n                selector\n            });\n            const pouchDocs = pouchResult.docs;\n            const query = collection.find({\n                selector\n            });\n            const docs = await query.exec();\n\n            assert.strictEqual(pouchDocs.length, docs.length);\n            assert.strictEqual(pouchDocs[0].firstName, docs[0].firstName);\n\n            db.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"gitter: query with regex does not return correct results","suites":["issues","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":1429,"column":68},"line":1429,"code":"        it('gitter: query with regex does not return correct results', async () => {\n            if (!config.storage.hasRegexSupport) {\n                return;\n            }\n\n            // create a schema\n            const mySchema = {\n                version: 0,\n                primaryKey: 'passportId',\n                type: 'object',\n                properties: {\n                    passportId: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    firstName: {\n                        type: 'string'\n                    },\n                    lastName: {\n                        type: ['string', 'null']\n                    }\n                }\n            };\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n                eventReduce: true,\n                ignoreDuplicate: true\n            });\n\n            // create a collection\n            const collections = await db.addCollections({\n                mycollection: {\n                    schema: mySchema\n                }\n            });\n            const collection = collections.mycollection;\n\n            // insert documents\n            await collection.bulkInsert([\n                {\n                    passportId: 'doc1',\n                    firstName: 'John',\n                    lastName: 'Doe'\n                }, {\n                    passportId: 'doc2',\n                    firstName: 'Martin',\n                    lastName: 'Smith'\n                }\n            ]);\n            const allDocs = await collection.find().exec();\n            assert.strictEqual(allDocs.length, 2);\n\n            // test 1 with RegExp object\n            const regexp = new RegExp('^Doe$', 'i');\n            const result1 = await collection.find({\n                selector: {\n                    lastName: { $regex: regexp }\n                }\n            }).exec();\n\n            // test 2 with regex string\n            const result2 = await collection.find({\n                selector: {\n                    lastName: { $regex: '^Doe$' }\n                }\n            }).exec();\n\n\n            // both results should only have the doc1\n            assert.strictEqual(result1.length, 1);\n            assert.strictEqual(result1[0].passportId, 'doc1');\n            assert.deepStrictEqual(\n                result1.map(d => d.toJSON()),\n                result2.map(d => d.toJSON())\n            );\n\n            db.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#2071 RxCollection.findOne().exec() returns deleted document while find().exec() not","suites":["issues","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":1508,"column":96},"line":1508,"code":"        it('#2071 RxCollection.findOne().exec() returns deleted document while find().exec() not', async () => {\n            const c = await humansCollection.create(1);\n\n            // delete it\n            const doc = await c.findOne();\n            await doc.remove();\n\n            // now find() returns empty array\n            const docs = await c.find().exec();\n            assert.strictEqual(docs.length, 0);\n\n            // findOne() still returns the deleted object\n            const doc2 = await c.findOne().exec();\n            assert.strictEqual(doc2, null);\n\n            c.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#2213 prepareQuery should handle all comparison operators","suites":["issues","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":1525,"column":69},"line":1525,"code":"        it('#2213 prepareQuery should handle all comparison operators', async () => {\n            const collection = await humansCollection.createAgeIndex(0);\n            await collection.insert({\n                passportId: 'foobar',\n                firstName: 'Bob',\n                lastName: 'Kelso',\n                age: 56\n            });\n\n            await collection.insert({\n                passportId: 'foobar2',\n                firstName: 'Bob2',\n                lastName: 'Kelso2',\n                age: 58\n            });\n\n            const myDocument = await collection.findOne({\n                selector: {\n                    age: {\n                        $gte: 57,\n                    },\n                },\n                sort: [{ age: 'asc' }]\n            }).exec(true);\n\n            assert.strictEqual(myDocument.age, 58);\n\n            collection.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"gitter: mutating find-params causes different results","suites":["issues","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":1557,"column":65},"line":1557,"code":"        it('gitter: mutating find-params causes different results', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n                eventReduce: false\n            });\n            const schema = clone(schemas.human);\n            schema.keyCompression = false;\n\n            const cols = await db.addCollections({\n                humans: {\n                    schema\n                }\n            });\n            const c = cols.humans;\n\n            const docDataMatching = schemaObjects.human();\n            docDataMatching.age = 42;\n            await c.insert(docDataMatching);\n\n            const docDataNotMatching = schemaObjects.human();\n            docDataNotMatching.age = 99;\n            await c.insert(docDataNotMatching);\n\n            const queryParams = {\n                selector: {\n                    age: 42\n                }\n            };\n            const queryMatching = c.find(queryParams);\n            const queryMatchingOne = c.findOne(queryParams);\n\n            const res1 = await queryMatching.exec();\n            const resOne1 = await queryMatchingOne.exec();\n            assert.strictEqual(res1.length, 1);\n            assert.ok(resOne1);\n            assert.strictEqual(resOne1.age, 42);\n\n            queryParams.selector.age = 0;\n\n            // trigger a write so the results are not cached\n            const addData = schemaObjects.human();\n            addData.age = 55;\n            await c.insert(addData);\n\n            const res2 = await queryMatching.exec();\n            const resOne2 = await queryMatchingOne.exec();\n\n            assert.strictEqual(res2.length, 1);\n            assert.ok(res2);\n            assert.strictEqual(resOne2.age, 42);\n\n            db.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#3498 RxQuery returns outdated result in second subscription","suites":["issues","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":1611,"column":72},"line":1611,"code":"        it('#3498 RxQuery returns outdated result in second subscription', async () => {\n            const schema = {\n                version: 0,\n                primaryKey: 'id',\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    field: {\n                        type: 'boolean'\n                    }\n                }\n            } as const;\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n                eventReduce: true,\n                ignoreDuplicate: true\n            });\n            const collection = (await db.addCollections({\n                collection: {\n                    schema\n                }\n            })).collection;\n\n            const doc = await collection.insert({ id: 'testid', field: false });\n\n            // Bug only happens the second time the query is used\n            const result1 = await collection.find({ selector: { field: false } }).exec();\n            assert.strictEqual(result1.length, 1);\n\n            await doc.update({\n                $set: {\n                    field: true\n                }\n            });\n\n            const obs = collection.find({ selector: { field: false } }).$;\n            const result2a: any[][] = [];\n            const result2b: any[][] = [];\n            const sub2 = obs.subscribe((d) => result2b.push(d));\n            const sub1 = obs.subscribe((d) => result2a.push(d));\n\n            await promiseWait(5);\n\n            sub1.unsubscribe();\n            sub2.unsubscribe();\n\n            assert.strictEqual(Math.max(...result2a.map(r => r.length)), 0);\n            assert.strictEqual(Math.max(...result2b.map(r => r.length)), 0);\n\n            db.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#3631 Sorting a query adds in deleted documents","suites":["issues","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":1666,"column":59},"line":1666,"code":"        it('#3631 Sorting a query adds in deleted documents', async () => {\n            const c = await humansCollection.createAgeIndex(1);\n            const doc = await c.findOne().exec(true);\n            await doc.remove();\n\n            const queryResult = await c.find({\n                selector: {},\n                sort: [\n                    { age: 'asc' }\n                ]\n            }).exec();\n\n            // should not have found the deleted document\n            assert.strictEqual(queryResult.length, 0);\n\n            c.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"get single indexes","suites":["static",".getIndexes()"],"updatePoint":{"line":28,"column":34},"line":28,"code":"            it('get single indexes', () => {\n                const indexes = getIndexes(schemas.human);\n                assert.strictEqual(indexes.length, 1);\n                assert.deepStrictEqual(indexes[0], ['firstName']);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get multiple indexes","suites":["static",".getIndexes()"],"updatePoint":{"line":33,"column":36},"line":33,"code":"            it('get multiple indexes', () => {\n                const indexes = getIndexes(schemas.bigHuman);\n                assert.ok(indexes.length > 1);\n                assert.deepStrictEqual(indexes[0], ['firstName']);\n                assert.deepStrictEqual(indexes[1], ['dnaHash']);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get sub-index","suites":["static",".getIndexes()"],"updatePoint":{"line":39,"column":29},"line":39,"code":"            it('get sub-index', () => {\n                const indexes = getIndexes(schemas.humanSubIndex);\n                assert.strictEqual(indexes.length, 1);\n                assert.deepStrictEqual(indexes[0], ['other.age']);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get no index","suites":["static",".getIndexes()"],"updatePoint":{"line":44,"column":28},"line":44,"code":"            it('get no index', () => {\n                const indexes = getIndexes(schemas.noIndexHuman);\n                assert.strictEqual(indexes.length, 0);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get compoundIndex","suites":["static",".getIndexes()"],"updatePoint":{"line":48,"column":33},"line":48,"code":"            it('get compoundIndex', () => {\n                const indexes = getIndexes(schemas.compoundIndex);\n                assert.ok(Array.isArray(indexes));\n                assert.ok(Array.isArray(indexes[0]));\n                assert.deepStrictEqual(indexes[0], ['age', 'passportCountry']);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate human","suites":["static",".checkSchema()","positive"],"updatePoint":{"line":57,"column":34},"line":57,"code":"                it('validate human', () => {\n                    checkSchema(schemas.human);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate bigHuman","suites":["static",".checkSchema()","positive"],"updatePoint":{"line":60,"column":37},"line":60,"code":"                it('validate bigHuman', () => {\n                    checkSchema(schemas.bigHuman);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate without index","suites":["static",".checkSchema()","positive"],"updatePoint":{"line":63,"column":42},"line":63,"code":"                it('validate without index', () => {\n                    checkSchema(schemas.noIndexHuman);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate with compoundIndexes","suites":["static",".checkSchema()","positive"],"updatePoint":{"line":66,"column":49},"line":66,"code":"                it('validate with compoundIndexes', () => {\n                    checkSchema(schemas.compoundIndex);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate empty","suites":["static",".checkSchema()","positive"],"updatePoint":{"line":69,"column":34},"line":69,"code":"                it('validate empty', () => {\n                    checkSchema(schemas.empty);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate with defaults","suites":["static",".checkSchema()","positive"],"updatePoint":{"line":72,"column":42},"line":72,"code":"                it('validate with defaults', () => {\n                    checkSchema(schemas.humanDefault);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate point","suites":["static",".checkSchema()","positive"],"updatePoint":{"line":75,"column":34},"line":75,"code":"                it('validate point', () => {\n                    checkSchema(schemas.point);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validates deep nested indexes","suites":["static",".checkSchema()","positive"],"updatePoint":{"line":78,"column":49},"line":78,"code":"                it('validates deep nested indexes', () => {\n                    checkSchema(schemas.humanWithDeepNestedIndexes);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"break when index defined at object property level","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":83,"column":69},"line":83,"code":"                it('break when index defined at object property level', () => {\n                    assert.throws(() => checkSchema({\n                        version: 0,\n                        primaryKey: 'id',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            name: {\n                                type: 'string',\n                                index: true\n                            } as any,\n                            job: {\n                                type: 'object',\n                                properties: {\n                                    name: {\n                                        type: 'string',\n                                        index: true\n                                    } as any,\n                                    manager: {\n                                        type: 'object',\n                                        properties: {\n                                            fullName: {\n                                                type: 'string',\n                                                index: true\n                                            } as any\n                                        }\n                                    }\n                                }\n                            }\n                        },\n                        required: ['job']\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"break when compoundIndex is specified in a separate field","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":119,"column":77},"line":119,"code":"                it('break when compoundIndex is specified in a separate field', () => {\n                    assert.throws(() => checkSchema({\n                        version: 0,\n                        primaryKey: 'id',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            name: {\n                                type: 'string',\n                                index: true\n                            } as any\n                        },\n                        compoundIndexes: ['id', 'name']\n                    } as any), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"throw when underscore field is used as property name","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":137,"column":72},"line":137,"code":"                it('throw when underscore field is used as property name', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        primaryKey: '_asdf',\n                        type: 'object',\n                        properties: {\n                            _asdf: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            firstName: {\n                                type: 'string'\n                            }\n                        },\n                        required: ['firstName']\n                    } as any), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"break when index is no string","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":155,"column":49},"line":155,"code":"                it('break when index is no string', () => {\n                    assert.throws(() => checkSchema(schemas.noStringIndex), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"break when index does not exist in schema properties","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":158,"column":72},"line":158,"code":"                it('break when index does not exist in schema properties', () => {\n                    assert.throws(() => checkSchema(schemas.notExistingIndex), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"break compoundIndex key is no string","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":161,"column":56},"line":161,"code":"                it('break compoundIndex key is no string', () => {\n                    assert.throws(() => checkSchema(schemas.compoundIndexNoString), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"break on wrong formated compundIndex","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":164,"column":56},"line":164,"code":"                it('break on wrong formated compundIndex', () => {\n                    assert.throws(() => checkSchema(schemas.wrongCompoundFormat), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"break when dots in fieldname","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":167,"column":48},"line":167,"code":"                it('break when dots in fieldname', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        description: 'dot in fieldname',\n                        primaryKey: 'my.field',\n                        type: 'object',\n                        properties: {\n                            'my.field': {\n                                type: 'string',\n                                maxLength: 100\n                            }\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"break when required is set via required: true","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":182,"column":65},"line":182,"code":"                it('break when required is set via required: true', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        primaryKey: 'myfield',\n                        type: 'object',\n                        properties: {\n                            'myfield': {\n                                type: 'string',\n                                required: true,\n                                maxLength: 100\n                            } as any\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not allow $-char in fieldnames","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":201,"column":57},"line":201,"code":"                it('should not allow $-char in fieldnames', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        primaryKey: 'id',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            'firstName$': {\n                                type: 'string'\n                            }\n                        }\n                    }), Error);\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        primaryKey: 'id',\n                        description: '$ in fieldname',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            'first$Name': {\n                                type: 'string'\n                            }\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not allow $-char in nested fieldnames","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":234,"column":64},"line":234,"code":"                it('should not allow $-char in nested fieldnames', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        description: '$ in nested fieldname',\n                        primaryKey: 'id',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            'things': {\n                                type: 'object',\n                                properties: {\n                                    first$Name: {\n                                        type: 'string'\n                                    }\n                                }\n                            }\n                        }\n                    }), Error);\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        description: '$ in nested fieldname',\n                        primaryKey: 'id',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            'things': {\n                                type: 'object',\n                                properties: {\n                                    firstName$: {\n                                        type: 'string'\n                                    }\n                                }\n                            }\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not allow ending lodash _ in fieldnames (reserved for populate)","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":278,"column":90},"line":278,"code":"                it('should not allow ending lodash _ in fieldnames (reserved for populate)', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        primaryKey: 'id',\n                        description: '_ in fieldname',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            'firstName_': {\n                                type: 'string'\n                            }\n                        }\n                    }), Error, 'underscore');\n                    // nested\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        description: 'dot in fieldname',\n                        primaryKey: 'id',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            'foo': {\n                                type: 'object',\n                                properties: {\n                                    'name_': {\n                                        type: 'string'\n                                    }\n                                }\n                            }\n                        }\n                    }), Error, 'underscore');\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not allow RxDocument-properties as top-fieldnames (own)","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":318,"column":82},"line":318,"code":"                it('should not allow RxDocument-properties as top-fieldnames (own)', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        description: 'collection as fieldname',\n                        primaryKey: 'collection',\n                        type: 'object',\n                        properties: {\n                            'collection': {\n                                type: 'string',\n                                maxLength: 100\n                            }\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not allow RxDocument-properties as top-fieldnames (prototype)","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":333,"column":88},"line":333,"code":"                it('should not allow RxDocument-properties as top-fieldnames (prototype)', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        description: 'save as fieldname',\n                        primaryKey: 'save',\n                        type: 'object',\n                        properties: {\n                            'save': {\n                                type: 'string',\n                                maxLength: 100\n                            }\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"throw when no version","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":348,"column":41},"line":348,"code":"                it('throw when no version', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        description: 'save as fieldname',\n                        type: 'object',\n                        properties: {\n                            'foobar': {\n                                type: 'string'\n                            }\n                        }\n                    } as any), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"throw when version < 0","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":360,"column":42},"line":360,"code":"                it('throw when version < 0', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: -10,\n                        description: 'save as fieldname',\n                        primaryKey: 'foobar',\n                        type: 'object',\n                        properties: {\n                            'foobar': {\n                                type: 'string',\n                                maxLength: 100\n                            }\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"throw when version no number","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":375,"column":48},"line":375,"code":"                it('throw when version no number', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 'foobar',\n                        description: 'save as fieldname',\n                        primaryKey: 'foobar',\n                        properties: {\n                            'foobar': {\n                                type: 'string',\n                                maxLength: 100\n                            }\n                        }\n                    } as any), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"throw when defaults on non-first-level field","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":389,"column":64},"line":389,"code":"                it('throw when defaults on non-first-level field', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        description: 'save as fieldname',\n                        primaryKey: 'foobar',\n                        type: 'object',\n                        properties: {\n                            foobar: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            deeper: {\n                                type: 'object',\n                                properties: {\n                                    name: {\n                                        type: 'string',\n                                        default: 'foobar'\n                                    } as any\n                                }\n                            }\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"throw when _id is not primary","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":413,"column":49},"line":413,"code":"                it('throw when _id is not primary', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        primaryKey: 'userId',\n                        description: 'save as fieldname',\n                        type: 'object',\n                        properties: {\n                            userId: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            _id: {\n                                type: 'string',\n                            },\n                            firstName: {\n                                type: 'string'\n                            }\n                        },\n                        required: ['firstName']\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should sort array with objects and strings","suites":["static",".fillWithDefaultSettings() / .normalizeRxJsonSchema()"],"updatePoint":{"line":438,"column":58},"line":438,"code":"            it('should sort array with objects and strings', () => {\n                const val = ['firstName', 'lastName', {\n                    name: 2\n                }];\n                const normalized = sortObject(val);\n                assert.deepStrictEqual(val, normalized);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should be the same object","suites":["static",".fillWithDefaultSettings() / .normalizeRxJsonSchema()"],"updatePoint":{"line":445,"column":41},"line":445,"code":"            it('should be the same object', () => {\n                const schema = normalizeRxJsonSchema(schemas.humanNormalizeSchema1);\n                assert.deepStrictEqual(schema, schemas.humanNormalizeSchema1);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should deep sort one schema with different orders to be the same","suites":["static",".fillWithDefaultSettings() / .normalizeRxJsonSchema()"],"updatePoint":{"line":449,"column":80},"line":449,"code":"            it('should deep sort one schema with different orders to be the same', () => {\n                const schema1 = normalizeRxJsonSchema(schemas.humanNormalizeSchema1);\n                const schema2 = normalizeRxJsonSchema(schemas.humanNormalizeSchema2);\n                assert.deepStrictEqual(schema1, schema2);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not sort indexes array in the schema (related with https://github.com/pubkey/rxdb/pull/1695#issuecomment-554636433)","suites":["static",".fillWithDefaultSettings() / .normalizeRxJsonSchema()"],"updatePoint":{"line":454,"column":138},"line":454,"code":"            it('should not sort indexes array in the schema (related with https://github.com/pubkey/rxdb/pull/1695#issuecomment-554636433)', () => {\n                const schema = normalizeRxJsonSchema(schemas.humanWithSimpleAndCompoundIndexes);\n                assert.deepStrictEqual(schema.indexes, schemas.humanWithSimpleAndCompoundIndexes.indexes);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should have added the primaryKey to indexes that did not contain it","suites":["static",".fillWithDefaultSettings() / .normalizeRxJsonSchema()"],"updatePoint":{"line":458,"column":83},"line":458,"code":"            it('should have added the primaryKey to indexes that did not contain it', () => {\n                const schema: RxJsonSchema<any> = fillWithDefaultSettings({\n                    primaryKey: 'id',\n                    version: 0,\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    },\n                    required: ['id'],\n                    indexes: [\n                        'age',\n                        ['foo', 'bar'],\n                        ['bar', 'id', 'foo']\n                    ]\n                });\n                const normalizedSchema = normalizeRxJsonSchema(schema);\n                assert.deepStrictEqual(\n                    normalizedSchema.indexes,\n                    [\n                        ['age', 'id'],\n                        ['foo', 'bar', 'id'],\n                        ['bar', 'id', 'foo']\n                    ]\n                );\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"create human","suites":["static",".create()","positive"],"updatePoint":{"line":489,"column":32},"line":489,"code":"                it('create human', () => {\n                    const schema = createRxSchema(schemas.human);\n                    assert.strictEqual(schema.constructor.name, 'RxSchema');\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"create nested","suites":["static",".create()","positive"],"updatePoint":{"line":493,"column":33},"line":493,"code":"                it('create nested', () => {\n                    const schema = createRxSchema(schemas.nestedHuman);\n                    assert.strictEqual(schema.constructor.name, 'RxSchema');\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"create point","suites":["static",".create()","positive"],"updatePoint":{"line":497,"column":32},"line":497,"code":"                it('create point', () => {\n                    const schema = createRxSchema(schemas.point);\n                    assert.strictEqual(schema.constructor.name, 'RxSchema');\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should have indexes human","suites":["static",".create()","positive"],"updatePoint":{"line":501,"column":45},"line":501,"code":"                it('should have indexes human', () => {\n                    const schema = createRxSchema(schemas.human);\n                    assert.strictEqual(schema.indexes[0][0], 'firstName');\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"broken schema (nostringIndex)","suites":["static",".create()","negative"],"updatePoint":{"line":507,"column":49},"line":507,"code":"                it('broken schema (nostringIndex)', () => {\n                    assert.throws(() => createRxSchema(schemas.noStringIndex), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"first-level field is \"language\" is forbitten","suites":["static",".create()","negative"],"updatePoint":{"line":510,"column":64},"line":510,"code":"                it('first-level field is \"language\" is forbitten', () => {\n                    assert.throws(() => createRxSchema<any>({\n                        title: 'schema',\n                        version: 0,\n                        primaryKey: 'foo',\n                        description: 'dot in fieldname',\n                        type: 'object',\n                        properties: {\n                            foo: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            language: {\n                                type: 'string'\n                            }\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should contain the field","suites":["static",".getFinalFields()"],"updatePoint":{"line":531,"column":40},"line":531,"code":"            it('should contain the field', () => {\n                const ret = getFinalFields({\n                    version: 0,\n                    primaryKey: 'myField',\n                    type: 'object',\n                    properties: {\n                        myField: {\n                            type: 'string',\n                            maxLength: 100,\n                            final: true\n                        }\n                    }\n                });\n                assert.ok(ret.includes('myField'));\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should contain the primary","suites":["static",".getFinalFields()"],"updatePoint":{"line":546,"column":42},"line":546,"code":"            it('should contain the primary', () => {\n                const ret = getFinalFields({\n                    version: 0,\n                    primaryKey: 'myField',\n                    type: 'object',\n                    properties: {\n                        myField: {\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    }\n                });\n                assert.deepStrictEqual(ret, ['myField']);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get empty array when current==0","suites":["instance",".getPreviousVersions()"],"updatePoint":{"line":564,"column":47},"line":564,"code":"            it('get empty array when current==0', () => {\n                const schema = createRxSchema({\n                    title: 'schema',\n                    version: 0,\n                    primaryKey: 'foobar',\n                    type: 'object',\n                    properties: {\n                        'foobar': {\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    }\n                });\n                assert.deepStrictEqual(\n                    getPreviousVersions(schema.jsonSchema),\n                    []\n                );\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get valid array when current==5","suites":["instance",".getPreviousVersions()"],"updatePoint":{"line":582,"column":47},"line":582,"code":"            it('get valid array when current==5', () => {\n                const schema = createRxSchema({\n                    title: 'schema',\n                    version: 5,\n                    primaryKey: 'foobar',\n                    type: 'object',\n                    properties: {\n                        'foobar': {\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    }\n                });\n                assert.deepStrictEqual(\n                    getPreviousVersions(schema.jsonSchema),\n                    [0, 1, 2, 3, 4]\n                );\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should hash","suites":["instance",".hash","positive"],"updatePoint":{"line":603,"column":31},"line":603,"code":"                it('should hash', () => {\n                    const schema = createRxSchema(schemas.human);\n                    const hash = schema.hash;\n                    assert.strictEqual(typeof hash, 'string');\n                    assert.ok(hash.length > 10);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should normalize one schema with two different orders and generate for each the same hash","suites":["instance",".hash","positive"],"updatePoint":{"line":609,"column":109},"line":609,"code":"                it('should normalize one schema with two different orders and generate for each the same hash', () => {\n                    const schema1 = createRxSchema(schemas.humanNormalizeSchema1);\n                    const schema2 = createRxSchema(schemas.humanNormalizeSchema2);\n                    const hash1 = schema1.hash;\n                    const hash2 = schema2.hash;\n                    assert.strictEqual(hash1, hash2);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate one human","suites":["instance",".validate()","positive"],"updatePoint":{"line":620,"column":38},"line":620,"code":"                it('validate one human', () => {\n                    const schema = createRxSchema(schemas.human);\n                    const obj: any = schemaObjects.human();\n                    schema.validate(obj);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate one point","suites":["instance",".validate()","positive"],"updatePoint":{"line":625,"column":38},"line":625,"code":"                it('validate one point', () => {\n                    const schema = createRxSchema(schemas.point);\n                    const obj: any = schemaObjects.point();\n                    schema.validate(obj);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate without non-required","suites":["instance",".validate()","positive"],"updatePoint":{"line":630,"column":49},"line":630,"code":"                it('validate without non-required', () => {\n                    const schema = createRxSchema(schemas.human);\n                    const obj: any = schemaObjects.human();\n                    delete obj.age;\n                    schema.validate(obj);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate nested","suites":["instance",".validate()","positive"],"updatePoint":{"line":636,"column":35},"line":636,"code":"                it('validate nested', () => {\n                    const schema = createRxSchema(schemas.nestedHuman);\n                    const obj: any = schemaObjects.nestedHuman();\n                    schema.validate(obj);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"required field not given","suites":["instance",".validate()","negative"],"updatePoint":{"line":643,"column":44},"line":643,"code":"                it('required field not given', () => {\n                    const schema = createRxSchema(schemas.human);\n                    const obj: any = schemaObjects.human();\n                    obj['_id'] = randomCouchString(10);\n                    delete obj.lastName;\n                    assert.throws(() => schema.validate(obj), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"overflow maximum int","suites":["instance",".validate()","negative"],"updatePoint":{"line":650,"column":40},"line":650,"code":"                it('overflow maximum int', () => {\n                    const schema = createRxSchema(schemas.human);\n                    const obj: any = schemaObjects.human();\n                    obj['_id'] = randomCouchString(10);\n                    obj.age = 1000;\n                    assert.throws(() => schema.validate(obj), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"overadditional property","suites":["instance",".validate()","negative"],"updatePoint":{"line":657,"column":43},"line":657,"code":"                it('overadditional property', () => {\n                    const schema = createRxSchema(schemas.human);\n                    const obj: any = schemaObjects.human();\n                    obj['_id'] = randomCouchString(10);\n                    obj['token'] = randomCouchString(5);\n                    assert.throws(() => schema.validate(obj), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"::after","suites":["instance",".validate()","negative"],"updatePoint":{"line":664,"column":27},"line":664,"code":"                it('::after', () => {\n                    const schema = createRxSchema(schemas.human);\n                    const obj: any = schemaObjects.human();\n                    schema.validate(obj);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"accessible error-parameters","suites":["instance",".validate()","negative"],"updatePoint":{"line":669,"column":47},"line":669,"code":"                it('accessible error-parameters', () => {\n                    const schema = createRxSchema(schemas.human);\n                    const obj = schemaObjects.human();\n                    (obj as any)['foobar'] = 'barfoo';\n                    let hasThrown = false;\n                    try {\n                        schema.validate(obj);\n                    } catch (err) {\n                        const message = (err as any).parameters.errors[0].message;\n                        assert.ok(message.includes('additional'));\n                        hasThrown = true;\n                    }\n                    assert.ok(hasThrown);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should respect nested additionalProperties: false","suites":["instance",".validate()","negative"],"updatePoint":{"line":683,"column":69},"line":683,"code":"                it('should respect nested additionalProperties: false', () => {\n                    const jsonSchema: any = clone(schemas.heroArray);\n                    jsonSchema.properties.skills.items['additionalProperties'] = false;\n                    const schema = createRxSchema(jsonSchema);\n                    const obj = {\n                        name: 'foobar',\n                        skills: [\n                            {\n                                name: 'foo',\n                                damage: 10,\n                                nonDefinedField: 'foobar'\n                            }\n                        ],\n                    };\n\n                    let hasThrown = false;\n                    try {\n                        schema.validate(obj);\n                    } catch (err) {\n                        const message = (err as any).parameters.errors[0].message;\n                        assert.strictEqual(message, 'has additional properties');\n                        hasThrown = true;\n                    }\n                    assert.ok(hasThrown);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"final fields should be required","suites":["instance",".validate()","negative"],"updatePoint":{"line":708,"column":51},"line":708,"code":"                it('final fields should be required', () => {\n                    const schema = createRxSchema(schemas.humanFinal);\n                    let hasThrown = false;\n                    const obj = {\n                        passportId: 'foobar',\n                        firstName: 'foo',\n                        lastName: 'bar'\n                    };\n                    try {\n                        schema.validate(obj);\n                    } catch (err) {\n                        const deepParam = (err as any).parameters.errors[0].field;\n                        assert.strictEqual(deepParam, 'data.age');\n                        hasThrown = true;\n                    }\n                    assert.ok(hasThrown);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should show fields with undefined in the error-params","suites":["instance",".validate()","negative"],"updatePoint":{"line":725,"column":73},"line":725,"code":"                it('should show fields with undefined in the error-params', () => {\n                    const schema = createRxSchema(schemas.humanFinal);\n                    let error = null;\n                    try {\n                        schema.validate({\n                            foo: 'bar',\n                            noval: undefined,\n                            nr: 7\n                        });\n                    } catch (err) {\n                        error = err;\n                    }\n                    assert.ok(error);\n                    assert.deepStrictEqual((error as any).parameters.obj.noval, undefined);\n                    const text = (error as any).toString();\n                    assert.ok(text.includes('noval'));\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should allow a valid change","suites":["instance",".validateChange()","positive"],"updatePoint":{"line":746,"column":47},"line":746,"code":"                it('should allow a valid change', () => {\n                    const schema = createRxSchema(schemas.human);\n                    const dataBefore = schemaObjects.human();\n                    const dataAfter = clone(dataBefore);\n                    dataAfter.age = 100;\n\n                    schema.validateChange(dataBefore, dataAfter);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not allow to change the primary","suites":["instance",".validateChange()","negative"],"updatePoint":{"line":756,"column":58},"line":756,"code":"                it('should not allow to change the primary', async () => {\n                    const schema = createRxSchema(schemas.primaryHuman);\n                    const dataBefore = schemaObjects.human();\n                    const dataAfter = clone(dataBefore);\n                    dataAfter.passportId = 'foobar';\n\n                    await AsyncTestUtil.assertThrows(\n                        () => schema.validateChange(dataBefore, dataAfter),\n                        'RxError',\n                        'final'\n                    );\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not allow to change a final field","suites":["instance",".validateChange()","negative"],"updatePoint":{"line":768,"column":60},"line":768,"code":"                it('should not allow to change a final field', async () => {\n                    const schema = createRxSchema(schemas.humanFinal);\n                    const dataBefore = schemaObjects.human();\n                    dataBefore.age = 1;\n                    const dataAfter = clone(dataBefore);\n                    dataAfter.age = 100;\n\n                    await AsyncTestUtil.assertThrows(\n                        () => schema.validateChange(dataBefore, dataAfter),\n                        'RxError',\n                        'final'\n                    );\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get firstLevel","suites":["instance",".getSchemaByObjectPath()","positive"],"updatePoint":{"line":785,"column":34},"line":785,"code":"                it('get firstLevel', () => {\n                    const schema = createRxSchema(schemas.human);\n                    const schemaObj = getSchemaByObjectPath(schema.jsonSchema, 'passportId');\n                    assert.strictEqual(schemaObj.type, 'string');\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get deeper","suites":["instance",".getSchemaByObjectPath()","positive"],"updatePoint":{"line":790,"column":30},"line":790,"code":"                it('get deeper', () => {\n                    const schema = createRxSchema(schemas.nestedHuman);\n                    const schemaObj = getSchemaByObjectPath(schema.jsonSchema, 'mainSkill');\n                    assert.ok(schemaObj.properties);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get nested","suites":["instance",".getSchemaByObjectPath()","positive"],"updatePoint":{"line":795,"column":30},"line":795,"code":"                it('get nested', () => {\n                    const schema = createRxSchema(schemas.nestedHuman);\n                    const schemaObj = getSchemaByObjectPath(schema.jsonSchema, 'mainSkill.name');\n                    assert.strictEqual(schemaObj.type, 'string');\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should fill all unset fields","suites":["instance",".fillObjectWithDefaults()","positive"],"updatePoint":{"line":805,"column":48},"line":805,"code":"                it('should fill all unset fields', () => {\n                    const schema = createRxSchema(schemas.humanDefault);\n                    const data = {\n                        foo: 'bar'\n                    };\n                    const filled = schema.fillObjectWithDefaults(data);\n                    assert.ok(data !== filled);\n                    assert.strictEqual(filled.foo, 'bar');\n                    assert.strictEqual(filled.age, 20);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not overwrite given values","suites":["instance",".fillObjectWithDefaults()","positive"],"updatePoint":{"line":815,"column":53},"line":815,"code":"                it('should not overwrite given values', () => {\n                    const schema = createRxSchema(schemas.humanDefault);\n                    const data = {\n                        foo: 'bar',\n                        age: 40\n                    };\n                    const data2 = clone(data);\n                    const filled = schema.fillObjectWithDefaults(data);\n                    const filled2 = schema.fillObjectWithDefaults(data2);\n                    assert.ok(data !== filled);\n                    assert.strictEqual(filled.foo, 'bar');\n                    assert.strictEqual(filled.age, 40);\n                    assert.strictEqual(filled2.foo, 'bar');\n                    assert.strictEqual(filled2.age, 40);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"#590 Strange schema behavior with sub-sub-index","suites":["issues"],"updatePoint":{"line":834,"column":59},"line":834,"code":"        it('#590 Strange schema behavior with sub-sub-index', async () => {\n            const schema: RxJsonSchema<{ id: string, fileInfo: any }> = {\n                version: 0,\n                primaryKey: 'id',\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    fileInfo: {\n                        type: 'object',\n                        properties: {\n                            watch: {\n                                type: 'object',\n                                properties: {\n                                    time: {\n                                        type: 'number',\n                                        minimum: 0,\n                                        maximum: 10000,\n                                        multipleOf: 1\n                                    }\n                                }\n                            }\n                        },\n                    },\n                },\n                indexes: ['fileInfo.watch.time']\n            };\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage()\n            });\n            const cols = await db.addCollections({\n                items: {\n                    schema\n                }\n            });\n\n            await cols.items.insert({\n                id: '1',\n                fileInfo: {\n                    watch: {\n                        time: 1\n                    }\n                }\n            });\n\n            const query = cols.items.find({\n                selector: {\n                    'fileInfo.watch.time': {\n                        $gt: -9999999999999999999999999999\n                    }\n                },\n                sort: [\n                    { 'fileInfo.watch.time': 'asc' }\n                ]\n            });\n\n            const found = await query.exec();\n            assert.strictEqual(found.length, 1);\n            assert.strictEqual(found[0].fileInfo.watch.time, 1);\n            db.destroy();\n        });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"#620 indexes should not be required","suites":["issues"],"updatePoint":{"line":898,"column":47},"line":898,"code":"        it('#620 indexes should not be required', async () => {\n            const mySchema: RxJsonSchema<{ passportId: string, firstName: string; lastName: string; age: number; }> = {\n                version: 0,\n                primaryKey: 'passportId',\n                type: 'object',\n                properties: {\n                    passportId: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    firstName: {\n                        type: 'string'\n                    },\n                    lastName: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    age: {\n                        type: 'integer',\n                        minimum: 0,\n                        maximum: 150\n                    }\n                },\n                indexes: ['lastName']\n            };\n            // create a database\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage()\n            });\n            const collections = await db.addCollections({\n                test: {\n                    schema: mySchema\n                }\n            });\n            await collections.test.insert({\n                passportId: 'foobar',\n                firstName: 'Bob',\n                age: 56\n            });\n            db.destroy();\n        });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"#697 Indexes do not work in objects named \"properties\"","suites":["issues"],"updatePoint":{"line":940,"column":66},"line":940,"code":"        it('#697 Indexes do not work in objects named \"properties\"', async () => {\n            const mySchema: RxJsonSchema<{ id: string; properties: any }> = {\n                version: 0,\n                primaryKey: 'id',\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    properties: {\n                        type: 'object',\n                        properties: {\n                            name: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            content: {\n                                type: 'string',\n                                maxLength: 100\n                            }\n                        }\n                    },\n                },\n                indexes: ['properties.name', 'properties.content']\n            };\n\n            // create a database\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage()\n            });\n            const collections = await db.addCollections({\n                test: {\n                    schema: mySchema\n                }\n            });\n\n            await collections.test.insert({\n                id: randomCouchString(12),\n                properties: {\n                    name: 'Title',\n                    content: 'Post content'\n                }\n            });\n\n            db.destroy();\n        });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"#697(2) should also work deep nested","suites":["issues"],"updatePoint":{"line":988,"column":48},"line":988,"code":"        it('#697(2) should also work deep nested', async () => {\n            const mySchema: RxJsonSchema<{ id: string; properties: any; }> = {\n                version: 0,\n                type: 'object',\n                primaryKey: 'id',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    properties: {\n                        type: 'object',\n                        properties: {\n                            name: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            properties: {\n                                type: 'string',\n                                maxLength: 100\n                            }\n                        }\n                    },\n                },\n                indexes: ['properties.name', 'properties.properties']\n            };\n\n            // create a database\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage()\n            });\n            const collections = await db.addCollections({\n                test: {\n                    schema: mySchema\n                }\n            });\n\n            await collections.test.insert({\n                id: randomCouchString(12),\n                properties: {\n                    name: 'Title',\n                    properties: 'Post content'\n                }\n            });\n\n            assert.deepStrictEqual(\n                [\n                    ['properties.name', 'id'],\n                    ['properties.properties', 'id']\n                ],\n                collections.test.schema.indexes\n            );\n\n            db.destroy();\n        });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"w8 a bit","suites":["wait a bit"],"updatePoint":{"line":1046,"column":20},"line":1046,"code":"        it('w8 a bit', async () => {\n            await AsyncTestUtil.wait(0);\n        });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should sort in the correct order","suites":["RxStorageDexieStatics",".getSortComparator()"],"updatePoint":{"line":43,"column":48},"line":43,"code":"            it('should sort in the correct order', () => {\n                const docA = schemaObjects.human(\n                    randomCouchString(10),\n                    1\n                );\n                const docB = schemaObjects.human(\n                    randomCouchString(10),\n                    2\n                );\n                const query: MangoQuery = {\n                    selector: {},\n                    sort: [\n                        { age: 'asc' }\n                    ]\n                }\n                const comparator = RxStorageDexieStatics.getSortComparator<HumanDocumentType>(\n                    humanMinimal as any,\n                    query\n                );\n                const sortResult = comparator(docA, docB);\n                assert.strictEqual(sortResult, -1);\n                const sortResultReverse = comparator(docB, docA);\n                assert.strictEqual(sortResultReverse, 1);\n            });","file":"unit/rx-storage-dexie.test.ts","skipped":false,"dir":"test"},{"name":"should find the matching document","suites":["RxStorageDexieStatics",".getQueryMatcher()"],"updatePoint":{"line":69,"column":49},"line":69,"code":"            it('should find the matching document', () => {\n                const docMatching = schemaObjects.human(\n                    randomCouchString(10),\n                    1\n                );\n                const docNotMatching = schemaObjects.human(\n                    randomCouchString(10),\n                    2\n                );\n                const query: MangoQuery = {\n                    selector: {\n                        age: 1\n                    }\n                };\n                const matcher = RxStorageDexieStatics.getQueryMatcher(\n                    fillWithDefaultSettings(humanMinimal),\n                    query\n                );\n                const matching = matcher(docMatching as any);\n                assert.ok(matching);\n\n                const notMatching = matcher(docNotMatching as any);\n                assert.strictEqual(notMatching, false);\n            });","file":"unit/rx-storage-dexie.test.ts","skipped":false,"dir":"test"},{"name":"should start with the primary key","suites":["helper",".getDexieStoreSchema()"],"updatePoint":{"line":97,"column":49},"line":97,"code":"            it('should start with the primary key', () => {\n                const dexieSchema = getDexieStoreSchema({\n                    primaryKey: 'id',\n                    type: 'object',\n                    version: 0,\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    }\n                });\n                assert.ok(dexieSchema.startsWith('id'));\n            });","file":"unit/rx-storage-dexie.test.ts","skipped":false,"dir":"test"},{"name":"should contains the indexes","suites":["helper",".getDexieStoreSchema()"],"updatePoint":{"line":111,"column":43},"line":111,"code":"            it('should contains the indexes', () => {\n                const dexieSchema = getDexieStoreSchema({\n                    primaryKey: 'id',\n                    type: 'object',\n                    version: 0,\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        age: {\n                            type: 'number'\n                        }\n                    },\n                    indexes: [\n                        ['age', 'id']\n                    ]\n                });\n                assert.ok(dexieSchema.startsWith('id, [age+id]'));\n            });","file":"unit/rx-storage-dexie.test.ts","skipped":false,"dir":"test"},{"name":"should use the correct index","suites":["query",".getPouchQueryPlan()"],"updatePoint":{"line":135,"column":44},"line":135,"code":"            it('should use the correct index', () => {\n                const schema: RxJsonSchema<any> = {\n                    version: 0,\n                    primaryKey: 'key',\n                    type: 'object',\n                    properties: {\n                        key: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        age: {\n                            type: 'number'\n                        }\n                    },\n                    indexes: [\n                        ['age', 'key']\n                    ]\n                };\n\n                const queryPlan = getPouchQueryPlan(\n                    schema,\n                    {\n                        selector: {\n                            age: {\n                                $gt: 18\n                            }\n                        },\n                        sort: [\n                            { age: 'asc' },\n                            { key: 'asc' }\n                        ],\n                        limit: 5,\n                        skip: 1\n                    }\n                );\n\n                const hasAgeField = queryPlan.index.def.fields.find((field: any) => Object.keys(field)[0] === 'age');\n                assert.ok(hasAgeField);\n                const hasKeyField = queryPlan.index.def.fields.find((field: any) => Object.keys(field)[0] === 'key');\n                assert.ok(hasKeyField);\n            });","file":"unit/rx-storage-dexie.test.ts","skipped":false,"dir":"test"},{"name":"should respect a custom index","suites":[".query()"],"updatePoint":{"line":179,"column":41},"line":179,"code":"        it('should respect a custom index', async () => {\n            /**\n             * This test should only run when dexie\n             */\n            assert.strictEqual(config.storage.name, 'dexie');\n\n            const storage = config.storage.getStorage();\n\n            let schema = clone(humanSchemaLiteral) as any;\n            schema.indexes.push(['passportId', 'age']);\n            /*\n                        schema.indexes.push(['age']);\n                        schema.indexes.push(['age', 'passportId']);\n                        schema.indexes.push(['age', 'firstName', 'passportId']);\n                        schema.indexes.push(['firstName', 'age', 'passportId']);\n                        */\n            schema = normalizeRxJsonSchema(schema);\n\n            const databaseName = randomCouchString(12);\n            const storageInstance = await storage.createStorageInstance<HumanDocumentType>({\n                databaseName,\n                collectionName: randomCouchString(12),\n                schema,\n                options: {},\n                multiInstance: false\n            });\n\n            await storageInstance.bulkWrite(\n                new Array(5).fill(0).map(() => {\n                    const data = schemaObjects.human() as any;\n                    data._attachments = {};\n                    data._deleted = false;\n                    data.age = 18;\n                    return {\n                        document: data\n                    }\n                })\n            );\n\n            // const hasIndexes = await pouch.getIndexes();\n\n            async function analyzeQuery(query: MangoQuery<HumanDocumentType>) {\n                const preparedQuery = storage.statics.prepareQuery(\n                    schema,\n                    normalizeMangoQuery(schema, query)\n                );\n                const queryPlan = getPouchQueryPlan(\n                    schema,\n                    preparedQuery\n                );\n                const result = await storageInstance.query(preparedQuery);\n                return {\n                    query,\n                    preparedQuery,\n                    queryPlan,\n                    result: result.documents\n                };\n            }\n\n            const defaultAnalyzed = await analyzeQuery({\n                selector: {},\n                sort: [\n                    { passportId: 'asc' }\n                ]\n            });\n\n            const customIndexAnalyzed = await analyzeQuery({\n                selector: {},\n                sort: [\n                    { passportId: 'asc' }\n                ],\n                index: ['passportId', 'age']\n            });\n\n            // default should use default index\n            assert.strictEqual(\n                defaultAnalyzed.queryPlan.index.ddoc,\n                null\n            );\n\n            // custom should use the custom index\n            (customIndexAnalyzed.query as any).index.forEach((indexKey: string) => {\n                if (indexKey !== 'passportId') {\n                    assert.ok(ensureNotFalsy(customIndexAnalyzed.queryPlan.index.ddoc).includes(indexKey));\n                }\n            });\n            assert.ok(ensureNotFalsy(customIndexAnalyzed.queryPlan.index.ddoc).includes('_id'));\n\n            // both queries should have returned the same documents\n            assert.deepStrictEqual(\n                defaultAnalyzed.result,\n                customIndexAnalyzed.result\n            );\n\n            storageInstance.close();\n        });","file":"unit/rx-storage-dexie.test.ts","skipped":false,"dir":"test"},{"name":".hashKey","suites":["statics"],"updatePoint":{"line":164,"column":20},"line":164,"code":"        it('.hashKey', () => {\n            const statics = config.storage.getStorage().statics;\n            assert.strictEqual(typeof statics.hashKey, 'string');\n            assert.ok(statics.hashKey.length > 0);\n        });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"open and close","suites":["RxStorageInstance","creation"],"updatePoint":{"line":172,"column":30},"line":172,"code":"            it('open and close', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n                await storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"open many instances on the same database name","suites":["RxStorageInstance","creation"],"updatePoint":{"line":182,"column":61},"line":182,"code":"            it('open many instances on the same database name', async () => {\n                const databaseName = randomCouchString(12);\n                const amount = 20;\n                const storage = config.storage.getStorage();\n                const instances = await Promise.all(\n                    new Array(amount).fill(0).map(() => storage.createStorageInstance<TestDocType>({\n                        databaseName,\n                        collectionName: randomCouchString(12),\n                        schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                        options: {},\n                        multiInstance: false\n                    }))\n                );\n                await Promise.all(instances.map(instance => instance.close()));\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should write the document","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":199,"column":41},"line":199,"code":"            it('should write the document', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const docData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'barfoo1',\n                    _deleted: false,\n                    _meta: {\n                        lwt: now()\n                    },\n                    _rev: EXAMPLE_REVISION_1,\n                    _attachments: {}\n                };\n                const writeResponse = await storageInstance.bulkWrite(\n                    [{\n                        document: clone(docData)\n                    }]\n                );\n\n                assert.deepStrictEqual(writeResponse.error, {});\n                const first = getFromObjectOrThrow(writeResponse.success, 'foobar');\n                assert.deepStrictEqual(docData, first);\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should error on conflict","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":229,"column":40},"line":229,"code":"            it('should error on conflict', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const writeData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'barfoo',\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n\n                await storageInstance.bulkWrite(\n                    [{\n                        document: writeData\n                    }]\n                );\n                const writeResponse = await storageInstance.bulkWrite(\n                    [{\n                        document: writeData\n                    }]\n                );\n\n                assert.deepStrictEqual(writeResponse.success, {});\n                const first = getFromObjectOrThrow(writeResponse.error, 'foobar');\n                assert.strictEqual(first.status, 409);\n                assert.strictEqual(first.documentId, 'foobar');\n\n                /**\n                 * The conflict error state must contain the\n                 * document state in the database.\n                 * This ensures that we can continue resolving the conflict\n                 * without having to pull the document out of the db first.\n                 */\n                assert.ok(ensureNotFalsy(first.documentInDb).value, writeData.value);\n\n                assert.ok(first.writeRow);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"when inserting the same document at the same time, the first call must succeed while the seconds has a conflict","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":277,"column":127},"line":277,"code":"            it('when inserting the same document at the same time, the first call must succeed while the seconds has a conflict', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const writeData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'barfoo',\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n\n\n                const [first, second] = await Promise.all([\n                    storageInstance.bulkWrite(\n                        [{\n                            document: Object.assign({}, writeData, {\n                                value: 'first'\n                            })\n                        }]\n                    ),\n                    storageInstance.bulkWrite(\n                        [{\n                            document: Object.assign({}, writeData, {\n                                value: 'second'\n                            })\n                        }]\n                    )\n                ]);\n\n                assert.deepStrictEqual(first.error, {});\n                assert.strictEqual(getFromObjectOrThrow(first.success, 'foobar').value, 'first');\n                assert.strictEqual(getFromObjectOrThrow(second.error, 'foobar').status, 409);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should not find the deleted document","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":321,"column":52},"line":321,"code":"            it('should not find the deleted document', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                // make an insert\n                const insertData = {\n                    key: 'foobar',\n                    value: 'barfoo1',\n                    _deleted: false,\n                    _rev: EXAMPLE_REVISION_1,\n                    _attachments: {},\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n                const insertResponse = await storageInstance.bulkWrite(\n                    [{\n                        document: insertData\n                    }]\n                );\n                assert.deepStrictEqual(insertResponse.error, {});\n                const first = getFromObjectOrThrow(insertResponse.success, 'foobar');\n\n\n                // make an update\n                const updateData = Object.assign({}, insertData, {\n                    value: 'barfoo2',\n                    _rev: EXAMPLE_REVISION_2,\n                    _meta: {\n                        lwt: now()\n                    }\n                });\n                const updateResponse = await storageInstance.bulkWrite(\n                    [{\n                        previous: insertData,\n                        document: updateData\n                    }]\n                );\n                assert.deepStrictEqual(updateResponse.error, {});\n\n                // make the delete\n                const deleteResponse = await storageInstance.bulkWrite(\n                    [{\n                        previous: updateData,\n                        document: Object.assign({}, first, {\n                            _deleted: true,\n                            _rev: EXAMPLE_REVISION_3,\n                            _meta: {\n                                lwt: now()\n                            }\n                        })\n                    }]\n                );\n                assert.deepStrictEqual(deleteResponse.error, {});\n\n                const foundDoc = await storageInstance.findDocumentsById(['foobar'], false);\n                assert.deepStrictEqual(foundDoc, {});\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to overwrite a deleted the document","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":386,"column":66},"line":386,"code":"            it('should be able to overwrite a deleted the document', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const docId = 'undeleteMe';\n                const insertResponse = await storageInstance.bulkWrite(\n                    [{\n                        document: {\n                            key: docId,\n                            value: 'barfoo1',\n                            _deleted: false,\n                            _attachments: {},\n                            _rev: EXAMPLE_REVISION_1,\n                            _meta: {\n                                lwt: now()\n                            }\n                        }\n                    }]\n                );\n                assert.strictEqual(Object.keys(insertResponse.error).length, 0);\n                let previous = getFromObjectOrThrow(insertResponse.success, docId);\n\n                const updateResponse = await storageInstance.bulkWrite(\n                    [{\n                        previous: previous,\n                        document: Object.assign({}, previous, {\n                            value: 'barfoo2',\n                            _rev: EXAMPLE_REVISION_2,\n                            _meta: {\n                                lwt: now()\n                            }\n                        })\n                    }]\n                );\n                assert.deepStrictEqual(updateResponse.error, {});\n                previous = getFromObjectOrThrow(updateResponse.success, docId);\n\n\n                const deleteResponse = await storageInstance.bulkWrite(\n                    [{\n                        previous: previous,\n                        document: Object.assign({}, previous, {\n                            _deleted: true,\n                            _rev: EXAMPLE_REVISION_3,\n                            _meta: {\n                                lwt: now()\n                            }\n                        })\n                    }]\n                );\n                assert.deepStrictEqual(deleteResponse.error, {});\n                const second = getFromObjectOrThrow(deleteResponse.success, docId);\n\n\n                const undeleteResponse = await storageInstance.bulkWrite(\n                    [{\n                        // No previous doc data is send here. Because we 'undelete' the document\n                        // which can be done via .insert()\n                        document: Object.assign({}, second, {\n                            _deleted: false,\n                            value: 'aaa',\n                            _rev: EXAMPLE_REVISION_4,\n                            _meta: {\n                                lwt: now()\n                            }\n                        })\n                    }]\n                );\n\n                assert.deepStrictEqual(undeleteResponse.error, {});\n                const third = getFromObjectOrThrow(undeleteResponse.success, docId);\n                assert.strictEqual(third.value, 'aaa');\n\n\n                const foundDoc = await storageInstance.findDocumentsById([docId], false);\n                assert.ok(foundDoc[docId]);\n                assert.deepStrictEqual(foundDoc[docId].value, 'aaa');\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to update the state of a deleted document","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":477,"column":72},"line":477,"code":"            it('should be able to update the state of a deleted document', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n                const docId = 'foobar';\n\n                // insert\n                const docData: RxDocumentData<TestDocType> = {\n                    key: docId,\n                    value: 'barfoo1',\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n                const insertResponse = await storageInstance.bulkWrite([{\n                    document: docData\n                }]);\n                assert.deepStrictEqual(insertResponse.error, {});\n                let previous = insertResponse.success[docId];\n\n                // delete\n                const deleteResponse = await storageInstance.bulkWrite([{\n                    previous,\n                    document: Object.assign({}, docData, {\n                        _deleted: true,\n                        _rev: EXAMPLE_REVISION_2,\n                        _meta: { lwt: now() }\n                    })\n                }]);\n                assert.deepStrictEqual(deleteResponse.error, {});\n                previous = deleteResponse.success[docId];\n\n                // modify deleted\n                const modifyResponse = await storageInstance.bulkWrite([{\n                    previous,\n                    document: Object.assign({}, docData, {\n                        value: 'barfoo2',\n                        _deleted: true,\n                        _rev: EXAMPLE_REVISION_3,\n                        _meta: { lwt: now() }\n                    })\n                }]);\n                assert.deepStrictEqual(modifyResponse.error, {});\n                previous = modifyResponse.success[docId];\n                assert.strictEqual(previous.value, 'barfoo2');\n\n                // check modified\n                const docs = await storageInstance.findDocumentsById([docId], true);\n                const doc = docs[docId];\n                assert.ok(doc);\n                assert.strictEqual(doc.value, 'barfoo2');\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to unset a property","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":538,"column":50},"line":538,"code":"            it('should be able to unset a property', async () => {\n                const schema = getTestDataSchema();\n                schema.required = ['key'];\n\n                const storageInstance = await config.storage.getStorage().createStorageInstance<OptionalValueTestDoc>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: schema as any,\n                    options: {},\n                    multiInstance: false\n                });\n                const docId = 'foobar';\n                const insertData: RxDocumentWriteData<OptionalValueTestDoc> = {\n                    key: docId,\n                    value: 'barfoo1',\n                    _attachments: {},\n                    _deleted: false,\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n                const writeResponse = await storageInstance.bulkWrite(\n                    [{\n                        document: insertData\n                    }]\n                );\n                const insertResponse = getFromObjectOrThrow(writeResponse.success, docId);\n                const insertDataAfterWrite: RxDocumentData<OptionalValueTestDoc> = Object.assign(\n                    {},\n                    insertResponse,\n                    {\n                        _rev: insertResponse._rev\n                    }\n                );\n\n                const updateResponse = await storageInstance.bulkWrite(\n                    [{\n                        previous: insertDataAfterWrite,\n                        document: {\n                            key: docId,\n                            _attachments: {},\n                            _deleted: false,\n                            _rev: EXAMPLE_REVISION_2,\n                            _meta: {\n                                lwt: now()\n                            }\n                        }\n                    }]\n                );\n                const updateResponseDoc = getFromObjectOrThrow(updateResponse.success, docId);\n                delete (updateResponseDoc as any)._deleted;\n                delete (updateResponseDoc as any)._rev;\n                delete (updateResponseDoc as any)._meta;\n\n                assert.deepStrictEqual(\n                    updateResponseDoc,\n                    {\n                        key: docId,\n                        _attachments: {}\n                    }\n                )\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to store a complex document with key compression","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":603,"column":79},"line":603,"code":"            it('should be able to store a complex document with key compression', async () => {\n                const databaseName = randomCouchString(12);\n                const schema = fillWithDefaultSettings(schemas.averageSchema());\n                const compressionState = getCompressionStateByRxJsonSchema(schema);\n                const storageInstance = await config.storage.getStorage().createStorageInstance<any>({\n                    databaseName,\n                    collectionName: randomCouchString(12),\n                    schema: compressionState.schema,\n                    options: {},\n                    multiInstance: false\n                });\n\n                const docData = Object.assign(\n                    schemaObjects.averageSchema(),\n                    {\n                        _attachments: {},\n                        _deleted: false,\n                        _rev: EXAMPLE_REVISION_1,\n                        _meta: {\n                            lwt: now()\n                        }\n                    }\n                );\n                const compressedDocData = compressObject(\n                    compressionState.table,\n                    docData\n                );\n                const writeResponse = await storageInstance.bulkWrite([\n                    {\n                        document: compressedDocData\n                    }\n                ]);\n                assert.deepStrictEqual(writeResponse.error, {});\n\n                const getDocFromDb = await storageInstance.findDocumentsById([docData.id], false);\n                assert.deepStrictEqual(\n                    getDocFromDb[docData.id],\n                    compressedDocData\n                );\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to create another instance after a write","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":645,"column":71},"line":645,"code":"            it('should be able to create another instance after a write', async () => {\n                const databaseName = randomCouchString(12);\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName,\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n                const docData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'barfoo1',\n                    _attachments: {},\n                    _deleted: false,\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n                await storageInstance.bulkWrite(\n                    [{\n                        document: clone(docData)\n                    }]\n                );\n                const storageInstance2 = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName,\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n                await storageInstance2.bulkWrite(\n                    [{\n                        document: Object.assign(\n                            clone(docData),\n                            {\n                                _rev: EXAMPLE_REVISION_2,\n                            }\n                        )\n                    }]\n                );\n                await Promise.all([\n                    storageInstance.close(),\n                    storageInstance2.close()\n                ]);\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should sort in the correct order","suites":["RxStorageInstance",".getSortComparator()"],"updatePoint":{"line":693,"column":48},"line":693,"code":"            it('should sort in the correct order', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<{\n                    _id: string;\n                    age: number;\n                }>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: fillWithDefaultSettings({\n                        version: 0,\n                        type: 'object',\n                        primaryKey: '_id',\n                        properties: {\n                            _id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            age: {\n                                type: 'number'\n                            }\n                        },\n                        required: [\n                            '_id',\n                            'age'\n                        ]\n                    }),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const query: FilledMangoQuery<any> = {\n                    selector: {},\n                    limit: 1000,\n                    sort: [\n                        { age: 'asc' }\n                    ],\n                    skip: 0\n                };\n                const preparedQuery = config.storage.getStorage().statics.prepareQuery(\n                    storageInstance.schema,\n                    query\n                );\n\n                const comparator = config.storage.getStorage().statics.getSortComparator(\n                    storageInstance.schema,\n                    preparedQuery\n                );\n\n                const doc1: any = schemaObjects.human();\n                doc1._id = 'aa';\n                doc1.age = 1;\n                const doc2: any = schemaObjects.human();\n                doc2._id = 'bb';\n                doc2.age = 100;\n\n                // should sort in the correct order\n                assert.deepStrictEqual(\n                    [doc1, doc2],\n                    [doc1, doc2].sort(comparator)\n                );\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should still sort in correct order when docs do not match the selector","suites":["RxStorageInstance",".getSortComparator()"],"updatePoint":{"line":755,"column":86},"line":755,"code":"            it('should still sort in correct order when docs do not match the selector', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getTestDataSchema(),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const matchingValue = 'foobar';\n                const query: FilledMangoQuery<TestDocType> = {\n                    selector: {\n                        value: {\n                            $eq: matchingValue\n                        }\n                    },\n                    sort: [\n                        { key: 'asc' }\n                    ],\n                    skip: 0\n                };\n                const preparedQuery = config.storage.getStorage().statics.prepareQuery(\n                    storageInstance.schema,\n                    query\n                );\n\n                const comparator = config.storage.getStorage().statics.getSortComparator(\n                    storageInstance.schema,\n                    preparedQuery\n                );\n\n                const docs: TestDocType[] = [\n                    {\n                        value: matchingValue,\n                        key: 'aaa'\n                    },\n                    {\n                        value: 'barfoo',\n                        key: 'bbb'\n                    }\n                ];\n\n                const result = comparator(\n                    docs[0],\n                    docs[1]\n\n                );\n                assert.strictEqual(result, -1);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should work with a more complex query","suites":["RxStorageInstance",".getSortComparator()"],"updatePoint":{"line":806,"column":53},"line":806,"code":"            it('should work with a more complex query', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getTestDataSchema(),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const matchingValue = 'aaa';\n                const query: FilledMangoQuery<TestDocType> = {\n                    selector: {\n                        $or: [\n                            {\n                                value: matchingValue,\n                                key: matchingValue\n                            },\n                            {\n                                value: 'barfoo',\n                                key: 'barfoo'\n                            }\n                        ],\n                        key: matchingValue\n                    },\n                    sort: [\n                        { key: 'asc' }\n                    ],\n                    skip: 0\n                };\n\n                const preparedQuery = config.storage.getStorage().statics.prepareQuery(\n                    storageInstance.schema,\n                    query\n                );\n\n                const comparator = config.storage.getStorage().statics.getSortComparator(\n                    storageInstance.schema,\n                    preparedQuery\n                );\n\n                const docs: TestDocType[] = [\n                    {\n                        value: matchingValue,\n                        key: matchingValue\n                    },\n                    {\n                        value: 'bbb',\n                        key: 'bbb'\n                    }\n                ];\n\n                const result = comparator(\n                    docs[0],\n                    docs[1]\n\n                );\n                assert.strictEqual(result, -1);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should match the right docs","suites":["RxStorageInstance",".getQueryMatcher()"],"updatePoint":{"line":868,"column":43},"line":868,"code":"            it('should match the right docs', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion(0, '_id' as any),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const query: FilledMangoQuery<TestDocType> = {\n                    selector: {\n                        age: {\n                            $gt: 10,\n                            $ne: 50\n                        }\n                    },\n                    sort: [\n                        {\n                            _id: 'asc'\n                        }\n                    ],\n                    skip: 0\n                };\n\n                const queryMatcher = config.storage.getStorage().statics.getQueryMatcher(\n                    storageInstance.schema,\n                    config.storage.getStorage().statics.prepareQuery(\n                        storageInstance.schema,\n                        query\n                    )\n                );\n\n                const doc1: any = schemaObjects.human();\n                doc1._id = 'aa';\n                doc1.age = 1;\n                const doc2: any = schemaObjects.human();\n                doc2._id = 'bb';\n                doc2.age = 100;\n\n                assert.strictEqual(queryMatcher(doc1), false);\n                assert.strictEqual(queryMatcher(doc2), true);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should not match deleted documents","suites":["RxStorageInstance",".getQueryMatcher()"],"updatePoint":{"line":912,"column":50},"line":912,"code":"            it('should not match deleted documents', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<{ _id: string }>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<{ _id: string }>(0, '_id' as any),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const query: FilledMangoQuery<{ _id: string }> = {\n                    selector: {},\n                    sort: [\n                        { _id: 'asc' }\n                    ],\n                    skip: 0\n                };\n\n                const queryMatcher = config.storage.getStorage().statics.getQueryMatcher(\n                    storageInstance.schema,\n                    config.storage.getStorage().statics.prepareQuery(\n                        storageInstance.schema,\n                        query\n                    )\n                );\n\n                const doc1: any = schemaObjects.human();\n                doc1._deleted = true;\n                assert.strictEqual(\n                    queryMatcher(doc1),\n                    false\n                );\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should match the nested document","suites":["RxStorageInstance",".getQueryMatcher()"],"updatePoint":{"line":946,"column":48},"line":946,"code":"            it('should match the nested document', async () => {\n                const schema = getNestedDocSchema();\n                const query: FilledMangoQuery<NestedDoc> = {\n                    selector: {\n                        'nes.ted': {\n                            $eq: 'barfoo'\n                        }\n                    },\n                    sort: [\n                        { id: 'asc' }\n                    ],\n                    skip: 0\n                };\n\n                const queryMatcher = config.storage.getStorage().statics.getQueryMatcher(\n                    schema,\n                    config.storage.getStorage().statics.prepareQuery(\n                        schema,\n                        query\n                    )\n                );\n\n                const notMatchingDoc = {\n                    id: 'foobar',\n                    nes: {\n                        ted: 'xxx'\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n                const matchingDoc = {\n                    id: 'foobar',\n                    nes: {\n                        ted: 'barfoo'\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n\n                assert.strictEqual(\n                    queryMatcher(notMatchingDoc),\n                    false\n                );\n                assert.strictEqual(\n                    queryMatcher(matchingDoc),\n                    true\n                );\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should find all documents","suites":["RxStorageInstance",".query()"],"updatePoint":{"line":1004,"column":41},"line":1004,"code":"            it('should find all documents', async () => {\n                const storageInstance = await config.storage\n                    .getStorage()\n                    .createStorageInstance<{ key: string; value: string; }>({\n                        databaseName: randomCouchString(12),\n                        collectionName: randomCouchString(12),\n                        schema: getPseudoSchemaForVersion<{ key: string; value: string; }>(0, 'key'),\n                        options: {},\n                        multiInstance: false\n                    });\n\n                const writeData = {\n                    key: 'foobar',\n                    value: 'barfoo',\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n\n                await storageInstance.bulkWrite(\n                    [{\n                        document: writeData\n                    }]\n                );\n\n                const preparedQuery = config.storage.getStorage().statics.prepareQuery(\n                    storageInstance.schema,\n                    {\n                        selector: {},\n                        sort: [{ key: 'asc' }],\n                        skip: 0\n                    }\n                );\n                const allDocs = await storageInstance.query(preparedQuery);\n                const first = allDocs.documents[0];\n                assert.ok(first);\n                assert.strictEqual(first.value, 'barfoo');\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should sort in the correct order","suites":["RxStorageInstance",".query()"],"updatePoint":{"line":1047,"column":48},"line":1047,"code":"            it('should sort in the correct order', async () => {\n                const storageInstance = await config.storage\n                    .getStorage()\n                    .createStorageInstance<{ key: string; value: string; }>({\n                        databaseName: randomCouchString(12),\n                        collectionName: randomCouchString(12),\n                        schema: getTestDataSchema(),\n                        options: {},\n                        multiInstance: false\n                    });\n\n                await storageInstance.bulkWrite([\n                    {\n                        document: getWriteData({ value: 'a' })\n                    },\n                    {\n                        document: getWriteData({ value: 'b' })\n                    },\n                    {\n                        document: getWriteData({ value: 'c' })\n                    },\n                ]);\n\n                const preparedQuery = config.storage.getStorage().statics.prepareQuery(\n                    storageInstance.schema,\n                    {\n                        selector: {},\n                        sort: [\n                            { value: 'desc' }\n                        ],\n                        skip: 0\n                    }\n                );\n                const allDocs = await storageInstance.query(preparedQuery);\n\n                assert.strictEqual(allDocs.documents[0].value, 'c');\n                assert.strictEqual(allDocs.documents[1].value, 'b');\n                assert.strictEqual(allDocs.documents[2].value, 'a');\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should have the same deterministic order of .query() and .getSortComparator()","suites":["RxStorageInstance",".query()"],"updatePoint":{"line":1092,"column":93},"line":1092,"code":"            it('should have the same deterministic order of .query() and .getSortComparator()', async () => {\n                const schema: RxJsonSchema<RxDocumentData<RandomDoc>> = fillWithDefaultSettings({\n                    version: 0,\n                    primaryKey: 'id',\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        equal: {\n                            type: 'string',\n                            maxLength: 20,\n                            enum: ['foobar']\n                        },\n                        increment: {\n                            type: 'number',\n                            minimum: 0,\n                            maximum: 1000,\n                            multipleOf: 1\n                        },\n                        random: {\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    },\n                    indexes: [\n                        /**\n                         * RxDB wil always append the primaryKey to an index\n                         * if the primaryKey was not used in the index before.\n                         * This ensures we have a deterministic sorting when querying documents\n                         * from that index.\n                         */\n                        ['equal', 'id'],\n                        ['increment', 'id'],\n                        ['random', 'id'],\n                        [\n                            'equal',\n                            'increment',\n                            'id'\n                        ]\n                    ],\n                    required: [\n                        'id',\n                        'equal',\n                        'increment',\n                        'random'\n                    ]\n                });\n                const storageInstance = await config.storage\n                    .getStorage()\n                    .createStorageInstance<RandomDoc>({\n                        databaseName: randomCouchString(12),\n                        collectionName: randomCouchString(12),\n                        schema,\n                        options: {},\n                        multiInstance: false\n                    });\n\n                const docData: RxDocumentWriteData<RandomDoc>[] = new Array(10)\n                    .fill(0)\n                    .map((_x, idx) => ({\n                        id: randomString(10),\n                        equal: 'foobar',\n                        random: randomString(10),\n                        increment: idx + 1,\n                        _deleted: false,\n                        _attachments: {},\n                        _rev: EXAMPLE_REVISION_1,\n                        _meta: {\n                            lwt: now()\n                        }\n                    }));\n                const writeResponse: RxStorageBulkWriteResponse<RandomDoc> = await storageInstance.bulkWrite(\n                    docData.map(d => ({ document: d }))\n                );\n                if (Object.keys(writeResponse.error).length > 0) {\n                    throw new Error('could not save');\n                }\n                const docs = Object.values(writeResponse.success);\n\n                async function testQuery(query: FilledMangoQuery<RandomDoc>): Promise<void> {\n                    const preparedQuery = config.storage.getStorage().statics.prepareQuery(\n                        storageInstance.schema,\n                        query\n                    );\n                    const docsViaQuery = (await storageInstance.query(preparedQuery)).documents;\n                    const sortComparator = config.storage.getStorage().statics.getSortComparator(\n                        storageInstance.schema,\n                        preparedQuery\n                    );\n                    const docsViaSort = shuffleArray(docs).sort(sortComparator);\n                    assert.deepStrictEqual(docsViaQuery, docsViaSort);\n                }\n                const queries: FilledMangoQuery<RandomDoc>[] = [\n                    {\n                        selector: {},\n                        sort: [\n                            { id: 'asc' }\n                        ],\n                        skip: 0\n                    },\n                    {\n                        selector: {},\n                        sort: [\n                            { equal: 'asc' },\n                            /**\n                             * RxDB will always append the primaryKey as last sort parameter\n                             * if the primary key is not used in the sorting before.\n                             */\n                            { id: 'asc' }\n                        ],\n                        skip: 0\n                    },\n                    {\n                        selector: {},\n                        sort: [\n                            { increment: 'desc' },\n                            { id: 'asc' }\n                        ],\n                        skip: 0\n                    },\n                    {\n                        selector: {},\n                        sort: [\n                            { equal: 'asc' },\n                            { increment: 'desc' },\n                            { id: 'asc' }\n                        ],\n                        skip: 0\n                    }\n                ];\n                for (const query of queries) {\n                    await testQuery(query);\n                }\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to search over a nested object","suites":["RxStorageInstance",".query()"],"updatePoint":{"line":1230,"column":61},"line":1230,"code":"            it('should be able to search over a nested object', async () => {\n                const schema = getNestedDocSchema();\n                const storageInstance = await config.storage\n                    .getStorage()\n                    .createStorageInstance<NestedDoc>({\n                        databaseName: randomCouchString(12),\n                        collectionName: randomCouchString(12),\n                        schema,\n                        options: {},\n                        multiInstance: false\n                    });\n                const insertResult = await storageInstance.bulkWrite([\n                    {\n                        document: {\n                            id: 'foobar',\n                            nes: {\n                                ted: 'barfoo'\n                            },\n                            _deleted: false,\n                            _attachments: {},\n                            _rev: EXAMPLE_REVISION_1,\n                            _meta: {\n                                lwt: now()\n                            }\n                        }\n                    }\n                ]);\n                assert.deepStrictEqual(insertResult.error, {});\n\n                const preparedQuery = config.storage.getStorage().statics.prepareQuery<NestedDoc>(\n                    schema,\n                    {\n                        selector: {\n                            'nes.ted': {\n                                $eq: 'barfoo'\n                            }\n                        },\n                        sort: [\n                            { 'nes.ted': 'asc' },\n                            { id: 'asc' }\n                        ],\n                        skip: 0\n                    }\n                );\n\n                const results = await storageInstance.query(preparedQuery);\n                assert.strictEqual(results.documents.length, 1);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should find the documents","suites":["RxStorageInstance",".findDocumentsById()"],"updatePoint":{"line":1282,"column":41},"line":1282,"code":"            it('should find the documents', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const docData = {\n                    key: 'foobar',\n                    value: 'barfoo',\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n                await storageInstance.bulkWrite(\n                    [{\n                        document: docData\n                    }]\n                );\n\n                const found = await storageInstance.findDocumentsById(['foobar'], false);\n                const foundDoc = getFromObjectOrThrow(found, 'foobar');\n                assert.deepStrictEqual(foundDoc, docData);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should find deleted documents","suites":["RxStorageInstance",".findDocumentsById()"],"updatePoint":{"line":1313,"column":45},"line":1313,"code":"            it('should find deleted documents', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const insertResult = await storageInstance.bulkWrite(\n                    [{\n                        document: {\n                            key: 'foobar',\n                            value: 'barfoo',\n                            _deleted: false,\n                            _attachments: {},\n                            _rev: EXAMPLE_REVISION_1,\n                            _meta: {\n                                lwt: now()\n                            }\n                        }\n                    }]\n                );\n                const previous = getFromObjectOrThrow(insertResult.success, 'foobar');\n\n                await storageInstance.bulkWrite(\n                    [{\n                        previous,\n                        document: {\n                            key: 'foobar',\n                            value: 'barfoo2',\n                            _deleted: true,\n                            _attachments: {},\n                            _rev: EXAMPLE_REVISION_2,\n                            _meta: {\n                                lwt: now()\n                            }\n                        }\n                    }]\n                );\n\n                const found = await storageInstance.findDocumentsById(['foobar'], true);\n                const foundDeleted = getFromObjectOrThrow(found, 'foobar');\n\n                // even on deleted documents, we must get the other properties.\n                assert.strictEqual(foundDeleted.value, 'barfoo2');\n                assert.strictEqual(foundDeleted._deleted, true);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should get the latests change","suites":["RxStorageInstance",".getChangedDocumentsSince()"],"updatePoint":{"line":1365,"column":45},"line":1365,"code":"            it('should get the latests change', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<{ key: string }>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n                let checkpoint: any;\n                async function getChanges(): Promise<RxDocumentData<{ key: string }>[]> {\n                    const res = await storageInstance.getChangedDocumentsSince(10, checkpoint);\n                    if (res.length > 0) {\n                        checkpoint = lastOfArray(res).checkpoint;\n                    }\n                    return res.map(r => r.document);\n                }\n\n                // should not return anything if nothing has happened\n                const docsEmpty = await getChanges();\n                assert.strictEqual(docsEmpty.length, 0);\n\n                // insert one\n                const insertResult = await storageInstance.bulkWrite([\n                    {\n                        document: {\n                            key: 'foobar',\n                            _deleted: false,\n                            _attachments: {},\n                            _rev: EXAMPLE_REVISION_1,\n                            _meta: {\n                                lwt: now()\n                            }\n                        }\n                    }\n                ]);\n                const docsAfterInsert = await getChanges();\n                assert.strictEqual(docsAfterInsert.length, 1);\n                assert.strictEqual(docsAfterInsert[0].key, 'foobar');\n\n                // delete one\n                await storageInstance.bulkWrite([\n                    {\n                        previous: getFromObjectOrThrow(insertResult.success, 'foobar'),\n                        document: {\n                            key: 'foobar',\n                            _deleted: true,\n                            _attachments: {},\n                            _rev: EXAMPLE_REVISION_2,\n                            _meta: {\n                                lwt: now()\n                            }\n                        }\n                    }\n                ]);\n                const docsAfterDelete = await getChanges();\n                assert.strictEqual(docsAfterDelete.length, 1);\n                assert.strictEqual(docsAfterDelete[0].key, 'foobar');\n                assert.strictEqual(docsAfterDelete[0]._deleted, true);\n\n                // get only the last change when requesting with empty checkpoint\n                const resTotal = await storageInstance.getChangedDocumentsSince(100);\n                assert.strictEqual(resTotal.length, 1);\n                assert.strictEqual(resTotal[0].document.key, 'foobar');\n                assert.strictEqual(resTotal[0].document._deleted, true);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should return the correct amount of documents","suites":["RxStorageInstance",".getChangedDocumentsSince()"],"updatePoint":{"line":1432,"column":61},"line":1432,"code":"            it('should return the correct amount of documents', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getTestDataSchema(),\n                    options: {},\n                    multiInstance: false\n                });\n\n                let previous: any;\n                const insertResult = await storageInstance.bulkWrite([\n                    {\n                        document: getWriteData({ key: 'foobar', value: '0' })\n                    },\n                    // also add another random document\n                    {\n                        document: getWriteData()\n                    }\n                ]);\n                assert.deepStrictEqual(insertResult.error, {});\n                previous = getFromObjectOrThrow(insertResult.success, 'foobar');\n\n                // update the document many times\n                let t = 0;\n                while (t < 10) {\n                    t++;\n                    const newDoc = clone(previous);\n                    newDoc.value = t + '';\n                    const newRev = createRevision(newDoc, previous);\n                    newDoc._rev = newRev;\n                    newDoc._meta.lwt = now();\n                    const updateResult = await storageInstance.bulkWrite([\n                        {\n                            previous,\n                            document: newDoc\n                        }\n                    ]);\n                    assert.deepStrictEqual(updateResult.error, {});\n                    previous = getFromObjectOrThrow(updateResult.success, 'foobar');\n                }\n\n                // should return both documents when called without checkpoint\n                const resultWithoutCheckpoint = await storageInstance.getChangedDocumentsSince(10);\n                assert.strictEqual(resultWithoutCheckpoint.length, 2);\n                // the foobar-doc must have the latest value\n                const foobarRow = resultWithoutCheckpoint.find(row => row.document.key === 'foobar');\n                assert.strictEqual(ensureNotFalsy(foobarRow).document.value, '10');\n\n                // insert many more documents\n                const insertManyResult = await storageInstance.bulkWrite(\n                    new Array(10)\n                        .fill(0)\n                        .map(() => ({ document: getWriteData() }))\n                );\n                assert.deepStrictEqual(insertManyResult.error, {});\n\n                // should return both documents when called without checkpoint\n                const resultManyWithoutCheckpoint = await storageInstance.getChangedDocumentsSince(100);\n                assert.strictEqual(resultManyWithoutCheckpoint.length, 12);\n\n\n                // first get 5 and then another 5 and then again.\n                const resultFirstFive = await storageInstance.getChangedDocumentsSince(5);\n                const resultSecondFive = await storageInstance.getChangedDocumentsSince(5, lastOfArray(resultFirstFive).checkpoint);\n                const resultThirdFive = await storageInstance.getChangedDocumentsSince(5, lastOfArray(resultSecondFive).checkpoint);\n                assert.strictEqual(resultFirstFive.length + resultSecondFive.length + resultThirdFive.length, 12);\n                const resultFourthFive = await storageInstance.getChangedDocumentsSince(5, lastOfArray(resultThirdFive).checkpoint);\n                assert.strictEqual(resultFourthFive.length, 0);\n\n\n                // delete the document\n                const newDoc = clone(previous);\n                newDoc.value = t + '';\n                newDoc._deleted = true;\n                newDoc._meta.lwt = now();\n                const newRev = createRevision(newDoc, previous);\n                newDoc._rev = newRev;\n                const deleteResult = await storageInstance.bulkWrite([\n                    {\n                        previous,\n                        document: newDoc\n                    }\n                ]);\n                assert.deepStrictEqual(deleteResult.error, {});\n\n                const resultAfterDelete = await storageInstance.getChangedDocumentsSince(5, lastOfArray(resultThirdFive).checkpoint);\n                assert.strictEqual(resultAfterDelete.length, 1);\n                assert.strictEqual(resultAfterDelete[0].document._deleted, true);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should emit exactly one event on write","suites":["RxStorageInstance",".changeStream()"],"updatePoint":{"line":1525,"column":54},"line":1525,"code":"            it('should emit exactly one event on write', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const emitted: EventBulk<RxStorageChangeEvent<TestDocType>>[] = [];\n                const sub = storageInstance.changeStream().subscribe(x => {\n                    emitted.push(x);\n                });\n\n                const writeData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'one',\n                    _deleted: false,\n                    _rev: EXAMPLE_REVISION_1,\n                    _attachments: {},\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n\n                // insert\n                await storageInstance.bulkWrite([{\n                    document: writeData\n                }]);\n\n                await wait(100);\n                assert.strictEqual(emitted.length, 1);\n                assert.strictEqual(emitted[0].events.length, 1);\n\n                // should contain the _meta data\n                assert.ok((emitted as any)[0].events[0].change.doc._meta.lwt);\n\n                sub.unsubscribe();\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be compatible with rxjs operators","suites":["RxStorageInstance",".changeStream()"],"updatePoint":{"line":1565,"column":56},"line":1565,"code":"            it('should be compatible with rxjs operators', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const emitted: EventBulk<RxStorageChangeEvent<TestDocType>>[] = [];\n                const sub = storageInstance.changeStream()\n                    .pipe(\n                        map(x => x),\n                        filter(() => true)\n                    )\n                    .subscribe(x => {\n                        emitted.push(x);\n                    });\n\n                const writeData = {\n                    key: 'foobar',\n                    value: 'one',\n                    _rev: EXAMPLE_REVISION_1,\n                    _deleted: false,\n                    _attachments: {},\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n\n                // insert\n                await storageInstance.bulkWrite([{\n                    document: writeData\n                }]);\n\n                await wait(100);\n                assert.strictEqual(emitted.length, 1);\n\n                sub.unsubscribe();\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should emit all events","suites":["RxStorageInstance",".changeStream()"],"updatePoint":{"line":1606,"column":38},"line":1606,"code":"            it('should emit all events', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const emitted: EventBulk<RxStorageChangeEvent<RxDocumentData<TestDocType>>>[] = [];\n                const sub = storageInstance.changeStream().subscribe(x => {\n                    emitted.push(x);\n                });\n\n                let previous: RxDocumentData<TestDocType> | undefined;\n                const writeData = {\n                    key: 'foobar',\n                    value: 'one',\n                    _rev: EXAMPLE_REVISION_1,\n                    _deleted: false,\n                    _attachments: {},\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n\n                // insert\n                const firstWriteResult = await storageInstance.bulkWrite([{\n                    previous,\n                    document: writeData\n                }]);\n                previous = getFromObjectOrThrow(firstWriteResult.success, writeData.key);\n\n                // update\n                const originalBeforeUpdate = clone(writeData);\n                const updateResult = await storageInstance.bulkWrite([{\n                    previous,\n                    document: Object.assign({}, writeData, {\n                        _rev: EXAMPLE_REVISION_2,\n                        _meta: {\n                            lwt: now()\n                        }\n                    })\n                }]);\n                previous = getFromObjectOrThrow(updateResult.success, writeData.key);\n\n                // should not mutate the input or add additional properties to output\n                originalBeforeUpdate._rev = (previous as any)._rev;\n                originalBeforeUpdate._meta = (previous as any)._meta;\n                assert.deepStrictEqual(originalBeforeUpdate, previous);\n\n                // delete\n                const deleteBulkWriteResponse = await storageInstance.bulkWrite([{\n                    previous,\n                    document: Object.assign({}, writeData, {\n                        _rev: EXAMPLE_REVISION_3,\n                        _deleted: true,\n                        _meta: {\n                            lwt: now()\n                        }\n                    })\n                }]);\n                assert.deepStrictEqual(deleteBulkWriteResponse.error, {});\n\n                await waitUntil(() => {\n                    return flattenEvents(emitted).length === 3;\n                });\n                const emittedEvents = flattenEvents(emitted);\n                const lastEvent = lastOfArray(emittedEvents);\n                if (!lastEvent) {\n                    throw new Error('missing last event');\n                }\n\n                /**\n                 * The previous doc data must still contain the given revision height.\n                 * This changed because in the past we increased the rev height\n                 * to be compliant with strange PouchDB behavior.\n                 */\n                const lastRevision = parseRevision((lastEvent as any).change.previous._rev);\n                assert.strictEqual(lastRevision.height, 2);\n\n                assert.strictEqual(lastEvent.change.operation, 'DELETE');\n                assert.ok(lastEvent.change.previous);\n\n                sub.unsubscribe();\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to store and retrieve an attachment","suites":["RxStorageInstance","attachments"],"updatePoint":{"line":1698,"column":66},"line":1698,"code":"            it('should be able to store and retrieve an attachment', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: Object.assign(\n                        getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                        {\n                            attachments: {}\n                        }\n                    ),\n                    options: {},\n                    multiInstance: false\n                });\n                const statics = config.storage.getStorage().statics;\n\n\n                const attachmentData = new Array(20).fill('a').join('');\n                const dataBlobBuffer = blobBufferUtil.createBlobBuffer(\n                    attachmentData,\n                    'text/plain'\n                );\n\n                const dataStringBase64 = await blobBufferUtil.toBase64String(dataBlobBuffer);\n                const attachmentHash = await hashAttachmentData(\n                    dataStringBase64,\n                    statics\n                );\n                const dataLength = getAttachmentSize(dataStringBase64);\n\n                const writeData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'one',\n                    _rev: EXAMPLE_REVISION_1,\n                    _deleted: false,\n                    _meta: {\n                        lwt: now()\n                    },\n                    _attachments: {\n                        foo: {\n                            digest: statics.hashKey + '-' + attachmentHash,\n                            length: dataLength,\n                            data: dataStringBase64,\n                            type: 'text/plain'\n                        }\n                    }\n                };\n                await writeSingle<TestDocType>(\n                    storageInstance,\n                    {\n                        document: writeData\n                    }\n                );\n\n                const attachmentDataAfter = await storageInstance.getAttachmentData('foobar', 'foo');\n                assert.strictEqual(attachmentDataAfter, dataStringBase64);\n\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should return the correct attachment object on all document fetch methods","suites":["RxStorageInstance","attachments"],"updatePoint":{"line":1757,"column":89},"line":1757,"code":"            it('should return the correct attachment object on all document fetch methods', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: Object.assign(\n                        getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                        {\n                            attachments: {}\n                        }\n                    ),\n                    options: {},\n                    multiInstance: false\n                });\n                const statics = config.storage.getStorage().statics;\n\n                const emitted: EventBulk<RxStorageChangeEvent<any>>[] = [];\n                const sub = storageInstance.changeStream().subscribe(x => {\n                    emitted.push(x);\n                });\n\n                const attachmentData = new Array(20).fill('a').join('');\n                const dataBlobBuffer = blobBufferUtil.createBlobBuffer(\n                    attachmentData,\n                    'text/plain'\n                );\n\n                const dataStringBase64 = await blobBufferUtil.toBase64String(dataBlobBuffer);\n                const attachmentHash = await hashAttachmentData(\n                    dataStringBase64,\n                    statics\n                );\n                const dataLength = getAttachmentSize(dataStringBase64);\n\n                const writeData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'one',\n                    _rev: EXAMPLE_REVISION_1,\n                    _deleted: false,\n                    _meta: {\n                        lwt: now()\n                    },\n                    _attachments: {\n                        foo: {\n                            digest: statics.hashKey + '-' + attachmentHash,\n                            length: dataLength,\n                            data: dataStringBase64,\n                            type: 'text/plain'\n                        }\n                    }\n                };\n\n\n                const writeResult = await writeSingle<TestDocType>(\n                    storageInstance,\n                    {\n                        document: writeData\n                    }\n                );\n                await waitUntil(() => flattenEvents(emitted).length === 1);\n\n                assert.strictEqual(writeResult._attachments.foo.type, 'text/plain');\n                assert.strictEqual(writeResult._attachments.foo.digest, statics.hashKey + '-' + attachmentHash);\n\n                /**\n                 * When getting the document from the storage again,\n                 * it should contain the same attachment digest and length\n                 */\n                const docFromStorage = await getSingleDocument(\n                    storageInstance,\n                    'foobar'\n                );\n                assert.strictEqual(\n                    writeResult._attachments.foo.digest,\n                    ensureNotFalsy(docFromStorage)._attachments.foo.digest\n                );\n                assert.strictEqual(\n                    writeResult._attachments.foo.length,\n                    ensureNotFalsy(docFromStorage)._attachments.foo.length\n                );\n\n                // check in query() result\n                const queryResult = await storageInstance.query(\n                    config.storage.getStorage().statics.prepareQuery(\n                        storageInstance.schema,\n                        {\n                            selector: {},\n                            sort: [\n                                { key: 'asc' }\n                            ],\n                            skip: 0\n                        }\n                    )\n                );\n                assert.strictEqual(queryResult.documents[0]._attachments.foo.type, 'text/plain');\n                assert.strictEqual(queryResult.documents[0]._attachments.foo.length, dataLength);\n\n                // check in findDocumentsById() result\n                const byId = await storageInstance.findDocumentsById([writeData.key], false);\n                const byIdDoc = getFromObjectOrThrow(byId, writeData.key);\n                assert.strictEqual(byIdDoc._attachments.foo.type, 'text/plain');\n                assert.strictEqual(byIdDoc._attachments.foo.length, dataLength);\n                assert.ok(!(byIdDoc._attachments.foo as any).data);\n\n                // test the emitted event\n                const firstEventAttachment = flattenEvents(emitted)[0].change.doc._attachments.foo;\n                assert.strictEqual(firstEventAttachment.type, 'text/plain');\n                assert.strictEqual(firstEventAttachment.length, dataLength);\n                assert.ok(!(firstEventAttachment as any).data);\n\n                const changesResult = await storageInstance.getChangedDocumentsSince(1000);\n                const firstChange = changesResult[0].document;\n                if (!firstChange) {\n                    throw new Error('first change missing');\n                }\n                assert.strictEqual(firstChange.key, 'foobar');\n\n                sub.unsubscribe();\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to add multiple attachments, one each write","suites":["RxStorageInstance","attachments"],"updatePoint":{"line":1876,"column":74},"line":1876,"code":"            it('should be able to add multiple attachments, one each write', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: Object.assign(\n                        getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                        {\n                            attachments: {}\n                        }\n                    ),\n                    options: {},\n                    multiInstance: false\n                });\n\n                let previous: RxDocumentData<TestDocType> | undefined;\n\n                const data = blobBufferUtil.createBlobBuffer(randomString(20), 'text/plain');\n                const attachmentHash = await config.storage.getStorage().statics.hash(data);\n                const dataString = await blobBufferUtil.toBase64String(data);\n                const writeData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'one',\n                    _rev: EXAMPLE_REVISION_1,\n                    _deleted: false,\n                    _meta: {\n                        lwt: now()\n                    },\n                    _attachments: {\n                        foo: {\n                            digest: config.storage.getStorage().statics.hashKey + '-' + attachmentHash,\n                            length: blobBufferUtil.size(data),\n                            data: dataString,\n                            type: 'text/plain'\n                        }\n                    }\n                };\n\n                previous = await writeSingle<TestDocType>(\n                    storageInstance,\n                    {\n                        previous,\n                        document: Object.assign({}, writeData, {\n                            _meta: {\n                                lwt: now()\n                            }\n                        })\n                    }\n                );\n\n                if (!previous) {\n                    throw new Error('previous missing');\n                }\n\n                writeData._attachments = flatClone(previous._attachments) as any;\n\n                const data2 = blobBufferUtil.createBlobBuffer(randomString(20), 'text/plain');\n                const attachmentHash2 = await config.storage.getStorage().statics.hash(data2);\n                const dataString2 = await blobBufferUtil.toBase64String(data2);\n                writeData._attachments.bar = {\n                    data: dataString2,\n                    digest: config.storage.getStorage().statics.hashKey + '-' + attachmentHash2,\n                    length: blobBufferUtil.size(data2),\n                    type: 'text/plain'\n                };\n                writeData._rev = EXAMPLE_REVISION_2;\n\n                previous = await writeSingle<TestDocType>(\n                    storageInstance,\n                    {\n                        previous,\n                        document: Object.assign({}, writeData, {\n                            _meta: {\n                                lwt: now()\n                            }\n                        })\n                    }\n                );\n                if (!previous) {\n                    throw new Error('previous missing');\n                }\n\n                assert.strictEqual(Object.keys(previous._attachments).length, 2);\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"_deleted documents must loose all attachments","suites":["RxStorageInstance","attachments"],"updatePoint":{"line":1960,"column":61},"line":1960,"code":"            it('_deleted documents must loose all attachments', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: Object.assign(\n                        getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                        {\n                            attachments: {}\n                        }\n                    ),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const data = blobBufferUtil.createBlobBuffer(randomString(20), 'text/plain');\n                const attachmentHash = await config.storage.getStorage().statics.hash(data);\n                const dataString = await blobBufferUtil.toBase64String(data);\n                const writeData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'one',\n                    _rev: EXAMPLE_REVISION_1,\n                    _deleted: false,\n                    _meta: {\n                        lwt: now()\n                    },\n                    _attachments: {\n                        foo: {\n                            digest: config.storage.getStorage().statics.hashKey + '-' + attachmentHash,\n                            length: blobBufferUtil.size(data),\n                            data: dataString,\n                            type: 'text/plain'\n                        }\n                    }\n                };\n                await storageInstance.bulkWrite([{ document: writeData }]);\n                await storageInstance.getAttachmentData('foobar', 'foo');\n\n                const deleteData = clone(writeData);\n                deleteData._meta.lwt = now();\n                deleteData._deleted = true;\n                deleteData._attachments = {};\n                deleteData._rev = EXAMPLE_REVISION_2;\n\n                await storageInstance.bulkWrite([{ previous: writeData, document: deleteData }]);\n\n\n                let hasThrown = false;\n                try {\n                    await storageInstance.getAttachmentData('foobar', 'foo');\n                } catch (err) {\n                    hasThrown = true;\n                }\n                assert.ok(hasThrown);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should have cleaned up the deleted document","suites":["RxStorageInstance",".cleanup"],"updatePoint":{"line":2018,"column":59},"line":2018,"code":"            it('should have cleaned up the deleted document', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const id = 'foobar';\n                const nonDeletedId = 'foobar2';\n\n                /**\n                 * Insert one that does not get deleted\n                 * and should still be there after the cleanup\n                 */\n                await storageInstance.bulkWrite([{\n                    document: {\n                        key: nonDeletedId,\n                        value: 'barfoo',\n                        _rev: EXAMPLE_REVISION_1,\n                        _deleted: false,\n                        _meta: {\n                            lwt: now()\n                        },\n                        _attachments: {}\n                    }\n                }]);\n\n\n                /**\n                 * Insert\n                 */\n                const insertResult = await storageInstance.bulkWrite([{\n                    document: {\n                        key: id,\n                        value: 'barfoo',\n                        _attachments: {},\n                        _rev: EXAMPLE_REVISION_1,\n                        _meta: {\n                            lwt: now()\n                        },\n                        _deleted: false\n                    }\n                }]);\n                const previous = getFromObjectOrThrow(insertResult.success, id);\n\n                /**\n                 * Delete\n                 */\n                const deleteResult = await storageInstance.bulkWrite([{\n                    previous,\n                    document: {\n                        key: id,\n                        value: 'barfoo',\n                        _rev: EXAMPLE_REVISION_2,\n                        _deleted: true,\n                        _meta: {\n                            lwt: now()\n                        },\n                        _attachments: {}\n                    }\n                }]);\n                getFromObjectOrThrow(deleteResult.success, id);\n\n                /**\n                 * Running .cleanup() with a height minimumDeletedTime\n                 * should not remove the deleted document.\n                 */\n                await storageInstance.cleanup(1000 * 60 * 60);\n\n                const mustBeThereButDeleted = await storageInstance.findDocumentsById(\n                    [id],\n                    true\n                );\n                const doc = mustBeThereButDeleted[id];\n                assert.ok(doc._deleted);\n\n                // clean up the deleted document\n                await storageInstance.cleanup(0);\n\n                if (config.storage.name === 'pouchdb') {\n                    /**\n                     * PouchDB is not able to fully purge a document\n                     * so it makes no sense to check if the deleted document\n                     * was removed on cleanup.\n                     */\n                    await storageInstance.close();\n                    return;\n                }\n\n                const mustNotBeThere = await storageInstance.findDocumentsById(\n                    [id],\n                    true\n                );\n                assert.deepStrictEqual(mustNotBeThere, {});\n\n                /**\n                 * Other docs must still be there\n                 */\n                const nonDeletedDoc = await storageInstance.findDocumentsById(\n                    [nonDeletedId],\n                    true\n                );\n                assert.ok(nonDeletedDoc[nonDeletedId]);\n\n                await storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should at some time return true (when all docs are cleaned up)","suites":["RxStorageInstance",".cleanup"],"updatePoint":{"line":2126,"column":78},"line":2126,"code":"            it('should at some time return true (when all docs are cleaned up)', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n\n                let done = false;\n                while (!done) {\n                    done = await storageInstance.cleanup(0);\n                }\n\n                const id = 'foobar';\n                /**\n                 * Insert\n                 */\n                const insertResult = await storageInstance.bulkWrite([{\n                    document: {\n                        key: id,\n                        value: 'barfoo',\n                        _attachments: {},\n                        _rev: EXAMPLE_REVISION_1,\n                        _meta: {\n                            lwt: now()\n                        },\n                        _deleted: false\n                    }\n                }]);\n                const previous = getFromObjectOrThrow(insertResult.success, id);\n\n                /**\n                 * Delete\n                 */\n                const deleteResult = await storageInstance.bulkWrite([{\n                    previous,\n                    document: {\n                        key: id,\n                        value: 'barfoo',\n                        _rev: EXAMPLE_REVISION_2,\n                        _deleted: true,\n                        _meta: {\n                            lwt: now()\n                        },\n                        _attachments: {}\n                    }\n                }]);\n                getFromObjectOrThrow(deleteResult.success, id);\n\n                done = false;\n                while (!done) {\n                    done = await storageInstance.cleanup(0);\n                }\n\n                await storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should have deleted all data","suites":["RxStorageInstance",".remove()"],"updatePoint":{"line":2186,"column":44},"line":2186,"code":"            it('should have deleted all data', async () => {\n                const databaseName = randomCouchString(12);\n                const collectionName = randomCouchString(12);\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName,\n                    collectionName,\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n                await storageInstance.bulkWrite([\n                    {\n                        document: {\n                            key: 'foobar',\n                            value: 'barfoo',\n                            _deleted: false,\n                            _rev: EXAMPLE_REVISION_1,\n                            _meta: {\n                                lwt: now()\n                            },\n                            _attachments: {}\n                        }\n                    }\n                ]);\n                await storageInstance.remove();\n                const storageInstance2 = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName,\n                    collectionName,\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n                const docs = await storageInstance2.findDocumentsById(['foobar'], false);\n                assert.strictEqual(Object.keys(docs).length, 0);\n\n                storageInstance2.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to write and read documents","suites":["multiInstance","RxStorageInstance"],"updatePoint":{"line":2266,"column":58},"line":2266,"code":"            it('should be able to write and read documents', async () => {\n                const instances = await getMultiInstanceRxStorageInstance();\n\n                const emittedB: EventBulk<RxStorageChangeEvent<RxDocumentData<TestDocType>>>[] = [];\n                instances.b.changeStream().subscribe(ev => emittedB.push(ev));\n                const emittedA: EventBulk<RxStorageChangeEvent<RxDocumentData<TestDocType>>>[] = [];\n                instances.a.changeStream().subscribe(ev => emittedA.push(ev));\n\n                // insert a document on A\n                const writeData = getWriteData();\n                await instances.a.bulkWrite([{ document: writeData }]);\n\n                // find the document on B\n                await waitUntil(async () => {\n                    try {\n                        const foundAgain = await instances.b.findDocumentsById([writeData.key], false);\n                        const foundDoc = getFromObjectOrThrow(foundAgain, writeData.key);\n                        assert.strictEqual(foundDoc.key, writeData.key);\n                        return true;\n                    } catch (err) {\n                        return false;\n                    }\n                }, 10 * 1000, 100);\n\n                // find via query\n                const preparedQuery: PreparedQuery<TestDocType> = config.storage.getStorage().statics.prepareQuery<TestDocType>(\n                    instances.b.schema,\n                    {\n                        selector: {},\n                        limit: 1,\n                        sort: [{ key: 'asc' }],\n                        skip: 0\n                    }\n                );\n\n                const foundViaQuery = await instances.b.query(preparedQuery);\n                assert.strictEqual(foundViaQuery.documents.length, 1);\n                const foundViaQueryDoc = foundViaQuery.documents.find(doc => doc.key === writeData.key);\n                assert.ok(foundViaQueryDoc);\n\n                // close both\n                await closeMultiInstanceRxStorageInstance(instances);\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to finish a query even when the leading instance gets closed","suites":["multiInstance","RxStorageInstance"],"updatePoint":{"line":2315,"column":91},"line":2315,"code":"            it('should be able to finish a query even when the leading instance gets closed', async () => {\n                const instances = await getMultiInstanceRxStorageInstance();\n\n                // insert a document on A\n                await instances.a.bulkWrite([{ document: getWriteData() }]);\n\n                const preparedQuery: PreparedQuery<TestDocType> = config.storage.getStorage().statics.prepareQuery<TestDocType>(\n                    instances.b.schema,\n                    {\n                        selector: {},\n                        limit: 1,\n                        sort: [{ key: 'asc' }],\n                        skip: 0\n                    }\n                );\n\n                const queryResultBefore = await instances.b.query(preparedQuery);\n                assert.ok(queryResultBefore);\n\n                // close A while starting a query on B\n                const queryResultPromise = instances.b.query(preparedQuery);\n                instances.a.close();\n\n                // the query should still resolve.\n                await queryResultPromise;\n\n                await instances.b.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should not mix up documents stored with different schema versions","suites":["multiInstance","RxStorageInstance"],"updatePoint":{"line":2343,"column":81},"line":2343,"code":"            it('should not mix up documents stored with different schema versions', async () => {\n                const storageInstanceV0 = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n                const storageInstanceV1 = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(1, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const writeResponseV0 = await storageInstanceV0.bulkWrite(\n                    [{\n                        document: {\n                            key: 'foobar0',\n                            value: '0',\n                            _deleted: false,\n                            _meta: {\n                                lwt: now()\n                            },\n                            _rev: EXAMPLE_REVISION_1,\n                            _attachments: {}\n                        }\n                    }]\n                );\n                const writeResponseV1 = await storageInstanceV1.bulkWrite(\n                    [{\n                        document: {\n                            key: 'foobar1',\n                            value: '1',\n                            _deleted: false,\n                            _meta: {\n                                lwt: now()\n                            },\n                            _rev: EXAMPLE_REVISION_1,\n                            _attachments: {}\n                        }\n                    }]\n                );\n                assert.deepStrictEqual(writeResponseV0.error, {});\n                assert.deepStrictEqual(writeResponseV1.error, {});\n\n\n                const plainQuery = {\n                    selector: {},\n                    sort: [{ key: 'asc' }]\n                };\n                const preparedQueryV0 = config.storage.getStorage().statics.prepareQuery(\n                    getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    clone(plainQuery)\n                );\n                const resultV0 = await storageInstanceV0.query(preparedQueryV0);\n                assert.strictEqual(resultV0.documents.length, 1);\n                assert.strictEqual(resultV0.documents[0].value, '0');\n\n\n                const preparedQueryV1 = config.storage.getStorage().statics.prepareQuery(\n                    getPseudoSchemaForVersion<TestDocType>(1, 'key'),\n                    clone(plainQuery)\n                );\n                const resultV1 = await storageInstanceV1.query(preparedQueryV1);\n                assert.strictEqual(resultV1.documents.length, 1);\n                assert.strictEqual(resultV1.documents[0].value, '1');\n\n\n                storageInstanceV0.close();\n                storageInstanceV1.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should not mix up documents stored in a different database name","suites":["multiInstance","RxStorageInstance"],"updatePoint":{"line":2416,"column":79},"line":2416,"code":"            it('should not mix up documents stored in a different database name', async () => {\n                const collectionName = 'aaaaa';\n                const schema = getPseudoSchemaForVersion<TestDocType>(0, 'key');\n                const storageInstance1 = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName,\n                    schema,\n                    options: {},\n                    multiInstance: false\n                });\n\n                const writeResponse = await storageInstance1.bulkWrite(\n                    [{\n                        document: {\n                            key: 'foobar0',\n                            value: '0',\n                            _deleted: false,\n                            _meta: {\n                                lwt: now()\n                            },\n                            _rev: EXAMPLE_REVISION_1,\n                            _attachments: {}\n                        }\n                    }]\n                );\n                assert.deepStrictEqual(writeResponse.error, {});\n                await storageInstance1.close();\n\n\n                const storageInstance2 = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseName: randomCouchString(12),\n                    collectionName,\n                    schema,\n                    options: {},\n                    multiInstance: false\n                });\n\n                const allDocsQuery = config.storage.getStorage().statics.prepareQuery(\n                    schema,\n                    {\n                        selector: {},\n                        skip: 0,\n                        sort: [{ key: 'asc' }]\n                    }\n                );\n                const allDocs = await storageInstance2.query(allDocsQuery);\n                assert.deepStrictEqual(allDocs.documents, []);\n\n                storageInstance2.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"documents that are stored on different schema versions, should not interfer","suites":["migration"],"updatePoint":{"line":2469,"column":87},"line":2469,"code":"        it('documents that are stored on different schema versions, should not interfer', async () => {\n            const storage = config.storage.getStorage();\n            const databaseName = randomCouchString(12);\n            const collectionName = randomCouchString(12);\n            const storageInstanceZero = await storage.createStorageInstance<TestDocType>({\n                databaseName,\n                collectionName,\n                schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                options: {},\n                multiInstance: false\n            });\n            const storageInstanceOne = await storage.createStorageInstance<TestDocType>({\n                databaseName,\n                collectionName,\n                schema: getPseudoSchemaForVersion<TestDocType>(1, 'key'),\n                options: {},\n                multiInstance: false\n            });\n\n            const writeResultZero = await storageInstanceZero.bulkWrite([{ document: getWriteData({ value: 'zero' }) }]);\n            assert.deepStrictEqual(writeResultZero.error, {});\n\n            const writeResultOne = await storageInstanceOne.bulkWrite([{ document: getWriteData({ value: 'one' }) }]);\n            assert.deepStrictEqual(writeResultOne.error, {});\n\n            const docsZero = await storageInstanceZero.query(\n                storage.statics.prepareQuery(\n                    storageInstanceZero.schema,\n                    {\n                        selector: {},\n                        sort: [\n                            { key: 'asc' }\n                        ],\n                        skip: 0\n                    }\n                )\n            );\n            assert.strictEqual(docsZero.documents.length, 1);\n            assert.strictEqual(docsZero.documents[0].value, 'zero');\n\n            const docsOne = await storageInstanceOne.query(\n                storage.statics.prepareQuery(\n                    storageInstanceOne.schema,\n                    {\n                        selector: {},\n                        sort: [\n                            { key: 'asc' }\n                        ],\n                        skip: 0\n                    }\n                )\n            );\n            assert.strictEqual(docsOne.documents.length, 1);\n            assert.strictEqual(docsOne.documents[0].value, 'one');\n\n            storageInstanceZero.close();\n            storageInstanceOne.close();\n        });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"create/write/remove","suites":["rx-storage-lokijs.test.js"],"updatePoint":{"line":41,"column":31},"line":41,"code":"        it('create/write/remove', async () => {\n            const collection = await humansCollections.create(\n                10,\n                randomCouchString(10),\n                true,\n                true,\n                getRxStorageLoki()\n            );\n            const doc = await collection.findOne().exec(true);\n            assert.ok(doc);\n\n            const storageInstance: RxStorageInstanceLoki<HumanDocumentType> = collection.storageInstance as any;\n            assert.ok(storageInstance.internals.leaderElector);\n\n            await collection.database.destroy();\n        });","file":"unit/rx-storage-lokijs.test.ts","skipped":false,"dir":"test"},{"name":"should work with 2 instances","suites":["rx-storage-lokijs.test.js"],"updatePoint":{"line":57,"column":40},"line":57,"code":"        it('should work with 2 instances', async () => {\n            const databaseName = randomCouchString(12);\n            const col1 = await humansCollections.createMultiInstance(\n                databaseName,\n                0,\n                null,\n                getRxStorageLoki()\n            );\n            await col1.database.waitForLeadership();\n            const col2 = await humansCollections.createMultiInstance(\n                databaseName,\n                0,\n                null,\n                getRxStorageLoki()\n            );\n            await col1.insert(schemaObjects.human());\n            const doc2 = await col2.findOne().exec(true);\n            assert.ok(doc2);\n            const doc3 = await col1.findOne().exec(true);\n            assert.ok(doc3);\n\n            // the database storage of col2 should not have internal localState\n            assert.ok(col1.database.internalStore.internals.localState);\n            assert.ok(!col2.database.internalStore.internals.localState);\n\n            /**\n             * Only col1 should be leader\n             * and so only col1 should have a localState.\n             */\n            assert.ok(col1.storageInstance.internals.localState);\n            assert.ok(!col2.storageInstance.internals.localState);\n\n            /**\n             * The query on the non-leading instance\n             * must return the correct query results.\n             */\n            await col2.insert(schemaObjects.human());\n            await col1.insert(schemaObjects.human());\n            await waitUntil(async () => {\n                const res = await col2.find().exec();\n                if (res.length > 3) {\n                    throw new Error('got too much docs');\n                }\n                return res.length === 3;\n            });\n\n            col1.database.destroy();\n            col2.database.destroy();\n        });","file":"unit/rx-storage-lokijs.test.ts","skipped":false,"dir":"test"},{"name":"should not have localState if not leader","suites":["rx-storage-lokijs.test.js"],"updatePoint":{"line":106,"column":52},"line":106,"code":"        it('should not have localState if not leader', async () => {\n            const databaseName = randomCouchString(12);\n            const amount = 5;\n            const cols = await Promise.all(\n                new Array(amount).fill(0)\n                    .map(() => humansCollections.createMultiInstance(\n                        databaseName,\n                        0,\n                        null,\n                        getRxStorageLoki()\n                    ))\n            );\n            const getLeaders = () => {\n                return cols.filter(col => {\n                    const storageInstance = col.storageInstance;\n                    const leaderElector: LeaderElector = storageInstance.internals.leaderElector;\n                    return leaderElector.isLeader;\n                });\n            }\n\n            // wait until one is leader\n            await waitUntil(() => {\n                const leaderAmount = getLeaders().length;\n                if (leaderAmount > 1) {\n                    throw new Error('duplicate leaders detected');\n                } else if (leaderAmount === 1) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }, 50 * 1000, 200);\n\n            // add some collections after leader is elected\n            await Promise.all(\n                new Array(amount).fill(0)\n                    .map(async () => {\n                        const col = await humansCollections.createMultiInstance(\n                            databaseName,\n                            0,\n                            null,\n                            getRxStorageLoki()\n                        );\n                        cols.push(col);\n                    })\n            );\n\n            /**\n             * Run some operations on non-leading instance\n             * to emulate real world usage\n             */\n            const firstNonLeading = cols.find(col => !col.database.isLeader());\n            if (!firstNonLeading) {\n                throw new Error('no non leading instance');\n            }\n            await firstNonLeading.insert({\n                passportId: randomCouchString(10),\n                firstName: 'foo',\n                lastName: 'bar',\n                age: 10,\n            });\n            await firstNonLeading.insertLocal(\n                randomCouchString(10),\n                { foo: 'bar' }\n            );\n\n            /**\n             * The non-leading instances should not\n             * have localState set in its storage instances.\n             */\n            cols.forEach(col => {\n                const mustHaveLocal = col.storageInstance.internals.leaderElector.isLeader;\n                assert.strictEqual(mustHaveLocal, !!col.database.internalStore.internals.localState);\n                assert.strictEqual(mustHaveLocal, !!col.storageInstance.internals.localState);\n            });\n\n            cols.forEach(col => col.database.destroy());\n        });","file":"unit/rx-storage-lokijs.test.ts","skipped":false,"dir":"test"},{"name":"listening to queries must work","suites":["rx-storage-lokijs.test.js"],"updatePoint":{"line":183,"column":42},"line":183,"code":"        it('listening to queries must work', async () => {\n            const databaseName = randomCouchString(12);\n            const col1 = await humansCollections.createMultiInstance(\n                databaseName,\n                0,\n                null,\n                getRxStorageLoki()\n            );\n            await col1.database.waitForLeadership();\n            const col2 = await humansCollections.createMultiInstance(\n                databaseName,\n                0,\n                null,\n                getRxStorageLoki()\n            );\n            let lastResult1: any[];\n            let lastResult2: any[];\n\n            const sub1 = col1.find().$.subscribe(res => lastResult1 = res);\n            const sub2 = col1.find().$.subscribe(res => lastResult2 = res);\n\n            await waitUntil(() => !!lastResult1 && !!lastResult2);\n\n            await col2.insert(schemaObjects.human());\n            await waitUntil(() => lastResult1.length === 1 && lastResult2.length === 1);\n\n            sub1.unsubscribe();\n            sub2.unsubscribe();\n            col1.database.destroy();\n            col2.database.destroy();\n        });","file":"unit/rx-storage-lokijs.test.ts","skipped":false,"dir":"test"},{"name":"should use the given adapter","suites":["rx-storage-lokijs.test.js"],"updatePoint":{"line":214,"column":40},"line":214,"code":"        it('should use the given adapter', async () => {\n            if (!config.platform.isNode()) {\n                return;\n            }\n            /**\n             * @link https://github.com/techfort/LokiJS/blob/master/tutorials/Persistence%20Adapters.md#an-example-using-fastest-and-most-scalable-lokifsstructuredadapter-for-nodejs-might-look-like-\n             */\n            const lfsa = require('lokijs/src/loki-fs-structured-adapter.js');\n            const adapter = new lfsa();\n            const storage = getRxStorageLoki({\n                adapter\n            });\n\n            const databaseName = 'lokijs-fs-adapter-test-' + randomCouchString(12);\n            const dbLocation = path.join(\n                __dirname,\n                '../',\n                databaseName\n            );\n\n            const storageInstance = await storage.createStorageInstance<{ key: string }>({\n                databaseName: dbLocation,\n                collectionName: randomCouchString(12),\n                schema: getPseudoSchemaForVersion(0, 'key'),\n                options: {},\n                multiInstance: false\n            });\n\n            const localState = await ensureNotFalsy(storageInstance.internals.localState);\n            assert.ok(localState.databaseState.database.persistenceAdapter === adapter);\n            const writeResponse = await storageInstance.bulkWrite([{\n                document: {\n                    key: 'foobar',\n                    _deleted: false,\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    },\n                    _attachments: {}\n                }\n            }]);\n            assert.deepStrictEqual(writeResponse.error, {});\n\n            /**\n             * It should have written the file to the filesystem\n             * on the next autosave which is called on close()\n             */\n            await storageInstance.close();\n            const exists = fs.existsSync(dbLocation + '.db');\n            assert.ok(exists);\n        });","file":"unit/rx-storage-lokijs.test.ts","skipped":false,"dir":"test"},{"name":"should have called the autosaveCallback","suites":["rx-storage-lokijs.test.js"],"updatePoint":{"line":265,"column":51},"line":265,"code":"        it('should have called the autosaveCallback', async () => {\n            if (!config.platform.isNode()) {\n                return;\n            }\n            const lfsa = require('lokijs/src/loki-fs-structured-adapter.js');\n            const adapter = new lfsa();\n\n            let callbackCalledCount = 0;\n            const storage = getRxStorageLoki({\n                adapter,\n                autosaveCallback: () => callbackCalledCount = callbackCalledCount + 1\n            });\n            const databaseName = 'lokijs-fs-test-autosaveCallback-' + randomCouchString(12);\n            const dbLocation = path.join(\n                __dirname,\n                '../',\n                databaseName\n            );\n            const storageInstance = await storage.createStorageInstance<{ key: string }>({\n                databaseName: dbLocation,\n                collectionName: randomCouchString(12),\n                schema: getPseudoSchemaForVersion(0, 'key'),\n                options: {},\n                multiInstance: false\n            });\n\n            await storageInstance.bulkWrite([{\n                document: {\n                    key: 'foobar',\n                    _deleted: false,\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    },\n                    _attachments: {}\n                }\n            }]);\n\n            await waitUntil(() => callbackCalledCount === 1);\n            await storageInstance.close();\n        });","file":"unit/rx-storage-lokijs.test.ts","skipped":false,"dir":"test"},{"name":"must not use setTimeout internally","suites":["rx-storage-lokijs.test.js","#3666 RxDB with lokijs works bad in Safari and FF when using multiple tabs"],"updatePoint":{"line":320,"column":50},"line":320,"code":"            it('must not use setTimeout internally', async () => {\n                if (\n                    // run only on node to ensure that rewriting the setTimeout works properly.\n                    !config.platform.isNode() ||\n                    // do not run in fast mode because we overwrite global.setTimeout which break parallel tests.\n                    config.isFastMode()\n                ) {\n                    return;\n                }\n\n                const oldSetTimeout = global.setTimeout;\n                (global as any).setTimeout = (fn: Function, time: number) => {\n                    throw new Error('LokiJS must not use setTimeout(' + fn.toString() + ', ' + time + ')');\n                }\n\n                const storage = getRxStorageLoki({\n                    /**\n                     * Do not set a persistence adapter.\n                     * It is allowed to use setTimeout in the persistence\n                     * because it is required to have it to determine when the database is isdle.\n                     * Also the persistence happens in the background so it is not that bad\n                     * if the setTimeout takes longer because the browser throttled the tab.\n                     */\n                });\n\n                const storageInstance = await storage.createStorageInstance({\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    multiInstance: false,\n                    options: {},\n                    schema: fillWithDefaultSettings(schemas.human)\n                });\n\n                const firstDocData = Object.assign(schemaObjects.human(), {\n                    _deleted: false,\n                    _meta: {\n                        lwt: now()\n                    },\n                    _rev: EXAMPLE_REVISION_1,\n                    _attachments: {}\n                });\n                await storageInstance.bulkWrite([\n                    {\n                        document: firstDocData\n                    }\n                ]);\n\n                await storageInstance.bulkWrite([\n                    {\n                        document: Object.assign(schemaObjects.human(), {\n                            _deleted: false,\n                            _attachments: {},\n                            _meta: {\n                                lwt: now()\n                            },\n                            _rev: '1-51b2fae5721cc4d3cf7392f19e6cc118'\n                        })\n                    }\n                ]);\n                const preparedQuery = storage.statics.prepareQuery(\n                    fillWithDefaultSettings(schemas.human),\n                    {\n                        selector: {},\n                        sort: [{\n                            passportId: 'asc'\n                        }],\n                        skip: 0\n                    }\n                );\n                await storageInstance.query(preparedQuery);\n                await storageInstance.findDocumentsById([firstDocData.passportId], false);\n\n                await storageInstance.close();\n\n                // reset the global.setTimeout so the following tests work properly.\n                global.setTimeout = oldSetTimeout;\n            });","file":"unit/rx-storage-lokijs.test.ts","skipped":false,"dir":"test"},{"name":"should move the $lastWriteAt value to _meta.lwt","suites":["rx-storage-lokijs.test.js","#3666 RxDB with lokijs works bad in Safari and FF when using multiple tabs"],"updatePoint":{"line":400,"column":59},"line":400,"code":"        it('should move the $lastWriteAt value to _meta.lwt', async () => {\n            if (!config.platform.isNode()) {\n                return;\n            }\n            const lfsa = require('lokijs/src/loki-fs-structured-adapter.js');\n            const adapter = new lfsa();\n            const storage = getRxStorageLoki({\n                adapter\n            });\n\n            const databaseName = 'lokijs-migration-test-' + randomCouchString(12);\n            const dbLocation = path.join(\n                __dirname,\n                '../',\n                databaseName\n            );\n            const collectionName = randomCouchString(12);\n            const storageInstance = await storage.createStorageInstance<{ key: string }>({\n                databaseName: dbLocation,\n                collectionName,\n                schema: getPseudoSchemaForVersion(0, 'key'),\n                options: {},\n                multiInstance: false\n            });\n\n            const key = 'foobar';\n            const lwtValue = 1000;\n            const localState = ensureNotFalsy(await storageInstance.internals.localState);\n            localState.collection.insert({\n                key,\n                $lastWriteAt: lwtValue,\n                _deleted: false,\n                _attachments: {},\n                _rev: '1-62080c42d471e3d2625e49dcca3b8e3e'\n            });\n            // manually trigger the save queue because we did a write to the internal loki db. \n            await localState.databaseState.saveQueue.addWrite();\n\n            await storageInstance.close();\n\n            const storageInstance2 = await storage.createStorageInstance<{ key: string }>({\n                databaseName: dbLocation,\n                collectionName,\n                schema: getPseudoSchemaForVersion(0, 'key'),\n                options: {},\n                multiInstance: false\n            });\n\n            const docFromStorage = await storageInstance2.findDocumentsById([key], true);\n            const doc = ensureNotFalsy(docFromStorage[key]);\n\n            assert.ok(doc._meta);\n            assert.strictEqual(doc._meta.lwt, lwtValue);\n            assert.ok(!doc.hasOwnProperty('$lastWriteAt'));\n\n            storageInstance2.close();\n        });","file":"unit/rx-storage-lokijs.test.ts","skipped":false,"dir":"test"},{"name":".hashAttachmentData() must return the same hash as pouchdb creates for an attachment","suites":["utils"],"updatePoint":{"line":49,"column":96},"line":49,"code":"        it('.hashAttachmentData() must return the same hash as pouchdb creates for an attachment', async () => {\n            const storage = getRxStoragePouch('memory');\n            const pouch: PouchDBInstance = new PouchDB(\n                randomCouchString(12),\n                {\n                    adapter: 'memory'\n                }\n            ) as any;\n\n            const attachmentData = 'foobaasdfasdfsadfr';\n            const attachmentDataBlobBuffer = blobBufferUtil.createBlobBuffer(\n                attachmentData,\n                'text/plain'\n            );\n            const attachmentDataBBase64 = await blobBufferUtil.toBase64String(attachmentDataBlobBuffer);\n            const attachmentId = 'myText';\n            const docId = 'myDoc';\n\n            const rxdbHash = await hashAttachmentData(\n                attachmentDataBBase64,\n                storage.statics\n            );\n\n            await pouch.put({\n                _id: docId,\n                _attachments: {\n                    [attachmentId]: {\n                        data: attachmentDataBBase64,\n                        type: 'text/plain'\n                    }\n                }\n            });\n            const pouchDoc = await pouch.get(docId);\n            assert.strictEqual(\n                pouchDoc._attachments[attachmentId].digest,\n                storage.statics.hashKey + '-' + rxdbHash\n            );\n\n            const size = getAttachmentSize(attachmentDataBBase64);\n            assert.strictEqual(pouchDoc._attachments[attachmentId].length, size);\n\n            pouch.destroy();\n        });","file":"unit/rx-storage-pouchdb.test.ts","skipped":false,"dir":"test"},{"name":"should not throw when added to pouch","suites":["custom events plugin"],"updatePoint":{"line":94,"column":48},"line":94,"code":"        it('should not throw when added to pouch', () => {\n            addCustomEventsPluginToPouch();\n        });","file":"unit/rx-storage-pouchdb.test.ts","skipped":false,"dir":"test"},{"name":"should emit data on bulkDocs","suites":["custom events plugin"],"updatePoint":{"line":97,"column":40},"line":97,"code":"        it('should emit data on bulkDocs', async () => {\n            const pouch: PouchDBInstance = new PouchDB(\n                randomCouchString(12),\n                {\n                    adapter: 'memory'\n                }\n            ) as any;\n            await pouch.info();\n            (pouch as any).primaryPath = '_id';\n\n            const emitted: any[] = [];\n            const sub = getCustomEventEmitterByPouch(pouch).subject.subscribe(ev => {\n                emitted.push(ev);\n            });\n\n\n            await pouch.bulkDocs([{\n                _id: 'foo',\n                val: 'bar'\n            }], {\n                // add custom data to the options which should be passed through\n                custom: {\n                    foo: 'bar'\n                }\n            } as any);\n\n            await waitUntil(() => flattenEvents(emitted).length === 1);\n\n            const first = flattenEvents(emitted)[0];\n            assert.deepStrictEqual(\n                first.change.operation,\n                'INSERT'\n            );\n\n            pouch.destroy();\n            sub.unsubscribe();\n        });","file":"unit/rx-storage-pouchdb.test.ts","skipped":false,"dir":"test"},{"name":"should respect a custom index","suites":[".query()"],"updatePoint":{"line":136,"column":41},"line":136,"code":"        it('should respect a custom index', async () => {\n            const storage = getRxStoragePouch('memory');\n            let schema = clone(humanSchemaLiteral);\n            schema.indexes.push(['age']);\n            schema.indexes.push(['passportId', 'age']);\n            schema.indexes.push(['age', 'passportId']);\n            schema.indexes.push(['age', 'firstName', 'passportId']);\n            schema.indexes.push(['firstName', 'age', 'passportId']);\n            schema = normalizeRxJsonSchema(schema);\n\n            const storageInstance = await storage.createStorageInstance<HumanDocumentType>({\n                databaseName: randomCouchString(12),\n                collectionName: randomCouchString(12),\n                schema,\n                options: {},\n                multiInstance: false\n            });\n\n            await storageInstance.bulkWrite(\n                new Array(5).fill(0).map(() => {\n                    const data: RxDocumentWriteData<HumanDocumentType> = Object.assign(\n                        schemaObjects.human(),\n                        {\n                            _attachments: {},\n                            _deleted: false,\n                            _rev: EXAMPLE_REVISION_1,\n                            _meta: {\n                                lwt: now()\n                            }\n                        }\n                    );\n                    data.age = 18;\n                    return {\n                        document: data\n                    }\n                })\n            );\n\n            const pouch = storageInstance.internals.pouch;\n            // const hasIndexes = await pouch.getIndexes();\n\n            async function analyzeQuery(query: MangoQuery<HumanDocumentType>) {\n                const preparedQuery = storage.statics.prepareQuery(\n                    schema,\n                    normalizeMangoQuery(schema, query)\n                );\n                const explained = await pouch.explain(preparedQuery);\n                const result = await pouch.find(preparedQuery);\n                return {\n                    query,\n                    preparedQuery,\n                    explained,\n                    result: result.docs\n                };\n            }\n\n            const defaultAnalyzed = await analyzeQuery({\n                selector: {},\n                sort: [\n                    { passportId: 'asc' }\n                ]\n            });\n\n            const customIndexAnalyzed = await analyzeQuery({\n                selector: {},\n                sort: [\n                    { passportId: 'asc' }\n                ],\n                index: ['passportId', 'age']\n            });\n\n            // default should use default index\n            assert.strictEqual(\n                defaultAnalyzed.explained.index.ddoc,\n                null\n            );\n\n            // custom should use the custom index\n            (customIndexAnalyzed.query as any).index.forEach((indexKey: string) => {\n                if (indexKey !== 'passportId') {\n                    assert.ok(ensureNotFalsy(customIndexAnalyzed.explained.index.ddoc).includes(indexKey));\n                }\n            });\n            assert.ok(ensureNotFalsy(customIndexAnalyzed.explained.index.ddoc).includes('_id'));\n\n            // both queries should have returned the same documents\n            assert.deepStrictEqual(\n                defaultAnalyzed.result,\n                customIndexAnalyzed.result\n            );\n\n            storageInstance.close();\n        });","file":"unit/rx-storage-pouchdb.test.ts","skipped":false,"dir":"test"},{"name":"should run and sync","suites":[],"updatePoint":{"line":43,"column":27},"line":43,"code":"    it('should run and sync', async function () {\n        this.timeout(12 * 1000);\n        const port = nexPort();\n        const serverCollection = await humansCollection.create(0, 'human');\n        await serverCollection.database.server({\n            path: '/db',\n            port\n        });\n\n        // check access to path\n        const colUrl = 'http://localhost:' + port + '/db/human';\n        const gotJson = await request(colUrl);\n        const got = JSON.parse(gotJson);\n\n        assert.strictEqual(got.doc_count, 1);\n\n        const clientCollection = await humansCollection.create(0, 'humanclient');\n\n        // sync\n        clientCollection.syncCouchDB({\n            remote: colUrl,\n            direction: {\n                pull: true,\n                push: true\n            }\n        });\n\n        // insert one doc on each side\n        const insertServer = schemaObjects.human();\n        insertServer.firstName = 'server';\n        await serverCollection.insert(insertServer);\n\n        await wait(200);\n\n        const insertClient = schemaObjects.human();\n        insertClient.firstName = 'client';\n        await clientCollection.insert(insertClient);\n\n        await AsyncTestUtil.waitUntil(async () => {\n            const serverDocs = await serverCollection.find().exec();\n            return serverDocs.length === 2;\n        });\n\n        clientCollection.database.destroy();\n        serverCollection.database.destroy();\n    });","file":"unit/server.test.ts","skipped":false,"dir":"test"},{"name":"should run and sync as sub app for express","suites":[],"updatePoint":{"line":89,"column":50},"line":89,"code":"    it('should run and sync as sub app for express', async function () {\n        this.timeout(12 * 1000);\n        const port = nexPort();\n        const serverCollection = await humansCollection.create(0);\n        const { app, server } = await serverCollection.database.server({\n            path: '/',\n            port,\n            cors: false,\n            startServer: false\n        });\n\n        // check if server was returned\n        if (server !== null) {\n            return Promise.reject(\n                new Error('Server was created')\n            );\n        }\n\n        // create new express app and mount sub app\n        const customApp = express();\n        customApp.use('/rxdb', app);\n        const customServer = customApp.listen(port);\n\n        // check access to path\n        const colUrl = 'http://localhost:' + port + '/rxdb/human';\n        const gotJson = await request(colUrl);\n\n        const got = JSON.parse(gotJson);\n        assert.strictEqual(got.doc_count, 1);\n\n        const clientCollection = await humansCollection.create(0);\n\n        // sync\n        clientCollection.syncCouchDB({\n            remote: colUrl\n        });\n\n        // insert one doc on each side\n        await clientCollection.insert(schemaObjects.human());\n        await serverCollection.insert(schemaObjects.human());\n\n        // both collections should have 2 documents\n        await AsyncTestUtil.waitUntil(async () => {\n            const serverDocs = await serverCollection.find().exec();\n            const clientDocs = await clientCollection.find().exec();\n            return (clientDocs.length === 2 && serverDocs.length === 2);\n        });\n\n        clientCollection.database.destroy();\n        serverCollection.database.destroy();\n\n        // custom server has to closed independently\n        customServer.close();\n    });","file":"unit/server.test.ts","skipped":false,"dir":"test"},{"name":"should send cors when defined for missing origin","suites":[],"updatePoint":{"line":143,"column":56},"line":143,"code":"    it('should send cors when defined for missing origin', async function () {\n        this.timeout(12 * 1000);\n        const port = nexPort();\n        const serverCollection = await humansCollection.create(0);\n        await serverCollection.database.server({\n            path: '/db',\n            port,\n            cors: true\n        });\n        const colUrl = 'http://localhost:' + port + '/db/human';\n\n        await new Promise((res, rej) => {\n            requestR({\n                method: 'GET',\n                url: colUrl,\n            }, (error, response) => {\n                if (error) rej(error);\n\n                const responseHeaders: any = Object.keys(response.headers).reduce((acc, header) => ({\n                    ...acc,\n                    [header.toLowerCase()]: response.headers[header]\n                }), {});\n                const originHeaderName = 'Access-Control-Allow-Origin'.toLowerCase();\n                const credentialsHeaderName = 'Access-Control-Allow-Credentials'.toLowerCase();\n\n                const hasOriginHeader = responseHeaders[originHeaderName] === '*';\n                const hasCredentialsHeader = responseHeaders[credentialsHeaderName] === 'true';\n\n                if (!hasOriginHeader || !hasCredentialsHeader) {\n                    rej(\n                        new Error(\n                            'cors headers not set: ' +\n                            JSON.stringify(response.headers, null, 2)\n                        )\n                    );\n                } else res(null);\n            });\n        });\n\n        serverCollection.database.destroy();\n    });","file":"unit/server.test.ts","skipped":false,"dir":"test"},{"name":"should send cors when defined for present origin","suites":[],"updatePoint":{"line":184,"column":56},"line":184,"code":"    it('should send cors when defined for present origin', async function () {\n        this.timeout(12 * 1000);\n        const port = nexPort();\n        const serverCollection = await humansCollection.create(0);\n        await serverCollection.database.server({\n            path: '/db',\n            port,\n            cors: true\n        });\n        const colUrl = 'http://localhost:' + port + '/db/human';\n\n        const origin = 'example.com';\n        await new Promise((res, rej) => {\n            requestR({\n                method: 'GET',\n                url: colUrl,\n                headers: {\n                    'Origin': origin,\n                }\n            }, (error, response) => {\n                if (error) rej(error);\n\n                const responseHeaders: any = Object.keys(response.headers).reduce((acc, header) => ({\n                    ...acc,\n                    [header.toLowerCase()]: response.headers[header]\n                }), {});\n                const originHeaderName = 'Access-Control-Allow-Origin'.toLowerCase();\n                const credentialsHeaderName = 'Access-Control-Allow-Credentials'.toLowerCase();\n\n                const hasOriginHeader = responseHeaders[originHeaderName] === origin;\n                const hasCredentialsHeader = responseHeaders[credentialsHeaderName] === 'true';\n\n                if (!hasOriginHeader || !hasCredentialsHeader) {\n                    rej(\n                        new Error(\n                            'cors headers not set: ' +\n                            JSON.stringify(response.headers, null, 2)\n                        )\n                    );\n                } else res(null);\n            });\n        });\n\n        serverCollection.database.destroy();\n    });","file":"unit/server.test.ts","skipped":false,"dir":"test"},{"name":"should free port when database is destroyed","suites":[],"updatePoint":{"line":229,"column":51},"line":229,"code":"    it('should free port when database is destroyed', async () => {\n        const port = 5000;\n        const col1 = await humansCollection.create(0);\n        await col1.database.server({\n            port\n        });\n        await col1.database.destroy();\n\n        const col2 = await humansCollection.create(0);\n        await col2.database.server({\n            port\n        });\n        col2.database.destroy();\n    });","file":"unit/server.test.ts","skipped":false,"dir":"test"},{"name":"using node-websql with an absolute path should work","suites":[],"updatePoint":{"line":243,"column":59},"line":243,"code":"    it('using node-websql with an absolute path should work', async () => {\n        addPouchPlugin(NodeWebsqlAdapter);\n        const dbName = config.rootPath + 'test_tmp/' + randomCouchString(10);\n        const db1 = await createRxDatabase({\n            name: dbName,\n            storage: getRxStoragePouch('leveldb'),\n            multiInstance: false\n        });\n        const cols1 = await db1.addCollections({\n            human: {\n                schema: schemas.human\n            }\n        });\n        const col1 = cols1.human;\n\n        await col1.insert(schemaObjects.human());\n\n        await db1.server({\n            port: nexPort()\n        });\n\n        await col1.insert(schemaObjects.human());\n\n        db1.destroy();\n    });","file":"unit/server.test.ts","skipped":false,"dir":"test"},{"name":"using full leveldown-module should work","suites":[],"updatePoint":{"line":268,"column":47},"line":268,"code":"    it('using full leveldown-module should work', async () => {\n        addPouchPlugin(NodeWebsqlAdapter);\n        const db1 = await createRxDatabase({\n            name: config.rootPath + 'test_tmp/' + randomCouchString(10),\n            storage: getRxStoragePouch(levelDown),\n            multiInstance: false\n        });\n        const cols1 = await db1.addCollections({\n            human: {\n                schema: schemas.human\n            }\n        });\n        const col1 = cols1.human;\n\n        await col1.insert(schemaObjects.human());\n\n        await db1.server({\n            port: nexPort()\n        });\n\n        await col1.insert(schemaObjects.human());\n\n        await AsyncTestUtil.waitUntil(async () => {\n            const serverDocs = await col1.find().exec();\n            return (serverDocs.length === 2);\n        });\n\n        db1.destroy();\n    });","file":"unit/server.test.ts","skipped":false,"dir":"test"},{"name":"should work on filesystem-storage","suites":[],"updatePoint":{"line":297,"column":41},"line":297,"code":"    it('should work on filesystem-storage', async () => {\n        return; // TODO fix this test\n\n        addPouchPlugin(NodeWebsqlAdapter);\n\n        const port = nexPort();\n\n        const db1Name = config.rootPath + 'test_tmp/' + randomCouchString(10);\n        const db2Name = config.rootPath + 'test_tmp/' + randomCouchString(10);\n        fs.mkdirSync(db1Name, { recursive: true });\n        fs.mkdirSync(db2Name, { recursive: true });\n\n        const db1 = await createRxDatabase({\n            name: db1Name,\n            storage: getRxStoragePouch('leveldb'),\n            multiInstance: false\n        });\n        const cols1 = await db1.addCollections({\n            human: {\n                schema: schemas.human\n            }\n        });\n        const col1 = cols1.human;\n\n        const db2 = await createRxDatabase({\n            name: db2Name,\n            storage: getRxStoragePouch('leveldb'),\n            multiInstance: false\n        });\n        const cols2 = await db2.addCollections({\n            human: {\n                schema: schemas.human\n            }\n        });\n        const col2 = cols2.human;\n\n        await db1.server({\n            port\n        });\n\n        await col2.syncCouchDB({\n            remote: 'http://localhost:' + port + '/db/human'\n        });\n\n        await col1.insert(schemaObjects.human());\n        await col2.insert(schemaObjects.human());\n\n        const findDoc = col1.findOne().exec();\n        assert.ok(findDoc);\n\n        // both collections should have 2 documents\n        await AsyncTestUtil.waitUntil(async () => {\n            const serverDocs = await col1.find().exec();\n            const clientDocs = await col2.find().exec();\n            return (clientDocs.length === 2 && serverDocs.length === 2);\n        });\n\n        db1.destroy();\n        db2.destroy();\n    });","file":"unit/server.test.ts","skipped":false,"dir":"test"},{"name":"should work for collections with later schema versions","suites":[],"updatePoint":{"line":357,"column":62},"line":357,"code":"    it('should work for collections with later schema versions', async function () {\n        this.timeout(12 * 1000);\n        const port = nexPort();\n        const serverCollection = await humansCollection.createMigrationCollection(0);\n        const serverResponse = await serverCollection.database.server({\n            path: '/db',\n            port\n        });\n        assert.ok(serverResponse);\n\n\n        // check access to path\n        const colUrl = 'http://localhost:' + port + '/db/human';\n        const gotJson = await request(colUrl);\n        const got = JSON.parse(gotJson);\n        assert.strictEqual(got.doc_count, 1);\n\n        const clientCollection = await humansCollection.createMigrationCollection(0);\n\n        // sync\n        clientCollection.syncCouchDB({\n            remote: colUrl\n        });\n\n        // insert one doc on each side\n        await clientCollection.insert(schemaObjects.simpleHumanV3());\n        await serverCollection.insert(schemaObjects.simpleHumanV3());\n\n        // both collections should have 2 documents\n        await AsyncTestUtil.waitUntil(async () => {\n            const serverDocs = await serverCollection.find().exec();\n            const clientDocs = await clientCollection.find().exec();\n            return (clientDocs.length === 2 && serverDocs.length === 2);\n        });\n\n        clientCollection.database.destroy();\n        serverCollection.database.destroy();\n    });","file":"unit/server.test.ts","skipped":false,"dir":"test"},{"name":"should work for dynamic collection-names","suites":[],"updatePoint":{"line":395,"column":48},"line":395,"code":"    it('should work for dynamic collection-names', async () => {\n        const port = nexPort();\n        const name = 'foobar';\n        const serverCollection = await humansCollection.create(0, name);\n        await serverCollection.database.server({\n            port\n        });\n        const clientCollection = await humansCollection.create(0, name);\n\n        // sync\n        clientCollection.syncCouchDB({\n            remote: 'http://localhost:' + port + '/db/' + name\n        });\n\n        // insert one doc on each side\n        await clientCollection.insert(schemaObjects.human());\n        await serverCollection.insert(schemaObjects.human());\n\n        // both collections should have 2 documents\n        await AsyncTestUtil.waitUntil(async () => {\n            const serverDocs = await serverCollection.find().exec();\n            const clientDocs = await clientCollection.find().exec();\n            return (clientDocs.length === 2 && serverDocs.length === 2);\n        });\n\n        clientCollection.database.destroy();\n        serverCollection.database.destroy();\n    });","file":"unit/server.test.ts","skipped":false,"dir":"test"},{"name":"should throw if collections that created after server()","suites":[],"updatePoint":{"line":423,"column":63},"line":423,"code":"    it('should throw if collections that created after server()', async () => {\n        const port = nexPort();\n        const db1 = await createRxDatabase({\n            name: randomCouchString(10),\n            storage: getRxStoragePouch('memory'),\n            multiInstance: false\n        });\n        await db1.server({\n            port\n        });\n        await AsyncTestUtil.assertThrows(\n            () => db1.addCollections({\n                human: {\n                    schema: schemas.human\n                }\n            }),\n            'RxError',\n            'after'\n        );\n\n        db1.destroy();\n    });","file":"unit/server.test.ts","skipped":false,"dir":"test"},{"name":"should throw on startup when port is already used","suites":[],"updatePoint":{"line":445,"column":57},"line":445,"code":"    it('should throw on startup when port is already used', async () => {\n        const port = nexPort();\n        const db1 = await createRxDatabase({\n            name: randomCouchString(10),\n            storage: getRxStoragePouch('memory'),\n            multiInstance: false\n        });\n        await db1.server({\n            port\n        });\n\n        // wait until started up\n        await AsyncTestUtil.waitUntil(async () => {\n            try {\n                const gotJson = await request('http://localhost:' + port + '/db/');\n                JSON.parse(gotJson);\n                return true;\n            } catch (err) {\n                return false;\n            }\n        });\n\n        const db2 = await createRxDatabase({\n            name: randomCouchString(10),\n            storage: getRxStoragePouch('memory'),\n            multiInstance: false\n        });\n\n        let hasThrown = false;\n        try {\n            await db2.server({ port });\n        } catch (err) {\n            hasThrown = true;\n        }\n        assert.ok(hasThrown);\n\n        db1.destroy();\n        db2.destroy();\n    });","file":"unit/server.test.ts","skipped":false,"dir":"test"},{"name":"use the path when given","suites":["issues","#1447 server path not working"],"updatePoint":{"line":486,"column":39},"line":486,"code":"            it('use the path when given', async function () {\n                this.timeout(12 * 1000);\n                const port = nexPort();\n                const path = '/db2';\n                const serverCollection = await humansCollection.create(0);\n                await serverCollection.database.server({\n                    path,\n                    port\n                });\n\n                const colUrl = 'http://localhost:' + port + path + '/human';\n                const gotJson = await request(colUrl);\n                const got = JSON.parse(gotJson);\n                assert.strictEqual(got.doc_count, 1);\n\n                serverCollection.database.destroy();\n            });","file":"unit/server.test.ts","skipped":false,"dir":"test"},{"name":"use the path with ending slash","suites":["issues","#1447 server path not working"],"updatePoint":{"line":503,"column":46},"line":503,"code":"            it('use the path with ending slash', async function () {\n                this.timeout(12 * 1000);\n                const port = nexPort();\n                const path = '/db3/';\n                const serverCollection = await humansCollection.create(0);\n                await serverCollection.database.server({\n                    path,\n                    port\n                });\n\n                const colUrl = 'http://localhost:' + port + path + 'human';\n                const gotJson = await request(colUrl);\n                const got = JSON.parse(gotJson);\n                assert.strictEqual(got.doc_count, 1);\n\n                serverCollection.database.destroy();\n            });","file":"unit/server.test.ts","skipped":false,"dir":"test"},{"name":"should be able to use the root /","suites":["issues","#1447 server path not working"],"updatePoint":{"line":520,"column":48},"line":520,"code":"            it('should be able to use the root /', async function () {\n                this.timeout(12 * 1000);\n                const port = nexPort();\n                const path = '/';\n                const serverCollection = await humansCollection.create(0);\n                await serverCollection.database.server({\n                    path,\n                    port\n                });\n\n                const colUrl = 'http://localhost:' + port + path + 'human';\n                const gotJson = await request(colUrl);\n                const got = JSON.parse(gotJson);\n                assert.strictEqual(got.doc_count, 1);\n\n                serverCollection.database.destroy();\n            });","file":"unit/server.test.ts","skipped":false,"dir":"test"},{"name":"having a collection with leveldb and no doc, will not make sync working","suites":["issues","#1447 server path not working"],"updatePoint":{"line":537,"column":87},"line":537,"code":"            it('having a collection with leveldb and no doc, will not make sync working', async function () {\n                const dbName = config.rootPath + 'test_tmp/' + randomCouchString(10);\n                const db = await createRxDatabase({\n                    name: dbName,\n                    storage: getRxStoragePouch('leveldb'),\n                    multiInstance: false\n                });\n                const cols = await db.addCollections({\n                    human: {\n                        schema: schemas.human\n                    }\n                });\n                const col = cols.human;\n\n                const port = nexPort();\n                await db.server({\n                    port\n                });\n                await AsyncTestUtil.waitUntil(async () => {\n                    try {\n                        const gotJson = await request('http://localhost:' + port + '/db/' + col.name);\n                        const got = JSON.parse(gotJson);\n                        return !!got.doc_count;\n                    } catch (err) {\n                        return false;\n                    }\n                });\n                db.destroy();\n            });","file":"unit/server.test.ts","skipped":false,"dir":"test"},{"name":"should create a new document","suites":["RxCollection.newDocument()"],"updatePoint":{"line":21,"column":40},"line":21,"code":"        it('should create a new document', async () => {\n            const c = await humansCollection.create(0);\n            const newDoc = c.newDocument();\n            assert.ok(newDoc);\n            c.database.destroy();\n        });","file":"unit/temporary-document.test.ts","skipped":false,"dir":"test"},{"name":"should have initial data","suites":["RxCollection.newDocument()"],"updatePoint":{"line":27,"column":36},"line":27,"code":"        it('should have initial data', async () => {\n            const c = await humansCollection.create(0);\n            const newDoc = c.newDocument({\n                firstName: 'foobar'\n            });\n            assert.strictEqual(newDoc.firstName, 'foobar');\n            c.database.destroy();\n        });","file":"unit/temporary-document.test.ts","skipped":false,"dir":"test"},{"name":"should not check the schema on changing values","suites":["RxCollection.newDocument()"],"updatePoint":{"line":35,"column":58},"line":35,"code":"        it('should not check the schema on changing values', async () => {\n            const c = await humansCollection.create(0);\n            const newDoc: any = c.newDocument({\n                firstName: 'foobar'\n            });\n            newDoc.lastName = 1337;\n            assert.strictEqual(newDoc.firstName, 'foobar');\n            c.database.destroy();\n        });","file":"unit/temporary-document.test.ts","skipped":false,"dir":"test"},{"name":"should be possible to set the primary","suites":["RxCollection.newDocument()"],"updatePoint":{"line":44,"column":49},"line":44,"code":"        it('should be possible to set the primary', async () => {\n            const c = await humansCollection.createPrimary(0);\n            const newDoc = c.newDocument();\n            newDoc.passportId = 'foobar';\n            assert.strictEqual(newDoc.passportId, 'foobar');\n            c.database.destroy();\n        });","file":"unit/temporary-document.test.ts","skipped":false,"dir":"test"},{"name":"should have default-values","suites":["RxCollection.newDocument()"],"updatePoint":{"line":51,"column":38},"line":51,"code":"        it('should have default-values', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n            });\n            const cols = await db.addCollections({\n                nestedhuman: {\n                    schema: schemas.humanDefault\n                }\n            });\n            const c = cols.nestedhuman;\n            const newDoc = c.newDocument();\n            assert.strictEqual(newDoc.age, 20);\n\n            db.destroy();\n        });","file":"unit/temporary-document.test.ts","skipped":false,"dir":"test"},{"name":"should save the document","suites":[".save()","positive"],"updatePoint":{"line":70,"column":40},"line":70,"code":"            it('should save the document', async () => {\n                const c = await humansCollection.create(0);\n                const newDoc = c.newDocument(schemaObjects.human());\n                await newDoc.save();\n                c.database.destroy();\n            });","file":"unit/temporary-document.test.ts","skipped":false,"dir":"test"},{"name":"should have cached the new doc","suites":[".save()","positive"],"updatePoint":{"line":76,"column":46},"line":76,"code":"            it('should have cached the new doc', async () => {\n                const c = await humansCollection.create(0);\n                const newDoc = c.newDocument(schemaObjects.human());\n                await newDoc.save();\n                const sameDoc = await c.findOne().exec();\n                assert.ok(newDoc === sameDoc);\n                c.database.destroy();\n            });","file":"unit/temporary-document.test.ts","skipped":false,"dir":"test"},{"name":"should be able to save again","suites":[".save()","positive"],"updatePoint":{"line":84,"column":44},"line":84,"code":"            it('should be able to save again', async () => {\n                const c = await humansCollection.create(0);\n                const newDoc = c.newDocument(schemaObjects.human());\n                await newDoc.save();\n\n                await newDoc.atomicPatch({ firstName: 'foobar' });\n                assert.strictEqual('foobar', newDoc.firstName);\n                const allDocs = await c.find().exec();\n                assert.strictEqual(allDocs.length, 1);\n                c.database.destroy();\n            });","file":"unit/temporary-document.test.ts","skipped":false,"dir":"test"},{"name":"throw if schema missmatch","suites":[".save()","negative"],"updatePoint":{"line":97,"column":41},"line":97,"code":"            it('throw if schema missmatch', async () => {\n                const c = await humansCollection.create(0);\n                const docData: any = schemaObjects.human();\n                docData['foo'] = 'bar';\n                const newDoc = c.newDocument(docData);\n                await AsyncTestUtil.assertThrows(\n                    () => newDoc.save(),\n                    'RxError',\n                    'does not match'\n                );\n                c.database.destroy();\n            });","file":"unit/temporary-document.test.ts","skipped":false,"dir":"test"},{"name":"should be able to use ORM-functions","suites":["ORM"],"updatePoint":{"line":112,"column":47},"line":112,"code":"        it('should be able to use ORM-functions', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n            });\n            const cols = await db.addCollections({\n                humans: {\n                    schema: schemas.human,\n                    methods: {\n                        foobar: function () {\n                            return 'test';\n                        }\n                    }\n                }\n            });\n            const c = cols.humans;\n            const newDoc = c.newDocument(schemaObjects.human());\n            assert.strictEqual(newDoc.foobar(), 'test');\n            db.destroy();\n        });","file":"unit/temporary-document.test.ts","skipped":false,"dir":"test"},{"name":"should be emit the correct values","suites":["reactive"],"updatePoint":{"line":134,"column":45},"line":134,"code":"        it('should be emit the correct values', async () => {\n            const c = await humansCollection.create(0);\n            const newDoc: any = c.newDocument(schemaObjects.human());\n            await newDoc.save();\n            const emitted: any[] = [];\n            const sub = newDoc.firstName$.subscribe((val: any) => emitted.push(val));\n\n            await newDoc.atomicPatch({ firstName: 'foobar1' });\n            await newDoc.atomicPatch({ firstName: 'foobar2' });\n\n            await AsyncTestUtil.waitUntil(() => emitted.length === 3);\n            assert.strictEqual('foobar2', emitted.pop());\n            sub.unsubscribe();\n            c.database.destroy();\n        });","file":"unit/temporary-document.test.ts","skipped":false,"dir":"test"},{"name":"reproduce","suites":["ISSUES","#215 setting field to null throws"],"updatePoint":{"line":152,"column":25},"line":152,"code":"            it('reproduce', async () => {\n                const c = await humansCollection.create(0);\n                const newDoc: any = c.newDocument();\n                newDoc.age = null;\n                newDoc.age = 10;\n                assert.strictEqual(newDoc.age, 10);\n                c.database.destroy();\n            });","file":"unit/temporary-document.test.ts","skipped":false,"dir":"test"},{"name":"should work with a string","suites":["util.test.js",".fastUnsecureHash()"],"updatePoint":{"line":29,"column":37},"line":29,"code":"        it('should work with a string', () => {\n            const hash = fastUnsecureHash('foobar');\n            assert.strictEqual(typeof hash, 'number');\n            assert.ok(hash > 0);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should work on object","suites":["util.test.js",".fastUnsecureHash()"],"updatePoint":{"line":34,"column":33},"line":34,"code":"        it('should work on object', () => {\n            const hash = fastUnsecureHash({\n                foo: 'bar'\n            });\n            assert.strictEqual(typeof hash, 'number');\n            assert.ok(hash > 0);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should get the same hash twice","suites":["util.test.js",".fastUnsecureHash()"],"updatePoint":{"line":41,"column":42},"line":41,"code":"        it('should get the same hash twice', () => {\n            const str = randomCouchString(10);\n            const hash = fastUnsecureHash(str);\n            const hash2 = fastUnsecureHash(str);\n            assert.strictEqual(hash, hash2);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should work with a very large string","suites":["util.test.js",".fastUnsecureHash()"],"updatePoint":{"line":47,"column":48},"line":47,"code":"        it('should work with a very large string', () => {\n            const str = randomCouchString(5000);\n            const hash = fastUnsecureHash(str);\n            assert.strictEqual(typeof hash, 'number');\n            assert.ok(hash > 0);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should return the same values for the same document data","suites":["util.test.js",".createRevision()"],"updatePoint":{"line":55,"column":68},"line":55,"code":"        it('should return the same values for the same document data', async () => {\n            const hash1 = createRevision({\n                foo: 'bar',\n                bar: 'foo',\n                _deleted: false,\n                _attachments: {},\n                _meta: {\n                    lwt: 1\n                }\n            } as any);\n            const hash2 = createRevision({\n                foo: 'bar',\n                bar: 'foo',\n                // _rev_tree and _rev must be ignored from hashing\n                _rev: '1-asdf',\n                _rev_tree: 'foobar',\n                _deleted: false,\n                _attachments: {},\n                _meta: {\n                    lwt: 1\n                }\n            });\n            assert.strictEqual(hash1, hash2);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should return the same value as pouchdb","suites":["util.test.js",".createRevision()"],"updatePoint":{"line":79,"column":51},"line":79,"code":"        it('should return the same value as pouchdb', async () => {\n            const docData = {\n                foo: 'bar',\n                bar: 'foo',\n                _rev_tree: '1-asdfasdf'\n            };\n            const ownRev = createRevision(docData as any);\n            const pouchRev = '1-' + pouchCreateRevisison(docData, true);\n            assert.strictEqual(ownRev, pouchRev);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should sort when regex in object","suites":["util.test.js",".sortObject()"],"updatePoint":{"line":91,"column":44},"line":91,"code":"        it('should sort when regex in object', () => {\n            const obj = {\n                color: {\n                    '$regex': /foobar/g\n                }\n            };\n            const sorted = sortObject(obj);\n            assert.ok(sorted.color.$regex instanceof RegExp);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should validate a normal string","suites":["util.test.js",".validateDatabaseName()","positive"],"updatePoint":{"line":103,"column":47},"line":103,"code":"            it('should validate a normal string', () => {\n                validateDatabaseName('foobar');\n            });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should allow _ and $ after the first character","suites":["util.test.js",".validateDatabaseName()","positive"],"updatePoint":{"line":106,"column":62},"line":106,"code":"            it('should allow _ and $ after the first character', () => {\n                validateDatabaseName('foo_bar');\n                validateDatabaseName('foobar_');\n                validateDatabaseName('foobar$');\n            });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should not allow _ and $ as the first character","suites":["util.test.js",".validateDatabaseName()","positive"],"updatePoint":{"line":111,"column":63},"line":111,"code":"            it('should not allow _ and $ as the first character', async () => {\n                await AsyncTestUtil.assertThrows(\n                    () => validateDatabaseName('$foobar'),\n                    'RxError',\n                    'UT2'\n                );\n                await AsyncTestUtil.assertThrows(\n                    () => validateDatabaseName('_foobar'),\n                    'RxError',\n                    'UT2'\n                );\n            });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should validate foldernames","suites":["util.test.js",".validateDatabaseName()","positive"],"updatePoint":{"line":123,"column":43},"line":123,"code":"            it('should validate foldernames', () => {\n                validateDatabaseName('./foobar'); // unix\n                validateDatabaseName('.\\\\foobar'); // windows\n            });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should not validate a spaced string","suites":["util.test.js",".validateDatabaseName()","negative"],"updatePoint":{"line":129,"column":51},"line":129,"code":"            it('should not validate a spaced string', async () => {\n                await AsyncTestUtil.assertThrows(\n                    () => validateDatabaseName('foo bar'),\n                    'RxError',\n                    'UT2'\n                );\n            });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should increase the returned value each time","suites":["util.test.js",".now()"],"updatePoint":{"line":139,"column":56},"line":139,"code":"        it('should increase the returned value each time', () => {\n            const values: number[] = [];\n            new Array(100)\n                .fill(0)\n                .forEach(() => {\n                    values.push(now());\n                });\n\n            let last = 0;\n            values.forEach(value => {\n                assert.ok(value > last);\n                last = value;\n            });\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should be able to run all functions","suites":["util.test.js","blobBufferUtil"],"updatePoint":{"line":155,"column":47},"line":155,"code":"        it('should be able to run all functions', async () => {\n            const text = 'foobar';\n            const blobBuffer = blobBufferUtil.createBlobBuffer(text, 'plain/text');\n            assert.ok(blobBufferUtil.isBlobBuffer(blobBuffer));\n            const asString = await blobBufferUtil.toString(blobBuffer);\n            assert.strictEqual(text, asString);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should be able to run often in circle","suites":["util.test.js","blobBufferUtil"],"updatePoint":{"line":162,"column":49},"line":162,"code":"        it('should be able to run often in circle', async () => {\n            const text = 'foobar';\n            let blobBuffer = blobBufferUtil.createBlobBuffer(text, 'plain/text');\n            let asString = await blobBufferUtil.toString(blobBuffer);\n            blobBuffer = blobBufferUtil.createBlobBuffer(asString, 'plain/text');\n            asString = await blobBufferUtil.toString(blobBuffer);\n            blobBuffer = blobBufferUtil.createBlobBuffer(asString, 'plain/text');\n            asString = await blobBufferUtil.toString(blobBuffer);\n\n            assert.strictEqual(text, asString);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":".size() should return a deterministic value","suites":["util.test.js","blobBufferUtil"],"updatePoint":{"line":173,"column":55},"line":173,"code":"        it('.size() should return a deterministic value', () => {\n            const amount = 30;\n            const str = randomCouchString(amount);\n            const blobBuffer = blobBufferUtil.createBlobBuffer(str, 'plain/text');\n            const size = blobBufferUtil.size(blobBuffer);\n            assert.strictEqual(size, amount);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should do the correct base64 conversion","suites":["util.test.js","blobBufferUtil"],"updatePoint":{"line":180,"column":51},"line":180,"code":"        it('should do the correct base64 conversion', async () => {\n            const plain = 'aaa';\n            const base64 = 'YWFh';\n\n            const blobBuffer = blobBufferUtil.createBlobBuffer(plain, 'plain/text');\n            assert.strictEqual(\n                await blobBufferUtil.toBase64String(blobBuffer),\n                base64\n            );\n            assert.strictEqual(\n                await blobBufferUtil.toString(blobBuffer),\n                plain\n            );\n\n            const blobBufferFromb64 = await blobBufferUtil.createBlobBufferFromBase64(base64, 'plain/text');\n            assert.strictEqual(\n                await blobBufferUtil.toBase64String(blobBufferFromb64),\n                base64\n            );\n            assert.strictEqual(\n                await blobBufferUtil.toString(blobBufferFromb64),\n                plain\n            );\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should work with non latin-1 chars","suites":["util.test.js","blobBufferUtil"],"updatePoint":{"line":204,"column":46},"line":204,"code":"        it('should work with non latin-1 chars', async () => {\n            const plain = 'a';\n            const base64 = 'YcOkw58=';\n            const blobBuffer = blobBufferUtil.createBlobBuffer(plain, 'plain/text');\n            assert.strictEqual(\n                await blobBufferUtil.toBase64String(blobBuffer),\n                base64\n            );\n            assert.strictEqual(\n                await blobBufferUtil.toString(blobBuffer),\n                plain\n            );\n            const blobBufferFromb64 = await blobBufferUtil.createBlobBufferFromBase64(base64, 'plain/text');\n            assert.strictEqual(\n                await blobBufferUtil.toString(blobBufferFromb64),\n                plain\n            );\n            assert.strictEqual(\n                await blobBufferUtil.toBase64String(blobBufferFromb64),\n                base64\n            );\n            assert.strictEqual(\n                await blobBufferUtil.toString(blobBufferFromb64),\n                plain\n            );\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should not allow to mutate the object","suites":["util.test.js",".deepFreezeWhenDevMode()"],"updatePoint":{"line":232,"column":49},"line":232,"code":"        it('should not allow to mutate the object', () => {\n            const obj = {\n                foo: 'bar'\n            };\n            const frozen = deepFreezeWhenDevMode(obj);\n            assert.throws(\n                () => (frozen as any).foo = 'xxx'\n            );\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should freeze the given object and not create a new frozen one","suites":["util.test.js",".deepFreezeWhenDevMode()"],"updatePoint":{"line":241,"column":74},"line":241,"code":"        it('should freeze the given object and not create a new frozen one', () => {\n            const obj = {\n                foo: 'bar'\n            };\n            const frozen = deepFreezeWhenDevMode(obj);\n            assert.ok(obj === frozen);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should sort correctly by lwt","suites":["util.test.js",".sortDocumentsByLastWriteTime()"],"updatePoint":{"line":252,"column":40},"line":252,"code":"        it('should sort correctly by lwt', () => {\n            const docs: RxDocumentData<SortDocType>[] = [\n                {\n                    id: 'a',\n                    _meta: {\n                        lwt: 1000\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1\n                },\n                {\n                    id: 'a',\n                    _meta: {\n                        lwt: 999\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1\n                },\n                {\n                    id: 'a',\n                    _meta: {\n                        lwt: 1001\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1\n                }\n            ];\n            const sorted = sortDocumentsByLastWriteTime(sortDocPrimary, docs);\n            assert.strictEqual(sorted[0]._meta.lwt, 999);\n            assert.strictEqual(sorted[1]._meta.lwt, 1000);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should sort correctly by id","suites":["util.test.js",".sortDocumentsByLastWriteTime()"],"updatePoint":{"line":286,"column":39},"line":286,"code":"        it('should sort correctly by id', () => {\n            const docs: RxDocumentData<SortDocType>[] = [\n                {\n                    id: 'b',\n                    _meta: {\n                        lwt: 1000\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1\n                },\n                {\n                    id: 'a',\n                    _meta: {\n                        lwt: 999\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1\n                },\n                {\n                    id: 'c',\n                    _meta: {\n                        lwt: 1001\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1\n                }\n            ];\n            const sorted = sortDocumentsByLastWriteTime(sortDocPrimary, docs);\n            assert.strictEqual(sorted[0].id, 'a');\n            assert.strictEqual(sorted[1].id, 'b');\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should return the given argument in case of integer","suites":["util.test.js",".ensureInteger()"],"updatePoint":{"line":322,"column":63},"line":322,"code":"        it('should return the given argument in case of integer', () => {\n             assert.doesNotThrow(() => ensureInteger(56));\n             assert.strictEqual(ensureInteger(56),56);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should throw error for  argument","suites":["util.test.js",".ensureInteger()"],"updatePoint":{"line":335,"column":56},"line":335,"code":"            it(`should throw error for ${value} argument`, () => {\n                assert.throws(() => ensureInteger(value));\n            });","file":"unit/util.test.ts","skipped":false,"dir":"test"}]}