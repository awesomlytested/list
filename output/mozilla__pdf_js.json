{"repo":"mozilla/pdf.js","url":"https://github.com/mozilla/pdf.js","branch":"master","configs":[{"package":"pdf.js","lang":"js","dir":"test","framework":"jasmine","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"returns output","suites":["font1","test harness testing"],"line":6,"updatePoint":{"line":6,"column":22,"index":2708},"code":"    it(\"returns output\", async function () {\n      const output = await ttx(font1_1);\n      verifyTtxOutput(output);\n      expect(/<ttFont /.test(output)).toEqual(true);\n      expect(/<\\/ttFont>/.test(output)).toEqual(true);\n    });","file":"font/font_core_spec.js","skipped":false,"dir":"test"},{"name":"table was truncated in the middle of functions","suites":["font_fpgm","Fixes fpgm table"],"line":11,"updatePoint":{"line":11,"column":54,"index":93716},"code":"    it(\"table was truncated in the middle of functions\", async function () {\n      const cMap = await CMapFactory.create({\n        encoding: Name.get(\"Identity-H\")\n      });\n      const font = new Font(\"font\", new Stream(font2324), {\n        loadedName: \"font\",\n        type: \"CIDFontType2\",\n        differences: [],\n        defaultEncoding: [],\n        cMap,\n        toUnicode: new ToUnicodeMap([]),\n        xHeight: 0,\n        capHeight: 0,\n        italicAngle: 0\n      });\n      const output = await ttx(font.data);\n      verifyTtxOutput(output);\n      expect(/(ENDF\\[ \\]|SVTCA\\[0\\])\\s*\\/\\*.*\\*\\/\\s*<\\/assembly>\\s*<\\/fpgm>/.test(output)).toEqual(true);\n    });","file":"font/font_fpgm_spec.js","skipped":false,"dir":"test"},{"name":"has invalid version number","suites":["font_post","OS/2 table removal on bad post table values"],"line":13,"updatePoint":{"line":13,"column":34,"index":39197},"code":"    it(\"has invalid version number\", async function () {\n      const font = new Font(\"font\", new Stream(font2154), {\n        loadedName: \"font\",\n        type: \"TrueType\",\n        differences: [],\n        defaultEncoding: [],\n        toUnicode: new ToUnicodeMap([]),\n        xHeight: 0,\n        capHeight: 0,\n        italicAngle: 0\n      });\n      const output = await ttx(font.data);\n      verifyTtxOutput(output);\n      expect(/<OS_2>\\s*<!--.*\\r?\\n.*-->\\s*<version value=\"3\"\\/>/.test(output)).toEqual(true);\n    });","file":"font/font_os2_spec.js","skipped":false,"dir":"test"},{"name":"has invalid selection attributes presence","suites":["font_post","OS/2 table removal on bad post table values"],"line":28,"updatePoint":{"line":28,"column":49,"index":39729},"code":"    it(\"has invalid selection attributes presence\", async function () {\n      const cMap = await CMapFactory.create({\n        encoding: Name.get(\"Identity-H\")\n      });\n      const font = new Font(\"font\", new Stream(font1282), {\n        loadedName: \"font\",\n        type: \"CIDFontType2\",\n        differences: [],\n        defaultEncoding: [],\n        cMap,\n        toUnicode: new ToUnicodeMap([]),\n        xHeight: 0,\n        capHeight: 0,\n        italicAngle: 0\n      });\n      const output = await ttx(font.data);\n      verifyTtxOutput(output);\n      expect(/<OS_2>\\s*<!--.*\\r?\\n.*-->\\s*<version value=\"3\"\\/>/.test(output)).toEqual(true);\n    });","file":"font/font_os2_spec.js","skipped":false,"dir":"test"},{"name":"has invalid version number","suites":["font_post","post table removal on bad post table values"],"line":15,"updatePoint":{"line":15,"column":34,"index":74463},"code":"    it(\"has invalid version number\", async function () {\n      const cMap = await CMapFactory.create({\n        encoding: Name.get(\"Identity-H\")\n      });\n      const font = new Font(\"font\", new Stream(font2109), {\n        loadedName: \"font\",\n        type: \"CIDFontType2\",\n        differences: [],\n        defaultEncoding: [],\n        cMap,\n        toUnicode: new ToUnicodeMap([]),\n        xHeight: 0,\n        capHeight: 0,\n        italicAngle: 0\n      });\n      const output = await ttx(font.data);\n      verifyTtxOutput(output);\n      expect(/<post>\\s*<formatType value=\"3\\.0\"\\/>/.test(output)).toEqual(true);\n    });","file":"font/font_post_spec.js","skipped":false,"dir":"test"},{"name":"has invalid glyph name indexes","suites":["font_post","post table removal on bad post table values"],"line":34,"updatePoint":{"line":34,"column":38,"index":75086},"code":"    it(\"has invalid glyph name indexes\", async function () {\n      const font = new Font(\"font\", new Stream(font2189), {\n        loadedName: \"font\",\n        type: \"TrueType\",\n        differences: [],\n        defaultEncoding: [],\n        toUnicode: new ToUnicodeMap([]),\n        xHeight: 0,\n        capHeight: 0,\n        italicAngle: 0\n      });\n      const output = await ttx(font.data);\n      verifyTtxOutput(output);\n      expect(/<post>\\s*<formatType value=\"3\\.0\"\\/>/.test(output)).toEqual(true);\n    });","file":"font/font_post_spec.js","skipped":false,"dir":"test"},{"name":"has right amount of glyphs specified","suites":["font_post","post table removal on bad post table values"],"line":49,"updatePoint":{"line":49,"column":44,"index":75600},"code":"    it(\"has right amount of glyphs specified\", async function () {\n      const font = new Font(\"font\", new Stream(font2374), {\n        loadedName: \"font\",\n        type: \"TrueType\",\n        differences: [],\n        defaultEncoding: [],\n        toUnicode: new ToUnicodeMap([]),\n        xHeight: 0,\n        capHeight: 0,\n        italicAngle: 0\n      });\n      const output = await ttx(font.data);\n      verifyTtxOutput(output);\n      expect(/<post>\\s*<formatType value=\"3\\.0\"\\/>/.test(output)).toEqual(true);\n    });","file":"font/font_post_spec.js","skipped":false,"dir":"test"},{"name":"must build structure that maps to text layer","suites":["accessibility","structure tree"],"line":29,"updatePoint":{"line":29,"column":52,"index":981},"code":"    it(\"must build structure that maps to text layer\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForSelector(\".structTree\"); // Check the headings match up.\n\n        const head1 = await page.$eval(\".structTree [role='heading'][aria-level='1'] span\", el => document.getElementById(el.getAttribute(\"aria-owns\")).textContent);\n        expect(head1).withContext(`In ${browserName}`).toEqual(\"Heading 1\");\n        const head2 = await page.$eval(\".structTree [role='heading'][aria-level='2'] span\", el => document.getElementById(el.getAttribute(\"aria-owns\")).textContent);\n        expect(head2).withContext(`In ${browserName}`).toEqual(\"Heading 2\"); // Check the order of the content.\n\n        const texts = await page.$$eval(\".structTree [aria-owns]\", nodes => nodes.map(el => document.getElementById(el.getAttribute(\"aria-owns\")).textContent));\n        expect(texts).withContext(`In ${browserName}`).toEqual([\"Heading 1\", \"This paragraph 1.\", \"Heading 2\", \"This paragraph 2.\"]);\n      }));\n    });","file":"integration/accessibility_spec.js","skipped":false,"dir":"test"},{"name":"must show a popup on mouseover","suites":["Annotation highlight","annotation-highlight.pdf"],"line":31,"updatePoint":{"line":31,"column":38,"index":1038},"code":"    it(\"must show a popup on mouseover\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        let hidden = await page.$eval(\"[data-annotation-id='21R']\", el => el.hidden);\n        expect(hidden).withContext(`In ${browserName}`).toEqual(true);\n        await page.hover(\"[data-annotation-id='19R']\");\n        await page.waitForSelector(\"[data-annotation-id='21R']\", {\n          visible: true,\n          timeout: 0\n        });\n        hidden = await page.$eval(\"[data-annotation-id='21R']\", el => el.hidden);\n        expect(hidden).withContext(`In ${browserName}`).toEqual(false);\n      }));\n    });","file":"integration/annotation_spec.js","skipped":false,"dir":"test"},{"name":"must let checkboxes with the same name behave like radio buttons","suites":["Checkbox annotation","issue12706.pdf"],"line":55,"updatePoint":{"line":55,"column":72,"index":1990},"code":"    it(\"must let checkboxes with the same name behave like radio buttons\", async () => {\n      const selectors = [63, 70, 79].map(n => `[data-annotation-id='${n}R']`);\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        for (const selector of selectors) {\n          await page.click(selector);\n          await page.waitForFunction(`document.querySelector(\"${selector} > :first-child\").checked`);\n\n          for (const otherSelector of selectors) {\n            const checked = await page.$eval(`${otherSelector} > :first-child`, el => el.checked);\n            expect(checked).withContext(`In ${browserName}`).toBe(selector === otherSelector);\n          }\n        }\n      }));\n    });","file":"integration/annotation_spec.js","skipped":false,"dir":"test"},{"name":"must update all the fields with the same value","suites":["Text widget","issue13271.pdf"],"line":80,"updatePoint":{"line":80,"column":54,"index":2955},"code":"    it(\"must update all the fields with the same value\", async () => {\n      const base = \"hello world\";\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.type(getSelector(\"25R\"), base);\n        await page.waitForFunction(`${getQuerySelector(\"24R\")}.value !== \"\"`);\n        await page.waitForFunction(`${getQuerySelector(\"26R\")}.value !== \"\"`);\n        let text = await page.$eval(getSelector(\"24R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(base);\n        text = await page.$eval(getSelector(\"26R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(base);\n      }));\n    });","file":"integration/annotation_spec.js","skipped":false,"dir":"test"},{"name":"must let checkboxes with the same name behave like radio buttons","suites":["Annotation and storage","issue14023.pdf"],"line":103,"updatePoint":{"line":103,"column":72,"index":3941},"code":"    it(\"must let checkboxes with the same name behave like radio buttons\", async () => {\n      const text1 = \"hello world!\";\n      const text2 = \"!dlrow olleh\";\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        // Text field.\n        await page.type(getSelector(\"64R\"), text1); // Checkbox.\n\n        await page.click(\"[data-annotation-id='65R']\"); // Radio.\n\n        await page.click(\"[data-annotation-id='67R']\");\n\n        for (const [pageNumber, textId, checkId, radio1Id, radio2Id] of [[2, \"18R\", \"19R\", \"21R\", \"20R\"], [5, \"23R\", \"24R\", \"22R\", \"25R\"]]) {\n          await page.evaluate(n => {\n            window.document.querySelectorAll(`[data-page-number=\"${n}\"][class=\"page\"]`)[0].scrollIntoView();\n          }, pageNumber); // Need to wait to have a displayed text input.\n\n          await page.waitForSelector(getSelector(textId), {\n            timeout: 0\n          });\n          const text = await page.$eval(getSelector(textId), el => el.value);\n          expect(text).withContext(`In ${browserName}`).toEqual(text1);\n          let checked = await page.$eval(getSelector(checkId), el => el.checked);\n          expect(checked).toEqual(true);\n          checked = await page.$eval(getSelector(radio1Id), el => el.checked);\n          expect(checked).toEqual(false);\n          checked = await page.$eval(getSelector(radio2Id), el => el.checked);\n          expect(checked).toEqual(false);\n        } // Change data on page 5 and check that other pages changed.\n        // Text field.\n\n\n        await page.type(getSelector(\"23R\"), text2); // Checkbox.\n\n        await page.click(\"[data-annotation-id='24R']\"); // Radio.\n\n        await page.click(\"[data-annotation-id='25R']\");\n\n        for (const [pageNumber, textId, checkId, radio1Id, radio2Id] of [[1, \"64R\", \"65R\", \"67R\", \"68R\"], [2, \"18R\", \"19R\", \"21R\", \"20R\"]]) {\n          await page.evaluate(n => {\n            window.document.querySelectorAll(`[data-page-number=\"${n}\"][class=\"page\"]`)[0].scrollIntoView();\n          }, pageNumber); // Need to wait to have a displayed text input.\n\n          await page.waitForSelector(getSelector(textId), {\n            timeout: 0\n          });\n          const text = await page.$eval(getSelector(textId), el => el.value);\n          expect(text).withContext(`In ${browserName}`).toEqual(text2 + text1);\n          let checked = await page.$eval(getSelector(checkId), el => el.checked);\n          expect(checked).toEqual(false);\n          checked = await page.$eval(getSelector(radio1Id), el => el.checked);\n          expect(checked).toEqual(false);\n          checked = await page.$eval(getSelector(radio2Id), el => el.checked);\n          expect(checked).toEqual(false);\n        }\n      }));\n    });","file":"integration/annotation_spec.js","skipped":false,"dir":"test"},{"name":"must reset all fields","suites":["ResetForm action","resetform.pdf"],"line":170,"updatePoint":{"line":170,"column":29,"index":6893},"code":"    it(\"must reset all fields\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        const base = \"hello world\";\n\n        for (let i = 63; i <= 67; i++) {\n          await page.type(getSelector(`${i}R`), base);\n        }\n\n        const selectors = [69, 71, 75].map(n => `[data-annotation-id='${n}R']`);\n\n        for (const selector of selectors) {\n          await page.click(selector);\n        }\n\n        await page.select(getSelector(\"78R\"), \"b\");\n        await page.select(getSelector(\"81R\"), \"f\");\n        await page.click(\"[data-annotation-id='82R']\");\n        await page.waitForFunction(`${getQuerySelector(\"63R\")}.value === \"\"`);\n\n        for (let i = 63; i <= 68; i++) {\n          const text = await page.$eval(getSelector(`${i}R`), el => el.value);\n          expect(text).withContext(`In ${browserName}`).toEqual(\"\");\n        }\n\n        const ids = [69, 71, 72, 73, 74, 75, 76, 77];\n\n        for (const id of ids) {\n          const checked = await page.$eval(getSelector(`${id}R`), el => el.checked);\n          expect(checked).withContext(`In ${browserName}`).toEqual(false);\n        }\n\n        let selected = await page.$eval(`${getSelector(\"78R\")} [value=\"a\"]`, el => el.selected);\n        expect(selected).withContext(`In ${browserName}`).toEqual(true);\n        selected = await page.$eval(`${getSelector(\"81R\")} [value=\"d\"]`, el => el.selected);\n        expect(selected).withContext(`In ${browserName}`).toEqual(true);\n      }));\n    });","file":"integration/annotation_spec.js","skipped":false,"dir":"test"},{"name":"must reset some fields","suites":["ResetForm action","resetform.pdf"],"line":207,"updatePoint":{"line":207,"column":30,"index":8379},"code":"    it(\"must reset some fields\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        const base = \"hello world\";\n\n        for (let i = 63; i <= 68; i++) {\n          await page.type(getSelector(`${i}R`), base);\n        }\n\n        const selectors = [69, 71, 72, 73, 75].map(n => `[data-annotation-id='${n}R']`);\n\n        for (const selector of selectors) {\n          await page.click(selector);\n        }\n\n        await page.select(getSelector(\"78R\"), \"b\");\n        await page.select(getSelector(\"81R\"), \"f\");\n        await page.click(\"[data-annotation-id='84R']\");\n        await page.waitForFunction(`${getQuerySelector(\"63R\")}.value === \"\"`);\n\n        for (let i = 63; i <= 68; i++) {\n          const expected = (i - 3) % 2 === 0 ? \"\" : base;\n          const text = await page.$eval(getSelector(`${i}R`), el => el.value);\n          expect(text).withContext(`In ${browserName}`).toEqual(expected);\n        }\n\n        let ids = [69, 72, 73, 74, 76, 77];\n\n        for (const id of ids) {\n          const checked = await page.$eval(getSelector(`${id}R`), el => el.checked);\n          expect(checked).withContext(`In ${browserName + id}`).toEqual(false);\n        }\n\n        ids = [71, 75];\n\n        for (const id of ids) {\n          const checked = await page.$eval(getSelector(`${id}R`), el => el.checked);\n          expect(checked).withContext(`In ${browserName}`).toEqual(true);\n        }\n\n        let selected = await page.$eval(`${getSelector(\"78R\")} [value=\"a\"]`, el => el.selected);\n        expect(selected).withContext(`In ${browserName}`).toEqual(true);\n        selected = await page.$eval(`${getSelector(\"81R\")} [value=\"f\"]`, el => el.selected);\n        expect(selected).withContext(`In ${browserName}`).toEqual(true);\n      }));\n    });","file":"integration/annotation_spec.js","skipped":false,"dir":"test"},{"name":"must highlight text in the right position","suites":["find bar","highlight all"],"line":34,"updatePoint":{"line":34,"column":49,"index":1182},"code":"    it(\"must highlight text in the right position\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.click(\"#viewFind\");\n        await page.waitForSelector(\"#viewFind\", {\n          hidden: false\n        });\n        await page.type(\"#findInput\", \"a\");\n        await page.click(\"#findHighlightAll\");\n        await page.waitForSelector(\".textLayer .highlight\"); // The PDF has the text \"AB BA\" in a monospace font.\n        // Make sure we have the right number of highlighted divs.\n\n        const highlights = await page.$$(\".textLayer .highlight\");\n        expect(highlights.length).withContext(`In ${browserName}`).toEqual(2);\n        const glyphWidth = 15.98; // From the PDF.\n\n        const pageDiv = await page.$(\".page canvas\");\n        const pageBox = await pageDiv.boundingBox();\n        const firstA = await highlights[0].boundingBox();\n        const secondA = await highlights[1].boundingBox(); // Subtract the page offset from the text bounding boxes;\n\n        firstA.x -= pageBox.x;\n        firstA.y -= pageBox.y;\n        secondA.x -= pageBox.x;\n        secondA.y -= pageBox.y; // They should be on the same line.\n\n        expect(firstA.y).withContext(`In ${browserName}`).toEqual(secondA.y);\n        const fontSize = 26.66; // From the PDF.\n        // The highlighted text has more padding.\n\n        fuzzyMatch(firstA.height, fontSize + 5, browserName);\n        fuzzyMatch(secondA.height, fontSize + 5, browserName);\n        const expectedFirstAX = 28;\n        fuzzyMatch(firstA.x, expectedFirstAX, browserName); // The second 'A' should be 4 glyphs widths from the first.\n\n        fuzzyMatch(secondA.x, expectedFirstAX + glyphWidth * 4, browserName);\n      }));\n    });","file":"integration/find_spec.js","skipped":false,"dir":"test"},{"name":"must search xfa correctly","suites":["find bar","highlight all"],"line":80,"updatePoint":{"line":80,"column":33,"index":3132},"code":"    it(\"must search xfa correctly\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.click(\"#viewFind\");\n        await page.waitForSelector(\"#viewFind\", {\n          hidden: false\n        });\n        await page.type(\"#findInput\", \"city\");\n        await page.waitForSelector(\"#findInput[data-status='']\");\n        await page.waitForSelector(\".xfaLayer .highlight\");\n        const resultElement = await page.waitForSelector(\"#findResultsCount\");\n        const resultText = await resultElement.evaluate(el => el.textContent);\n        expect(resultText).toEqual(\"1 of 7 matches\");\n        const selectedElement = await page.waitForSelector(\".highlight.selected\");\n        const selectedText = await selectedElement.evaluate(el => el.textContent);\n        expect(selectedText).toEqual(\"City\");\n      }));\n    });","file":"integration/find_spec.js","skipped":false,"dir":"test"},{"name":"must write a string in a FreeText editor","suites":["Editor","FreeText"],"line":30,"updatePoint":{"line":30,"column":48,"index":1018},"code":"    it(\"must write a string in a FreeText editor\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.click(\"#editorFreeText\");\n        const rect = await page.$eval(\".annotationEditorLayer\", el => {\n          // With Chrome something is wrong when serializing a DomRect,\n          // hence we extract the values and just return them.\n          const {\n            x,\n            y\n          } = el.getBoundingClientRect();\n          return {\n            x,\n            y\n          };\n        });\n        const data = \"Hello PDF.js World !!\";\n        await page.mouse.click(rect.x + 100, rect.y + 100);\n        await page.type(`${editorPrefix}0 .internal`, data);\n        const editorRect = await page.$eval(`${editorPrefix}0`, el => {\n          const {\n            x,\n            y,\n            width,\n            height\n          } = el.getBoundingClientRect();\n          return {\n            x,\n            y,\n            width,\n            height\n          };\n        }); // Commit.\n\n        await page.mouse.click(editorRect.x, editorRect.y + 2 * editorRect.height);\n        const content = await page.$eval(`${editorPrefix}0`, el => el.innerText.trimEnd());\n        expect(content).withContext(`In ${browserName}`).toEqual(data);\n      }));\n    });","file":"integration/freetext_editor_spec.js","skipped":false,"dir":"test"},{"name":"must copy/paste","suites":["Editor","FreeText"],"line":68,"updatePoint":{"line":68,"column":23,"index":2297},"code":"    it(\"must copy/paste\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        const editorRect = await page.$eval(`${editorPrefix}0`, el => {\n          const {\n            x,\n            y,\n            width,\n            height\n          } = el.getBoundingClientRect();\n          return {\n            x,\n            y,\n            width,\n            height\n          };\n        }); // Select the editor created previously.\n\n        await page.mouse.click(editorRect.x + editorRect.width / 2, editorRect.y + editorRect.height / 2);\n        await page.keyboard.down(\"Control\");\n        await page.keyboard.press(\"c\");\n        await page.keyboard.up(\"Control\");\n        await page.keyboard.down(\"Control\");\n        await page.keyboard.press(\"v\");\n        await page.keyboard.up(\"Control\");\n        const content = await page.$eval(`${editorPrefix}0`, el => el.innerText.trimEnd());\n        let pastedContent = await page.$eval(`${editorPrefix}1`, el => el.innerText.trimEnd());\n        expect(pastedContent).withContext(`In ${browserName}`).toEqual(content);\n        await page.keyboard.down(\"Control\");\n        await page.keyboard.press(\"c\");\n        await page.keyboard.up(\"Control\");\n        await page.keyboard.down(\"Control\");\n        await page.keyboard.press(\"v\");\n        await page.keyboard.up(\"Control\");\n        pastedContent = await page.$eval(`${editorPrefix}2`, el => el.innerText.trimEnd());\n        expect(pastedContent).withContext(`In ${browserName}`).toEqual(content);\n      }));\n    });","file":"integration/freetext_editor_spec.js","skipped":false,"dir":"test"},{"name":"must clear all","suites":["Editor","FreeText"],"line":105,"updatePoint":{"line":105,"column":22,"index":3837},"code":"    it(\"must clear all\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.keyboard.down(\"Control\");\n        await page.keyboard.press(\"a\");\n        await page.keyboard.up(\"Control\");\n        await page.keyboard.down(\"Control\");\n        await page.keyboard.press(\"Backspace\");\n        await page.keyboard.up(\"Control\");\n\n        for (const n of [0, 1, 2]) {\n          const hasEditor = await page.evaluate(sel => {\n            return !!document.querySelector(sel);\n          }, `${editorPrefix}${n}`);\n          expect(hasEditor).withContext(`In ${browserName}`).toEqual(false);\n        }\n      }));\n    });","file":"integration/freetext_editor_spec.js","skipped":false,"dir":"test"},{"name":"must check that a paste has been undone","suites":["Editor","FreeText"],"line":122,"updatePoint":{"line":122,"column":47,"index":4520},"code":"    it(\"must check that a paste has been undone\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        const rect = await page.$eval(\".annotationEditorLayer\", el => {\n          const {\n            x,\n            y\n          } = el.getBoundingClientRect();\n          return {\n            x,\n            y\n          };\n        });\n        const data = \"Hello PDF.js World !!\";\n        await page.mouse.click(rect.x + 100, rect.y + 100);\n        await page.type(`${editorPrefix}3 .internal`, data);\n        const editorRect = await page.$eval(`${editorPrefix}3`, el => {\n          const {\n            x,\n            y,\n            width,\n            height\n          } = el.getBoundingClientRect();\n          return {\n            x,\n            y,\n            width,\n            height\n          };\n        }); // Commit.\n\n        await page.mouse.click(editorRect.x, editorRect.y + 2 * editorRect.height); // And select it again.\n\n        await page.mouse.click(editorRect.x + editorRect.width / 2, editorRect.y + editorRect.height / 2);\n        await page.keyboard.down(\"Control\");\n        await page.keyboard.press(\"c\");\n        await page.keyboard.up(\"Control\");\n        await page.keyboard.down(\"Control\");\n        await page.keyboard.press(\"v\");\n        await page.keyboard.up(\"Control\");\n        let hasEditor = await page.evaluate(sel => {\n          return !!document.querySelector(sel);\n        }, `${editorPrefix}4`);\n        expect(hasEditor).withContext(`In ${browserName}`).toEqual(true);\n        await page.keyboard.down(\"Control\");\n        await page.keyboard.press(\"z\");\n        await page.keyboard.up(\"Control\");\n        hasEditor = await page.evaluate(sel => {\n          return !!document.querySelector(sel);\n        }, `${editorPrefix}4`);\n        expect(hasEditor).withContext(`In ${browserName}`).toEqual(false);\n      }));\n    });","file":"integration/freetext_editor_spec.js","skipped":false,"dir":"test"},{"name":"must check that aria-owns is correct","suites":["Editor","FreeText"],"line":174,"updatePoint":{"line":174,"column":44,"index":6403},"code":"    it(\"must check that aria-owns is correct\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        const [adobeComRect, oldAriaOwns] = await page.$eval(\".textLayer\", el => {\n          for (const span of el.querySelectorAll(`span[role=\"presentation\"]`)) {\n            if (span.innerText.includes(\"adobe.com\")) {\n              span.setAttribute(\"pdfjs\", true);\n              const {\n                x,\n                y,\n                width,\n                height\n              } = span.getBoundingClientRect();\n              return [{\n                x,\n                y,\n                width,\n                height\n              }, span.getAttribute(\"aria-owns\")];\n            }\n          }\n\n          return null;\n        });\n        expect(oldAriaOwns).withContext(`In ${browserName}`).toEqual(null);\n        const data = \"Hello PDF.js World !!\";\n        await page.mouse.click(adobeComRect.x + adobeComRect.width + 10, adobeComRect.y + adobeComRect.height / 2);\n        await page.type(`${editorPrefix}5 .internal`, data);\n        const editorRect = await page.$eval(`${editorPrefix}5`, el => {\n          const {\n            x,\n            y,\n            width,\n            height\n          } = el.getBoundingClientRect();\n          return {\n            x,\n            y,\n            width,\n            height\n          };\n        }); // Commit.\n\n        await page.mouse.click(editorRect.x, editorRect.y + 2 * editorRect.height);\n        const ariaOwns = await page.$eval(\".textLayer\", el => {\n          const span = el.querySelector(`span[pdfjs=\"true\"]`);\n          return span?.getAttribute(\"aria-owns\") || null;\n        });\n        expect(ariaOwns).withContext(`In ${browserName}`).toEqual(`${editorPrefix}5-editor`.slice(1));\n      }));\n    });","file":"integration/freetext_editor_spec.js","skipped":false,"dir":"test"},{"name":"must select/unselect several editors and check copy, paste and delete operations","suites":["Editor","FreeText (multiselection)"],"line":248,"updatePoint":{"line":248,"column":88,"index":8873},"code":"    it(\"must select/unselect several editors and check copy, paste and delete operations\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.click(\"#editorFreeText\");\n        const rect = await page.$eval(\".annotationEditorLayer\", el => {\n          // With Chrome something is wrong when serializing a DomRect,\n          // hence we extract the values and just return them.\n          const {\n            x,\n            y\n          } = el.getBoundingClientRect();\n          return {\n            x,\n            y\n          };\n        });\n        const editorCenters = [];\n\n        for (let i = 0; i < 4; i++) {\n          const data = `FreeText ${i}`;\n          await page.mouse.click(rect.x + (i + 1) * 100, rect.y + (i + 1) * 100);\n          await page.type(`${editorPrefix}${i} .internal`, data);\n          const editorRect = await page.$eval(`${editorPrefix}${i}`, el => {\n            const {\n              x,\n              y,\n              width,\n              height\n            } = el.getBoundingClientRect();\n            return {\n              x,\n              y,\n              width,\n              height\n            };\n          });\n          editorCenters.push({\n            x: editorRect.x + editorRect.width / 2,\n            y: editorRect.y + editorRect.height / 2\n          }); // Commit.\n\n          await page.mouse.click(editorRect.x, editorRect.y + 2 * editorRect.height);\n        }\n\n        await page.keyboard.down(\"Control\");\n        await page.keyboard.press(\"a\");\n        await page.keyboard.up(\"Control\");\n        expect(await getSelected(page)).withContext(`In ${browserName}`).toEqual([0, 1, 2, 3]);\n        await page.keyboard.down(\"Control\");\n        await page.mouse.click(editorCenters[1].x, editorCenters[1].y);\n        expect(await getSelected(page)).withContext(`In ${browserName}`).toEqual([0, 2, 3]);\n        await page.mouse.click(editorCenters[2].x, editorCenters[2].y);\n        expect(await getSelected(page)).withContext(`In ${browserName}`).toEqual([0, 3]);\n        await page.mouse.click(editorCenters[1].x, editorCenters[1].y);\n        await page.keyboard.up(\"Control\");\n        expect(await getSelected(page)).withContext(`In ${browserName}`).toEqual([0, 1, 3]);\n        await page.keyboard.down(\"Control\");\n        await page.keyboard.press(\"c\");\n        await page.keyboard.up(\"Control\");\n        await page.keyboard.down(\"Control\");\n        await page.keyboard.press(\"v\");\n        await page.keyboard.up(\"Control\"); // 0,1,3 are unselected and new pasted editors are selected.\n\n        expect(await getSelected(page)).withContext(`In ${browserName}`).toEqual([4, 5, 6]); // No ctrl here, hence all are unselected and 2 is selected.\n\n        await page.mouse.click(editorCenters[2].x, editorCenters[2].y);\n        expect(await getSelected(page)).withContext(`In ${browserName}`).toEqual([2]);\n        await page.mouse.click(editorCenters[1].x, editorCenters[1].y);\n        expect(await getSelected(page)).withContext(`In ${browserName}`).toEqual([1]);\n        await page.keyboard.down(\"Control\");\n        await page.mouse.click(editorCenters[3].x, editorCenters[3].y);\n        expect(await getSelected(page)).withContext(`In ${browserName}`).toEqual([1, 3]);\n        await page.keyboard.up(\"Control\"); // Delete 1 and 3.\n\n        await page.keyboard.press(\"Backspace\");\n        await page.keyboard.down(\"Control\");\n        await page.keyboard.press(\"a\");\n        await page.keyboard.up(\"Control\");\n        expect(await getSelected(page)).withContext(`In ${browserName}`).toEqual([0, 2, 4, 5, 6]); // Create an empty editor.\n\n        await page.mouse.click(rect.x + 700, rect.y + 100);\n        expect(await getSelected(page)).withContext(`In ${browserName}`).toEqual([7]); // Set the focus to 2 and check that only 2 is selected.\n\n        await page.mouse.click(editorCenters[2].x, editorCenters[2].y);\n        expect(await getSelected(page)).withContext(`In ${browserName}`).toEqual([2]); // Create an empty editor.\n\n        await page.mouse.click(rect.x + 700, rect.y + 100);\n        expect(await getSelected(page)).withContext(`In ${browserName}`).toEqual([8]); // Dismiss it.\n\n        await page.keyboard.press(\"Escape\"); // Select all.\n\n        await page.keyboard.down(\"Control\");\n        await page.keyboard.press(\"a\");\n        await page.keyboard.up(\"Control\"); // Check that all the editors are correctly selected (and the focus\n        // didn't move to the body when the empty editor was removed).\n\n        expect(await getSelected(page)).withContext(`In ${browserName}`).toEqual([0, 2, 4, 5, 6]);\n      }));\n    });","file":"integration/freetext_editor_spec.js","skipped":false,"dir":"test"},{"name":"must check that first text field has focus","suites":["Interaction","in 160F-2019.pdf"],"line":43,"updatePoint":{"line":43,"column":50,"index":1355},"code":"    it(\"must check that first text field has focus\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\"); // The document has an open action in order to give the focus to 401R.\n\n        const id = await page.evaluate(() => {\n          const element = window.document.activeElement;\n          return element.getAttribute(\"data-element-id\");\n        });\n        expect(id).withContext(`In ${browserName}`).toEqual(\"401R\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must show a text field and then make in invisible when content is removed","suites":["Interaction","in 160F-2019.pdf"],"line":54,"updatePoint":{"line":54,"column":81,"index":1945},"code":"    it(\"must show a text field and then make in invisible when content is removed\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        let visibility = await page.$eval(getSelector(\"427R\"), el => getComputedStyle(el).visibility);\n        expect(visibility).withContext(`In ${browserName}`).toEqual(\"hidden\");\n        await page.type(getSelector(\"416R\"), \"3.14159\", {\n          delay: 200\n        });\n        await page.click(getSelector(\"419R\"));\n        await page.waitForFunction(`${getComputedStyleSelector(\"427R\")}.visibility !== \"hidden\"`);\n        visibility = await page.$eval(getSelector(\"427R\"), el => getComputedStyle(el).visibility);\n        expect(visibility).withContext(`In ${browserName}`).toEqual(\"visible\"); // Clear the textfield\n\n        await clearInput(page, getSelector(\"416R\")); // and leave it\n\n        await page.click(getSelector(\"419R\"));\n        await page.waitForFunction(`${getComputedStyleSelector(\"427R\")}.visibility !== \"visible\"`);\n        visibility = await page.$eval(getSelector(\"427R\"), el => getComputedStyle(el).visibility);\n        expect(visibility).withContext(`In ${browserName}`).toEqual(\"hidden\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must format the field with 2 digits and leave field with a click","suites":["Interaction","in 160F-2019.pdf"],"line":74,"updatePoint":{"line":74,"column":72,"index":3137},"code":"    it(\"must format the field with 2 digits and leave field with a click\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.type(getSelector(\"416R\"), \"3.14159\", {\n          delay: 200\n        });\n        await page.click(getSelector(\"419R\"));\n        const valueFnStr = `${getQuerySelector(\"416R\")}.value !== \"3.14159\"`;\n        await page.waitForFunction(valueFnStr);\n        const text = await page.$eval(getSelector(\"416R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"3,14\");\n        const sum = await page.$eval(getSelector(\"427R\"), el => el.value);\n        expect(sum).withContext(`In ${browserName}`).toEqual(\"3,14\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must format the field with 2 digits, leave field with a click and again","suites":["Interaction","in 160F-2019.pdf"],"line":88,"updatePoint":{"line":88,"column":79,"index":3875},"code":"    it(\"must format the field with 2 digits, leave field with a click and again\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.type(getSelector(\"448R\"), \"61803\", {\n          delay: 200\n        });\n        await page.click(getSelector(\"419R\"));\n        const valueOneFnStr = `${getQuerySelector(\"448R\")}.value !== \"61803\"`;\n        await page.waitForFunction(valueOneFnStr);\n        let text = await page.$eval(getSelector(\"448R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"61.803,00\");\n        await page.click(getSelector(\"448R\"));\n        const valueTwoFnStr = `${getQuerySelector(\"448R\")}.value !== \"61.803,00\"`;\n        await page.waitForFunction(valueTwoFnStr);\n        text = await page.$eval(getSelector(\"448R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"61803\"); // Clear the textfield\n\n        await clearInput(page, getSelector(\"448R\"));\n        await page.type(getSelector(\"448R\"), \"1.61803\", {\n          delay: 200\n        });\n        await page.click(getSelector(\"419R\"));\n        const valueThreeFnStr = `${getQuerySelector(\"448R\")}.value !== \"1.61803\"`;\n        await page.waitForFunction(valueThreeFnStr);\n        text = await page.$eval(getSelector(\"448R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"1,62\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must format the field with 2 digits and leave field with a TAB","suites":["Interaction","in 160F-2019.pdf"],"line":115,"updatePoint":{"line":115,"column":70,"index":5279},"code":"    it(\"must format the field with 2 digits and leave field with a TAB\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        const prevSum = await page.$eval(getSelector(\"427R\"), el => el.value);\n        await page.type(getSelector(\"422R\"), \"2.7182818\", {\n          delay: 200\n        });\n        await page.keyboard.press(\"Tab\");\n        await page.waitForFunction(`${getQuerySelector(\"422R\")}.value !== \"2.7182818\"`);\n        const text = await page.$eval(getSelector(\"422R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"2,72\");\n        await page.waitForFunction(`${getQuerySelector(\"427R\")}.value !== \"${prevSum}\"`);\n        const sum = await page.$eval(getSelector(\"427R\"), el => el.value);\n        expect(sum).withContext(`In ${browserName}`).toEqual(\"5,86\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must format the field with 2 digits and hit ESC","suites":["Interaction","in 160F-2019.pdf"],"line":130,"updatePoint":{"line":130,"column":55,"index":6122},"code":"    it(\"must format the field with 2 digits and hit ESC\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        let sum = await page.$eval(getSelector(\"471R\"), el => el.value);\n        expect(sum).withContext(`In ${browserName}`).toEqual(\"4,24\");\n        await page.type(getSelector(\"436R\"), \"0.69314\", {\n          delay: 200\n        });\n        await page.keyboard.press(\"Escape\");\n        const text = await page.$eval(getSelector(\"436R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"0.69314\");\n        await page.waitForFunction(`${getQuerySelector(\"471R\")}.value !== \"${sum}\"`);\n        sum = await page.$eval(getSelector(\"471R\"), el => el.value);\n        expect(sum).withContext(`In ${browserName}`).toEqual(\"3,55\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must format the field with 2 digits on key ENTER","suites":["Interaction","in 160F-2019.pdf"],"line":145,"updatePoint":{"line":145,"column":56,"index":6935},"code":"    it(\"must format the field with 2 digits on key ENTER\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        const prevSum = await page.$eval(getSelector(\"427R\"), el => el.value);\n        await page.type(getSelector(\"419R\"), \"0.577215\", {\n          delay: 200\n        });\n        await page.keyboard.press(\"Enter\");\n        const text = await page.$eval(getSelector(\"419R\"), el => el.value);\n        expect(text).toEqual(\"0.577215\");\n        await page.waitForFunction(`${getQuerySelector(\"427R\")}.value !== \"${prevSum}\"`);\n        const sum = await page.$eval(getSelector(\"427R\"), el => el.value);\n        expect(sum).toEqual(\"6,44\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must reset all","suites":["Interaction","in 160F-2019.pdf"],"line":159,"updatePoint":{"line":159,"column":22,"index":7595},"code":"    it(\"must reset all\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        // click on a radio button\n        await page.click(\"[data-annotation-id='449R']\"); // this field has no actions but it must be cleared on reset\n\n        await page.type(getSelector(\"405R\"), \"employee\", {\n          delay: 200\n        });\n        let checked = await page.$eval(getSelector(\"449R\"), el => el.checked);\n        expect(checked).toEqual(true); // click on reset button\n\n        await page.click(\"[data-annotation-id='402R']\");\n        await Promise.all([\"416R\", \"422R\", \"419R\", \"405R\"].map(id => {\n          const querySelector = getQuerySelector(id);\n          return page.waitForFunction(`${querySelector}.value === \"\"`);\n        }));\n        let text = await page.$eval(getSelector(\"416R\"), el => el.value);\n        expect(text).toEqual(\"\");\n        text = await page.$eval(getSelector(\"422R\"), el => el.value);\n        expect(text).toEqual(\"\");\n        text = await page.$eval(getSelector(\"419R\"), el => el.value);\n        expect(text).toEqual(\"\");\n        text = await page.$eval(getSelector(\"405R\"), el => el.value);\n        expect(text).toEqual(\"\");\n        checked = await page.$eval(getSelector(\"449R\"), el => el.checked);\n        expect(checked).toEqual(false);\n        const visibility = await page.$eval(getSelector(\"427R\"), el => getComputedStyle(el).visibility);\n        expect(visibility).toEqual(\"hidden\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must show values in a text input when clicking on radio buttons","suites":["Interaction","in js-buttons.pdf"],"line":198,"updatePoint":{"line":198,"column":71,"index":9346},"code":"    it(\"must show values in a text input when clicking on radio buttons\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\");\n        const expected = [[\"81R\", \"Group1=Choice1::1\"], [\"82R\", \"Group1=Choice2::2\"], [\"83R\", \"Group1=Choice3::3\"], [\"84R\", \"Group1=Choice4::4\"]];\n\n        for (const [id, expectedText] of expected) {\n          // Clear the textfield\n          await clearInput(page, getSelector(\"80R\"));\n          await page.click(getSelector(id));\n          await page.waitForFunction(`${getQuerySelector(\"80R\")}.value !== \"\"`);\n          const text = await page.$eval(getSelector(\"80R\"), el => el.value);\n          expect(text).withContext(`In ${browserName}`).toEqual(expectedText);\n        }\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must show values in a text input when clicking on checkboxes","suites":["Interaction","in js-buttons.pdf"],"line":213,"updatePoint":{"line":213,"column":68,"index":10188},"code":"    it(\"must show values in a text input when clicking on checkboxes\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        const expected = [[\"85R\", \"Check1=Yes::5\"], [\"87R\", \"Check2=Yes::6\"], [\"88R\", \"Check3=Yes::7\"], [\"89R\", \"Check4=Yes::8\"], [\"85R\", \"Check1=Off::5\"], [\"87R\", \"Check2=Off::6\"], [\"88R\", \"Check3=Off::7\"], [\"89R\", \"Check4=Off::8\"]];\n\n        for (const [id, expectedText] of expected) {\n          // Clear the textfield\n          await clearInput(page, getSelector(\"80R\"));\n          await page.click(getSelector(id));\n          await page.waitForFunction(`${getQuerySelector(\"80R\")}.value !== \"\"`);\n          const text = await page.$eval(getSelector(\"80R\"), el => el.value);\n          expect(text).withContext(`In ${browserName}`).toEqual(expectedText);\n        }\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must show values in a text input when clicking on checkboxes in a group","suites":["Interaction","in js-buttons.pdf"],"line":227,"updatePoint":{"line":227,"column":79,"index":11038},"code":"    it(\"must show values in a text input when clicking on checkboxes in a group\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        const expected = [[\"90R\", \"Check5=Yes1::9\"], [\"91R\", \"Check5=Yes2::10\"], [\"92R\", \"Check5=Yes3::11\"], [\"93R\", \"Check5=Yes4::12\"], [\"93R\", \"Check5=Off::12\"]];\n\n        for (const [id, expectedText] of expected) {\n          // Clear the textfield\n          await clearInput(page, getSelector(\"80R\"));\n          await page.click(getSelector(id));\n          await page.waitForFunction(`${getQuerySelector(\"80R\")}.value !== \"\"`);\n          const text = await page.$eval(getSelector(\"80R\"), el => el.value);\n          expect(text).withContext(`In ${browserName}`).toEqual(expectedText);\n        }\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must show values in a text input when clicking on checkboxes or radio with no actions","suites":["Interaction","in js-buttons.pdf"],"line":241,"updatePoint":{"line":241,"column":93,"index":11832},"code":"    it(\"must show values in a text input when clicking on checkboxes or radio with no actions\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        const expected = [[\"\", \"Off;Off\"], [\"94R\", \"Yes;Off\"], [\"95R\", \"Yes;NoAct2\"], [\"96R\", \"Yes;NoAct3\"], [\"94R\", \"Off;NoAct3\"], [\"95R\", \"Off;NoAct2\"]];\n\n        for (const [id, expectedText] of expected) {\n          // Clear the textfield\n          await clearInput(page, getSelector(\"80R\"));\n\n          if (id) {\n            await page.click(getSelector(id));\n          }\n\n          await page.click(\"[data-annotation-id='97R']\");\n          await page.waitForFunction(`${getQuerySelector(\"80R\")}.value !== \"\"`);\n          const text = await page.$eval(getSelector(\"80R\"), el => el.value);\n          expect(text).withContext(`In ${browserName}`).toEqual(expectedText);\n        }\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must execute WillPrint and DidPrint actions","suites":["Interaction","in doc_actions.pdf for printing"],"line":269,"updatePoint":{"line":269,"column":51,"index":12918},"code":"    it(\"must execute WillPrint and DidPrint actions\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        if (process.platform === \"win32\" && browserName === \"firefox\") {\n          pending(\"Disabled in Firefox on Windows, because of bug 1662471.\");\n        }\n\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\");\n        await clearInput(page, getSelector(\"47R\"));\n        await page.evaluate(_ => {\n          window.document.activeElement.blur();\n        });\n        await page.waitForFunction(`${getQuerySelector(\"47R\")}.value === \"\"`);\n        let text = await actAndWaitForInput(page, getSelector(\"47R\"), async () => {\n          await page.click(\"#print\");\n        });\n        expect(text).withContext(`In ${browserName}`).toEqual(\"WillPrint\");\n        await page.waitForFunction(`${getQuerySelector(\"50R\")}.value !== \"\"`);\n        text = await page.$eval(getSelector(\"50R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"DidPrint\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must execute WillSave and DidSave actions","suites":["Interaction","in doc_actions.pdf for saving"],"line":299,"updatePoint":{"line":299,"column":49,"index":14229},"code":"    it(\"must execute WillSave and DidSave actions\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\");\n\n        try {\n          // Disable download in chrome\n          // (it leads to an error in firefox so the try...)\n          await page._client.send(\"Page.setDownloadBehavior\", {\n            behavior: \"deny\"\n          });\n        } catch (_) {}\n\n        await clearInput(page, getSelector(\"47R\"));\n        await page.evaluate(_ => {\n          window.document.activeElement.blur();\n        });\n        await page.waitForFunction(`${getQuerySelector(\"47R\")}.value === \"\"`);\n        let text = await actAndWaitForInput(page, getSelector(\"47R\"), async () => {\n          await page.click(\"#download\");\n        });\n        expect(text).withContext(`In ${browserName}`).toEqual(\"WillSave\");\n        await page.waitForFunction(`${getQuerySelector(\"50R\")}.value !== \"\"`);\n        text = await page.$eval(getSelector(\"50R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"DidSave\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must execute PageOpen and PageClose actions","suites":["Interaction","in doc_actions.pdf for page actions"],"line":334,"updatePoint":{"line":334,"column":51,"index":15634},"code":"    it(\"must execute PageOpen and PageClose actions\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\");\n        await page.waitForFunction(`${getQuerySelector(\"47R\")}.value !== \"\"`);\n        let text = await page.$eval(getSelector(\"47R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"PageOpen 1\");\n\n        for (let run = 0; run < 5; run++) {\n          for (const ref of [\"18R\", \"19R\", \"20R\", \"21R\", \"47R\", \"50R\"]) {\n            await page.evaluate(selector => {\n              const element = window.document.querySelector(selector);\n\n              if (element) {\n                element.value = \"\";\n              }\n            }, getSelector(ref));\n          }\n\n          for (const [refOpen, refClose, pageNumOpen, pageNumClose] of [[\"18R\", \"50R\", 2, 1], [\"21R\", \"19R\", 3, 2], [\"47R\", \"20R\", 1, 3]]) {\n            text = await actAndWaitForInput(page, getSelector(refOpen), async () => {\n              await page.evaluate(selector => {\n                const element = window.document.querySelector(selector);\n                element.scrollIntoView();\n              }, getSelector(refOpen));\n            }, false);\n            expect(text).withContext(`In ${browserName}`).toEqual(`PageOpen ${pageNumOpen}`);\n            text = await page.$eval(getSelector(refClose), el => el.value);\n            expect(text).withContext(`In ${browserName}`).toEqual(`PageClose ${pageNumClose}`);\n          }\n        }\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must print authors in a text field","suites":["Interaction","in js-authors.pdf"],"line":375,"updatePoint":{"line":375,"column":42,"index":17439},"code":"    it(\"must print authors in a text field\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        const text = await actAndWaitForInput(page, getSelector(\"25R\"), async () => {\n          await page.click(\"[data-annotation-id='26R']\");\n        });\n        expect(text).withContext(`In ${browserName}`).toEqual(\"author1::author2::author3::author4::author5\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must print selected value in a text field","suites":["Interaction","in listbox_actions.pdf"],"line":392,"updatePoint":{"line":392,"column":49,"index":18101},"code":"    it(\"must print selected value in a text field\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        for (const num of [7, 6, 4, 3, 2, 1]) {\n          await clearInput(page, getSelector(\"33R\"));\n          await page.click(`option[value=Export${num}]`);\n          await page.waitForFunction(`${getQuerySelector(\"33R\")}.value !== \"\"`);\n          const text = await page.$eval(getSelector(\"33R\"), el => el.value);\n          expect(text).withContext(`In ${browserName}`).toEqual(`Item${num},Export${num}`);\n        }\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must clear and restore list elements","suites":["Interaction","in listbox_actions.pdf"],"line":403,"updatePoint":{"line":403,"column":44,"index":18668},"code":"    it(\"must clear and restore list elements\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        // Click on ClearItems button.\n        await page.click(\"[data-annotation-id='34R']\");\n        await page.waitForFunction(`${getQuerySelector(\"30R\")}.children.length === 0`); // Click on Restore button.\n\n        await page.click(\"[data-annotation-id='37R']\");\n        await page.waitForFunction(`${getQuerySelector(\"30R\")}.children.length !== 0`);\n\n        for (const num of [7, 6, 4, 3, 2, 1]) {\n          await clearInput(page, getSelector(\"33R\"));\n          await page.click(`option[value=Export${num}]`);\n          await page.waitForFunction(`${getQuerySelector(\"33R\")}.value !== \"\"`);\n          const text = await page.$eval(getSelector(\"33R\"), el => el.value);\n          expect(text).withContext(`In ${browserName}`).toEqual(`Item${num},Export${num}`);\n        }\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must insert new elements","suites":["Interaction","in listbox_actions.pdf"],"line":421,"updatePoint":{"line":421,"column":32,"index":19580},"code":"    it(\"must insert new elements\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        let len = 6;\n\n        for (const num of [1, 3, 5, 6, 431, -1, 0]) {\n          ++len;\n          await clearInput(page, getSelector(\"33R\"));\n          await clearInput(page, getSelector(\"39R\"));\n          await page.type(getSelector(\"39R\"), `${num},Insert${num},Tresni${num}`, {\n            delay: 10\n          }); // Click on AddItem button.\n\n          await page.click(\"[data-annotation-id='38R']\");\n          await page.waitForFunction(`${getQuerySelector(\"30R\")}.children.length === ${len}`); // Click on newly added option.\n\n          await page.select(getSelector(\"30R\"), `Tresni${num}`);\n          await page.waitForFunction(`${getQuerySelector(\"33R\")}.value !== \"\"`);\n          const text = await page.$eval(getSelector(\"33R\"), el => el.value);\n          expect(text).withContext(`In ${browserName}`).toEqual(`Insert${num},Tresni${num}`);\n        }\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must delete some element","suites":["Interaction","in listbox_actions.pdf"],"line":443,"updatePoint":{"line":443,"column":32,"index":20578},"code":"    it(\"must delete some element\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        let len = 6; // Click on Restore button.\n\n        await clearInput(page, getSelector(\"33R\"));\n        await page.click(\"[data-annotation-id='37R']\");\n        await page.waitForFunction(`${getQuerySelector(\"30R\")}.children.length === ${len}`);\n\n        for (const num of [2, 5]) {\n          --len;\n          await clearInput(page, getSelector(\"39R\"));\n          await page.type(getSelector(\"39R\"), `${num}`); // Click on DeleteItem button.\n\n          await page.click(\"[data-annotation-id='36R']\");\n          await page.waitForFunction(`${getQuerySelector(\"30R\")}.children.length === ${len}`);\n        }\n\n        for (const num of [6, 4, 2, 1]) {\n          await clearInput(page, getSelector(\"33R\"));\n          await page.click(`option[value=Export${num}]`);\n          await page.waitForFunction(`${getQuerySelector(\"33R\")}.value !== \"\"`);\n          const text = await page.$eval(getSelector(\"33R\"), el => el.value);\n          expect(text).withContext(`In ${browserName}`).toEqual(`Item${num},Export${num}`);\n        }\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must change colors","suites":["Interaction","in js-colors.pdf"],"line":478,"updatePoint":{"line":478,"column":26,"index":21965},"code":"    it(\"must change colors\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        for (const [name, ref] of [[\"Text1\", \"34R\"], [\"Check1\", \"35R\"], [\"Radio1\", \"37R\"], [\"Choice1\", \"38R\"]]) {\n          await clearInput(page, getSelector(\"34R\"));\n          await page.type(getSelector(\"34R\"), `${name}`, {\n            delay: 10\n          });\n\n          for (const [id, propName, expected] of [[41, \"backgroundColor\", \"rgb(255, 0, 0)\"], [43, \"color\", \"rgb(0, 255, 0)\"], [44, \"border-top-color\", \"rgb(0, 0, 255)\"]]) {\n            const current = await page.$eval(getSelector(ref), (el, _propName) => getComputedStyle(el)[_propName], propName);\n            await page.click(`[data-annotation-id='${id}R']`);\n            await page.waitForFunction(`${getComputedStyleSelector(ref)}[\"${propName}\"] !== \"${current}\"`);\n            const color = await page.$eval(getSelector(ref), (el, _propName) => getComputedStyle(el)[_propName], propName);\n            expect(color).withContext(`In ${browserName}`).toEqual(expected);\n          }\n        }\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must compute sum of fields","suites":["Interaction","in issue13132.pdf"],"line":505,"updatePoint":{"line":505,"column":34,"index":23295},"code":"    it(\"must compute sum of fields\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\");\n        await page.evaluate(selector => {\n          window.document.querySelector(selector).scrollIntoView();\n        }, getSelector(\"171R\"));\n        let sum = 0;\n\n        for (const [id, val] of [[\"138R\", 1], [\"77R\", 2], [\"93R\", 3], [\"151R\", 4], [\"79R\", 5]]) {\n          const prev = await page.$eval(getSelector(\"171R\"), el => el.value);\n          await page.type(getSelector(id), val.toString(), {\n            delay: 100\n          });\n          await page.keyboard.press(\"Tab\");\n          await page.waitForFunction(`${getQuerySelector(\"171R\")}.value !== \"${prev}\"`);\n          sum += val;\n          const total = await page.$eval(getSelector(\"171R\"), el => el.value);\n          expect(total).withContext(`In ${browserName}`).toEqual(`£${sum}`);\n        } // Some unrendered annotations have been updated, so check\n        // that they've the correct value when rendered.\n\n\n        await page.evaluate(() => {\n          window.document.querySelectorAll('[data-page-number=\"4\"][class=\"page\"]')[0].scrollIntoView();\n        });\n        await page.waitForSelector(getSelector(\"299R\"), {\n          timeout: 0\n        });\n        const total = await page.$eval(getSelector(\"299R\"), el => el.value);\n        expect(total).withContext(`In ${browserName}`).toEqual(`£${sum}`);\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must check page index","suites":["Interaction","Check field properties"],"line":546,"updatePoint":{"line":546,"column":29,"index":25026},"code":"    it(\"must check page index\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\");\n        await clearInput(page, getSelector(\"55R\"));\n        await page.type(getSelector(\"55R\"), `\n            ['Text1', 'Text2', 'Text4',\n             'List Box7', 'Group6'].map(x => this.getField(x).page).join(',')\n            `); // Click on execute button to eval the above code.\n\n        await page.click(\"[data-annotation-id='57R']\");\n        await page.waitForFunction(`${getQuerySelector(\"56R\")}.value !== \"\"`);\n        const text = await page.$eval(getSelector(\"56R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"0,0,1,1,1\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must check display","suites":["Interaction","Check field properties"],"line":561,"updatePoint":{"line":561,"column":26,"index":25816},"code":"    it(\"must check display\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        for (const [type, vis] of [[\"hidden\", \"hidden\"], [\"noPrint\", \"visible\"], [\"noView\", \"hidden\"], [\"visible\", \"visible\"]]) {\n          let visibility = await page.$eval(getSelector(\"56R\"), el => getComputedStyle(el).visibility);\n          await clearInput(page, getSelector(\"55R\"));\n          await page.type(getSelector(\"55R\"), `this.getField(\"Text2\").display = display.${type};`);\n          await page.click(\"[data-annotation-id='57R']\");\n          await page.waitForFunction(`${getComputedStyleSelector(\"56R\")}.visibility !== \"${visibility}\"`);\n          visibility = await page.$eval(getSelector(\"56R\"), el => getComputedStyle(el).visibility);\n          expect(visibility).withContext(`In ${browserName}`).toEqual(vis);\n        }\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must update fields with the same name from JS","suites":["Interaction","in issue13269.pdf"],"line":583,"updatePoint":{"line":583,"column":53,"index":26945},"code":"    it(\"must update fields with the same name from JS\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\");\n        await page.type(getSelector(\"27R\"), \"hello\");\n        await page.keyboard.press(\"Enter\");\n        await Promise.all([\"24R\", \"25R\", \"26R\"].map(async id => page.waitForFunction(`${getQuerySelector(id)}.value !== \"\"`)));\n        const expected = \"hello world\";\n\n        for (const id of [\"24R\", \"25R\", \"26R\"]) {\n          const text = await page.$eval(getSelector(id), el => el.value);\n          expect(text).withContext(`In ${browserName}`).toEqual(expected);\n        }\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must print securityHandler value in a text field","suites":["Interaction","in secHandler.pdf"],"line":606,"updatePoint":{"line":606,"column":56,"index":27905},"code":"    it(\"must print securityHandler value in a text field\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        const text = await actAndWaitForInput(page, getSelector(\"25R\"), async () => {\n          await page.click(\"[data-annotation-id='26R']\");\n        });\n        expect(text).withContext(`In ${browserName}`).toEqual(\"Standard\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must check input for US zip format","suites":["Interaction","in issue14307.pdf (1)"],"line":628,"updatePoint":{"line":628,"column":42,"index":28657},"code":"    it(\"must check input for US zip format\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\");\n        await clearInput(page, getSelector(\"29R\"));\n        await clearInput(page, getSelector(\"30R\"));\n        await page.focus(getSelector(\"29R\"));\n        await page.type(getSelector(\"29R\"), \"12A\", {\n          delay: 100\n        });\n        await page.waitForFunction(`${getQuerySelector(\"29R\")}.value !== \"12A\"`);\n        let text = await page.$eval(getSelector(`29R`), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"12\");\n        await page.focus(getSelector(\"29R\"));\n        await page.type(getSelector(\"29R\"), \"34\", {\n          delay: 100\n        });\n        await page.click(\"[data-annotation-id='30R']\");\n        await page.waitForFunction(`${getQuerySelector(\"29R\")}.value !== \"1234\"`);\n        text = await page.$eval(getSelector(`29R`), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"\");\n        await page.focus(getSelector(\"29R\"));\n        await page.type(getSelector(\"29R\"), \"12345\", {\n          delay: 100\n        });\n        await page.click(\"[data-annotation-id='30R']\");\n        text = await page.$eval(getSelector(`29R`), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"12345\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must check input for US phone number (long) format","suites":["Interaction","in issue14307.pdf (2)"],"line":671,"updatePoint":{"line":671,"column":58,"index":30482},"code":"    it(\"must check input for US phone number (long) format\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\");\n        await clearInput(page, getSelector(\"29R\"));\n        await clearInput(page, getSelector(\"30R\"));\n        await page.focus(getSelector(\"30R\"));\n        await page.type(getSelector(\"30R\"), \"(123) 456A\", {\n          delay: 100\n        });\n        await page.waitForFunction(`${getQuerySelector(\"30R\")}.value !== \"(123) 456A\"`);\n        let text = await page.$eval(getSelector(`30R`), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"(123) 456\");\n        await page.focus(getSelector(\"30R\"));\n        await page.type(getSelector(\"30R\"), \"-789\", {\n          delay: 100\n        });\n        await page.click(\"[data-annotation-id='29R']\");\n        await page.waitForFunction(`${getQuerySelector(\"30R\")}.value !== \"(123) 456-789\"`);\n        text = await page.$eval(getSelector(`30R`), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"\");\n        await page.focus(getSelector(\"30R\"));\n        await page.type(getSelector(\"30R\"), \"(123) 456-7890\", {\n          delay: 100\n        });\n        await page.click(\"[data-annotation-id='29R']\");\n        text = await page.$eval(getSelector(\"30R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"(123) 456-7890\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must check input for US phone number (short) format","suites":["Interaction","in issue14307.pdf (3)"],"line":714,"updatePoint":{"line":714,"column":59,"index":32358},"code":"    it(\"must check input for US phone number (short) format\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\");\n        await clearInput(page, getSelector(\"29R\"));\n        await clearInput(page, getSelector(\"30R\"));\n        await page.focus(getSelector(\"30R\"));\n        await page.type(getSelector(\"30R\"), \"123A\", {\n          delay: 100\n        });\n        await page.waitForFunction(`${getQuerySelector(\"30R\")}.value !== \"123A\"`);\n        let text = await page.$eval(getSelector(`30R`), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"123\");\n        await page.focus(getSelector(\"30R\"));\n        await page.type(getSelector(\"30R\"), \"-456\", {\n          delay: 100\n        });\n        await page.click(\"[data-annotation-id='29R']\");\n        await page.waitForFunction(`${getQuerySelector(\"30R\")}.value !== \"123-456\"`);\n        text = await page.$eval(getSelector(\"30R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"\");\n        await page.focus(getSelector(\"30R\"));\n        await page.type(getSelector(\"30R\"), \"123-4567\", {\n          delay: 100\n        });\n        await page.click(\"[data-annotation-id='29R']\");\n        text = await page.$eval(getSelector(\"30R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"123-4567\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must convert input to uppercase","suites":["Interaction","in issue14862.pdf"],"line":757,"updatePoint":{"line":757,"column":39,"index":34174},"code":"    it(\"must convert input to uppercase\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\");\n        await page.type(getSelector(\"27R\"), \"Hello\", {\n          delay: 100\n        });\n        await page.waitForFunction(`${getQuerySelector(\"27R\")}.value !== \"Hello\"`);\n        let text = await page.$eval(getSelector(\"27R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"HELLO\");\n        await page.type(getSelector(\"27R\"), \" world\", {\n          delay: 100\n        });\n        await page.waitForFunction(`${getQuerySelector(\"27R\")}.value !== \"HELLO world\"`);\n        text = await page.$eval(getSelector(\"27R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"HELLO WORLD\");\n        await page.keyboard.press(\"Backspace\");\n        await page.keyboard.press(\"Backspace\");\n        await page.waitForFunction(`${getQuerySelector(\"27R\")}.value !== \"HELLO WORLD\"`);\n        text = await page.$eval(getSelector(\"27R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"HELLO WOR\");\n        await page.type(getSelector(\"27R\"), \"12.dL\", {\n          delay: 100\n        });\n        await page.waitForFunction(`${getQuerySelector(\"27R\")}.value !== \"HELLO WOR\"`);\n        text = await page.$eval(getSelector(\"27R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"HELLO WORDL\");\n        await page.type(getSelector(\"27R\"), \" \", {\n          delay: 100\n        });\n        await page.keyboard.down(\"Control\");\n        await page.keyboard.press(\"Backspace\");\n        await page.keyboard.up(\"Control\");\n        await page.waitForFunction(`${getQuerySelector(\"27R\")}.value !== \"HELLO WORDL \"`);\n        text = await page.$eval(getSelector(\"27R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"HELLO \");\n        await page.$eval(getSelector(\"27R\"), el => {\n          // Select LL\n          el.selectionStart = 2;\n          el.selectionEnd = 4;\n        });\n        await page.keyboard.press(\"a\");\n        text = await page.$eval(getSelector(\"27R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"HEAO \");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must check that an infinite loop is not triggered","suites":["Interaction","in issue14862.pdf"],"line":802,"updatePoint":{"line":802,"column":57,"index":36508},"code":"    it(\"must check that an infinite loop is not triggered\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\");\n        await page.type(getSelector(\"28R\"), \"Hello\", {\n          delay: 100\n        });\n        await page.waitForFunction(`${getQuerySelector(\"28R\")}.value !== \"123\"`);\n        let text = await page.$eval(getSelector(\"28R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"Hello123\"); // The action will trigger a calculateNow which itself\n        // will trigger a resetForm (inducing a calculateNow) and a\n        // calculateNow.\n\n        await page.click(\"[data-annotation-id='31R']\");\n        await page.waitForFunction(`${getQuerySelector(\"28R\")}.value !== \"Hello123\"`); // Without preventing against infinite loop the field is empty.\n\n        text = await page.$eval(getSelector(\"28R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"123\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must check that field value is correctly updated","suites":["Interaction","in issue14705.pdf"],"line":835,"updatePoint":{"line":835,"column":56,"index":37944},"code":"    it(\"must check that field value is correctly updated\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\");\n        await page.type(getSelector(\"29R\"), \"Hello World\", {\n          delay: 100\n        });\n        await page.click(getSelector(\"27R\"));\n        await page.waitForFunction(`${getQuerySelector(\"29R\")}.value !== \"Hello World\"`);\n        let text = await page.$eval(getSelector(\"29R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"checked\");\n        await page.click(getSelector(\"27R\"));\n        await page.waitForFunction(`${getQuerySelector(\"29R\")}.value !== \"checked\"`);\n        text = await page.$eval(getSelector(\"29R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"unchecked\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must check that field value is correctly formatted","suites":["Interaction","in bug1766987.pdf"],"line":860,"updatePoint":{"line":860,"column":58,"index":39084},"code":"    it(\"must check that field value is correctly formatted\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\");\n        let text = await page.$eval(getSelector(\"75R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"150.32 €\");\n        text = await page.$eval(getSelector(\"82R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"12.74 Kwh\");\n        text = await page.$eval(getSelector(\"91R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"352.19 Kwh\");\n        text = await page.$eval(getSelector(\"101R\"), el => el.value);\n        expect(text).withContext(`In ${browserName}`).toEqual(\"20.57 €\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must check that a button and text field with a border are hidden","suites":["Interaction","in issue15053.pdf"],"line":882,"updatePoint":{"line":882,"column":72,"index":40167},"code":"    it(\"must check that a button and text field with a border are hidden\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\");\n        let visibility = await page.$eval(\"[data-annotation-id='35R']\", el => getComputedStyle(el).visibility);\n        expect(visibility).withContext(`In ${browserName}`).toEqual(\"visible\");\n        visibility = await page.$eval(\"[data-annotation-id='51R']\", el => getComputedStyle(el).visibility);\n        expect(visibility).withContext(`In ${browserName}`).toEqual(\"visible\");\n        await page.click(getSelector(\"44R\"));\n        visibility = await page.$eval(\"[data-annotation-id='35R']\", el => getComputedStyle(el).visibility);\n        expect(visibility).withContext(`In ${browserName}`).toEqual(\"hidden\");\n        visibility = await page.$eval(\"[data-annotation-id='51R']\", el => getComputedStyle(el).visibility);\n        expect(visibility).withContext(`In ${browserName}`).toEqual(\"hidden\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must check that data-main-rotation is correct","suites":["Interaction","in bug1675139.pdf"],"line":905,"updatePoint":{"line":905,"column":53,"index":41448},"code":"    it(\"must check that data-main-rotation is correct\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\");\n        let base = 0;\n\n        while (base !== 360) {\n          for (const [ref, angle] of [[47, 0], [42, 90], [45, 180], [46, 270]]) {\n            const rotation = await page.$eval(`[data-annotation-id='${ref}R']`, el => parseInt(el.getAttribute(\"data-main-rotation\") || 0));\n            expect(rotation).withContext(`In ${browserName}`).toEqual((360 + (360 - (base + angle)) % 360) % 360);\n          }\n\n          base += 90;\n          await page.click(getSelector(\"48R\"));\n        }\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"must check that a values is correctly updated on a field and its siblings","suites":["Interaction","in issue15092.pdf"],"line":930,"updatePoint":{"line":930,"column":81,"index":42442},"code":"    it(\"must check that a values is correctly updated on a field and its siblings\", async () => {\n      await Promise.all(pages.map(async ([browserName, page]) => {\n        await page.waitForFunction(\"window.PDFViewerApplication.scriptingReady === true\");\n        await clearInput(page, getSelector(\"39R\"));\n        await page.type(getSelector(\"39R\"), \"123\", {\n          delay: 10\n        });\n        const prevTotal = await page.$eval(getSelector(\"43R\"), el => el.value);\n        await clearInput(page, getSelector(\"42R\"));\n        await page.type(getSelector(\"42R\"), \"456\", {\n          delay: 10\n        });\n        await page.click(getSelector(\"45R\"));\n        await page.waitForFunction(`${getQuerySelector(\"43R\")}.value !== \"${prevTotal}\"`);\n        await page.waitForFunction(`${getQuerySelector(\"46R\")}.value !== \"${prevTotal}\"`);\n        let total = await page.$eval(getSelector(\"43R\"), el => el.value);\n        expect(total).withContext(`In ${browserName}`).toEqual(\"579.00\");\n        total = await page.$eval(getSelector(\"46R\"), el => el.value);\n        expect(total).withContext(`In ${browserName}`).toEqual(\"579.00\");\n      }));\n    });","file":"integration/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should get id for annotation","suites":["annotation","AnnotationFactory"],"line":119,"updatePoint":{"line":119,"column":36,"index":3801},"code":"    it(\"should get id for annotation\", async function () {\n      const annotationDict = new Dict();\n      annotationDict.set(\"Type\", Name.get(\"Annot\"));\n      annotationDict.set(\"Subtype\", Name.get(\"Link\"));\n      const annotationRef = Ref.get(10, 0);\n      const xref = new XRefMock([{\n        ref: annotationRef,\n        data: annotationDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, annotationRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.LINK);\n      expect(data.id).toEqual(\"10R\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle missing /Subtype","suites":["annotation","AnnotationFactory"],"line":156,"updatePoint":{"line":156,"column":38,"index":5356},"code":"    it(\"should handle missing /Subtype\", async function () {\n      const annotationDict = new Dict();\n      annotationDict.set(\"Type\", Name.get(\"Annot\"));\n      const annotationRef = Ref.get(1, 0);\n      const xref = new XRefMock([{\n        ref: annotationRef,\n        data: annotationDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, annotationRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toBeUndefined();\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should ignore missing quadpoints","suites":["annotation","getQuadPoints"],"line":180,"updatePoint":{"line":180,"column":40,"index":6060},"code":"    it(\"should ignore missing quadpoints\", function () {\n      expect(getQuadPoints(dict, rect)).toEqual(null);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should ignore non-array values","suites":["annotation","getQuadPoints"],"line":183,"updatePoint":{"line":183,"column":38,"index":6178},"code":"    it(\"should ignore non-array values\", function () {\n      dict.set(\"QuadPoints\", \"foo\");\n      expect(getQuadPoints(dict, rect)).toEqual(null);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should ignore arrays where the length is not a multiple of eight","suites":["annotation","getQuadPoints"],"line":187,"updatePoint":{"line":187,"column":72,"index":6367},"code":"    it(\"should ignore arrays where the length is not a multiple of eight\", function () {\n      dict.set(\"QuadPoints\", [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n      expect(getQuadPoints(dict, rect)).toEqual(null);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should ignore quadpoints if one coordinate lies outside the rectangle","suites":["annotation","getQuadPoints"],"line":191,"updatePoint":{"line":191,"column":77,"index":6587},"code":"    it(\"should ignore quadpoints if one coordinate lies outside the rectangle\", function () {\n      rect = [10, 10, 20, 20];\n      const inputs = [[11, 11, 12, 12, 9, 13, 14, 14], // Smaller than lower x coordinate.\n      [11, 11, 12, 12, 13, 9, 14, 14], // Smaller than lower y coordinate.\n      [11, 11, 12, 12, 21, 13, 14, 14], // Larger than upper x coordinate.\n      [11, 11, 12, 12, 13, 21, 14, 14] // Larger than upper y coordinate.\n      ];\n\n      for (const input of inputs) {\n        dict.set(\"QuadPoints\", input);\n        expect(getQuadPoints(dict, rect)).toEqual(null);\n      }\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should process quadpoints in the standard order","suites":["annotation","getQuadPoints"],"line":204,"updatePoint":{"line":204,"column":55,"index":7163},"code":"    it(\"should process quadpoints in the standard order\", function () {\n      rect = [10, 10, 20, 20];\n      dict.set(\"QuadPoints\", [10, 20, 20, 20, 10, 10, 20, 10, 11, 19, 19, 19, 11, 11, 19, 11]);\n      expect(getQuadPoints(dict, rect)).toEqual([[{\n        x: 10,\n        y: 20\n      }, {\n        x: 20,\n        y: 20\n      }, {\n        x: 10,\n        y: 10\n      }, {\n        x: 20,\n        y: 10\n      }], [{\n        x: 11,\n        y: 19\n      }, {\n        x: 19,\n        y: 19\n      }, {\n        x: 11,\n        y: 11\n      }, {\n        x: 19,\n        y: 11\n      }]]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should normalize and process quadpoints in non-standard orders","suites":["annotation","getQuadPoints"],"line":233,"updatePoint":{"line":233,"column":70,"index":7760},"code":"    it(\"should normalize and process quadpoints in non-standard orders\", function () {\n      rect = [10, 10, 20, 20];\n      const nonStandardOrders = [// Bottom left, bottom right, top right and top left.\n      [10, 20, 20, 20, 20, 10, 10, 10], // Top left, top right, bottom left and bottom right.\n      [10, 10, 20, 10, 10, 20, 20, 20], // Top left, top right, bottom right and bottom left.\n      [10, 10, 20, 10, 20, 20, 10, 20]];\n\n      for (const nonStandardOrder of nonStandardOrders) {\n        dict.set(\"QuadPoints\", nonStandardOrder);\n        expect(getQuadPoints(dict, rect)).toEqual([[{\n          x: 10,\n          y: 20\n        }, {\n          x: 20,\n          y: 20\n        }, {\n          x: 10,\n          y: 10\n        }, {\n          x: 20,\n          y: 10\n        }]]);\n      }\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set and get valid contents","suites":["annotation","Annotation"],"line":267,"updatePoint":{"line":267,"column":41,"index":8741},"code":"    it(\"should set and get valid contents\", function () {\n      const annotation = new Annotation({\n        dict,\n        ref\n      });\n      annotation.setContents(\"Foo bar baz\");\n      expect(annotation._contents).toEqual({\n        str: \"Foo bar baz\",\n        dir: \"ltr\"\n      });\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should not set and get invalid contents","suites":["annotation","Annotation"],"line":278,"updatePoint":{"line":278,"column":47,"index":9038},"code":"    it(\"should not set and get invalid contents\", function () {\n      const annotation = new Annotation({\n        dict,\n        ref\n      });\n      annotation.setContents(undefined);\n      expect(annotation._contents).toEqual({\n        str: \"\",\n        dir: \"ltr\"\n      });\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set and get a valid modification date","suites":["annotation","Annotation"],"line":289,"updatePoint":{"line":289,"column":52,"index":9325},"code":"    it(\"should set and get a valid modification date\", function () {\n      const annotation = new Annotation({\n        dict,\n        ref\n      });\n      annotation.setModificationDate(\"D:20190422\");\n      expect(annotation.modificationDate).toEqual(\"D:20190422\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should not set and get an invalid modification date","suites":["annotation","Annotation"],"line":297,"updatePoint":{"line":297,"column":59,"index":9604},"code":"    it(\"should not set and get an invalid modification date\", function () {\n      const annotation = new Annotation({\n        dict,\n        ref\n      });\n      annotation.setModificationDate(undefined);\n      expect(annotation.modificationDate).toEqual(null);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set and get flags","suites":["annotation","Annotation"],"line":305,"updatePoint":{"line":305,"column":32,"index":9845},"code":"    it(\"should set and get flags\", function () {\n      const annotation = new Annotation({\n        dict,\n        ref\n      });\n      annotation.setFlags(13);\n      expect(annotation.hasFlag(AnnotationFlag.INVISIBLE)).toEqual(true);\n      expect(annotation.hasFlag(AnnotationFlag.NOZOOM)).toEqual(true);\n      expect(annotation.hasFlag(AnnotationFlag.PRINT)).toEqual(true);\n      expect(annotation.hasFlag(AnnotationFlag.READONLY)).toEqual(false);\n      expect(annotation.hasFlag(AnnotationFlag.HIDDEN)).toEqual(false);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should be viewable and not printable by default","suites":["annotation","Annotation"],"line":317,"updatePoint":{"line":317,"column":55,"index":10395},"code":"    it(\"should be viewable and not printable by default\", function () {\n      const annotation = new Annotation({\n        dict,\n        ref\n      });\n      expect(annotation.viewable).toEqual(true);\n      expect(annotation.printable).toEqual(false);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set and get a valid rectangle","suites":["annotation","Annotation"],"line":325,"updatePoint":{"line":325,"column":44,"index":10642},"code":"    it(\"should set and get a valid rectangle\", function () {\n      const annotation = new Annotation({\n        dict,\n        ref\n      });\n      annotation.setRectangle([117, 694, 164.298, 720]);\n      expect(annotation.rectangle).toEqual([117, 694, 164.298, 720]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should not set and get an invalid rectangle","suites":["annotation","Annotation"],"line":333,"updatePoint":{"line":333,"column":51,"index":10923},"code":"    it(\"should not set and get an invalid rectangle\", function () {\n      const annotation = new Annotation({\n        dict,\n        ref\n      });\n      annotation.setRectangle([117, 694, 164.298]);\n      expect(annotation.rectangle).toEqual([0, 0, 0, 0]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should reject a color if it is not an array","suites":["annotation","Annotation"],"line":341,"updatePoint":{"line":341,"column":51,"index":11187},"code":"    it(\"should reject a color if it is not an array\", function () {\n      const annotation = new Annotation({\n        dict,\n        ref\n      });\n      annotation.setColor(\"red\");\n      expect(annotation.color).toEqual(new Uint8ClampedArray([0, 0, 0]));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set and get a transparent color","suites":["annotation","Annotation"],"line":349,"updatePoint":{"line":349,"column":46,"index":11444},"code":"    it(\"should set and get a transparent color\", function () {\n      const annotation = new Annotation({\n        dict,\n        ref\n      });\n      annotation.setColor([]);\n      expect(annotation.color).toEqual(null);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set and get a grayscale color","suites":["annotation","Annotation"],"line":357,"updatePoint":{"line":357,"column":44,"index":11668},"code":"    it(\"should set and get a grayscale color\", function () {\n      const annotation = new Annotation({\n        dict,\n        ref\n      });\n      annotation.setColor([0.4]);\n      expect(annotation.color).toEqual(new Uint8ClampedArray([102, 102, 102]));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set and get an RGB color","suites":["annotation","Annotation"],"line":365,"updatePoint":{"line":365,"column":39,"index":11924},"code":"    it(\"should set and get an RGB color\", function () {\n      const annotation = new Annotation({\n        dict,\n        ref\n      });\n      annotation.setColor([0, 0, 1]);\n      expect(annotation.color).toEqual(new Uint8ClampedArray([0, 0, 255]));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set and get a CMYK color","suites":["annotation","Annotation"],"line":373,"updatePoint":{"line":373,"column":39,"index":12180},"code":"    it(\"should set and get a CMYK color\", function () {\n      const annotation = new Annotation({\n        dict,\n        ref\n      });\n      annotation.setColor([0.1, 0.92, 0.84, 0.02]);\n      expect(annotation.color).toEqual(new Uint8ClampedArray([234, 59, 48]));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should not set and get an invalid color","suites":["annotation","Annotation"],"line":381,"updatePoint":{"line":381,"column":47,"index":12460},"code":"    it(\"should not set and get an invalid color\", function () {\n      const annotation = new Annotation({\n        dict,\n        ref\n      });\n      annotation.setColor([0.4, 0.6]);\n      expect(annotation.color).toEqual(new Uint8ClampedArray([0, 0, 0]));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set and get a valid width","suites":["annotation","AnnotationBorderStyle"],"line":391,"updatePoint":{"line":391,"column":40,"index":12772},"code":"    it(\"should set and get a valid width\", function () {\n      const borderStyleInt = new AnnotationBorderStyle();\n      borderStyleInt.setWidth(3);\n      const borderStyleNum = new AnnotationBorderStyle();\n      borderStyleNum.setWidth(2.5);\n      expect(borderStyleInt.width).toEqual(3);\n      expect(borderStyleNum.width).toEqual(2.5);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should not set and get an invalid width","suites":["annotation","AnnotationBorderStyle"],"line":399,"updatePoint":{"line":399,"column":47,"index":13126},"code":"    it(\"should not set and get an invalid width\", function () {\n      const borderStyle = new AnnotationBorderStyle();\n      borderStyle.setWidth(\"three\");\n      expect(borderStyle.width).toEqual(1);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set the width to zero, when the input is a `Name` (issue 10385)","suites":["annotation","AnnotationBorderStyle"],"line":404,"updatePoint":{"line":404,"column":78,"index":13365},"code":"    it(\"should set the width to zero, when the input is a `Name` (issue 10385)\", function () {\n      const borderStyleZero = new AnnotationBorderStyle();\n      borderStyleZero.setWidth(Name.get(\"0\"));\n      const borderStyleFive = new AnnotationBorderStyle();\n      borderStyleFive.setWidth(Name.get(\"5\"));\n      expect(borderStyleZero.width).toEqual(0);\n      expect(borderStyleFive.width).toEqual(0);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set and get a valid style","suites":["annotation","AnnotationBorderStyle"],"line":412,"updatePoint":{"line":412,"column":40,"index":13738},"code":"    it(\"should set and get a valid style\", function () {\n      const borderStyle = new AnnotationBorderStyle();\n      borderStyle.setStyle(Name.get(\"D\"));\n      expect(borderStyle.style).toEqual(AnnotationBorderStyleType.DASHED);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should not set and get an invalid style","suites":["annotation","AnnotationBorderStyle"],"line":417,"updatePoint":{"line":417,"column":47,"index":13983},"code":"    it(\"should not set and get an invalid style\", function () {\n      const borderStyle = new AnnotationBorderStyle();\n      borderStyle.setStyle(\"Dashed\");\n      expect(borderStyle.style).toEqual(AnnotationBorderStyleType.SOLID);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set and get a valid dash array","suites":["annotation","AnnotationBorderStyle"],"line":422,"updatePoint":{"line":422,"column":45,"index":14220},"code":"    it(\"should set and get a valid dash array\", function () {\n      const borderStyle = new AnnotationBorderStyle();\n      borderStyle.setDashArray([1, 2, 3]);\n      expect(borderStyle.dashArray).toEqual([1, 2, 3]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should not set and get an invalid dash array","suites":["annotation","AnnotationBorderStyle"],"line":427,"updatePoint":{"line":427,"column":52,"index":14451},"code":"    it(\"should not set and get an invalid dash array\", function () {\n      const borderStyle = new AnnotationBorderStyle();\n      borderStyle.setDashArray([0, 0]);\n      expect(borderStyle.dashArray).toEqual([3]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set and get a valid horizontal corner radius","suites":["annotation","AnnotationBorderStyle"],"line":432,"updatePoint":{"line":432,"column":59,"index":14680},"code":"    it(\"should set and get a valid horizontal corner radius\", function () {\n      const borderStyle = new AnnotationBorderStyle();\n      borderStyle.setHorizontalCornerRadius(3);\n      expect(borderStyle.horizontalCornerRadius).toEqual(3);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should not set and get an invalid horizontal corner radius","suites":["annotation","AnnotationBorderStyle"],"line":437,"updatePoint":{"line":437,"column":66,"index":14935},"code":"    it(\"should not set and get an invalid horizontal corner radius\", function () {\n      const borderStyle = new AnnotationBorderStyle();\n      borderStyle.setHorizontalCornerRadius(\"three\");\n      expect(borderStyle.horizontalCornerRadius).toEqual(0);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set and get a valid vertical corner radius","suites":["annotation","AnnotationBorderStyle"],"line":442,"updatePoint":{"line":442,"column":57,"index":15187},"code":"    it(\"should set and get a valid vertical corner radius\", function () {\n      const borderStyle = new AnnotationBorderStyle();\n      borderStyle.setVerticalCornerRadius(3);\n      expect(borderStyle.verticalCornerRadius).toEqual(3);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should not set and get an invalid vertical corner radius","suites":["annotation","AnnotationBorderStyle"],"line":447,"updatePoint":{"line":447,"column":64,"index":15436},"code":"    it(\"should not set and get an invalid vertical corner radius\", function () {\n      const borderStyle = new AnnotationBorderStyle();\n      borderStyle.setVerticalCornerRadius(\"three\");\n      expect(borderStyle.verticalCornerRadius).toEqual(0);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set and get a valid creation date","suites":["annotation","MarkupAnnotation"],"line":462,"updatePoint":{"line":462,"column":48,"index":15893},"code":"    it(\"should set and get a valid creation date\", function () {\n      const markupAnnotation = new MarkupAnnotation({\n        dict,\n        ref\n      });\n      markupAnnotation.setCreationDate(\"D:20190422\");\n      expect(markupAnnotation.creationDate).toEqual(\"D:20190422\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should not set and get an invalid creation date","suites":["annotation","MarkupAnnotation"],"line":470,"updatePoint":{"line":470,"column":55,"index":16184},"code":"    it(\"should not set and get an invalid creation date\", function () {\n      const markupAnnotation = new MarkupAnnotation({\n        dict,\n        ref\n      });\n      markupAnnotation.setCreationDate(undefined);\n      expect(markupAnnotation.creationDate).toEqual(null);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should not parse IRT/RT when not defined","suites":["annotation","MarkupAnnotation"],"line":478,"updatePoint":{"line":478,"column":48,"index":16457},"code":"    it(\"should not parse IRT/RT when not defined\", async function () {\n      dict.set(\"Type\", Name.get(\"Annot\"));\n      dict.set(\"Subtype\", Name.get(\"Text\"));\n      const xref = new XRefMock([{\n        ref,\n        data: dict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, ref, pdfManagerMock, idFactoryMock);\n      expect(data.inReplyTo).toBeUndefined();\n      expect(data.replyType).toBeUndefined();\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should parse IRT and set default RT when not defined","suites":["annotation","MarkupAnnotation"],"line":491,"updatePoint":{"line":491,"column":60,"index":16917},"code":"    it(\"should parse IRT and set default RT when not defined\", async function () {\n      const annotationRef = Ref.get(819, 0);\n      const annotationDict = new Dict();\n      annotationDict.set(\"Type\", Name.get(\"Annot\"));\n      annotationDict.set(\"Subtype\", Name.get(\"Text\"));\n      const replyRef = Ref.get(820, 0);\n      const replyDict = new Dict();\n      replyDict.set(\"Type\", Name.get(\"Annot\"));\n      replyDict.set(\"Subtype\", Name.get(\"Text\"));\n      replyDict.set(\"IRT\", annotationRef);\n      const xref = new XRefMock([{\n        ref: annotationRef,\n        data: annotationDict\n      }, {\n        ref: replyRef,\n        data: replyDict\n      }]);\n      annotationDict.assignXref(xref);\n      replyDict.assignXref(xref);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, replyRef, pdfManagerMock, idFactoryMock);\n      expect(data.inReplyTo).toEqual(annotationRef.toString());\n      expect(data.replyType).toEqual(\"R\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should parse IRT/RT for a group type","suites":["annotation","MarkupAnnotation"],"line":516,"updatePoint":{"line":516,"column":44,"index":17860},"code":"    it(\"should parse IRT/RT for a group type\", async function () {\n      const annotationRef = Ref.get(819, 0);\n      const annotationDict = new Dict();\n      annotationDict.set(\"Type\", Name.get(\"Annot\"));\n      annotationDict.set(\"Subtype\", Name.get(\"Text\"));\n      annotationDict.set(\"T\", \"ParentTitle\");\n      annotationDict.set(\"Contents\", \"ParentText\");\n      annotationDict.set(\"CreationDate\", \"D:20180423\");\n      annotationDict.set(\"M\", \"D:20190423\");\n      annotationDict.set(\"C\", [0, 0, 1]);\n      const popupRef = Ref.get(820, 0);\n      const popupDict = new Dict();\n      popupDict.set(\"Type\", Name.get(\"Annot\"));\n      popupDict.set(\"Subtype\", Name.get(\"Popup\"));\n      popupDict.set(\"Parent\", annotationRef);\n      annotationDict.set(\"Popup\", popupRef);\n      const replyRef = Ref.get(821, 0);\n      const replyDict = new Dict();\n      replyDict.set(\"Type\", Name.get(\"Annot\"));\n      replyDict.set(\"Subtype\", Name.get(\"Text\"));\n      replyDict.set(\"IRT\", annotationRef);\n      replyDict.set(\"RT\", Name.get(\"Group\"));\n      replyDict.set(\"T\", \"ReplyTitle\");\n      replyDict.set(\"Contents\", \"ReplyText\");\n      replyDict.set(\"CreationDate\", \"D:20180523\");\n      replyDict.set(\"M\", \"D:20190523\");\n      replyDict.set(\"C\", [0.4]);\n      const xref = new XRefMock([{\n        ref: annotationRef,\n        data: annotationDict\n      }, {\n        ref: popupRef,\n        data: popupDict\n      }, {\n        ref: replyRef,\n        data: replyDict\n      }]);\n      annotationDict.assignXref(xref);\n      popupDict.assignXref(xref);\n      replyDict.assignXref(xref);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, replyRef, pdfManagerMock, idFactoryMock);\n      expect(data.inReplyTo).toEqual(annotationRef.toString());\n      expect(data.replyType).toEqual(\"Group\");\n      expect(data.titleObj).toEqual({\n        str: \"ParentTitle\",\n        dir: \"ltr\"\n      });\n      expect(data.contentsObj).toEqual({\n        str: \"ParentText\",\n        dir: \"ltr\"\n      });\n      expect(data.creationDate).toEqual(\"D:20180423\");\n      expect(data.modificationDate).toEqual(\"D:20190423\");\n      expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));\n      expect(data.hasPopup).toEqual(true);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should parse IRT/RT for a reply type","suites":["annotation","MarkupAnnotation"],"line":574,"updatePoint":{"line":574,"column":44,"index":20081},"code":"    it(\"should parse IRT/RT for a reply type\", async function () {\n      const annotationRef = Ref.get(819, 0);\n      const annotationDict = new Dict();\n      annotationDict.set(\"Type\", Name.get(\"Annot\"));\n      annotationDict.set(\"Subtype\", Name.get(\"Text\"));\n      annotationDict.set(\"T\", \"ParentTitle\");\n      annotationDict.set(\"Contents\", \"ParentText\");\n      annotationDict.set(\"CreationDate\", \"D:20180423\");\n      annotationDict.set(\"M\", \"D:20190423\");\n      annotationDict.set(\"C\", [0, 0, 1]);\n      const popupRef = Ref.get(820, 0);\n      const popupDict = new Dict();\n      popupDict.set(\"Type\", Name.get(\"Annot\"));\n      popupDict.set(\"Subtype\", Name.get(\"Popup\"));\n      popupDict.set(\"Parent\", annotationRef);\n      annotationDict.set(\"Popup\", popupRef);\n      const replyRef = Ref.get(821, 0);\n      const replyDict = new Dict();\n      replyDict.set(\"Type\", Name.get(\"Annot\"));\n      replyDict.set(\"Subtype\", Name.get(\"Text\"));\n      replyDict.set(\"IRT\", annotationRef);\n      replyDict.set(\"RT\", Name.get(\"R\"));\n      replyDict.set(\"T\", \"ReplyTitle\");\n      replyDict.set(\"Contents\", \"ReplyText\");\n      replyDict.set(\"CreationDate\", \"D:20180523\");\n      replyDict.set(\"M\", \"D:20190523\");\n      replyDict.set(\"C\", [0.4]);\n      const xref = new XRefMock([{\n        ref: annotationRef,\n        data: annotationDict\n      }, {\n        ref: popupRef,\n        data: popupDict\n      }, {\n        ref: replyRef,\n        data: replyDict\n      }]);\n      annotationDict.assignXref(xref);\n      popupDict.assignXref(xref);\n      replyDict.assignXref(xref);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, replyRef, pdfManagerMock, idFactoryMock);\n      expect(data.inReplyTo).toEqual(annotationRef.toString());\n      expect(data.replyType).toEqual(\"R\");\n      expect(data.titleObj).toEqual({\n        str: \"ReplyTitle\",\n        dir: \"ltr\"\n      });\n      expect(data.contentsObj).toEqual({\n        str: \"ReplyText\",\n        dir: \"ltr\"\n      });\n      expect(data.creationDate).toEqual(\"D:20180523\");\n      expect(data.modificationDate).toEqual(\"D:20190523\");\n      expect(data.color).toEqual(new Uint8ClampedArray([102, 102, 102]));\n      expect(data.hasPopup).toEqual(false);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should not parse state model and state when not defined","suites":["annotation","TextAnnotation"],"line":634,"updatePoint":{"line":634,"column":63,"index":22365},"code":"    it(\"should not parse state model and state when not defined\", async function () {\n      const annotationRef = Ref.get(819, 0);\n      const annotationDict = new Dict();\n      annotationDict.set(\"Type\", Name.get(\"Annot\"));\n      annotationDict.set(\"Subtype\", Name.get(\"Text\"));\n      annotationDict.set(\"Contents\", \"TestText\");\n      const replyRef = Ref.get(820, 0);\n      const replyDict = new Dict();\n      replyDict.set(\"Type\", Name.get(\"Annot\"));\n      replyDict.set(\"Subtype\", Name.get(\"Text\"));\n      replyDict.set(\"IRT\", annotationRef);\n      replyDict.set(\"RT\", Name.get(\"R\"));\n      replyDict.set(\"Contents\", \"ReplyText\");\n      const xref = new XRefMock([{\n        ref: annotationRef,\n        data: annotationDict\n      }, {\n        ref: replyRef,\n        data: replyDict\n      }]);\n      annotationDict.assignXref(xref);\n      replyDict.assignXref(xref);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, replyRef, pdfManagerMock, idFactoryMock);\n      expect(data.stateModel).toBeNull();\n      expect(data.state).toBeNull();\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should correctly parse state model and state when defined","suites":["annotation","TextAnnotation"],"line":662,"updatePoint":{"line":662,"column":65,"index":23439},"code":"    it(\"should correctly parse state model and state when defined\", async function () {\n      const annotationRef = Ref.get(819, 0);\n      const annotationDict = new Dict();\n      annotationDict.set(\"Type\", Name.get(\"Annot\"));\n      annotationDict.set(\"Subtype\", Name.get(\"Text\"));\n      const replyRef = Ref.get(820, 0);\n      const replyDict = new Dict();\n      replyDict.set(\"Type\", Name.get(\"Annot\"));\n      replyDict.set(\"Subtype\", Name.get(\"Text\"));\n      replyDict.set(\"IRT\", annotationRef);\n      replyDict.set(\"RT\", Name.get(\"R\"));\n      replyDict.set(\"StateModel\", \"Review\");\n      replyDict.set(\"State\", \"Rejected\");\n      const xref = new XRefMock([{\n        ref: annotationRef,\n        data: annotationDict\n      }, {\n        ref: replyRef,\n        data: replyDict\n      }]);\n      annotationDict.assignXref(xref);\n      replyDict.assignXref(xref);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, replyRef, pdfManagerMock, idFactoryMock);\n      expect(data.stateModel).toEqual(\"Review\");\n      expect(data.state).toEqual(\"Rejected\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should correctly parse a URI action","suites":["annotation","LinkAnnotation"],"line":692,"updatePoint":{"line":692,"column":43,"index":24547},"code":"    it(\"should correctly parse a URI action\", async function () {\n      const actionDict = new Dict();\n      actionDict.set(\"Type\", Name.get(\"Action\"));\n      actionDict.set(\"S\", Name.get(\"URI\"));\n      actionDict.set(\"URI\", \"http://www.ctan.org/tex-archive/info/lshort\");\n      const annotationDict = new Dict();\n      annotationDict.set(\"Type\", Name.get(\"Annot\"));\n      annotationDict.set(\"Subtype\", Name.get(\"Link\"));\n      annotationDict.set(\"A\", actionDict);\n      const annotationRef = Ref.get(820, 0);\n      const xref = new XRefMock([{\n        ref: annotationRef,\n        data: annotationDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, annotationRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.LINK);\n      expect(data.url).toEqual(\"http://www.ctan.org/tex-archive/info/lshort\");\n      expect(data.unsafeUrl).toEqual(\"http://www.ctan.org/tex-archive/info/lshort\");\n      expect(data.dest).toBeUndefined();\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should correctly parse a GoTo action","suites":["annotation","LinkAnnotation"],"line":760,"updatePoint":{"line":760,"column":44,"index":27760},"code":"    it(\"should correctly parse a GoTo action\", async function () {\n      const actionDict = new Dict();\n      actionDict.set(\"Type\", Name.get(\"Action\"));\n      actionDict.set(\"S\", Name.get(\"GoTo\"));\n      actionDict.set(\"D\", \"page.157\");\n      const annotationDict = new Dict();\n      annotationDict.set(\"Type\", Name.get(\"Annot\"));\n      annotationDict.set(\"Subtype\", Name.get(\"Link\"));\n      annotationDict.set(\"A\", actionDict);\n      const annotationRef = Ref.get(798, 0);\n      const xref = new XRefMock([{\n        ref: annotationRef,\n        data: annotationDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, annotationRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.LINK);\n      expect(data.url).toBeUndefined();\n      expect(data.unsafeUrl).toBeUndefined();\n      expect(data.dest).toEqual(\"page.157\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should correctly parse a GoToR action, with named destination","suites":["annotation","LinkAnnotation"],"line":833,"updatePoint":{"line":833,"column":69,"index":31048},"code":"    it(\"should correctly parse a GoToR action, with named destination\", async function () {\n      const actionDict = new Dict();\n      actionDict.set(\"Type\", Name.get(\"Action\"));\n      actionDict.set(\"S\", Name.get(\"GoToR\"));\n      actionDict.set(\"F\", \"http://www.example.com/test.pdf\");\n      actionDict.set(\"D\", \"15\");\n      const annotationDict = new Dict();\n      annotationDict.set(\"Type\", Name.get(\"Annot\"));\n      annotationDict.set(\"Subtype\", Name.get(\"Link\"));\n      annotationDict.set(\"A\", actionDict);\n      const annotationRef = Ref.get(495, 0);\n      const xref = new XRefMock([{\n        ref: annotationRef,\n        data: annotationDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, annotationRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.LINK);\n      expect(data.url).toEqual(\"http://www.example.com/test.pdf#15\");\n      expect(data.unsafeUrl).toEqual(\"http://www.example.com/test.pdf#15\");\n      expect(data.dest).toBeUndefined();\n      expect(data.newWindow).toBeFalsy();\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should correctly parse a GoToR action, with explicit destination array","suites":["annotation","LinkAnnotation"],"line":857,"updatePoint":{"line":857,"column":78,"index":32139},"code":"    it(\"should correctly parse a GoToR action, with explicit destination array\", async function () {\n      const actionDict = new Dict();\n      actionDict.set(\"Type\", Name.get(\"Action\"));\n      actionDict.set(\"S\", Name.get(\"GoToR\"));\n      actionDict.set(\"F\", \"http://www.example.com/test.pdf\");\n      actionDict.set(\"D\", [14, Name.get(\"XYZ\"), null, 298.043, null]);\n      const annotationDict = new Dict();\n      annotationDict.set(\"Type\", Name.get(\"Annot\"));\n      annotationDict.set(\"Subtype\", Name.get(\"Link\"));\n      annotationDict.set(\"A\", actionDict);\n      const annotationRef = Ref.get(489, 0);\n      const xref = new XRefMock([{\n        ref: annotationRef,\n        data: annotationDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, annotationRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.LINK);\n      expect(data.url).toEqual(new URL(\"http://www.example.com/test.pdf#\" + '[14,{\"name\":\"XYZ\"},null,298.043,null]').href);\n      expect(data.unsafeUrl).toEqual(\"http://www.example.com/test.pdf#\" + '[14,{\"name\":\"XYZ\"},null,298.043,null]');\n      expect(data.dest).toBeUndefined();\n      expect(data.newWindow).toBeFalsy();\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should correctly parse a Named action","suites":["annotation","LinkAnnotation"],"line":965,"updatePoint":{"line":965,"column":45,"index":37241},"code":"    it(\"should correctly parse a Named action\", async function () {\n      const actionDict = new Dict();\n      actionDict.set(\"Type\", Name.get(\"Action\"));\n      actionDict.set(\"S\", Name.get(\"Named\"));\n      actionDict.set(\"N\", Name.get(\"GoToPage\"));\n      const annotationDict = new Dict();\n      annotationDict.set(\"Type\", Name.get(\"Annot\"));\n      annotationDict.set(\"Subtype\", Name.get(\"Link\"));\n      annotationDict.set(\"A\", actionDict);\n      const annotationRef = Ref.get(12, 0);\n      const xref = new XRefMock([{\n        ref: annotationRef,\n        data: annotationDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, annotationRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.LINK);\n      expect(data.url).toBeUndefined();\n      expect(data.unsafeUrl).toBeUndefined();\n      expect(data.action).toEqual(\"GoToPage\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should correctly parse a simple Dest","suites":["annotation","LinkAnnotation"],"line":987,"updatePoint":{"line":987,"column":44,"index":38155},"code":"    it(\"should correctly parse a simple Dest\", async function () {\n      const annotationDict = new Dict();\n      annotationDict.set(\"Type\", Name.get(\"Annot\"));\n      annotationDict.set(\"Subtype\", Name.get(\"Link\"));\n      annotationDict.set(\"Dest\", Name.get(\"LI0\"));\n      const annotationRef = Ref.get(583, 0);\n      const xref = new XRefMock([{\n        ref: annotationRef,\n        data: annotationDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, annotationRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.LINK);\n      expect(data.url).toBeUndefined();\n      expect(data.unsafeUrl).toBeUndefined();\n      expect(data.dest).toEqual(\"LI0\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should correctly parse a simple Dest, with explicit destination array","suites":["annotation","LinkAnnotation"],"line":1005,"updatePoint":{"line":1005,"column":77,"index":38922},"code":"    it(\"should correctly parse a simple Dest, with explicit destination array\", async function () {\n      const annotationDict = new Dict();\n      annotationDict.set(\"Type\", Name.get(\"Annot\"));\n      annotationDict.set(\"Subtype\", Name.get(\"Link\"));\n      annotationDict.set(\"Dest\", [Ref.get(17, 0), Name.get(\"XYZ\"), 0, 841.89, null]);\n      const annotationRef = Ref.get(10, 0);\n      const xref = new XRefMock([{\n        ref: annotationRef,\n        data: annotationDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, annotationRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.LINK);\n      expect(data.url).toBeUndefined();\n      expect(data.unsafeUrl).toBeUndefined();\n      expect(data.dest).toEqual([Ref.get(17, 0), Name.get(\"XYZ\"), 0, 841.89, null]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should not set quadpoints if not defined","suites":["annotation","LinkAnnotation"],"line":1047,"updatePoint":{"line":1047,"column":48,"index":40835},"code":"    it(\"should not set quadpoints if not defined\", async function () {\n      const annotationDict = new Dict();\n      annotationDict.set(\"Type\", Name.get(\"Annot\"));\n      annotationDict.set(\"Subtype\", Name.get(\"Link\"));\n      const annotationRef = Ref.get(121, 0);\n      const xref = new XRefMock([{\n        ref: annotationRef,\n        data: annotationDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, annotationRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.LINK);\n      expect(data.quadPoints).toBeUndefined();\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set quadpoints if defined","suites":["annotation","LinkAnnotation"],"line":1062,"updatePoint":{"line":1062,"column":40,"index":41435},"code":"    it(\"should set quadpoints if defined\", async function () {\n      const annotationDict = new Dict();\n      annotationDict.set(\"Type\", Name.get(\"Annot\"));\n      annotationDict.set(\"Subtype\", Name.get(\"Link\"));\n      annotationDict.set(\"Rect\", [10, 10, 20, 20]);\n      annotationDict.set(\"QuadPoints\", [10, 20, 20, 20, 10, 10, 20, 10]);\n      const annotationRef = Ref.get(121, 0);\n      const xref = new XRefMock([{\n        ref: annotationRef,\n        data: annotationDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, annotationRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.LINK);\n      expect(data.quadPoints).toEqual([[{\n        x: 10,\n        y: 20\n      }, {\n        x: 20,\n        y: 20\n      }, {\n        x: 10,\n        y: 10\n      }, {\n        x: 20,\n        y: 10\n      }]]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle unknown field names","suites":["annotation","WidgetAnnotation"],"line":1102,"updatePoint":{"line":1102,"column":41,"index":42620},"code":"    it(\"should handle unknown field names\", async function () {\n      const widgetRef = Ref.get(20, 0);\n      const xref = new XRefMock([{\n        ref: widgetRef,\n        data: widgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, widgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.fieldName).toEqual(\"\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should construct the field name when there are no ancestors","suites":["annotation","WidgetAnnotation"],"line":1114,"updatePoint":{"line":1114,"column":67,"index":43078},"code":"    it(\"should construct the field name when there are no ancestors\", async function () {\n      widgetDict.set(\"T\", \"foo\");\n      const widgetRef = Ref.get(21, 0);\n      const xref = new XRefMock([{\n        ref: widgetRef,\n        data: widgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, widgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.fieldName).toEqual(\"foo\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should construct the field name when there are ancestors","suites":["annotation","WidgetAnnotation"],"line":1127,"updatePoint":{"line":1127,"column":64,"index":43570},"code":"    it(\"should construct the field name when there are ancestors\", async function () {\n      const firstParent = new Dict();\n      firstParent.set(\"T\", \"foo\");\n      const secondParent = new Dict();\n      secondParent.set(\"Parent\", firstParent);\n      secondParent.set(\"T\", \"bar\");\n      widgetDict.set(\"Parent\", secondParent);\n      widgetDict.set(\"T\", \"baz\");\n      const widgetRef = Ref.get(22, 0);\n      const xref = new XRefMock([{\n        ref: widgetRef,\n        data: widgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, widgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.fieldName).toEqual(\"foo.bar.baz\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle unknown text alignment, maximum length and flags","suites":["annotation","TextWidgetAnnotation"],"line":1216,"updatePoint":{"line":1216,"column":70,"index":47183},"code":"    it(\"should handle unknown text alignment, maximum length and flags\", async function () {\n      textWidgetDict.set(\"DV\", \"foo\");\n      const textWidgetRef = Ref.get(124, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.textAlignment).toEqual(null);\n      expect(data.maxLen).toEqual(null);\n      expect(data.readOnly).toEqual(false);\n      expect(data.hidden).toEqual(false);\n      expect(data.multiLine).toEqual(false);\n      expect(data.comb).toEqual(false);\n      expect(data.defaultFieldValue).toEqual(\"foo\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should not set invalid text alignment, maximum length and flags","suites":["annotation","TextWidgetAnnotation"],"line":1235,"updatePoint":{"line":1235,"column":71,"index":47972},"code":"    it(\"should not set invalid text alignment, maximum length and flags\", async function () {\n      textWidgetDict.set(\"Q\", \"center\");\n      textWidgetDict.set(\"MaxLen\", \"five\");\n      textWidgetDict.set(\"Ff\", \"readonly\");\n      const textWidgetRef = Ref.get(43, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.textAlignment).toEqual(null);\n      expect(data.maxLen).toEqual(null);\n      expect(data.readOnly).toEqual(false);\n      expect(data.hidden).toEqual(false);\n      expect(data.multiLine).toEqual(false);\n      expect(data.comb).toEqual(false);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set valid text alignment, maximum length and flags","suites":["annotation","TextWidgetAnnotation"],"line":1255,"updatePoint":{"line":1255,"column":65,"index":48791},"code":"    it(\"should set valid text alignment, maximum length and flags\", async function () {\n      textWidgetDict.set(\"Q\", 1);\n      textWidgetDict.set(\"MaxLen\", 20);\n      textWidgetDict.set(\"Ff\", AnnotationFieldFlag.READONLY + AnnotationFieldFlag.MULTILINE);\n      const textWidgetRef = Ref.get(84, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.textAlignment).toEqual(1);\n      expect(data.maxLen).toEqual(20);\n      expect(data.readOnly).toEqual(true);\n      expect(data.hidden).toEqual(false);\n      expect(data.multiLine).toEqual(true);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should reject comb fields without a maximum length","suites":["annotation","TextWidgetAnnotation"],"line":1274,"updatePoint":{"line":1274,"column":58,"index":49595},"code":"    it(\"should reject comb fields without a maximum length\", async function () {\n      textWidgetDict.set(\"Ff\", AnnotationFieldFlag.COMB);\n      const textWidgetRef = Ref.get(46, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.comb).toEqual(false);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should accept comb fields with a maximum length","suites":["annotation","TextWidgetAnnotation"],"line":1287,"updatePoint":{"line":1287,"column":55,"index":50113},"code":"    it(\"should accept comb fields with a maximum length\", async function () {\n      textWidgetDict.set(\"MaxLen\", 20);\n      textWidgetDict.set(\"Ff\", AnnotationFieldFlag.COMB);\n      const textWidgetRef = Ref.get(46, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.comb).toEqual(true);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should only accept comb fields when the flags are valid","suites":["annotation","TextWidgetAnnotation"],"line":1301,"updatePoint":{"line":1301,"column":63,"index":50678},"code":"    it(\"should only accept comb fields when the flags are valid\", async function () {\n      const invalidFieldFlags = [AnnotationFieldFlag.MULTILINE, AnnotationFieldFlag.PASSWORD, AnnotationFieldFlag.FILESELECT]; // Start with all invalid flags set and remove them one by one.\n      // The field may only use combs when all invalid flags are unset.\n\n      let flags = AnnotationFieldFlag.COMB + AnnotationFieldFlag.MULTILINE + AnnotationFieldFlag.PASSWORD + AnnotationFieldFlag.FILESELECT;\n      let promise = Promise.resolve();\n\n      for (let i = 0, ii = invalidFieldFlags.length; i <= ii; i++) {\n        promise = promise.then(() => {\n          textWidgetDict.set(\"MaxLen\", 20);\n          textWidgetDict.set(\"Ff\", flags);\n          const textWidgetRef = Ref.get(93, 0);\n          const xref = new XRefMock([{\n            ref: textWidgetRef,\n            data: textWidgetDict\n          }]);\n          return AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock).then(({\n            data\n          }) => {\n            expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n            const valid = invalidFieldFlags.length === 0;\n            expect(data.comb).toEqual(valid); // Remove the last invalid flag for the next iteration.\n\n            if (!valid) {\n              flags -= invalidFieldFlags.pop();\n            }\n          });\n        });\n      }\n\n      await promise;\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render regular text for printing","suites":["annotation","TextWidgetAnnotation"],"line":1333,"updatePoint":{"line":1333,"column":47,"index":52076},"code":"    it(\"should render regular text for printing\", async function () {\n      const textWidgetRef = Ref.get(271, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }, helvRefObj]);\n      const task = new WorkerTask(\"test print\");\n      partialEvaluator.xref = xref;\n      const annotation = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: \"test\\\\print\"\n      });\n      const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);\n      expect(appearance).toEqual(\"/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm\" + \" 2 3.04 Td (test\\\\\\\\print) Tj ET Q EMC\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render regular text in Japanese for printing","suites":["annotation","TextWidgetAnnotation"],"line":1349,"updatePoint":{"line":1349,"column":59,"index":52872},"code":"    it(\"should render regular text in Japanese for printing\", async function () {\n      textWidgetDict.get(\"DR\").get(\"Font\").set(\"Goth\", gothRefObj.ref);\n      textWidgetDict.set(\"DA\", \"/Goth 5 Tf\");\n      const textWidgetRef = Ref.get(271, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }, gothRefObj]);\n      const task = new WorkerTask(\"test print\");\n      partialEvaluator.xref = xref;\n      const annotation = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: \"こんにちは世界の\"\n      });\n      const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);\n      const utf16String = \"\\x30\\x53\\x30\\x93\\x30\\x6b\\x30\\x61\\x30\\x6f\\x4e\\x16\\x75\\x4c\\x30\\x6e\";\n      expect(appearance).toEqual(\"/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 0 Tm\" + ` 2 2 Td (${utf16String}) Tj ET Q EMC`);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render regular text for printing using normal appearance","suites":["annotation","TextWidgetAnnotation"],"line":1368,"updatePoint":{"line":1368,"column":71,"index":53887},"code":"    it(\"should render regular text for printing using normal appearance\", async function () {\n      const textWidgetRef = Ref.get(271, 0);\n      const appearanceStatesDict = new Dict();\n      const normalAppearanceDict = new Dict();\n      const normalAppearanceStream = new StringStream(\"0.1 0.2 0.3 rg\");\n      normalAppearanceStream.dict = normalAppearanceDict;\n      appearanceStatesDict.set(\"N\", normalAppearanceStream);\n      textWidgetDict.set(\"AP\", appearanceStatesDict);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }, helvRefObj]);\n      const task = new WorkerTask(\"test print\");\n      partialEvaluator.xref = xref;\n      const annotation = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      const operatorList = await annotation.getOperatorList(partialEvaluator, task, RenderingIntentFlag.PRINT, false, annotationStorage);\n      expect(operatorList.argsArray.length).toEqual(3);\n      expect(operatorList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);\n      expect(operatorList.argsArray[0]).toEqual([\"271R\", [0, 0, 32, 10], [32, 0, 0, 10, 0, 0], [1, 0, 0, 1, 0, 0], false]);\n      expect(operatorList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render auto-sized text for printing","suites":["annotation","TextWidgetAnnotation"],"line":1390,"updatePoint":{"line":1390,"column":50,"index":55216},"code":"    it(\"should render auto-sized text for printing\", async function () {\n      textWidgetDict.set(\"DA\", \"/Helv 0 Tf\");\n      const textWidgetRef = Ref.get(271, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }, helvRefObj]);\n      const task = new WorkerTask(\"test print\");\n      partialEvaluator.xref = xref;\n      const annotation = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: \"test (print)\"\n      });\n      const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);\n      expect(appearance).toEqual(\"/Tx BMC q BT /Helv 5.92 Tf 0 g 1 0 0 1 0 0 Tm\" + \" 2 3.23 Td (test \\\\(print\\\\)) Tj ET Q EMC\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render auto-sized text in Japanese for printing","suites":["annotation","TextWidgetAnnotation"],"line":1407,"updatePoint":{"line":1407,"column":62,"index":56072},"code":"    it(\"should render auto-sized text in Japanese for printing\", async function () {\n      textWidgetDict.get(\"DR\").get(\"Font\").set(\"Goth\", gothRefObj.ref);\n      textWidgetDict.set(\"DA\", \"/Goth 0 Tf\");\n      const textWidgetRef = Ref.get(271, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }, gothRefObj]);\n      const task = new WorkerTask(\"test print\");\n      partialEvaluator.xref = xref;\n      const annotation = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: \"こんにちは世界の\"\n      });\n      const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);\n      const utf16String = \"\\x30\\x53\\x30\\x93\\x30\\x6b\\x30\\x61\\x30\\x6f\\x4e\\x16\\x75\\x4c\\x30\\x6e\";\n      expect(appearance).toEqual(\"/Tx BMC q BT /Goth 3.5 Tf 0 g 1 0 0 1 0 0 Tm\" + ` 2 2 Td (${utf16String}) Tj ET Q EMC`);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should not render a password for printing","suites":["annotation","TextWidgetAnnotation"],"line":1426,"updatePoint":{"line":1426,"column":49,"index":57071},"code":"    it(\"should not render a password for printing\", async function () {\n      textWidgetDict.set(\"Ff\", AnnotationFieldFlag.PASSWORD);\n      const textWidgetRef = Ref.get(271, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }, helvRefObj]);\n      const task = new WorkerTask(\"test print\");\n      partialEvaluator.xref = xref;\n      const annotation = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: \"mypassword\"\n      });\n      const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);\n      expect(appearance).toEqual(null);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render multiline text for printing","suites":["annotation","TextWidgetAnnotation"],"line":1443,"updatePoint":{"line":1443,"column":49,"index":57839},"code":"    it(\"should render multiline text for printing\", async function () {\n      textWidgetDict.set(\"Ff\", AnnotationFieldFlag.MULTILINE);\n      const textWidgetRef = Ref.get(271, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }, helvRefObj]);\n      const task = new WorkerTask(\"test print\");\n      partialEvaluator.xref = xref;\n      const annotation = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: \"a aa aaa aaaa aaaaa aaaaaa \" + \"pneumonoultramicroscopicsilicovolcanoconiosis\"\n      });\n      const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);\n      expect(appearance).toEqual(\"/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 10 Tm \" + \"2 -5 Td (a aa aaa ) Tj\\n\" + \"0 -5 Td (aaaa aaaaa ) Tj\\n\" + \"0 -5 Td (aaaaaa ) Tj\\n\" + \"0 -5 Td (pneumonoultr) Tj\\n\" + \"0 -5 Td (amicroscopi) Tj\\n\" + \"0 -5 Td (csilicovolca) Tj\\n\" + \"0 -5 Td (noconiosis) Tj ET Q EMC\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render multiline text in Japanese for printing","suites":["annotation","TextWidgetAnnotation"],"line":1460,"updatePoint":{"line":1460,"column":61,"index":58944},"code":"    it(\"should render multiline text in Japanese for printing\", async function () {\n      textWidgetDict.set(\"Ff\", AnnotationFieldFlag.MULTILINE);\n      textWidgetDict.get(\"DR\").get(\"Font\").set(\"Goth\", gothRefObj.ref);\n      textWidgetDict.set(\"DA\", \"/Goth 5 Tf\");\n      const textWidgetRef = Ref.get(271, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }, gothRefObj]);\n      const task = new WorkerTask(\"test print\");\n      partialEvaluator.xref = xref;\n      const annotation = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: \"こんにちは世界の\"\n      });\n      const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);\n      expect(appearance).toEqual(\"/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 10 Tm \" + \"2 -5 Td (\\x30\\x53\\x30\\x93\\x30\\x6b\\x30\\x61\\x30\\x6f) Tj\\n\" + \"0 -5 Td (\\x4e\\x16\\x75\\x4c\\x30\\x6e) Tj ET Q EMC\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render multiline text with various EOL for printing","suites":["annotation","TextWidgetAnnotation"],"line":1479,"updatePoint":{"line":1479,"column":66,"index":59995},"code":"    it(\"should render multiline text with various EOL for printing\", async function () {\n      textWidgetDict.set(\"Ff\", AnnotationFieldFlag.MULTILINE);\n      textWidgetDict.set(\"Rect\", [0, 0, 128, 10]);\n      const textWidgetRef = Ref.get(271, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }, helvRefObj]);\n      const task = new WorkerTask(\"test print\");\n      partialEvaluator.xref = xref;\n      const expectedAppearance = \"/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 10 Tm \" + \"2 -5 Td \" + \"(Lorem ipsum dolor sit amet, consectetur adipiscing elit.) Tj\\n\" + \"0 -5 Td \" + \"(Aliquam vitae felis ac lectus bibendum ultricies quis non) Tj\\n\" + \"0 -5 Td \" + \"( diam.) Tj\\n\" + \"0 -5 Td \" + \"(Morbi id porttitor quam, a iaculis dui.) Tj\\n\" + \"0 -5 Td \" + \"(Pellentesque habitant morbi tristique senectus et netus ) Tj\\n\" + \"0 -5 Td \" + \"(et malesuada fames ac turpis egestas.) Tj\\n\" + \"0 -5 Td () Tj\\n\" + \"0 -5 Td () Tj\\n\" + \"0 -5 Td \" + \"(Nulla consectetur, ligula in tincidunt placerat, velit ) Tj\\n\" + \"0 -5 Td \" + \"(augue consectetur orci, sed mattis libero nunc ut massa.) Tj\\n\" + \"0 -5 Td \" + \"(Etiam facilisis tempus interdum.) Tj ET Q EMC\";\n      const annotation = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\\r\" + \"Aliquam vitae felis ac lectus bibendum ultricies quis non diam.\\n\" + \"Morbi id porttitor quam, a iaculis dui.\\r\\n\" + \"Pellentesque habitant morbi tristique senectus et \" + \"netus et malesuada fames ac turpis egestas.\\n\\r\\n\\r\" + \"Nulla consectetur, ligula in tincidunt placerat, \" + \"velit augue consectetur orci, sed mattis libero nunc ut massa.\\r\" + \"Etiam facilisis tempus interdum.\"\n      });\n      const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);\n      expect(appearance).toEqual(expectedAppearance);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render comb for printing","suites":["annotation","TextWidgetAnnotation"],"line":1498,"updatePoint":{"line":1498,"column":39,"index":61999},"code":"    it(\"should render comb for printing\", async function () {\n      textWidgetDict.set(\"Ff\", AnnotationFieldFlag.COMB);\n      textWidgetDict.set(\"MaxLen\", 4);\n      const textWidgetRef = Ref.get(271, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }, helvRefObj]);\n      const task = new WorkerTask(\"test print\");\n      partialEvaluator.xref = xref;\n      const annotation = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: \"aa(aa)a\\\\\"\n      });\n      const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);\n      expect(appearance).toEqual(\"/Tx BMC q BT /Helv 5 Tf 1 0 0 1 2 3.035 Tm\" + \" (a) Tj 8 0 Td (a) Tj 8 0 Td (\\\\() Tj\" + \" 8 0 Td (a) Tj 8 0 Td (a) Tj\" + \" 8 0 Td (\\\\)) Tj 8 0 Td (a) Tj\" + \" 8 0 Td (\\\\\\\\) Tj ET Q EMC\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render comb with Japanese text for printing","suites":["annotation","TextWidgetAnnotation"],"line":1516,"updatePoint":{"line":1516,"column":58,"index":62991},"code":"    it(\"should render comb with Japanese text for printing\", async function () {\n      textWidgetDict.set(\"Ff\", AnnotationFieldFlag.COMB);\n      textWidgetDict.set(\"MaxLen\", 4);\n      textWidgetDict.get(\"DR\").get(\"Font\").set(\"Goth\", gothRefObj.ref);\n      textWidgetDict.set(\"DA\", \"/Goth 5 Tf\");\n      textWidgetDict.set(\"Rect\", [0, 0, 32, 10]);\n      const textWidgetRef = Ref.get(271, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }, gothRefObj]);\n      const task = new WorkerTask(\"test print\");\n      partialEvaluator.xref = xref;\n      const annotation = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: \"こんにちは世界の\"\n      });\n      const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);\n      expect(appearance).toEqual(\"/Tx BMC q BT /Goth 5 Tf 1 0 0 1 2 2 Tm\" + \" (\\x30\\x53) Tj 8 0 Td (\\x30\\x93) Tj 8 0 Td (\\x30\\x6b) Tj\" + \" 8 0 Td (\\x30\\x61) Tj 8 0 Td (\\x30\\x6f) Tj\" + \" 8 0 Td (\\x4e\\x16) Tj 8 0 Td (\\x75\\x4c) Tj\" + \" 8 0 Td (\\x30\\x6e) Tj ET Q EMC\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should save text","suites":["annotation","TextWidgetAnnotation"],"line":1537,"updatePoint":{"line":1537,"column":24,"index":64161},"code":"    it(\"should save text\", async function () {\n      const textWidgetRef = Ref.get(123, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }, helvRefObj]);\n      partialEvaluator.xref = xref;\n      const task = new WorkerTask(\"test save\");\n      const annotation = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: \"hello world\"\n      });\n      const data = await annotation.save(partialEvaluator, task, annotationStorage);\n      expect(data.length).toEqual(2);\n      const [oldData, newData] = data;\n      expect(oldData.ref).toEqual(Ref.get(123, 0));\n      expect(newData.ref).toEqual(Ref.get(2, 0));\n      oldData.data = oldData.data.replace(/\\(D:\\d+\\)/, \"(date)\");\n      expect(oldData.data).toEqual(\"123 0 obj\\n\" + \"<< /Type /Annot /Subtype /Widget /FT /Tx /DA (/Helv 5 Tf) /DR \" + \"<< /Font << /Helv 314 0 R>>>> /Rect [0 0 32 10] \" + \"/V (hello world) /AP << /N 2 0 R>> /M (date)>>\\nendobj\\n\");\n      expect(newData.data).toEqual(\"2 0 obj\\n<< /Length 74 /Subtype /Form /Resources \" + \"<< /Font << /Helv 314 0 R>>>> /BBox [0 0 32 10]>> stream\\n\" + \"/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2 3.04 Td (hello world) Tj \" + \"ET Q EMC\\nendstream\\nendobj\\n\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should save rotated text","suites":["annotation","TextWidgetAnnotation"],"line":1559,"updatePoint":{"line":1559,"column":32,"index":65528},"code":"    it(\"should save rotated text\", async function () {\n      const textWidgetRef = Ref.get(123, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }, helvRefObj]);\n      partialEvaluator.xref = xref;\n      const task = new WorkerTask(\"test save\");\n      const annotation = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: \"hello world\",\n        rotation: 90\n      });\n      const data = await annotation.save(partialEvaluator, task, annotationStorage);\n      expect(data.length).toEqual(2);\n      const [oldData, newData] = data;\n      expect(oldData.ref).toEqual(Ref.get(123, 0));\n      expect(newData.ref).toEqual(Ref.get(2, 0));\n      oldData.data = oldData.data.replace(/\\(D:\\d+\\)/, \"(date)\");\n      expect(oldData.data).toEqual(\"123 0 obj\\n\" + \"<< /Type /Annot /Subtype /Widget /FT /Tx /DA (/Helv 5 Tf) /DR \" + \"<< /Font << /Helv 314 0 R>>>> /Rect [0 0 32 10] \" + \"/V (hello world) /AP << /N 2 0 R>> /M (date) /MK << /R 90>>>>\\nendobj\\n\");\n      expect(newData.data).toEqual(\"2 0 obj\\n<< /Length 74 /Subtype /Form /Resources \" + \"<< /Font << /Helv 314 0 R>>>> /BBox [0 0 32 10] /Matrix [0 1 -1 0 32 0]>> stream\\n\" + \"/Tx BMC q BT /Helv 5 Tf 1 0 0 1 0 0 Tm 2 3.04 Td (hello world) Tj \" + \"ET Q EMC\\nendstream\\nendobj\\n\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should get field object for usage in JS sandbox","suites":["annotation","TextWidgetAnnotation"],"line":1582,"updatePoint":{"line":1582,"column":55,"index":66979},"code":"    it(\"should get field object for usage in JS sandbox\", async function () {\n      const textWidgetRef = Ref.get(123, 0);\n      const xDictRef = Ref.get(141, 0);\n      const dDictRef = Ref.get(262, 0);\n      const next0Ref = Ref.get(314, 0);\n      const next1Ref = Ref.get(271, 0);\n      const next2Ref = Ref.get(577, 0);\n      const next00Ref = Ref.get(413, 0);\n      const xDict = new Dict();\n      const dDict = new Dict();\n      const next0Dict = new Dict();\n      const next1Dict = new Dict();\n      const next2Dict = new Dict();\n      const next00Dict = new Dict();\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }, {\n        ref: xDictRef,\n        data: xDict\n      }, {\n        ref: dDictRef,\n        data: dDict\n      }, {\n        ref: next0Ref,\n        data: next0Dict\n      }, {\n        ref: next00Ref,\n        data: next00Dict\n      }, {\n        ref: next1Ref,\n        data: next1Dict\n      }, {\n        ref: next2Ref,\n        data: next2Dict\n      }]);\n      const JS = Name.get(\"JavaScript\");\n      const additionalActionsDict = new Dict();\n      const eDict = new Dict();\n      eDict.set(\"JS\", \"hello()\");\n      eDict.set(\"S\", JS);\n      additionalActionsDict.set(\"E\", eDict); // Test the cycle detection here.\n\n      xDict.set(\"JS\", \"world()\");\n      xDict.set(\"S\", JS);\n      xDict.set(\"Next\", [next0Ref, next1Ref, next2Ref, xDictRef]);\n      next0Dict.set(\"JS\", \"olleh()\");\n      next0Dict.set(\"S\", JS);\n      next0Dict.set(\"Next\", next00Ref);\n      next00Dict.set(\"JS\", \"foo()\");\n      next00Dict.set(\"S\", JS);\n      next00Dict.set(\"Next\", next0Ref);\n      next1Dict.set(\"JS\", \"dlrow()\");\n      next1Dict.set(\"S\", JS);\n      next1Dict.set(\"Next\", xDictRef);\n      next2Dict.set(\"JS\", \"oof()\");\n      next2Dict.set(\"S\", JS);\n      dDict.set(\"JS\", \"bar()\");\n      dDict.set(\"S\", JS);\n      dDict.set(\"Next\", dDictRef);\n      additionalActionsDict.set(\"D\", dDictRef);\n      additionalActionsDict.set(\"X\", xDictRef);\n      textWidgetDict.set(\"AA\", additionalActionsDict);\n      partialEvaluator.xref = xref;\n      const annotation = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      const fieldObject = await annotation.getFieldObject();\n      const actions = fieldObject.actions;\n      expect(actions[\"Mouse Enter\"]).toEqual([\"hello()\"]);\n      expect(actions[\"Mouse Exit\"]).toEqual([\"world()\", \"olleh()\", \"foo()\", \"dlrow()\", \"oof()\"]);\n      expect(actions[\"Mouse Down\"]).toEqual([\"bar()\"]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should save Japanese text","suites":["annotation","TextWidgetAnnotation"],"line":1653,"updatePoint":{"line":1653,"column":33,"index":69466},"code":"    it(\"should save Japanese text\", async function () {\n      textWidgetDict.get(\"DR\").get(\"Font\").set(\"Goth\", gothRefObj.ref);\n      textWidgetDict.set(\"DA\", \"/Goth 5 Tf\");\n      const textWidgetRef = Ref.get(123, 0);\n      const xref = new XRefMock([{\n        ref: textWidgetRef,\n        data: textWidgetDict\n      }, gothRefObj]);\n      partialEvaluator.xref = xref;\n      const task = new WorkerTask(\"test save\");\n      const annotation = await AnnotationFactory.create(xref, textWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: \"こんにちは世界の\"\n      });\n      const data = await annotation.save(partialEvaluator, task, annotationStorage);\n      const utf16String = \"\\x30\\x53\\x30\\x93\\x30\\x6b\\x30\\x61\\x30\\x6f\\x4e\\x16\\x75\\x4c\\x30\\x6e\";\n      expect(data.length).toEqual(2);\n      const [oldData, newData] = data;\n      expect(oldData.ref).toEqual(Ref.get(123, 0));\n      expect(newData.ref).toEqual(Ref.get(2, 0));\n      oldData.data = oldData.data.replace(/\\(D:\\d+\\)/, \"(date)\");\n      expect(oldData.data).toEqual(\"123 0 obj\\n\" + \"<< /Type /Annot /Subtype /Widget /FT /Tx /DA (/Goth 5 Tf) /DR \" + \"<< /Font << /Helv 314 0 R /Goth 159 0 R>>>> /Rect [0 0 32 10] \" + `/V (\\xfe\\xff${utf16String}) /AP << /N 2 0 R>> /M (date)>>\\nendobj\\n`);\n      expect(newData.data).toEqual(\"2 0 obj\\n<< /Length 76 /Subtype /Form /Resources \" + \"<< /Font << /Helv 314 0 R /Goth 159 0 R>>>> /BBox [0 0 32 10]>> stream\\n\" + `/Tx BMC q BT /Goth 5 Tf 1 0 0 1 0 0 Tm 2 2 Td (${utf16String}) Tj ` + \"ET Q EMC\\nendstream\\nendobj\\n\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle checkboxes with export value","suites":["annotation","ButtonWidgetAnnotation"],"line":1690,"updatePoint":{"line":1690,"column":50,"index":71488},"code":"    it(\"should handle checkboxes with export value\", async function () {\n      buttonWidgetDict.set(\"V\", Name.get(\"Checked\"));\n      buttonWidgetDict.set(\"DV\", Name.get(\"Off\"));\n      const appearanceStatesDict = new Dict();\n      const normalAppearanceDict = new Dict();\n      normalAppearanceDict.set(\"Off\", 0);\n      normalAppearanceDict.set(\"Checked\", 1);\n      appearanceStatesDict.set(\"N\", normalAppearanceDict);\n      buttonWidgetDict.set(\"AP\", appearanceStatesDict);\n      const buttonWidgetRef = Ref.get(124, 0);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.checkBox).toEqual(true);\n      expect(data.fieldValue).toEqual(\"Checked\");\n      expect(data.defaultFieldValue).toEqual(\"Off\");\n      expect(data.radioButton).toEqual(false);\n      expect(data.exportValue).toEqual(\"Checked\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle checkboxes without export value","suites":["annotation","ButtonWidgetAnnotation"],"line":1714,"updatePoint":{"line":1714,"column":53,"index":72561},"code":"    it(\"should handle checkboxes without export value\", async function () {\n      buttonWidgetDict.set(\"V\", Name.get(\"Checked\"));\n      buttonWidgetDict.set(\"DV\", Name.get(\"Off\"));\n      const buttonWidgetRef = Ref.get(124, 0);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.checkBox).toEqual(true);\n      expect(data.fieldValue).toEqual(\"Checked\");\n      expect(data.defaultFieldValue).toEqual(\"Off\");\n      expect(data.radioButton).toEqual(false);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle checkboxes without /Off appearance","suites":["annotation","ButtonWidgetAnnotation"],"line":1731,"updatePoint":{"line":1731,"column":56,"index":73289},"code":"    it(\"should handle checkboxes without /Off appearance\", async function () {\n      buttonWidgetDict.set(\"V\", Name.get(\"Checked\"));\n      buttonWidgetDict.set(\"DV\", Name.get(\"Off\"));\n      const appearanceStatesDict = new Dict();\n      const normalAppearanceDict = new Dict();\n      normalAppearanceDict.set(\"Checked\", 1);\n      appearanceStatesDict.set(\"N\", normalAppearanceDict);\n      buttonWidgetDict.set(\"AP\", appearanceStatesDict);\n      const buttonWidgetRef = Ref.get(124, 0);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.checkBox).toEqual(true);\n      expect(data.fieldValue).toEqual(\"Checked\");\n      expect(data.defaultFieldValue).toEqual(\"Off\");\n      expect(data.radioButton).toEqual(false);\n      expect(data.exportValue).toEqual(\"Checked\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render checkbox with fallback font for printing","suites":["annotation","ButtonWidgetAnnotation"],"line":1754,"updatePoint":{"line":1754,"column":62,"index":74329},"code":"    it(\"should render checkbox with fallback font for printing\", async function () {\n      const appearanceStatesDict = new Dict();\n      const normalAppearanceDict = new Dict();\n      const checkedAppearanceDict = new Dict();\n      const uncheckedAppearanceDict = new Dict();\n      const checkedStream = new StringStream(\"/ 12 Tf (4) Tj\");\n      checkedStream.dict = checkedAppearanceDict;\n      const uncheckedStream = new StringStream(\"\");\n      uncheckedStream.dict = uncheckedAppearanceDict;\n      checkedAppearanceDict.set(\"BBox\", [0, 0, 8, 8]);\n      checkedAppearanceDict.set(\"FormType\", 1);\n      checkedAppearanceDict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n      normalAppearanceDict.set(\"Checked\", checkedStream);\n      normalAppearanceDict.set(\"Off\", uncheckedStream);\n      appearanceStatesDict.set(\"N\", normalAppearanceDict);\n      buttonWidgetDict.set(\"AP\", appearanceStatesDict);\n      const buttonWidgetRef = Ref.get(124, 0);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      const task = new WorkerTask(\"test print\");\n      const checkboxEvaluator = partialEvaluator.clone({\n        ignoreErrors: true\n      });\n      const annotation = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: true\n      });\n      const operatorList = await annotation.getOperatorList(checkboxEvaluator, task, RenderingIntentFlag.PRINT, false, annotationStorage);\n      expect(operatorList.argsArray.length).toEqual(5);\n      expect(operatorList.fnArray).toEqual([OPS.beginAnnotation, OPS.dependency, OPS.setFont, OPS.showText, OPS.endAnnotation]);\n      expect(operatorList.argsArray[0]).toEqual([\"124R\", [0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0], false]);\n      expect(operatorList.argsArray[3][0][0].unicode).toEqual(\"4\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render checkboxes for printing","suites":["annotation","ButtonWidgetAnnotation"],"line":1790,"updatePoint":{"line":1790,"column":45,"index":76255},"code":"    it(\"should render checkboxes for printing\", async function () {\n      const appearanceStatesDict = new Dict();\n      const normalAppearanceDict = new Dict();\n      const checkedAppearanceDict = new Dict();\n      const uncheckedAppearanceDict = new Dict();\n      const checkedStream = new StringStream(\"0.1 0.2 0.3 rg\");\n      checkedStream.dict = checkedAppearanceDict;\n      const uncheckedStream = new StringStream(\"0.3 0.2 0.1 rg\");\n      uncheckedStream.dict = uncheckedAppearanceDict;\n      checkedAppearanceDict.set(\"BBox\", [0, 0, 8, 8]);\n      checkedAppearanceDict.set(\"FormType\", 1);\n      checkedAppearanceDict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n      normalAppearanceDict.set(\"Checked\", checkedStream);\n      normalAppearanceDict.set(\"Off\", uncheckedStream);\n      appearanceStatesDict.set(\"N\", normalAppearanceDict);\n      buttonWidgetDict.set(\"AP\", appearanceStatesDict);\n      const buttonWidgetRef = Ref.get(124, 0);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      const task = new WorkerTask(\"test print\");\n      const annotation = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: true\n      });\n      let operatorList = await annotation.getOperatorList(partialEvaluator, task, RenderingIntentFlag.PRINT, false, annotationStorage);\n      expect(operatorList.argsArray.length).toEqual(3);\n      expect(operatorList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);\n      expect(operatorList.argsArray[0]).toEqual([\"124R\", [0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0], false]);\n      expect(operatorList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));\n      annotationStorage.set(annotation.data.id, {\n        value: false\n      });\n      operatorList = await annotation.getOperatorList(partialEvaluator, task, RenderingIntentFlag.PRINT, false, annotationStorage);\n      expect(operatorList.argsArray.length).toEqual(3);\n      expect(operatorList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);\n      expect(operatorList.argsArray[0]).toEqual([\"124R\", [0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0], false]);\n      expect(operatorList.argsArray[1]).toEqual(new Uint8ClampedArray([76, 51, 26]));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render checkboxes for printing twice","suites":["annotation","ButtonWidgetAnnotation"],"line":1831,"updatePoint":{"line":1831,"column":51,"index":78682},"code":"    it(\"should render checkboxes for printing twice\", async function () {\n      const appearanceStatesDict = new Dict();\n      const normalAppearanceDict = new Dict();\n      const checkedAppearanceDict = new Dict();\n      const uncheckedAppearanceDict = new Dict();\n      const checkedStream = new StringStream(\"0.1 0.2 0.3 rg\");\n      checkedStream.dict = checkedAppearanceDict;\n      const uncheckedStream = new StringStream(\"0.3 0.2 0.1 rg\");\n      uncheckedStream.dict = uncheckedAppearanceDict;\n      checkedAppearanceDict.set(\"BBox\", [0, 0, 8, 8]);\n      checkedAppearanceDict.set(\"FormType\", 1);\n      checkedAppearanceDict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n      normalAppearanceDict.set(\"Checked\", checkedStream);\n      normalAppearanceDict.set(\"Off\", uncheckedStream);\n      appearanceStatesDict.set(\"N\", normalAppearanceDict);\n      buttonWidgetDict.set(\"AP\", appearanceStatesDict);\n      buttonWidgetDict.set(\"AS\", Name.get(\"Off\"));\n      const buttonWidgetRef = Ref.get(1249, 0);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      const task = new WorkerTask(\"test print\");\n      const annotation = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n\n      for (let i = 0; i < 2; i++) {\n        annotationStorage.set(annotation.data.id, {\n          value: true\n        });\n        const operatorList = await annotation.getOperatorList(partialEvaluator, task, RenderingIntentFlag.PRINT, false, annotationStorage);\n        expect(operatorList.argsArray.length).toEqual(3);\n        expect(operatorList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);\n        expect(operatorList.argsArray[0]).toEqual([\"1249R\", [0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0], false]);\n        expect(operatorList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));\n      }\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render checkboxes for printing using normal appearance","suites":["annotation","ButtonWidgetAnnotation"],"line":1868,"updatePoint":{"line":1868,"column":69,"index":80661},"code":"    it(\"should render checkboxes for printing using normal appearance\", async function () {\n      const appearanceStatesDict = new Dict();\n      const normalAppearanceDict = new Dict();\n      const checkedAppearanceDict = new Dict();\n      const uncheckedAppearanceDict = new Dict();\n      const checkedStream = new StringStream(\"0.1 0.2 0.3 rg\");\n      checkedStream.dict = checkedAppearanceDict;\n      const uncheckedStream = new StringStream(\"0.3 0.2 0.1 rg\");\n      uncheckedStream.dict = uncheckedAppearanceDict;\n      checkedAppearanceDict.set(\"BBox\", [0, 0, 8, 8]);\n      checkedAppearanceDict.set(\"FormType\", 1);\n      checkedAppearanceDict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n      normalAppearanceDict.set(\"Checked\", checkedStream);\n      normalAppearanceDict.set(\"Off\", uncheckedStream);\n      appearanceStatesDict.set(\"N\", normalAppearanceDict);\n      buttonWidgetDict.set(\"AP\", appearanceStatesDict);\n      buttonWidgetDict.set(\"AS\", Name.get(\"Checked\"));\n      const buttonWidgetRef = Ref.get(124, 0);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      const task = new WorkerTask(\"test print\");\n      const annotation = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      const operatorList = await annotation.getOperatorList(partialEvaluator, task, RenderingIntentFlag.PRINT, false, annotationStorage);\n      expect(operatorList.argsArray.length).toEqual(3);\n      expect(operatorList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);\n      expect(operatorList.argsArray[0]).toEqual([\"124R\", [0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0], false]);\n      expect(operatorList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should save checkboxes","suites":["annotation","ButtonWidgetAnnotation"],"line":1899,"updatePoint":{"line":1899,"column":30,"index":82462},"code":"    it(\"should save checkboxes\", async function () {\n      const appearanceStatesDict = new Dict();\n      const normalAppearanceDict = new Dict();\n      normalAppearanceDict.set(\"Checked\", Ref.get(314, 0));\n      normalAppearanceDict.set(\"Off\", Ref.get(271, 0));\n      appearanceStatesDict.set(\"N\", normalAppearanceDict);\n      buttonWidgetDict.set(\"AP\", appearanceStatesDict);\n      buttonWidgetDict.set(\"V\", Name.get(\"Off\"));\n      const buttonWidgetRef = Ref.get(123, 0);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      partialEvaluator.xref = xref;\n      const task = new WorkerTask(\"test save\");\n      const annotation = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: true\n      });\n      const [oldData] = await annotation.save(partialEvaluator, task, annotationStorage);\n      oldData.data = oldData.data.replace(/\\(D:\\d+\\)/, \"(date)\");\n      expect(oldData.ref).toEqual(Ref.get(123, 0));\n      expect(oldData.data).toEqual(\"123 0 obj\\n\" + \"<< /Type /Annot /Subtype /Widget /FT /Btn \" + \"/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> \" + \"/V /Checked /AS /Checked /M (date)>>\\nendobj\\n\");\n      annotationStorage.set(annotation.data.id, {\n        value: false\n      });\n      const data = await annotation.save(partialEvaluator, task, annotationStorage);\n      expect(data).toEqual(null);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should save rotated checkboxes","suites":["annotation","ButtonWidgetAnnotation"],"line":1929,"updatePoint":{"line":1929,"column":38,"index":83987},"code":"    it(\"should save rotated checkboxes\", async function () {\n      const appearanceStatesDict = new Dict();\n      const normalAppearanceDict = new Dict();\n      normalAppearanceDict.set(\"Checked\", Ref.get(314, 0));\n      normalAppearanceDict.set(\"Off\", Ref.get(271, 0));\n      appearanceStatesDict.set(\"N\", normalAppearanceDict);\n      buttonWidgetDict.set(\"AP\", appearanceStatesDict);\n      buttonWidgetDict.set(\"V\", Name.get(\"Off\"));\n      const buttonWidgetRef = Ref.get(123, 0);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      partialEvaluator.xref = xref;\n      const task = new WorkerTask(\"test save\");\n      const annotation = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: true,\n        rotation: 180\n      });\n      const [oldData] = await annotation.save(partialEvaluator, task, annotationStorage);\n      oldData.data = oldData.data.replace(/\\(D:\\d+\\)/, \"(date)\");\n      expect(oldData.ref).toEqual(Ref.get(123, 0));\n      expect(oldData.data).toEqual(\"123 0 obj\\n\" + \"<< /Type /Annot /Subtype /Widget /FT /Btn \" + \"/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> \" + \"/V /Checked /AS /Checked /M (date) /MK << /R 180>>>>\\nendobj\\n\");\n      annotationStorage.set(annotation.data.id, {\n        value: false\n      });\n      const data = await annotation.save(partialEvaluator, task, annotationStorage);\n      expect(data).toEqual(null);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle radio buttons with a field value","suites":["annotation","ButtonWidgetAnnotation"],"line":1960,"updatePoint":{"line":1960,"column":54,"index":85567},"code":"    it(\"should handle radio buttons with a field value\", async function () {\n      const parentDict = new Dict();\n      parentDict.set(\"V\", Name.get(\"1\"));\n      const normalAppearanceStateDict = new Dict();\n      normalAppearanceStateDict.set(\"2\", null);\n      const appearanceStatesDict = new Dict();\n      appearanceStatesDict.set(\"N\", normalAppearanceStateDict);\n      buttonWidgetDict.set(\"Ff\", AnnotationFieldFlag.RADIO);\n      buttonWidgetDict.set(\"Parent\", parentDict);\n      buttonWidgetDict.set(\"AP\", appearanceStatesDict);\n      const buttonWidgetRef = Ref.get(124, 0);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.checkBox).toEqual(false);\n      expect(data.radioButton).toEqual(true);\n      expect(data.fieldValue).toEqual(\"1\");\n      expect(data.buttonValue).toEqual(\"2\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle radio buttons with a field value that's not an ASCII string","suites":["annotation","ButtonWidgetAnnotation"],"line":1984,"updatePoint":{"line":1984,"column":81,"index":86658},"code":"    it(\"should handle radio buttons with a field value that's not an ASCII string\", async function () {\n      const parentDict = new Dict();\n      parentDict.set(\"V\", Name.get(\"\\x91I=\\x91\\xf0\\x93\\xe0\\x97e3\"));\n      const normalAppearanceStateDict = new Dict();\n      normalAppearanceStateDict.set(\"\\x91I=\\x91\\xf0\\x93\\xe0\\x97e3\", null);\n      const appearanceStatesDict = new Dict();\n      appearanceStatesDict.set(\"N\", normalAppearanceStateDict);\n      buttonWidgetDict.set(\"Ff\", AnnotationFieldFlag.RADIO);\n      buttonWidgetDict.set(\"Parent\", parentDict);\n      buttonWidgetDict.set(\"AP\", appearanceStatesDict);\n      const buttonWidgetRef = Ref.get(124, 0);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.checkBox).toEqual(false);\n      expect(data.radioButton).toEqual(true);\n      expect(data.fieldValue).toEqual(\"‚I=‚ðﬁàŠe3\");\n      expect(data.buttonValue).toEqual(\"‚I=‚ðﬁàŠe3\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle radio buttons without a field value","suites":["annotation","ButtonWidgetAnnotation"],"line":2008,"updatePoint":{"line":2008,"column":57,"index":87797},"code":"    it(\"should handle radio buttons without a field value\", async function () {\n      const normalAppearanceStateDict = new Dict();\n      normalAppearanceStateDict.set(\"2\", null);\n      const appearanceStatesDict = new Dict();\n      appearanceStatesDict.set(\"N\", normalAppearanceStateDict);\n      buttonWidgetDict.set(\"Ff\", AnnotationFieldFlag.RADIO);\n      buttonWidgetDict.set(\"AP\", appearanceStatesDict);\n      const buttonWidgetRef = Ref.get(124, 0);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.checkBox).toEqual(false);\n      expect(data.radioButton).toEqual(true);\n      expect(data.fieldValue).toEqual(null);\n      expect(data.buttonValue).toEqual(\"2\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render radio buttons for printing","suites":["annotation","ButtonWidgetAnnotation"],"line":2029,"updatePoint":{"line":2029,"column":48,"index":88727},"code":"    it(\"should render radio buttons for printing\", async function () {\n      const appearanceStatesDict = new Dict();\n      const normalAppearanceDict = new Dict();\n      const checkedAppearanceDict = new Dict();\n      const uncheckedAppearanceDict = new Dict();\n      const checkedStream = new StringStream(\"0.1 0.2 0.3 rg\");\n      checkedStream.dict = checkedAppearanceDict;\n      const uncheckedStream = new StringStream(\"0.3 0.2 0.1 rg\");\n      uncheckedStream.dict = uncheckedAppearanceDict;\n      checkedAppearanceDict.set(\"BBox\", [0, 0, 8, 8]);\n      checkedAppearanceDict.set(\"FormType\", 1);\n      checkedAppearanceDict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n      normalAppearanceDict.set(\"Checked\", checkedStream);\n      normalAppearanceDict.set(\"Off\", uncheckedStream);\n      appearanceStatesDict.set(\"N\", normalAppearanceDict);\n      buttonWidgetDict.set(\"Ff\", AnnotationFieldFlag.RADIO);\n      buttonWidgetDict.set(\"AP\", appearanceStatesDict);\n      const buttonWidgetRef = Ref.get(124, 0);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      const task = new WorkerTask(\"test print\");\n      const annotation = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: true\n      });\n      let operatorList = await annotation.getOperatorList(partialEvaluator, task, RenderingIntentFlag.PRINT, false, annotationStorage);\n      expect(operatorList.argsArray.length).toEqual(3);\n      expect(operatorList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);\n      expect(operatorList.argsArray[0]).toEqual([\"124R\", [0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0], false]);\n      expect(operatorList.argsArray[1]).toEqual(new Uint8ClampedArray([26, 51, 76]));\n      annotationStorage.set(annotation.data.id, {\n        value: false\n      });\n      operatorList = await annotation.getOperatorList(partialEvaluator, task, RenderingIntentFlag.PRINT, false, annotationStorage);\n      expect(operatorList.argsArray.length).toEqual(3);\n      expect(operatorList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);\n      expect(operatorList.argsArray[0]).toEqual([\"124R\", [0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0], false]);\n      expect(operatorList.argsArray[1]).toEqual(new Uint8ClampedArray([76, 51, 26]));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render radio buttons for printing using normal appearance","suites":["annotation","ButtonWidgetAnnotation"],"line":2071,"updatePoint":{"line":2071,"column":72,"index":91236},"code":"    it(\"should render radio buttons for printing using normal appearance\", async function () {\n      const appearanceStatesDict = new Dict();\n      const normalAppearanceDict = new Dict();\n      const checkedAppearanceDict = new Dict();\n      const uncheckedAppearanceDict = new Dict();\n      const checkedStream = new StringStream(\"0.1 0.2 0.3 rg\");\n      checkedStream.dict = checkedAppearanceDict;\n      const uncheckedStream = new StringStream(\"0.3 0.2 0.1 rg\");\n      uncheckedStream.dict = uncheckedAppearanceDict;\n      checkedAppearanceDict.set(\"BBox\", [0, 0, 8, 8]);\n      checkedAppearanceDict.set(\"FormType\", 1);\n      checkedAppearanceDict.set(\"Matrix\", [1, 0, 0, 1, 0, 0]);\n      normalAppearanceDict.set(\"Checked\", checkedStream);\n      normalAppearanceDict.set(\"Off\", uncheckedStream);\n      appearanceStatesDict.set(\"N\", normalAppearanceDict);\n      buttonWidgetDict.set(\"Ff\", AnnotationFieldFlag.RADIO);\n      buttonWidgetDict.set(\"AP\", appearanceStatesDict);\n      buttonWidgetDict.set(\"AS\", Name.get(\"Off\"));\n      const buttonWidgetRef = Ref.get(124, 0);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      const task = new WorkerTask(\"test print\");\n      const annotation = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      const operatorList = await annotation.getOperatorList(partialEvaluator, task, RenderingIntentFlag.PRINT, false, annotationStorage);\n      expect(operatorList.argsArray.length).toEqual(3);\n      expect(operatorList.fnArray).toEqual([OPS.beginAnnotation, OPS.setFillRGBColor, OPS.endAnnotation]);\n      expect(operatorList.argsArray[0]).toEqual([\"124R\", [0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0], false]);\n      expect(operatorList.argsArray[1]).toEqual(new Uint8ClampedArray([76, 51, 26]));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should save radio buttons","suites":["annotation","ButtonWidgetAnnotation"],"line":2103,"updatePoint":{"line":2103,"column":33,"index":93097},"code":"    it(\"should save radio buttons\", async function () {\n      const appearanceStatesDict = new Dict();\n      const normalAppearanceDict = new Dict();\n      normalAppearanceDict.set(\"Checked\", Ref.get(314, 0));\n      normalAppearanceDict.set(\"Off\", Ref.get(271, 0));\n      appearanceStatesDict.set(\"N\", normalAppearanceDict);\n      buttonWidgetDict.set(\"Ff\", AnnotationFieldFlag.RADIO);\n      buttonWidgetDict.set(\"AP\", appearanceStatesDict);\n      const buttonWidgetRef = Ref.get(123, 0);\n      const parentRef = Ref.get(456, 0);\n      const parentDict = new Dict();\n      parentDict.set(\"V\", Name.get(\"Off\"));\n      parentDict.set(\"Kids\", [buttonWidgetRef]);\n      buttonWidgetDict.set(\"Parent\", parentRef);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }, {\n        ref: parentRef,\n        data: parentDict\n      }]);\n      parentDict.xref = xref;\n      buttonWidgetDict.xref = xref;\n      partialEvaluator.xref = xref;\n      const task = new WorkerTask(\"test save\");\n      const annotation = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: true\n      });\n      let data = await annotation.save(partialEvaluator, task, annotationStorage);\n      expect(data.length).toEqual(2);\n      const [radioData, parentData] = data;\n      radioData.data = radioData.data.replace(/\\(D:\\d+\\)/, \"(date)\");\n      expect(radioData.ref).toEqual(Ref.get(123, 0));\n      expect(radioData.data).toEqual(\"123 0 obj\\n\" + \"<< /Type /Annot /Subtype /Widget /FT /Btn /Ff 32768 \" + \"/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> \" + \"/Parent 456 0 R /AS /Checked /M (date)>>\\nendobj\\n\");\n      expect(parentData.ref).toEqual(Ref.get(456, 0));\n      expect(parentData.data).toEqual(\"456 0 obj\\n<< /V /Checked /Kids [123 0 R]>>\\nendobj\\n\");\n      annotationStorage.set(annotation.data.id, {\n        value: false\n      });\n      data = await annotation.save(partialEvaluator, task, annotationStorage);\n      expect(data).toEqual(null);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should save radio buttons without a field value","suites":["annotation","ButtonWidgetAnnotation"],"line":2147,"updatePoint":{"line":2147,"column":55,"index":95238},"code":"    it(\"should save radio buttons without a field value\", async function () {\n      const appearanceStatesDict = new Dict();\n      const normalAppearanceDict = new Dict();\n      normalAppearanceDict.set(\"Checked\", Ref.get(314, 0));\n      normalAppearanceDict.set(\"Off\", Ref.get(271, 0));\n      appearanceStatesDict.set(\"N\", normalAppearanceDict);\n      buttonWidgetDict.set(\"Ff\", AnnotationFieldFlag.RADIO);\n      buttonWidgetDict.set(\"AP\", appearanceStatesDict);\n      const buttonWidgetRef = Ref.get(123, 0);\n      const parentRef = Ref.get(456, 0);\n      const parentDict = new Dict();\n      parentDict.set(\"Kids\", [buttonWidgetRef]);\n      buttonWidgetDict.set(\"Parent\", parentRef);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }, {\n        ref: parentRef,\n        data: parentDict\n      }]);\n      parentDict.xref = xref;\n      buttonWidgetDict.xref = xref;\n      partialEvaluator.xref = xref;\n      const task = new WorkerTask(\"test save\");\n      const annotation = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: true\n      });\n      const data = await annotation.save(partialEvaluator, task, annotationStorage);\n      expect(data.length).toEqual(2);\n      const [radioData, parentData] = data;\n      radioData.data = radioData.data.replace(/\\(D:\\d+\\)/, \"(date)\");\n      expect(radioData.ref).toEqual(Ref.get(123, 0));\n      expect(radioData.data).toEqual(\"123 0 obj\\n\" + \"<< /Type /Annot /Subtype /Widget /FT /Btn /Ff 32768 \" + \"/AP << /N << /Checked 314 0 R /Off 271 0 R>>>> \" + \"/Parent 456 0 R /AS /Checked /M (date)>>\\nendobj\\n\");\n      expect(parentData.ref).toEqual(Ref.get(456, 0));\n      expect(parentData.data).toEqual(\"456 0 obj\\n<< /Kids [123 0 R] /V /Checked>>\\nendobj\\n\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should save nothing","suites":["annotation","ButtonWidgetAnnotation"],"line":2185,"updatePoint":{"line":2185,"column":27,"index":97115},"code":"    it(\"should save nothing\", async function () {\n      const buttonWidgetRef = Ref.get(124, 0);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      const task = new WorkerTask(\"test save\");\n      const annotation = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      const data = await annotation.save(partialEvaluator, task, annotationStorage);\n      expect(data).toEqual(null);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle push buttons","suites":["annotation","ButtonWidgetAnnotation"],"line":2197,"updatePoint":{"line":2197,"column":34,"index":97655},"code":"    it(\"should handle push buttons\", async function () {\n      const buttonWidgetRef = Ref.get(124, 0);\n      buttonWidgetDict.set(\"Ff\", AnnotationFieldFlag.PUSHBUTTON);\n      const actionDict = new Dict();\n      actionDict.set(\"S\", Name.get(\"JavaScript\"));\n      actionDict.set(\"JS\", \"do_something();\");\n      buttonWidgetDict.set(\"A\", actionDict);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.pushButton).toEqual(true);\n      expect(data.actions.Action).toEqual([\"do_something();\"]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle push buttons that act as a tooltip only","suites":["annotation","ButtonWidgetAnnotation"],"line":2215,"updatePoint":{"line":2215,"column":61,"index":98445},"code":"    it(\"should handle push buttons that act as a tooltip only\", async function () {\n      const buttonWidgetRef = Ref.get(124, 0);\n      buttonWidgetDict.set(\"Ff\", AnnotationFieldFlag.PUSHBUTTON);\n      buttonWidgetDict.set(\"TU\", \"An alternative text\");\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.pushButton).toEqual(true);\n      expect(data.alternativeText).toEqual(\"An alternative text\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle URL in A dict in push buttons","suites":["annotation","ButtonWidgetAnnotation"],"line":2230,"updatePoint":{"line":2230,"column":51,"index":99105},"code":"    it(\"should handle URL in A dict in push buttons\", async function () {\n      const buttonWidgetRef = Ref.get(124, 0);\n      buttonWidgetDict.set(\"Ff\", AnnotationFieldFlag.PUSHBUTTON);\n      const actionDict = new Dict();\n      actionDict.set(\"S\", Name.get(\"JavaScript\"));\n      actionDict.set(\"JS\", \"app.launchURL('https://developer.mozilla.org/en-US/', true)\");\n      buttonWidgetDict.set(\"A\", actionDict);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.url).toEqual(\"https://developer.mozilla.org/en-US/\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle URL in AA dict in push buttons","suites":["annotation","ButtonWidgetAnnotation"],"line":2246,"updatePoint":{"line":2246,"column":52,"index":99827},"code":"    it(\"should handle URL in AA dict in push buttons\", async function () {\n      const buttonWidgetRef = Ref.get(124, 0);\n      buttonWidgetDict.set(\"Ff\", AnnotationFieldFlag.PUSHBUTTON); // D stands for MouseDown.\n\n      const dDict = new Dict();\n      dDict.set(\"S\", Name.get(\"JavaScript\"));\n      dDict.set(\"JS\", \"app.launchURL('https://developer.mozilla.org/en-US/', true)\");\n      const actionDict = new Dict();\n      actionDict.set(\"D\", dDict);\n      buttonWidgetDict.set(\"AA\", actionDict);\n      const xref = new XRefMock([{\n        ref: buttonWidgetRef,\n        data: buttonWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, buttonWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.url).toEqual(\"https://developer.mozilla.org/en-US/\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle missing option arrays","suites":["annotation","ChoiceWidgetAnnotation"],"line":2293,"updatePoint":{"line":2293,"column":43,"index":101639},"code":"    it(\"should handle missing option arrays\", async function () {\n      const choiceWidgetRef = Ref.get(122, 0);\n      const xref = new XRefMock([{\n        ref: choiceWidgetRef,\n        data: choiceWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, choiceWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.options).toEqual([]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle option arrays with array elements","suites":["annotation","ChoiceWidgetAnnotation"],"line":2305,"updatePoint":{"line":2305,"column":55,"index":102108},"code":"    it(\"should handle option arrays with array elements\", async function () {\n      const optionBarRef = Ref.get(20, 0);\n      const optionBarStr = \"Bar\";\n      const optionOneRef = Ref.get(10, 0);\n      const optionOneArr = [\"bar_export\", optionBarRef];\n      const options = [[\"foo_export\", \"Foo\"], optionOneRef];\n      const expected = [{\n        exportValue: \"foo_export\",\n        displayValue: \"Foo\"\n      }, {\n        exportValue: \"bar_export\",\n        displayValue: \"Bar\"\n      }];\n      choiceWidgetDict.set(\"Opt\", options);\n      const choiceWidgetRef = Ref.get(123, 0);\n      const xref = new XRefMock([{\n        ref: choiceWidgetRef,\n        data: choiceWidgetDict\n      }, {\n        ref: optionBarRef,\n        data: optionBarStr\n      }, {\n        ref: optionOneRef,\n        data: optionOneArr\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, choiceWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.options).toEqual(expected);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle option arrays with string elements","suites":["annotation","ChoiceWidgetAnnotation"],"line":2336,"updatePoint":{"line":2336,"column":56,"index":103169},"code":"    it(\"should handle option arrays with string elements\", async function () {\n      const optionBarRef = Ref.get(10, 0);\n      const optionBarStr = \"Bar\";\n      const options = [\"Foo\", optionBarRef];\n      const expected = [{\n        exportValue: \"Foo\",\n        displayValue: \"Foo\"\n      }, {\n        exportValue: \"Bar\",\n        displayValue: \"Bar\"\n      }];\n      choiceWidgetDict.set(\"Opt\", options);\n      const choiceWidgetRef = Ref.get(981, 0);\n      const xref = new XRefMock([{\n        ref: choiceWidgetRef,\n        data: choiceWidgetDict\n      }, {\n        ref: optionBarRef,\n        data: optionBarStr\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, choiceWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.options).toEqual(expected);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle inherited option arrays (issue 8094)","suites":["annotation","ChoiceWidgetAnnotation"],"line":2362,"updatePoint":{"line":2362,"column":58,"index":104037},"code":"    it(\"should handle inherited option arrays (issue 8094)\", async function () {\n      const options = [[\"Value1\", \"Description1\"], [\"Value2\", \"Description2\"]];\n      const expected = [{\n        exportValue: \"Value1\",\n        displayValue: \"Description1\"\n      }, {\n        exportValue: \"Value2\",\n        displayValue: \"Description2\"\n      }];\n      const parentDict = new Dict();\n      parentDict.set(\"Opt\", options);\n      choiceWidgetDict.set(\"Parent\", parentDict);\n      const choiceWidgetRef = Ref.get(123, 0);\n      const xref = new XRefMock([{\n        ref: choiceWidgetRef,\n        data: choiceWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, choiceWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.options).toEqual(expected);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should decode form values","suites":["annotation","ChoiceWidgetAnnotation"],"line":2385,"updatePoint":{"line":2385,"column":33,"index":104878},"code":"    it(\"should decode form values\", async function () {\n      const encodedString = \"\\xFE\\xFF\\x00F\\x00o\\x00o\";\n      const decodedString = \"Foo\";\n      choiceWidgetDict.set(\"Opt\", [encodedString]);\n      choiceWidgetDict.set(\"V\", encodedString);\n      choiceWidgetDict.set(\"DV\", Name.get(\"foo\"));\n      const choiceWidgetRef = Ref.get(984, 0);\n      const xref = new XRefMock([{\n        ref: choiceWidgetRef,\n        data: choiceWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, choiceWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.fieldValue).toEqual([decodedString]);\n      expect(data.defaultFieldValue).toEqual(\"foo\");\n      expect(data.options).toEqual([{\n        exportValue: decodedString,\n        displayValue: decodedString\n      }]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should convert the field value to an array","suites":["annotation","ChoiceWidgetAnnotation"],"line":2407,"updatePoint":{"line":2407,"column":50,"index":105773},"code":"    it(\"should convert the field value to an array\", async function () {\n      const inputs = [null, \"Foo\", [\"Foo\", \"Bar\"]];\n      const outputs = [[], [\"Foo\"], [\"Foo\", \"Bar\"]];\n      let promise = Promise.resolve();\n\n      for (let i = 0, ii = inputs.length; i < ii; i++) {\n        promise = promise.then(() => {\n          choiceWidgetDict.set(\"V\", inputs[i]);\n          const choiceWidgetRef = Ref.get(968, 0);\n          const xref = new XRefMock([{\n            ref: choiceWidgetRef,\n            data: choiceWidgetDict\n          }]);\n          return AnnotationFactory.create(xref, choiceWidgetRef, pdfManagerMock, idFactoryMock).then(({\n            data\n          }) => {\n            expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n            expect(data.fieldValue).toEqual(outputs[i]);\n          });\n        });\n      }\n\n      await promise;\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle unknown flags","suites":["annotation","ChoiceWidgetAnnotation"],"line":2431,"updatePoint":{"line":2431,"column":35,"index":106626},"code":"    it(\"should handle unknown flags\", async function () {\n      const choiceWidgetRef = Ref.get(166, 0);\n      const xref = new XRefMock([{\n        ref: choiceWidgetRef,\n        data: choiceWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, choiceWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.readOnly).toEqual(false);\n      expect(data.hidden).toEqual(false);\n      expect(data.combo).toEqual(false);\n      expect(data.multiSelect).toEqual(false);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should not set invalid flags","suites":["annotation","ChoiceWidgetAnnotation"],"line":2446,"updatePoint":{"line":2446,"column":36,"index":107210},"code":"    it(\"should not set invalid flags\", async function () {\n      choiceWidgetDict.set(\"Ff\", \"readonly\");\n      const choiceWidgetRef = Ref.get(165, 0);\n      const xref = new XRefMock([{\n        ref: choiceWidgetRef,\n        data: choiceWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, choiceWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.readOnly).toEqual(false);\n      expect(data.hidden).toEqual(false);\n      expect(data.combo).toEqual(false);\n      expect(data.multiSelect).toEqual(false);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set valid flags","suites":["annotation","ChoiceWidgetAnnotation"],"line":2462,"updatePoint":{"line":2462,"column":30,"index":107834},"code":"    it(\"should set valid flags\", async function () {\n      choiceWidgetDict.set(\"Ff\", AnnotationFieldFlag.READONLY + AnnotationFieldFlag.COMBO + AnnotationFieldFlag.MULTISELECT);\n      const choiceWidgetRef = Ref.get(512, 0);\n      const xref = new XRefMock([{\n        ref: choiceWidgetRef,\n        data: choiceWidgetDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, choiceWidgetRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.WIDGET);\n      expect(data.readOnly).toEqual(true);\n      expect(data.hidden).toEqual(false);\n      expect(data.combo).toEqual(true);\n      expect(data.multiSelect).toEqual(true);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render choice for printing","suites":["annotation","ChoiceWidgetAnnotation"],"line":2478,"updatePoint":{"line":2478,"column":41,"index":108546},"code":"    it(\"should render choice for printing\", async function () {\n      const choiceWidgetRef = Ref.get(271, 0);\n      const xref = new XRefMock([{\n        ref: choiceWidgetRef,\n        data: choiceWidgetDict\n      }, fontRefObj]);\n      const task = new WorkerTask(\"test print\");\n      partialEvaluator.xref = xref;\n      const annotation = await AnnotationFactory.create(xref, choiceWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: \"a value\"\n      });\n      const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);\n      expect(appearance).toEqual([\"/Tx BMC q\", \"1 1 32 10 re W n\", \"BT\", \"/Helv 5 Tf\", \"1 0 0 1 0 10 Tm\", \"ET Q EMC\"].join(\"\\n\"));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render choice with multiple selections but one is visible for printing","suites":["annotation","ChoiceWidgetAnnotation"],"line":2494,"updatePoint":{"line":2494,"column":85,"index":109384},"code":"    it(\"should render choice with multiple selections but one is visible for printing\", async function () {\n      choiceWidgetDict.set(\"Ff\", AnnotationFieldFlag.MULTISELECT);\n      choiceWidgetDict.set(\"Opt\", [[\"A\", \"a\"], [\"B\", \"b\"], [\"C\", \"c\"], [\"D\", \"d\"]]);\n      choiceWidgetDict.set(\"V\", [\"A\"]);\n      const choiceWidgetRef = Ref.get(271, 0);\n      const xref = new XRefMock([{\n        ref: choiceWidgetRef,\n        data: choiceWidgetDict\n      }, fontRefObj]);\n      const task = new WorkerTask(\"test print\");\n      partialEvaluator.xref = xref;\n      const annotation = await AnnotationFactory.create(xref, choiceWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: [\"A\", \"C\"]\n      });\n      const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);\n      expect(appearance).toEqual([\"/Tx BMC q\", \"1 1 32 10 re W n\", \"0.600006 0.756866 0.854904 rg\", \"1 3.25 32 6.75 re f\", \"BT\", \"/Helv 5 Tf\", \"1 0 0 1 0 10 Tm\", \"2 -5.88 Td (a) Tj\", \"0 -6.75 Td (b) Tj\", \"ET Q EMC\"].join(\"\\n\"));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render choice with multiple selections for printing","suites":["annotation","ChoiceWidgetAnnotation"],"line":2513,"updatePoint":{"line":2513,"column":66,"index":110494},"code":"    it(\"should render choice with multiple selections for printing\", async function () {\n      choiceWidgetDict.set(\"Ff\", AnnotationFieldFlag.MULTISELECT);\n      choiceWidgetDict.set(\"Opt\", [[\"A\", \"a\"], [\"B\", \"b\"], [\"C\", \"c\"], [\"D\", \"d\"]]);\n      choiceWidgetDict.set(\"V\", [\"A\"]);\n      const choiceWidgetRef = Ref.get(271, 0);\n      const xref = new XRefMock([{\n        ref: choiceWidgetRef,\n        data: choiceWidgetDict\n      }, fontRefObj]);\n      const task = new WorkerTask(\"test print\");\n      partialEvaluator.xref = xref;\n      const annotation = await AnnotationFactory.create(xref, choiceWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: [\"B\", \"C\"]\n      });\n      const appearance = await annotation._getAppearance(partialEvaluator, task, annotationStorage);\n      expect(appearance).toEqual([\"/Tx BMC q\", \"1 1 32 10 re W n\", \"0.600006 0.756866 0.854904 rg\", \"1 3.25 32 6.75 re f\", \"1 -3.5 32 6.75 re f\", \"BT\", \"/Helv 5 Tf\", \"1 0 0 1 0 10 Tm\", \"2 -5.88 Td (b) Tj\", \"0 -6.75 Td (c) Tj\", \"ET Q EMC\"].join(\"\\n\"));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should save rotated choice","suites":["annotation","ChoiceWidgetAnnotation"],"line":2532,"updatePoint":{"line":2532,"column":34,"index":111595},"code":"    it(\"should save rotated choice\", async function () {\n      choiceWidgetDict.set(\"Opt\", [\"A\", \"B\", \"C\"]);\n      choiceWidgetDict.set(\"V\", \"A\");\n      const choiceWidgetRef = Ref.get(123, 0);\n      const xref = new XRefMock([{\n        ref: choiceWidgetRef,\n        data: choiceWidgetDict\n      }, fontRefObj]);\n      partialEvaluator.xref = xref;\n      const task = new WorkerTask(\"test save\");\n      const annotation = await AnnotationFactory.create(xref, choiceWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: \"C\",\n        rotation: 270\n      });\n      const data = await annotation.save(partialEvaluator, task, annotationStorage);\n      expect(data.length).toEqual(2);\n      const [oldData, newData] = data;\n      expect(oldData.ref).toEqual(Ref.get(123, 0));\n      expect(newData.ref).toEqual(Ref.get(2, 0));\n      oldData.data = oldData.data.replace(/\\(D:\\d+\\)/, \"(date)\");\n      expect(oldData.data).toEqual(\"123 0 obj\\n\" + \"<< /Type /Annot /Subtype /Widget /FT /Ch /DA (/Helv 5 Tf) /DR \" + \"<< /Font << /Helv 314 0 R>>>> \" + \"/Rect [0 0 32 10] /Opt [(A) (B) (C)] /V (C) \" + \"/AP << /N 2 0 R>> /M (date) /MK << /R 270>>>>\\nendobj\\n\");\n      expect(newData.data).toEqual([\"2 0 obj\", \"<< /Length 170 /Subtype /Form /Resources << /Font << /Helv 314 0 R>>>> \" + \"/BBox [0 0 32 10] /Matrix [0 -1 1 0 0 10]>> stream\", \"/Tx BMC q\", \"1 1 10 32 re W n\", \"0.600006 0.756866 0.854904 rg\", \"1 11.75 10 6.75 re f\", \"BT\", \"/Helv 5 Tf\", \"1 0 0 1 0 32 Tm\", \"2 -5.88 Td (A) Tj\", \"0 -6.75 Td (B) Tj\", \"0 -6.75 Td (C) Tj\", \"ET Q EMC\", \"endstream\", \"endobj\\n\"].join(\"\\n\"));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should save choice","suites":["annotation","ChoiceWidgetAnnotation"],"line":2557,"updatePoint":{"line":2557,"column":26,"index":113259},"code":"    it(\"should save choice\", async function () {\n      choiceWidgetDict.set(\"Opt\", [\"A\", \"B\", \"C\"]);\n      choiceWidgetDict.set(\"V\", \"A\");\n      const choiceWidgetRef = Ref.get(123, 0);\n      const xref = new XRefMock([{\n        ref: choiceWidgetRef,\n        data: choiceWidgetDict\n      }, fontRefObj]);\n      partialEvaluator.xref = xref;\n      const task = new WorkerTask(\"test save\");\n      const annotation = await AnnotationFactory.create(xref, choiceWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: \"C\"\n      });\n      const data = await annotation.save(partialEvaluator, task, annotationStorage);\n      expect(data.length).toEqual(2);\n      const [oldData, newData] = data;\n      expect(oldData.ref).toEqual(Ref.get(123, 0));\n      expect(newData.ref).toEqual(Ref.get(2, 0));\n      oldData.data = oldData.data.replace(/\\(D:\\d+\\)/, \"(date)\");\n      expect(oldData.data).toEqual(\"123 0 obj\\n\" + \"<< /Type /Annot /Subtype /Widget /FT /Ch /DA (/Helv 5 Tf) /DR \" + \"<< /Font << /Helv 314 0 R>>>> \" + \"/Rect [0 0 32 10] /Opt [(A) (B) (C)] /V (C) \" + \"/AP << /N 2 0 R>> /M (date)>>\\nendobj\\n\");\n      expect(newData.data).toEqual([\"2 0 obj\", \"<< /Length 133 /Subtype /Form /Resources << /Font << /Helv 314 0 R>>>> \" + \"/BBox [0 0 32 10]>> stream\", \"/Tx BMC q\", \"1 1 32 10 re W n\", \"0.600006 0.756866 0.854904 rg\", \"1 3.25 32 6.75 re f\", \"BT\", \"/Helv 5 Tf\", \"1 0 0 1 0 10 Tm\", \"2 -5.88 Td (C) Tj\", \"ET Q EMC\", \"endstream\", \"endobj\\n\"].join(\"\\n\"));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should save choice with multiple selections","suites":["annotation","ChoiceWidgetAnnotation"],"line":2581,"updatePoint":{"line":2581,"column":51,"index":114842},"code":"    it(\"should save choice with multiple selections\", async function () {\n      choiceWidgetDict.set(\"Ff\", AnnotationFieldFlag.MULTISELECT);\n      choiceWidgetDict.set(\"Opt\", [[\"A\", \"a\"], [\"B\", \"b\"], [\"C\", \"c\"], [\"D\", \"d\"]]);\n      choiceWidgetDict.set(\"V\", [\"A\"]);\n      const choiceWidgetRef = Ref.get(123, 0);\n      const xref = new XRefMock([{\n        ref: choiceWidgetRef,\n        data: choiceWidgetDict\n      }, fontRefObj]);\n      const task = new WorkerTask(\"test save\");\n      partialEvaluator.xref = xref;\n      const annotation = await AnnotationFactory.create(xref, choiceWidgetRef, pdfManagerMock, idFactoryMock);\n      const annotationStorage = new Map();\n      annotationStorage.set(annotation.data.id, {\n        value: [\"B\", \"C\"]\n      });\n      const data = await annotation.save(partialEvaluator, task, annotationStorage);\n      expect(data.length).toEqual(2);\n      const [oldData, newData] = data;\n      expect(oldData.ref).toEqual(Ref.get(123, 0));\n      expect(newData.ref).toEqual(Ref.get(2, 0));\n      oldData.data = oldData.data.replace(/\\(D:\\d+\\)/, \"(date)\");\n      expect(oldData.data).toEqual(\"123 0 obj\\n\" + \"<< /Type /Annot /Subtype /Widget /FT /Ch /DA (/Helv 5 Tf) /DR \" + \"<< /Font << /Helv 314 0 R>>>> /Rect [0 0 32 10] /Ff 2097152 /Opt \" + \"[[(A) (a)] [(B) (b)] [(C) (c)] [(D) (d)]] /V [(B) (C)] /AP \" + \"<< /N 2 0 R>> /M (date)>>\\nendobj\\n\");\n      expect(newData.data).toEqual([\"2 0 obj\", \"<< /Length 171 /Subtype /Form /Resources << /Font << /Helv 314 0 R>>>> \" + \"/BBox [0 0 32 10]>> stream\", \"/Tx BMC q\", \"1 1 32 10 re W n\", \"0.600006 0.756866 0.854904 rg\", \"1 3.25 32 6.75 re f\", \"1 -3.5 32 6.75 re f\", \"BT\", \"/Helv 5 Tf\", \"1 0 0 1 0 10 Tm\", \"2 -5.88 Td (b) Tj\", \"0 -6.75 Td (c) Tj\", \"ET Q EMC\", \"endstream\", \"endobj\\n\"].join(\"\\n\"));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set the line coordinates","suites":["annotation","LineAnnotation"],"line":2608,"updatePoint":{"line":2608,"column":39,"index":116661},"code":"    it(\"should set the line coordinates\", async function () {\n      const lineDict = new Dict();\n      lineDict.set(\"Type\", Name.get(\"Annot\"));\n      lineDict.set(\"Subtype\", Name.get(\"Line\"));\n      lineDict.set(\"L\", [1, 2, 3, 4]);\n      lineDict.set(\"LE\", [\"Square\", \"Circle\"]);\n      const lineRef = Ref.get(122, 0);\n      const xref = new XRefMock([{\n        ref: lineRef,\n        data: lineDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, lineRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.LINE);\n      expect(data.lineCoordinates).toEqual([1, 2, 3, 4]);\n      expect(data.lineEndings).toEqual([\"None\", \"None\"]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set the line endings","suites":["annotation","LineAnnotation"],"line":2626,"updatePoint":{"line":2626,"column":35,"index":117370},"code":"    it(\"should set the line endings\", async function () {\n      const lineDict = new Dict();\n      lineDict.set(\"Type\", Name.get(\"Annot\"));\n      lineDict.set(\"Subtype\", Name.get(\"Line\"));\n      lineDict.set(\"L\", [1, 2, 3, 4]);\n      lineDict.set(\"LE\", [Name.get(\"Square\"), Name.get(\"Circle\")]);\n      const lineRef = Ref.get(122, 0);\n      const xref = new XRefMock([{\n        ref: lineRef,\n        data: lineDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, lineRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.LINE);\n      expect(data.lineCoordinates).toEqual([1, 2, 3, 4]);\n      expect(data.lineEndings).toEqual([\"Square\", \"Circle\"]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should correctly parse a file attachment","suites":["annotation","FileAttachmentAnnotation"],"line":2646,"updatePoint":{"line":2646,"column":48,"index":118175},"code":"    it(\"should correctly parse a file attachment\", async function () {\n      const fileStream = new StringStream(\"<<\\n\" + \"/Type /EmbeddedFile\\n\" + \"/Subtype /text#2Fplain\\n\" + \">>\\n\" + \"stream\\n\" + \"Test attachment\" + \"endstream\\n\");\n      const parser = new Parser({\n        lexer: new Lexer(fileStream),\n        xref: null,\n        allowStreams: true\n      });\n      const fileStreamRef = Ref.get(18, 0);\n      const fileStreamDict = parser.getObj();\n      const embeddedFileDict = new Dict();\n      embeddedFileDict.set(\"F\", fileStreamRef);\n      const fileSpecRef = Ref.get(19, 0);\n      const fileSpecDict = new Dict();\n      fileSpecDict.set(\"Type\", Name.get(\"Filespec\"));\n      fileSpecDict.set(\"Desc\", \"\");\n      fileSpecDict.set(\"EF\", embeddedFileDict);\n      fileSpecDict.set(\"UF\", \"Test.txt\");\n      const fileAttachmentRef = Ref.get(20, 0);\n      const fileAttachmentDict = new Dict();\n      fileAttachmentDict.set(\"Type\", Name.get(\"Annot\"));\n      fileAttachmentDict.set(\"Subtype\", Name.get(\"FileAttachment\"));\n      fileAttachmentDict.set(\"FS\", fileSpecRef);\n      fileAttachmentDict.set(\"T\", \"Topic\");\n      fileAttachmentDict.set(\"Contents\", \"Test.txt\");\n      const xref = new XRefMock([{\n        ref: fileStreamRef,\n        data: fileStreamDict\n      }, {\n        ref: fileSpecRef,\n        data: fileSpecDict\n      }, {\n        ref: fileAttachmentRef,\n        data: fileAttachmentDict\n      }]);\n      embeddedFileDict.assignXref(xref);\n      fileSpecDict.assignXref(xref);\n      fileAttachmentDict.assignXref(xref);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, fileAttachmentRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.FILEATTACHMENT);\n      expect(data.file.filename).toEqual(\"Test.txt\");\n      expect(data.file.content).toEqual(stringToBytes(\"Test attachment\"));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should inherit properties from its parent","suites":["annotation","PopupAnnotation"],"line":2692,"updatePoint":{"line":2692,"column":49,"index":120098},"code":"    it(\"should inherit properties from its parent\", async function () {\n      const parentDict = new Dict();\n      parentDict.set(\"Type\", Name.get(\"Annot\"));\n      parentDict.set(\"Subtype\", Name.get(\"Text\"));\n      parentDict.set(\"M\", \"D:20190423\");\n      parentDict.set(\"C\", [0, 0, 1]);\n      const popupDict = new Dict();\n      popupDict.set(\"Type\", Name.get(\"Annot\"));\n      popupDict.set(\"Subtype\", Name.get(\"Popup\"));\n      popupDict.set(\"Parent\", parentDict);\n      const popupRef = Ref.get(13, 0);\n      const xref = new XRefMock([{\n        ref: popupRef,\n        data: popupDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, popupRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.POPUP);\n      expect(data.modificationDate).toEqual(\"D:20190423\");\n      expect(data.color).toEqual(new Uint8ClampedArray([0, 0, 255]));\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle missing parent properties","suites":["annotation","PopupAnnotation"],"line":2714,"updatePoint":{"line":2714,"column":47,"index":121012},"code":"    it(\"should handle missing parent properties\", async function () {\n      const parentDict = new Dict();\n      parentDict.set(\"Type\", Name.get(\"Annot\"));\n      parentDict.set(\"Subtype\", Name.get(\"Text\"));\n      const popupDict = new Dict();\n      popupDict.set(\"Type\", Name.get(\"Annot\"));\n      popupDict.set(\"Subtype\", Name.get(\"Popup\"));\n      popupDict.set(\"Parent\", parentDict);\n      const popupRef = Ref.get(13, 0);\n      const xref = new XRefMock([{\n        ref: popupRef,\n        data: popupDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, popupRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.POPUP);\n      expect(data.modificationDate).toEqual(null);\n      expect(data.color).toEqual(null);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should create a new FreeText annotation","suites":["annotation","FreeTextAnnotation"],"line":2820,"updatePoint":{"line":2820,"column":47,"index":125100},"code":"    it(\"should create a new FreeText annotation\", async () => {\n      partialEvaluator.xref = new XRefMock();\n      const task = new WorkerTask(\"test FreeText creation\");\n      const data = await AnnotationFactory.saveNewAnnotations(partialEvaluator, task, [{\n        annotationType: AnnotationEditorType.FREETEXT,\n        rect: [12, 34, 56, 78],\n        rotation: 0,\n        fontSize: 10,\n        color: [0, 0, 0],\n        value: \"Hello PDF.js World!\"\n      }]);\n      const base = data.annotations[0].data.replace(/\\(D:\\d+\\)/, \"(date)\");\n      expect(base).toEqual(\"2 0 obj\\n\" + \"<< /Type /Annot /Subtype /FreeText /CreationDate (date) \" + \"/Rect [12 34 56 78] /DA (/Helv 10 Tf 0 g) /Contents (Hello PDF.js World!) \" + \"/F 4 /Border [0 0 0] /Rotate 0 /AP << /N 3 0 R>>>>\\n\" + \"endobj\\n\");\n      const font = data.dependencies[0].data;\n      expect(font).toEqual(\"1 0 obj\\n\" + \"<< /BaseFont /Helvetica /Type /Font /Subtype /Type1 /Encoding \" + \"/WinAnsiEncoding>>\\n\" + \"endobj\\n\");\n      const appearance = data.dependencies[1].data;\n      expect(appearance).toEqual(\"3 0 obj\\n\" + \"<< /FormType 1 /Subtype /Form /Type /XObject /BBox [0 0 44 44] \" + \"/Length 101 /Resources << /Font << /Helv 1 0 R>>>>>> stream\\n\" + \"q\\n\" + \"0 0 44 44 re W n\\n\" + \"BT\\n\" + \"1 0 0 1 0 47.5 Tm 0 Tc 0 g\\n\" + \"/Helv 10 Tf\\n\" + \"0 -13.5 Td (Hello PDF.js World!) Tj\\n\" + \"ET\\n\" + \"Q\\n\" + \"endstream\\n\" + \"\\n\" + \"endobj\\n\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render an added FreeText annotation for printing","suites":["annotation","FreeTextAnnotation"],"line":2838,"updatePoint":{"line":2838,"column":63,"index":126526},"code":"    it(\"should render an added FreeText annotation for printing\", async function () {\n      partialEvaluator.xref = new XRefMock();\n      const task = new WorkerTask(\"test FreeText printing\");\n      const freetextAnnotation = (await AnnotationFactory.printNewAnnotations(partialEvaluator, task, [{\n        annotationType: AnnotationEditorType.FREETEXT,\n        rect: [12, 34, 56, 78],\n        rotation: 0,\n        fontSize: 10,\n        color: [0, 0, 0],\n        value: \"A\"\n      }]))[0];\n      const operatorList = await freetextAnnotation.getOperatorList(partialEvaluator, task, RenderingIntentFlag.PRINT, false, null);\n      expect(operatorList.fnArray.length).toEqual(16);\n      expect(operatorList.fnArray).toEqual([OPS.beginAnnotation, OPS.save, OPS.constructPath, OPS.clip, OPS.endPath, OPS.beginText, OPS.setTextMatrix, OPS.setCharSpacing, OPS.setFillRGBColor, OPS.dependency, OPS.setFont, OPS.moveText, OPS.showText, OPS.endText, OPS.restore, OPS.endAnnotation]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle a single ink list","suites":["annotation","InkAnnotation"],"line":2855,"updatePoint":{"line":2855,"column":39,"index":127530},"code":"    it(\"should handle a single ink list\", async function () {\n      const inkDict = new Dict();\n      inkDict.set(\"Type\", Name.get(\"Annot\"));\n      inkDict.set(\"Subtype\", Name.get(\"Ink\"));\n      inkDict.set(\"InkList\", [[1, 1, 1, 2, 2, 2, 3, 3]]);\n      const inkRef = Ref.get(142, 0);\n      const xref = new XRefMock([{\n        ref: inkRef,\n        data: inkDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, inkRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.INK);\n      expect(data.inkLists.length).toEqual(1);\n      expect(data.inkLists[0]).toEqual([{\n        x: 1,\n        y: 1\n      }, {\n        x: 1,\n        y: 2\n      }, {\n        x: 2,\n        y: 2\n      }, {\n        x: 3,\n        y: 3\n      }]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should handle multiple ink lists","suites":["annotation","InkAnnotation"],"line":2884,"updatePoint":{"line":2884,"column":40,"index":128331},"code":"    it(\"should handle multiple ink lists\", async function () {\n      const inkDict = new Dict();\n      inkDict.set(\"Type\", Name.get(\"Annot\"));\n      inkDict.set(\"Subtype\", Name.get(\"Ink\"));\n      inkDict.set(\"InkList\", [[1, 1, 1, 2], [3, 3, 4, 5]]);\n      const inkRef = Ref.get(143, 0);\n      const xref = new XRefMock([{\n        ref: inkRef,\n        data: inkDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, inkRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.INK);\n      expect(data.inkLists.length).toEqual(2);\n      expect(data.inkLists[0]).toEqual([{\n        x: 1,\n        y: 1\n      }, {\n        x: 1,\n        y: 2\n      }]);\n      expect(data.inkLists[1]).toEqual([{\n        x: 3,\n        y: 3\n      }, {\n        x: 4,\n        y: 5\n      }]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should create a new Ink annotation","suites":["annotation","InkAnnotation"],"line":2914,"updatePoint":{"line":2914,"column":42,"index":129178},"code":"    it(\"should create a new Ink annotation\", async function () {\n      partialEvaluator.xref = new XRefMock();\n      const task = new WorkerTask(\"test Ink creation\");\n      const data = await AnnotationFactory.saveNewAnnotations(partialEvaluator, task, [{\n        annotationType: AnnotationEditorType.INK,\n        rect: [12, 34, 56, 78],\n        rotation: 0,\n        thickness: 1,\n        color: [0, 0, 0],\n        paths: [{\n          bezier: [10, 11, 12, 13, 14, 15, 16, 17, 22, 23, 24, 25, 26, 27],\n          points: [1, 2, 3, 4, 5, 6, 7, 8]\n        }, {\n          bezier: [910, 911, 912, 913, 914, 915, 916, 917, 922, 923, 924, 925, 926, 927],\n          points: [91, 92, 93, 94, 95, 96, 97, 98]\n        }]\n      }]);\n      const base = data.annotations[0].data.replace(/\\(D:\\d+\\)/, \"(date)\");\n      expect(base).toEqual(\"1 0 obj\\n\" + \"<< /Type /Annot /Subtype /Ink /CreationDate (date) /Rect [12 34 56 78] \" + \"/InkList [[1 2 3 4 5 6 7 8] [91 92 93 94 95 96 97 98]] /F 4 /Border [0 0 0] \" + \"/Rotate 0 /AP << /N 2 0 R>>>>\\n\" + \"endobj\\n\");\n      const appearance = data.dependencies[0].data;\n      expect(appearance).toEqual(\"2 0 obj\\n\" + \"<< /FormType 1 /Subtype /Form /Type /XObject /BBox [0 0 44 44] /Length 129>> stream\\n\" + \"1 w 1 J 1 j\\n\" + \"0 G\\n\" + \"10 11 m\\n\" + \"12 13 14 15 16 17 c\\n\" + \"22 23 24 25 26 27 c\\n\" + \"S\\n\" + \"910 911 m\\n\" + \"912 913 914 915 916 917 c\\n\" + \"922 923 924 925 926 927 c\\n\" + \"S\\n\" + \"endstream\\n\" + \"\\n\" + \"endobj\\n\");\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should render an added Ink annotation for printing","suites":["annotation","InkAnnotation"],"line":2936,"updatePoint":{"line":2936,"column":58,"index":130660},"code":"    it(\"should render an added Ink annotation for printing\", async function () {\n      partialEvaluator.xref = new XRefMock();\n      const task = new WorkerTask(\"test Ink printing\");\n      const inkAnnotation = (await AnnotationFactory.printNewAnnotations(partialEvaluator, task, [{\n        annotationType: AnnotationEditorType.INK,\n        rect: [12, 34, 56, 78],\n        rotation: 0,\n        thickness: 3,\n        color: [0, 255, 0],\n        paths: [{\n          bezier: [1, 2, 3, 4, 5, 6, 7, 8],\n          // Useless in the printing case.\n          points: [1, 2, 3, 4, 5, 6, 7, 8]\n        }]\n      }]))[0];\n      const operatorList = await inkAnnotation.getOperatorList(partialEvaluator, task, RenderingIntentFlag.PRINT, false, null);\n      expect(operatorList.argsArray.length).toEqual(8);\n      expect(operatorList.fnArray).toEqual([OPS.beginAnnotation, OPS.setLineWidth, OPS.setLineCap, OPS.setLineJoin, OPS.setStrokeRGBColor, OPS.constructPath, OPS.stroke, OPS.endAnnotation]); // Linewidth.\n\n      expect(operatorList.argsArray[1]).toEqual([3]); // LineCap.\n\n      expect(operatorList.argsArray[2]).toEqual([1]); // LineJoin.\n\n      expect(operatorList.argsArray[3]).toEqual([1]); // Color.\n\n      expect(operatorList.argsArray[4]).toEqual(new Uint8ClampedArray([0, 255, 0])); // Path.\n\n      expect(operatorList.argsArray[5][0]).toEqual([OPS.moveTo, OPS.curveTo]);\n      expect(operatorList.argsArray[5][1]).toEqual([1, 2, 3, 4, 5, 6, 7, 8]); // Min-max.\n\n      expect(operatorList.argsArray[5][2]).toEqual([1, 1, 2, 2]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set quadpoints to null if not defined","suites":["annotation","HightlightAnnotation"],"line":2970,"updatePoint":{"line":2970,"column":52,"index":132248},"code":"    it(\"should set quadpoints to null if not defined\", async function () {\n      const highlightDict = new Dict();\n      highlightDict.set(\"Type\", Name.get(\"Annot\"));\n      highlightDict.set(\"Subtype\", Name.get(\"Highlight\"));\n      const highlightRef = Ref.get(121, 0);\n      const xref = new XRefMock([{\n        ref: highlightRef,\n        data: highlightDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, highlightRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);\n      expect(data.quadPoints).toEqual(null);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set quadpoints if defined","suites":["annotation","HightlightAnnotation"],"line":2985,"updatePoint":{"line":2985,"column":40,"index":132849},"code":"    it(\"should set quadpoints if defined\", async function () {\n      const highlightDict = new Dict();\n      highlightDict.set(\"Type\", Name.get(\"Annot\"));\n      highlightDict.set(\"Subtype\", Name.get(\"Highlight\"));\n      highlightDict.set(\"Rect\", [10, 10, 20, 20]);\n      highlightDict.set(\"QuadPoints\", [10, 20, 20, 20, 10, 10, 20, 10]);\n      const highlightRef = Ref.get(121, 0);\n      const xref = new XRefMock([{\n        ref: highlightRef,\n        data: highlightDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, highlightRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);\n      expect(data.quadPoints).toEqual([[{\n        x: 10,\n        y: 20\n      }, {\n        x: 20,\n        y: 20\n      }, {\n        x: 10,\n        y: 10\n      }, {\n        x: 20,\n        y: 10\n      }]]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set quadpoints to null when empty","suites":["annotation","HightlightAnnotation"],"line":3014,"updatePoint":{"line":3014,"column":48,"index":133740},"code":"    it(\"should set quadpoints to null when empty\", async function () {\n      const highlightDict = new Dict();\n      highlightDict.set(\"Type\", Name.get(\"Annot\"));\n      highlightDict.set(\"Subtype\", Name.get(\"Highlight\"));\n      highlightDict.set(\"Rect\", [10, 10, 20, 20]);\n      highlightDict.set(\"QuadPoints\", []);\n      const highlightRef = Ref.get(121, 0);\n      const xref = new XRefMock([{\n        ref: highlightRef,\n        data: highlightDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, highlightRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.HIGHLIGHT);\n      expect(data.quadPoints).toEqual(null);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set quadpoints to null if not defined","suites":["annotation","UnderlineAnnotation"],"line":3033,"updatePoint":{"line":3033,"column":52,"index":134501},"code":"    it(\"should set quadpoints to null if not defined\", async function () {\n      const underlineDict = new Dict();\n      underlineDict.set(\"Type\", Name.get(\"Annot\"));\n      underlineDict.set(\"Subtype\", Name.get(\"Underline\"));\n      const underlineRef = Ref.get(121, 0);\n      const xref = new XRefMock([{\n        ref: underlineRef,\n        data: underlineDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, underlineRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.UNDERLINE);\n      expect(data.quadPoints).toEqual(null);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set quadpoints if defined","suites":["annotation","UnderlineAnnotation"],"line":3048,"updatePoint":{"line":3048,"column":40,"index":135102},"code":"    it(\"should set quadpoints if defined\", async function () {\n      const underlineDict = new Dict();\n      underlineDict.set(\"Type\", Name.get(\"Annot\"));\n      underlineDict.set(\"Subtype\", Name.get(\"Underline\"));\n      underlineDict.set(\"Rect\", [10, 10, 20, 20]);\n      underlineDict.set(\"QuadPoints\", [10, 20, 20, 20, 10, 10, 20, 10]);\n      const underlineRef = Ref.get(121, 0);\n      const xref = new XRefMock([{\n        ref: underlineRef,\n        data: underlineDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, underlineRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.UNDERLINE);\n      expect(data.quadPoints).toEqual([[{\n        x: 10,\n        y: 20\n      }, {\n        x: 20,\n        y: 20\n      }, {\n        x: 10,\n        y: 10\n      }, {\n        x: 20,\n        y: 10\n      }]]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set quadpoints to null if not defined","suites":["annotation","SquigglyAnnotation"],"line":3079,"updatePoint":{"line":3079,"column":52,"index":136050},"code":"    it(\"should set quadpoints to null if not defined\", async function () {\n      const squigglyDict = new Dict();\n      squigglyDict.set(\"Type\", Name.get(\"Annot\"));\n      squigglyDict.set(\"Subtype\", Name.get(\"Squiggly\"));\n      const squigglyRef = Ref.get(121, 0);\n      const xref = new XRefMock([{\n        ref: squigglyRef,\n        data: squigglyDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, squigglyRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);\n      expect(data.quadPoints).toEqual(null);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set quadpoints if defined","suites":["annotation","SquigglyAnnotation"],"line":3094,"updatePoint":{"line":3094,"column":40,"index":136642},"code":"    it(\"should set quadpoints if defined\", async function () {\n      const squigglyDict = new Dict();\n      squigglyDict.set(\"Type\", Name.get(\"Annot\"));\n      squigglyDict.set(\"Subtype\", Name.get(\"Squiggly\"));\n      squigglyDict.set(\"Rect\", [10, 10, 20, 20]);\n      squigglyDict.set(\"QuadPoints\", [10, 20, 20, 20, 10, 10, 20, 10]);\n      const squigglyRef = Ref.get(121, 0);\n      const xref = new XRefMock([{\n        ref: squigglyRef,\n        data: squigglyDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, squigglyRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.SQUIGGLY);\n      expect(data.quadPoints).toEqual([[{\n        x: 10,\n        y: 20\n      }, {\n        x: 20,\n        y: 20\n      }, {\n        x: 10,\n        y: 10\n      }, {\n        x: 20,\n        y: 10\n      }]]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set quadpoints to null if not defined","suites":["annotation","StrikeOutAnnotation"],"line":3125,"updatePoint":{"line":3125,"column":52,"index":137580},"code":"    it(\"should set quadpoints to null if not defined\", async function () {\n      const strikeOutDict = new Dict();\n      strikeOutDict.set(\"Type\", Name.get(\"Annot\"));\n      strikeOutDict.set(\"Subtype\", Name.get(\"StrikeOut\"));\n      const strikeOutRef = Ref.get(121, 0);\n      const xref = new XRefMock([{\n        ref: strikeOutRef,\n        data: strikeOutDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, strikeOutRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.STRIKEOUT);\n      expect(data.quadPoints).toEqual(null);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should set quadpoints if defined","suites":["annotation","StrikeOutAnnotation"],"line":3140,"updatePoint":{"line":3140,"column":40,"index":138181},"code":"    it(\"should set quadpoints if defined\", async function () {\n      const strikeOutDict = new Dict();\n      strikeOutDict.set(\"Type\", Name.get(\"Annot\"));\n      strikeOutDict.set(\"Subtype\", Name.get(\"StrikeOut\"));\n      strikeOutDict.set(\"Rect\", [10, 10, 20, 20]);\n      strikeOutDict.set(\"QuadPoints\", [10, 20, 20, 20, 10, 10, 20, 10]);\n      const strikeOutRef = Ref.get(121, 0);\n      const xref = new XRefMock([{\n        ref: strikeOutRef,\n        data: strikeOutDict\n      }]);\n      const {\n        data\n      } = await AnnotationFactory.create(xref, strikeOutRef, pdfManagerMock, idFactoryMock);\n      expect(data.annotationType).toEqual(AnnotationType.STRIKEOUT);\n      expect(data.quadPoints).toEqual([[{\n        x: 10,\n        y: 20\n      }, {\n        x: 20,\n        y: 20\n      }, {\n        x: 10,\n        y: 10\n      }, {\n        x: 20,\n        y: 10\n      }]]);\n    });","file":"unit/annotation_spec.js","skipped":false,"dir":"test"},{"name":"should get and set a new value in the annotation storage","suites":["AnnotationStorage","GetOrDefaultValue"],"line":18,"updatePoint":{"line":18,"column":64,"index":831},"code":"    it(\"should get and set a new value in the annotation storage\", function () {\n      const annotationStorage = new AnnotationStorage();\n      let value = annotationStorage.getValue(\"123A\", {\n        value: \"hello world\"\n      }).value;\n      expect(value).toEqual(\"hello world\");\n      annotationStorage.setValue(\"123A\", {\n        value: \"hello world\"\n      }); // the second argument is the default value to use\n      // if the key isn't in the storage\n\n      value = annotationStorage.getValue(\"123A\", {\n        value: \"an other string\"\n      }).value;\n      expect(value).toEqual(\"hello world\");\n    });","file":"unit/annotation_storage_spec.js","skipped":false,"dir":"test"},{"name":"should get set values and default ones in the annotation storage","suites":["AnnotationStorage","GetOrDefaultValue"],"line":34,"updatePoint":{"line":34,"column":72,"index":1448},"code":"    it(\"should get set values and default ones in the annotation storage\", function () {\n      const annotationStorage = new AnnotationStorage();\n      annotationStorage.setValue(\"123A\", {\n        value: \"hello world\",\n        hello: \"world\"\n      });\n      const result = annotationStorage.getValue(\"123A\", {\n        value: \"an other string\",\n        world: \"hello\"\n      });\n      expect(result).toEqual({\n        value: \"hello world\",\n        hello: \"world\",\n        world: \"hello\"\n      });\n    });","file":"unit/annotation_storage_spec.js","skipped":false,"dir":"test"},{"name":"should set a new value in the annotation storage","suites":["AnnotationStorage","SetValue"],"line":52,"updatePoint":{"line":52,"column":56,"index":1978},"code":"    it(\"should set a new value in the annotation storage\", function () {\n      const annotationStorage = new AnnotationStorage();\n      annotationStorage.setValue(\"123A\", {\n        value: \"an other string\"\n      });\n      const value = annotationStorage.getAll()[\"123A\"].value;\n      expect(value).toEqual(\"an other string\");\n    });","file":"unit/annotation_storage_spec.js","skipped":false,"dir":"test"},{"name":"should call onSetModified() if value is changed","suites":["AnnotationStorage","SetValue"],"line":60,"updatePoint":{"line":60,"column":55,"index":2311},"code":"    it(\"should call onSetModified() if value is changed\", function () {\n      const annotationStorage = new AnnotationStorage();\n      let called = false;\n\n      const callback = function () {\n        called = true;\n      };\n\n      annotationStorage.onSetModified = callback;\n      annotationStorage.setValue(\"asdf\", {\n        value: \"original\"\n      });\n      expect(called).toBe(true); // changing value\n\n      annotationStorage.setValue(\"asdf\", {\n        value: \"modified\"\n      });\n      expect(called).toBe(true); // not changing value\n\n      called = false;\n      annotationStorage.setValue(\"asdf\", {\n        value: \"modified\"\n      });\n      expect(called).toBe(false);\n    });","file":"unit/annotation_storage_spec.js","skipped":false,"dir":"test"},{"name":"should call onResetModified() if set","suites":["AnnotationStorage","ResetModified"],"line":87,"updatePoint":{"line":87,"column":44,"index":3033},"code":"    it(\"should call onResetModified() if set\", function () {\n      const annotationStorage = new AnnotationStorage();\n      let called = false;\n\n      const callback = function () {\n        called = true;\n      };\n\n      annotationStorage.onResetModified = callback;\n      annotationStorage.setValue(\"asdf\", {\n        value: \"original\"\n      });\n      annotationStorage.resetModified();\n      expect(called).toBe(true);\n      called = false; // not changing value\n\n      annotationStorage.setValue(\"asdf\", {\n        value: \"original\"\n      });\n      annotationStorage.resetModified();\n      expect(called).toBe(false); // changing value\n\n      annotationStorage.setValue(\"asdf\", {\n        value: \"modified\"\n      });\n      annotationStorage.resetModified();\n      expect(called).toBe(true);\n    });","file":"unit/annotation_storage_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from URL-string","suites":["api","getDocument"],"line":50,"updatePoint":{"line":50,"column":39,"index":2326},"code":"    it(\"creates pdf doc from URL-string\", async function () {\n      const urlStr = TEST_PDFS_PATH + basicApiFileName;\n      const loadingTask = getDocument(urlStr);\n      expect(loadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n      const pdfDocument = await loadingTask.promise;\n      expect(typeof urlStr).toEqual(\"string\");\n      expect(pdfDocument instanceof PDFDocumentProxy).toEqual(true);\n      expect(pdfDocument.numPages).toEqual(3);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from URL-object","suites":["api","getDocument"],"line":60,"updatePoint":{"line":60,"column":39,"index":2825},"code":"    it(\"creates pdf doc from URL-object\", async function () {\n      if (isNodeJS) {\n        pending(\"window.location is not supported in Node.js.\");\n      }\n\n      const urlObj = new URL(TEST_PDFS_PATH + basicApiFileName, window.location);\n      const loadingTask = getDocument(urlObj);\n      expect(loadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n      const pdfDocument = await loadingTask.promise;\n      expect(urlObj instanceof URL).toEqual(true);\n      expect(pdfDocument instanceof PDFDocumentProxy).toEqual(true);\n      expect(pdfDocument.numPages).toEqual(3);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from URL","suites":["api","getDocument"],"line":74,"updatePoint":{"line":74,"column":32,"index":3443},"code":"    it(\"creates pdf doc from URL\", async function () {\n      const loadingTask = getDocument(basicApiGetDocumentParams);\n      expect(loadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n      const progressReportedCapability = createPromiseCapability(); // Attach the callback that is used to report loading progress;\n      // similarly to how viewer.js works.\n\n      loadingTask.onProgress = function (progressData) {\n        if (!progressReportedCapability.settled) {\n          progressReportedCapability.resolve(progressData);\n        }\n      };\n\n      const data = await Promise.all([progressReportedCapability.promise, loadingTask.promise]);\n      expect(data[0].loaded / data[0].total >= 0).toEqual(true);\n      expect(data[1] instanceof PDFDocumentProxy).toEqual(true);\n      expect(loadingTask).toEqual(data[1].loadingTask);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from URL and aborts before worker initialized","suites":["api","getDocument"],"line":92,"updatePoint":{"line":92,"column":69,"index":4366},"code":"    it(\"creates pdf doc from URL and aborts before worker initialized\", async function () {\n      const loadingTask = getDocument(basicApiGetDocumentParams);\n      expect(loadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n      const destroyed = loadingTask.destroy();\n\n      try {\n        await loadingTask.promise; // Shouldn't get here.\n\n        expect(false).toEqual(true);\n      } catch (reason) {\n        expect(true).toEqual(true);\n        await destroyed;\n      }\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from URL and aborts loading after worker initialized","suites":["api","getDocument"],"line":106,"updatePoint":{"line":106,"column":76,"index":4864},"code":"    it(\"creates pdf doc from URL and aborts loading after worker initialized\", async function () {\n      const loadingTask = getDocument(basicApiGetDocumentParams);\n      expect(loadingTask instanceof PDFDocumentLoadingTask).toEqual(true); // This can be somewhat random -- we cannot guarantee perfect\n      // 'Terminate' message to the worker before/after setting up pdfManager.\n\n      const destroyed = loadingTask._worker.promise.then(function () {\n        return loadingTask.destroy();\n      });\n\n      await destroyed;\n      expect(true).toEqual(true);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from typed array","suites":["api","getDocument"],"line":118,"updatePoint":{"line":118,"column":40,"index":5395},"code":"    it(\"creates pdf doc from typed array\", async function () {\n      const typedArrayPdf = await DefaultFileReaderFactory.fetch({\n        path: TEST_PDFS_PATH + basicApiFileName\n      }); // Sanity check to make sure that we fetched the entire PDF file.\n\n      expect(typedArrayPdf.length).toEqual(basicApiFileLength);\n      const loadingTask = getDocument(typedArrayPdf);\n      expect(loadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n      const progressReportedCapability = createPromiseCapability();\n\n      loadingTask.onProgress = function (data) {\n        progressReportedCapability.resolve(data);\n      };\n\n      const data = await Promise.all([loadingTask.promise, progressReportedCapability.promise]);\n      expect(data[0] instanceof PDFDocumentProxy).toEqual(true);\n      expect(data[1].loaded / data[1].total).toEqual(1);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from invalid PDF file","suites":["api","getDocument"],"line":137,"updatePoint":{"line":137,"column":45,"index":6288},"code":"    it(\"creates pdf doc from invalid PDF file\", async function () {\n      // A severely corrupt PDF file (even Adobe Reader fails to open it).\n      const loadingTask = getDocument(buildGetDocumentParams(\"bug1020226.pdf\"));\n      expect(loadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n\n      try {\n        await loadingTask.promise; // Shouldn't get here.\n\n        expect(false).toEqual(true);\n      } catch (reason) {\n        expect(reason instanceof InvalidPDFException).toEqual(true);\n        expect(reason.message).toEqual(\"Invalid PDF structure.\");\n      }\n\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from non-existent URL","suites":["api","getDocument"],"line":153,"updatePoint":{"line":153,"column":45,"index":6908},"code":"    it(\"creates pdf doc from non-existent URL\", async function () {\n      if (!isNodeJS) {\n        // Re-enable in https://github.com/mozilla/pdf.js/issues/13061.\n        pending(\"Fails intermittently on Linux in browsers.\");\n      }\n\n      const loadingTask = getDocument(buildGetDocumentParams(\"non-existent.pdf\"));\n      expect(loadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n\n      try {\n        await loadingTask.promise; // Shouldn't get here.\n\n        expect(false).toEqual(true);\n      } catch (reason) {\n        expect(reason instanceof MissingPDFException).toEqual(true);\n      }\n\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from PDF file protected with user and owner password","suites":["api","getDocument"],"line":172,"updatePoint":{"line":172,"column":76,"index":7587},"code":"    it(\"creates pdf doc from PDF file protected with user and owner password\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"pr6531_1.pdf\"));\n      expect(loadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n      const passwordNeededCapability = createPromiseCapability();\n      const passwordIncorrectCapability = createPromiseCapability(); // Attach the callback that is used to request a password;\n      // similarly to how the default viewer handles passwords.\n\n      loadingTask.onPassword = function (updatePassword, reason) {\n        if (reason === PasswordResponses.NEED_PASSWORD && !passwordNeededCapability.settled) {\n          passwordNeededCapability.resolve();\n          updatePassword(\"qwerty\"); // Provide an incorrect password.\n\n          return;\n        }\n\n        if (reason === PasswordResponses.INCORRECT_PASSWORD && !passwordIncorrectCapability.settled) {\n          passwordIncorrectCapability.resolve();\n          updatePassword(\"asdfasdf\"); // Provide the correct password.\n\n          return;\n        } // Shouldn't get here.\n\n\n        expect(false).toEqual(true);\n      };\n\n      const data = await Promise.all([passwordNeededCapability.promise, passwordIncorrectCapability.promise, loadingTask.promise]);\n      expect(data[2] instanceof PDFDocumentProxy).toEqual(true);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from PDF file protected with only a user password","suites":["api","getDocument"],"line":202,"updatePoint":{"line":202,"column":73,"index":8968},"code":"    it(\"creates pdf doc from PDF file protected with only a user password\", async function () {\n      const filename = \"pr6531_2.pdf\";\n      const passwordNeededLoadingTask = getDocument(buildGetDocumentParams(filename, {\n        password: \"\"\n      }));\n      expect(passwordNeededLoadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n      const result1 = passwordNeededLoadingTask.promise.then(function () {\n        // Shouldn't get here.\n        expect(false).toEqual(true);\n        return Promise.reject(new Error(\"loadingTask should be rejected\"));\n      }, function (data) {\n        expect(data instanceof PasswordException).toEqual(true);\n        expect(data.code).toEqual(PasswordResponses.NEED_PASSWORD);\n        return passwordNeededLoadingTask.destroy();\n      });\n      const passwordIncorrectLoadingTask = getDocument(buildGetDocumentParams(filename, {\n        password: \"qwerty\"\n      }));\n      expect(passwordIncorrectLoadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n      const result2 = passwordIncorrectLoadingTask.promise.then(function () {\n        // Shouldn't get here.\n        expect(false).toEqual(true);\n        return Promise.reject(new Error(\"loadingTask should be rejected\"));\n      }, function (data) {\n        expect(data instanceof PasswordException).toEqual(true);\n        expect(data.code).toEqual(PasswordResponses.INCORRECT_PASSWORD);\n        return passwordIncorrectLoadingTask.destroy();\n      });\n      const passwordAcceptedLoadingTask = getDocument(buildGetDocumentParams(filename, {\n        password: \"asdfasdf\"\n      }));\n      expect(passwordAcceptedLoadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n      const result3 = passwordAcceptedLoadingTask.promise.then(function (data) {\n        expect(data instanceof PDFDocumentProxy).toEqual(true);\n        return passwordAcceptedLoadingTask.destroy();\n      });\n      await Promise.all([result1, result2, result3]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from empty typed array","suites":["api","getDocument"],"line":310,"updatePoint":{"line":310,"column":46,"index":13991},"code":"    it(\"creates pdf doc from empty typed array\", async function () {\n      const loadingTask = getDocument(new Uint8Array(0));\n      expect(loadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n\n      try {\n        await loadingTask.promise; // Shouldn't get here.\n\n        expect(false).toEqual(true);\n      } catch (reason) {\n        expect(reason instanceof InvalidPDFException).toEqual(true);\n        expect(reason.message).toEqual(\"The PDF file is empty, i.e. its size is zero bytes.\");\n      }\n\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"checks that `docId`s are unique and increasing","suites":["api","getDocument"],"line":325,"updatePoint":{"line":325,"column":54,"index":14551},"code":"    it(\"checks that `docId`s are unique and increasing\", async function () {\n      const loadingTask1 = getDocument(basicApiGetDocumentParams);\n      expect(loadingTask1 instanceof PDFDocumentLoadingTask).toEqual(true);\n      await loadingTask1.promise;\n      const docId1 = loadingTask1.docId;\n      const loadingTask2 = getDocument(basicApiGetDocumentParams);\n      expect(loadingTask2 instanceof PDFDocumentLoadingTask).toEqual(true);\n      await loadingTask2.promise;\n      const docId2 = loadingTask2.docId;\n      expect(docId1).not.toEqual(docId2);\n      const docIdRegExp = /^d(\\d+)$/,\n            docNum1 = docIdRegExp.exec(docId1)?.[1],\n            docNum2 = docIdRegExp.exec(docId2)?.[1];\n      expect(+docNum1).toBeLessThan(+docNum2);\n      await Promise.all([loadingTask1.destroy(), loadingTask2.destroy()]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from PDF file with bad XRef entry","suites":["api","getDocument"],"line":341,"updatePoint":{"line":341,"column":57,"index":15383},"code":"    it(\"creates pdf doc from PDF file with bad XRef entry\", async function () {\n      // A corrupt PDF file, where the XRef table have (some) bogus entries.\n      const loadingTask = getDocument(buildGetDocumentParams(\"PDFBOX-4352-0.pdf\", {\n        rangeChunkSize: 100\n      }));\n      expect(loadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n      const pdfDocument = await loadingTask.promise;\n      expect(pdfDocument.numPages).toEqual(1);\n      const page = await pdfDocument.getPage(1);\n      expect(page instanceof PDFPageProxy).toEqual(true);\n      const opList = await page.getOperatorList();\n      expect(opList.fnArray.length).toEqual(0);\n      expect(opList.argsArray.length).toEqual(0);\n      expect(opList.lastChunk).toEqual(true);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from PDF file with bad XRef header","suites":["api","getDocument"],"line":357,"updatePoint":{"line":357,"column":58,"index":16184},"code":"    it(\"creates pdf doc from PDF file with bad XRef header\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"GHOSTSCRIPT-698804-1-fuzzed.pdf\"));\n      expect(loadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n      const pdfDocument = await loadingTask.promise;\n      expect(pdfDocument.numPages).toEqual(1);\n      const page = await pdfDocument.getPage(1);\n      expect(page instanceof PDFPageProxy).toEqual(true);\n      const opList = await page.getOperatorList();\n      expect(opList.fnArray.length).toEqual(0);\n      expect(opList.argsArray.length).toEqual(0);\n      expect(opList.lastChunk).toEqual(true);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from PDF file with bad XRef byteWidths","suites":["api","getDocument"],"line":370,"updatePoint":{"line":370,"column":62,"index":16887},"code":"    it(\"creates pdf doc from PDF file with bad XRef byteWidths\", async function () {\n      // A corrupt PDF file, where the XRef /W-array have (some) bogus entries.\n      const loadingTask = getDocument(buildGetDocumentParams(\"REDHAT-1531897-0.pdf\"));\n      expect(loadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n\n      try {\n        await loadingTask.promise; // Shouldn't get here.\n\n        expect(false).toEqual(true);\n      } catch (reason) {\n        expect(reason instanceof InvalidPDFException).toEqual(true);\n        expect(reason.message).toEqual(\"Invalid PDF structure.\");\n      }\n\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from PDF file with inaccessible /Pages tree","suites":["api","getDocument"],"line":386,"updatePoint":{"line":386,"column":67,"index":17540},"code":"    it(\"creates pdf doc from PDF file with inaccessible /Pages tree\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"poppler-395-0-fuzzed.pdf\"));\n      expect(loadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n\n      try {\n        await loadingTask.promise; // Shouldn't get here.\n\n        expect(false).toEqual(true);\n      } catch (reason) {\n        expect(reason instanceof InvalidPDFException).toEqual(true);\n        expect(reason.message).toEqual(\"Invalid Root reference.\");\n      }\n\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from PDF files, with bad /Pages tree /Count","suites":["api","getDocument"],"line":401,"updatePoint":{"line":401,"column":67,"index":18118},"code":"    it(\"creates pdf doc from PDF files, with bad /Pages tree /Count\", async function () {\n      const loadingTask1 = getDocument(buildGetDocumentParams(\"poppler-67295-0.pdf\"));\n      const loadingTask2 = getDocument(buildGetDocumentParams(\"poppler-85140-0.pdf\"));\n      expect(loadingTask1 instanceof PDFDocumentLoadingTask).toEqual(true);\n      expect(loadingTask2 instanceof PDFDocumentLoadingTask).toEqual(true);\n      const pdfDocument1 = await loadingTask1.promise;\n      const pdfDocument2 = await loadingTask2.promise;\n      expect(pdfDocument1.numPages).toEqual(1);\n      expect(pdfDocument2.numPages).toEqual(1);\n      const page = await pdfDocument1.getPage(1);\n      expect(page instanceof PDFPageProxy).toEqual(true);\n      const opList = await page.getOperatorList();\n      expect(opList.fnArray.length).toBeGreaterThan(5);\n      expect(opList.argsArray.length).toBeGreaterThan(5);\n      expect(opList.lastChunk).toEqual(true);\n\n      try {\n        await pdfDocument2.getPage(1); // Shouldn't get here.\n\n        expect(false).toEqual(true);\n      } catch (reason) {\n        expect(reason instanceof UnknownErrorException).toEqual(true);\n        expect(reason.message).toEqual(\"Bad (uncompressed) XRef entry: 3R\");\n      }\n\n      await Promise.all([loadingTask1.destroy(), loadingTask2.destroy()]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from PDF files, with circular references","suites":["api","getDocument"],"line":428,"updatePoint":{"line":428,"column":64,"index":19434},"code":"    it(\"creates pdf doc from PDF files, with circular references\", async function () {\n      const loadingTask1 = getDocument(buildGetDocumentParams(\"poppler-91414-0-53.pdf\"));\n      const loadingTask2 = getDocument(buildGetDocumentParams(\"poppler-91414-0-54.pdf\"));\n      expect(loadingTask1 instanceof PDFDocumentLoadingTask).toEqual(true);\n      expect(loadingTask2 instanceof PDFDocumentLoadingTask).toEqual(true);\n      const pdfDocument1 = await loadingTask1.promise;\n      const pdfDocument2 = await loadingTask2.promise;\n      expect(pdfDocument1.numPages).toEqual(1);\n      expect(pdfDocument2.numPages).toEqual(1);\n      const pageA = await pdfDocument1.getPage(1);\n      const pageB = await pdfDocument2.getPage(1);\n      expect(pageA instanceof PDFPageProxy).toEqual(true);\n      expect(pageB instanceof PDFPageProxy).toEqual(true);\n\n      for (const opList of [await pageA.getOperatorList(), await pageB.getOperatorList()]) {\n        expect(opList.fnArray.length).toBeGreaterThan(5);\n        expect(opList.argsArray.length).toBeGreaterThan(5);\n        expect(opList.lastChunk).toEqual(true);\n      }\n\n      await Promise.all([loadingTask1.destroy(), loadingTask2.destroy()]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from PDF files, with bad /Pages tree /Kids entries","suites":["api","getDocument"],"line":450,"updatePoint":{"line":450,"column":74,"index":20641},"code":"    it(\"creates pdf doc from PDF files, with bad /Pages tree /Kids entries\", async function () {\n      const loadingTask1 = getDocument(buildGetDocumentParams(\"poppler-742-0-fuzzed.pdf\"));\n      const loadingTask2 = getDocument(buildGetDocumentParams(\"poppler-937-0-fuzzed.pdf\"));\n      expect(loadingTask1 instanceof PDFDocumentLoadingTask).toEqual(true);\n      expect(loadingTask2 instanceof PDFDocumentLoadingTask).toEqual(true);\n      const pdfDocument1 = await loadingTask1.promise;\n      const pdfDocument2 = await loadingTask2.promise;\n      expect(pdfDocument1.numPages).toEqual(1);\n      expect(pdfDocument2.numPages).toEqual(1);\n\n      try {\n        await pdfDocument1.getPage(1); // Shouldn't get here.\n\n        expect(false).toEqual(true);\n      } catch (reason) {\n        expect(reason instanceof UnknownErrorException).toEqual(true);\n        expect(reason.message).toEqual(\"Illegal character: 41\");\n      }\n\n      try {\n        await pdfDocument2.getPage(1); // Shouldn't get here.\n\n        expect(false).toEqual(true);\n      } catch (reason) {\n        expect(reason instanceof UnknownErrorException).toEqual(true);\n        expect(reason.message).toEqual(\"End of file inside array.\");\n      }\n\n      await Promise.all([loadingTask1.destroy(), loadingTask2.destroy()]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates pdf doc from PDF file with bad /Resources entry","suites":["api","getDocument"],"line":480,"updatePoint":{"line":480,"column":63,"index":21921},"code":"    it(\"creates pdf doc from PDF file with bad /Resources entry\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue15150.pdf\"));\n      expect(loadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n      const pdfDocument = await loadingTask.promise;\n      expect(pdfDocument.numPages).toEqual(1);\n      const page = await pdfDocument.getPage(1);\n      expect(page instanceof PDFPageProxy).toEqual(true);\n      const opList = await page.getOperatorList();\n      expect(opList.fnArray).toEqual([OPS.setLineWidth, OPS.setStrokeRGBColor, OPS.constructPath, OPS.closeStroke]);\n      expect(opList.argsArray).toEqual([[0.5], new Uint8ClampedArray([255, 0, 0]), [[OPS.moveTo, OPS.lineTo], [0, 9.75, 0.5, 9.75], [0, 0.5, 9.75, 9.75]], null]);\n      expect(opList.lastChunk).toEqual(true);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"worker created or destroyed","suites":["api","PDFWorker"],"line":495,"updatePoint":{"line":495,"column":35,"index":22806},"code":"    it(\"worker created or destroyed\", async function () {\n      if (isNodeJS) {\n        pending(\"Worker is not supported in Node.js.\");\n      }\n\n      const worker = new PDFWorker({\n        name: \"test1\"\n      });\n      await worker.promise;\n      expect(worker.name).toEqual(\"test1\");\n      expect(!!worker.port).toEqual(true);\n      expect(worker.destroyed).toEqual(false);\n      expect(!!worker._webWorker).toEqual(true);\n      expect(worker.port === worker._webWorker).toEqual(true);\n      worker.destroy();\n      expect(!!worker.port).toEqual(false);\n      expect(worker.destroyed).toEqual(true);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"worker created or destroyed by getDocument","suites":["api","PDFWorker"],"line":513,"updatePoint":{"line":513,"column":50,"index":23431},"code":"    it(\"worker created or destroyed by getDocument\", async function () {\n      if (isNodeJS) {\n        pending(\"Worker is not supported in Node.js.\");\n      }\n\n      const loadingTask = getDocument(basicApiGetDocumentParams);\n      let worker;\n      loadingTask.promise.then(function () {\n        worker = loadingTask._worker;\n        expect(!!worker).toEqual(true);\n      });\n      const destroyPromise = loadingTask.promise.then(function () {\n        return loadingTask.destroy();\n      });\n      await destroyPromise;\n      const destroyedWorker = loadingTask._worker;\n      expect(!!destroyedWorker).toEqual(false);\n      expect(worker.destroyed).toEqual(true);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"worker created and can be used in getDocument","suites":["api","PDFWorker"],"line":532,"updatePoint":{"line":532,"column":53,"index":24108},"code":"    it(\"worker created and can be used in getDocument\", async function () {\n      if (isNodeJS) {\n        pending(\"Worker is not supported in Node.js.\");\n      }\n\n      const worker = new PDFWorker({\n        name: \"test1\"\n      });\n      const loadingTask = getDocument(buildGetDocumentParams(basicApiFileName, {\n        worker\n      }));\n      loadingTask.promise.then(function () {\n        const docWorker = loadingTask._worker;\n        expect(!!docWorker).toEqual(false); // checking is the same port is used in the MessageHandler\n\n        const messageHandlerPort = loadingTask._transport.messageHandler.comObj;\n        expect(messageHandlerPort === worker.port).toEqual(true);\n      });\n      const destroyPromise = loadingTask.promise.then(function () {\n        return loadingTask.destroy();\n      });\n      await destroyPromise;\n      expect(worker.destroyed).toEqual(false);\n      worker.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"creates more than one worker","suites":["api","PDFWorker"],"line":557,"updatePoint":{"line":557,"column":36,"index":25006},"code":"    it(\"creates more than one worker\", async function () {\n      if (isNodeJS) {\n        pending(\"Worker is not supported in Node.js.\");\n      }\n\n      const worker1 = new PDFWorker({\n        name: \"test1\"\n      });\n      const worker2 = new PDFWorker({\n        name: \"test2\"\n      });\n      const worker3 = new PDFWorker({\n        name: \"test3\"\n      });\n      await Promise.all([worker1.promise, worker2.promise, worker3.promise]);\n      expect(worker1.port !== worker2.port && worker1.port !== worker3.port && worker2.port !== worker3.port).toEqual(true);\n      worker1.destroy();\n      worker2.destroy();\n      worker3.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets current workerSrc","suites":["api","PDFWorker"],"line":577,"updatePoint":{"line":577,"column":30,"index":25642},"code":"    it(\"gets current workerSrc\", function () {\n      if (isNodeJS) {\n        pending(\"Worker is not supported in Node.js.\");\n      }\n\n      const workerSrc = PDFWorker.workerSrc;\n      expect(typeof workerSrc).toEqual(\"string\");\n      expect(workerSrc).toEqual(GlobalWorkerOptions.workerSrc);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets number of pages","suites":["api","PDFDocument"],"line":596,"updatePoint":{"line":596,"column":28,"index":26258},"code":"    it(\"gets number of pages\", function () {\n      expect(pdfDocument.numPages).toEqual(3);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets fingerprints","suites":["api","PDFDocument"],"line":599,"updatePoint":{"line":599,"column":25,"index":26355},"code":"    it(\"gets fingerprints\", function () {\n      expect(pdfDocument.fingerprints).toEqual([\"ea8b35919d6279a369e835bde778611b\", null]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets fingerprints, from modified document","suites":["api","PDFDocument"],"line":602,"updatePoint":{"line":602,"column":49,"index":26521},"code":"    it(\"gets fingerprints, from modified document\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"annotation-tx.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      expect(pdfDoc.fingerprints).toEqual([\"3ebd77c320274649a68f10dbf3b9f882\", \"e7087346aa4b4ae0911c1f1643b57345\"]);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets page","suites":["api","PDFDocument"],"line":608,"updatePoint":{"line":608,"column":17,"index":26853},"code":"    it(\"gets page\", async function () {\n      const data = await pdfDocument.getPage(1);\n      expect(data instanceof PDFPageProxy).toEqual(true);\n      expect(data.pageNumber).toEqual(1);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets non-existent page","suites":["api","PDFDocument"],"line":613,"updatePoint":{"line":613,"column":30,"index":27063},"code":"    it(\"gets non-existent page\", async function () {\n      const pageNumbers = [\n      /* outOfRange = */\n      100,\n      /* nonInteger = */\n      2.5,\n      /* nonNumber = */\n      \"1\"];\n\n      for (const pageNumber of pageNumbers) {\n        try {\n          await pdfDocument.getPage(pageNumber); // Shouldn't get here.\n\n          expect(false).toEqual(true);\n        } catch (reason) {\n          expect(reason instanceof Error).toEqual(true);\n          expect(reason.message).toEqual(\"Invalid page request.\");\n        }\n      }\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets page, from /Pages tree with circular reference","suites":["api","PDFDocument"],"line":633,"updatePoint":{"line":633,"column":59,"index":27631},"code":"    it(\"gets page, from /Pages tree with circular reference\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"Pages-tree-refs.pdf\"));\n      const page1 = loadingTask.promise.then(function (pdfDoc) {\n        return pdfDoc.getPage(1).then(function (pdfPage) {\n          expect(pdfPage instanceof PDFPageProxy).toEqual(true);\n          expect(pdfPage.ref).toEqual({\n            num: 6,\n            gen: 0\n          });\n        }, function (reason) {\n          throw new Error(\"shall not fail for valid page\");\n        });\n      });\n      const page2 = loadingTask.promise.then(function (pdfDoc) {\n        return pdfDoc.getPage(2).then(function (pdfPage) {\n          throw new Error(\"shall fail for invalid page\");\n        }, function (reason) {\n          expect(reason instanceof UnknownErrorException).toEqual(true);\n          expect(reason.message).toEqual(\"Pages tree contains circular reference.\");\n        });\n      });\n      await Promise.all([page1, page2]);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets page multiple time, with working caches","suites":["api","PDFDocument"],"line":657,"updatePoint":{"line":657,"column":52,"index":28664},"code":"    it(\"gets page multiple time, with working caches\", async function () {\n      const promiseA = pdfDocument.getPage(1);\n      const promiseB = pdfDocument.getPage(1);\n      expect(promiseA instanceof Promise).toEqual(true);\n      expect(promiseA).toBe(promiseB);\n      const pageA = await promiseA;\n      const pageB = await promiseB;\n      expect(pageA instanceof PDFPageProxy).toEqual(true);\n      expect(pageA).toBe(pageB);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets page index","suites":["api","PDFDocument"],"line":667,"updatePoint":{"line":667,"column":23,"index":29072},"code":"    it(\"gets page index\", async function () {\n      const ref = {\n        num: 17,\n        gen: 0\n      }; // Reference to second page.\n\n      const pageIndex = await pdfDocument.getPageIndex(ref);\n      expect(pageIndex).toEqual(1);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets invalid page index","suites":["api","PDFDocument"],"line":676,"updatePoint":{"line":676,"column":31,"index":29322},"code":"    it(\"gets invalid page index\", async function () {\n      const pageRefs = [\n      /* fontRef = */\n      {\n        num: 3,\n        gen: 0\n      },\n      /* invalidRef = */\n      {\n        num: -1,\n        gen: 0\n      },\n      /* nonRef = */\n      \"qwerty\",\n      /* nullRef = */\n      null];\n      const expectedErrors = [{\n        exception: UnknownErrorException,\n        message: \"The reference does not point to a /Page dictionary.\"\n      }, {\n        exception: Error,\n        message: \"Invalid pageIndex request.\"\n      }, {\n        exception: Error,\n        message: \"Invalid pageIndex request.\"\n      }, {\n        exception: Error,\n        message: \"Invalid pageIndex request.\"\n      }];\n\n      for (let i = 0, ii = pageRefs.length; i < ii; i++) {\n        try {\n          await pdfDocument.getPageIndex(pageRefs[i]); // Shouldn't get here.\n\n          expect(false).toEqual(true);\n        } catch (reason) {\n          const {\n            exception,\n            message\n          } = expectedErrors[i];\n          expect(reason instanceof exception).toEqual(true);\n          expect(reason.message).toEqual(message);\n        }\n      }\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets destinations, from /Dests dictionary","suites":["api","PDFDocument"],"line":721,"updatePoint":{"line":721,"column":49,"index":30490},"code":"    it(\"gets destinations, from /Dests dictionary\", async function () {\n      const destinations = await pdfDocument.getDestinations();\n      expect(destinations).toEqual({\n        chapter1: [{\n          gen: 0,\n          num: 17\n        }, {\n          name: \"XYZ\"\n        }, 0, 841.89, null]\n      });\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets a destination, from /Dests dictionary","suites":["api","PDFDocument"],"line":732,"updatePoint":{"line":732,"column":50,"index":30802},"code":"    it(\"gets a destination, from /Dests dictionary\", async function () {\n      const destination = await pdfDocument.getDestination(\"chapter1\");\n      expect(destination).toEqual([{\n        gen: 0,\n        num: 17\n      }, {\n        name: \"XYZ\"\n      }, 0, 841.89, null]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets a non-existent destination, from /Dests dictionary","suites":["api","PDFDocument"],"line":741,"updatePoint":{"line":741,"column":63,"index":31096},"code":"    it(\"gets a non-existent destination, from /Dests dictionary\", async function () {\n      const destination = await pdfDocument.getDestination(\"non-existent-named-destination\");\n      expect(destination).toEqual(null);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets destinations, from /Names (NameTree) dictionary","suites":["api","PDFDocument"],"line":745,"updatePoint":{"line":745,"column":60,"index":31322},"code":"    it(\"gets destinations, from /Names (NameTree) dictionary\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue6204.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const destinations = await pdfDoc.getDestinations();\n      expect(destinations).toEqual({\n        \"Page.1\": [{\n          num: 1,\n          gen: 0\n        }, {\n          name: \"XYZ\"\n        }, 0, 375, null],\n        \"Page.2\": [{\n          num: 6,\n          gen: 0\n        }, {\n          name: \"XYZ\"\n        }, 0, 375, null]\n      });\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets a destination, from /Names (NameTree) dictionary","suites":["api","PDFDocument"],"line":765,"updatePoint":{"line":765,"column":61,"index":31916},"code":"    it(\"gets a destination, from /Names (NameTree) dictionary\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue6204.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const destination = await pdfDoc.getDestination(\"Page.1\");\n      expect(destination).toEqual([{\n        num: 1,\n        gen: 0\n      }, {\n        name: \"XYZ\"\n      }, 0, 375, null]);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets a non-existent destination, from /Names (NameTree) dictionary","suites":["api","PDFDocument"],"line":777,"updatePoint":{"line":777,"column":74,"index":32373},"code":"    it(\"gets a non-existent destination, from /Names (NameTree) dictionary\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue6204.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const destination = await pdfDoc.getDestination(\"non-existent-named-destination\");\n      expect(destination).toEqual(null);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets a destination, from out-of-order /Names (NameTree) dictionary (issue 10272)","suites":["api","PDFDocument"],"line":784,"updatePoint":{"line":784,"column":88,"index":32785},"code":"    it(\"gets a destination, from out-of-order /Names (NameTree) dictionary (issue 10272)\", async function () {\n      if (isNodeJS) {\n        pending(\"Linked test-cases are not supported in Node.js.\");\n      }\n\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue10272.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const destination = await pdfDoc.getDestination(\"link_1\");\n      expect(destination).toEqual([{\n        num: 17,\n        gen: 0\n      }, {\n        name: \"XYZ\"\n      }, 69, 125, 0]);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets a destination, from /Names (NameTree) dictionary with keys using PDFDocEncoding (issue 14847)","suites":["api","PDFDocument"],"line":800,"updatePoint":{"line":800,"column":106,"index":33373},"code":"    it(\"gets a destination, from /Names (NameTree) dictionary with keys using PDFDocEncoding (issue 14847)\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue14847.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const destination = await pdfDoc.getDestination(\"index\");\n      expect(destination).toEqual([{\n        num: 10,\n        gen: 0\n      }, {\n        name: \"XYZ\"\n      }, 85.039, 728.504, null]);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets non-string destination","suites":["api","PDFDocument"],"line":812,"updatePoint":{"line":812,"column":35,"index":33801},"code":"    it(\"gets non-string destination\", async function () {\n      let numberPromise = pdfDocument.getDestination(4.3);\n      let booleanPromise = pdfDocument.getDestination(true);\n      let arrayPromise = pdfDocument.getDestination([{\n        num: 17,\n        gen: 0\n      }, {\n        name: \"XYZ\"\n      }, 0, 841.89, null]);\n      numberPromise = numberPromise.then(function () {\n        throw new Error(\"shall fail for non-string destination.\");\n      }, function (reason) {\n        expect(reason instanceof Error).toEqual(true);\n      });\n      booleanPromise = booleanPromise.then(function () {\n        throw new Error(\"shall fail for non-string destination.\");\n      }, function (reason) {\n        expect(reason instanceof Error).toEqual(true);\n      });\n      arrayPromise = arrayPromise.then(function () {\n        throw new Error(\"shall fail for non-string destination.\");\n      }, function (reason) {\n        expect(reason instanceof Error).toEqual(true);\n      });\n      await Promise.all([numberPromise, booleanPromise, arrayPromise]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets non-existent page labels","suites":["api","PDFDocument"],"line":838,"updatePoint":{"line":838,"column":37,"index":34855},"code":"    it(\"gets non-existent page labels\", async function () {\n      const pageLabels = await pdfDocument.getPageLabels();\n      expect(pageLabels).toEqual(null);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets page labels","suites":["api","PDFDocument"],"line":842,"updatePoint":{"line":842,"column":24,"index":35010},"code":"    it(\"gets page labels\", async function () {\n      // PageLabels with Roman/Arabic numerals.\n      const loadingTask0 = getDocument(buildGetDocumentParams(\"bug793632.pdf\"));\n      const promise0 = loadingTask0.promise.then(function (pdfDoc) {\n        return pdfDoc.getPageLabels();\n      }); // PageLabels with only a label prefix.\n\n      const loadingTask1 = getDocument(buildGetDocumentParams(\"issue1453.pdf\"));\n      const promise1 = loadingTask1.promise.then(function (pdfDoc) {\n        return pdfDoc.getPageLabels();\n      }); // PageLabels identical to standard page numbering.\n\n      const loadingTask2 = getDocument(buildGetDocumentParams(\"rotation.pdf\"));\n      const promise2 = loadingTask2.promise.then(function (pdfDoc) {\n        return pdfDoc.getPageLabels();\n      }); // PageLabels with bad \"Prefix\" entries.\n\n      const loadingTask3 = getDocument(buildGetDocumentParams(\"bad-PageLabels.pdf\"));\n      const promise3 = loadingTask3.promise.then(function (pdfDoc) {\n        return pdfDoc.getPageLabels();\n      });\n      const pageLabels = await Promise.all([promise0, promise1, promise2, promise3]);\n      expect(pageLabels[0]).toEqual([\"i\", \"ii\", \"iii\", \"1\"]);\n      expect(pageLabels[1]).toEqual([\"Front Page1\"]);\n      expect(pageLabels[2]).toEqual([\"1\", \"2\"]);\n      expect(pageLabels[3]).toEqual([\"X3\"]);\n      await Promise.all([loadingTask0.destroy(), loadingTask1.destroy(), loadingTask2.destroy(), loadingTask3.destroy()]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets default page layout","suites":["api","PDFDocument"],"line":870,"updatePoint":{"line":870,"column":32,"index":36476},"code":"    it(\"gets default page layout\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"tracemonkey.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pageLayout = await pdfDoc.getPageLayout();\n      expect(pageLayout).toEqual(\"\");\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets non-default page layout","suites":["api","PDFDocument"],"line":877,"updatePoint":{"line":877,"column":36,"index":36801},"code":"    it(\"gets non-default page layout\", async function () {\n      const pageLayout = await pdfDocument.getPageLayout();\n      expect(pageLayout).toEqual(\"SinglePage\");\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets default page mode","suites":["api","PDFDocument"],"line":881,"updatePoint":{"line":881,"column":30,"index":36970},"code":"    it(\"gets default page mode\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"tracemonkey.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pageMode = await pdfDoc.getPageMode();\n      expect(pageMode).toEqual(\"UseNone\");\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets non-default page mode","suites":["api","PDFDocument"],"line":888,"updatePoint":{"line":888,"column":34,"index":37294},"code":"    it(\"gets non-default page mode\", async function () {\n      const pageMode = await pdfDocument.getPageMode();\n      expect(pageMode).toEqual(\"UseOutlines\");\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets default viewer preferences","suites":["api","PDFDocument"],"line":892,"updatePoint":{"line":892,"column":39,"index":37467},"code":"    it(\"gets default viewer preferences\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"tracemonkey.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const prefs = await pdfDoc.getViewerPreferences();\n      expect(prefs).toEqual(null);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets non-default viewer preferences","suites":["api","PDFDocument"],"line":899,"updatePoint":{"line":899,"column":43,"index":37798},"code":"    it(\"gets non-default viewer preferences\", async function () {\n      const prefs = await pdfDocument.getViewerPreferences();\n      expect(prefs).toEqual({\n        Direction: \"L2R\"\n      });\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets default open action","suites":["api","PDFDocument"],"line":905,"updatePoint":{"line":905,"column":32,"index":37988},"code":"    it(\"gets default open action\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"tracemonkey.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const openAction = await pdfDoc.getOpenAction();\n      expect(openAction).toEqual(null);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets non-default open action (with destination)","suites":["api","PDFDocument"],"line":912,"updatePoint":{"line":912,"column":55,"index":38334},"code":"    it(\"gets non-default open action (with destination)\", async function () {\n      const openAction = await pdfDocument.getOpenAction();\n      expect(openAction.dest).toEqual([{\n        num: 15,\n        gen: 0\n      }, {\n        name: \"FitH\"\n      }, null]);\n      expect(openAction.action).toBeUndefined();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets non-default open action (with Print action)","suites":["api","PDFDocument"],"line":922,"updatePoint":{"line":922,"column":56,"index":38652},"code":"    it(\"gets non-default open action (with Print action)\", async function () {\n      // PDF document with \"Print\" Named action in the OpenAction dictionary.\n      const loadingTask1 = getDocument(buildGetDocumentParams(\"bug1001080.pdf\")); // PDF document with \"Print\" Named action in the OpenAction dictionary,\n      // but the OpenAction dictionary is missing the `Type` entry.\n\n      const loadingTask2 = getDocument(buildGetDocumentParams(\"issue11442_reduced.pdf\"));\n      const promise1 = loadingTask1.promise.then(function (pdfDoc) {\n        return pdfDoc.getOpenAction();\n      }).then(function (openAction) {\n        expect(openAction.dest).toBeUndefined();\n        expect(openAction.action).toEqual(\"Print\");\n        return loadingTask1.destroy();\n      });\n      const promise2 = loadingTask2.promise.then(function (pdfDoc) {\n        return pdfDoc.getOpenAction();\n      }).then(function (openAction) {\n        expect(openAction.dest).toBeUndefined();\n        expect(openAction.action).toEqual(\"Print\");\n        return loadingTask2.destroy();\n      });\n      await Promise.all([promise1, promise2]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets non-existent attachments","suites":["api","PDFDocument"],"line":944,"updatePoint":{"line":944,"column":37,"index":39750},"code":"    it(\"gets non-existent attachments\", async function () {\n      const attachments = await pdfDocument.getAttachments();\n      expect(attachments).toEqual(null);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets attachments","suites":["api","PDFDocument"],"line":948,"updatePoint":{"line":948,"column":24,"index":39908},"code":"    it(\"gets attachments\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"attachment.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const attachments = await pdfDoc.getAttachments();\n      const attachment = attachments[\"foo.txt\"];\n      expect(attachment.filename).toEqual(\"foo.txt\");\n      expect(attachment.content).toEqual(new Uint8Array([98, 97, 114, 32, 98, 97, 122, 32, 10]));\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets javascript","suites":["api","PDFDocument"],"line":957,"updatePoint":{"line":957,"column":23,"index":40384},"code":"    it(\"gets javascript\", async function () {\n      const javascript = await pdfDocument.getJavaScript();\n      expect(javascript).toEqual(null);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets javascript with printing instructions (JS action)","suites":["api","PDFDocument"],"line":961,"updatePoint":{"line":961,"column":62,"index":40577},"code":"    it(\"gets javascript with printing instructions (JS action)\", async function () {\n      // PDF document with \"JavaScript\" action in the OpenAction dictionary.\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue6106.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const javascript = await pdfDoc.getJavaScript();\n      expect(javascript).toEqual([\"this.print({bUI:true,bSilent:false,bShrinkToFit:true});\"]);\n      expect(javascript[0]).toMatch(AutoPrintRegExp);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets hasJSActions, in document without javaScript","suites":["api","PDFDocument"],"line":970,"updatePoint":{"line":970,"column":57,"index":41109},"code":"    it(\"gets hasJSActions, in document without javaScript\", async function () {\n      const hasJSActions = await pdfDocument.hasJSActions();\n      expect(hasJSActions).toEqual(false);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets hasJSActions, in document with javaScript","suites":["api","PDFDocument"],"line":974,"updatePoint":{"line":974,"column":54,"index":41298},"code":"    it(\"gets hasJSActions, in document with javaScript\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"doc_actions.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const hasJSActions = await pdfDoc.hasJSActions();\n      expect(hasJSActions).toEqual(true);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets non-existent JSActions","suites":["api","PDFDocument"],"line":981,"updatePoint":{"line":981,"column":35,"index":41627},"code":"    it(\"gets non-existent JSActions\", async function () {\n      const jsActions = await pdfDocument.getJSActions();\n      expect(jsActions).toEqual(null);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets JSActions","suites":["api","PDFDocument"],"line":985,"updatePoint":{"line":985,"column":22,"index":41777},"code":"    it(\"gets JSActions\", async function () {\n      // PDF document with \"JavaScript\" action in the OpenAction dictionary.\n      const loadingTask = getDocument(buildGetDocumentParams(\"doc_actions.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const docActions = await pdfDoc.getJSActions();\n      const page1 = await pdfDoc.getPage(1);\n      const page1Actions = await page1.getJSActions();\n      const page3 = await pdfDoc.getPage(3);\n      const page3Actions = await page3.getJSActions();\n      expect(docActions).toEqual({\n        DidPrint: [`this.getField(\"Text2\").value = \"DidPrint\";`],\n        DidSave: [`this.getField(\"Text2\").value = \"DidSave\";`],\n        WillClose: [`this.getField(\"Text1\").value = \"WillClose\";`],\n        WillPrint: [`this.getField(\"Text1\").value = \"WillPrint\";`],\n        WillSave: [`this.getField(\"Text1\").value = \"WillSave\";`]\n      });\n      expect(page1Actions).toEqual({\n        PageOpen: [`this.getField(\"Text1\").value = \"PageOpen 1\";`],\n        PageClose: [`this.getField(\"Text2\").value = \"PageClose 1\";`]\n      });\n      expect(page3Actions).toEqual({\n        PageOpen: [`this.getField(\"Text5\").value = \"PageOpen 3\";`],\n        PageClose: [`this.getField(\"Text6\").value = \"PageClose 3\";`]\n      });\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets non-existent fieldObjects","suites":["api","PDFDocument"],"line":1011,"updatePoint":{"line":1011,"column":38,"index":43086},"code":"    it(\"gets non-existent fieldObjects\", async function () {\n      const fieldObjects = await pdfDocument.getFieldObjects();\n      expect(fieldObjects).toEqual(null);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets fieldObjects","suites":["api","PDFDocument"],"line":1015,"updatePoint":{"line":1015,"column":25,"index":43248},"code":"    it(\"gets fieldObjects\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"js-authors.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const fieldObjects = await pdfDoc.getFieldObjects();\n      expect(fieldObjects).toEqual({\n        Text1: [{\n          id: \"25R\",\n          value: \"\",\n          defaultValue: \"\",\n          multiline: false,\n          password: false,\n          charLimit: null,\n          comb: false,\n          editable: true,\n          hidden: false,\n          name: \"Text1\",\n          rect: [24.1789, 719.66, 432.22, 741.66],\n          actions: null,\n          page: 0,\n          strokeColor: null,\n          fillColor: null,\n          rotation: 0,\n          type: \"text\"\n        }],\n        Button1: [{\n          id: \"26R\",\n          value: \"Off\",\n          defaultValue: null,\n          exportValues: undefined,\n          editable: true,\n          name: \"Button1\",\n          rect: [455.436, 719.678, 527.436, 739.678],\n          hidden: false,\n          actions: {\n            Action: [`this.getField(\"Text1\").value = this.info.authors.join(\"::\");`]\n          },\n          page: 0,\n          strokeColor: null,\n          fillColor: new Uint8ClampedArray([192, 192, 192]),\n          rotation: 0,\n          type: \"button\"\n        }]\n      });\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets non-existent calculationOrder","suites":["api","PDFDocument"],"line":1060,"updatePoint":{"line":1060,"column":42,"index":44618},"code":"    it(\"gets non-existent calculationOrder\", async function () {\n      const calculationOrder = await pdfDocument.getCalculationOrderIds();\n      expect(calculationOrder).toEqual(null);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets calculationOrder","suites":["api","PDFDocument"],"line":1064,"updatePoint":{"line":1064,"column":29,"index":44799},"code":"    it(\"gets calculationOrder\", async function () {\n      if (isNodeJS) {\n        pending(\"Linked test-cases are not supported in Node.js.\");\n      }\n\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue13132.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const calculationOrder = await pdfDoc.getCalculationOrderIds();\n      expect(calculationOrder).toEqual([\"319R\", \"320R\", \"321R\", \"322R\", \"323R\", \"324R\", \"325R\", \"326R\", \"327R\", \"328R\", \"329R\", \"330R\", \"331R\", \"332R\", \"333R\", \"334R\", \"335R\"]);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets non-existent outline","suites":["api","PDFDocument"],"line":1075,"updatePoint":{"line":1075,"column":33,"index":45374},"code":"    it(\"gets non-existent outline\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"tracemonkey.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const outline = await pdfDoc.getOutline();\n      expect(outline).toEqual(null);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets outline","suites":["api","PDFDocument"],"line":1082,"updatePoint":{"line":1082,"column":20,"index":45676},"code":"    it(\"gets outline\", async function () {\n      const outline = await pdfDocument.getOutline(); // Two top level entries.\n\n      expect(Array.isArray(outline)).toEqual(true);\n      expect(outline.length).toEqual(2); // Make sure some basic attributes are set.\n\n      const outlineItem = outline[1];\n      expect(outlineItem.title).toEqual(\"Chapter 1\");\n      expect(Array.isArray(outlineItem.dest)).toEqual(true);\n      expect(outlineItem.url).toEqual(null);\n      expect(outlineItem.unsafeUrl).toBeUndefined();\n      expect(outlineItem.newWindow).toBeUndefined();\n      expect(outlineItem.bold).toEqual(true);\n      expect(outlineItem.italic).toEqual(false);\n      expect(outlineItem.color).toEqual(new Uint8ClampedArray([0, 64, 128]));\n      expect(outlineItem.items.length).toEqual(1);\n      expect(outlineItem.items[0].title).toEqual(\"Paragraph 1.1\");\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets outline containing a URL","suites":["api","PDFDocument"],"line":1100,"updatePoint":{"line":1100,"column":37,"index":46558},"code":"    it(\"gets outline containing a URL\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue3214.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const outline = await pdfDoc.getOutline();\n      expect(Array.isArray(outline)).toEqual(true);\n      expect(outline.length).toEqual(5);\n      const outlineItemTwo = outline[2];\n      expect(typeof outlineItemTwo.title).toEqual(\"string\");\n      expect(outlineItemTwo.dest).toEqual(null);\n      expect(outlineItemTwo.url).toEqual(\"http://google.com/\");\n      expect(outlineItemTwo.unsafeUrl).toEqual(\"http://google.com\");\n      expect(outlineItemTwo.newWindow).toBeUndefined();\n      const outlineItemOne = outline[1];\n      expect(outlineItemOne.bold).toEqual(false);\n      expect(outlineItemOne.italic).toEqual(true);\n      expect(outlineItemOne.color).toEqual(new Uint8ClampedArray([0, 0, 0]));\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets outline, with dest-strings using PDFDocEncoding (issue 14864)","suites":["api","PDFDocument"],"line":1118,"updatePoint":{"line":1118,"column":74,"index":47528},"code":"    it(\"gets outline, with dest-strings using PDFDocEncoding (issue 14864)\", async function () {\n      if (isNodeJS) {\n        pending(\"Linked test-cases are not supported in Node.js.\");\n      }\n\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue14864.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const outline = await pdfDoc.getOutline();\n      expect(Array.isArray(outline)).toEqual(true);\n      expect(outline.length).toEqual(6);\n      expect(outline[4]).toEqual({\n        dest: \"Händel -- Halle🎆lujah\",\n        url: null,\n        unsafeUrl: undefined,\n        newWindow: undefined,\n        title: \"Händel -- Halle🎆lujah\",\n        color: new Uint8ClampedArray([0, 0, 0]),\n        count: undefined,\n        bold: false,\n        italic: false,\n        items: []\n      });\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets outline with non-displayable chars","suites":["api","PDFDocument"],"line":1142,"updatePoint":{"line":1142,"column":47,"index":48353},"code":"    it(\"gets outline with non-displayable chars\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue14267.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const outline = await pdfDoc.getOutline();\n      expect(Array.isArray(outline)).toEqual(true);\n      expect(outline.length).toEqual(1);\n      const outlineItem = outline[0];\n      expect(outlineItem.title).toEqual(\"hello\\x11world\");\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets non-existent permissions","suites":["api","PDFDocument"],"line":1152,"updatePoint":{"line":1152,"column":37,"index":48824},"code":"    it(\"gets non-existent permissions\", async function () {\n      const permissions = await pdfDocument.getPermissions();\n      expect(permissions).toEqual(null);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets permissions","suites":["api","PDFDocument"],"line":1156,"updatePoint":{"line":1156,"column":24,"index":48982},"code":"    it(\"gets permissions\", async function () {\n      // Editing not allowed.\n      const loadingTask0 = getDocument(buildGetDocumentParams(\"issue9972-1.pdf\"));\n      const promise0 = loadingTask0.promise.then(function (pdfDoc) {\n        return pdfDoc.getPermissions();\n      }); // Printing not allowed.\n\n      const loadingTask1 = getDocument(buildGetDocumentParams(\"issue9972-2.pdf\"));\n      const promise1 = loadingTask1.promise.then(function (pdfDoc) {\n        return pdfDoc.getPermissions();\n      }); // Copying not allowed.\n\n      const loadingTask2 = getDocument(buildGetDocumentParams(\"issue9972-3.pdf\"));\n      const promise2 = loadingTask2.promise.then(function (pdfDoc) {\n        return pdfDoc.getPermissions();\n      });\n      const totalPermissionCount = Object.keys(PermissionFlag).length;\n      const permissions = await Promise.all([promise0, promise1, promise2]);\n      expect(permissions[0].length).toEqual(totalPermissionCount - 1);\n      expect(permissions[0].includes(PermissionFlag.MODIFY_CONTENTS)).toBeFalsy();\n      expect(permissions[1].length).toEqual(totalPermissionCount - 2);\n      expect(permissions[1].includes(PermissionFlag.PRINT)).toBeFalsy();\n      expect(permissions[1].includes(PermissionFlag.PRINT_HIGH_QUALITY)).toBeFalsy();\n      expect(permissions[2].length).toEqual(totalPermissionCount - 1);\n      expect(permissions[2].includes(PermissionFlag.COPY)).toBeFalsy();\n      await Promise.all([loadingTask0.destroy(), loadingTask1.destroy(), loadingTask2.destroy()]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets metadata","suites":["api","PDFDocument"],"line":1183,"updatePoint":{"line":1183,"column":21,"index":50495},"code":"    it(\"gets metadata\", async function () {\n      const {\n        info,\n        metadata,\n        contentDispositionFilename,\n        contentLength\n      } = await pdfDocument.getMetadata();\n      expect(info.Title).toEqual(\"Basic API Test\"); // Custom, non-standard, information dictionary entries.\n\n      expect(info.Custom).toEqual(undefined); // The following are PDF.js specific, non-standard, properties.\n\n      expect(info.PDFFormatVersion).toEqual(\"1.7\");\n      expect(info.Language).toEqual(\"en\");\n      expect(info.EncryptFilterName).toEqual(null);\n      expect(info.IsLinearized).toEqual(false);\n      expect(info.IsAcroFormPresent).toEqual(false);\n      expect(info.IsXFAPresent).toEqual(false);\n      expect(info.IsCollectionPresent).toEqual(false);\n      expect(info.IsSignaturesPresent).toEqual(false);\n      expect(metadata instanceof Metadata).toEqual(true);\n      expect(metadata.get(\"dc:title\")).toEqual(\"Basic API Test\");\n      expect(contentDispositionFilename).toEqual(null);\n      expect(contentLength).toEqual(basicApiFileLength);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets metadata, with custom info dict entries","suites":["api","PDFDocument"],"line":1207,"updatePoint":{"line":1207,"column":52,"index":51589},"code":"    it(\"gets metadata, with custom info dict entries\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"tracemonkey.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const {\n        info,\n        metadata,\n        contentDispositionFilename,\n        contentLength\n      } = await pdfDoc.getMetadata();\n      expect(info.Creator).toEqual(\"TeX\");\n      expect(info.Producer).toEqual(\"pdfeTeX-1.21a\");\n      expect(info.CreationDate).toEqual(\"D:20090401163925-07'00'\"); // Custom, non-standard, information dictionary entries.\n\n      const custom = info.Custom;\n      expect(typeof custom === \"object\" && custom !== null).toEqual(true);\n      expect(custom[\"PTEX.Fullbanner\"]).toEqual(\"This is pdfeTeX, \" + \"Version 3.141592-1.21a-2.2 (Web2C 7.5.4) kpathsea version 3.5.6\"); // The following are PDF.js specific, non-standard, properties.\n\n      expect(info.PDFFormatVersion).toEqual(\"1.4\");\n      expect(info.Language).toEqual(null);\n      expect(info.EncryptFilterName).toEqual(null);\n      expect(info.IsLinearized).toEqual(false);\n      expect(info.IsAcroFormPresent).toEqual(false);\n      expect(info.IsXFAPresent).toEqual(false);\n      expect(info.IsCollectionPresent).toEqual(false);\n      expect(info.IsSignaturesPresent).toEqual(false);\n      expect(metadata).toEqual(null);\n      expect(contentDispositionFilename).toEqual(null);\n      expect(contentLength).toEqual(1016315);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets metadata, with missing PDF header (bug 1606566)","suites":["api","PDFDocument"],"line":1237,"updatePoint":{"line":1237,"column":60,"index":53068},"code":"    it(\"gets metadata, with missing PDF header (bug 1606566)\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"bug1606566.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const {\n        info,\n        metadata,\n        contentDispositionFilename,\n        contentLength\n      } = await pdfDoc.getMetadata(); // Custom, non-standard, information dictionary entries.\n\n      expect(info.Custom).toEqual(undefined); // The following are PDF.js specific, non-standard, properties.\n\n      expect(info.PDFFormatVersion).toEqual(null);\n      expect(info.Language).toEqual(null);\n      expect(info.EncryptFilterName).toEqual(null);\n      expect(info.IsLinearized).toEqual(false);\n      expect(info.IsAcroFormPresent).toEqual(false);\n      expect(info.IsXFAPresent).toEqual(false);\n      expect(info.IsCollectionPresent).toEqual(false);\n      expect(info.IsSignaturesPresent).toEqual(false);\n      expect(metadata).toEqual(null);\n      expect(contentDispositionFilename).toEqual(null);\n      expect(contentLength).toEqual(624);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets metadata, with corrupt /Metadata XRef entry","suites":["api","PDFDocument"],"line":1262,"updatePoint":{"line":1262,"column":56,"index":54171},"code":"    it(\"gets metadata, with corrupt /Metadata XRef entry\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"PDFBOX-3148-2-fuzzed.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const {\n        info,\n        metadata,\n        contentDispositionFilename,\n        contentLength\n      } = await pdfDoc.getMetadata(); // Custom, non-standard, information dictionary entries.\n\n      expect(info.Custom).toEqual(undefined); // The following are PDF.js specific, non-standard, properties.\n\n      expect(info.PDFFormatVersion).toEqual(\"1.6\");\n      expect(info.Language).toEqual(null);\n      expect(info.EncryptFilterName).toEqual(null);\n      expect(info.IsLinearized).toEqual(false);\n      expect(info.IsAcroFormPresent).toEqual(true);\n      expect(info.IsXFAPresent).toEqual(false);\n      expect(info.IsCollectionPresent).toEqual(false);\n      expect(info.IsSignaturesPresent).toEqual(false);\n      expect(metadata).toEqual(null);\n      expect(contentDispositionFilename).toEqual(null);\n      expect(contentLength).toEqual(244351);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets markInfo","suites":["api","PDFDocument"],"line":1287,"updatePoint":{"line":1287,"column":21,"index":55252},"code":"    it(\"gets markInfo\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"annotation-line.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const markInfo = await pdfDoc.getMarkInfo();\n      expect(markInfo.Marked).toEqual(true);\n      expect(markInfo.UserProperties).toEqual(false);\n      expect(markInfo.Suspects).toEqual(false);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets data","suites":["api","PDFDocument"],"line":1295,"updatePoint":{"line":1295,"column":17,"index":55632},"code":"    it(\"gets data\", async function () {\n      const data = await pdfDocument.getData();\n      expect(data instanceof Uint8Array).toEqual(true);\n      expect(data.length).toEqual(basicApiFileLength);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets download info","suites":["api","PDFDocument"],"line":1300,"updatePoint":{"line":1300,"column":26,"index":55848},"code":"    it(\"gets download info\", async function () {\n      const downloadInfo = await pdfDocument.getDownloadInfo();\n      expect(downloadInfo).toEqual({\n        length: basicApiFileLength\n      });\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets document stats","suites":["api","PDFDocument"],"line":1306,"updatePoint":{"line":1306,"column":27,"index":56052},"code":"    it(\"gets document stats\", async function () {\n      const stats = pdfDocument.stats;\n      expect(stats).toEqual(null);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"cleans up document resources","suites":["api","PDFDocument"],"line":1310,"updatePoint":{"line":1310,"column":36,"index":56193},"code":"    it(\"cleans up document resources\", async function () {\n      await pdfDocument.cleanup();\n      expect(true).toEqual(true);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"checks that fingerprints are unique","suites":["api","PDFDocument"],"line":1314,"updatePoint":{"line":1314,"column":43,"index":56336},"code":"    it(\"checks that fingerprints are unique\", async function () {\n      const loadingTask1 = getDocument(buildGetDocumentParams(\"issue4436r.pdf\"));\n      const loadingTask2 = getDocument(buildGetDocumentParams(\"issue4575.pdf\"));\n      const data = await Promise.all([loadingTask1.promise, loadingTask2.promise]);\n      const fingerprints1 = data[0].fingerprints;\n      const fingerprints2 = data[1].fingerprints;\n      expect(fingerprints1).not.toEqual(fingerprints2);\n      expect(fingerprints1).toEqual([\"657428c0628e329f9a281fb6d2d092d4\", null]);\n      expect(fingerprints2).toEqual([\"04c7126b34a46b6d4d6e7a1eff7edcb6\", null]);\n      await Promise.all([loadingTask1.destroy(), loadingTask2.destroy()]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"write a value in an annotation, save the pdf and load it","suites":["api","PDFDocument"],"line":1325,"updatePoint":{"line":1325,"column":64,"index":57071},"code":"    it(\"write a value in an annotation, save the pdf and load it\", async function () {\n      let loadingTask = getDocument(buildGetDocumentParams(\"evaljs.pdf\"));\n      let pdfDoc = await loadingTask.promise;\n      const value = \"Hello World\";\n      pdfDoc.annotationStorage.setValue(\"55R\", {\n        value\n      });\n      const data = await pdfDoc.saveDocument();\n      await loadingTask.destroy();\n      loadingTask = getDocument(data);\n      pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      const annotations = await pdfPage.getAnnotations();\n      const field = annotations.find(annotation => annotation.id === \"55R\");\n      expect(!!field).toEqual(true);\n      expect(field.fieldValue).toEqual(value);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"server disallows cors","suites":["api","PDFDocument","Cross-origin"],"line":1391,"updatePoint":{"line":1391,"column":31,"index":59311},"code":"      it(\"server disallows cors\", async function () {\n        await testCannotLoad(\"basicapi.pdf\");\n      });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"server allows cors without credentials, default withCredentials","suites":["api","PDFDocument","Cross-origin"],"line":1394,"updatePoint":{"line":1394,"column":73,"index":59463},"code":"      it(\"server allows cors without credentials, default withCredentials\", async function () {\n        await testCanLoad(\"basicapi.pdf?cors=withoutCredentials\");\n      });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"server allows cors without credentials, and withCredentials=false","suites":["api","PDFDocument","Cross-origin"],"line":1397,"updatePoint":{"line":1397,"column":75,"index":59638},"code":"      it(\"server allows cors without credentials, and withCredentials=false\", async function () {\n        await testCanLoad(\"basicapi.pdf?cors=withoutCredentials\", {\n          withCredentials: false\n        });\n      });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"server allows cors without credentials, but withCredentials=true","suites":["api","PDFDocument","Cross-origin"],"line":1402,"updatePoint":{"line":1402,"column":74,"index":59858},"code":"      it(\"server allows cors without credentials, but withCredentials=true\", async function () {\n        await testCannotLoad(\"basicapi.pdf?cors=withoutCredentials\", {\n          withCredentials: true\n        });\n      });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"server allows cors with credentials, and withCredentials=true","suites":["api","PDFDocument","Cross-origin"],"line":1407,"updatePoint":{"line":1407,"column":71,"index":60077},"code":"      it(\"server allows cors with credentials, and withCredentials=true\", async function () {\n        await testCanLoad(\"basicapi.pdf?cors=withCredentials\", {\n          withCredentials: true\n        });\n      });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"server allows cors with credentials, and withCredentials=false","suites":["api","PDFDocument","Cross-origin"],"line":1412,"updatePoint":{"line":1412,"column":72,"index":60291},"code":"      it(\"server allows cors with credentials, and withCredentials=false\", async function () {\n        // The server supports even more than we need, so if the previous tests\n        // pass, then this should pass for sure.\n        // The only case where this test fails is when the server does not reply\n        // with the Access-Control-Allow-Origin header.\n        await testCanLoad(\"basicapi.pdf?cors=withCredentials\", {\n          withCredentials: false\n        });\n      });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets page number","suites":["api","Page"],"line":1433,"updatePoint":{"line":1433,"column":24,"index":61091},"code":"    it(\"gets page number\", function () {\n      expect(page.pageNumber).toEqual(1);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets rotate","suites":["api","Page"],"line":1436,"updatePoint":{"line":1436,"column":19,"index":61177},"code":"    it(\"gets rotate\", function () {\n      expect(page.rotate).toEqual(0);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets ref","suites":["api","Page"],"line":1439,"updatePoint":{"line":1439,"column":16,"index":61256},"code":"    it(\"gets ref\", function () {\n      expect(page.ref).toEqual({\n        num: 15,\n        gen: 0\n      });\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets userUnit","suites":["api","Page"],"line":1445,"updatePoint":{"line":1445,"column":21,"index":61377},"code":"    it(\"gets userUnit\", function () {\n      expect(page.userUnit).toEqual(1.0);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets view","suites":["api","Page"],"line":1448,"updatePoint":{"line":1448,"column":17,"index":61461},"code":"    it(\"gets view\", function () {\n      expect(page.view).toEqual([0, 0, 595.28, 841.89]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets view, with empty/invalid bounding boxes","suites":["api","Page"],"line":1451,"updatePoint":{"line":1451,"column":52,"index":61595},"code":"    it(\"gets view, with empty/invalid bounding boxes\", async function () {\n      const viewLoadingTask = getDocument(buildGetDocumentParams(\"boundingBox_invalid.pdf\"));\n      const pdfDoc = await viewLoadingTask.promise;\n      const numPages = pdfDoc.numPages;\n      expect(numPages).toEqual(3);\n      const viewPromises = [];\n\n      for (let i = 0; i < numPages; i++) {\n        viewPromises[i] = pdfDoc.getPage(i + 1).then(pdfPage => {\n          return pdfPage.view;\n        });\n      }\n\n      const [page1, page2, page3] = await Promise.all(viewPromises);\n      expect(page1).toEqual([0, 0, 612, 792]);\n      expect(page2).toEqual([0, 0, 800, 600]);\n      expect(page3).toEqual([0, 0, 600, 800]);\n      await viewLoadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets viewport","suites":["api","Page"],"line":1470,"updatePoint":{"line":1470,"column":21,"index":62310},"code":"    it(\"gets viewport\", function () {\n      const viewport = page.getViewport({\n        scale: 1.5,\n        rotation: 90\n      });\n      expect(viewport instanceof PageViewport).toEqual(true);\n      expect(viewport.viewBox).toEqual(page.view);\n      expect(viewport.scale).toEqual(1.5);\n      expect(viewport.rotation).toEqual(90);\n      expect(viewport.transform).toEqual([0, 1.5, 1.5, 0, 0, 0]);\n      expect(viewport.width).toEqual(1262.835);\n      expect(viewport.height).toEqual(892.92);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets viewport with \"offsetX/offsetY\" arguments","suites":["api","Page"],"line":1483,"updatePoint":{"line":1483,"column":54,"index":62844},"code":"    it('gets viewport with \"offsetX/offsetY\" arguments', function () {\n      const viewport = page.getViewport({\n        scale: 1,\n        rotation: 0,\n        offsetX: 100,\n        offsetY: -100\n      });\n      expect(viewport instanceof PageViewport).toEqual(true);\n      expect(viewport.transform).toEqual([1, 0, 0, -1, 100, 741.89]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets viewport respecting \"dontFlip\" argument","suites":["api","Page"],"line":1493,"updatePoint":{"line":1493,"column":52,"index":63188},"code":"    it('gets viewport respecting \"dontFlip\" argument', function () {\n      const scale = 1,\n            rotation = 0;\n      const viewport = page.getViewport({\n        scale,\n        rotation\n      });\n      expect(viewport instanceof PageViewport).toEqual(true);\n      const dontFlipViewport = page.getViewport({\n        scale,\n        rotation,\n        dontFlip: true\n      });\n      expect(dontFlipViewport instanceof PageViewport).toEqual(true);\n      expect(dontFlipViewport).not.toEqual(viewport);\n      expect(dontFlipViewport).toEqual(viewport.clone({\n        dontFlip: true\n      }));\n      expect(viewport.transform).toEqual([1, 0, 0, -1, 0, 841.89]);\n      expect(dontFlipViewport.transform).toEqual([1, 0, -0, 1, 0, 0]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets viewport with invalid rotation","suites":["api","Page"],"line":1514,"updatePoint":{"line":1514,"column":43,"index":63920},"code":"    it(\"gets viewport with invalid rotation\", function () {\n      expect(function () {\n        page.getViewport({\n          scale: 1,\n          rotation: 45\n        });\n      }).toThrow(new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\"));\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets annotations","suites":["api","Page"],"line":1522,"updatePoint":{"line":1522,"column":24,"index":64176},"code":"    it(\"gets annotations\", async function () {\n      const defaultPromise = page.getAnnotations().then(function (data) {\n        expect(data.length).toEqual(4);\n      });\n      const anyPromise = page.getAnnotations({\n        intent: \"any\"\n      }).then(function (data) {\n        expect(data.length).toEqual(4);\n      });\n      const displayPromise = page.getAnnotations({\n        intent: \"display\"\n      }).then(function (data) {\n        expect(data.length).toEqual(4);\n      });\n      const printPromise = page.getAnnotations({\n        intent: \"print\"\n      }).then(function (data) {\n        expect(data.length).toEqual(4);\n      });\n      await Promise.all([defaultPromise, anyPromise, displayPromise, printPromise]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets annotations containing relative URLs (bug 766086)","suites":["api","Page"],"line":1543,"updatePoint":{"line":1543,"column":62,"index":64943},"code":"    it(\"gets annotations containing relative URLs (bug 766086)\", async function () {\n      const filename = \"bug766086.pdf\";\n      const defaultLoadingTask = getDocument(buildGetDocumentParams(filename));\n      const defaultPromise = defaultLoadingTask.promise.then(function (pdfDoc) {\n        return pdfDoc.getPage(1).then(function (pdfPage) {\n          return pdfPage.getAnnotations();\n        });\n      });\n      const docBaseUrlLoadingTask = getDocument(buildGetDocumentParams(filename, {\n        docBaseUrl: \"http://www.example.com/test/pdfs/qwerty.pdf\"\n      }));\n      const docBaseUrlPromise = docBaseUrlLoadingTask.promise.then(function (pdfDoc) {\n        return pdfDoc.getPage(1).then(function (pdfPage) {\n          return pdfPage.getAnnotations();\n        });\n      });\n      const invalidDocBaseUrlLoadingTask = getDocument(buildGetDocumentParams(filename, {\n        docBaseUrl: \"qwerty.pdf\"\n      }));\n      const invalidDocBaseUrlPromise = invalidDocBaseUrlLoadingTask.promise.then(function (pdfDoc) {\n        return pdfDoc.getPage(1).then(function (pdfPage) {\n          return pdfPage.getAnnotations();\n        });\n      });\n      const [defaultAnnotations, docBaseUrlAnnotations, invalidDocBaseUrlAnnotations] = await Promise.all([defaultPromise, docBaseUrlPromise, invalidDocBaseUrlPromise]);\n      expect(defaultAnnotations[0].url).toBeUndefined();\n      expect(defaultAnnotations[0].unsafeUrl).toEqual(\"../../0021/002156/215675E.pdf#15\");\n      expect(docBaseUrlAnnotations[0].url).toEqual(\"http://www.example.com/0021/002156/215675E.pdf#15\");\n      expect(docBaseUrlAnnotations[0].unsafeUrl).toEqual(\"../../0021/002156/215675E.pdf#15\");\n      expect(invalidDocBaseUrlAnnotations[0].url).toBeUndefined();\n      expect(invalidDocBaseUrlAnnotations[0].unsafeUrl).toEqual(\"../../0021/002156/215675E.pdf#15\");\n      await Promise.all([defaultLoadingTask.destroy(), docBaseUrlLoadingTask.destroy(), invalidDocBaseUrlLoadingTask.destroy()]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets text content","suites":["api","Page"],"line":1576,"updatePoint":{"line":1576,"column":25,"index":66869},"code":"    it(\"gets text content\", async function () {\n      const defaultPromise = page.getTextContent();\n      const parametersPromise = page.getTextContent({\n        disableCombineTextItems: true\n      });\n      const data = await Promise.all([defaultPromise, parametersPromise]);\n      expect(!!data[0].items).toEqual(true);\n      expect(data[0].items.length).toEqual(15);\n      expect(!!data[0].styles).toEqual(true);\n      const page1 = mergeText(data[0].items);\n      expect(page1).toEqual(`Table Of Content\nChapter 1 .......................................................... 2\nParagraph 1.1 ...................................................... 3\npage 1 / 3`);\n      expect(!!data[1].items).toEqual(true);\n      expect(data[1].items.length).toEqual(6);\n      expect(!!data[1].styles).toEqual(true);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets text content, with correct properties (issue 8276)","suites":["api","Page"],"line":1594,"updatePoint":{"line":1594,"column":63,"index":67717},"code":"    it(\"gets text content, with correct properties (issue 8276)\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue8276_reduced.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      const {\n        items,\n        styles\n      } = await pdfPage.getTextContent();\n      expect(items.length).toEqual(1); // Font name will a random object id.\n\n      const fontName = items[0].fontName;\n      expect(Object.keys(styles)).toEqual([fontName]);\n      expect(items[0]).toEqual({\n        dir: \"ltr\",\n        fontName,\n        height: 18,\n        str: \"Issue 8276\",\n        transform: [18, 0, 0, 18, 441.81, 708.4499999999999],\n        width: 77.49,\n        hasEOL: false\n      });\n      expect(styles[fontName]).toEqual({\n        fontFamily: \"serif\",\n        // `useSystemFonts` has a different value in web environments\n        // and in Node.js.\n        ascent: isNodeJS ? NaN : 0.683,\n        descent: isNodeJS ? NaN : -0.217,\n        vertical: false\n      });\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets text content, with no extra spaces (issue 13226)","suites":["api","Page"],"line":1625,"updatePoint":{"line":1625,"column":61,"index":68805},"code":"    it(\"gets text content, with no extra spaces (issue 13226)\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue13226.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      const {\n        items\n      } = await pdfPage.getTextContent();\n      const text = mergeText(items);\n      expect(text).toEqual(\"Mitarbeiterinnen und Mitarbeiter arbeiten in über 100 Ländern engagiert im Dienste\");\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets text content, with merged spaces (issue 13201)","suites":["api","Page"],"line":1636,"updatePoint":{"line":1636,"column":59,"index":69327},"code":"    it(\"gets text content, with merged spaces (issue 13201)\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue13201.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      const {\n        items\n      } = await pdfPage.getTextContent();\n      const text = mergeText(items);\n      expect(text.includes(\"Abstract. A purely peer-to-peer version of electronic cash would allow online\")).toEqual(true);\n      expect(text.includes(\"avoid mediating disputes. The cost of mediation increases transaction costs, limiting the\")).toEqual(true);\n      expect(text.includes(\"system is secure as long as honest nodes collectively control more CPU power than any\")).toEqual(true);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets text content, with no spaces between letters of words (issue 11913)","suites":["api","Page"],"line":1649,"updatePoint":{"line":1649,"column":80,"index":70148},"code":"    it(\"gets text content, with no spaces between letters of words (issue 11913)\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue11913.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      const {\n        items\n      } = await pdfPage.getTextContent();\n      const text = mergeText(items);\n      expect(text.includes(\"1. The first of these cases arises from the tragic handicap which has blighted the life of the Plaintiff, and from the response of the\")).toEqual(true);\n      expect(text.includes(\"argued in this Court the appeal raises narrower, but important, issues which may be summarised as follows:-\")).toEqual(true);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets text content, with merged spaces (issue 10900)","suites":["api","Page"],"line":1661,"updatePoint":{"line":1661,"column":59,"index":70891},"code":"    it(\"gets text content, with merged spaces (issue 10900)\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue10900.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      const {\n        items\n      } = await pdfPage.getTextContent();\n      const text = mergeText(items);\n      expect(text.includes(`3 3 3 3\n851.5 854.9 839.3 837.5\n633.6 727.8 789.9 796.2\n1,485.1 1,582.7 1,629.2 1,633.7\n114.2 121.7 125.3 130.7\n13.0x 13.0x 13.0x 12.5x`)).toEqual(true);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets text content, with spaces (issue 10640)","suites":["api","Page"],"line":1677,"updatePoint":{"line":1677,"column":52,"index":71474},"code":"    it(\"gets text content, with spaces (issue 10640)\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue10640.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      const {\n        items\n      } = await pdfPage.getTextContent();\n      const text = mergeText(items);\n      expect(text.includes(`Open Sans is a humanist sans serif typeface designed by Steve Matteson.\nOpen Sans was designed with an upright stress, open forms and a neu-\ntral, yet friendly appearance. It was optimized for print, web, and mobile\ninterfaces, and has excellent legibility characteristics in its letterforms (see\nfigure \\x81 on the following page). This font is available from the Google Font\nDirectory [\\x81] as TrueType files licensed under the Apache License version \\x82.\\x80.\nThis package provides support for this font in LATEX. It includes Type \\x81\nversions of the fonts, converted for this package using FontForge from its\nsources, for full support with Dvips.`)).toEqual(true);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets text content, with negative spaces (bug 931481)","suites":["api","Page"],"line":1696,"updatePoint":{"line":1696,"column":60,"index":72583},"code":"    it(\"gets text content, with negative spaces (bug 931481)\", async function () {\n      if (isNodeJS) {\n        pending(\"Linked test-cases are not supported in Node.js.\");\n      }\n\n      const loadingTask = getDocument(buildGetDocumentParams(\"bug931481.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      const {\n        items\n      } = await pdfPage.getTextContent();\n      const text = mergeText(items);\n      expect(text.includes(`Kathrin Nachbaur\nDie promovierte Juristin ist 1979 in Graz geboren und aufgewachsen. Nach\nerfolgreichem Studienabschluss mit Fokus auf Europarecht absolvierte sie ein\nPraktikum bei Magna International in Kanada in der Human Resources Abteilung.\nAnschliessend wurde sie geschult in Human Resources, Arbeitsrecht und\nKommunikation, währenddessen sie auch an ihrem Doktorat im Wirtschaftsrecht\narbeitete. Seither arbeitete sie bei Magna International als Projekt Manager in der\nInnovationsabteilung. Seit 2009 ist sie Frank Stronachs Büroleiterin in Österreich und\nKanada. Zusätzlich ist sie seit 2012 Vice President, Business Development der\nStronach Group und Vizepräsidentin und Institutsleiterin des Stronach Institut für\nsozialökonomische Gerechtigkeit.`)).toEqual(true);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets text content, with invisible text marks (issue 9186)","suites":["api","Page"],"line":1721,"updatePoint":{"line":1721,"column":65,"index":73897},"code":"    it(\"gets text content, with invisible text marks (issue 9186)\", async function () {\n      if (isNodeJS) {\n        pending(\"Linked test-cases are not supported in Node.js.\");\n      }\n\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue9186.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      const {\n        items\n      } = await pdfPage.getTextContent();\n      const text = mergeText(items);\n      expect(text.includes(`This Agreement (“Agreement”) is made as of this 25th day of January, 2017, by and\nbetween EDWARD G. ATSINGER III, not individually but as sole Trustee of the ATSINGER\nFAMILY TRUST /u/a dated October 31, 1980 as amended, and STUART W. EPPERSON, not\nindividually but solely as Trustee of the STUART W. EPPERSON REVOCABLE LIVING\nTRUST /u/a dated January 14th 1993 as amended, collectively referred to herein as “Lessor”, and\nCaron Broadcasting, Inc., an Ohio corporation (“Lessee”).`)).toEqual(true);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets text content, with beginbfrange operator handled correctly (bug 1627427)","suites":["api","Page"],"line":1741,"updatePoint":{"line":1741,"column":85,"index":74955},"code":"    it(\"gets text content, with beginbfrange operator handled correctly (bug 1627427)\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"bug1627427_reduced.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      const {\n        items\n      } = await pdfPage.getTextContent();\n      const text = mergeText(items);\n      expect(text).toEqual(\"침하게 흐린 품이 눈이 올 듯하더니 눈은 아니 오고 얼다가 만 비가 추\");\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets text content, and check that out-of-page text is not present (bug 1755201)","suites":["api","Page"],"line":1752,"updatePoint":{"line":1752,"column":87,"index":75470},"code":"    it(\"gets text content, and check that out-of-page text is not present (bug 1755201)\", async function () {\n      if (isNodeJS) {\n        pending(\"Linked test-cases are not supported in Node.js.\");\n      }\n\n      const loadingTask = getDocument(buildGetDocumentParams(\"bug1755201.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(6);\n      const {\n        items\n      } = await pdfPage.getTextContent();\n      const text = mergeText(items);\n      expect(/win aisle/.test(text)).toEqual(false);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets text content with or without includeMarkedContent, and compare (issue 15094)","suites":["api","Page"],"line":1767,"updatePoint":{"line":1767,"column":89,"index":76060},"code":"    it(\"gets text content with or without includeMarkedContent, and compare (issue 15094)\", async function () {\n      if (isNodeJS) {\n        pending(\"Linked test-cases are not supported in Node.js.\");\n      }\n\n      const loadingTask = getDocument(buildGetDocumentParams(\"pdf.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(568);\n      let {\n        items\n      } = await pdfPage.getTextContent({\n        includeMarkedContent: false\n      });\n      const textWithoutMC = mergeText(items);\n      ({\n        items\n      } = await pdfPage.getTextContent({\n        includeMarkedContent: true\n      }));\n      const textWithMC = mergeText(items);\n      expect(textWithoutMC).toEqual(textWithMC);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets empty structure tree","suites":["api","Page"],"line":1790,"updatePoint":{"line":1790,"column":33,"index":76790},"code":"    it(\"gets empty structure tree\", async function () {\n      const tree = await page.getStructTree();\n      expect(tree).toEqual(null);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets simple structure tree","suites":["api","Page"],"line":1794,"updatePoint":{"line":1794,"column":34,"index":76936},"code":"    it(\"gets simple structure tree\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"structure_simple.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      const tree = await pdfPage.getStructTree();\n      expect(tree).toEqual({\n        role: \"Root\",\n        children: [{\n          role: \"Document\",\n          lang: \"en-US\",\n          children: [{\n            role: \"H1\",\n            children: [{\n              role: \"NonStruct\",\n              children: [{\n                type: \"content\",\n                id: \"page2R_mcid0\"\n              }]\n            }]\n          }, {\n            role: \"P\",\n            children: [{\n              role: \"NonStruct\",\n              children: [{\n                type: \"content\",\n                id: \"page2R_mcid1\"\n              }]\n            }]\n          }, {\n            role: \"H2\",\n            children: [{\n              role: \"NonStruct\",\n              children: [{\n                type: \"content\",\n                id: \"page2R_mcid2\"\n              }]\n            }]\n          }, {\n            role: \"P\",\n            children: [{\n              role: \"NonStruct\",\n              children: [{\n                type: \"content\",\n                id: \"page2R_mcid3\"\n              }]\n            }]\n          }]\n        }]\n      });\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets operator list","suites":["api","Page"],"line":1845,"updatePoint":{"line":1845,"column":26,"index":78321},"code":"    it(\"gets operator list\", async function () {\n      const operatorList = await page.getOperatorList();\n      expect(operatorList.fnArray.length).toBeGreaterThan(100);\n      expect(operatorList.argsArray.length).toBeGreaterThan(100);\n      expect(operatorList.lastChunk).toEqual(true);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets operatorList with JPEG image (issue 4888)","suites":["api","Page"],"line":1851,"updatePoint":{"line":1851,"column":54,"index":78645},"code":"    it(\"gets operatorList with JPEG image (issue 4888)\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"cmykjpeg.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      const operatorList = await pdfPage.getOperatorList();\n      const imgIndex = operatorList.fnArray.indexOf(OPS.paintImageXObject);\n      const imgArgs = operatorList.argsArray[imgIndex];\n      const {\n        data\n      } = pdfPage.objs.get(imgArgs[0]);\n      expect(data instanceof Uint8ClampedArray).toEqual(true);\n      expect(data.length).toEqual(90000);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets operator list, containing Annotation-operatorLists","suites":["api","Page"],"line":1895,"updatePoint":{"line":1895,"column":63,"index":80593},"code":"    it(\"gets operator list, containing Annotation-operatorLists\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"annotation-line.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      const operatorList = await pdfPage.getOperatorList();\n      expect(operatorList.fnArray.length).toBeGreaterThan(20);\n      expect(operatorList.argsArray.length).toBeGreaterThan(20);\n      expect(operatorList.lastChunk).toEqual(true); // The `getOperatorList` method, similar to the `render` method,\n      // is supposed to include any existing Annotation-operatorLists.\n\n      expect(operatorList.fnArray.includes(OPS.beginAnnotation)).toEqual(true);\n      expect(operatorList.fnArray.includes(OPS.endAnnotation)).toEqual(true);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets operator list, with `annotationMode`-option","suites":["api","Page"],"line":1909,"updatePoint":{"line":1909,"column":56,"index":81431},"code":"    it(\"gets operator list, with `annotationMode`-option\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"evaljs.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(2);\n      pdfDoc.annotationStorage.setValue(\"30R\", {\n        value: \"test\"\n      });\n      pdfDoc.annotationStorage.setValue(\"31R\", {\n        value: true\n      });\n      const opListAnnotDisable = await pdfPage.getOperatorList({\n        annotationMode: AnnotationMode.DISABLE\n      });\n      expect(opListAnnotDisable.fnArray.length).toEqual(0);\n      expect(opListAnnotDisable.argsArray.length).toEqual(0);\n      expect(opListAnnotDisable.lastChunk).toEqual(true);\n      const opListAnnotEnable = await pdfPage.getOperatorList({\n        annotationMode: AnnotationMode.ENABLE\n      });\n      expect(opListAnnotEnable.fnArray.length).toBeGreaterThan(140);\n      expect(opListAnnotEnable.argsArray.length).toBeGreaterThan(140);\n      expect(opListAnnotEnable.lastChunk).toEqual(true);\n      const opListAnnotEnableForms = await pdfPage.getOperatorList({\n        annotationMode: AnnotationMode.ENABLE_FORMS\n      });\n      expect(opListAnnotEnableForms.fnArray.length).toBeGreaterThan(30);\n      expect(opListAnnotEnableForms.argsArray.length).toBeGreaterThan(30);\n      expect(opListAnnotEnableForms.lastChunk).toEqual(true);\n      const opListAnnotEnableStorage = await pdfPage.getOperatorList({\n        annotationMode: AnnotationMode.ENABLE_STORAGE\n      });\n      expect(opListAnnotEnableStorage.fnArray.length).toBeGreaterThan(170);\n      expect(opListAnnotEnableStorage.argsArray.length).toBeGreaterThan(170);\n      expect(opListAnnotEnableStorage.lastChunk).toEqual(true); // Sanity check to ensure that the `annotationMode` is correctly applied.\n\n      expect(opListAnnotDisable.fnArray.length).toBeLessThan(opListAnnotEnableForms.fnArray.length);\n      expect(opListAnnotEnableForms.fnArray.length).toBeLessThan(opListAnnotEnable.fnArray.length);\n      expect(opListAnnotEnable.fnArray.length).toBeLessThan(opListAnnotEnableStorage.fnArray.length);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets operatorList, with page resources containing corrupt /CCITTFaxDecode data","suites":["api","Page"],"line":1949,"updatePoint":{"line":1949,"column":86,"index":83606},"code":"    it(\"gets operatorList, with page resources containing corrupt /CCITTFaxDecode data\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"poppler-90-0-fuzzed.pdf\"));\n      expect(loadingTask instanceof PDFDocumentLoadingTask).toEqual(true);\n      const pdfDoc = await loadingTask.promise;\n      expect(pdfDoc.numPages).toEqual(16);\n      const pdfPage = await pdfDoc.getPage(6);\n      expect(pdfPage instanceof PDFPageProxy).toEqual(true);\n      const opList = await pdfPage.getOperatorList();\n      expect(opList.fnArray.length).toBeGreaterThan(25);\n      expect(opList.argsArray.length).toBeGreaterThan(25);\n      expect(opList.lastChunk).toEqual(true);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets document stats after parsing page","suites":["api","Page"],"line":1962,"updatePoint":{"line":1962,"column":46,"index":84298},"code":"    it(\"gets document stats after parsing page\", async function () {\n      await page.getOperatorList();\n      const stats = pdfDocument.stats;\n      const expectedStreamTypes = {\n        [StreamType.FLATE]: true\n      };\n      const expectedFontTypes = {\n        [FontType.TYPE1STANDARD]: true,\n        [FontType.CIDFONTTYPE2]: true\n      };\n      expect(stats).toEqual({\n        streamTypes: expectedStreamTypes,\n        fontTypes: expectedFontTypes\n      });\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets page stats after parsing page, without `pdfBug` set","suites":["api","Page"],"line":1977,"updatePoint":{"line":1977,"column":64,"index":84786},"code":"    it(\"gets page stats after parsing page, without `pdfBug` set\", async function () {\n      await page.getOperatorList();\n      expect(page.stats).toEqual(null);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets page stats after parsing page, with `pdfBug` set","suites":["api","Page"],"line":1981,"updatePoint":{"line":1981,"column":61,"index":84954},"code":"    it(\"gets page stats after parsing page, with `pdfBug` set\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(basicApiFileName, {\n        pdfBug: true\n      }));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      await pdfPage.getOperatorList();\n      const stats = pdfPage.stats;\n      expect(stats instanceof StatTimer).toEqual(true);\n      expect(stats.times.length).toEqual(1);\n      const [statEntry] = stats.times;\n      expect(statEntry.name).toEqual(\"Page Request\");\n      expect(statEntry.end - statEntry.start).toBeGreaterThanOrEqual(0);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"gets page stats after rendering page, with `pdfBug` set","suites":["api","Page"],"line":1996,"updatePoint":{"line":1996,"column":63,"index":85632},"code":"    it(\"gets page stats after rendering page, with `pdfBug` set\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(basicApiFileName, {\n        pdfBug: true\n      }));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      const viewport = pdfPage.getViewport({\n        scale: 1\n      });\n      expect(viewport instanceof PageViewport).toEqual(true);\n      const canvasAndCtx = CanvasFactory.create(viewport.width, viewport.height);\n      const renderTask = pdfPage.render({\n        canvasContext: canvasAndCtx.context,\n        canvasFactory: CanvasFactory,\n        viewport\n      });\n      expect(renderTask instanceof RenderTask).toEqual(true);\n      await renderTask.promise;\n      const stats = pdfPage.stats;\n      expect(stats instanceof StatTimer).toEqual(true);\n      expect(stats.times.length).toEqual(3);\n      const [statEntryOne, statEntryTwo, statEntryThree] = stats.times;\n      expect(statEntryOne.name).toEqual(\"Page Request\");\n      expect(statEntryOne.end - statEntryOne.start).toBeGreaterThanOrEqual(0);\n      expect(statEntryTwo.name).toEqual(\"Rendering\");\n      expect(statEntryTwo.end - statEntryTwo.start).toBeGreaterThan(0);\n      expect(statEntryThree.name).toEqual(\"Overall\");\n      expect(statEntryThree.end - statEntryThree.start).toBeGreaterThan(0);\n      CanvasFactory.destroy(canvasAndCtx);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"cancels rendering of page","suites":["api","Page"],"line":2027,"updatePoint":{"line":2027,"column":33,"index":87044},"code":"    it(\"cancels rendering of page\", async function () {\n      const viewport = page.getViewport({\n        scale: 1\n      });\n      expect(viewport instanceof PageViewport).toEqual(true);\n      const canvasAndCtx = CanvasFactory.create(viewport.width, viewport.height);\n      const renderTask = page.render({\n        canvasContext: canvasAndCtx.context,\n        canvasFactory: CanvasFactory,\n        viewport\n      });\n      expect(renderTask instanceof RenderTask).toEqual(true);\n      renderTask.cancel();\n\n      try {\n        await renderTask.promise; // Shouldn't get here.\n\n        expect(false).toEqual(true);\n      } catch (reason) {\n        expect(reason instanceof RenderingCancelledException).toEqual(true);\n        expect(reason.message).toEqual(\"Rendering cancelled, page 1\");\n        expect(reason.type).toEqual(\"canvas\");\n      }\n\n      CanvasFactory.destroy(canvasAndCtx);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"re-render page, using the same canvas, after cancelling rendering","suites":["api","Page"],"line":2053,"updatePoint":{"line":2053,"column":73,"index":87979},"code":"    it(\"re-render page, using the same canvas, after cancelling rendering\", async function () {\n      const viewport = page.getViewport({\n        scale: 1\n      });\n      expect(viewport instanceof PageViewport).toEqual(true);\n      const canvasAndCtx = CanvasFactory.create(viewport.width, viewport.height);\n      const renderTask = page.render({\n        canvasContext: canvasAndCtx.context,\n        canvasFactory: CanvasFactory,\n        viewport\n      });\n      expect(renderTask instanceof RenderTask).toEqual(true);\n      renderTask.cancel();\n\n      try {\n        await renderTask.promise; // Shouldn't get here.\n\n        expect(false).toEqual(true);\n      } catch (reason) {\n        expect(reason instanceof RenderingCancelledException).toEqual(true);\n      }\n\n      const reRenderTask = page.render({\n        canvasContext: canvasAndCtx.context,\n        canvasFactory: CanvasFactory,\n        viewport\n      });\n      expect(reRenderTask instanceof RenderTask).toEqual(true);\n      await reRenderTask.promise;\n      CanvasFactory.destroy(canvasAndCtx);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"multiple render() on the same canvas","suites":["api","Page"],"line":2084,"updatePoint":{"line":2084,"column":44,"index":89016},"code":"    it(\"multiple render() on the same canvas\", async function () {\n      const optionalContentConfigPromise = pdfDocument.getOptionalContentConfig();\n      const viewport = page.getViewport({\n        scale: 1\n      });\n      expect(viewport instanceof PageViewport).toEqual(true);\n      const canvasAndCtx = CanvasFactory.create(viewport.width, viewport.height);\n      const renderTask1 = page.render({\n        canvasContext: canvasAndCtx.context,\n        canvasFactory: CanvasFactory,\n        viewport,\n        optionalContentConfigPromise\n      });\n      expect(renderTask1 instanceof RenderTask).toEqual(true);\n      const renderTask2 = page.render({\n        canvasContext: canvasAndCtx.context,\n        canvasFactory: CanvasFactory,\n        viewport,\n        optionalContentConfigPromise\n      });\n      expect(renderTask2 instanceof RenderTask).toEqual(true);\n      await Promise.all([renderTask1.promise, renderTask2.promise.then(() => {\n        // Shouldn't get here.\n        expect(false).toEqual(true);\n      }, reason => {\n        // It fails because we are already using this canvas.\n        expect(/multiple render\\(\\)/.test(reason.message)).toEqual(true);\n      })]);\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"cleans up document resources after rendering of page","suites":["api","Page"],"line":2113,"updatePoint":{"line":2113,"column":60,"index":90221},"code":"    it(\"cleans up document resources after rendering of page\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(basicApiFileName));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      const viewport = pdfPage.getViewport({\n        scale: 1\n      });\n      expect(viewport instanceof PageViewport).toEqual(true);\n      const canvasAndCtx = CanvasFactory.create(viewport.width, viewport.height);\n      const renderTask = pdfPage.render({\n        canvasContext: canvasAndCtx.context,\n        canvasFactory: CanvasFactory,\n        viewport\n      });\n      expect(renderTask instanceof RenderTask).toEqual(true);\n      await renderTask.promise;\n      await pdfDoc.cleanup();\n      expect(true).toEqual(true);\n      CanvasFactory.destroy(canvasAndCtx);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"cleans up document resources during rendering of page","suites":["api","Page"],"line":2134,"updatePoint":{"line":2134,"column":61,"index":91093},"code":"    it(\"cleans up document resources during rendering of page\", async function () {\n      const loadingTask = getDocument(buildGetDocumentParams(\"tracemonkey.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      const viewport = pdfPage.getViewport({\n        scale: 1\n      });\n      expect(viewport instanceof PageViewport).toEqual(true);\n      const canvasAndCtx = CanvasFactory.create(viewport.width, viewport.height);\n      const renderTask = pdfPage.render({\n        canvasContext: canvasAndCtx.context,\n        canvasFactory: CanvasFactory,\n        viewport\n      });\n      expect(renderTask instanceof RenderTask).toEqual(true); // Ensure that clean-up runs during rendering.\n\n      renderTask.onContinue = function (cont) {\n        waitSome(cont);\n      };\n\n      try {\n        await pdfDoc.cleanup(); // Shouldn't get here.\n\n        expect(false).toEqual(true);\n      } catch (reason) {\n        expect(reason instanceof Error).toEqual(true);\n        expect(reason.message).toEqual(\"startCleanup: Page 1 is currently rendering.\");\n      }\n\n      await renderTask.promise;\n      CanvasFactory.destroy(canvasAndCtx);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"caches image resources at the document/page level as expected (issue 11878)","suites":["api","Page"],"line":2167,"updatePoint":{"line":2167,"column":83,"index":92336},"code":"    it(\"caches image resources at the document/page level as expected (issue 11878)\", async function () {\n      const {\n        NUM_PAGES_THRESHOLD\n      } = GlobalImageCache,\n            EXPECTED_WIDTH = 2550,\n            EXPECTED_HEIGHT = 3300;\n      const loadingTask = getDocument(buildGetDocumentParams(\"issue11878.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      let firstImgData = null;\n\n      for (let i = 1; i <= pdfDoc.numPages; i++) {\n        const pdfPage = await pdfDoc.getPage(i);\n        const opList = await pdfPage.getOperatorList();\n        const {\n          commonObjs,\n          objs\n        } = pdfPage;\n        const imgIndex = opList.fnArray.indexOf(OPS.paintImageXObject);\n        const [objId, width, height] = opList.argsArray[imgIndex];\n\n        if (i < NUM_PAGES_THRESHOLD) {\n          expect(objId).toEqual(`img_p${i - 1}_1`);\n          expect(objs.has(objId)).toEqual(true);\n          expect(commonObjs.has(objId)).toEqual(false);\n        } else {\n          expect(objId).toEqual(`g_${loadingTask.docId}_img_p${NUM_PAGES_THRESHOLD - 1}_1`);\n          expect(objs.has(objId)).toEqual(false);\n          expect(commonObjs.has(objId)).toEqual(true);\n        }\n\n        expect(width).toEqual(EXPECTED_WIDTH);\n        expect(height).toEqual(EXPECTED_HEIGHT); // Ensure that the actual image data is identical for all pages.\n\n        if (i === 1) {\n          firstImgData = objs.get(objId);\n          expect(firstImgData.width).toEqual(EXPECTED_WIDTH);\n          expect(firstImgData.height).toEqual(EXPECTED_HEIGHT);\n          expect(firstImgData.kind).toEqual(ImageKind.RGB_24BPP);\n          expect(firstImgData.data instanceof Uint8ClampedArray).toEqual(true);\n          expect(firstImgData.data.length).toEqual(25245000);\n        } else {\n          const objsPool = i >= NUM_PAGES_THRESHOLD ? commonObjs : objs;\n          const currentImgData = objsPool.get(objId);\n          expect(currentImgData.width).toEqual(firstImgData.width);\n          expect(currentImgData.height).toEqual(firstImgData.height);\n          expect(currentImgData.kind).toEqual(firstImgData.kind);\n          expect(currentImgData.data instanceof Uint8ClampedArray).toEqual(true);\n          expect(currentImgData.data.every((value, index) => {\n            return value === firstImgData.data[index];\n          })).toEqual(true);\n        }\n      }\n\n      await loadingTask.destroy();\n      firstImgData = null;\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"render for printing, with `printAnnotationStorage` set","suites":["api","Page"],"line":2223,"updatePoint":{"line":2223,"column":62,"index":94742},"code":"    it(\"render for printing, with `printAnnotationStorage` set\", async function () {\n      async function getPrintData(printAnnotationStorage = null) {\n        const canvasAndCtx = CanvasFactory.create(viewport.width, viewport.height);\n        const renderTask = pdfPage.render({\n          canvasContext: canvasAndCtx.context,\n          canvasFactory: CanvasFactory,\n          viewport,\n          intent: \"print\",\n          annotationMode: AnnotationMode.ENABLE_STORAGE,\n          printAnnotationStorage\n        });\n        await renderTask.promise;\n        const printData = canvasAndCtx.canvas.toDataURL();\n        CanvasFactory.destroy(canvasAndCtx);\n        return printData;\n      }\n\n      const loadingTask = getDocument(buildGetDocumentParams(\"annotation-tx.pdf\"));\n      const pdfDoc = await loadingTask.promise;\n      const pdfPage = await pdfDoc.getPage(1);\n      const viewport = pdfPage.getViewport({\n        scale: 1\n      }); // Update the contents of the form-field.\n\n      const {\n        annotationStorage\n      } = pdfDoc;\n      annotationStorage.setValue(\"22R\", {\n        value: \"Hello World\"\n      }); // Render for printing, with default parameters.\n\n      const printOriginalData = await getPrintData(); // Get the *frozen* print-storage for use during printing.\n\n      const printAnnotationStorage = annotationStorage.print; // Update the contents of the form-field again.\n\n      annotationStorage.setValue(\"22R\", {\n        value: \"Printing again...\"\n      });\n      const annotationHash = AnnotationStorage.getHash(annotationStorage.serializable);\n      const printAnnotationHash = AnnotationStorage.getHash(printAnnotationStorage.serializable); // Sanity check to ensure that the print-storage didn't change,\n      // after the form-field was updated.\n\n      expect(printAnnotationHash).not.toEqual(annotationHash); // Render for printing again, after updating the form-field,\n      // with default parameters.\n\n      const printAgainData = await getPrintData(); // Render for printing again, after updating the form-field,\n      // with `printAnnotationStorage` set.\n\n      const printStorageData = await getPrintData(printAnnotationStorage); // Ensure that printing again, with default parameters,\n      // actually uses the \"new\" form-field data.\n\n      expect(printAgainData).not.toEqual(printOriginalData); // Finally ensure that printing, with `printAnnotationStorage` set,\n      // still uses the \"previous\" form-field data.\n\n      expect(printStorageData).toEqual(printOriginalData);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"should correctly render PDFs in parallel","suites":["api","Multiple `getDocument` instances"],"line":2322,"updatePoint":{"line":2322,"column":48,"index":98998},"code":"    it(\"should correctly render PDFs in parallel\", async function () {\n      let baseline1, baseline2, baseline3;\n      const promiseDone = renderPDF(pdf1).then(function (data1) {\n        baseline1 = data1;\n        return renderPDF(pdf2);\n      }).then(function (data2) {\n        baseline2 = data2;\n        return renderPDF(pdf3);\n      }).then(function (data3) {\n        baseline3 = data3;\n        return Promise.all([renderPDF(pdf1), renderPDF(pdf2), renderPDF(pdf3)]);\n      }).then(function (dataUrls) {\n        expect(dataUrls[0]).toEqual(baseline1);\n        expect(dataUrls[1]).toEqual(baseline2);\n        expect(dataUrls[2]).toEqual(baseline3);\n        return true;\n      });\n      await promiseDone;\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"should fetch document info and page using ranges","suites":["api","PDFDataRangeTransport"],"line":2353,"updatePoint":{"line":2353,"column":56,"index":100041},"code":"    it(\"should fetch document info and page using ranges\", async function () {\n      const initialDataLength = 4000;\n      let fetches = 0;\n      const data = await dataPromise;\n      const initialData = data.subarray(0, initialDataLength);\n      const transport = new PDFDataRangeTransport(data.length, initialData);\n\n      transport.requestDataRange = function (begin, end) {\n        fetches++;\n        waitSome(function () {\n          transport.onDataProgress(4000);\n          transport.onDataRange(begin, data.subarray(begin, end));\n        });\n      };\n\n      const loadingTask = getDocument(transport);\n      const pdfDocument = await loadingTask.promise;\n      expect(pdfDocument.numPages).toEqual(14);\n      const pdfPage = await pdfDocument.getPage(10);\n      expect(pdfPage.rotate).toEqual(0);\n      expect(fetches).toBeGreaterThan(2);\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"should fetch document info and page using range and streaming","suites":["api","PDFDataRangeTransport"],"line":2376,"updatePoint":{"line":2376,"column":69,"index":100943},"code":"    it(\"should fetch document info and page using range and streaming\", async function () {\n      const initialDataLength = 4000;\n      let fetches = 0;\n      const data = await dataPromise;\n      const initialData = data.subarray(0, initialDataLength);\n      const transport = new PDFDataRangeTransport(data.length, initialData);\n\n      transport.requestDataRange = function (begin, end) {\n        fetches++;\n\n        if (fetches === 1) {\n          // Send rest of the data on first range request.\n          transport.onDataProgressiveRead(data.subarray(initialDataLength));\n        }\n\n        waitSome(function () {\n          transport.onDataRange(begin, data.subarray(begin, end));\n        });\n      };\n\n      const loadingTask = getDocument(transport);\n      const pdfDocument = await loadingTask.promise;\n      expect(pdfDocument.numPages).toEqual(14);\n      const pdfPage = await pdfDocument.getPage(10);\n      expect(pdfPage.rotate).toEqual(0);\n      expect(fetches).toEqual(1);\n      await new Promise(resolve => {\n        waitSome(resolve);\n      });\n      await loadingTask.destroy();\n    });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"handles invalid base URLs","suites":["api","PDFWorkerUtil","isSameOrigin"],"line":2435,"updatePoint":{"line":2435,"column":35,"index":102914},"code":"      it(\"handles invalid base URLs\", function () {\n        // The base URL is not valid.\n        expect(isSameOrigin(\"/foo\", \"/bar\")).toEqual(false); // The base URL has no origin.\n\n        expect(isSameOrigin(\"blob:foo\", \"/bar\")).toEqual(false);\n      });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"correctly checks if the origin of both URLs matches","suites":["api","PDFWorkerUtil","isSameOrigin"],"line":2441,"updatePoint":{"line":2441,"column":61,"index":103198},"code":"      it(\"correctly checks if the origin of both URLs matches\", function () {\n        expect(isSameOrigin(\"https://www.mozilla.org/foo\", \"https://www.mozilla.org/bar\")).toEqual(true);\n        expect(isSameOrigin(\"https://www.mozilla.org/foo\", \"https://www.example.com/bar\")).toEqual(false);\n      });","file":"unit/api_spec.js","skipped":false,"dir":"test"},{"name":"handles `push` correctly","suites":["BaseViewer","PDFPageViewBuffer"],"line":31,"updatePoint":{"line":31,"column":32,"index":1013},"code":"    it(\"handles `push` correctly\", function () {\n      const buffer = new PDFPageViewBuffer(3);\n      const viewsMap = createViewsMap(1, 5),\n            iterator = viewsMap.values();\n\n      for (let i = 0; i < 3; i++) {\n        const view = iterator.next().value;\n        buffer.push(view);\n      } // Ensure that the correct views are inserted.\n\n\n      expect([...buffer]).toEqual([viewsMap.get(1), viewsMap.get(2), viewsMap.get(3)]);\n\n      for (let i = 3; i < 5; i++) {\n        const view = iterator.next().value;\n        buffer.push(view);\n      } // Ensure that the correct views are evicted.\n\n\n      expect([...buffer]).toEqual([viewsMap.get(3), viewsMap.get(4), viewsMap.get(5)]);\n    });","file":"unit/base_viewer_spec.js","skipped":false,"dir":"test"},{"name":"handles `resize` correctly","suites":["BaseViewer","PDFPageViewBuffer"],"line":52,"updatePoint":{"line":52,"column":34,"index":1711},"code":"    it(\"handles `resize` correctly\", function () {\n      const buffer = new PDFPageViewBuffer(5);\n      const viewsMap = createViewsMap(1, 5),\n            iterator = viewsMap.values();\n\n      for (let i = 0; i < 5; i++) {\n        const view = iterator.next().value;\n        buffer.push(view);\n      } // Ensure that keeping the size constant won't evict any views.\n\n\n      buffer.resize(5);\n      expect([...buffer]).toEqual([viewsMap.get(1), viewsMap.get(2), viewsMap.get(3), viewsMap.get(4), viewsMap.get(5)]); // Ensure that increasing the size won't evict any views.\n\n      buffer.resize(10);\n      expect([...buffer]).toEqual([viewsMap.get(1), viewsMap.get(2), viewsMap.get(3), viewsMap.get(4), viewsMap.get(5)]); // Ensure that decreasing the size will evict the correct views.\n\n      buffer.resize(3);\n      expect([...buffer]).toEqual([viewsMap.get(3), viewsMap.get(4), viewsMap.get(5)]);\n    });","file":"unit/base_viewer_spec.js","skipped":false,"dir":"test"},{"name":"handles `resize` correctly, with `idsToKeep` provided","suites":["BaseViewer","PDFPageViewBuffer"],"line":72,"updatePoint":{"line":72,"column":61,"index":2643},"code":"    it(\"handles `resize` correctly, with `idsToKeep` provided\", function () {\n      const buffer = new PDFPageViewBuffer(5);\n      const viewsMap = createViewsMap(1, 5),\n            iterator = viewsMap.values();\n\n      for (let i = 0; i < 5; i++) {\n        const view = iterator.next().value;\n        buffer.push(view);\n      } // Ensure that keeping the size constant won't evict any views,\n      // while re-ordering them correctly.\n\n\n      buffer.resize(5, new Set([1, 2]));\n      expect([...buffer]).toEqual([viewsMap.get(3), viewsMap.get(4), viewsMap.get(5), viewsMap.get(1), viewsMap.get(2)]); // Ensure that increasing the size won't evict any views,\n      // while re-ordering them correctly.\n\n      buffer.resize(10, new Set([3, 4, 5]));\n      expect([...buffer]).toEqual([viewsMap.get(1), viewsMap.get(2), viewsMap.get(3), viewsMap.get(4), viewsMap.get(5)]); // Ensure that decreasing the size will evict the correct views,\n      // while re-ordering the remaining ones correctly.\n\n      buffer.resize(3, new Set([1, 2, 5]));\n      expect([...buffer]).toEqual([viewsMap.get(1), viewsMap.get(2), viewsMap.get(5)]);\n    });","file":"unit/base_viewer_spec.js","skipped":false,"dir":"test"},{"name":"handles `has` correctly","suites":["BaseViewer","PDFPageViewBuffer"],"line":95,"updatePoint":{"line":95,"column":31,"index":3745},"code":"    it(\"handles `has` correctly\", function () {\n      const buffer = new PDFPageViewBuffer(3);\n      const viewsMap = createViewsMap(1, 2),\n            iterator = viewsMap.values();\n\n      for (let i = 0; i < 1; i++) {\n        const view = iterator.next().value;\n        buffer.push(view);\n      }\n\n      expect(buffer.has(viewsMap.get(1))).toEqual(true);\n      expect(buffer.has(viewsMap.get(2))).toEqual(false);\n    });","file":"unit/base_viewer_spec.js","skipped":false,"dir":"test"},{"name":"should mark text as LTR if there's only LTR-characters","suites":["bidi"],"line":23,"updatePoint":{"line":23,"column":60,"index":1005},"code":"  it(\"should mark text as LTR if there's only LTR-characters\", function () {\n    const str = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit.\";\n    const bidiText = bidi(str, -1, false);\n    expect(bidiText.str).toEqual(\"Lorem ipsum dolor sit amet, consectetur adipisicing elit.\");\n    expect(bidiText.dir).toEqual(\"ltr\");\n  });","file":"unit/bidi_spec.js","skipped":false,"dir":"test"},{"name":"should mark text as RTL if more than 30% of text is RTL","suites":["bidi"],"line":29,"updatePoint":{"line":29,"column":61,"index":1345},"code":"  it(\"should mark text as RTL if more than 30% of text is RTL\", function () {\n    // 33% of test text are RTL characters\n    const test = \"\\u0645\\u0635\\u0631 Egypt\";\n    const result = \"Egypt \\u0631\\u0635\\u0645\";\n    const bidiText = bidi(test, -1, false);\n    expect(bidiText.str).toEqual(result);\n    expect(bidiText.dir).toEqual(\"rtl\");\n  });","file":"unit/bidi_spec.js","skipped":false,"dir":"test"},{"name":"should mark text as LTR if less than 30% of text is RTL","suites":["bidi"],"line":37,"updatePoint":{"line":37,"column":61,"index":1691},"code":"  it(\"should mark text as LTR if less than 30% of text is RTL\", function () {\n    const test = \"Egypt is known as \\u0645\\u0635\\u0631 in Arabic.\";\n    const result = \"Egypt is known as \\u0631\\u0635\\u0645 in Arabic.\";\n    const bidiText = bidi(test, -1, false);\n    expect(bidiText.str).toEqual(result);\n    expect(bidiText.dir).toEqual(\"ltr\");\n  });","file":"unit/bidi_spec.js","skipped":false,"dir":"test"},{"name":"parses header","suites":["CFFParser"],"line":60,"updatePoint":{"line":60,"column":19,"index":2188},"code":"  it(\"parses header\", function () {\n    const header = cff.header;\n    expect(header.major).toEqual(1);\n    expect(header.minor).toEqual(0);\n    expect(header.hdrSize).toEqual(4);\n    expect(header.offSize).toEqual(1);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses name index","suites":["CFFParser"],"line":67,"updatePoint":{"line":67,"column":23,"index":2417},"code":"  it(\"parses name index\", function () {\n    const names = cff.names;\n    expect(names.length).toEqual(1);\n    expect(names[0]).toEqual(\"ABCDEF+Times-Roman\");\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses string index","suites":["CFFParser"],"line":72,"updatePoint":{"line":72,"column":25,"index":2583},"code":"  it(\"parses string index\", function () {\n    const strings = cff.strings;\n    expect(strings.count).toEqual(3);\n    expect(strings.get(0)).toEqual(\".notdef\");\n    expect(strings.get(391)).toEqual(\"001.007\");\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses top dict","suites":["CFFParser"],"line":78,"updatePoint":{"line":78,"column":21,"index":2794},"code":"  it(\"parses top dict\", function () {\n    const topDict = cff.topDict; // 391 version 392 FullName 393 FamilyName 389 Weight 28416 UniqueID\n    // -168 -218 1000 898 FontBBox 94 CharStrings 45 102 Private\n\n    expect(topDict.getByName(\"version\")).toEqual(391);\n    expect(topDict.getByName(\"FullName\")).toEqual(392);\n    expect(topDict.getByName(\"FamilyName\")).toEqual(393);\n    expect(topDict.getByName(\"Weight\")).toEqual(389);\n    expect(topDict.getByName(\"UniqueID\")).toEqual(28416);\n    expect(topDict.getByName(\"FontBBox\")).toEqual([-168, -218, 1000, 898]);\n    expect(topDict.getByName(\"CharStrings\")).toEqual(94);\n    expect(topDict.getByName(\"Private\")).toEqual([45, 102]);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"refuses to add topDict key with invalid value (bug 1068432)","suites":["CFFParser"],"line":91,"updatePoint":{"line":91,"column":65,"index":3526},"code":"  it(\"refuses to add topDict key with invalid value (bug 1068432)\", function () {\n    const topDict = cff.topDict;\n    const defaultValue = topDict.getByName(\"UnderlinePosition\");\n    topDict.setByKey(\n    /* [12, 3] = */\n    3075, [NaN]);\n    expect(topDict.getByName(\"UnderlinePosition\")).toEqual(defaultValue);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses a CharString having cntrmask","suites":["CFFParser"],"line":113,"updatePoint":{"line":113,"column":41,"index":4423},"code":"  it(\"parses a CharString having cntrmask\", function () {\n    // prettier-ignore\n    const bytes = new Uint8Array([0, 1, // count\n    1, // offsetSize\n    0, // offset[0]\n    38, // end\n    149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 1, // hstem\n    149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 149, 3, // vstem\n    20, // cntrmask\n    22, 22, // fail if misparsed as hmoveto\n    14 // endchar\n    ]);\n    parser.bytes = bytes;\n    const charStringsIndex = parser.parseIndex(0).obj;\n    const charStrings = parser.parseCharStrings({\n      charStrings: charStringsIndex,\n      privateDict: privateDictStub\n    }).charStrings;\n    expect(charStrings.count).toEqual(1); // shouldn't be sanitized\n\n    expect(charStrings.get(0).length).toEqual(38);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses a CharString endchar with 4 args w/seac enabled","suites":["CFFParser"],"line":135,"updatePoint":{"line":135,"column":60,"index":5259},"code":"  it(\"parses a CharString endchar with 4 args w/seac enabled\", function () {\n    const cffParser = new CFFParser(fontData, {},\n    /* seacAnalysisEnabled = */\n    true);\n    cffParser.parse(); // cff\n    // prettier-ignore\n\n    const bytes = new Uint8Array([0, 1, // count\n    1, // offsetSize\n    0, // offset[0]\n    237, 247, 22, 247, 72, 204, 247, 86, 14]);\n    cffParser.bytes = bytes;\n    const charStringsIndex = cffParser.parseIndex(0).obj;\n    const result = cffParser.parseCharStrings({\n      charStrings: charStringsIndex,\n      privateDict: privateDictStub\n    });\n    expect(result.charStrings.count).toEqual(1);\n    expect(result.charStrings.get(0).length).toEqual(1);\n    expect(result.seacs.length).toEqual(1);\n    expect(result.seacs[0].length).toEqual(4);\n    expect(result.seacs[0][0]).toEqual(130);\n    expect(result.seacs[0][1]).toEqual(180);\n    expect(result.seacs[0][2]).toEqual(65);\n    expect(result.seacs[0][3]).toEqual(194);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses a CharString endchar with 4 args w/seac disabled","suites":["CFFParser"],"line":161,"updatePoint":{"line":161,"column":61,"index":6218},"code":"  it(\"parses a CharString endchar with 4 args w/seac disabled\", function () {\n    const cffParser = new CFFParser(fontData, {},\n    /* seacAnalysisEnabled = */\n    false);\n    cffParser.parse(); // cff\n    // prettier-ignore\n\n    const bytes = new Uint8Array([0, 1, // count\n    1, // offsetSize\n    0, // offset[0]\n    237, 247, 22, 247, 72, 204, 247, 86, 14]);\n    cffParser.bytes = bytes;\n    const charStringsIndex = cffParser.parseIndex(0).obj;\n    const result = cffParser.parseCharStrings({\n      charStrings: charStringsIndex,\n      privateDict: privateDictStub\n    });\n    expect(result.charStrings.count).toEqual(1);\n    expect(result.charStrings.get(0).length).toEqual(9);\n    expect(result.seacs.length).toEqual(0);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses a CharString endchar no args","suites":["CFFParser"],"line":182,"updatePoint":{"line":182,"column":41,"index":6932},"code":"  it(\"parses a CharString endchar no args\", function () {\n    // prettier-ignore\n    const bytes = new Uint8Array([0, 1, // count\n    1, // offsetSize\n    0, // offset[0]\n    14]);\n    parser.bytes = bytes;\n    const charStringsIndex = parser.parseIndex(0).obj;\n    const result = parser.parseCharStrings({\n      charStrings: charStringsIndex,\n      privateDict: privateDictStub\n    });\n    expect(result.charStrings.count).toEqual(1);\n    expect(result.charStrings.get(0)[0]).toEqual(14);\n    expect(result.seacs.length).toEqual(0);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses predefined charsets","suites":["CFFParser"],"line":198,"updatePoint":{"line":198,"column":32,"index":7463},"code":"  it(\"parses predefined charsets\", function () {\n    const charset = parser.parseCharsets(0, 0, null, true);\n    expect(charset.predefined).toEqual(true);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses charset format 0","suites":["CFFParser"],"line":202,"updatePoint":{"line":202,"column":29,"index":7621},"code":"  it(\"parses charset format 0\", function () {\n    // The first three bytes make the offset large enough to skip predefined.\n    // prettier-ignore\n    const bytes = new Uint8Array([0x00, 0x00, 0x00, 0x00, // format\n    0x00, 0x02 // sid/cid\n    ]);\n    parser.bytes = bytes;\n    let charset = parser.parseCharsets(3, 2, new CFFStrings(), false);\n    expect(charset.charset[1]).toEqual(\"exclam\"); // CID font\n\n    charset = parser.parseCharsets(3, 2, new CFFStrings(), true);\n    expect(charset.charset[1]).toEqual(2);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses charset format 1","suites":["CFFParser"],"line":215,"updatePoint":{"line":215,"column":29,"index":8145},"code":"  it(\"parses charset format 1\", function () {\n    // The first three bytes make the offset large enough to skip predefined.\n    // prettier-ignore\n    const bytes = new Uint8Array([0x00, 0x00, 0x00, 0x01, // format\n    0x00, 0x08, // sid/cid start\n    0x01 // sid/cid left\n    ]);\n    parser.bytes = bytes;\n    let charset = parser.parseCharsets(3, 2, new CFFStrings(), false);\n    expect(charset.charset).toEqual([\".notdef\", \"quoteright\", \"parenleft\"]); // CID font\n\n    charset = parser.parseCharsets(3, 2, new CFFStrings(), true);\n    expect(charset.charset).toEqual([0, 8, 9]);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses charset format 2","suites":["CFFParser"],"line":229,"updatePoint":{"line":229,"column":29,"index":8733},"code":"  it(\"parses charset format 2\", function () {\n    // format 2 is the same as format 1 but the left is card16\n    // The first three bytes make the offset large enough to skip predefined.\n    // prettier-ignore\n    const bytes = new Uint8Array([0x00, 0x00, 0x00, 0x02, // format\n    0x00, 0x08, // sid/cid start\n    0x00, 0x01 // sid/cid left\n    ]);\n    parser.bytes = bytes;\n    let charset = parser.parseCharsets(3, 2, new CFFStrings(), false);\n    expect(charset.charset).toEqual([\".notdef\", \"quoteright\", \"parenleft\"]); // CID font\n\n    charset = parser.parseCharsets(3, 2, new CFFStrings(), true);\n    expect(charset.charset).toEqual([0, 8, 9]);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses encoding format 0","suites":["CFFParser"],"line":244,"updatePoint":{"line":244,"column":30,"index":9391},"code":"  it(\"parses encoding format 0\", function () {\n    // The first two bytes make the offset large enough to skip predefined.\n    // prettier-ignore\n    const bytes = new Uint8Array([0x00, 0x00, 0x00, // format\n    0x01, // count\n    0x08 // start\n    ]);\n    parser.bytes = bytes;\n    const encoding = parser.parseEncoding(2, {}, new CFFStrings(), null);\n    expect(encoding.encoding).toEqual(createWithNullProto({\n      0x8: 1\n    }));\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses encoding format 1","suites":["CFFParser"],"line":257,"updatePoint":{"line":257,"column":30,"index":9832},"code":"  it(\"parses encoding format 1\", function () {\n    // The first two bytes make the offset large enough to skip predefined.\n    // prettier-ignore\n    const bytes = new Uint8Array([0x00, 0x00, 0x01, // format\n    0x01, // num ranges\n    0x07, // range1 start\n    0x01 // range2 left\n    ]);\n    parser.bytes = bytes;\n    const encoding = parser.parseEncoding(2, {}, new CFFStrings(), null);\n    expect(encoding.encoding).toEqual(createWithNullProto({\n      0x7: 0x01,\n      0x08: 0x02\n    }));\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses fdselect format 0","suites":["CFFParser"],"line":272,"updatePoint":{"line":272,"column":30,"index":10331},"code":"  it(\"parses fdselect format 0\", function () {\n    // prettier-ignore\n    const bytes = new Uint8Array([0x00, // format\n    0x00, // gid: 0 fd: 0\n    0x01 // gid: 1 fd: 1\n    ]);\n    parser.bytes = bytes.slice();\n    const fdSelect = parser.parseFDSelect(0, 2);\n    expect(fdSelect.fdSelect).toEqual([0, 1]);\n    expect(fdSelect.format).toEqual(0);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses fdselect format 3","suites":["CFFParser"],"line":283,"updatePoint":{"line":283,"column":30,"index":10686},"code":"  it(\"parses fdselect format 3\", function () {\n    // prettier-ignore\n    const bytes = new Uint8Array([0x03, // format\n    0x00, 0x02, // range count\n    0x00, 0x00, // first gid\n    0x09, // font dict 1 id\n    0x00, 0x02, // next gid\n    0x0a, // font dict 2 id\n    0x00, 0x04 // sentinel (last gid)\n    ]);\n    parser.bytes = bytes.slice();\n    const fdSelect = parser.parseFDSelect(0, 4);\n    expect(fdSelect.fdSelect).toEqual([9, 9, 0xa, 0xa]);\n    expect(fdSelect.format).toEqual(3);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses invalid fdselect format 3 (bug 1146106)","suites":["CFFParser"],"line":298,"updatePoint":{"line":298,"column":52,"index":11204},"code":"  it(\"parses invalid fdselect format 3 (bug 1146106)\", function () {\n    // prettier-ignore\n    const bytes = new Uint8Array([0x03, // format\n    0x00, 0x02, // range count\n    0x00, 0x01, // first gid (invalid)\n    0x09, // font dict 1 id\n    0x00, 0x02, // next gid\n    0x0a, // font dict 2 id\n    0x00, 0x04 // sentinel (last gid)\n    ]);\n    parser.bytes = bytes.slice();\n    const fdSelect = parser.parseFDSelect(0, 4);\n    expect(fdSelect.fdSelect).toEqual([9, 9, 0xa, 0xa]);\n    expect(fdSelect.format).toEqual(3);\n  }); // TODO fdArray","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"encodes integers","suites":["CFFCompiler"],"line":324,"updatePoint":{"line":324,"column":22,"index":11947},"code":"  it(\"encodes integers\", function () {\n    const c = new CFFCompiler(); // all the examples from the spec\n\n    expect(c.encodeInteger(0)).toEqual([0x8b]);\n    expect(c.encodeInteger(100)).toEqual([0xef]);\n    expect(c.encodeInteger(-100)).toEqual([0x27]);\n    expect(c.encodeInteger(1000)).toEqual([0xfa, 0x7c]);\n    expect(c.encodeInteger(-1000)).toEqual([0xfe, 0x7c]);\n    expect(c.encodeInteger(10000)).toEqual([0x1c, 0x27, 0x10]);\n    expect(c.encodeInteger(-10000)).toEqual([0x1c, 0xd8, 0xf0]);\n    expect(c.encodeInteger(100000)).toEqual([0x1d, 0x00, 0x01, 0x86, 0xa0]);\n    expect(c.encodeInteger(-100000)).toEqual([0x1d, 0xff, 0xfe, 0x79, 0x60]);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"encodes floats","suites":["CFFCompiler"],"line":337,"updatePoint":{"line":337,"column":20,"index":12606},"code":"  it(\"encodes floats\", function () {\n    const c = new CFFCompiler();\n    expect(c.encodeFloat(-2.25)).toEqual([0x1e, 0xe2, 0xa2, 0x5f]);\n    expect(c.encodeFloat(5e-11)).toEqual([0x1e, 0x5c, 0x11, 0xff]);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"sanitizes name index","suites":["CFFCompiler"],"line":342,"updatePoint":{"line":342,"column":26,"index":12824},"code":"  it(\"sanitizes name index\", function () {\n    const c = new CFFCompiler();\n    let nameIndexCompiled = c.compileNameIndex([\"[a\"]);\n    let parser = testParser(nameIndexCompiled);\n    let nameIndex = parser.parseIndex(0);\n    let names = parser.parseNameIndex(nameIndex.obj);\n    expect(names).toEqual([\"_a\"]);\n    let longName = \"\";\n\n    for (let i = 0; i < 129; i++) {\n      longName += \"_\";\n    }\n\n    nameIndexCompiled = c.compileNameIndex([longName]);\n    parser = testParser(nameIndexCompiled);\n    nameIndex = parser.parseIndex(0);\n    names = parser.parseNameIndex(nameIndex.obj);\n    expect(names[0].length).toEqual(127);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"compiles fdselect format 0","suites":["CFFCompiler"],"line":361,"updatePoint":{"line":361,"column":32,"index":13467},"code":"  it(\"compiles fdselect format 0\", function () {\n    const fdSelect = new CFFFDSelect(0, [3, 2, 1]);\n    const c = new CFFCompiler();\n    const out = c.compileFDSelect(fdSelect);\n    expect(out).toEqual([0, // format\n    3, // gid: 0 fd 3\n    2, // gid: 1 fd 3\n    1 // gid: 2 fd 3\n    ]);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"compiles fdselect format 3","suites":["CFFCompiler"],"line":371,"updatePoint":{"line":371,"column":32,"index":13763},"code":"  it(\"compiles fdselect format 3\", function () {\n    const fdSelect = new CFFFDSelect(3, [0, 0, 1, 1]);\n    const c = new CFFCompiler();\n    const out = c.compileFDSelect(fdSelect);\n    expect(out).toEqual([3, // format\n    0, // nRanges (high)\n    2, // nRanges (low)\n    0, // range struct 0 - first (high)\n    0, // range struct 0 - first (low)\n    0, // range struct 0 - fd\n    0, // range struct 0 - first (high)\n    2, // range struct 0 - first (low)\n    1, // range struct 0 - fd\n    0, // sentinel (high)\n    4 // sentinel (low)\n    ]);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"compiles fdselect format 3, single range","suites":["CFFCompiler"],"line":388,"updatePoint":{"line":388,"column":46,"index":14328},"code":"  it(\"compiles fdselect format 3, single range\", function () {\n    const fdSelect = new CFFFDSelect(3, [0, 0]);\n    const c = new CFFCompiler();\n    const out = c.compileFDSelect(fdSelect);\n    expect(out).toEqual([3, // format\n    0, // nRanges (high)\n    1, // nRanges (low)\n    0, // range struct 0 - first (high)\n    0, // range struct 0 - first (low)\n    0, // range struct 0 - fd\n    0, // sentinel (high)\n    2 // sentinel (low)\n    ]);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"compiles charset of CID font","suites":["CFFCompiler"],"line":402,"updatePoint":{"line":402,"column":34,"index":14766},"code":"  it(\"compiles charset of CID font\", function () {\n    const charset = new CFFCharset();\n    const c = new CFFCompiler();\n    const numGlyphs = 7;\n    const out = c.compileCharset(charset, numGlyphs, new CFFStrings(), true); // All CID charsets get turned into a simple format 2.\n\n    expect(out).toEqual([2, // format\n    0, // cid (high)\n    0, // cid (low)\n    0, // nLeft (high)\n    numGlyphs - 1 // nLeft (low)\n    ]);\n  });","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"compiles charset of non CID font","suites":["CFFCompiler"],"line":415,"updatePoint":{"line":415,"column":38,"index":15200},"code":"  it(\"compiles charset of non CID font\", function () {\n    const charset = new CFFCharset(false, 0, [\"space\", \"exclam\"]);\n    const c = new CFFCompiler();\n    const numGlyphs = 3;\n    const out = c.compileCharset(charset, numGlyphs, new CFFStrings(), false); // All non-CID fonts use a format 0 charset.\n\n    expect(out).toEqual([0, // format\n    0, // sid of 'space' (high)\n    1, // sid of 'space' (low)\n    0, // sid of 'exclam' (high)\n    2 // sid of 'exclam' (low)\n    ]);\n  }); // TODO a lot more compiler tests","file":"unit/cff_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses beginbfchar","suites":["cmap"],"line":38,"updatePoint":{"line":38,"column":24,"index":1385},"code":"  it(\"parses beginbfchar\", async function () {\n    // prettier-ignore\n    const str = \"2 beginbfchar\\n\" + \"<03> <00>\\n\" + \"<04> <01>\\n\" + \"endbfchar\\n\";\n    const stream = new StringStream(str);\n    const cmap = await CMapFactory.create({\n      encoding: stream\n    });\n    expect(cmap.lookup(0x03)).toEqual(String.fromCharCode(0x00));\n    expect(cmap.lookup(0x04)).toEqual(String.fromCharCode(0x01));\n    expect(cmap.lookup(0x05)).toBeUndefined();\n  });","file":"unit/cmap_spec.js","skipped":false,"dir":"test"},{"name":"parses beginbfrange with range","suites":["cmap"],"line":49,"updatePoint":{"line":49,"column":36,"index":1852},"code":"  it(\"parses beginbfrange with range\", async function () {\n    // prettier-ignore\n    const str = \"1 beginbfrange\\n\" + \"<06> <0B> 0\\n\" + \"endbfrange\\n\";\n    const stream = new StringStream(str);\n    const cmap = await CMapFactory.create({\n      encoding: stream\n    });\n    expect(cmap.lookup(0x05)).toBeUndefined();\n    expect(cmap.lookup(0x06)).toEqual(String.fromCharCode(0x00));\n    expect(cmap.lookup(0x0b)).toEqual(String.fromCharCode(0x05));\n    expect(cmap.lookup(0x0c)).toBeUndefined();\n  });","file":"unit/cmap_spec.js","skipped":false,"dir":"test"},{"name":"parses beginbfrange with array","suites":["cmap"],"line":61,"updatePoint":{"line":61,"column":36,"index":2354},"code":"  it(\"parses beginbfrange with array\", async function () {\n    // prettier-ignore\n    const str = \"1 beginbfrange\\n\" + \"<0D> <12> [ 0 1 2 3 4 5 ]\\n\" + \"endbfrange\\n\";\n    const stream = new StringStream(str);\n    const cmap = await CMapFactory.create({\n      encoding: stream\n    });\n    expect(cmap.lookup(0x0c)).toBeUndefined();\n    expect(cmap.lookup(0x0d)).toEqual(0x00);\n    expect(cmap.lookup(0x12)).toEqual(0x05);\n    expect(cmap.lookup(0x13)).toBeUndefined();\n  });","file":"unit/cmap_spec.js","skipped":false,"dir":"test"},{"name":"parses begincidchar","suites":["cmap"],"line":73,"updatePoint":{"line":73,"column":25,"index":2817},"code":"  it(\"parses begincidchar\", async function () {\n    // prettier-ignore\n    const str = \"1 begincidchar\\n\" + \"<14> 0\\n\" + \"endcidchar\\n\";\n    const stream = new StringStream(str);\n    const cmap = await CMapFactory.create({\n      encoding: stream\n    });\n    expect(cmap.lookup(0x14)).toEqual(0x00);\n    expect(cmap.lookup(0x15)).toBeUndefined();\n  });","file":"unit/cmap_spec.js","skipped":false,"dir":"test"},{"name":"parses begincidrange","suites":["cmap"],"line":83,"updatePoint":{"line":83,"column":26,"index":3170},"code":"  it(\"parses begincidrange\", async function () {\n    // prettier-ignore\n    const str = \"1 begincidrange\\n\" + \"<0016> <001B>   0\\n\" + \"endcidrange\\n\";\n    const stream = new StringStream(str);\n    const cmap = await CMapFactory.create({\n      encoding: stream\n    });\n    expect(cmap.lookup(0x15)).toBeUndefined();\n    expect(cmap.lookup(0x16)).toEqual(0x00);\n    expect(cmap.lookup(0x1b)).toEqual(0x05);\n    expect(cmap.lookup(0x1c)).toBeUndefined();\n  });","file":"unit/cmap_spec.js","skipped":false,"dir":"test"},{"name":"decodes codespace ranges","suites":["cmap"],"line":95,"updatePoint":{"line":95,"column":30,"index":3632},"code":"  it(\"decodes codespace ranges\", async function () {\n    // prettier-ignore\n    const str = \"1 begincodespacerange\\n\" + \"<01> <02>\\n\" + \"<00000003> <00000004>\\n\" + \"endcodespacerange\\n\";\n    const stream = new StringStream(str);\n    const cmap = await CMapFactory.create({\n      encoding: stream\n    });\n    const c = {};\n    cmap.readCharCode(String.fromCharCode(1), 0, c);\n    expect(c.charcode).toEqual(1);\n    expect(c.length).toEqual(1);\n    cmap.readCharCode(String.fromCharCode(0, 0, 0, 3), 0, c);\n    expect(c.charcode).toEqual(3);\n    expect(c.length).toEqual(4);\n  });","file":"unit/cmap_spec.js","skipped":false,"dir":"test"},{"name":"decodes 4 byte codespace ranges","suites":["cmap"],"line":110,"updatePoint":{"line":110,"column":37,"index":4218},"code":"  it(\"decodes 4 byte codespace ranges\", async function () {\n    // prettier-ignore\n    const str = \"1 begincodespacerange\\n\" + \"<8EA1A1A1> <8EA1FEFE>\\n\" + \"endcodespacerange\\n\";\n    const stream = new StringStream(str);\n    const cmap = await CMapFactory.create({\n      encoding: stream\n    });\n    const c = {};\n    cmap.readCharCode(String.fromCharCode(0x8e, 0xa1, 0xa1, 0xa1), 0, c);\n    expect(c.charcode).toEqual(0x8ea1a1a1);\n    expect(c.length).toEqual(4);\n  });","file":"unit/cmap_spec.js","skipped":false,"dir":"test"},{"name":"read usecmap","suites":["cmap"],"line":122,"updatePoint":{"line":122,"column":18,"index":4669},"code":"  it(\"read usecmap\", async function () {\n    const str = \"/Adobe-Japan1-1 usecmap\\n\";\n    const stream = new StringStream(str);\n    const cmap = await CMapFactory.create({\n      encoding: stream,\n      fetchBuiltInCMap,\n      useCMap: null\n    });\n    expect(cmap instanceof CMap).toEqual(true);\n    expect(cmap.useCMap).not.toBeNull();\n    expect(cmap.builtInCMap).toBeFalsy();\n    expect(cmap.length).toEqual(0x20a7);\n    expect(cmap.isIdentityCMap).toEqual(false);\n  });","file":"unit/cmap_spec.js","skipped":false,"dir":"test"},{"name":"parses cmapname","suites":["cmap"],"line":136,"updatePoint":{"line":136,"column":21,"index":5146},"code":"  it(\"parses cmapname\", async function () {\n    const str = \"/CMapName /Identity-H def\\n\";\n    const stream = new StringStream(str);\n    const cmap = await CMapFactory.create({\n      encoding: stream\n    });\n    expect(cmap.name).toEqual(\"Identity-H\");\n  });","file":"unit/cmap_spec.js","skipped":false,"dir":"test"},{"name":"parses wmode","suites":["cmap"],"line":144,"updatePoint":{"line":144,"column":18,"index":5402},"code":"  it(\"parses wmode\", async function () {\n    const str = \"/WMode 1 def\\n\";\n    const stream = new StringStream(str);\n    const cmap = await CMapFactory.create({\n      encoding: stream\n    });\n    expect(cmap.vertical).toEqual(true);\n  });","file":"unit/cmap_spec.js","skipped":false,"dir":"test"},{"name":"loads built in cmap","suites":["cmap"],"line":152,"updatePoint":{"line":152,"column":25,"index":5648},"code":"  it(\"loads built in cmap\", async function () {\n    const cmap = await CMapFactory.create({\n      encoding: Name.get(\"Adobe-Japan1-1\"),\n      fetchBuiltInCMap,\n      useCMap: null\n    });\n    expect(cmap instanceof CMap).toEqual(true);\n    expect(cmap.useCMap).toBeNull();\n    expect(cmap.builtInCMap).toBeTruthy();\n    expect(cmap.length).toEqual(0x20a7);\n    expect(cmap.isIdentityCMap).toEqual(false);\n  });","file":"unit/cmap_spec.js","skipped":false,"dir":"test"},{"name":"loads built in identity cmap","suites":["cmap"],"line":164,"updatePoint":{"line":164,"column":34,"index":6068},"code":"  it(\"loads built in identity cmap\", async function () {\n    const cmap = await CMapFactory.create({\n      encoding: Name.get(\"Identity-H\"),\n      fetchBuiltInCMap,\n      useCMap: null\n    });\n    expect(cmap instanceof IdentityCMap).toEqual(true);\n    expect(cmap.vertical).toEqual(false);\n    expect(cmap.length).toEqual(0x10000);\n    expect(function () {\n      return cmap.isIdentityCMap;\n    }).toThrow(new Error(\"should not access .isIdentityCMap\"));\n  });","file":"unit/cmap_spec.js","skipped":false,"dir":"test"},{"name":"attempts to load a non-existent built-in CMap","suites":["cmap"],"line":177,"updatePoint":{"line":177,"column":51,"index":6547},"code":"  it(\"attempts to load a non-existent built-in CMap\", async function () {\n    try {\n      await CMapFactory.create({\n        encoding: Name.get(\"null\"),\n        fetchBuiltInCMap,\n        useCMap: null\n      }); // Shouldn't get here.\n\n      expect(false).toEqual(true);\n    } catch (reason) {\n      expect(reason instanceof Error).toEqual(true);\n      expect(reason.message).toEqual(\"Unknown CMap name: null\");\n    }\n  });","file":"unit/cmap_spec.js","skipped":false,"dir":"test"},{"name":"attempts to load a built-in CMap without the necessary API parameters","suites":["cmap"],"line":191,"updatePoint":{"line":191,"column":75,"index":6994},"code":"  it(\"attempts to load a built-in CMap without the necessary API parameters\", async function () {\n    function tmpFetchBuiltInCMap(name) {\n      const CMapReaderFactory = new DefaultCMapReaderFactory({});\n      return CMapReaderFactory.fetch({\n        name\n      });\n    }\n\n    try {\n      await CMapFactory.create({\n        encoding: Name.get(\"Adobe-Japan1-1\"),\n        fetchBuiltInCMap: tmpFetchBuiltInCMap,\n        useCMap: null\n      }); // Shouldn't get here.\n\n      expect(false).toEqual(true);\n    } catch (reason) {\n      expect(reason instanceof Error).toEqual(true);\n      expect(reason.message).toEqual('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.');\n    }\n  });","file":"unit/cmap_spec.js","skipped":false,"dir":"test"},{"name":"attempts to load a built-in CMap with inconsistent API parameters","suites":["cmap"],"line":212,"updatePoint":{"line":212,"column":71,"index":7745},"code":"  it(\"attempts to load a built-in CMap with inconsistent API parameters\", async function () {\n    function tmpFetchBuiltInCMap(name) {\n      const CMapReaderFactory = new DefaultCMapReaderFactory({\n        baseUrl: CMAP_PARAMS.cMapUrl,\n        isCompressed: false\n      });\n      return CMapReaderFactory.fetch({\n        name\n      });\n    }\n\n    try {\n      await CMapFactory.create({\n        encoding: Name.get(\"Adobe-Japan1-1\"),\n        fetchBuiltInCMap: tmpFetchBuiltInCMap,\n        useCMap: null\n      }); // Shouldn't get here.\n\n      expect(false).toEqual(true);\n    } catch (reason) {\n      expect(reason instanceof Error).toEqual(true);\n      const message = reason.message;\n      expect(message.startsWith(\"Unable to load CMap at: \")).toEqual(true);\n      expect(message.endsWith(\"/external/bcmaps/Adobe-Japan1-1\")).toEqual(true);\n    }\n  });","file":"unit/cmap_spec.js","skipped":false,"dir":"test"},{"name":"should be true if decode is not an array","suites":["colorspace","ColorSpace.isDefaultDecode"],"line":23,"updatePoint":{"line":23,"column":48,"index":1107},"code":"    it(\"should be true if decode is not an array\", function () {\n      expect(ColorSpace.isDefaultDecode(\"string\", 0)).toBeTruthy();\n    });","file":"unit/colorspace_spec.js","skipped":false,"dir":"test"},{"name":"should be true if length of decode array is not correct","suites":["colorspace","ColorSpace.isDefaultDecode"],"line":26,"updatePoint":{"line":26,"column":63,"index":1263},"code":"    it(\"should be true if length of decode array is not correct\", function () {\n      expect(ColorSpace.isDefaultDecode([0], 1)).toBeTruthy();\n      expect(ColorSpace.isDefaultDecode([0, 1, 0], 1)).toBeTruthy();\n    });","file":"unit/colorspace_spec.js","skipped":false,"dir":"test"},{"name":"should be true if decode map matches the default decode map","suites":["colorspace","ColorSpace.isDefaultDecode"],"line":30,"updatePoint":{"line":30,"column":67,"index":1487},"code":"    it(\"should be true if decode map matches the default decode map\", function () {\n      expect(ColorSpace.isDefaultDecode([], 0)).toBeTruthy();\n      expect(ColorSpace.isDefaultDecode([0, 0], 1)).toBeFalsy();\n      expect(ColorSpace.isDefaultDecode([0, 1], 1)).toBeTruthy();\n      expect(ColorSpace.isDefaultDecode([0, 1, 0, 1, 0, 1], 3)).toBeTruthy();\n      expect(ColorSpace.isDefaultDecode([0, 1, 0, 1, 1, 1], 3)).toBeFalsy();\n      expect(ColorSpace.isDefaultDecode([0, 1, 0, 1, 0, 1, 0, 1], 4)).toBeTruthy();\n      expect(ColorSpace.isDefaultDecode([1, 0, 0, 1, 0, 1, 0, 1], 4)).toBeFalsy();\n    });","file":"unit/colorspace_spec.js","skipped":false,"dir":"test"},{"name":"caching by Name","suites":["colorspace","ColorSpace caching"],"line":48,"updatePoint":{"line":48,"column":23,"index":2303},"code":"    it(\"caching by Name\", function () {\n      const xref = new XRefMock();\n      const pdfFunctionFactory = new PDFFunctionFactory({\n        xref\n      });\n      const colorSpace1 = ColorSpace.parse({\n        cs: Name.get(\"Pattern\"),\n        xref,\n        resources: null,\n        pdfFunctionFactory,\n        localColorSpaceCache\n      });\n      expect(colorSpace1.name).toEqual(\"Pattern\");\n      const colorSpace2 = ColorSpace.parse({\n        cs: Name.get(\"Pattern\"),\n        xref,\n        resources: null,\n        pdfFunctionFactory,\n        localColorSpaceCache\n      });\n      expect(colorSpace2.name).toEqual(\"Pattern\");\n      const colorSpaceNonCached = ColorSpace.parse({\n        cs: Name.get(\"Pattern\"),\n        xref,\n        resources: null,\n        pdfFunctionFactory,\n        localColorSpaceCache: new LocalColorSpaceCache()\n      });\n      expect(colorSpaceNonCached.name).toEqual(\"Pattern\");\n      const colorSpaceOther = ColorSpace.parse({\n        cs: Name.get(\"RGB\"),\n        xref,\n        resources: null,\n        pdfFunctionFactory,\n        localColorSpaceCache\n      });\n      expect(colorSpaceOther.name).toEqual(\"DeviceRGB\"); // These two must be *identical* if caching worked as intended.\n\n      expect(colorSpace1).toBe(colorSpace2);\n      expect(colorSpace1).not.toBe(colorSpaceNonCached);\n      expect(colorSpace1).not.toBe(colorSpaceOther);\n    });","file":"unit/colorspace_spec.js","skipped":false,"dir":"test"},{"name":"caching by Ref","suites":["colorspace","ColorSpace caching"],"line":90,"updatePoint":{"line":90,"column":22,"index":3676},"code":"    it(\"caching by Ref\", function () {\n      const paramsCalGray = new Dict();\n      paramsCalGray.set(\"WhitePoint\", [1, 1, 1]);\n      paramsCalGray.set(\"BlackPoint\", [0, 0, 0]);\n      paramsCalGray.set(\"Gamma\", 2.0);\n      const paramsCalRGB = new Dict();\n      paramsCalRGB.set(\"WhitePoint\", [1, 1, 1]);\n      paramsCalRGB.set(\"BlackPoint\", [0, 0, 0]);\n      paramsCalRGB.set(\"Gamma\", [1, 1, 1]);\n      paramsCalRGB.set(\"Matrix\", [1, 0, 0, 0, 1, 0, 0, 0, 1]);\n      const xref = new XRefMock([{\n        ref: Ref.get(50, 0),\n        data: [Name.get(\"CalGray\"), paramsCalGray]\n      }, {\n        ref: Ref.get(100, 0),\n        data: [Name.get(\"CalRGB\"), paramsCalRGB]\n      }]);\n      const pdfFunctionFactory = new PDFFunctionFactory({\n        xref\n      });\n      const colorSpace1 = ColorSpace.parse({\n        cs: Ref.get(50, 0),\n        xref,\n        resources: null,\n        pdfFunctionFactory,\n        localColorSpaceCache\n      });\n      expect(colorSpace1.name).toEqual(\"CalGray\");\n      const colorSpace2 = ColorSpace.parse({\n        cs: Ref.get(50, 0),\n        xref,\n        resources: null,\n        pdfFunctionFactory,\n        localColorSpaceCache\n      });\n      expect(colorSpace2.name).toEqual(\"CalGray\");\n      const colorSpaceNonCached = ColorSpace.parse({\n        cs: Ref.get(50, 0),\n        xref,\n        resources: null,\n        pdfFunctionFactory,\n        localColorSpaceCache: new LocalColorSpaceCache()\n      });\n      expect(colorSpaceNonCached.name).toEqual(\"CalGray\");\n      const colorSpaceOther = ColorSpace.parse({\n        cs: Ref.get(100, 0),\n        xref,\n        resources: null,\n        pdfFunctionFactory,\n        localColorSpaceCache\n      });\n      expect(colorSpaceOther.name).toEqual(\"CalRGB\"); // These two must be *identical* if caching worked as intended.\n\n      expect(colorSpace1).toBe(colorSpace2);\n      expect(colorSpace1).not.toBe(colorSpaceNonCached);\n      expect(colorSpace1).not.toBe(colorSpaceOther);\n    });","file":"unit/colorspace_spec.js","skipped":false,"dir":"test"},{"name":"should handle the case when cs is a Name object","suites":["colorspace","DeviceGrayCS"],"line":149,"updatePoint":{"line":149,"column":55,"index":5715},"code":"    it(\"should handle the case when cs is a Name object\", function () {\n      const cs = Name.get(\"DeviceGray\");\n      const xref = new XRefMock([{\n        ref: Ref.get(10, 0),\n        data: new Dict()\n      }]);\n      const resources = new Dict();\n      const pdfFunctionFactory = new PDFFunctionFactory({\n        xref\n      });\n      const colorSpace = ColorSpace.parse({\n        cs,\n        xref,\n        resources,\n        pdfFunctionFactory,\n        localColorSpaceCache: new LocalColorSpaceCache()\n      });\n      const testSrc = new Uint8Array([27, 125, 250, 131]);\n      const testDest = new Uint8ClampedArray(4 * 4 * 3); // prettier-ignore\n\n      const expectedDest = new Uint8ClampedArray([27, 27, 27, 27, 27, 27, 125, 125, 125, 125, 125, 125, 27, 27, 27, 27, 27, 27, 125, 125, 125, 125, 125, 125, 250, 250, 250, 250, 250, 250, 131, 131, 131, 131, 131, 131, 250, 250, 250, 250, 250, 250, 131, 131, 131, 131, 131, 131]);\n      colorSpace.fillRgb(testDest, 2, 2, 4, 4, 4, 8, testSrc, 0);\n      expect(colorSpace.getRgb(new Float32Array([0.1]), 0)).toEqual(new Uint8ClampedArray([26, 26, 26]));\n      expect(colorSpace.getOutputLength(2, 0)).toEqual(6);\n      expect(colorSpace.isPassthrough(8)).toBeFalsy();\n      expect(testDest).toEqual(expectedDest);\n    });","file":"unit/colorspace_spec.js","skipped":false,"dir":"test"},{"name":"should handle the case when cs is an indirect object","suites":["colorspace","DeviceGrayCS"],"line":176,"updatePoint":{"line":176,"column":60,"index":6990},"code":"    it(\"should handle the case when cs is an indirect object\", function () {\n      const cs = Ref.get(10, 0);\n      const xref = new XRefMock([{\n        ref: cs,\n        data: Name.get(\"DeviceGray\")\n      }]);\n      const resources = new Dict();\n      const pdfFunctionFactory = new PDFFunctionFactory({\n        xref\n      });\n      const colorSpace = ColorSpace.parse({\n        cs,\n        xref,\n        resources,\n        pdfFunctionFactory,\n        localColorSpaceCache: new LocalColorSpaceCache()\n      });\n      const testSrc = new Uint8Array([27, 125, 250, 131]);\n      const testDest = new Uint8ClampedArray(3 * 3 * 3); // prettier-ignore\n\n      const expectedDest = new Uint8ClampedArray([27, 27, 27, 27, 27, 27, 125, 125, 125, 27, 27, 27, 27, 27, 27, 125, 125, 125, 250, 250, 250, 250, 250, 250, 131, 131, 131]);\n      colorSpace.fillRgb(testDest, 2, 2, 3, 3, 3, 8, testSrc, 0);\n      expect(colorSpace.getRgb(new Float32Array([0.2]), 0)).toEqual(new Uint8ClampedArray([51, 51, 51]));\n      expect(colorSpace.getOutputLength(3, 1)).toEqual(12);\n      expect(colorSpace.isPassthrough(8)).toBeFalsy();\n      expect(testDest).toEqual(expectedDest);\n    });","file":"unit/colorspace_spec.js","skipped":false,"dir":"test"},{"name":"should handle the case when cs is a Name object","suites":["colorspace","DeviceRgbCS"],"line":205,"updatePoint":{"line":205,"column":55,"index":8194},"code":"    it(\"should handle the case when cs is a Name object\", function () {\n      const cs = Name.get(\"DeviceRGB\");\n      const xref = new XRefMock([{\n        ref: Ref.get(10, 0),\n        data: new Dict()\n      }]);\n      const resources = new Dict();\n      const pdfFunctionFactory = new PDFFunctionFactory({\n        xref\n      });\n      const colorSpace = ColorSpace.parse({\n        cs,\n        xref,\n        resources,\n        pdfFunctionFactory,\n        localColorSpaceCache: new LocalColorSpaceCache()\n      }); // prettier-ignore\n\n      const testSrc = new Uint8Array([27, 125, 250, 131, 139, 140, 111, 25, 198, 21, 147, 255]);\n      const testDest = new Uint8ClampedArray(4 * 4 * 3); // prettier-ignore\n\n      const expectedDest = new Uint8ClampedArray([27, 125, 250, 27, 125, 250, 131, 139, 140, 131, 139, 140, 27, 125, 250, 27, 125, 250, 131, 139, 140, 131, 139, 140, 111, 25, 198, 111, 25, 198, 21, 147, 255, 21, 147, 255, 111, 25, 198, 111, 25, 198, 21, 147, 255, 21, 147, 255]);\n      colorSpace.fillRgb(testDest, 2, 2, 4, 4, 4, 8, testSrc, 0);\n      expect(colorSpace.getRgb(new Float32Array([0.1, 0.2, 0.3]), 0)).toEqual(new Uint8ClampedArray([26, 51, 77]));\n      expect(colorSpace.getOutputLength(4, 0)).toEqual(4);\n      expect(colorSpace.isPassthrough(8)).toBeTruthy();\n      expect(testDest).toEqual(expectedDest);\n    });","file":"unit/colorspace_spec.js","skipped":false,"dir":"test"},{"name":"should handle the case when cs is an indirect object","suites":["colorspace","DeviceRgbCS"],"line":233,"updatePoint":{"line":233,"column":60,"index":9537},"code":"    it(\"should handle the case when cs is an indirect object\", function () {\n      const cs = Ref.get(10, 0);\n      const xref = new XRefMock([{\n        ref: cs,\n        data: Name.get(\"DeviceRGB\")\n      }]);\n      const resources = new Dict();\n      const pdfFunctionFactory = new PDFFunctionFactory({\n        xref\n      });\n      const colorSpace = ColorSpace.parse({\n        cs,\n        xref,\n        resources,\n        pdfFunctionFactory,\n        localColorSpaceCache: new LocalColorSpaceCache()\n      }); // prettier-ignore\n\n      const testSrc = new Uint8Array([27, 125, 250, 131, 139, 140, 111, 25, 198, 21, 147, 255]);\n      const testDest = new Uint8ClampedArray(3 * 3 * 3); // prettier-ignore\n\n      const expectedDest = new Uint8ClampedArray([27, 125, 250, 27, 125, 250, 131, 139, 140, 27, 125, 250, 27, 125, 250, 131, 139, 140, 111, 25, 198, 111, 25, 198, 21, 147, 255]);\n      colorSpace.fillRgb(testDest, 2, 2, 3, 3, 3, 8, testSrc, 0);\n      expect(colorSpace.getRgb(new Float32Array([0.1, 0.2, 0.3]), 0)).toEqual(new Uint8ClampedArray([26, 51, 77]));\n      expect(colorSpace.getOutputLength(4, 1)).toEqual(5);\n      expect(colorSpace.isPassthrough(8)).toBeTruthy();\n      expect(testDest).toEqual(expectedDest);\n    });","file":"unit/colorspace_spec.js","skipped":false,"dir":"test"},{"name":"should handle the case when cs is a Name object","suites":["colorspace","DeviceCmykCS"],"line":263,"updatePoint":{"line":263,"column":55,"index":10814},"code":"    it(\"should handle the case when cs is a Name object\", function () {\n      const cs = Name.get(\"DeviceCMYK\");\n      const xref = new XRefMock([{\n        ref: Ref.get(10, 0),\n        data: new Dict()\n      }]);\n      const resources = new Dict();\n      const pdfFunctionFactory = new PDFFunctionFactory({\n        xref\n      });\n      const colorSpace = ColorSpace.parse({\n        cs,\n        xref,\n        resources,\n        pdfFunctionFactory,\n        localColorSpaceCache: new LocalColorSpaceCache()\n      }); // prettier-ignore\n\n      const testSrc = new Uint8Array([27, 125, 250, 128, 131, 139, 140, 45, 111, 25, 198, 78, 21, 147, 255, 69]);\n      const testDest = new Uint8ClampedArray(4 * 4 * 3); // prettier-ignore\n\n      const expectedDest = new Uint8ClampedArray([135, 81, 18, 135, 81, 18, 114, 102, 97, 114, 102, 97, 135, 81, 18, 135, 81, 18, 114, 102, 97, 114, 102, 97, 112, 144, 75, 112, 144, 75, 188, 98, 27, 188, 98, 27, 112, 144, 75, 112, 144, 75, 188, 98, 27, 188, 98, 27]);\n      colorSpace.fillRgb(testDest, 2, 2, 4, 4, 4, 8, testSrc, 0);\n      expect(colorSpace.getRgb(new Float32Array([0.1, 0.2, 0.3, 1]), 0)).toEqual(new Uint8ClampedArray([32, 28, 21]));\n      expect(colorSpace.getOutputLength(4, 0)).toEqual(3);\n      expect(colorSpace.isPassthrough(8)).toBeFalsy();\n      expect(testDest).toEqual(expectedDest);\n    });","file":"unit/colorspace_spec.js","skipped":false,"dir":"test"},{"name":"should handle the case when cs is an indirect object","suites":["colorspace","DeviceCmykCS"],"line":291,"updatePoint":{"line":291,"column":60,"index":12165},"code":"    it(\"should handle the case when cs is an indirect object\", function () {\n      const cs = Ref.get(10, 0);\n      const xref = new XRefMock([{\n        ref: cs,\n        data: Name.get(\"DeviceCMYK\")\n      }]);\n      const resources = new Dict();\n      const pdfFunctionFactory = new PDFFunctionFactory({\n        xref\n      });\n      const colorSpace = ColorSpace.parse({\n        cs,\n        xref,\n        resources,\n        pdfFunctionFactory,\n        localColorSpaceCache: new LocalColorSpaceCache()\n      }); // prettier-ignore\n\n      const testSrc = new Uint8Array([27, 125, 250, 128, 131, 139, 140, 45, 111, 25, 198, 78, 21, 147, 255, 69]);\n      const testDest = new Uint8ClampedArray(3 * 3 * 3); // prettier-ignore\n\n      const expectedDest = new Uint8ClampedArray([135, 81, 18, 135, 81, 18, 114, 102, 97, 135, 81, 18, 135, 81, 18, 114, 102, 97, 112, 144, 75, 112, 144, 75, 188, 98, 27]);\n      colorSpace.fillRgb(testDest, 2, 2, 3, 3, 3, 8, testSrc, 0);\n      expect(colorSpace.getRgb(new Float32Array([0.1, 0.2, 0.3, 1]), 0)).toEqual(new Uint8ClampedArray([32, 28, 21]));\n      expect(colorSpace.getOutputLength(4, 1)).toEqual(4);\n      expect(colorSpace.isPassthrough(8)).toBeFalsy();\n      expect(testDest).toEqual(expectedDest);\n    });","file":"unit/colorspace_spec.js","skipped":false,"dir":"test"},{"name":"should handle the case when cs is an array","suites":["colorspace","CalGrayCS"],"line":321,"updatePoint":{"line":321,"column":50,"index":13447},"code":"    it(\"should handle the case when cs is an array\", function () {\n      const params = new Dict();\n      params.set(\"WhitePoint\", [1, 1, 1]);\n      params.set(\"BlackPoint\", [0, 0, 0]);\n      params.set(\"Gamma\", 2.0);\n      const cs = [Name.get(\"CalGray\"), params];\n      const xref = new XRefMock([{\n        ref: Ref.get(10, 0),\n        data: new Dict()\n      }]);\n      const resources = new Dict();\n      const pdfFunctionFactory = new PDFFunctionFactory({\n        xref\n      });\n      const colorSpace = ColorSpace.parse({\n        cs,\n        xref,\n        resources,\n        pdfFunctionFactory,\n        localColorSpaceCache: new LocalColorSpaceCache()\n      });\n      const testSrc = new Uint8Array([27, 125, 250, 131]);\n      const testDest = new Uint8ClampedArray(4 * 4 * 3); // prettier-ignore\n\n      const expectedDest = new Uint8ClampedArray([25, 25, 25, 25, 25, 25, 143, 143, 143, 143, 143, 143, 25, 25, 25, 25, 25, 25, 143, 143, 143, 143, 143, 143, 251, 251, 251, 251, 251, 251, 149, 149, 149, 149, 149, 149, 251, 251, 251, 251, 251, 251, 149, 149, 149, 149, 149, 149]);\n      colorSpace.fillRgb(testDest, 2, 2, 4, 4, 4, 8, testSrc, 0);\n      expect(colorSpace.getRgb(new Float32Array([1.0]), 0)).toEqual(new Uint8ClampedArray([255, 255, 255]));\n      expect(colorSpace.getOutputLength(4, 0)).toEqual(12);\n      expect(colorSpace.isPassthrough(8)).toBeFalsy();\n      expect(testDest).toEqual(expectedDest);\n    });","file":"unit/colorspace_spec.js","skipped":false,"dir":"test"},{"name":"should handle the case when cs is an array","suites":["colorspace","CalRGBCS"],"line":354,"updatePoint":{"line":354,"column":50,"index":14917},"code":"    it(\"should handle the case when cs is an array\", function () {\n      const params = new Dict();\n      params.set(\"WhitePoint\", [1, 1, 1]);\n      params.set(\"BlackPoint\", [0, 0, 0]);\n      params.set(\"Gamma\", [1, 1, 1]);\n      params.set(\"Matrix\", [1, 0, 0, 0, 1, 0, 0, 0, 1]);\n      const cs = [Name.get(\"CalRGB\"), params];\n      const xref = new XRefMock([{\n        ref: Ref.get(10, 0),\n        data: new Dict()\n      }]);\n      const resources = new Dict();\n      const pdfFunctionFactory = new PDFFunctionFactory({\n        xref\n      });\n      const colorSpace = ColorSpace.parse({\n        cs,\n        xref,\n        resources,\n        pdfFunctionFactory,\n        localColorSpaceCache: new LocalColorSpaceCache()\n      }); // prettier-ignore\n\n      const testSrc = new Uint8Array([27, 125, 250, 131, 139, 140, 111, 25, 198, 21, 147, 255]);\n      const testDest = new Uint8ClampedArray(3 * 3 * 3); // prettier-ignore\n\n      const expectedDest = new Uint8ClampedArray([0, 238, 255, 0, 238, 255, 185, 196, 195, 0, 238, 255, 0, 238, 255, 185, 196, 195, 235, 0, 243, 235, 0, 243, 0, 255, 255]);\n      colorSpace.fillRgb(testDest, 2, 2, 3, 3, 3, 8, testSrc, 0);\n      expect(colorSpace.getRgb(new Float32Array([0.1, 0.2, 0.3]), 0)).toEqual(new Uint8ClampedArray([0, 147, 151]));\n      expect(colorSpace.getOutputLength(4, 0)).toEqual(4);\n      expect(colorSpace.isPassthrough(8)).toBeFalsy();\n      expect(testDest).toEqual(expectedDest);\n    });","file":"unit/colorspace_spec.js","skipped":false,"dir":"test"},{"name":"should handle the case when cs is an array","suites":["colorspace","LabCS"],"line":389,"updatePoint":{"line":389,"column":50,"index":16404},"code":"    it(\"should handle the case when cs is an array\", function () {\n      const params = new Dict();\n      params.set(\"WhitePoint\", [1, 1, 1]);\n      params.set(\"BlackPoint\", [0, 0, 0]);\n      params.set(\"Range\", [-100, 100, -100, 100]);\n      const cs = [Name.get(\"Lab\"), params];\n      const xref = new XRefMock([{\n        ref: Ref.get(10, 0),\n        data: new Dict()\n      }]);\n      const resources = new Dict();\n      const pdfFunctionFactory = new PDFFunctionFactory({\n        xref\n      });\n      const colorSpace = ColorSpace.parse({\n        cs,\n        xref,\n        resources,\n        pdfFunctionFactory,\n        localColorSpaceCache: new LocalColorSpaceCache()\n      }); // prettier-ignore\n\n      const testSrc = new Uint8Array([27, 25, 50, 31, 19, 40, 11, 25, 98, 21, 47, 55]);\n      const testDest = new Uint8ClampedArray(3 * 3 * 3); // prettier-ignore\n\n      const expectedDest = new Uint8ClampedArray([0, 49, 101, 0, 49, 101, 0, 53, 117, 0, 49, 101, 0, 49, 101, 0, 53, 117, 0, 41, 40, 0, 41, 40, 0, 43, 90]);\n      colorSpace.fillRgb(testDest, 2, 2, 3, 3, 3, 8, testSrc, 0);\n      expect(colorSpace.getRgb([55, 25, 35], 0)).toEqual(new Uint8ClampedArray([188, 100, 61]));\n      expect(colorSpace.getOutputLength(4, 0)).toEqual(4);\n      expect(colorSpace.isPassthrough(8)).toBeFalsy();\n      expect(colorSpace.isDefaultDecode([0, 1])).toBeTruthy();\n      expect(testDest).toEqual(expectedDest);\n    });","file":"unit/colorspace_spec.js","skipped":false,"dir":"test"},{"name":"should handle the case when cs is an array","suites":["colorspace","IndexedCS"],"line":424,"updatePoint":{"line":424,"column":50,"index":17866},"code":"    it(\"should handle the case when cs is an array\", function () {\n      // prettier-ignore\n      const lookup = new Stream(new Uint8Array([23, 155, 35, 147, 69, 93, 255, 109, 70]));\n      const cs = [Name.get(\"Indexed\"), Name.get(\"DeviceRGB\"), 2, lookup];\n      const xref = new XRefMock([{\n        ref: Ref.get(10, 0),\n        data: new Dict()\n      }]);\n      const resources = new Dict();\n      const pdfFunctionFactory = new PDFFunctionFactory({\n        xref\n      });\n      const colorSpace = ColorSpace.parse({\n        cs,\n        xref,\n        resources,\n        pdfFunctionFactory,\n        localColorSpaceCache: new LocalColorSpaceCache()\n      });\n      const testSrc = new Uint8Array([2, 2, 0, 1]);\n      const testDest = new Uint8ClampedArray(3 * 3 * 3); // prettier-ignore\n\n      const expectedDest = new Uint8ClampedArray([255, 109, 70, 255, 109, 70, 255, 109, 70, 255, 109, 70, 255, 109, 70, 255, 109, 70, 23, 155, 35, 23, 155, 35, 147, 69, 93]);\n      colorSpace.fillRgb(testDest, 2, 2, 3, 3, 3, 8, testSrc, 0);\n      expect(colorSpace.getRgb([2], 0)).toEqual(new Uint8ClampedArray([255, 109, 70]));\n      expect(colorSpace.isPassthrough(8)).toBeFalsy();\n      expect(colorSpace.isDefaultDecode([0, 1], 1)).toBeTruthy();\n      expect(testDest).toEqual(expectedDest);\n    });","file":"unit/colorspace_spec.js","skipped":false,"dir":"test"},{"name":"should handle the case when cs is an array","suites":["colorspace","AlternateCS"],"line":455,"updatePoint":{"line":455,"column":50,"index":19203},"code":"    it(\"should handle the case when cs is an array\", function () {\n      const fnDict = new Dict();\n      fnDict.set(\"FunctionType\", 4);\n      fnDict.set(\"Domain\", [0.0, 1.0]);\n      fnDict.set(\"Range\", [0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0]);\n      fnDict.set(\"Length\", 58);\n      let fn = new StringStream(\"{ dup 0.84 mul \" + \"exch 0.00 exch \" + \"dup 0.44 mul \" + \"exch 0.21 mul }\");\n      fn = new Stream(fn.bytes, 0, 58, fnDict);\n      const fnRef = Ref.get(10, 0);\n      const cs = [Name.get(\"Separation\"), Name.get(\"LogoGreen\"), Name.get(\"DeviceCMYK\"), fnRef];\n      const xref = new XRefMock([{\n        ref: fnRef,\n        data: fn\n      }]);\n      const resources = new Dict();\n      const pdfFunctionFactory = new PDFFunctionFactory({\n        xref\n      });\n      const colorSpace = ColorSpace.parse({\n        cs,\n        xref,\n        resources,\n        pdfFunctionFactory,\n        localColorSpaceCache: new LocalColorSpaceCache()\n      });\n      const testSrc = new Uint8Array([27, 25, 50, 31]);\n      const testDest = new Uint8ClampedArray(3 * 3 * 3); // prettier-ignore\n\n      const expectedDest = new Uint8ClampedArray([226, 242, 241, 226, 242, 241, 229, 244, 242, 226, 242, 241, 226, 242, 241, 229, 244, 242, 203, 232, 229, 203, 232, 229, 222, 241, 238]);\n      colorSpace.fillRgb(testDest, 2, 2, 3, 3, 3, 8, testSrc, 0);\n      expect(colorSpace.getRgb([0.1], 0)).toEqual(new Uint8ClampedArray([228, 243, 242]));\n      expect(colorSpace.isPassthrough(8)).toBeFalsy();\n      expect(colorSpace.isDefaultDecode([0, 1])).toBeTruthy();\n      expect(testDest).toEqual(expectedDest);\n    });","file":"unit/colorspace_spec.js","skipped":false,"dir":"test"},{"name":"handles non-dictionary arguments","suites":["core_utils","getInheritableProperty"],"line":20,"updatePoint":{"line":20,"column":40,"index":1003},"code":"    it(\"handles non-dictionary arguments\", function () {\n      expect(getInheritableProperty({\n        dict: null,\n        key: \"foo\"\n      })).toEqual(undefined);\n      expect(getInheritableProperty({\n        dict: undefined,\n        key: \"foo\"\n      })).toEqual(undefined);\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles dictionaries that do not contain the property","suites":["core_utils","getInheritableProperty"],"line":30,"updatePoint":{"line":30,"column":61,"index":1308},"code":"    it(\"handles dictionaries that do not contain the property\", function () {\n      // Empty dictionary.\n      const emptyDict = new Dict();\n      expect(getInheritableProperty({\n        dict: emptyDict,\n        key: \"foo\"\n      })).toEqual(undefined); // Filled dictionary with a different property.\n\n      const filledDict = new Dict();\n      filledDict.set(\"bar\", \"baz\");\n      expect(getInheritableProperty({\n        dict: filledDict,\n        key: \"foo\"\n      })).toEqual(undefined);\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"fetches the property if it is not inherited","suites":["core_utils","getInheritableProperty"],"line":45,"updatePoint":{"line":45,"column":51,"index":1794},"code":"    it(\"fetches the property if it is not inherited\", function () {\n      const ref = Ref.get(10, 0);\n      const xref = new XRefMock([{\n        ref,\n        data: \"quux\"\n      }]);\n      const dict = new Dict(xref); // Regular values should be fetched.\n\n      dict.set(\"foo\", \"bar\");\n      expect(getInheritableProperty({\n        dict,\n        key: \"foo\"\n      })).toEqual(\"bar\"); // Array value should be fetched (with references resolved).\n\n      dict.set(\"baz\", [\"qux\", ref]);\n      expect(getInheritableProperty({\n        dict,\n        key: \"baz\",\n        getArray: true\n      })).toEqual([\"qux\", \"quux\"]);\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"fetches the property if it is inherited and present on one level","suites":["core_utils","getInheritableProperty"],"line":66,"updatePoint":{"line":66,"column":72,"index":2435},"code":"    it(\"fetches the property if it is inherited and present on one level\", function () {\n      const ref = Ref.get(10, 0);\n      const xref = new XRefMock([{\n        ref,\n        data: \"quux\"\n      }]);\n      const firstDict = new Dict(xref);\n      const secondDict = new Dict(xref);\n      firstDict.set(\"Parent\", secondDict); // Regular values should be fetched.\n\n      secondDict.set(\"foo\", \"bar\");\n      expect(getInheritableProperty({\n        dict: firstDict,\n        key: \"foo\"\n      })).toEqual(\"bar\"); // Array value should be fetched (with references resolved).\n\n      secondDict.set(\"baz\", [\"qux\", ref]);\n      expect(getInheritableProperty({\n        dict: firstDict,\n        key: \"baz\",\n        getArray: true\n      })).toEqual([\"qux\", \"quux\"]);\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"fetches the property if it is inherited and present on multiple levels","suites":["core_utils","getInheritableProperty"],"line":89,"updatePoint":{"line":89,"column":78,"index":3205},"code":"    it(\"fetches the property if it is inherited and present on multiple levels\", function () {\n      const ref = Ref.get(10, 0);\n      const xref = new XRefMock([{\n        ref,\n        data: \"quux\"\n      }]);\n      const firstDict = new Dict(xref);\n      const secondDict = new Dict(xref);\n      firstDict.set(\"Parent\", secondDict); // Regular values should be fetched.\n\n      firstDict.set(\"foo\", \"bar1\");\n      secondDict.set(\"foo\", \"bar2\");\n      expect(getInheritableProperty({\n        dict: firstDict,\n        key: \"foo\"\n      })).toEqual(\"bar1\");\n      expect(getInheritableProperty({\n        dict: firstDict,\n        key: \"foo\",\n        getArray: false,\n        stopWhenFound: false\n      })).toEqual([\"bar1\", \"bar2\"]); // Array value should be fetched (with references resolved).\n\n      firstDict.set(\"baz\", [\"qux1\", ref]);\n      secondDict.set(\"baz\", [\"qux2\", ref]);\n      expect(getInheritableProperty({\n        dict: firstDict,\n        key: \"baz\",\n        getArray: true,\n        stopWhenFound: false\n      })).toEqual([[\"qux1\", \"quux\"], [\"qux2\", \"quux\"]]);\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles invalid arguments","suites":["core_utils","toRomanNumerals"],"line":123,"updatePoint":{"line":123,"column":33,"index":4287},"code":"    it(\"handles invalid arguments\", function () {\n      for (const input of [\"foo\", -1, 0]) {\n        expect(function () {\n          toRomanNumerals(input);\n        }).toThrow(new Error(\"The number should be a positive integer.\"));\n      }\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"converts numbers to uppercase Roman numerals","suites":["core_utils","toRomanNumerals"],"line":130,"updatePoint":{"line":130,"column":52,"index":4554},"code":"    it(\"converts numbers to uppercase Roman numerals\", function () {\n      expect(toRomanNumerals(1)).toEqual(\"I\");\n      expect(toRomanNumerals(6)).toEqual(\"VI\");\n      expect(toRomanNumerals(7)).toEqual(\"VII\");\n      expect(toRomanNumerals(8)).toEqual(\"VIII\");\n      expect(toRomanNumerals(10)).toEqual(\"X\");\n      expect(toRomanNumerals(40)).toEqual(\"XL\");\n      expect(toRomanNumerals(100)).toEqual(\"C\");\n      expect(toRomanNumerals(500)).toEqual(\"D\");\n      expect(toRomanNumerals(1000)).toEqual(\"M\");\n      expect(toRomanNumerals(2019)).toEqual(\"MMXIX\");\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"converts numbers to lowercase Roman numerals","suites":["core_utils","toRomanNumerals"],"line":142,"updatePoint":{"line":142,"column":52,"index":5124},"code":"    it(\"converts numbers to lowercase Roman numerals\", function () {\n      expect(toRomanNumerals(1,\n      /* lowercase = */\n      true)).toEqual(\"i\");\n      expect(toRomanNumerals(6,\n      /* lowercase = */\n      true)).toEqual(\"vi\");\n      expect(toRomanNumerals(7,\n      /* lowercase = */\n      true)).toEqual(\"vii\");\n      expect(toRomanNumerals(8,\n      /* lowercase = */\n      true)).toEqual(\"viii\");\n      expect(toRomanNumerals(10,\n      /* lowercase = */\n      true)).toEqual(\"x\");\n      expect(toRomanNumerals(40,\n      /* lowercase = */\n      true)).toEqual(\"xl\");\n      expect(toRomanNumerals(100,\n      /* lowercase = */\n      true)).toEqual(\"c\");\n      expect(toRomanNumerals(500,\n      /* lowercase = */\n      true)).toEqual(\"d\");\n      expect(toRomanNumerals(1000,\n      /* lowercase = */\n      true)).toEqual(\"m\");\n      expect(toRomanNumerals(2019,\n      /* lowercase = */\n      true)).toEqual(\"mmxix\");\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles values smaller than/equal to zero","suites":["core_utils","log2"],"line":176,"updatePoint":{"line":176,"column":49,"index":6090},"code":"    it(\"handles values smaller than/equal to zero\", function () {\n      expect(log2(0)).toEqual(0);\n      expect(log2(-1)).toEqual(0);\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles values larger than zero","suites":["core_utils","log2"],"line":180,"updatePoint":{"line":180,"column":39,"index":6223},"code":"    it(\"handles values larger than zero\", function () {\n      expect(log2(1)).toEqual(0);\n      expect(log2(2)).toEqual(1);\n      expect(log2(3)).toEqual(2);\n      expect(log2(3.14)).toEqual(2);\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles space characters","suites":["core_utils","isWhiteSpace"],"line":188,"updatePoint":{"line":188,"column":32,"index":6466},"code":"    it(\"handles space characters\", function () {\n      expect(isWhiteSpace(0x20)).toEqual(true);\n      expect(isWhiteSpace(0x09)).toEqual(true);\n      expect(isWhiteSpace(0x0d)).toEqual(true);\n      expect(isWhiteSpace(0x0a)).toEqual(true);\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles non-space characters","suites":["core_utils","isWhiteSpace"],"line":194,"updatePoint":{"line":194,"column":36,"index":6719},"code":"    it(\"handles non-space characters\", function () {\n      expect(isWhiteSpace(0x0b)).toEqual(false);\n      expect(isWhiteSpace(null)).toEqual(false);\n      expect(isWhiteSpace(undefined)).toEqual(false);\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"should get a correctly parsed path","suites":["core_utils","parseXFAPath"],"line":201,"updatePoint":{"line":201,"column":42,"index":6985},"code":"    it(\"should get a correctly parsed path\", function () {\n      const path = \"foo.bar[12].oof[3].rab.FOO[123].BAR[456]\";\n      expect(parseXFAPath(path)).toEqual([{\n        name: \"foo\",\n        pos: 0\n      }, {\n        name: \"bar\",\n        pos: 12\n      }, {\n        name: \"oof\",\n        pos: 3\n      }, {\n        name: \"rab\",\n        pos: 0\n      }, {\n        name: \"FOO\",\n        pos: 123\n      }, {\n        name: \"BAR\",\n        pos: 456\n      }]);\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"should escape PDF name","suites":["core_utils","escapePDFName"],"line":225,"updatePoint":{"line":225,"column":30,"index":7482},"code":"    it(\"should escape PDF name\", function () {\n      expect(escapePDFName(\"hello\")).toEqual(\"hello\");\n      expect(escapePDFName(\"\\xfehello\")).toEqual(\"#fehello\");\n      expect(escapePDFName(\"he\\xfell\\xffo\")).toEqual(\"he#fell#ffo\");\n      expect(escapePDFName(\"\\xfehe\\xfell\\xffo\\xff\")).toEqual(\"#fehe#fell#ffo#ff\");\n      expect(escapePDFName(\"#h#e#l#l#o\")).toEqual(\"#23h#23e#23l#23l#23o\");\n      expect(escapePDFName(\"#()<>[]{}/%\")).toEqual(\"#23#28#29#3c#3e#5b#5d#7b#7d#2f#25\");\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"should get a correctly encoded string with some entities","suites":["core_utils","encodeToXmlString"],"line":235,"updatePoint":{"line":235,"column":64,"index":8056},"code":"    it(\"should get a correctly encoded string with some entities\", function () {\n      const str = \"\\\"\\u0397ell😂' & <W😂rld>\";\n      expect(encodeToXmlString(str)).toEqual(\"&quot;&#x397;ell&#x1F602;&apos; &amp; &lt;W&#x1F602;rld&gt;\");\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"should get a correctly encoded basic ascii string","suites":["core_utils","encodeToXmlString"],"line":239,"updatePoint":{"line":239,"column":57,"index":8294},"code":"    it(\"should get a correctly encoded basic ascii string\", function () {\n      const str = \"hello world\";\n      expect(encodeToXmlString(str)).toEqual(str);\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"Check font family","suites":["core_utils","validateCSSFont"],"line":245,"updatePoint":{"line":245,"column":25,"index":8478},"code":"    it(\"Check font family\", function () {\n      const cssFontInfo = {\n        fontFamily: `\"blah blah \" blah blah\"`,\n        fontWeight: 0,\n        italicAngle: 0\n      };\n      expect(validateCSSFont(cssFontInfo)).toEqual(false);\n      cssFontInfo.fontFamily = `\"blah blah \\\\\" blah blah\"`;\n      expect(validateCSSFont(cssFontInfo)).toEqual(true);\n      cssFontInfo.fontFamily = `'blah blah ' blah blah'`;\n      expect(validateCSSFont(cssFontInfo)).toEqual(false);\n      cssFontInfo.fontFamily = `'blah blah \\\\' blah blah'`;\n      expect(validateCSSFont(cssFontInfo)).toEqual(true);\n      cssFontInfo.fontFamily = `\"blah blah `;\n      expect(validateCSSFont(cssFontInfo)).toEqual(false);\n      cssFontInfo.fontFamily = `blah blah\"`;\n      expect(validateCSSFont(cssFontInfo)).toEqual(false);\n      cssFontInfo.fontFamily = `'blah blah `;\n      expect(validateCSSFont(cssFontInfo)).toEqual(false);\n      cssFontInfo.fontFamily = `blah blah'`;\n      expect(validateCSSFont(cssFontInfo)).toEqual(false);\n      cssFontInfo.fontFamily = \"blah blah blah\";\n      expect(validateCSSFont(cssFontInfo)).toEqual(true);\n      cssFontInfo.fontFamily = \"blah 0blah blah\";\n      expect(validateCSSFont(cssFontInfo)).toEqual(false);\n      cssFontInfo.fontFamily = \"blah blah -0blah\";\n      expect(validateCSSFont(cssFontInfo)).toEqual(false);\n      cssFontInfo.fontFamily = \"blah blah --blah\";\n      expect(validateCSSFont(cssFontInfo)).toEqual(false);\n      cssFontInfo.fontFamily = \"blah blah -blah\";\n      expect(validateCSSFont(cssFontInfo)).toEqual(true);\n      cssFontInfo.fontFamily = \"blah fdqAJqjHJK23kl23__--Kj blah\";\n      expect(validateCSSFont(cssFontInfo)).toEqual(true);\n      cssFontInfo.fontFamily = \"blah fdqAJqjH$JK23kl23__--Kj blah\";\n      expect(validateCSSFont(cssFontInfo)).toEqual(false);\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"Check font weight","suites":["core_utils","validateCSSFont"],"line":281,"updatePoint":{"line":281,"column":25,"index":10284},"code":"    it(\"Check font weight\", function () {\n      const cssFontInfo = {\n        fontFamily: \"blah\",\n        fontWeight: 100,\n        italicAngle: 0\n      };\n      validateCSSFont(cssFontInfo);\n      expect(cssFontInfo.fontWeight).toEqual(\"100\");\n      cssFontInfo.fontWeight = \"700\";\n      validateCSSFont(cssFontInfo);\n      expect(cssFontInfo.fontWeight).toEqual(\"700\");\n      cssFontInfo.fontWeight = \"normal\";\n      validateCSSFont(cssFontInfo);\n      expect(cssFontInfo.fontWeight).toEqual(\"normal\");\n      cssFontInfo.fontWeight = 314;\n      validateCSSFont(cssFontInfo);\n      expect(cssFontInfo.fontWeight).toEqual(\"400\");\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"Check italic angle","suites":["core_utils","validateCSSFont"],"line":299,"updatePoint":{"line":299,"column":26,"index":10922},"code":"    it(\"Check italic angle\", function () {\n      const cssFontInfo = {\n        fontFamily: \"blah\",\n        fontWeight: 100,\n        italicAngle: 10\n      };\n      validateCSSFont(cssFontInfo);\n      expect(cssFontInfo.italicAngle).toEqual(\"10\");\n      cssFontInfo.italicAngle = -123;\n      validateCSSFont(cssFontInfo);\n      expect(cssFontInfo.italicAngle).toEqual(\"14\");\n      cssFontInfo.italicAngle = \"91\";\n      validateCSSFont(cssFontInfo);\n      expect(cssFontInfo.italicAngle).toEqual(\"14\");\n      cssFontInfo.italicAngle = 2.718;\n      validateCSSFont(cssFontInfo);\n      expect(cssFontInfo.italicAngle).toEqual(\"2.718\");\n    });","file":"unit/core_utils_spec.js","skipped":false,"dir":"test"},{"name":"should pass RFC 1321 test #1","suites":["crypto","calculateMD5"],"line":37,"updatePoint":{"line":37,"column":36,"index":1469},"code":"    it(\"should pass RFC 1321 test #1\", function () {\n      const input = stringToBytes(\"\");\n      const result = calculateMD5(input, 0, input.length);\n      const expected = hex2binary(\"d41d8cd98f00b204e9800998ecf8427e\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should pass RFC 1321 test #2","suites":["crypto","calculateMD5"],"line":43,"updatePoint":{"line":43,"column":36,"index":1739},"code":"    it(\"should pass RFC 1321 test #2\", function () {\n      const input = stringToBytes(\"a\");\n      const result = calculateMD5(input, 0, input.length);\n      const expected = hex2binary(\"0cc175b9c0f1b6a831c399e269772661\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should pass RFC 1321 test #3","suites":["crypto","calculateMD5"],"line":49,"updatePoint":{"line":49,"column":36,"index":2010},"code":"    it(\"should pass RFC 1321 test #3\", function () {\n      const input = stringToBytes(\"abc\");\n      const result = calculateMD5(input, 0, input.length);\n      const expected = hex2binary(\"900150983cd24fb0d6963f7d28e17f72\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should pass RFC 1321 test #4","suites":["crypto","calculateMD5"],"line":55,"updatePoint":{"line":55,"column":36,"index":2283},"code":"    it(\"should pass RFC 1321 test #4\", function () {\n      const input = stringToBytes(\"message digest\");\n      const result = calculateMD5(input, 0, input.length);\n      const expected = hex2binary(\"f96b697d7cb7938d525a2f31aaf161d0\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should pass RFC 1321 test #5","suites":["crypto","calculateMD5"],"line":61,"updatePoint":{"line":61,"column":36,"index":2567},"code":"    it(\"should pass RFC 1321 test #5\", function () {\n      const input = stringToBytes(\"abcdefghijklmnopqrstuvwxyz\");\n      const result = calculateMD5(input, 0, input.length);\n      const expected = hex2binary(\"c3fcd3d76192e4007dfb496cca67e13b\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should pass RFC 1321 test #6","suites":["crypto","calculateMD5"],"line":67,"updatePoint":{"line":67,"column":36,"index":2863},"code":"    it(\"should pass RFC 1321 test #6\", function () {\n      const input = stringToBytes(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\");\n      const result = calculateMD5(input, 0, input.length);\n      const expected = hex2binary(\"d174ab98d277d9f5a5611c2c9f419d9f\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should pass RFC 1321 test #7","suites":["crypto","calculateMD5"],"line":73,"updatePoint":{"line":73,"column":36,"index":3195},"code":"    it(\"should pass RFC 1321 test #7\", function () {\n      const input = stringToBytes(\"123456789012345678901234567890123456789012345678\" + \"90123456789012345678901234567890\");\n      const result = calculateMD5(input, 0, input.length);\n      const expected = hex2binary(\"57edf4a22be3c955ac49da2e2107b67a\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should pass test #1","suites":["crypto","ARCFourCipher"],"line":82,"updatePoint":{"line":82,"column":27,"index":3661},"code":"    it(\"should pass test #1\", function () {\n      const key = hex2binary(\"0123456789abcdef\");\n      const input = hex2binary(\"0123456789abcdef\");\n      const cipher = new ARCFourCipher(key);\n      const result = cipher.encryptBlock(input);\n      const expected = hex2binary(\"75b7878099e0c596\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should pass test #2","suites":["crypto","ARCFourCipher"],"line":90,"updatePoint":{"line":90,"column":27,"index":4004},"code":"    it(\"should pass test #2\", function () {\n      const key = hex2binary(\"0123456789abcdef\");\n      const input = hex2binary(\"0000000000000000\");\n      const cipher = new ARCFourCipher(key);\n      const result = cipher.encryptBlock(input);\n      const expected = hex2binary(\"7494c2e7104b0879\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should pass test #3","suites":["crypto","ARCFourCipher"],"line":98,"updatePoint":{"line":98,"column":27,"index":4347},"code":"    it(\"should pass test #3\", function () {\n      const key = hex2binary(\"0000000000000000\");\n      const input = hex2binary(\"0000000000000000\");\n      const cipher = new ARCFourCipher(key);\n      const result = cipher.encryptBlock(input);\n      const expected = hex2binary(\"de188941a3375d3a\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should pass test #4","suites":["crypto","ARCFourCipher"],"line":106,"updatePoint":{"line":106,"column":27,"index":4690},"code":"    it(\"should pass test #4\", function () {\n      const key = hex2binary(\"ef012345\");\n      const input = hex2binary(\"00000000000000000000\");\n      const cipher = new ARCFourCipher(key);\n      const result = cipher.encryptBlock(input);\n      const expected = hex2binary(\"d6a141a7ec3c38dfbd61\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should pass test #5","suites":["crypto","ARCFourCipher"],"line":114,"updatePoint":{"line":114,"column":27,"index":5033},"code":"    it(\"should pass test #5\", function () {\n      const key = hex2binary(\"0123456789abcdef\");\n      const input = hex2binary(\"010101010101010101010101010101010101010101010101010\" + \"10101010101010101010101010101010101010101010101010101010101010101010\" + \"10101010101010101010101010101010101010101010101010101010101010101010\" + \"10101010101010101010101010101010101010101010101010101010101010101010\" + \"10101010101010101010101010101010101010101010101010101010101010101010\" + \"10101010101010101010101010101010101010101010101010101010101010101010\" + \"10101010101010101010101010101010101010101010101010101010101010101010\" + \"10101010101010101010101010101010101010101010101010101010101010101010\" + \"10101010101010101010101010101010101010101010101010101010101010101010\" + \"10101010101010101010101010101010101010101010101010101010101010101010\" + \"10101010101010101010101010101010101010101010101010101010101010101010\" + \"10101010101010101010101010101010101010101010101010101010101010101010\" + \"10101010101010101010101010101010101010101010101010101010101010101010\" + \"10101010101010101010101010101010101010101010101010101010101010101010\" + \"10101010101010101010101010101010101010101010101010101010101010101010\" + \"101010101010101010101\");\n      const cipher = new ARCFourCipher(key);\n      const result = cipher.encryptBlock(input);\n      const expected = hex2binary(\"7595c3e6114a09780c4ad452338e1ffd9a1be9498f813d76\" + \"533449b6778dcad8c78a8d2ba9ac66085d0e53d59c26c2d1c490c1ebbe0ce66d1b6b\" + \"1b13b6b919b847c25a91447a95e75e4ef16779cde8bf0a95850e32af9689444fd377\" + \"108f98fdcbd4e726567500990bcc7e0ca3c4aaa304a387d20f3b8fbbcd42a1bd311d\" + \"7a4303dda5ab078896ae80c18b0af66dff319616eb784e495ad2ce90d7f772a81747\" + \"b65f62093b1e0db9e5ba532fafec47508323e671327df9444432cb7367cec82f5d44\" + \"c0d00b67d650a075cd4b70dedd77eb9b10231b6b5b741347396d62897421d43df9b4\" + \"2e446e358e9c11a9b2184ecbef0cd8e7a877ef968f1390ec9b3d35a5585cb009290e\" + \"2fcde7b5ec66d9084be44055a619d9dd7fc3166f9487f7cb272912426445998514c1\" + \"5d53a18c864ce3a2b7555793988126520eacf2e3066e230c91bee4dd5304f5fd0405\" + \"b35bd99c73135d3d9bc335ee049ef69b3867bf2d7bd1eaa595d8bfc0066ff8d31509\" + \"eb0c6caa006c807a623ef84c3d33c195d23ee320c40de0558157c822d4b8c569d849\" + \"aed59d4e0fd7f379586b4b7ff684ed6a189f7486d49b9c4bad9ba24b96abf924372c\" + \"8a8fffb10d55354900a77a3db5f205e1b99fcd8660863a159ad4abe40fa48934163d\" + \"dde542a6585540fd683cbfd8c00f12129a284deacc4cdefe58be7137541c047126c8\" + \"d49e2755ab181ab7e940b0c0\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should pass test #6","suites":["crypto","ARCFourCipher"],"line":122,"updatePoint":{"line":122,"column":27,"index":7542},"code":"    it(\"should pass test #6\", function () {\n      const key = hex2binary(\"fb029e3031323334\");\n      const input = hex2binary(\"aaaa0300000008004500004e661a00008011be640a0001220af\" + \"fffff00890089003a000080a601100001000000000000204543454a4548454346434\" + \"550464545494546464343414341434143414341414100002000011bd0b604\");\n      const cipher = new ARCFourCipher(key);\n      const result = cipher.encryptBlock(input);\n      const expected = hex2binary(\"f69c5806bd6ce84626bcbefb9474650aad1f7909b0f64d5f\" + \"58a503a258b7ed22eb0ea64930d3a056a55742fcce141d485f8aa836dea18df42c53\" + \"80805ad0c61a5d6f58f41040b24b7d1a693856ed0d4398e7aee3bf0e2a2ca8f7\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should pass test #7","suites":["crypto","ARCFourCipher"],"line":130,"updatePoint":{"line":130,"column":27,"index":8233},"code":"    it(\"should pass test #7\", function () {\n      const key = hex2binary(\"0123456789abcdef\");\n      const input = hex2binary(\"123456789abcdef0123456789abcdef0123456789abcdef012345678\");\n      const cipher = new ARCFourCipher(key);\n      const result = cipher.encryptBlock(input);\n      const expected = hex2binary(\"66a0949f8af7d6891f7f832ba833c00c892ebe30143ce28740011ecf\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should properly hash abc","suites":["crypto","calculateSHA256"],"line":140,"updatePoint":{"line":140,"column":32,"index":8711},"code":"    it(\"should properly hash abc\", function () {\n      const input = stringToBytes(\"abc\");\n      const result = calculateSHA256(input, 0, input.length);\n      const expected = hex2binary(\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should properly hash a multiblock input","suites":["crypto","calculateSHA256"],"line":146,"updatePoint":{"line":146,"column":47,"index":9030},"code":"    it(\"should properly hash a multiblock input\", function () {\n      const input = stringToBytes(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\");\n      const result = calculateSHA256(input, 0, input.length);\n      const expected = hex2binary(\"248D6A61D20638B8E5C026930C3E6039A33CE45964FF2167F6ECEDD419DB06C1\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should properly hash abc","suites":["crypto","calculateSHA384"],"line":154,"updatePoint":{"line":154,"column":32,"index":9437},"code":"    it(\"should properly hash abc\", function () {\n      const input = stringToBytes(\"abc\");\n      const result = calculateSHA384(input, 0, input.length);\n      const expected = hex2binary(\"CB00753F45A35E8BB5A03D699AC65007272C32AB0EDED163\" + \"1A8B605A43FF5BED8086072BA1E7CC2358BAECA134C825A7\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should properly hash a multiblock input","suites":["crypto","calculateSHA384"],"line":160,"updatePoint":{"line":160,"column":47,"index":9793},"code":"    it(\"should properly hash a multiblock input\", function () {\n      const input = stringToBytes(\"abcdefghbcdefghicdefghijdefghijkefghijklfghijklm\" + \"ghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrs\" + \"mnopqrstnopqrstu\");\n      const result = calculateSHA384(input, 0, input.length);\n      const expected = hex2binary(\"09330C33F71147E83D192FC782CD1B4753111B173B3B05D2\" + \"2FA08086E3B0F712FCC7C71A557E2DB966C3E9FA91746039\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should properly hash abc","suites":["crypto","calculateSHA512"],"line":168,"updatePoint":{"line":168,"column":32,"index":10303},"code":"    it(\"should properly hash abc\", function () {\n      const input = stringToBytes(\"abc\");\n      const result = calculateSHA512(input, 0, input.length);\n      const expected = hex2binary(\"DDAF35A193617ABACC417349AE20413112E6FA4E89A97EA2\" + \"0A9EEEE64B55D39A2192992A274FC1A836BA3C23A3FEEBBD\" + \"454D4423643CE80E2A9AC94FA54CA49F\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should properly hash a multiblock input","suites":["crypto","calculateSHA512"],"line":174,"updatePoint":{"line":174,"column":47,"index":10696},"code":"    it(\"should properly hash a multiblock input\", function () {\n      const input = stringToBytes(\"abcdefghbcdefghicdefghijdefghijkefghijklfghijklm\" + \"ghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrs\" + \"mnopqrstnopqrstu\");\n      const result = calculateSHA512(input, 0, input.length);\n      const expected = hex2binary(\"8E959B75DAE313DA8CF4F72814FC143F8F7779C6EB9F7FA1\" + \"7299AEADB6889018501D289E4900F7E4331B99DEC4B5433A\" + \"C7D329EEB6DD26545E96E55B874BE909\");\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should be able to encrypt a block","suites":["crypto","AES128","Encryption"],"line":183,"updatePoint":{"line":183,"column":43,"index":11286},"code":"      it(\"should be able to encrypt a block\", function () {\n        const input = hex2binary(\"00112233445566778899aabbccddeeff\");\n        const key = hex2binary(\"000102030405060708090a0b0c0d0e0f\");\n        const iv = hex2binary(\"00000000000000000000000000000000\");\n        const cipher = new AES128Cipher(key);\n        const result = cipher.encrypt(input, iv);\n        const expected = hex2binary(\"69c4e0d86a7b0430d8cdb78070b4c55a\");\n        expect(result).toEqual(expected);\n      });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should be able to decrypt a block with IV in stream","suites":["crypto","AES128","Decryption"],"line":194,"updatePoint":{"line":194,"column":61,"index":11839},"code":"      it(\"should be able to decrypt a block with IV in stream\", function () {\n        const input = hex2binary(\"0000000000000000000000000000000069c4e0d86a7b0430d\" + \"8cdb78070b4c55a\");\n        const key = hex2binary(\"000102030405060708090a0b0c0d0e0f\");\n        const cipher = new AES128Cipher(key);\n        const result = cipher.decryptBlock(input);\n        const expected = hex2binary(\"00112233445566778899aabbccddeeff\");\n        expect(result).toEqual(expected);\n      });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should be able to encrypt a block","suites":["crypto","AES256","Encryption"],"line":206,"updatePoint":{"line":206,"column":43,"index":12386},"code":"      it(\"should be able to encrypt a block\", function () {\n        const input = hex2binary(\"00112233445566778899aabbccddeeff\");\n        const key = hex2binary(\"000102030405060708090a0b0c0d0e0f101112131415161718\" + \"191a1b1c1d1e1f\");\n        const iv = hex2binary(\"00000000000000000000000000000000\");\n        const cipher = new AES256Cipher(key);\n        const result = cipher.encrypt(input, iv);\n        const expected = hex2binary(\"8ea2b7ca516745bfeafc49904b496089\");\n        expect(result).toEqual(expected);\n      });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should be able to decrypt a block with specified iv","suites":["crypto","AES256","Decryption"],"line":217,"updatePoint":{"line":217,"column":61,"index":12976},"code":"      it(\"should be able to decrypt a block with specified iv\", function () {\n        const input = hex2binary(\"8ea2b7ca516745bfeafc49904b496089\");\n        const key = hex2binary(\"000102030405060708090a0b0c0d0e0f101112131415161718\" + \"191a1b1c1d1e1f\");\n        const iv = hex2binary(\"00000000000000000000000000000000\");\n        const cipher = new AES256Cipher(key);\n        const result = cipher.decryptBlock(input, false, iv);\n        const expected = hex2binary(\"00112233445566778899aabbccddeeff\");\n        expect(result).toEqual(expected);\n      });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should be able to decrypt a block with IV in stream","suites":["crypto","AES256","Decryption"],"line":226,"updatePoint":{"line":226,"column":61,"index":13529},"code":"      it(\"should be able to decrypt a block with IV in stream\", function () {\n        const input = hex2binary(\"000000000000000000000000000000008ea2b7ca516745bf\" + \"eafc49904b496089\");\n        const key = hex2binary(\"000102030405060708090a0b0c0d0e0f101112131415161718\" + \"191a1b1c1d1e1f\");\n        const cipher = new AES256Cipher(key);\n        const result = cipher.decryptBlock(input, false);\n        const expected = hex2binary(\"00112233445566778899aabbccddeeff\");\n        expect(result).toEqual(expected);\n      });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should correctly check a user key","suites":["crypto","PDF17Algorithm"],"line":237,"updatePoint":{"line":237,"column":41,"index":14085},"code":"    it(\"should correctly check a user key\", function () {\n      const alg = new PDF17();\n      const password = new Uint8Array([117, 115, 101, 114]);\n      const userValidation = new Uint8Array([117, 169, 4, 32, 159, 101, 22, 220]);\n      const userPassword = new Uint8Array([131, 242, 143, 160, 87, 2, 138, 134, 79, 253, 189, 173, 224, 73, 144, 241, 190, 81, 197, 15, 249, 105, 145, 151, 15, 194, 65, 3, 1, 126, 187, 221]);\n      const result = alg.checkUserPassword(password, userValidation, userPassword);\n      expect(result).toEqual(true);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should correctly check an owner key","suites":["crypto","PDF17Algorithm"],"line":245,"updatePoint":{"line":245,"column":43,"index":14640},"code":"    it(\"should correctly check an owner key\", function () {\n      const alg = new PDF17();\n      const password = new Uint8Array([111, 119, 110, 101, 114]);\n      const ownerValidation = new Uint8Array([243, 118, 71, 153, 128, 17, 101, 62]);\n      const ownerPassword = new Uint8Array([60, 98, 137, 35, 51, 101, 200, 152, 210, 178, 226, 228, 134, 205, 163, 24, 204, 126, 177, 36, 106, 50, 36, 125, 210, 172, 171, 120, 222, 108, 139, 115]);\n      const uBytes = new Uint8Array([131, 242, 143, 160, 87, 2, 138, 134, 79, 253, 189, 173, 224, 73, 144, 241, 190, 81, 197, 15, 249, 105, 145, 151, 15, 194, 65, 3, 1, 126, 187, 221, 117, 169, 4, 32, 159, 101, 22, 220, 168, 94, 215, 192, 100, 38, 188, 40]);\n      const result = alg.checkOwnerPassword(password, ownerValidation, uBytes, ownerPassword);\n      expect(result).toEqual(true);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should generate a file encryption key from the user key","suites":["crypto","PDF17Algorithm"],"line":254,"updatePoint":{"line":254,"column":63,"index":15498},"code":"    it(\"should generate a file encryption key from the user key\", function () {\n      const alg = new PDF17();\n      const password = new Uint8Array([117, 115, 101, 114]);\n      const userKeySalt = new Uint8Array([168, 94, 215, 192, 100, 38, 188, 40]);\n      const userEncryption = new Uint8Array([35, 150, 195, 169, 245, 51, 51, 255, 158, 158, 33, 242, 231, 75, 125, 190, 25, 126, 172, 114, 195, 244, 137, 245, 234, 165, 42, 74, 60, 38, 17, 17]);\n      const result = alg.getUserKey(password, userKeySalt, userEncryption);\n      const expected = new Uint8Array([63, 114, 136, 209, 87, 61, 12, 30, 249, 1, 186, 144, 254, 248, 163, 153, 151, 51, 133, 10, 80, 152, 206, 15, 72, 187, 231, 33, 224, 239, 13, 213]);\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should generate a file encryption key from the owner key","suites":["crypto","PDF17Algorithm"],"line":263,"updatePoint":{"line":263,"column":64,"index":16258},"code":"    it(\"should generate a file encryption key from the owner key\", function () {\n      const alg = new PDF17();\n      const password = new Uint8Array([111, 119, 110, 101, 114]);\n      const ownerKeySalt = new Uint8Array([200, 245, 242, 12, 218, 123, 24, 120]);\n      const ownerEncryption = new Uint8Array([213, 202, 14, 189, 110, 76, 70, 191, 6, 195, 10, 190, 157, 100, 144, 85, 8, 62, 123, 178, 156, 229, 50, 40, 229, 216, 54, 222, 34, 38, 106, 223]);\n      const uBytes = new Uint8Array([131, 242, 143, 160, 87, 2, 138, 134, 79, 253, 189, 173, 224, 73, 144, 241, 190, 81, 197, 15, 249, 105, 145, 151, 15, 194, 65, 3, 1, 126, 187, 221, 117, 169, 4, 32, 159, 101, 22, 220, 168, 94, 215, 192, 100, 38, 188, 40]);\n      const result = alg.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);\n      const expected = new Uint8Array([63, 114, 136, 209, 87, 61, 12, 30, 249, 1, 186, 144, 254, 248, 163, 153, 151, 51, 133, 10, 80, 152, 206, 15, 72, 187, 231, 33, 224, 239, 13, 213]);\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should correctly check a user key","suites":["crypto","PDF20Algorithm"],"line":275,"updatePoint":{"line":275,"column":41,"index":17319},"code":"    it(\"should correctly check a user key\", function () {\n      const alg = new PDF20();\n      const password = new Uint8Array([117, 115, 101, 114]);\n      const userValidation = new Uint8Array([83, 245, 146, 101, 198, 247, 34, 198]);\n      const userPassword = new Uint8Array([94, 230, 205, 75, 166, 99, 250, 76, 219, 128, 17, 85, 57, 17, 33, 164, 150, 46, 103, 176, 160, 156, 187, 233, 166, 223, 163, 253, 147, 235, 95, 184]);\n      const result = alg.checkUserPassword(password, userValidation, userPassword);\n      expect(result).toEqual(true);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should correctly check an owner key","suites":["crypto","PDF20Algorithm"],"line":283,"updatePoint":{"line":283,"column":43,"index":17878},"code":"    it(\"should correctly check an owner key\", function () {\n      const alg = new PDF20();\n      const password = new Uint8Array([111, 119, 110, 101, 114]);\n      const ownerValidation = new Uint8Array([142, 232, 169, 208, 202, 214, 5, 185]);\n      const ownerPassword = new Uint8Array([88, 232, 62, 54, 245, 26, 245, 209, 137, 123, 221, 72, 199, 49, 37, 217, 31, 74, 115, 167, 127, 158, 176, 77, 45, 163, 87, 47, 39, 90, 217, 141]);\n      const uBytes = new Uint8Array([94, 230, 205, 75, 166, 99, 250, 76, 219, 128, 17, 85, 57, 17, 33, 164, 150, 46, 103, 176, 160, 156, 187, 233, 166, 223, 163, 253, 147, 235, 95, 184, 83, 245, 146, 101, 198, 247, 34, 198, 191, 11, 16, 94, 237, 216, 20, 175]);\n      const result = alg.checkOwnerPassword(password, ownerValidation, uBytes, ownerPassword);\n      expect(result).toEqual(true);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should generate a file encryption key from the user key","suites":["crypto","PDF20Algorithm"],"line":292,"updatePoint":{"line":292,"column":63,"index":18733},"code":"    it(\"should generate a file encryption key from the user key\", function () {\n      const alg = new PDF20();\n      const password = new Uint8Array([117, 115, 101, 114]);\n      const userKeySalt = new Uint8Array([191, 11, 16, 94, 237, 216, 20, 175]);\n      const userEncryption = new Uint8Array([121, 208, 2, 181, 230, 89, 156, 60, 253, 143, 212, 28, 84, 180, 196, 177, 173, 128, 221, 107, 46, 20, 94, 186, 135, 51, 95, 24, 20, 223, 254, 36]);\n      const result = alg.getUserKey(password, userKeySalt, userEncryption);\n      const expected = new Uint8Array([42, 218, 213, 39, 73, 91, 72, 79, 67, 38, 248, 133, 18, 189, 61, 34, 107, 79, 29, 56, 59, 181, 213, 118, 113, 34, 65, 210, 87, 174, 22, 239]);\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should generate a file encryption key from the owner key","suites":["crypto","PDF20Algorithm"],"line":301,"updatePoint":{"line":301,"column":64,"index":19485},"code":"    it(\"should generate a file encryption key from the owner key\", function () {\n      const alg = new PDF20();\n      const password = new Uint8Array([111, 119, 110, 101, 114]);\n      const ownerKeySalt = new Uint8Array([29, 208, 185, 46, 11, 76, 135, 149]);\n      const ownerEncryption = new Uint8Array([209, 73, 224, 77, 103, 155, 201, 181, 190, 68, 223, 20, 62, 90, 56, 210, 5, 240, 178, 128, 238, 124, 68, 254, 253, 244, 62, 108, 208, 135, 10, 251]);\n      const uBytes = new Uint8Array([94, 230, 205, 75, 166, 99, 250, 76, 219, 128, 17, 85, 57, 17, 33, 164, 150, 46, 103, 176, 160, 156, 187, 233, 166, 223, 163, 253, 147, 235, 95, 184, 83, 245, 146, 101, 198, 247, 34, 198, 191, 11, 16, 94, 237, 216, 20, 175]);\n      const result = alg.getOwnerKey(password, ownerKeySalt, uBytes, ownerEncryption);\n      const expected = new Uint8Array([42, 218, 213, 39, 73, 91, 72, 79, 67, 38, 248, 133, 18, 189, 61, 34, 107, 79, 29, 56, 59, 181, 213, 118, 113, 34, 65, 210, 87, 174, 22, 239]);\n      expect(result).toEqual(expected);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should accept user password","suites":["CipherTransformFactory","#ctor","AES256 Revision 5"],"line":462,"updatePoint":{"line":462,"column":37,"index":26962},"code":"      it(\"should accept user password\", function () {\n        ensurePasswordCorrect(aes256Dict, fileId1, \"user\");\n      });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should accept owner password","suites":["CipherTransformFactory","#ctor","AES256 Revision 5"],"line":465,"updatePoint":{"line":465,"column":38,"index":27087},"code":"      it(\"should accept owner password\", function () {\n        ensurePasswordCorrect(aes256Dict, fileId1, \"owner\");\n      });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should not accept blank password","suites":["CipherTransformFactory","#ctor","AES256 Revision 5"],"line":468,"updatePoint":{"line":468,"column":42,"index":27217},"code":"      it(\"should not accept blank password\", function () {\n        ensurePasswordNeeded(aes256Dict, fileId1);\n      });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should not accept wrong password","suites":["CipherTransformFactory","#ctor","AES256 Revision 5"],"line":471,"updatePoint":{"line":471,"column":42,"index":27337},"code":"      it(\"should not accept wrong password\", function () {\n        ensurePasswordIncorrect(aes256Dict, fileId1, \"wrong\");\n      });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should accept blank password","suites":["CipherTransformFactory","#ctor","AES256 Revision 5"],"line":474,"updatePoint":{"line":474,"column":38,"index":27465},"code":"      it(\"should accept blank password\", function () {\n        ensurePasswordCorrect(aes256BlankDict, fileId1);\n      });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should accept user password","suites":["CipherTransformFactory","#ctor","AES256 Revision 6"],"line":479,"updatePoint":{"line":479,"column":37,"index":27642},"code":"      it(\"should accept user password\", function () {\n        ensurePasswordCorrect(aes256IsoDict, fileId1, \"user\");\n      });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should accept owner password","suites":["CipherTransformFactory","#ctor","AES256 Revision 6"],"line":482,"updatePoint":{"line":482,"column":38,"index":27770},"code":"      it(\"should accept owner password\", function () {\n        ensurePasswordCorrect(aes256IsoDict, fileId1, \"owner\");\n      });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should not accept blank password","suites":["CipherTransformFactory","#ctor","AES256 Revision 6"],"line":485,"updatePoint":{"line":485,"column":42,"index":27903},"code":"      it(\"should not accept blank password\", function () {\n        ensurePasswordNeeded(aes256IsoDict, fileId1);\n      });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should not accept wrong password","suites":["CipherTransformFactory","#ctor","AES256 Revision 6"],"line":488,"updatePoint":{"line":488,"column":42,"index":28026},"code":"      it(\"should not accept wrong password\", function () {\n        ensurePasswordIncorrect(aes256IsoDict, fileId1, \"wrong\");\n      });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should accept blank password","suites":["CipherTransformFactory","#ctor","AES256 Revision 6"],"line":491,"updatePoint":{"line":491,"column":38,"index":28157},"code":"      it(\"should accept blank password\", function () {\n        ensurePasswordCorrect(aes256IsoBlankDict, fileId1);\n      });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should accept user password","suites":["CipherTransformFactory","#ctor","AES256 Revision 6"],"line":495,"updatePoint":{"line":495,"column":35,"index":28287},"code":"    it(\"should accept user password\", function () {\n      ensurePasswordCorrect(dict1, fileId1, \"123456\");\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should accept owner password","suites":["CipherTransformFactory","#ctor","AES256 Revision 6"],"line":498,"updatePoint":{"line":498,"column":36,"index":28403},"code":"    it(\"should accept owner password\", function () {\n      ensurePasswordCorrect(dict1, fileId1, \"654321\");\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should not accept blank password","suites":["CipherTransformFactory","#ctor","AES256 Revision 6"],"line":501,"updatePoint":{"line":501,"column":40,"index":28523},"code":"    it(\"should not accept blank password\", function () {\n      ensurePasswordNeeded(dict1, fileId1);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should not accept wrong password","suites":["CipherTransformFactory","#ctor","AES256 Revision 6"],"line":504,"updatePoint":{"line":504,"column":40,"index":28632},"code":"    it(\"should not accept wrong password\", function () {\n      ensurePasswordIncorrect(dict1, fileId1, \"wrong\");\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should accept blank password","suites":["CipherTransformFactory","#ctor","AES256 Revision 6"],"line":507,"updatePoint":{"line":507,"column":36,"index":28749},"code":"    it(\"should accept blank password\", function () {\n      ensurePasswordCorrect(dict2, fileId2);\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should encrypt and decrypt using ARCFour","suites":["CipherTransformFactory","Encrypt and decrypt"],"line":512,"updatePoint":{"line":512,"column":48,"index":28921},"code":"    it(\"should encrypt and decrypt using ARCFour\", function () {\n      dict3.CF = buildDict({\n        Identity: buildDict({\n          CFM: Name.get(\"V2\")\n        })\n      });\n      const dict = buildDict(dict3);\n      ensureEncryptDecryptIsIdentity(dict, fileId1, \"user\", \"hello world\");\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should encrypt and decrypt using AES128","suites":["CipherTransformFactory","Encrypt and decrypt"],"line":521,"updatePoint":{"line":521,"column":47,"index":29216},"code":"    it(\"should encrypt and decrypt using AES128\", function () {\n      dict3.CF = buildDict({\n        Identity: buildDict({\n          CFM: Name.get(\"AESV2\")\n        })\n      });\n      const dict = buildDict(dict3); // 0 char\n\n      ensureEncryptDecryptIsIdentity(dict, fileId1, \"user\", \"\"); // 1 char\n\n      ensureEncryptDecryptIsIdentity(dict, fileId1, \"user\", \"a\"); // 2 chars\n\n      ensureEncryptDecryptIsIdentity(dict, fileId1, \"user\", \"aa\"); // 16 chars\n\n      ensureEncryptDecryptIsIdentity(dict, fileId1, \"user\", \"aaaaaaaaaaaaaaaa\"); // 19 chars\n\n      ensureEncryptDecryptIsIdentity(dict, fileId1, \"user\", \"aaaaaaaaaaaaaaaaaaa\");\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should encrypt and decrypt using AES256","suites":["CipherTransformFactory","Encrypt and decrypt"],"line":539,"updatePoint":{"line":539,"column":47,"index":29861},"code":"    it(\"should encrypt and decrypt using AES256\", function () {\n      dict3.CF = buildDict({\n        Identity: buildDict({\n          CFM: Name.get(\"AESV3\")\n        })\n      });\n      const dict = buildDict(dict3); // 0 chars\n\n      ensureEncryptDecryptIsIdentity(dict, fileId1, \"user\", \"\"); // 4 chars\n\n      ensureEncryptDecryptIsIdentity(dict, fileId1, \"user\", \"aaaa\"); // 5 chars\n\n      ensureEncryptDecryptIsIdentity(dict, fileId1, \"user\", \"aaaaa\"); // 16 chars\n\n      ensureEncryptDecryptIsIdentity(dict, fileId1, \"user\", \"aaaaaaaaaaaaaaaa\"); // 22 chars\n\n      ensureEncryptDecryptIsIdentity(dict, fileId1, \"user\", \"aaaaaaaaaaaaaaaaaaaaaa\");\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should encrypt and have the correct length using AES128","suites":["CipherTransformFactory","Encrypt and decrypt"],"line":557,"updatePoint":{"line":557,"column":63,"index":30533},"code":"    it(\"should encrypt and have the correct length using AES128\", function () {\n      dict3.CF = buildDict({\n        Identity: buildDict({\n          CFM: Name.get(\"AESV2\")\n        })\n      });\n      const dict = buildDict(dict3); // 0 char\n\n      ensureAESEncryptedStringHasCorrectLength(dict, fileId1, \"user\", \"\"); // 1 char\n\n      ensureAESEncryptedStringHasCorrectLength(dict, fileId1, \"user\", \"a\"); // 2 chars\n\n      ensureAESEncryptedStringHasCorrectLength(dict, fileId1, \"user\", \"aa\"); // 16 chars\n\n      ensureAESEncryptedStringHasCorrectLength(dict, fileId1, \"user\", \"aaaaaaaaaaaaaaaa\"); // 19 chars\n\n      ensureAESEncryptedStringHasCorrectLength(dict, fileId1, \"user\", \"aaaaaaaaaaaaaaaaaaa\");\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"should encrypt and have the correct length using AES256","suites":["CipherTransformFactory","Encrypt and decrypt"],"line":575,"updatePoint":{"line":575,"column":63,"index":31244},"code":"    it(\"should encrypt and have the correct length using AES256\", function () {\n      dict3.CF = buildDict({\n        Identity: buildDict({\n          CFM: Name.get(\"AESV3\")\n        })\n      });\n      const dict = buildDict(dict3); // 0 char\n\n      ensureAESEncryptedStringHasCorrectLength(dict, fileId1, \"user\", \"\"); // 4 chars\n\n      ensureAESEncryptedStringHasCorrectLength(dict, fileId1, \"user\", \"aaaa\"); // 5 chars\n\n      ensureAESEncryptedStringHasCorrectLength(dict, fileId1, \"user\", \"aaaaa\"); // 16 chars\n\n      ensureAESEncryptedStringHasCorrectLength(dict, fileId1, \"user\", \"aaaaaaaaaaaaaaaa\"); // 22 chars\n\n      ensureAESEncryptedStringHasCorrectLength(dict, fileId1, \"user\", \"aaaaaaaaaaaaaaaaaaaaaa\");\n    });","file":"unit/crypto_spec.js","skipped":false,"dir":"test"},{"name":"renders to canvas with a default white background","suites":["custom canvas rendering"],"line":45,"updatePoint":{"line":45,"column":55,"index":1549},"code":"  it(\"renders to canvas with a default white background\", async function () {\n    const viewport = page.getViewport({\n      scale: 1\n    });\n    const canvasAndCtx = CanvasFactory.create(viewport.width, viewport.height);\n    const renderTask = page.render({\n      canvasContext: canvasAndCtx.context,\n      viewport\n    });\n    await renderTask.promise;\n    expect(getTopLeftPixel(canvasAndCtx.context)).toEqual({\n      r: 255,\n      g: 255,\n      b: 255,\n      a: 255\n    });\n    CanvasFactory.destroy(canvasAndCtx);\n  });","file":"unit/custom_spec.js","skipped":false,"dir":"test"},{"name":"renders to canvas with a custom background","suites":["custom canvas rendering"],"line":63,"updatePoint":{"line":63,"column":48,"index":2066},"code":"  it(\"renders to canvas with a custom background\", async function () {\n    const viewport = page.getViewport({\n      scale: 1\n    });\n    const canvasAndCtx = CanvasFactory.create(viewport.width, viewport.height);\n    const renderTask = page.render({\n      canvasContext: canvasAndCtx.context,\n      viewport,\n      background: \"rgba(255,0,0,1.0)\"\n    });\n    await renderTask.promise;\n    expect(getTopLeftPixel(canvasAndCtx.context)).toEqual({\n      r: 255,\n      g: 0,\n      b: 0,\n      a: 255\n    });\n    CanvasFactory.destroy(canvasAndCtx);\n  });","file":"unit/custom_spec.js","skipped":false,"dir":"test"},{"name":"should use given document for loading fonts (with Font Loading API)","suites":["custom ownerDocument"],"line":148,"updatePoint":{"line":148,"column":73,"index":4009},"code":"  it(\"should use given document for loading fonts (with Font Loading API)\", async function () {\n    const {\n      ownerDocument,\n      elements,\n      CanvasFactory\n    } = getMocks();\n    const getDocumentParams = buildGetDocumentParams(\"TrueType_without_cmap.pdf\", {\n      disableFontFace: false,\n      ownerDocument\n    });\n    const loadingTask = getDocument(getDocumentParams);\n    const doc = await loadingTask.promise;\n    const page = await doc.getPage(1);\n    const viewport = page.getViewport({\n      scale: 1\n    });\n    const canvasAndCtx = CanvasFactory.create(viewport.width, viewport.height);\n    await page.render({\n      canvasContext: canvasAndCtx.context,\n      viewport\n    }).promise;\n    const style = elements.find(element => element.tagName === \"style\");\n    expect(style).toBeFalsy();\n    expect(ownerDocument.fonts.size).toBeGreaterThanOrEqual(1);\n    expect(Array.from(ownerDocument.fonts).find(checkFont)).toBeTruthy();\n    await doc.destroy();\n    await loadingTask.destroy();\n    CanvasFactory.destroy(canvasAndCtx);\n    expect(ownerDocument.fonts.size).toBe(0);\n  });","file":"unit/custom_spec.js","skipped":false,"dir":"test"},{"name":"should use given document for loading fonts (with CSS rules)","suites":["custom ownerDocument"],"line":178,"updatePoint":{"line":178,"column":66,"index":5101},"code":"  it(\"should use given document for loading fonts (with CSS rules)\", async function () {\n    const {\n      ownerDocument,\n      elements,\n      CanvasFactory\n    } = getMocks();\n    ownerDocument.fonts = null;\n    const getDocumentParams = buildGetDocumentParams(\"TrueType_without_cmap.pdf\", {\n      disableFontFace: false,\n      ownerDocument\n    });\n    const loadingTask = getDocument(getDocumentParams);\n    const doc = await loadingTask.promise;\n    const page = await doc.getPage(1);\n    const viewport = page.getViewport({\n      scale: 1\n    });\n    const canvasAndCtx = CanvasFactory.create(viewport.width, viewport.height);\n    await page.render({\n      canvasContext: canvasAndCtx.context,\n      viewport\n    }).promise;\n    const style = elements.find(element => element.tagName === \"style\");\n    expect(style.sheet.cssRules.length).toBeGreaterThanOrEqual(1);\n    expect(style.sheet.cssRules.find(checkFontFaceRule)).toBeTruthy();\n    await doc.destroy();\n    await loadingTask.destroy();\n    CanvasFactory.destroy(canvasAndCtx);\n    expect(style.remove.called).toBe(true);\n  });","file":"unit/custom_spec.js","skipped":false,"dir":"test"},{"name":"should parse and create default appearance","suites":["Default appearance","parseDefaultAppearance and createDefaultAppearance"],"line":18,"updatePoint":{"line":18,"column":50,"index":878},"code":"    it(\"should parse and create default appearance\", function () {\n      const da = \"/F1 12 Tf 0.1 0.2 0.3 rg\";\n      const result = {\n        fontSize: 12,\n        fontName: \"F1\",\n        fontColor: new Uint8ClampedArray([26, 51, 76])\n      };\n      expect(parseDefaultAppearance(da)).toEqual(result);\n      expect(createDefaultAppearance(result)).toEqual(da);\n      expect(parseDefaultAppearance(\"0.1 0.2 0.3 rg /F1 12 Tf 0.3 0.2 0.1 rg /F2 13 Tf\")).toEqual({\n        fontSize: 13,\n        fontName: \"F2\",\n        fontColor: new Uint8ClampedArray([76, 51, 26])\n      });\n    });","file":"unit/default_appearance_spec.js","skipped":false,"dir":"test"},{"name":"should parse default appearance with save/restore","suites":["Default appearance","parseDefaultAppearance and createDefaultAppearance"],"line":33,"updatePoint":{"line":33,"column":57,"index":1466},"code":"    it(\"should parse default appearance with save/restore\", function () {\n      const da = \"q Q 0.1 0.2 0.3 rg /F1 12 Tf q 0.3 0.2 0.1 rg /F2 13 Tf Q\";\n      expect(parseDefaultAppearance(da)).toEqual({\n        fontSize: 12,\n        fontName: \"F1\",\n        fontColor: new Uint8ClampedArray([26, 51, 76])\n      });\n    });","file":"unit/default_appearance_spec.js","skipped":false,"dir":"test"},{"name":"should fail require(\"zlib\") unless in Node.js","suites":["SVGGraphics","paintImageXObject"],"line":116,"updatePoint":{"line":116,"column":53,"index":3668},"code":"    it('should fail require(\"zlib\") unless in Node.js', function () {\n      function testFunc() {\n        __non_webpack_require__(\"zlib\");\n      }\n\n      if (isNodeJS) {\n        // Verifies that the script loader replaces __non_webpack_require__ with\n        // require.\n        expect(testFunc.toString()).toMatch(/\\srequire\\([\"']zlib[\"']\\)/);\n        expect(testFunc).not.toThrow();\n      } else {\n        // require not defined, require('zlib') not a module, etc.\n        expect(testFunc).toThrow();\n      }\n    });","file":"unit/display_svg_spec.js","skipped":false,"dir":"test"},{"name":"should produce a reasonably small svg:image","suites":["SVGGraphics","paintImageXObject"],"line":131,"updatePoint":{"line":131,"column":51,"index":4185},"code":"    it(\"should produce a reasonably small svg:image\", async function () {\n      if (!isNodeJS) {\n        pending(\"zlib.deflateSync is not supported in non-Node environments.\");\n      }\n\n      const svgImg = await withZlib(true, getSVGImage);\n      expect(svgImg.nodeName).toBe(\"svg:image\");\n      expect(svgImg.getAttributeNS(null, \"width\")).toBe(\"200px\");\n      expect(svgImg.getAttributeNS(null, \"height\")).toBe(\"100px\");\n      const imgUrl = svgImg.getAttributeNS(XLINK_NS, \"href\"); // forceDataSchema = true, so the generated URL should be a data:-URL.\n\n      expect(imgUrl).toMatch(/^data:image\\/png;base64,/); // Test whether the generated image has a reasonable file size.\n      // I obtained a data URL of size 366 with Node 8.1.3 and zlib 1.2.11.\n      // Without zlib (uncompressed), the size of the data URL was excessive\n      // (80246).\n\n      expect(imgUrl.length).toBeLessThan(367);\n    });","file":"unit/display_svg_spec.js","skipped":false,"dir":"test"},{"name":"should be able to produce a svg:image without zlib","suites":["SVGGraphics","paintImageXObject"],"line":149,"updatePoint":{"line":149,"column":58,"index":5099},"code":"    it(\"should be able to produce a svg:image without zlib\", async function () {\n      const svgImg = await withZlib(false, getSVGImage);\n      expect(svgImg.nodeName).toBe(\"svg:image\");\n      expect(svgImg.getAttributeNS(null, \"width\")).toBe(\"200px\");\n      expect(svgImg.getAttributeNS(null, \"height\")).toBe(\"100px\");\n      const imgUrl = svgImg.getAttributeNS(XLINK_NS, \"href\");\n      expect(imgUrl).toMatch(/^data:image\\/png;base64,/); // The size of our naively generated PNG file is excessive :(\n\n      expect(imgUrl.length).toBe(80246);\n    });","file":"unit/display_svg_spec.js","skipped":false,"dir":"test"},{"name":"empty array","suites":["display_utils","binary search"],"line":28,"updatePoint":{"line":28,"column":19,"index":1125},"code":"    it(\"empty array\", function () {\n      expect(binarySearchFirstItem([], isTrue)).toEqual(0);\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"single boolean entry","suites":["display_utils","binary search"],"line":31,"updatePoint":{"line":31,"column":28,"index":1238},"code":"    it(\"single boolean entry\", function () {\n      expect(binarySearchFirstItem([false], isTrue)).toEqual(1);\n      expect(binarySearchFirstItem([true], isTrue)).toEqual(0);\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"three boolean entries","suites":["display_utils","binary search"],"line":35,"updatePoint":{"line":35,"column":29,"index":1421},"code":"    it(\"three boolean entries\", function () {\n      expect(binarySearchFirstItem([true, true, true], isTrue)).toEqual(0);\n      expect(binarySearchFirstItem([false, true, true], isTrue)).toEqual(1);\n      expect(binarySearchFirstItem([false, false, true], isTrue)).toEqual(2);\n      expect(binarySearchFirstItem([false, false, false], isTrue)).toEqual(3);\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"three numeric entries","suites":["display_utils","binary search"],"line":41,"updatePoint":{"line":41,"column":29,"index":1785},"code":"    it(\"three numeric entries\", function () {\n      expect(binarySearchFirstItem([0, 1, 2], isGreater3)).toEqual(3);\n      expect(binarySearchFirstItem([2, 3, 4], isGreater3)).toEqual(2);\n      expect(binarySearchFirstItem([4, 5, 6], isGreater3)).toEqual(0);\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"three numeric entries and a start index","suites":["display_utils","binary search"],"line":46,"updatePoint":{"line":46,"column":47,"index":2070},"code":"    it(\"three numeric entries and a start index\", function () {\n      expect(binarySearchFirstItem([0, 1, 2, 3, 4], isGreater3, 2)).toEqual(4);\n      expect(binarySearchFirstItem([2, 3, 4], isGreater3, 2)).toEqual(2);\n      expect(binarySearchFirstItem([4, 5, 6], isGreater3, 1)).toEqual(1);\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"`create` should throw an error if the dimensions are invalid","suites":["display_utils","DOMCanvasFactory"],"line":60,"updatePoint":{"line":60,"column":68,"index":2610},"code":"    it(\"`create` should throw an error if the dimensions are invalid\", function () {\n      // Invalid width.\n      expect(function () {\n        return canvasFactory.create(-1, 1);\n      }).toThrow(new Error(\"Invalid canvas size\")); // Invalid height.\n\n      expect(function () {\n        return canvasFactory.create(1, -1);\n      }).toThrow(new Error(\"Invalid canvas size\"));\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"`create` should return a canvas if the dimensions are valid","suites":["display_utils","DOMCanvasFactory"],"line":70,"updatePoint":{"line":70,"column":67,"index":2992},"code":"    it(\"`create` should return a canvas if the dimensions are valid\", function () {\n      if (isNodeJS) {\n        pending(\"Document is not supported in Node.js.\");\n      }\n\n      const {\n        canvas,\n        context\n      } = canvasFactory.create(20, 40);\n      expect(canvas instanceof HTMLCanvasElement).toBe(true);\n      expect(context instanceof CanvasRenderingContext2D).toBe(true);\n      expect(canvas.width).toBe(20);\n      expect(canvas.height).toBe(40);\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"`reset` should throw an error if no canvas is provided","suites":["display_utils","DOMCanvasFactory"],"line":84,"updatePoint":{"line":84,"column":62,"index":3461},"code":"    it(\"`reset` should throw an error if no canvas is provided\", function () {\n      const canvasAndContext = {\n        canvas: null,\n        context: null\n      };\n      expect(function () {\n        return canvasFactory.reset(canvasAndContext, 20, 40);\n      }).toThrow(new Error(\"Canvas is not specified\"));\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"`reset` should throw an error if the dimensions are invalid","suites":["display_utils","DOMCanvasFactory"],"line":93,"updatePoint":{"line":93,"column":67,"index":3784},"code":"    it(\"`reset` should throw an error if the dimensions are invalid\", function () {\n      const canvasAndContext = {\n        canvas: \"foo\",\n        context: \"bar\"\n      }; // Invalid width.\n\n      expect(function () {\n        return canvasFactory.reset(canvasAndContext, -1, 1);\n      }).toThrow(new Error(\"Invalid canvas size\")); // Invalid height.\n\n      expect(function () {\n        return canvasFactory.reset(canvasAndContext, 1, -1);\n      }).toThrow(new Error(\"Invalid canvas size\"));\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"`reset` should alter the canvas/context if the dimensions are valid","suites":["display_utils","DOMCanvasFactory"],"line":107,"updatePoint":{"line":107,"column":75,"index":4291},"code":"    it(\"`reset` should alter the canvas/context if the dimensions are valid\", function () {\n      if (isNodeJS) {\n        pending(\"Document is not supported in Node.js.\");\n      }\n\n      const canvasAndContext = canvasFactory.create(20, 40);\n      canvasFactory.reset(canvasAndContext, 60, 80);\n      const {\n        canvas,\n        context\n      } = canvasAndContext;\n      expect(canvas instanceof HTMLCanvasElement).toBe(true);\n      expect(context instanceof CanvasRenderingContext2D).toBe(true);\n      expect(canvas.width).toBe(60);\n      expect(canvas.height).toBe(80);\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"`destroy` should throw an error if no canvas is provided","suites":["display_utils","DOMCanvasFactory"],"line":123,"updatePoint":{"line":123,"column":64,"index":4864},"code":"    it(\"`destroy` should throw an error if no canvas is provided\", function () {\n      expect(function () {\n        return canvasFactory.destroy({});\n      }).toThrow(new Error(\"Canvas is not specified\"));\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"`destroy` should clear the canvas/context","suites":["display_utils","DOMCanvasFactory"],"line":128,"updatePoint":{"line":128,"column":49,"index":5063},"code":"    it(\"`destroy` should clear the canvas/context\", function () {\n      if (isNodeJS) {\n        pending(\"Document is not supported in Node.js.\");\n      }\n\n      const canvasAndContext = canvasFactory.create(20, 40);\n      canvasFactory.destroy(canvasAndContext);\n      const {\n        canvas,\n        context\n      } = canvasAndContext;\n      expect(canvas).toBe(null);\n      expect(context).toBe(null);\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"`create` should throw an error if the dimensions are invalid","suites":["display_utils","DOMSVGFactory"],"line":151,"updatePoint":{"line":151,"column":68,"index":5698},"code":"    it(\"`create` should throw an error if the dimensions are invalid\", function () {\n      // Invalid width.\n      expect(function () {\n        return svgFactory.create(-1, 0);\n      }).toThrow(new Error(\"Invalid SVG dimensions\")); // Invalid height.\n\n      expect(function () {\n        return svgFactory.create(0, -1);\n      }).toThrow(new Error(\"Invalid SVG dimensions\"));\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"`create` should return an SVG element if the dimensions are valid","suites":["display_utils","DOMSVGFactory"],"line":161,"updatePoint":{"line":161,"column":73,"index":6086},"code":"    it(\"`create` should return an SVG element if the dimensions are valid\", function () {\n      if (isNodeJS) {\n        pending(\"Document is not supported in Node.js.\");\n      }\n\n      const svg = svgFactory.create(20, 40);\n      expect(svg instanceof SVGSVGElement).toBe(true);\n      expect(svg.getAttribute(\"version\")).toBe(\"1.1\");\n      expect(svg.getAttribute(\"width\")).toBe(\"20px\");\n      expect(svg.getAttribute(\"height\")).toBe(\"40px\");\n      expect(svg.getAttribute(\"preserveAspectRatio\")).toBe(\"none\");\n      expect(svg.getAttribute(\"viewBox\")).toBe(\"0 0 20 40\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"`createElement` should throw an error if the type is not a string","suites":["display_utils","DOMSVGFactory"],"line":174,"updatePoint":{"line":174,"column":73,"index":6666},"code":"    it(\"`createElement` should throw an error if the type is not a string\", function () {\n      expect(function () {\n        return svgFactory.createElement(true);\n      }).toThrow(new Error(\"Invalid SVG element type\"));\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"`createElement` should return an SVG element if the type is valid","suites":["display_utils","DOMSVGFactory"],"line":179,"updatePoint":{"line":179,"column":73,"index":6895},"code":"    it(\"`createElement` should return an SVG element if the type is valid\", function () {\n      if (isNodeJS) {\n        pending(\"Document is not supported in Node.js.\");\n      }\n\n      const svg = svgFactory.createElement(\"svg:rect\");\n      expect(svg instanceof SVGRectElement).toBe(true);\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"should get the filename from an absolute URL","suites":["display_utils","getFilenameFromUrl"],"line":189,"updatePoint":{"line":189,"column":52,"index":7226},"code":"    it(\"should get the filename from an absolute URL\", function () {\n      const url = \"https://server.org/filename.pdf\";\n      expect(getFilenameFromUrl(url)).toEqual(\"filename.pdf\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"should get the filename from a relative URL","suites":["display_utils","getFilenameFromUrl"],"line":193,"updatePoint":{"line":193,"column":51,"index":7418},"code":"    it(\"should get the filename from a relative URL\", function () {\n      const url = \"../../filename.pdf\";\n      expect(getFilenameFromUrl(url)).toEqual(\"filename.pdf\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"should get the filename from a URL with an anchor","suites":["display_utils","getFilenameFromUrl"],"line":197,"updatePoint":{"line":197,"column":57,"index":7603},"code":"    it(\"should get the filename from a URL with an anchor\", function () {\n      const url = \"https://server.org/filename.pdf#foo\";\n      expect(getFilenameFromUrl(url)).toEqual(\"filename.pdf\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"should get the filename from a URL with query parameters","suites":["display_utils","getFilenameFromUrl"],"line":201,"updatePoint":{"line":201,"column":64,"index":7812},"code":"    it(\"should get the filename from a URL with query parameters\", function () {\n      const url = \"https://server.org/filename.pdf?foo=bar\";\n      expect(getFilenameFromUrl(url)).toEqual(\"filename.pdf\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets PDF filename","suites":["display_utils","getPdfFilenameFromUrl"],"line":207,"updatePoint":{"line":207,"column":25,"index":8042},"code":"    it(\"gets PDF filename\", function () {\n      // Relative URL\n      expect(getPdfFilenameFromUrl(\"/pdfs/file1.pdf\")).toEqual(\"file1.pdf\"); // Absolute URL\n\n      expect(getPdfFilenameFromUrl(\"http://www.example.com/pdfs/file2.pdf\")).toEqual(\"file2.pdf\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets fallback filename","suites":["display_utils","getPdfFilenameFromUrl"],"line":213,"updatePoint":{"line":213,"column":30,"index":8312},"code":"    it(\"gets fallback filename\", function () {\n      // Relative URL\n      expect(getPdfFilenameFromUrl(\"/pdfs/file1.txt\")).toEqual(\"document.pdf\"); // Absolute URL\n\n      expect(getPdfFilenameFromUrl(\"http://www.example.com/pdfs/file2.txt\")).toEqual(\"document.pdf\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets custom fallback filename","suites":["display_utils","getPdfFilenameFromUrl"],"line":219,"updatePoint":{"line":219,"column":37,"index":8595},"code":"    it(\"gets custom fallback filename\", function () {\n      // Relative URL\n      expect(getPdfFilenameFromUrl(\"/pdfs/file1.txt\", \"qwerty1.pdf\")).toEqual(\"qwerty1.pdf\"); // Absolute URL\n\n      expect(getPdfFilenameFromUrl(\"http://www.example.com/pdfs/file2.txt\", \"qwerty2.pdf\")).toEqual(\"qwerty2.pdf\"); // An empty string should be a valid custom fallback filename.\n\n      expect(getPdfFilenameFromUrl(\"/pdfs/file3.txt\", \"\")).toEqual(\"\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets fallback filename when url is not a string","suites":["display_utils","getPdfFilenameFromUrl"],"line":227,"updatePoint":{"line":227,"column":55,"index":9060},"code":"    it(\"gets fallback filename when url is not a string\", function () {\n      expect(getPdfFilenameFromUrl(null)).toEqual(\"document.pdf\");\n      expect(getPdfFilenameFromUrl(null, \"file.pdf\")).toEqual(\"file.pdf\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets PDF filename from URL containing leading/trailing whitespace","suites":["display_utils","getPdfFilenameFromUrl"],"line":231,"updatePoint":{"line":231,"column":73,"index":9300},"code":"    it(\"gets PDF filename from URL containing leading/trailing whitespace\", function () {\n      // Relative URL\n      expect(getPdfFilenameFromUrl(\"   /pdfs/file1.pdf   \")).toEqual(\"file1.pdf\"); // Absolute URL\n\n      expect(getPdfFilenameFromUrl(\"   http://www.example.com/pdfs/file2.pdf   \")).toEqual(\"file2.pdf\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets PDF filename from query string","suites":["display_utils","getPdfFilenameFromUrl"],"line":237,"updatePoint":{"line":237,"column":43,"index":9595},"code":"    it(\"gets PDF filename from query string\", function () {\n      // Relative URL\n      expect(getPdfFilenameFromUrl(\"/pdfs/pdfs.html?name=file1.pdf\")).toEqual(\"file1.pdf\"); // Absolute URL\n\n      expect(getPdfFilenameFromUrl(\"http://www.example.com/pdfs/pdf.html?file2.pdf\")).toEqual(\"file2.pdf\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets PDF filename from hash string","suites":["display_utils","getPdfFilenameFromUrl"],"line":243,"updatePoint":{"line":243,"column":42,"index":9901},"code":"    it(\"gets PDF filename from hash string\", function () {\n      // Relative URL\n      expect(getPdfFilenameFromUrl(\"/pdfs/pdfs.html#name=file1.pdf\")).toEqual(\"file1.pdf\"); // Absolute URL\n\n      expect(getPdfFilenameFromUrl(\"http://www.example.com/pdfs/pdf.html#file2.pdf\")).toEqual(\"file2.pdf\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets correct PDF filename when multiple ones are present","suites":["display_utils","getPdfFilenameFromUrl"],"line":249,"updatePoint":{"line":249,"column":64,"index":10229},"code":"    it(\"gets correct PDF filename when multiple ones are present\", function () {\n      // Relative URL\n      expect(getPdfFilenameFromUrl(\"/pdfs/file1.pdf?name=file.pdf\")).toEqual(\"file1.pdf\"); // Absolute URL\n\n      expect(getPdfFilenameFromUrl(\"http://www.example.com/pdfs/file2.pdf#file.pdf\")).toEqual(\"file2.pdf\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets PDF filename from URI-encoded data","suites":["display_utils","getPdfFilenameFromUrl"],"line":255,"updatePoint":{"line":255,"column":47,"index":10539},"code":"    it(\"gets PDF filename from URI-encoded data\", function () {\n      const encodedUrl = encodeURIComponent(\"http://www.example.com/pdfs/file1.pdf\");\n      expect(getPdfFilenameFromUrl(encodedUrl)).toEqual(\"file1.pdf\");\n      const encodedUrlWithQuery = encodeURIComponent(\"http://www.example.com/pdfs/file.txt?file2.pdf\");\n      expect(getPdfFilenameFromUrl(encodedUrlWithQuery)).toEqual(\"file2.pdf\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets PDF filename from data mistaken for URI-encoded","suites":["display_utils","getPdfFilenameFromUrl"],"line":261,"updatePoint":{"line":261,"column":60,"index":10963},"code":"    it(\"gets PDF filename from data mistaken for URI-encoded\", function () {\n      expect(getPdfFilenameFromUrl(\"/pdfs/%AA.pdf\")).toEqual(\"%AA.pdf\");\n      expect(getPdfFilenameFromUrl(\"/pdfs/%2F.pdf\")).toEqual(\"%2F.pdf\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets PDF filename from (some) standard protocols","suites":["display_utils","getPdfFilenameFromUrl"],"line":265,"updatePoint":{"line":265,"column":56,"index":11190},"code":"    it(\"gets PDF filename from (some) standard protocols\", function () {\n      // HTTP\n      expect(getPdfFilenameFromUrl(\"http://www.example.com/file1.pdf\")).toEqual(\"file1.pdf\"); // HTTPS\n\n      expect(getPdfFilenameFromUrl(\"https://www.example.com/file2.pdf\")).toEqual(\"file2.pdf\"); // File\n\n      expect(getPdfFilenameFromUrl(\"file:///path/to/files/file3.pdf\")).toEqual(\"file3.pdf\"); // FTP\n\n      expect(getPdfFilenameFromUrl(\"ftp://www.example.com/file4.pdf\")).toEqual(\"file4.pdf\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets PDF filename from query string appended to \"blob:\" URL","suites":["display_utils","getPdfFilenameFromUrl"],"line":275,"updatePoint":{"line":275,"column":67,"index":11698},"code":"    it('gets PDF filename from query string appended to \"blob:\" URL', function () {\n      if (isNodeJS) {\n        pending(\"Blob in not supported in Node.js.\");\n      }\n\n      const typedArray = new Uint8Array([1, 2, 3, 4, 5]);\n      const blobUrl = URL.createObjectURL(new Blob([typedArray], {\n        type: \"application/pdf\"\n      })); // Sanity check to ensure that a \"blob:\" URL was returned.\n\n      expect(blobUrl.startsWith(\"blob:\")).toEqual(true);\n      expect(getPdfFilenameFromUrl(blobUrl + \"?file.pdf\")).toEqual(\"file.pdf\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets fallback filename from query string appended to \"data:\" URL","suites":["display_utils","getPdfFilenameFromUrl"],"line":288,"updatePoint":{"line":288,"column":72,"index":12245},"code":"    it('gets fallback filename from query string appended to \"data:\" URL', function () {\n      const typedArray = new Uint8Array([1, 2, 3, 4, 5]),\n            str = bytesToString(typedArray);\n      const dataUrl = `data:application/pdf;base64,${btoa(str)}`; // Sanity check to ensure that a \"data:\" URL was returned.\n\n      expect(dataUrl.startsWith(\"data:\")).toEqual(true);\n      expect(getPdfFilenameFromUrl(dataUrl + \"?file1.pdf\")).toEqual(\"document.pdf\"); // Should correctly detect a \"data:\" URL with leading whitespace.\n\n      expect(getPdfFilenameFromUrl(\"     \" + dataUrl + \"?file2.pdf\")).toEqual(\"document.pdf\");\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles invalid Fetch URLs","suites":["display_utils","isValidFetchUrl"],"line":300,"updatePoint":{"line":300,"column":34,"index":12887},"code":"    it(\"handles invalid Fetch URLs\", function () {\n      expect(isValidFetchUrl(null)).toEqual(false);\n      expect(isValidFetchUrl(100)).toEqual(false);\n      expect(isValidFetchUrl(\"foo\")).toEqual(false);\n      expect(isValidFetchUrl(\"/foo\", 100)).toEqual(false);\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles relative Fetch URLs","suites":["display_utils","isValidFetchUrl"],"line":306,"updatePoint":{"line":306,"column":35,"index":13162},"code":"    it(\"handles relative Fetch URLs\", function () {\n      expect(isValidFetchUrl(\"/foo\", \"file://www.example.com\")).toEqual(false);\n      expect(isValidFetchUrl(\"/foo\", \"http://www.example.com\")).toEqual(true);\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles unsupported Fetch protocols","suites":["display_utils","isValidFetchUrl"],"line":310,"updatePoint":{"line":310,"column":43,"index":13389},"code":"    it(\"handles unsupported Fetch protocols\", function () {\n      expect(isValidFetchUrl(\"file://www.example.com\")).toEqual(false);\n      expect(isValidFetchUrl(\"ftp://www.example.com\")).toEqual(false);\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles supported Fetch protocols","suites":["display_utils","isValidFetchUrl"],"line":314,"updatePoint":{"line":314,"column":41,"index":13598},"code":"    it(\"handles supported Fetch protocols\", function () {\n      expect(isValidFetchUrl(\"http://www.example.com\")).toEqual(true);\n      expect(isValidFetchUrl(\"https://www.example.com\")).toEqual(true);\n    });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"converts PDF date strings to JavaScript `Date` objects","suites":["display_utils","PDFDateString","toDateObject"],"line":321,"updatePoint":{"line":321,"column":64,"index":13921},"code":"      it(\"converts PDF date strings to JavaScript `Date` objects\", function () {\n        const expectations = {\n          undefined: null,\n          null: null,\n          42: null,\n          2019: null,\n          D2019: null,\n          \"D:\": null,\n          \"D:201\": null,\n          \"D:2019\": new Date(Date.UTC(2019, 0, 1, 0, 0, 0)),\n          \"D:20190\": new Date(Date.UTC(2019, 0, 1, 0, 0, 0)),\n          \"D:201900\": new Date(Date.UTC(2019, 0, 1, 0, 0, 0)),\n          \"D:201913\": new Date(Date.UTC(2019, 0, 1, 0, 0, 0)),\n          \"D:201902\": new Date(Date.UTC(2019, 1, 1, 0, 0, 0)),\n          \"D:2019020\": new Date(Date.UTC(2019, 1, 1, 0, 0, 0)),\n          \"D:20190200\": new Date(Date.UTC(2019, 1, 1, 0, 0, 0)),\n          \"D:20190232\": new Date(Date.UTC(2019, 1, 1, 0, 0, 0)),\n          \"D:20190203\": new Date(Date.UTC(2019, 1, 3, 0, 0, 0)),\n          // Invalid dates like the 31th of April are handled by JavaScript:\n          \"D:20190431\": new Date(Date.UTC(2019, 4, 1, 0, 0, 0)),\n          \"D:201902030\": new Date(Date.UTC(2019, 1, 3, 0, 0, 0)),\n          \"D:2019020300\": new Date(Date.UTC(2019, 1, 3, 0, 0, 0)),\n          \"D:2019020324\": new Date(Date.UTC(2019, 1, 3, 0, 0, 0)),\n          \"D:2019020304\": new Date(Date.UTC(2019, 1, 3, 4, 0, 0)),\n          \"D:20190203040\": new Date(Date.UTC(2019, 1, 3, 4, 0, 0)),\n          \"D:201902030400\": new Date(Date.UTC(2019, 1, 3, 4, 0, 0)),\n          \"D:201902030460\": new Date(Date.UTC(2019, 1, 3, 4, 0, 0)),\n          \"D:201902030405\": new Date(Date.UTC(2019, 1, 3, 4, 5, 0)),\n          \"D:2019020304050\": new Date(Date.UTC(2019, 1, 3, 4, 5, 0)),\n          \"D:20190203040500\": new Date(Date.UTC(2019, 1, 3, 4, 5, 0)),\n          \"D:20190203040560\": new Date(Date.UTC(2019, 1, 3, 4, 5, 0)),\n          \"D:20190203040506\": new Date(Date.UTC(2019, 1, 3, 4, 5, 6)),\n          \"D:20190203040506F\": new Date(Date.UTC(2019, 1, 3, 4, 5, 6)),\n          \"D:20190203040506Z\": new Date(Date.UTC(2019, 1, 3, 4, 5, 6)),\n          \"D:20190203040506-\": new Date(Date.UTC(2019, 1, 3, 4, 5, 6)),\n          \"D:20190203040506+\": new Date(Date.UTC(2019, 1, 3, 4, 5, 6)),\n          \"D:20190203040506+'\": new Date(Date.UTC(2019, 1, 3, 4, 5, 6)),\n          \"D:20190203040506+0\": new Date(Date.UTC(2019, 1, 3, 4, 5, 6)),\n          \"D:20190203040506+01\": new Date(Date.UTC(2019, 1, 3, 3, 5, 6)),\n          \"D:20190203040506+00'\": new Date(Date.UTC(2019, 1, 3, 4, 5, 6)),\n          \"D:20190203040506+24'\": new Date(Date.UTC(2019, 1, 3, 4, 5, 6)),\n          \"D:20190203040506+01'\": new Date(Date.UTC(2019, 1, 3, 3, 5, 6)),\n          \"D:20190203040506+01'0\": new Date(Date.UTC(2019, 1, 3, 3, 5, 6)),\n          \"D:20190203040506+01'00\": new Date(Date.UTC(2019, 1, 3, 3, 5, 6)),\n          \"D:20190203040506+01'60\": new Date(Date.UTC(2019, 1, 3, 3, 5, 6)),\n          \"D:20190203040506+0102\": new Date(Date.UTC(2019, 1, 3, 3, 3, 6)),\n          \"D:20190203040506+01'02\": new Date(Date.UTC(2019, 1, 3, 3, 3, 6)),\n          \"D:20190203040506+01'02'\": new Date(Date.UTC(2019, 1, 3, 3, 3, 6)),\n          // Offset hour and minute that result in a day change:\n          \"D:20190203040506+05'07\": new Date(Date.UTC(2019, 1, 2, 22, 58, 6))\n        };\n\n        for (const [input, expectation] of Object.entries(expectations)) {\n          const result = PDFDateString.toDateObject(input);\n\n          if (result) {\n            expect(result.getTime()).toEqual(expectation.getTime());\n          } else {\n            expect(result).toEqual(expectation);\n          }\n        }\n      });","file":"unit/display_utils_spec.js","skipped":false,"dir":"test"},{"name":"should create correct objId/fontId using the idFactory","suites":["document","Page"],"line":21,"updatePoint":{"line":21,"column":62,"index":970},"code":"    it(\"should create correct objId/fontId using the idFactory\", function () {\n      const idFactory1 = createIdFactory(\n      /* pageIndex = */\n      0);\n      const idFactory2 = createIdFactory(\n      /* pageIndex = */\n      1);\n      expect(idFactory1.createObjId()).toEqual(\"p0_1\");\n      expect(idFactory1.createObjId()).toEqual(\"p0_2\");\n      expect(idFactory1.createFontId()).toEqual(\"f1\");\n      expect(idFactory1.createFontId()).toEqual(\"f2\");\n      expect(idFactory1.getDocId()).toEqual(\"g_d0\");\n      expect(idFactory2.createObjId()).toEqual(\"p1_1\");\n      expect(idFactory2.createObjId()).toEqual(\"p1_2\");\n      expect(idFactory2.createFontId()).toEqual(\"f1\");\n      expect(idFactory2.createFontId()).toEqual(\"f2\");\n      expect(idFactory2.getDocId()).toEqual(\"g_d0\");\n      expect(idFactory1.createObjId()).toEqual(\"p0_3\");\n      expect(idFactory1.createObjId()).toEqual(\"p0_4\");\n      expect(idFactory1.createFontId()).toEqual(\"f3\");\n      expect(idFactory1.createFontId()).toEqual(\"f4\");\n      expect(idFactory1.getDocId()).toEqual(\"g_d0\");\n    });","file":"unit/document_spec.js","skipped":false,"dir":"test"},{"name":"should get form info when no form data is present","suites":["document","PDFDocument"],"line":82,"updatePoint":{"line":82,"column":57,"index":2920},"code":"    it(\"should get form info when no form data is present\", function () {\n      const pdfDocument = getDocument(null);\n      expect(pdfDocument.formInfo).toEqual({\n        hasAcroForm: false,\n        hasSignatures: false,\n        hasXfa: false,\n        hasFields: false\n      });\n    });","file":"unit/document_spec.js","skipped":false,"dir":"test"},{"name":"should get form info when XFA is present","suites":["document","PDFDocument"],"line":91,"updatePoint":{"line":91,"column":48,"index":3199},"code":"    it(\"should get form info when XFA is present\", function () {\n      const acroForm = new Dict(); // The `XFA` entry can only be a non-empty array or stream.\n\n      acroForm.set(\"XFA\", []);\n      let pdfDocument = getDocument(acroForm);\n      expect(pdfDocument.formInfo).toEqual({\n        hasAcroForm: false,\n        hasSignatures: false,\n        hasXfa: false,\n        hasFields: false\n      });\n      acroForm.set(\"XFA\", [\"foo\", \"bar\"]);\n      pdfDocument = getDocument(acroForm);\n      expect(pdfDocument.formInfo).toEqual({\n        hasAcroForm: false,\n        hasSignatures: false,\n        hasXfa: true,\n        hasFields: false\n      });\n      acroForm.set(\"XFA\", new StringStream(\"\"));\n      pdfDocument = getDocument(acroForm);\n      expect(pdfDocument.formInfo).toEqual({\n        hasAcroForm: false,\n        hasSignatures: false,\n        hasXfa: false,\n        hasFields: false\n      });\n      acroForm.set(\"XFA\", new StringStream(\"non-empty\"));\n      pdfDocument = getDocument(acroForm);\n      expect(pdfDocument.formInfo).toEqual({\n        hasAcroForm: false,\n        hasSignatures: false,\n        hasXfa: true,\n        hasFields: false\n      });\n    });","file":"unit/document_spec.js","skipped":false,"dir":"test"},{"name":"should get form info when AcroForm is present","suites":["document","PDFDocument"],"line":127,"updatePoint":{"line":127,"column":53,"index":4372},"code":"    it(\"should get form info when AcroForm is present\", function () {\n      const acroForm = new Dict(); // The `Fields` entry can only be a non-empty array.\n\n      acroForm.set(\"Fields\", []);\n      let pdfDocument = getDocument(acroForm);\n      expect(pdfDocument.formInfo).toEqual({\n        hasAcroForm: false,\n        hasSignatures: false,\n        hasXfa: false,\n        hasFields: false\n      });\n      acroForm.set(\"Fields\", [\"foo\", \"bar\"]);\n      pdfDocument = getDocument(acroForm);\n      expect(pdfDocument.formInfo).toEqual({\n        hasAcroForm: true,\n        hasSignatures: false,\n        hasXfa: false,\n        hasFields: true\n      }); // If the first bit of the `SigFlags` entry is set and the `Fields` array\n      // only contains document signatures, then there is no AcroForm data.\n\n      acroForm.set(\"Fields\", [\"foo\", \"bar\"]);\n      acroForm.set(\"SigFlags\", 2);\n      pdfDocument = getDocument(acroForm);\n      expect(pdfDocument.formInfo).toEqual({\n        hasAcroForm: true,\n        hasSignatures: false,\n        hasXfa: false,\n        hasFields: true\n      });\n      const annotationDict = new Dict();\n      annotationDict.set(\"FT\", Name.get(\"Sig\"));\n      annotationDict.set(\"Rect\", [0, 0, 0, 0]);\n      const annotationRef = Ref.get(11, 0);\n      const kidsDict = new Dict();\n      kidsDict.set(\"Kids\", [annotationRef]);\n      const kidsRef = Ref.get(10, 0);\n      const xref = new XRefMock([{\n        ref: annotationRef,\n        data: annotationDict\n      }, {\n        ref: kidsRef,\n        data: kidsDict\n      }]);\n      acroForm.set(\"Fields\", [kidsRef]);\n      acroForm.set(\"SigFlags\", 3);\n      pdfDocument = getDocument(acroForm, xref);\n      expect(pdfDocument.formInfo).toEqual({\n        hasAcroForm: false,\n        hasSignatures: true,\n        hasXfa: false,\n        hasFields: true\n      });\n    });","file":"unit/document_spec.js","skipped":false,"dir":"test"},{"name":"should get calculation order array or null","suites":["document","PDFDocument"],"line":181,"updatePoint":{"line":181,"column":50,"index":6203},"code":"    it(\"should get calculation order array or null\", function () {\n      const acroForm = new Dict();\n      let pdfDocument = getDocument(acroForm);\n      expect(pdfDocument.calculationOrderIds).toEqual(null);\n      acroForm.set(\"CO\", [Ref.get(1, 0), Ref.get(2, 0), Ref.get(3, 0)]);\n      pdfDocument = getDocument(acroForm);\n      expect(pdfDocument.calculationOrderIds).toEqual([\"1R\", \"2R\", \"3R\"]);\n      acroForm.set(\"CO\", []);\n      pdfDocument = getDocument(acroForm);\n      expect(pdfDocument.calculationOrderIds).toEqual(null);\n      acroForm.set(\"CO\", [\"1\", \"2\"]);\n      pdfDocument = getDocument(acroForm);\n      expect(pdfDocument.calculationOrderIds).toEqual(null);\n      acroForm.set(\"CO\", [\"1\", Ref.get(1, 0), \"2\"]);\n      pdfDocument = getDocument(acroForm);\n      expect(pdfDocument.calculationOrderIds).toEqual([\"1R\"]);\n    });","file":"unit/document_spec.js","skipped":false,"dir":"test"},{"name":"should get field objects array or null","suites":["document","PDFDocument"],"line":198,"updatePoint":{"line":198,"column":46,"index":7043},"code":"    it(\"should get field objects array or null\", async function () {\n      const acroForm = new Dict();\n      let pdfDocument = getDocument(acroForm);\n      let fields = await pdfDocument.fieldObjects;\n      expect(fields).toEqual(null);\n      acroForm.set(\"Fields\", []);\n      pdfDocument = getDocument(acroForm);\n      fields = await pdfDocument.fieldObjects;\n      expect(fields).toEqual(null);\n      const kid1Ref = Ref.get(314, 0);\n      const kid11Ref = Ref.get(159, 0);\n      const kid2Ref = Ref.get(265, 0);\n      const kid2BisRef = Ref.get(266, 0);\n      const parentRef = Ref.get(358, 0);\n      const allFields = Object.create(null);\n\n      for (const name of [\"parent\", \"kid1\", \"kid2\", \"kid11\"]) {\n        const buttonWidgetDict = new Dict();\n        buttonWidgetDict.set(\"Type\", Name.get(\"Annot\"));\n        buttonWidgetDict.set(\"Subtype\", Name.get(\"Widget\"));\n        buttonWidgetDict.set(\"FT\", Name.get(\"Btn\"));\n        buttonWidgetDict.set(\"T\", name);\n        allFields[name] = buttonWidgetDict;\n      }\n\n      allFields.kid1.set(\"Kids\", [kid11Ref]);\n      allFields.parent.set(\"Kids\", [kid1Ref, kid2Ref, kid2BisRef]);\n      const xref = new XRefMock([{\n        ref: parentRef,\n        data: allFields.parent\n      }, {\n        ref: kid1Ref,\n        data: allFields.kid1\n      }, {\n        ref: kid11Ref,\n        data: allFields.kid11\n      }, {\n        ref: kid2Ref,\n        data: allFields.kid2\n      }, {\n        ref: kid2BisRef,\n        data: allFields.kid2\n      }]);\n      acroForm.set(\"Fields\", [parentRef]);\n      pdfDocument = getDocument(acroForm, xref);\n      fields = await pdfDocument.fieldObjects;\n\n      for (const [name, objs] of Object.entries(fields)) {\n        fields[name] = objs.map(obj => obj.id);\n      }\n\n      expect(fields[\"parent.kid1\"]).toEqual([\"314R\"]);\n      expect(fields[\"parent.kid1.kid11\"]).toEqual([\"159R\"]);\n      expect(fields[\"parent.kid2\"]).toEqual([\"265R\", \"266R\"]);\n      expect(fields.parent).toEqual([\"358R\"]);\n    });","file":"unit/document_spec.js","skipped":false,"dir":"test"},{"name":"should check if fields have any actions","suites":["document","PDFDocument"],"line":254,"updatePoint":{"line":254,"column":47,"index":9021},"code":"    it(\"should check if fields have any actions\", async function () {\n      const acroForm = new Dict();\n      let pdfDocument = getDocument(acroForm);\n      let hasJSActions = await pdfDocument.hasJSActions;\n      expect(hasJSActions).toEqual(false);\n      acroForm.set(\"Fields\", []);\n      pdfDocument = getDocument(acroForm);\n      hasJSActions = await pdfDocument.hasJSActions;\n      expect(hasJSActions).toEqual(false);\n      const kid1Ref = Ref.get(314, 0);\n      const kid11Ref = Ref.get(159, 0);\n      const kid2Ref = Ref.get(265, 0);\n      const parentRef = Ref.get(358, 0);\n      const allFields = Object.create(null);\n\n      for (const name of [\"parent\", \"kid1\", \"kid2\", \"kid11\"]) {\n        const buttonWidgetDict = new Dict();\n        buttonWidgetDict.set(\"Type\", Name.get(\"Annot\"));\n        buttonWidgetDict.set(\"Subtype\", Name.get(\"Widget\"));\n        buttonWidgetDict.set(\"FT\", Name.get(\"Btn\"));\n        buttonWidgetDict.set(\"T\", name);\n        allFields[name] = buttonWidgetDict;\n      }\n\n      allFields.kid1.set(\"Kids\", [kid11Ref]);\n      allFields.parent.set(\"Kids\", [kid1Ref, kid2Ref]);\n      const xref = new XRefMock([{\n        ref: parentRef,\n        data: allFields.parent\n      }, {\n        ref: kid1Ref,\n        data: allFields.kid1\n      }, {\n        ref: kid11Ref,\n        data: allFields.kid11\n      }, {\n        ref: kid2Ref,\n        data: allFields.kid2\n      }]);\n      acroForm.set(\"Fields\", [parentRef]);\n      pdfDocument = getDocument(acroForm, xref);\n      hasJSActions = await pdfDocument.hasJSActions;\n      expect(hasJSActions).toEqual(false);\n      const JS = Name.get(\"JavaScript\");\n      const additionalActionsDict = new Dict();\n      const eDict = new Dict();\n      eDict.set(\"JS\", \"hello()\");\n      eDict.set(\"S\", JS);\n      additionalActionsDict.set(\"E\", eDict);\n      allFields.kid2.set(\"AA\", additionalActionsDict);\n      pdfDocument = getDocument(acroForm, xref);\n      hasJSActions = await pdfDocument.hasJSActions;\n      expect(hasJSActions).toEqual(true);\n    });","file":"unit/document_spec.js","skipped":false,"dir":"test"},{"name":"should check undo/redo","suites":["editor","Command Manager"],"line":19,"updatePoint":{"line":19,"column":30,"index":835},"code":"    it(\"should check undo/redo\", function () {\n      const manager = new CommandManager(4);\n      let x = 0;\n\n      const makeDoUndo = n => ({\n        cmd: () => x += n,\n        undo: () => x -= n\n      });\n\n      manager.add({ ...makeDoUndo(1),\n        mustExec: true\n      });\n      expect(x).toEqual(1);\n      manager.add({ ...makeDoUndo(2),\n        mustExec: true\n      });\n      expect(x).toEqual(3);\n      manager.add({ ...makeDoUndo(3),\n        mustExec: true\n      });\n      expect(x).toEqual(6);\n      manager.undo();\n      expect(x).toEqual(3);\n      manager.undo();\n      expect(x).toEqual(1);\n      manager.undo();\n      expect(x).toEqual(0);\n      manager.undo();\n      expect(x).toEqual(0);\n      manager.redo();\n      expect(x).toEqual(1);\n      manager.redo();\n      expect(x).toEqual(3);\n      manager.redo();\n      expect(x).toEqual(6);\n      manager.redo();\n      expect(x).toEqual(6);\n      manager.undo();\n      expect(x).toEqual(3);\n      manager.redo();\n      expect(x).toEqual(6);\n    });","file":"unit/editor_spec.js","skipped":false,"dir":"test"},{"name":"should hit the limit of the manager","suites":["editor","Command Manager"],"line":62,"updatePoint":{"line":62,"column":41,"index":1865},"code":"  it(\"should hit the limit of the manager\", function () {\n    const manager = new CommandManager(3);\n    let x = 0;\n\n    const makeDoUndo = n => ({\n      cmd: () => x += n,\n      undo: () => x -= n\n    });\n\n    manager.add({ ...makeDoUndo(1),\n      mustExec: true\n    }); // 1\n\n    manager.add({ ...makeDoUndo(2),\n      mustExec: true\n    }); // 3\n\n    manager.add({ ...makeDoUndo(3),\n      mustExec: true\n    }); // 6\n\n    manager.add({ ...makeDoUndo(4),\n      mustExec: true\n    }); // 10\n\n    expect(x).toEqual(10);\n    manager.undo();\n    manager.undo();\n    expect(x).toEqual(3);\n    manager.undo();\n    expect(x).toEqual(1);\n    manager.undo();\n    expect(x).toEqual(1);\n    manager.redo();\n    manager.redo();\n    expect(x).toEqual(6);\n    manager.add({ ...makeDoUndo(5),\n      mustExec: true\n    });\n    expect(x).toEqual(11);\n  });","file":"unit/editor_spec.js","skipped":false,"dir":"test"},{"name":"should return a function","suites":["editor","fitCurve"],"line":104,"updatePoint":{"line":104,"column":32,"index":2734},"code":"    it(\"should return a function\", function () {\n      expect(typeof fitCurve).toEqual(\"function\");\n    });","file":"unit/editor_spec.js","skipped":false,"dir":"test"},{"name":"should compute an Array of bezier curves","suites":["editor","fitCurve"],"line":107,"updatePoint":{"line":107,"column":48,"index":2858},"code":"    it(\"should compute an Array of bezier curves\", function () {\n      const bezier = fitCurve([[1, 2], [4, 5]], 30, null);\n      expect(bezier).toEqual([[[1, 2], [2, 3], [3, 4], [4, 5]]]);\n    });","file":"unit/editor_spec.js","skipped":false,"dir":"test"},{"name":"fetches a valid array for known encoding names","suites":["encodings","getEncoding"],"line":18,"updatePoint":{"line":18,"column":54,"index":789},"code":"    it(\"fetches a valid array for known encoding names\", function () {\n      const knownEncodingNames = [\"ExpertEncoding\", \"MacExpertEncoding\", \"MacRomanEncoding\", \"StandardEncoding\", \"SymbolSetEncoding\", \"WinAnsiEncoding\", \"ZapfDingbatsEncoding\"];\n\n      for (const knownEncodingName of knownEncodingNames) {\n        const encoding = getEncoding(knownEncodingName);\n        expect(Array.isArray(encoding)).toEqual(true);\n        expect(encoding.length).toEqual(256);\n\n        for (const item of encoding) {\n          expect(typeof item).toEqual(\"string\");\n        }\n      }\n    });","file":"unit/encodings_spec.js","skipped":false,"dir":"test"},{"name":"fetches `null` for unknown encoding names","suites":["encodings","getEncoding"],"line":31,"updatePoint":{"line":31,"column":49,"index":1367},"code":"    it(\"fetches `null` for unknown encoding names\", function () {\n      expect(getEncoding(\"FooBarEncoding\")).toEqual(null);\n    });","file":"unit/encodings_spec.js","skipped":false,"dir":"test"},{"name":"should reject unknown operations","suites":["evaluator","splitCombinedOperations"],"line":73,"updatePoint":{"line":73,"column":40,"index":2078},"code":"    it(\"should reject unknown operations\", async function () {\n      const stream = new StringStream(\"fTT\");\n      const result = await runOperatorListCheck(partialEvaluator, stream, new ResourcesMock());\n      expect(!!result.fnArray && !!result.argsArray).toEqual(true);\n      expect(result.fnArray.length).toEqual(1);\n      expect(result.fnArray[0]).toEqual(OPS.fill);\n      expect(result.argsArray[0]).toEqual(null);\n    });","file":"unit/evaluator_spec.js","skipped":false,"dir":"test"},{"name":"should handle one operation","suites":["evaluator","splitCombinedOperations"],"line":81,"updatePoint":{"line":81,"column":35,"index":2502},"code":"    it(\"should handle one operation\", async function () {\n      const stream = new StringStream(\"Q\");\n      const result = await runOperatorListCheck(partialEvaluator, stream, new ResourcesMock());\n      expect(!!result.fnArray && !!result.argsArray).toEqual(true);\n      expect(result.fnArray.length).toEqual(1);\n      expect(result.fnArray[0]).toEqual(OPS.restore);\n    });","file":"unit/evaluator_spec.js","skipped":false,"dir":"test"},{"name":"should handle two glued operations","suites":["evaluator","splitCombinedOperations"],"line":88,"updatePoint":{"line":88,"column":42,"index":2885},"code":"    it(\"should handle two glued operations\", async function () {\n      const imgDict = new Dict();\n      imgDict.set(\"Subtype\", Name.get(\"Image\"));\n      imgDict.set(\"Width\", 1);\n      imgDict.set(\"Height\", 1);\n      const imgStream = new Stream([0]);\n      imgStream.dict = imgDict;\n      const xObject = new Dict();\n      xObject.set(\"Res1\", imgStream);\n      const resources = new ResourcesMock();\n      resources.XObject = xObject;\n      const stream = new StringStream(\"/Res1 DoQ\");\n      const result = await runOperatorListCheck(partialEvaluator, stream, resources);\n      expect(result.fnArray.length).toEqual(3);\n      expect(result.fnArray[0]).toEqual(OPS.dependency);\n      expect(result.fnArray[1]).toEqual(OPS.paintImageXObject);\n      expect(result.fnArray[2]).toEqual(OPS.restore);\n      expect(result.argsArray.length).toEqual(3);\n      expect(result.argsArray[0]).toEqual([\"img_p0_1\"]);\n      expect(result.argsArray[1]).toEqual([\"img_p0_1\", 1, 1]);\n      expect(result.argsArray[2]).toEqual(null);\n    });","file":"unit/evaluator_spec.js","skipped":false,"dir":"test"},{"name":"should handle three glued operations","suites":["evaluator","splitCombinedOperations"],"line":110,"updatePoint":{"line":110,"column":44,"index":3911},"code":"    it(\"should handle three glued operations\", async function () {\n      const stream = new StringStream(\"fff\");\n      const result = await runOperatorListCheck(partialEvaluator, stream, new ResourcesMock());\n      expect(!!result.fnArray && !!result.argsArray).toEqual(true);\n      expect(result.fnArray.length).toEqual(3);\n      expect(result.fnArray[0]).toEqual(OPS.fill);\n      expect(result.fnArray[1]).toEqual(OPS.fill);\n      expect(result.fnArray[2]).toEqual(OPS.fill);\n    });","file":"unit/evaluator_spec.js","skipped":false,"dir":"test"},{"name":"should handle three glued operations #2","suites":["evaluator","splitCombinedOperations"],"line":119,"updatePoint":{"line":119,"column":47,"index":4400},"code":"    it(\"should handle three glued operations #2\", async function () {\n      const resources = new ResourcesMock();\n      resources.Res1 = {};\n      const stream = new StringStream(\"B*Bf*\");\n      const result = await runOperatorListCheck(partialEvaluator, stream, resources);\n      expect(!!result.fnArray && !!result.argsArray).toEqual(true);\n      expect(result.fnArray.length).toEqual(3);\n      expect(result.fnArray[0]).toEqual(OPS.eoFillStroke);\n      expect(result.fnArray[1]).toEqual(OPS.fillStroke);\n      expect(result.fnArray[2]).toEqual(OPS.eoFill);\n    });","file":"unit/evaluator_spec.js","skipped":false,"dir":"test"},{"name":"should handle glued operations and operands","suites":["evaluator","splitCombinedOperations"],"line":130,"updatePoint":{"line":130,"column":51,"index":4973},"code":"    it(\"should handle glued operations and operands\", async function () {\n      const stream = new StringStream(\"f5 Ts\");\n      const result = await runOperatorListCheck(partialEvaluator, stream, new ResourcesMock());\n      expect(!!result.fnArray && !!result.argsArray).toEqual(true);\n      expect(result.fnArray.length).toEqual(2);\n      expect(result.fnArray[0]).toEqual(OPS.fill);\n      expect(result.fnArray[1]).toEqual(OPS.setTextRise);\n      expect(result.argsArray.length).toEqual(2);\n      expect(result.argsArray[1].length).toEqual(1);\n      expect(result.argsArray[1][0]).toEqual(5);\n    });","file":"unit/evaluator_spec.js","skipped":false,"dir":"test"},{"name":"should handle glued operations and literals","suites":["evaluator","splitCombinedOperations"],"line":141,"updatePoint":{"line":141,"column":51,"index":5576},"code":"    it(\"should handle glued operations and literals\", async function () {\n      const stream = new StringStream(\"trueifalserinulln\");\n      const result = await runOperatorListCheck(partialEvaluator, stream, new ResourcesMock());\n      expect(!!result.fnArray && !!result.argsArray).toEqual(true);\n      expect(result.fnArray.length).toEqual(3);\n      expect(result.fnArray[0]).toEqual(OPS.setFlatness);\n      expect(result.fnArray[1]).toEqual(OPS.setRenderingIntent);\n      expect(result.fnArray[2]).toEqual(OPS.endPath);\n      expect(result.argsArray.length).toEqual(3);\n      expect(result.argsArray[0].length).toEqual(1);\n      expect(result.argsArray[0][0]).toEqual(true);\n      expect(result.argsArray[1].length).toEqual(1);\n      expect(result.argsArray[1][0]).toEqual(false);\n      expect(result.argsArray[2]).toEqual(null);\n    });","file":"unit/evaluator_spec.js","skipped":false,"dir":"test"},{"name":"should execute if correct number of arguments","suites":["evaluator","validateNumberOfArgs"],"line":158,"updatePoint":{"line":158,"column":53,"index":6474},"code":"    it(\"should execute if correct number of arguments\", async function () {\n      const stream = new StringStream(\"5 1 d0\");\n      const result = await runOperatorListCheck(partialEvaluator, stream, new ResourcesMock());\n      expect(result.argsArray[0][0]).toEqual(5);\n      expect(result.argsArray[0][1]).toEqual(1);\n      expect(result.fnArray[0]).toEqual(OPS.setCharWidth);\n    });","file":"unit/evaluator_spec.js","skipped":false,"dir":"test"},{"name":"should execute if too many arguments","suites":["evaluator","validateNumberOfArgs"],"line":165,"updatePoint":{"line":165,"column":44,"index":6851},"code":"    it(\"should execute if too many arguments\", async function () {\n      const stream = new StringStream(\"5 1 4 d0\");\n      const result = await runOperatorListCheck(partialEvaluator, stream, new ResourcesMock());\n      expect(result.argsArray[0][0]).toEqual(1);\n      expect(result.argsArray[0][1]).toEqual(4);\n      expect(result.fnArray[0]).toEqual(OPS.setCharWidth);\n    });","file":"unit/evaluator_spec.js","skipped":false,"dir":"test"},{"name":"should execute if nested commands","suites":["evaluator","validateNumberOfArgs"],"line":172,"updatePoint":{"line":172,"column":41,"index":7227},"code":"    it(\"should execute if nested commands\", async function () {\n      const gState = new Dict();\n      gState.set(\"LW\", 2);\n      gState.set(\"CA\", 0.5);\n      const extGState = new Dict();\n      extGState.set(\"GS2\", gState);\n      const resources = new ResourcesMock();\n      resources.ExtGState = extGState;\n      const stream = new StringStream(\"/F2 /GS2 gs 5.711 Tf\");\n      const result = await runOperatorListCheck(partialEvaluator, stream, resources);\n      expect(result.fnArray.length).toEqual(3);\n      expect(result.fnArray[0]).toEqual(OPS.setGState);\n      expect(result.fnArray[1]).toEqual(OPS.dependency);\n      expect(result.fnArray[2]).toEqual(OPS.setFont);\n      expect(result.argsArray.length).toEqual(3);\n      expect(result.argsArray[0]).toEqual([[[\"LW\", 2], [\"CA\", 0.5]]]);\n      expect(result.argsArray[1]).toEqual([\"g_font_error\"]);\n      expect(result.argsArray[2]).toEqual([\"g_font_error\", 5.711]);\n    });","file":"unit/evaluator_spec.js","skipped":false,"dir":"test"},{"name":"should skip if too few arguments","suites":["evaluator","validateNumberOfArgs"],"line":191,"updatePoint":{"line":191,"column":40,"index":8157},"code":"    it(\"should skip if too few arguments\", async function () {\n      const stream = new StringStream(\"5 d0\");\n      const result = await runOperatorListCheck(partialEvaluator, stream, new ResourcesMock());\n      expect(result.argsArray).toEqual([]);\n      expect(result.fnArray).toEqual([]);\n    });","file":"unit/evaluator_spec.js","skipped":false,"dir":"test"},{"name":"should close opened saves","suites":["evaluator","validateNumberOfArgs"],"line":218,"updatePoint":{"line":218,"column":33,"index":9483},"code":"    it(\"should close opened saves\", async function () {\n      const stream = new StringStream(\"qq\");\n      const result = await runOperatorListCheck(partialEvaluator, stream, new ResourcesMock());\n      expect(!!result.fnArray && !!result.argsArray).toEqual(true);\n      expect(result.fnArray.length).toEqual(4);\n      expect(result.fnArray[0]).toEqual(OPS.save);\n      expect(result.fnArray[1]).toEqual(OPS.save);\n      expect(result.fnArray[2]).toEqual(OPS.restore);\n      expect(result.fnArray[3]).toEqual(OPS.restore);\n    });","file":"unit/evaluator_spec.js","skipped":false,"dir":"test"},{"name":"should error on paintXObject if name is missing","suites":["evaluator","validateNumberOfArgs"],"line":228,"updatePoint":{"line":228,"column":55,"index":10036},"code":"    it(\"should error on paintXObject if name is missing\", async function () {\n      const stream = new StringStream(\"/ Do\");\n\n      try {\n        await runOperatorListCheck(partialEvaluator, stream, new ResourcesMock()); // Shouldn't get here.\n\n        expect(false).toEqual(true);\n      } catch (reason) {\n        expect(reason instanceof FormatError).toEqual(true);\n        expect(reason.message).toEqual(\"XObject should be a stream\");\n      }\n    });","file":"unit/evaluator_spec.js","skipped":false,"dir":"test"},{"name":"should skip paintXObject if subtype is PS","suites":["evaluator","validateNumberOfArgs"],"line":240,"updatePoint":{"line":240,"column":49,"index":10484},"code":"    it(\"should skip paintXObject if subtype is PS\", async function () {\n      const xobjStreamDict = new Dict();\n      xobjStreamDict.set(\"Subtype\", Name.get(\"PS\"));\n      const xobjStream = new Stream([], 0, 0, xobjStreamDict);\n      const xobjs = new Dict();\n      xobjs.set(\"Res1\", xobjStream);\n      const resources = new Dict();\n      resources.set(\"XObject\", xobjs);\n      const stream = new StringStream(\"/Res1 Do\");\n      const result = await runOperatorListCheck(partialEvaluator, stream, resources);\n      expect(result.argsArray).toEqual([]);\n      expect(result.fnArray).toEqual([]);\n    });","file":"unit/evaluator_spec.js","skipped":false,"dir":"test"},{"name":"should abort operator list parsing","suites":["evaluator","thread control"],"line":255,"updatePoint":{"line":255,"column":42,"index":11130},"code":"    it(\"should abort operator list parsing\", async function () {\n      const stream = new StringStream(\"qqQQ\");\n      const resources = new ResourcesMock();\n      const result = new OperatorList();\n      const task = new WorkerTask(\"OperatorListAbort\");\n      task.terminate();\n\n      try {\n        await partialEvaluator.getOperatorList({\n          stream,\n          task,\n          resources,\n          operatorList: result\n        }); // Shouldn't get here.\n\n        expect(false).toEqual(true);\n      } catch (_) {\n        expect(!!result.fnArray && !!result.argsArray).toEqual(true);\n        expect(result.fnArray.length).toEqual(0);\n      }\n    });","file":"unit/evaluator_spec.js","skipped":false,"dir":"test"},{"name":"should abort text content parsing","suites":["evaluator","thread control"],"line":276,"updatePoint":{"line":276,"column":41,"index":11784},"code":"    it(\"should abort text content parsing\", async function () {\n      const resources = new ResourcesMock();\n      const stream = new StringStream(\"qqQQ\");\n      const task = new WorkerTask(\"TextContentAbort\");\n      task.terminate();\n\n      try {\n        await partialEvaluator.getTextContent({\n          stream,\n          task,\n          resources\n        }); // Shouldn't get here.\n\n        expect(false).toEqual(true);\n      } catch (_) {\n        expect(true).toEqual(true);\n      }\n    });","file":"unit/evaluator_spec.js","skipped":false,"dir":"test"},{"name":"should get correct total length after flushing","suites":["evaluator","operator list"],"line":301,"updatePoint":{"line":301,"column":54,"index":12394},"code":"    it(\"should get correct total length after flushing\", function () {\n      const operatorList = new OperatorList(null, new StreamSinkMock());\n      operatorList.addOp(OPS.save, null);\n      operatorList.addOp(OPS.restore, null);\n      expect(operatorList.totalLength).toEqual(2);\n      expect(operatorList.length).toEqual(2);\n      operatorList.flush();\n      expect(operatorList.totalLength).toEqual(2);\n      expect(operatorList.length).toEqual(0);\n    });","file":"unit/evaluator_spec.js","skipped":false,"dir":"test"},{"name":"dispatch event","suites":["event_utils","EventBus"],"line":19,"updatePoint":{"line":19,"column":22,"index":840},"code":"    it(\"dispatch event\", function () {\n      const eventBus = new EventBus();\n      let count = 0;\n      eventBus.on(\"test\", function (evt) {\n        expect(evt).toEqual(undefined);\n        count++;\n      });\n      eventBus.dispatch(\"test\");\n      expect(count).toEqual(1);\n    });","file":"unit/event_utils_spec.js","skipped":false,"dir":"test"},{"name":"dispatch event with arguments","suites":["event_utils","EventBus"],"line":29,"updatePoint":{"line":29,"column":37,"index":1137},"code":"    it(\"dispatch event with arguments\", function () {\n      const eventBus = new EventBus();\n      let count = 0;\n      eventBus.on(\"test\", function (evt) {\n        expect(evt).toEqual({\n          abc: 123\n        });\n        count++;\n      });\n      eventBus.dispatch(\"test\", {\n        abc: 123\n      });\n      expect(count).toEqual(1);\n    });","file":"unit/event_utils_spec.js","skipped":false,"dir":"test"},{"name":"dispatch different event","suites":["event_utils","EventBus"],"line":43,"updatePoint":{"line":43,"column":32,"index":1478},"code":"    it(\"dispatch different event\", function () {\n      const eventBus = new EventBus();\n      let count = 0;\n      eventBus.on(\"test\", function () {\n        count++;\n      });\n      eventBus.dispatch(\"nottest\");\n      expect(count).toEqual(0);\n    });","file":"unit/event_utils_spec.js","skipped":false,"dir":"test"},{"name":"dispatch event multiple times","suites":["event_utils","EventBus"],"line":52,"updatePoint":{"line":52,"column":37,"index":1735},"code":"    it(\"dispatch event multiple times\", function () {\n      const eventBus = new EventBus();\n      let count = 0;\n      eventBus.dispatch(\"test\");\n      eventBus.on(\"test\", function () {\n        count++;\n      });\n      eventBus.dispatch(\"test\");\n      eventBus.dispatch(\"test\");\n      expect(count).toEqual(2);\n    });","file":"unit/event_utils_spec.js","skipped":false,"dir":"test"},{"name":"dispatch event to multiple handlers","suites":["event_utils","EventBus"],"line":63,"updatePoint":{"line":63,"column":43,"index":2061},"code":"    it(\"dispatch event to multiple handlers\", function () {\n      const eventBus = new EventBus();\n      let count = 0;\n      eventBus.on(\"test\", function () {\n        count++;\n      });\n      eventBus.on(\"test\", function () {\n        count++;\n      });\n      eventBus.dispatch(\"test\");\n      expect(count).toEqual(2);\n    });","file":"unit/event_utils_spec.js","skipped":false,"dir":"test"},{"name":"dispatch to detached","suites":["event_utils","EventBus"],"line":75,"updatePoint":{"line":75,"column":28,"index":2373},"code":"    it(\"dispatch to detached\", function () {\n      const eventBus = new EventBus();\n      let count = 0;\n\n      const listener = function () {\n        count++;\n      };\n\n      eventBus.on(\"test\", listener);\n      eventBus.dispatch(\"test\");\n      eventBus.off(\"test\", listener);\n      eventBus.dispatch(\"test\");\n      expect(count).toEqual(1);\n    });","file":"unit/event_utils_spec.js","skipped":false,"dir":"test"},{"name":"dispatch to wrong detached","suites":["event_utils","EventBus"],"line":89,"updatePoint":{"line":89,"column":34,"index":2730},"code":"    it(\"dispatch to wrong detached\", function () {\n      const eventBus = new EventBus();\n      let count = 0;\n      eventBus.on(\"test\", function () {\n        count++;\n      });\n      eventBus.dispatch(\"test\");\n      eventBus.off(\"test\", function () {\n        count++;\n      });\n      eventBus.dispatch(\"test\");\n      expect(count).toEqual(2);\n    });","file":"unit/event_utils_spec.js","skipped":false,"dir":"test"},{"name":"dispatch to detached during handling","suites":["event_utils","EventBus"],"line":102,"updatePoint":{"line":102,"column":44,"index":3092},"code":"    it(\"dispatch to detached during handling\", function () {\n      const eventBus = new EventBus();\n      let count = 0;\n\n      const listener1 = function () {\n        eventBus.off(\"test\", listener2);\n        count++;\n      };\n\n      const listener2 = function () {\n        eventBus.off(\"test\", listener1);\n        count++;\n      };\n\n      eventBus.on(\"test\", listener1);\n      eventBus.on(\"test\", listener2);\n      eventBus.dispatch(\"test\");\n      eventBus.dispatch(\"test\");\n      expect(count).toEqual(2);\n    });","file":"unit/event_utils_spec.js","skipped":false,"dir":"test"},{"name":"dispatch event to handlers with/without 'once' option","suites":["event_utils","EventBus"],"line":122,"updatePoint":{"line":122,"column":61,"index":3625},"code":"    it(\"dispatch event to handlers with/without 'once' option\", function () {\n      const eventBus = new EventBus();\n      let multipleCount = 0,\n          onceCount = 0;\n      eventBus.on(\"test\", function () {\n        multipleCount++;\n      });\n      eventBus.on(\"test\", function () {\n        onceCount++;\n      }, {\n        once: true\n      });\n      eventBus.dispatch(\"test\");\n      eventBus.dispatch(\"test\");\n      eventBus.dispatch(\"test\");\n      expect(multipleCount).toEqual(3);\n      expect(onceCount).toEqual(1);\n    });","file":"unit/event_utils_spec.js","skipped":false,"dir":"test"},{"name":"should not re-dispatch to DOM","suites":["event_utils","EventBus"],"line":140,"updatePoint":{"line":140,"column":37,"index":4131},"code":"    it(\"should not re-dispatch to DOM\", async function () {\n      if (isNodeJS) {\n        pending(\"Document is not supported in Node.js.\");\n      }\n\n      const eventBus = new EventBus();\n      let count = 0;\n      eventBus.on(\"test\", function (evt) {\n        expect(evt).toEqual(undefined);\n        count++;\n      });\n\n      function domEventListener() {\n        // Shouldn't get here.\n        expect(false).toEqual(true);\n      }\n\n      document.addEventListener(\"test\", domEventListener);\n      eventBus.dispatch(\"test\");\n      await Promise.resolve();\n      expect(count).toEqual(1);\n      document.removeEventListener(\"test\", domEventListener);\n    });","file":"unit/event_utils_spec.js","skipped":false,"dir":"test"},{"name":"should reject invalid parameters","suites":["event_utils","waitOnEventOrTimeout"],"line":172,"updatePoint":{"line":172,"column":40,"index":4992},"code":"    it(\"should reject invalid parameters\", async function () {\n      const invalidTarget = waitOnEventOrTimeout({\n        target: \"window\",\n        name: \"DOMContentLoaded\"\n      }).then(function () {\n        // Shouldn't get here.\n        expect(false).toEqual(true);\n      }, function (reason) {\n        expect(reason instanceof Error).toEqual(true);\n      });\n      const invalidName = waitOnEventOrTimeout({\n        target: eventBus,\n        name: \"\"\n      }).then(function () {\n        // Shouldn't get here.\n        expect(false).toEqual(true);\n      }, function (reason) {\n        expect(reason instanceof Error).toEqual(true);\n      });\n      const invalidDelay = waitOnEventOrTimeout({\n        target: eventBus,\n        name: \"pagerendered\",\n        delay: -1000\n      }).then(function () {\n        // Shouldn't get here.\n        expect(false).toEqual(true);\n      }, function (reason) {\n        expect(reason instanceof Error).toEqual(true);\n      });\n      await Promise.all([invalidTarget, invalidName, invalidDelay]);\n    });","file":"unit/event_utils_spec.js","skipped":false,"dir":"test"},{"name":"should resolve on event, using the DOM","suites":["event_utils","waitOnEventOrTimeout"],"line":203,"updatePoint":{"line":203,"column":46,"index":6037},"code":"    it(\"should resolve on event, using the DOM\", async function () {\n      if (isNodeJS) {\n        pending(\"Document is not supported in Node.js.\");\n      }\n\n      const button = document.createElement(\"button\");\n      const buttonClicked = waitOnEventOrTimeout({\n        target: button,\n        name: \"click\",\n        delay: 10000\n      }); // Immediately dispatch the expected event.\n\n      button.click();\n      const type = await buttonClicked;\n      expect(type).toEqual(WaitOnType.EVENT);\n    });","file":"unit/event_utils_spec.js","skipped":false,"dir":"test"},{"name":"should resolve on timeout, using the DOM","suites":["event_utils","waitOnEventOrTimeout"],"line":219,"updatePoint":{"line":219,"column":48,"index":6542},"code":"    it(\"should resolve on timeout, using the DOM\", async function () {\n      if (isNodeJS) {\n        pending(\"Document is not supported in Node.js.\");\n      }\n\n      const button = document.createElement(\"button\");\n      const buttonClicked = waitOnEventOrTimeout({\n        target: button,\n        name: \"click\",\n        delay: 10\n      }); // Do *not* dispatch the event, and wait for the timeout.\n\n      const type = await buttonClicked;\n      expect(type).toEqual(WaitOnType.TIMEOUT);\n    });","file":"unit/event_utils_spec.js","skipped":false,"dir":"test"},{"name":"should resolve on event, using the EventBus","suites":["event_utils","waitOnEventOrTimeout"],"line":234,"updatePoint":{"line":234,"column":51,"index":7041},"code":"    it(\"should resolve on event, using the EventBus\", async function () {\n      const pageRendered = waitOnEventOrTimeout({\n        target: eventBus,\n        name: \"pagerendered\",\n        delay: 10000\n      }); // Immediately dispatch the expected event.\n\n      eventBus.dispatch(\"pagerendered\");\n      const type = await pageRendered;\n      expect(type).toEqual(WaitOnType.EVENT);\n    });","file":"unit/event_utils_spec.js","skipped":false,"dir":"test"},{"name":"should resolve on timeout, using the EventBus","suites":["event_utils","waitOnEventOrTimeout"],"line":245,"updatePoint":{"line":245,"column":53,"index":7433},"code":"    it(\"should resolve on timeout, using the EventBus\", async function () {\n      const pageRendered = waitOnEventOrTimeout({\n        target: eventBus,\n        name: \"pagerendered\",\n        delay: 10\n      }); // Do *not* dispatch the event, and wait for the timeout.\n\n      const type = await pageRendered;\n      expect(type).toEqual(WaitOnType.TIMEOUT);\n    });","file":"unit/event_utils_spec.js","skipped":false,"dir":"test"},{"name":"read with streaming","suites":["fetch_stream"],"line":20,"updatePoint":{"line":20,"column":25,"index":895},"code":"  it(\"read with streaming\", async function () {\n    const stream = new PDFFetchStream({\n      url: pdfUrl,\n      disableStream: false,\n      disableRange: true\n    });\n    const fullReader = stream.getFullReader();\n    let isStreamingSupported, isRangeSupported;\n    const promise = fullReader.headersReady.then(function () {\n      isStreamingSupported = fullReader.isStreamingSupported;\n      isRangeSupported = fullReader.isRangeSupported;\n    });\n    let len = 0;\n\n    const read = function () {\n      return fullReader.read().then(function (result) {\n        if (result.done) {\n          return undefined;\n        }\n\n        len += result.value.byteLength;\n        return read();\n      });\n    };\n\n    await Promise.all([read(), promise]);\n    expect(len).toEqual(pdfLength);\n    expect(isStreamingSupported).toEqual(true);\n    expect(isRangeSupported).toEqual(false);\n  });","file":"unit/fetch_stream_spec.js","skipped":false,"dir":"test"},{"name":"read ranges with streaming","suites":["fetch_stream"],"line":50,"updatePoint":{"line":50,"column":32,"index":1781},"code":"  it(\"read ranges with streaming\", async function () {\n    const rangeSize = 32768;\n    const stream = new PDFFetchStream({\n      url: pdfUrl,\n      rangeChunkSize: rangeSize,\n      disableStream: false,\n      disableRange: false\n    });\n    const fullReader = stream.getFullReader();\n    let isStreamingSupported, isRangeSupported, fullReaderCancelled;\n    const promise = fullReader.headersReady.then(function () {\n      isStreamingSupported = fullReader.isStreamingSupported;\n      isRangeSupported = fullReader.isRangeSupported; // We shall be able to close full reader without any issue.\n\n      fullReader.cancel(new AbortException(\"Don't need fullReader.\"));\n      fullReaderCancelled = true;\n    });\n    const tailSize = pdfLength % rangeSize || rangeSize;\n    const rangeReader1 = stream.getRangeReader(pdfLength - tailSize - rangeSize, pdfLength - tailSize);\n    const rangeReader2 = stream.getRangeReader(pdfLength - tailSize, pdfLength);\n    const result1 = {\n      value: 0\n    },\n          result2 = {\n      value: 0\n    };\n\n    const read = function (reader, lenResult) {\n      return reader.read().then(function (result) {\n        if (result.done) {\n          return undefined;\n        }\n\n        lenResult.value += result.value.byteLength;\n        return read(reader, lenResult);\n      });\n    };\n\n    await Promise.all([read(rangeReader1, result1), read(rangeReader2, result2), promise]);\n    expect(isStreamingSupported).toEqual(true);\n    expect(isRangeSupported).toEqual(true);\n    expect(fullReaderCancelled).toEqual(true);\n    expect(result1.value).toEqual(rangeSize);\n    expect(result2.value).toEqual(tailSize);\n  });","file":"unit/fetch_stream_spec.js","skipped":false,"dir":"test"},{"name":"parses empty programs","suites":["function","PostScriptParser"],"line":26,"updatePoint":{"line":26,"column":29,"index":1119},"code":"    it(\"parses empty programs\", function () {\n      const output = parse(\"{}\");\n      expect(output.length).toEqual(0);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"parses positive numbers","suites":["function","PostScriptParser"],"line":30,"updatePoint":{"line":30,"column":31,"index":1249},"code":"    it(\"parses positive numbers\", function () {\n      const number = 999;\n      const program = parse(\"{ \" + number + \" }\");\n      const expectedProgram = [number];\n      expect(program).toEqual(expectedProgram);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"parses negative numbers","suites":["function","PostScriptParser"],"line":36,"updatePoint":{"line":36,"column":31,"index":1470},"code":"    it(\"parses negative numbers\", function () {\n      const number = -999;\n      const program = parse(\"{ \" + number + \" }\");\n      const expectedProgram = [number];\n      expect(program).toEqual(expectedProgram);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"parses negative floats","suites":["function","PostScriptParser"],"line":42,"updatePoint":{"line":42,"column":30,"index":1691},"code":"    it(\"parses negative floats\", function () {\n      const number = 3.3;\n      const program = parse(\"{ \" + number + \" }\");\n      const expectedProgram = [number];\n      expect(program).toEqual(expectedProgram);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"parses operators","suites":["function","PostScriptParser"],"line":48,"updatePoint":{"line":48,"column":24,"index":1905},"code":"    it(\"parses operators\", function () {\n      const program = parse(\"{ sub }\");\n      const expectedProgram = [\"sub\"];\n      expect(program).toEqual(expectedProgram);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"parses if statements","suites":["function","PostScriptParser"],"line":53,"updatePoint":{"line":53,"column":28,"index":2085},"code":"    it(\"parses if statements\", function () {\n      const program = parse(\"{ { 99 } if }\");\n      const expectedProgram = [3, \"jz\", 99];\n      expect(program).toEqual(expectedProgram);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"parses ifelse statements","suites":["function","PostScriptParser"],"line":58,"updatePoint":{"line":58,"column":32,"index":2281},"code":"    it(\"parses ifelse statements\", function () {\n      const program = parse(\"{ { 99 } { 44 } ifelse }\");\n      const expectedProgram = [5, \"jz\", 99, 6, \"j\", 44];\n      expect(program).toEqual(expectedProgram);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"handles missing brackets","suites":["function","PostScriptParser"],"line":63,"updatePoint":{"line":63,"column":32,"index":2500},"code":"    it(\"handles missing brackets\", function () {\n      expect(function () {\n        parse(\"{\");\n      }).toThrow(new Error(\"Unexpected symbol: found undefined expected 1.\"));\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"handles junk after the end","suites":["function","PostScriptParser"],"line":68,"updatePoint":{"line":68,"column":34,"index":2685},"code":"    it(\"handles junk after the end\", function () {\n      const number = 3.3;\n      const program = parse(\"{ \" + number + \" }#\");\n      const expectedProgram = [number];\n      expect(program).toEqual(expectedProgram);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"pushes stack","suites":["function","PostScriptEvaluator"],"line":85,"updatePoint":{"line":85,"column":20,"index":3263},"code":"    it(\"pushes stack\", function () {\n      const stack = evaluate(\"{ 99 }\");\n      const expectedStack = [99];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"handles if with true","suites":["function","PostScriptEvaluator"],"line":90,"updatePoint":{"line":90,"column":28,"index":3434},"code":"    it(\"handles if with true\", function () {\n      const stack = evaluate(\"{ 1 {99} if }\");\n      const expectedStack = [99];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"handles if with false","suites":["function","PostScriptEvaluator"],"line":95,"updatePoint":{"line":95,"column":29,"index":3613},"code":"    it(\"handles if with false\", function () {\n      const stack = evaluate(\"{ 0 {99} if }\");\n      const expectedStack = [];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"handles ifelse with true","suites":["function","PostScriptEvaluator"],"line":100,"updatePoint":{"line":100,"column":32,"index":3793},"code":"    it(\"handles ifelse with true\", function () {\n      const stack = evaluate(\"{ 1 {99} {77} ifelse }\");\n      const expectedStack = [99];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"handles ifelse with false","suites":["function","PostScriptEvaluator"],"line":105,"updatePoint":{"line":105,"column":33,"index":3985},"code":"    it(\"handles ifelse with false\", function () {\n      const stack = evaluate(\"{ 0 {99} {77} ifelse }\");\n      const expectedStack = [77];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"handles nested if","suites":["function","PostScriptEvaluator"],"line":110,"updatePoint":{"line":110,"column":25,"index":4169},"code":"    it(\"handles nested if\", function () {\n      const stack = evaluate(\"{ 1 {1 {77} if} if }\");\n      const expectedStack = [77];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"abs","suites":["function","PostScriptEvaluator"],"line":115,"updatePoint":{"line":115,"column":11,"index":4337},"code":"    it(\"abs\", function () {\n      const stack = evaluate(\"{ -2 abs }\");\n      const expectedStack = [2];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"adds","suites":["function","PostScriptEvaluator"],"line":120,"updatePoint":{"line":120,"column":12,"index":4495},"code":"    it(\"adds\", function () {\n      const stack = evaluate(\"{ 1 2 add }\");\n      const expectedStack = [3];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"boolean and","suites":["function","PostScriptEvaluator"],"line":125,"updatePoint":{"line":125,"column":19,"index":4661},"code":"    it(\"boolean and\", function () {\n      const stack = evaluate(\"{ true false and }\");\n      const expectedStack = [false];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"bitwise and","suites":["function","PostScriptEvaluator"],"line":130,"updatePoint":{"line":130,"column":19,"index":4838},"code":"    it(\"bitwise and\", function () {\n      const stack = evaluate(\"{ 254 1 and }\");\n      const expectedStack = [254 & 1];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"calculates the inverse tangent of a number","suites":["function","PostScriptEvaluator"],"line":135,"updatePoint":{"line":135,"column":50,"index":5043},"code":"    it(\"calculates the inverse tangent of a number\", function () {\n      const stack = evaluate(\"{ 90 atan }\");\n      const expectedStack = [Math.atan(90)];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"handles bitshifting ","suites":["function","PostScriptEvaluator"],"line":140,"updatePoint":{"line":140,"column":28,"index":5230},"code":"    it(\"handles bitshifting \", function () {\n      const stack = evaluate(\"{ 50 2 bitshift }\");\n      const expectedStack = [200];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"calculates the ceiling value","suites":["function","PostScriptEvaluator"],"line":145,"updatePoint":{"line":145,"column":36,"index":5421},"code":"    it(\"calculates the ceiling value\", function () {\n      const stack = evaluate(\"{ 9.9 ceiling }\");\n      const expectedStack = [10];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"copies","suites":["function","PostScriptEvaluator"],"line":150,"updatePoint":{"line":150,"column":14,"index":5587},"code":"    it(\"copies\", function () {\n      const stack = evaluate(\"{ 99 98 2 copy }\");\n      const expectedStack = [99, 98, 99, 98];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"calculates the cosine of a number","suites":["function","PostScriptEvaluator"],"line":155,"updatePoint":{"line":155,"column":41,"index":5793},"code":"    it(\"calculates the cosine of a number\", function () {\n      const stack = evaluate(\"{ 90 cos }\");\n      const expectedStack = [Math.cos(90)];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"converts to int","suites":["function","PostScriptEvaluator"],"line":160,"updatePoint":{"line":160,"column":23,"index":5973},"code":"    it(\"converts to int\", function () {\n      const stack = evaluate(\"{ 9.9 cvi }\");\n      const expectedStack = [9];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"converts negatives to int","suites":["function","PostScriptEvaluator"],"line":165,"updatePoint":{"line":165,"column":33,"index":6153},"code":"    it(\"converts negatives to int\", function () {\n      const stack = evaluate(\"{ -9.9 cvi }\");\n      const expectedStack = [-9];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"converts to real","suites":["function","PostScriptEvaluator"],"line":170,"updatePoint":{"line":170,"column":24,"index":6326},"code":"    it(\"converts to real\", function () {\n      const stack = evaluate(\"{ 55.34 cvr }\");\n      const expectedStack = [55.34];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"divides","suites":["function","PostScriptEvaluator"],"line":175,"updatePoint":{"line":175,"column":15,"index":6494},"code":"    it(\"divides\", function () {\n      const stack = evaluate(\"{ 6 5 div }\");\n      const expectedStack = [1.2];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"maps division by zero to infinity","suites":["function","PostScriptEvaluator"],"line":180,"updatePoint":{"line":180,"column":41,"index":6684},"code":"    it(\"maps division by zero to infinity\", function () {\n      const stack = evaluate(\"{ 6 0 div }\");\n      const expectedStack = [Infinity];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"duplicates","suites":["function","PostScriptEvaluator"],"line":185,"updatePoint":{"line":185,"column":18,"index":6856},"code":"    it(\"duplicates\", function () {\n      const stack = evaluate(\"{ 99 dup }\");\n      const expectedStack = [99, 99];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"accepts an equality","suites":["function","PostScriptEvaluator"],"line":190,"updatePoint":{"line":190,"column":27,"index":7034},"code":"    it(\"accepts an equality\", function () {\n      const stack = evaluate(\"{ 9 9 eq }\");\n      const expectedStack = [true];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"rejects an inequality","suites":["function","PostScriptEvaluator"],"line":195,"updatePoint":{"line":195,"column":29,"index":7212},"code":"    it(\"rejects an inequality\", function () {\n      const stack = evaluate(\"{ 9 8 eq }\");\n      const expectedStack = [false];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"exchanges","suites":["function","PostScriptEvaluator"],"line":200,"updatePoint":{"line":200,"column":17,"index":7379},"code":"    it(\"exchanges\", function () {\n      const stack = evaluate(\"{ 44 99 exch }\");\n      const expectedStack = [99, 44];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"handles exponentiation","suites":["function","PostScriptEvaluator"],"line":205,"updatePoint":{"line":205,"column":30,"index":7564},"code":"    it(\"handles exponentiation\", function () {\n      const stack = evaluate(\"{ 10 2 exp }\");\n      const expectedStack = [100];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"pushes false onto the stack","suites":["function","PostScriptEvaluator"],"line":210,"updatePoint":{"line":210,"column":35,"index":7749},"code":"    it(\"pushes false onto the stack\", function () {\n      const stack = evaluate(\"{ false }\");\n      const expectedStack = [false];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"calculates the floor value","suites":["function","PostScriptEvaluator"],"line":215,"updatePoint":{"line":215,"column":34,"index":7932},"code":"    it(\"calculates the floor value\", function () {\n      const stack = evaluate(\"{ 9.9 floor }\");\n      const expectedStack = [9];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"handles greater than or equal to","suites":["function","PostScriptEvaluator"],"line":220,"updatePoint":{"line":220,"column":40,"index":8121},"code":"    it(\"handles greater than or equal to\", function () {\n      const stack = evaluate(\"{ 10 9 ge }\");\n      const expectedStack = [true];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"rejects less than for greater than or equal to","suites":["function","PostScriptEvaluator"],"line":225,"updatePoint":{"line":225,"column":54,"index":8325},"code":"    it(\"rejects less than for greater than or equal to\", function () {\n      const stack = evaluate(\"{ 8 9 ge }\");\n      const expectedStack = [false];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"handles greater than","suites":["function","PostScriptEvaluator"],"line":230,"updatePoint":{"line":230,"column":28,"index":8503},"code":"    it(\"handles greater than\", function () {\n      const stack = evaluate(\"{ 10 9 gt }\");\n      const expectedStack = [true];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"rejects less than or equal for greater than","suites":["function","PostScriptEvaluator"],"line":235,"updatePoint":{"line":235,"column":51,"index":8704},"code":"    it(\"rejects less than or equal for greater than\", function () {\n      const stack = evaluate(\"{ 9 9 gt }\");\n      const expectedStack = [false];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"divides to integer","suites":["function","PostScriptEvaluator"],"line":240,"updatePoint":{"line":240,"column":26,"index":8880},"code":"    it(\"divides to integer\", function () {\n      const stack = evaluate(\"{ 2 3 idiv }\");\n      const expectedStack = [0];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"divides to negative integer","suites":["function","PostScriptEvaluator"],"line":245,"updatePoint":{"line":245,"column":35,"index":9063},"code":"    it(\"divides to negative integer\", function () {\n      const stack = evaluate(\"{ -2 3 idiv }\");\n      const expectedStack = [0];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"duplicates index","suites":["function","PostScriptEvaluator"],"line":250,"updatePoint":{"line":250,"column":24,"index":9236},"code":"    it(\"duplicates index\", function () {\n      const stack = evaluate(\"{ 4 3 2 1 2 index }\");\n      const expectedStack = [4, 3, 2, 1, 3];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"handles less than or equal to","suites":["function","PostScriptEvaluator"],"line":255,"updatePoint":{"line":255,"column":37,"index":9440},"code":"    it(\"handles less than or equal to\", function () {\n      const stack = evaluate(\"{ 9 10 le }\");\n      const expectedStack = [true];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"rejects greater than for less than or equal to","suites":["function","PostScriptEvaluator"],"line":260,"updatePoint":{"line":260,"column":54,"index":9644},"code":"    it(\"rejects greater than for less than or equal to\", function () {\n      const stack = evaluate(\"{ 10 9 le }\");\n      const expectedStack = [false];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"calculates the natural logarithm","suites":["function","PostScriptEvaluator"],"line":265,"updatePoint":{"line":265,"column":40,"index":9835},"code":"    it(\"calculates the natural logarithm\", function () {\n      const stack = evaluate(\"{ 10 ln }\");\n      const expectedStack = [Math.log(10)];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"calculates the base 10 logarithm","suites":["function","PostScriptEvaluator"],"line":270,"updatePoint":{"line":270,"column":40,"index":10031},"code":"    it(\"calculates the base 10 logarithm\", function () {\n      const stack = evaluate(\"{ 100 log }\");\n      const expectedStack = [2];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"handles less than","suites":["function","PostScriptEvaluator"],"line":275,"updatePoint":{"line":275,"column":25,"index":10203},"code":"    it(\"handles less than\", function () {\n      const stack = evaluate(\"{ 9 10 lt }\");\n      const expectedStack = [true];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"rejects greater than or equal to for less than","suites":["function","PostScriptEvaluator"],"line":280,"updatePoint":{"line":280,"column":54,"index":10407},"code":"    it(\"rejects greater than or equal to for less than\", function () {\n      const stack = evaluate(\"{ 10 9 lt }\");\n      const expectedStack = [false];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"performs the modulo operation","suites":["function","PostScriptEvaluator"],"line":285,"updatePoint":{"line":285,"column":37,"index":10595},"code":"    it(\"performs the modulo operation\", function () {\n      const stack = evaluate(\"{ 4 3 mod }\");\n      const expectedStack = [1];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"multiplies two numbers (positive result)","suites":["function","PostScriptEvaluator"],"line":290,"updatePoint":{"line":290,"column":48,"index":10790},"code":"    it(\"multiplies two numbers (positive result)\", function () {\n      const stack = evaluate(\"{ 9 8 mul }\");\n      const expectedStack = [72];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"multiplies two numbers (negative result)","suites":["function","PostScriptEvaluator"],"line":295,"updatePoint":{"line":295,"column":48,"index":10986},"code":"    it(\"multiplies two numbers (negative result)\", function () {\n      const stack = evaluate(\"{ 9 -8 mul }\");\n      const expectedStack = [-72];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"accepts an inequality","suites":["function","PostScriptEvaluator"],"line":300,"updatePoint":{"line":300,"column":29,"index":11165},"code":"    it(\"accepts an inequality\", function () {\n      const stack = evaluate(\"{ 9 8 ne }\");\n      const expectedStack = [true];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"rejects an equality","suites":["function","PostScriptEvaluator"],"line":305,"updatePoint":{"line":305,"column":27,"index":11341},"code":"    it(\"rejects an equality\", function () {\n      const stack = evaluate(\"{ 9 9 ne }\");\n      const expectedStack = [false];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"negates","suites":["function","PostScriptEvaluator"],"line":310,"updatePoint":{"line":310,"column":15,"index":11506},"code":"    it(\"negates\", function () {\n      const stack = evaluate(\"{ 4.5 neg }\");\n      const expectedStack = [-4.5];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"boolean not","suites":["function","PostScriptEvaluator"],"line":315,"updatePoint":{"line":315,"column":19,"index":11675},"code":"    it(\"boolean not\", function () {\n      const stack = evaluate(\"{ true not }\");\n      const expectedStack = [false];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"bitwise not","suites":["function","PostScriptEvaluator"],"line":320,"updatePoint":{"line":320,"column":19,"index":11846},"code":"    it(\"bitwise not\", function () {\n      const stack = evaluate(\"{ 12 not }\");\n      const expectedStack = [-13];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"boolean or","suites":["function","PostScriptEvaluator"],"line":325,"updatePoint":{"line":325,"column":18,"index":12012},"code":"    it(\"boolean or\", function () {\n      const stack = evaluate(\"{ true false or }\");\n      const expectedStack = [true];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"bitwise or","suites":["function","PostScriptEvaluator"],"line":330,"updatePoint":{"line":330,"column":18,"index":12186},"code":"    it(\"bitwise or\", function () {\n      const stack = evaluate(\"{ 254 1 or }\");\n      const expectedStack = [254 | 1];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"pops stack","suites":["function","PostScriptEvaluator"],"line":335,"updatePoint":{"line":335,"column":18,"index":12358},"code":"    it(\"pops stack\", function () {\n      const stack = evaluate(\"{ 1 2 pop }\");\n      const expectedStack = [1];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"rolls stack right","suites":["function","PostScriptEvaluator"],"line":340,"updatePoint":{"line":340,"column":25,"index":12530},"code":"    it(\"rolls stack right\", function () {\n      const stack = evaluate(\"{ 1 3 2 2 4 1 roll }\");\n      const expectedStack = [2, 1, 3, 2];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"rolls stack left","suites":["function","PostScriptEvaluator"],"line":345,"updatePoint":{"line":345,"column":24,"index":12719},"code":"    it(\"rolls stack left\", function () {\n      const stack = evaluate(\"{ 1 3 2 2 4 -1 roll }\");\n      const expectedStack = [3, 2, 2, 1];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"rounds a number","suites":["function","PostScriptEvaluator"],"line":350,"updatePoint":{"line":350,"column":23,"index":12908},"code":"    it(\"rounds a number\", function () {\n      const stack = evaluate(\"{ 9.52 round }\");\n      const expectedStack = [10];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"calculates the sine of a number","suites":["function","PostScriptEvaluator"],"line":355,"updatePoint":{"line":355,"column":39,"index":13098},"code":"    it(\"calculates the sine of a number\", function () {\n      const stack = evaluate(\"{ 90 sin }\");\n      const expectedStack = [Math.sin(90)];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"calculates a square root (integer)","suites":["function","PostScriptEvaluator"],"line":360,"updatePoint":{"line":360,"column":42,"index":13297},"code":"    it(\"calculates a square root (integer)\", function () {\n      const stack = evaluate(\"{ 100 sqrt }\");\n      const expectedStack = [10];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"calculates a square root (float)","suites":["function","PostScriptEvaluator"],"line":365,"updatePoint":{"line":365,"column":40,"index":13486},"code":"    it(\"calculates a square root (float)\", function () {\n      const stack = evaluate(\"{ 99 sqrt }\");\n      const expectedStack = [Math.sqrt(99)];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"subtracts (positive result)","suites":["function","PostScriptEvaluator"],"line":370,"updatePoint":{"line":370,"column":35,"index":13680},"code":"    it(\"subtracts (positive result)\", function () {\n      const stack = evaluate(\"{ 6 4 sub }\");\n      const expectedStack = [2];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"subtracts (negative result)","suites":["function","PostScriptEvaluator"],"line":375,"updatePoint":{"line":375,"column":35,"index":13862},"code":"    it(\"subtracts (negative result)\", function () {\n      const stack = evaluate(\"{ 4 6 sub }\");\n      const expectedStack = [-2];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"pushes true onto the stack","suites":["function","PostScriptEvaluator"],"line":380,"updatePoint":{"line":380,"column":34,"index":14044},"code":"    it(\"pushes true onto the stack\", function () {\n      const stack = evaluate(\"{ true }\");\n      const expectedStack = [true];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"truncates a number","suites":["function","PostScriptEvaluator"],"line":385,"updatePoint":{"line":385,"column":26,"index":14217},"code":"    it(\"truncates a number\", function () {\n      const stack = evaluate(\"{ 35.004 truncate }\");\n      const expectedStack = [35];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"calculates an exclusive or value","suites":["function","PostScriptEvaluator"],"line":390,"updatePoint":{"line":390,"column":40,"index":14413},"code":"    it(\"calculates an exclusive or value\", function () {\n      const stack = evaluate(\"{ 3 9 xor }\");\n      const expectedStack = [10];\n      expect(stack).toEqual(expectedStack);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"check compiled add","suites":["function","PostScriptCompiler"],"line":419,"updatePoint":{"line":419,"column":26,"index":15330},"code":"    it(\"check compiled add\", function () {\n      check([0.25, 0.5, \"add\"], [], [0, 1], [{\n        input: [],\n        output: [0.75]\n      }]);\n      check([0, \"add\"], [0, 1], [0, 1], [{\n        input: [0.25],\n        output: [0.25]\n      }]);\n      check([0.5, \"add\"], [0, 1], [0, 1], [{\n        input: [0.25],\n        output: [0.75]\n      }]);\n      check([0, \"exch\", \"add\"], [0, 1], [0, 1], [{\n        input: [0.25],\n        output: [0.25]\n      }]);\n      check([0.5, \"exch\", \"add\"], [0, 1], [0, 1], [{\n        input: [0.25],\n        output: [0.75]\n      }]);\n      check([\"add\"], [0, 1, 0, 1], [0, 1], [{\n        input: [0.25, 0.5],\n        output: [0.75]\n      }]);\n      check([\"add\"], [0, 1], [0, 1], null);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"check compiled sub","suites":["function","PostScriptCompiler"],"line":446,"updatePoint":{"line":446,"column":26,"index":16053},"code":"    it(\"check compiled sub\", function () {\n      check([0.5, 0.25, \"sub\"], [], [0, 1], [{\n        input: [],\n        output: [0.25]\n      }]);\n      check([0, \"sub\"], [0, 1], [0, 1], [{\n        input: [0.25],\n        output: [0.25]\n      }]);\n      check([0.5, \"sub\"], [0, 1], [0, 1], [{\n        input: [0.75],\n        output: [0.25]\n      }]);\n      check([0, \"exch\", \"sub\"], [0, 1], [-1, 1], [{\n        input: [0.25],\n        output: [-0.25]\n      }]);\n      check([0.75, \"exch\", \"sub\"], [0, 1], [-1, 1], [{\n        input: [0.25],\n        output: [0.5]\n      }]);\n      check([\"sub\"], [0, 1, 0, 1], [-1, 1], [{\n        input: [0.25, 0.5],\n        output: [-0.25]\n      }]);\n      check([\"sub\"], [0, 1], [0, 1], null);\n      check([1, \"dup\", 3, 2, \"roll\", \"sub\", \"sub\"], [0, 1], [0, 1], [{\n        input: [0.75],\n        output: [0.75]\n      }]);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"check compiled mul","suites":["function","PostScriptCompiler"],"line":477,"updatePoint":{"line":477,"column":26,"index":16909},"code":"    it(\"check compiled mul\", function () {\n      check([0.25, 0.5, \"mul\"], [], [0, 1], [{\n        input: [],\n        output: [0.125]\n      }]);\n      check([0, \"mul\"], [0, 1], [0, 1], [{\n        input: [0.25],\n        output: [0]\n      }]);\n      check([0.5, \"mul\"], [0, 1], [0, 1], [{\n        input: [0.25],\n        output: [0.125]\n      }]);\n      check([1, \"mul\"], [0, 1], [0, 1], [{\n        input: [0.25],\n        output: [0.25]\n      }]);\n      check([0, \"exch\", \"mul\"], [0, 1], [0, 1], [{\n        input: [0.25],\n        output: [0]\n      }]);\n      check([0.5, \"exch\", \"mul\"], [0, 1], [0, 1], [{\n        input: [0.25],\n        output: [0.125]\n      }]);\n      check([1, \"exch\", \"mul\"], [0, 1], [0, 1], [{\n        input: [0.25],\n        output: [0.25]\n      }]);\n      check([\"mul\"], [0, 1, 0, 1], [0, 1], [{\n        input: [0.25, 0.5],\n        output: [0.125]\n      }]);\n      check([\"mul\"], [0, 1], [0, 1], null);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"check compiled max","suites":["function","PostScriptCompiler"],"line":512,"updatePoint":{"line":512,"column":26,"index":17838},"code":"    it(\"check compiled max\", function () {\n      check([\"dup\", 0.75, \"gt\", 7, \"jz\", \"pop\", 0.75], [0, 1], [0, 1], [{\n        input: [0.5],\n        output: [0.5]\n      }]);\n      check([\"dup\", 0.75, \"gt\", 7, \"jz\", \"pop\", 0.75], [0, 1], [0, 1], [{\n        input: [1],\n        output: [0.75]\n      }]);\n      check([\"dup\", 0.75, \"gt\", 5, \"jz\", \"pop\", 0.75], [0, 1], [0, 1], null);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"check pop/roll/index","suites":["function","PostScriptCompiler"],"line":523,"updatePoint":{"line":523,"column":28,"index":18226},"code":"    it(\"check pop/roll/index\", function () {\n      check([1, \"pop\"], [0, 1], [0, 1], [{\n        input: [0.5],\n        output: [0.5]\n      }]);\n      check([1, 3, -1, \"roll\"], [0, 1, 0, 1], [0, 1, 0, 1, 0, 1], [{\n        input: [0.25, 0.5],\n        output: [0.5, 1, 0.25]\n      }]);\n      check([1, 3, 1, \"roll\"], [0, 1, 0, 1], [0, 1, 0, 1, 0, 1], [{\n        input: [0.25, 0.5],\n        output: [1, 0.25, 0.5]\n      }]);\n      check([1, 3, 1.5, \"roll\"], [0, 1, 0, 1], [0, 1, 0, 1, 0, 1], null);\n      check([1, 1, \"index\"], [0, 1], [0, 1, 0, 1, 0, 1], [{\n        input: [0.5],\n        output: [0.5, 1, 0.5]\n      }]);\n      check([1, 3, \"index\", \"pop\"], [0, 1], [0, 1], null);\n      check([1, 0.5, \"index\", \"pop\"], [0, 1], [0, 1], null);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"check input boundaries","suites":["function","PostScriptCompiler"],"line":544,"updatePoint":{"line":544,"column":30,"index":18973},"code":"    it(\"check input boundaries\", function () {\n      check([], [0, 0.5], [0, 1], [{\n        input: [1],\n        output: [0.5]\n      }]);\n      check([], [0.5, 1], [0, 1], [{\n        input: [0],\n        output: [0.5]\n      }]);\n      check([\"dup\"], [0.5, 0.75], [0, 1, 0, 1], [{\n        input: [0],\n        output: [0.5, 0.5]\n      }]);\n      check([], [100, 1001], [0, 10000], [{\n        input: [1000],\n        output: [1000]\n      }]);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"check output boundaries","suites":["function","PostScriptCompiler"],"line":562,"updatePoint":{"line":562,"column":31,"index":19419},"code":"    it(\"check output boundaries\", function () {\n      check([], [0, 1], [0, 0.5], [{\n        input: [1],\n        output: [0.5]\n      }]);\n      check([], [0, 1], [0.5, 1], [{\n        input: [0],\n        output: [0.5]\n      }]);\n      check([\"dup\"], [0, 1], [0.5, 1, 0.75, 1], [{\n        input: [0],\n        output: [0.5, 0.75]\n      }]);\n      check([], [0, 10000], [100, 1001], [{\n        input: [1000],\n        output: [1000]\n      }]);\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"compile optimized","suites":["function","PostScriptCompiler"],"line":580,"updatePoint":{"line":580,"column":25,"index":19860},"code":"    it(\"compile optimized\", function () {\n      const compiler = new PostScriptCompiler();\n      const code = [0, \"add\", 1, 1, 3, -1, \"roll\", \"sub\", \"sub\", 1, \"mul\"];\n      const compiledCode = compiler.compile(code, [0, 1], [0, 1]);\n      expect(compiledCode).toEqual(\"dest[destOffset + 0] = Math.max(0, Math.min(1, src[srcOffset + 0]));\");\n    });","file":"unit/function_spec.js","skipped":false,"dir":"test"},{"name":"should return a ReadableStream","suites":["message_handler","sendWithStream"],"line":27,"updatePoint":{"line":27,"column":38,"index":1154},"code":"    it(\"should return a ReadableStream\", function () {\n      const port = new LoopbackPort();\n      const messageHandler1 = new MessageHandler(\"main\", \"worker\", port);\n      const readable = messageHandler1.sendWithStream(\"fakeHandler\"); // Check if readable is an instance of ReadableStream.\n\n      expect(typeof readable).toEqual(\"object\");\n      expect(typeof readable.getReader).toEqual(\"function\");\n    });","file":"unit/message_handler_spec.js","skipped":false,"dir":"test"},{"name":"should read using a reader","suites":["message_handler","sendWithStream"],"line":35,"updatePoint":{"line":35,"column":34,"index":1562},"code":"    it(\"should read using a reader\", async function () {\n      let log = \"\";\n      const port = new LoopbackPort();\n      const messageHandler1 = new MessageHandler(\"main\", \"worker\", port);\n      const messageHandler2 = new MessageHandler(\"worker\", \"main\", port);\n      messageHandler2.on(\"fakeHandler\", (data, sink) => {\n        sink.onPull = function () {\n          log += \"p\";\n        };\n\n        sink.onCancel = function (reason) {\n          log += \"c\";\n        };\n\n        sink.ready.then(() => {\n          sink.enqueue(\"hi\");\n          return sink.ready;\n        }).then(() => {\n          sink.close();\n        });\n        return sleep(5);\n      });\n      const readable = messageHandler1.sendWithStream(\"fakeHandler\", {}, {\n        highWaterMark: 1,\n\n        size() {\n          return 1;\n        }\n\n      });\n      const reader = readable.getReader();\n      await sleep(10);\n      expect(log).toEqual(\"\");\n      let result = await reader.read();\n      expect(log).toEqual(\"p\");\n      expect(result.value).toEqual(\"hi\");\n      expect(result.done).toEqual(false);\n      await sleep(10);\n      result = await reader.read();\n      expect(result.value).toEqual(undefined);\n      expect(result.done).toEqual(true);\n    });","file":"unit/message_handler_spec.js","skipped":false,"dir":"test"},{"name":"should not read any data when cancelled","suites":["message_handler","sendWithStream"],"line":77,"updatePoint":{"line":77,"column":47,"index":2799},"code":"    it(\"should not read any data when cancelled\", async function () {\n      let log = \"\";\n      const port = new LoopbackPort();\n      const messageHandler2 = new MessageHandler(\"worker\", \"main\", port);\n      messageHandler2.on(\"fakeHandler\", (data, sink) => {\n        sink.onPull = function () {\n          log += \"p\";\n        };\n\n        sink.onCancel = function (reason) {\n          log += \"c\";\n        };\n\n        log += \"0\";\n        sink.ready.then(() => {\n          log += \"1\";\n          sink.enqueue([1, 2, 3, 4], 4);\n          return sink.ready;\n        }).then(() => {\n          log += \"2\";\n          sink.enqueue([5, 6, 7, 8], 4);\n          return sink.ready;\n        }).then(() => {\n          log += \"3\";\n          sink.close();\n        }, () => {\n          log += \"4\";\n        });\n      });\n      const messageHandler1 = new MessageHandler(\"main\", \"worker\", port);\n      const readable = messageHandler1.sendWithStream(\"fakeHandler\", {}, {\n        highWaterMark: 4,\n\n        size(arr) {\n          return arr.length;\n        }\n\n      });\n      const reader = readable.getReader();\n      await sleep(10);\n      expect(log).toEqual(\"01\");\n      const result = await reader.read();\n      expect(result.value).toEqual([1, 2, 3, 4]);\n      expect(result.done).toEqual(false);\n      await sleep(10);\n      expect(log).toEqual(\"01p2\");\n      await reader.cancel(new AbortException(\"reader cancelled.\"));\n      expect(log).toEqual(\"01p2c4\");\n    });","file":"unit/message_handler_spec.js","skipped":false,"dir":"test"},{"name":"should not read when errored","suites":["message_handler","sendWithStream"],"line":126,"updatePoint":{"line":126,"column":36,"index":4240},"code":"    it(\"should not read when errored\", async function () {\n      let log = \"\";\n      const port = new LoopbackPort();\n      const messageHandler2 = new MessageHandler(\"worker\", \"main\", port);\n      messageHandler2.on(\"fakeHandler\", (data, sink) => {\n        sink.onPull = function () {\n          log += \"p\";\n        };\n\n        sink.onCancel = function (reason) {\n          log += \"c\";\n        };\n\n        log += \"0\";\n        sink.ready.then(() => {\n          log += \"1\";\n          sink.enqueue([1, 2, 3, 4], 4);\n          return sink.ready;\n        }).then(() => {\n          log += \"e\";\n          sink.error(new Error(\"should not read when errored\"));\n        });\n      });\n      const messageHandler1 = new MessageHandler(\"main\", \"worker\", port);\n      const readable = messageHandler1.sendWithStream(\"fakeHandler\", {}, {\n        highWaterMark: 4,\n\n        size(arr) {\n          return arr.length;\n        }\n\n      });\n      const reader = readable.getReader();\n      await sleep(10);\n      expect(log).toEqual(\"01\");\n      const result = await reader.read();\n      expect(result.value).toEqual([1, 2, 3, 4]);\n      expect(result.done).toEqual(false);\n\n      try {\n        await reader.read(); // Shouldn't get here.\n\n        expect(false).toEqual(true);\n      } catch (reason) {\n        expect(log).toEqual(\"01pe\");\n        expect(reason instanceof UnknownErrorException).toEqual(true);\n        expect(reason.message).toEqual(\"should not read when errored\");\n      }\n    });","file":"unit/message_handler_spec.js","skipped":false,"dir":"test"},{"name":"should read data with blocking promise","suites":["message_handler","sendWithStream"],"line":175,"updatePoint":{"line":175,"column":46,"index":5728},"code":"    it(\"should read data with blocking promise\", async function () {\n      let log = \"\";\n      const port = new LoopbackPort();\n      const messageHandler2 = new MessageHandler(\"worker\", \"main\", port);\n      messageHandler2.on(\"fakeHandler\", (data, sink) => {\n        sink.onPull = function () {\n          log += \"p\";\n        };\n\n        sink.onCancel = function (reason) {\n          log += \"c\";\n        };\n\n        log += \"0\";\n        sink.ready.then(() => {\n          log += \"1\";\n          sink.enqueue([1, 2, 3, 4], 4);\n          return sink.ready;\n        }).then(() => {\n          log += \"2\";\n          sink.enqueue([5, 6, 7, 8], 4);\n          return sink.ready;\n        }).then(() => {\n          sink.close();\n        });\n      });\n      const messageHandler1 = new MessageHandler(\"main\", \"worker\", port);\n      const readable = messageHandler1.sendWithStream(\"fakeHandler\", {}, {\n        highWaterMark: 4,\n\n        size(arr) {\n          return arr.length;\n        }\n\n      });\n      const reader = readable.getReader(); // Sleep for 10ms, so that read() is not unblocking the ready promise.\n      // Chain all read() to stream in sequence.\n\n      await sleep(10);\n      expect(log).toEqual(\"01\");\n      let result = await reader.read();\n      expect(result.value).toEqual([1, 2, 3, 4]);\n      expect(result.done).toEqual(false);\n      await sleep(10);\n      expect(log).toEqual(\"01p2\");\n      result = await reader.read();\n      expect(result.value).toEqual([5, 6, 7, 8]);\n      expect(result.done).toEqual(false);\n      await sleep(10);\n      expect(log).toEqual(\"01p2p\");\n      result = await reader.read();\n      expect(result.value).toEqual(undefined);\n      expect(result.done).toEqual(true);\n    });","file":"unit/message_handler_spec.js","skipped":false,"dir":"test"},{"name":"should ignore any pull after close is called","suites":["message_handler","sendWithStream"],"line":282,"updatePoint":{"line":282,"column":52,"index":9104},"code":"    it(\"should ignore any pull after close is called\", async function () {\n      let log = \"\";\n      const port = new LoopbackPort();\n      const capability = createPromiseCapability();\n      const messageHandler2 = new MessageHandler(\"worker\", \"main\", port);\n      messageHandler2.on(\"fakeHandler\", (data, sink) => {\n        sink.onPull = function () {\n          log += \"p\";\n        };\n\n        sink.onCancel = function (reason) {\n          log += \"c\";\n        };\n\n        log += \"0\";\n        sink.ready.then(() => {\n          log += \"1\";\n          sink.enqueue([1, 2, 3, 4], 4);\n        });\n        return capability.promise.then(() => {\n          sink.close();\n        });\n      });\n      const messageHandler1 = new MessageHandler(\"main\", \"worker\", port);\n      const readable = messageHandler1.sendWithStream(\"fakeHandler\", {}, {\n        highWaterMark: 10,\n\n        size(arr) {\n          return arr.length;\n        }\n\n      });\n      const reader = readable.getReader();\n      await sleep(10);\n      expect(log).toEqual(\"01\");\n      capability.resolve();\n      await capability.promise;\n      let result = await reader.read();\n      expect(result.value).toEqual([1, 2, 3, 4]);\n      expect(result.done).toEqual(false);\n      await sleep(10);\n      expect(log).toEqual(\"01\");\n      result = await reader.read();\n      expect(result.value).toEqual(undefined);\n      expect(result.done).toEqual(true);\n    });","file":"unit/message_handler_spec.js","skipped":false,"dir":"test"},{"name":"should handle valid metadata","suites":["metadata"],"line":25,"updatePoint":{"line":25,"column":34,"index":980},"code":"  it(\"should handle valid metadata\", function () {\n    const data = \"<x:xmpmeta xmlns:x='adobe:ns:meta/'>\" + \"<rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'>\" + \"<rdf:Description xmlns:dc='http://purl.org/dc/elements/1.1/'>\" + '<dc:title><rdf:Alt><rdf:li xml:lang=\"x-default\">Foo bar baz</rdf:li>' + \"</rdf:Alt></dc:title></rdf:Description></rdf:RDF></x:xmpmeta>\";\n    const metadata = createMetadata(data);\n    expect(metadata.has(\"dc:title\")).toBeTruthy();\n    expect(metadata.has(\"dc:qux\")).toBeFalsy();\n    expect(metadata.get(\"dc:title\")).toEqual(\"Foo bar baz\");\n    expect(metadata.get(\"dc:qux\")).toEqual(null);\n    expect(metadata.getAll()).toEqual({\n      \"dc:title\": \"Foo bar baz\"\n    });\n  });","file":"unit/metadata_spec.js","skipped":false,"dir":"test"},{"name":"should repair and handle invalid metadata","suites":["metadata"],"line":36,"updatePoint":{"line":36,"column":47,"index":1715},"code":"  it(\"should repair and handle invalid metadata\", function () {\n    const data = \"<x:xmpmeta xmlns:x='adobe:ns:meta/'>\" + \"<rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'>\" + \"<rdf:Description xmlns:dc='http://purl.org/dc/elements/1.1/'>\" + \"<dc:title>\\\\376\\\\377\\\\000P\\\\000D\\\\000F\\\\000&</dc:title>\" + \"</rdf:Description></rdf:RDF></x:xmpmeta>\";\n    const metadata = createMetadata(data);\n    expect(metadata.has(\"dc:title\")).toBeTruthy();\n    expect(metadata.has(\"dc:qux\")).toBeFalsy();\n    expect(metadata.get(\"dc:title\")).toEqual(\"PDF&\");\n    expect(metadata.get(\"dc:qux\")).toEqual(null);\n    expect(metadata.getAll()).toEqual({\n      \"dc:title\": \"PDF&\"\n    });\n  });","file":"unit/metadata_spec.js","skipped":false,"dir":"test"},{"name":"should repair and handle invalid metadata (bug 1424938)","suites":["metadata"],"line":47,"updatePoint":{"line":47,"column":61,"index":2416},"code":"  it(\"should repair and handle invalid metadata (bug 1424938)\", function () {\n    const data = \"<x:xmpmeta xmlns:x='adobe:ns:meta/' \" + \"x:xmptk='XMP toolkit 2.9.1-13, framework 1.6'>\" + \"<rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#' \" + \"xmlns:iX='http://ns.adobe.com/iX/1.0/'>\" + \"<rdf:Description rdf:about='61652fa7-fc1f-11dd-0000-ce81d41f9ecf' \" + \"xmlns:pdf='http://ns.adobe.com/pdf/1.3/' \" + \"pdf:Producer='GPL Ghostscript 8.63'/>\" + \"<rdf:Description rdf:about='61652fa7-fc1f-11dd-0000-ce81d41f9ecf' \" + \"xmlns:xap='http://ns.adobe.com/xap/1.0/' \" + \"xap:ModifyDate='2009-02-13T12:42:54+01:00' \" + \"xap:CreateDate='2009-02-13T12:42:54+01:00'>\" + \"<xap:CreatorTool>\\\\376\\\\377\\\\000P\\\\000D\\\\000F\\\\000C\\\\000r\\\\000e\\\\000a\" + \"\\\\000t\\\\000o\\\\000r\\\\000 \\\\000V\\\\000e\\\\000r\\\\000s\\\\000i\\\\000o\\\\000n\" + \"\\\\000 \\\\0000\\\\000.\\\\0009\\\\000.\\\\0006</xap:CreatorTool>\" + \"</rdf:Description><rdf:Description \" + \"rdf:about='61652fa7-fc1f-11dd-0000-ce81d41f9ecf' \" + \"xmlns:xapMM='http://ns.adobe.com/xap/1.0/mm/' \" + \"xapMM:DocumentID='61652fa7-fc1f-11dd-0000-ce81d41f9ecf'/>\" + \"<rdf:Description rdf:about='61652fa7-fc1f-11dd-0000-ce81d41f9ecf' \" + \"xmlns:dc='http://purl.org/dc/elements/1.1/' \" + \"dc:format='application/pdf'><dc:title><rdf:Alt>\" + \"<rdf:li xml:lang='x-default'>\\\\376\\\\377\\\\000L\\\\000&apos;\\\\000O\\\\000d\" + \"\\\\000i\\\\000s\\\\000s\\\\000e\\\\000e\\\\000 \\\\000t\\\\000h\\\\000\\\\351\\\\000m\\\\000a\" + \"\\\\000t\\\\000i\\\\000q\\\\000u\\\\000e\\\\000 \\\\000l\\\\000o\\\\000g\\\\000o\\\\000 \" + \"\\\\000O\\\\000d\\\\000i\\\\000s\\\\000s\\\\000\\\\351\\\\000\\\\351\\\\000 \\\\000-\\\\000 \" + \"\\\\000d\\\\000\\\\351\\\\000c\\\\000e\\\\000m\\\\000b\\\\000r\\\\000e\\\\000 \\\\0002\\\\0000\" + \"\\\\0000\\\\0008\\\\000.\\\\000p\\\\000u\\\\000b</rdf:li></rdf:Alt></dc:title>\" + \"<dc:creator><rdf:Seq><rdf:li>\\\\376\\\\377\\\\000O\\\\000D\\\\000I\\\\000S\" + \"</rdf:li></rdf:Seq></dc:creator></rdf:Description></rdf:RDF>\" + \"</x:xmpmeta>\";\n    const metadata = createMetadata(data);\n    expect(metadata.has(\"dc:title\")).toBeTruthy();\n    expect(metadata.has(\"dc:qux\")).toBeFalsy();\n    expect(metadata.get(\"dc:title\")).toEqual(\"L'Odissee thématique logo Odisséé - décembre 2008.pub\");\n    expect(metadata.get(\"dc:qux\")).toEqual(null);\n    expect(metadata.getAll()).toEqual({\n      \"dc:creator\": [\"ODIS\"],\n      \"dc:title\": \"L'Odissee thématique logo Odisséé - décembre 2008.pub\",\n      \"xap:creatortool\": \"PDFCreator Version 0.9.6\"\n    });\n  });","file":"unit/metadata_spec.js","skipped":false,"dir":"test"},{"name":"should gracefully handle incomplete tags (issue 8884)","suites":["metadata"],"line":60,"updatePoint":{"line":60,"column":59,"index":4763},"code":"  it(\"should gracefully handle incomplete tags (issue 8884)\", function () {\n    const data = '<?xpacket begin=\"Ã¯Â»Â¿\" id=\"W5M0MpCehiHzreSzNTczkc9d' + '<x:xmpmeta xmlns:x=\"adobe:ns:meta/\">' + '<rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">' + '<rdf:Description rdf:about=\"\"' + 'xmlns:pdfx=\"http://ns.adobe.com/pdfx/1.3/\">' + \"</rdf:Description>\" + '<rdf:Description rdf:about=\"\"' + 'xmlns:xap=\"http://ns.adobe.com/xap/1.0/\">' + \"<xap:ModifyDate>2010-03-25T11:20:09-04:00</xap:ModifyDate>\" + \"<xap:CreateDate>2010-03-25T11:20:09-04:00</xap:CreateDate>\" + \"<xap:MetadataDate>2010-03-25T11:20:09-04:00</xap:MetadataDate>\" + \"</rdf:Description>\" + '<rdf:Description rdf:about=\"\"' + 'xmlns:dc=\"http://purl.org/dc/elements/1.1/\">' + \"<dc:format>application/pdf</dc:format>\" + \"</rdf:Description>\" + '<rdf:Description rdf:about=\"\"' + 'xmlns:pdfaid=\"http://www.aiim.org/pdfa/ns/id/\">' + \"<pdfaid:part>1</pdfaid:part>\" + \"<pdfaid:conformance>A</pdfaid:conformance>\" + \"</rdf:Description>\" + \"</rdf:RDF>\" + \"</x:xmpmeta>\" + '<?xpacket end=\"w\"?>';\n    const metadata = createMetadata(data);\n    expect(isEmptyObj(metadata.getAll())).toEqual(true);\n  });","file":"unit/metadata_spec.js","skipped":false,"dir":"test"},{"name":"should gracefully handle \"junk\" before the actual metadata (issue 10395)","suites":["metadata"],"line":65,"updatePoint":{"line":65,"column":78,"index":5944},"code":"  it('should gracefully handle \"junk\" before the actual metadata (issue 10395)', function () {\n    const data = 'ï»¿<?xpacket begin=\"ï»¿\" id=\"W5M0MpCehiHzreSzNTczkc9d\"?>' + '<x:xmpmeta x:xmptk=\"TallComponents PDFObjects 1.0\" ' + 'xmlns:x=\"adobe:ns:meta/\">' + '<rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">' + '<rdf:Description rdf:about=\"\" ' + 'xmlns:pdf=\"http://ns.adobe.com/pdf/1.3/\">' + \"<pdf:Producer>PDFKit.NET 4.0.102.0</pdf:Producer>\" + \"<pdf:Keywords></pdf:Keywords>\" + \"<pdf:PDFVersion>1.7</pdf:PDFVersion></rdf:Description>\" + '<rdf:Description rdf:about=\"\" ' + 'xmlns:xap=\"http://ns.adobe.com/xap/1.0/\">' + \"<xap:CreateDate>2018-12-27T13:50:36-08:00</xap:CreateDate>\" + \"<xap:ModifyDate>2018-12-27T13:50:38-08:00</xap:ModifyDate>\" + \"<xap:CreatorTool></xap:CreatorTool>\" + \"<xap:MetadataDate>2018-12-27T13:50:38-08:00</xap:MetadataDate>\" + '</rdf:Description><rdf:Description rdf:about=\"\" ' + 'xmlns:dc=\"http://purl.org/dc/elements/1.1/\">' + \"<dc:creator><rdf:Seq><rdf:li></rdf:li></rdf:Seq></dc:creator>\" + \"<dc:subject><rdf:Bag /></dc:subject>\" + '<dc:description><rdf:Alt><rdf:li xml:lang=\"x-default\">' + \"</rdf:li></rdf:Alt></dc:description>\" + '<dc:title><rdf:Alt><rdf:li xml:lang=\"x-default\"></rdf:li>' + \"</rdf:Alt></dc:title><dc:format>application/pdf</dc:format>\" + '</rdf:Description></rdf:RDF></x:xmpmeta><?xpacket end=\"w\"?>';\n    const metadata = createMetadata(data);\n    expect(metadata.has(\"dc:title\")).toBeTruthy();\n    expect(metadata.has(\"dc:qux\")).toBeFalsy();\n    expect(metadata.get(\"dc:title\")).toEqual(\"\");\n    expect(metadata.get(\"dc:qux\")).toEqual(null);\n    expect(metadata.getAll()).toEqual({\n      \"dc:creator\": [\"\"],\n      \"dc:description\": \"\",\n      \"dc:format\": \"application/pdf\",\n      \"dc:subject\": [],\n      \"dc:title\": \"\",\n      \"pdf:keywords\": \"\",\n      \"pdf:pdfversion\": \"1.7\",\n      \"pdf:producer\": \"PDFKit.NET 4.0.102.0\",\n      \"xap:createdate\": \"2018-12-27T13:50:36-08:00\",\n      \"xap:creatortool\": \"\",\n      \"xap:metadatadate\": \"2018-12-27T13:50:38-08:00\",\n      \"xap:modifydate\": \"2018-12-27T13:50:38-08:00\"\n    });\n  });","file":"unit/metadata_spec.js","skipped":false,"dir":"test"},{"name":"should correctly handle metadata containing \"&apos\" (issue 10407)","suites":["metadata"],"line":87,"updatePoint":{"line":87,"column":71,"index":8032},"code":"  it('should correctly handle metadata containing \"&apos\" (issue 10407)', function () {\n    const data = \"<x:xmpmeta xmlns:x='adobe:ns:meta/'>\" + \"<rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'>\" + \"<rdf:Description xmlns:dc='http://purl.org/dc/elements/1.1/'>\" + \"<dc:title><rdf:Alt>\" + '<rdf:li xml:lang=\"x-default\">&apos;Foo bar baz&apos;</rdf:li>' + \"</rdf:Alt></dc:title></rdf:Description></rdf:RDF></x:xmpmeta>\";\n    const metadata = createMetadata(data);\n    expect(metadata.has(\"dc:title\")).toBeTruthy();\n    expect(metadata.has(\"dc:qux\")).toBeFalsy();\n    expect(metadata.get(\"dc:title\")).toEqual(\"'Foo bar baz'\");\n    expect(metadata.get(\"dc:qux\")).toEqual(null);\n    expect(metadata.getAll()).toEqual({\n      \"dc:title\": \"'Foo bar baz'\"\n    });\n  });","file":"unit/metadata_spec.js","skipped":false,"dir":"test"},{"name":"should gracefully handle unbalanced end tags (issue 10410)","suites":["metadata"],"line":98,"updatePoint":{"line":98,"column":64,"index":8805},"code":"  it(\"should gracefully handle unbalanced end tags (issue 10410)\", function () {\n    const data = '<?xpacket begin=\"Ã¯Â»Â¿\" id=\"W5M0MpCehiHzreSzNTczkc9d\"?>' + '<rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">' + '<rdf:Description rdf:about=\"\" ' + 'xmlns:pdf=\"http://ns.adobe.com/pdf/1.3/\">' + \"<pdf:Producer>Soda PDF 5</pdf:Producer></rdf:Description>\" + '<rdf:Description rdf:about=\"\" ' + 'xmlns:xap=\"http://ns.adobe.com/xap/1.0/\">' + \"<xap:CreateDate>2018-10-02T08:14:49-05:00</xap:CreateDate>\" + \"<xap:CreatorTool>Soda PDF 5</xap:CreatorTool>\" + \"<xap:MetadataDate>2018-10-02T08:14:49-05:00</xap:MetadataDate> \" + \"<xap:ModifyDate>2018-10-02T08:14:49-05:00</xap:ModifyDate>\" + '</rdf:Description><rdf:Description rdf:about=\"\" ' + 'xmlns:xmpMM=\"http://ns.adobe.com/xap/1.0/mm/\">' + \"<xmpMM:DocumentID>uuid:00000000-1c84-3cf9-89ba-bef0e729c831\" + \"</xmpMM:DocumentID></rdf:Description>\" + '</rdf:RDF></x:xmpmeta><?xpacket end=\"w\"?>';\n    const metadata = createMetadata(data);\n    expect(isEmptyObj(metadata.getAll())).toEqual(true);\n  });","file":"unit/metadata_spec.js","skipped":false,"dir":"test"},{"name":"should not be vulnerable to the billion laughs attack","suites":["metadata"],"line":103,"updatePoint":{"line":103,"column":59,"index":9858},"code":"  it(\"should not be vulnerable to the billion laughs attack\", function () {\n    const data = '<?xml version=\"1.0\"?>' + \"<!DOCTYPE lolz [\" + '  <!ENTITY lol \"lol\">' + '  <!ENTITY lol1 \"&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;\">' + '  <!ENTITY lol2 \"&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;\">' + '  <!ENTITY lol3 \"&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;\">' + '  <!ENTITY lol4 \"&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;\">' + '  <!ENTITY lol5 \"&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;\">' + '  <!ENTITY lol6 \"&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;\">' + '  <!ENTITY lol7 \"&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;\">' + '  <!ENTITY lol8 \"&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;\">' + '  <!ENTITY lol9 \"&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;\">' + \"]>\" + '<rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">' + '  <rdf:Description xmlns:dc=\"http://purl.org/dc/elements/1.1/\">' + \"    <dc:title>\" + \"      <rdf:Alt>\" + '        <rdf:li xml:lang=\"x-default\">a&lol9;b</rdf:li>' + \"      </rdf:Alt>\" + \"    </dc:title>\" + \"  </rdf:Description>\" + \"</rdf:RDF>\";\n    const metadata = createMetadata(data);\n    expect(metadata.has(\"dc:title\")).toBeTruthy();\n    expect(metadata.has(\"dc:qux\")).toBeFalsy();\n    expect(metadata.get(\"dc:title\")).toEqual(\"a&lol9;b\");\n    expect(metadata.get(\"dc:qux\")).toEqual(null);\n    expect(metadata.getAll()).toEqual({\n      \"dc:title\": \"a&lol9;b\"\n    });\n  });","file":"unit/metadata_spec.js","skipped":false,"dir":"test"},{"name":"instantiates without seed","suites":["MurmurHash3_64"],"line":17,"updatePoint":{"line":17,"column":31,"index":738},"code":"  it(\"instantiates without seed\", function () {\n    const hash = new MurmurHash3_64();\n    expect(hash).toEqual(jasmine.any(MurmurHash3_64));\n  });","file":"unit/murmurhash3_spec.js","skipped":false,"dir":"test"},{"name":"instantiates with seed","suites":["MurmurHash3_64"],"line":21,"updatePoint":{"line":21,"column":28,"index":883},"code":"  it(\"instantiates with seed\", function () {\n    const hash = new MurmurHash3_64(1);\n    expect(hash).toEqual(jasmine.any(MurmurHash3_64));\n  });","file":"unit/murmurhash3_spec.js","skipped":false,"dir":"test"},{"name":"correctly generates a hash from a string","suites":["MurmurHash3_64"],"line":29,"updatePoint":{"line":29,"column":46,"index":1192},"code":"  it(\"correctly generates a hash from a string\", function () {\n    const hash = new MurmurHash3_64();\n    hash.update(sourceText);\n    expect(hash.hexdigest()).toEqual(hexDigestExpected);\n  });","file":"unit/murmurhash3_spec.js","skipped":false,"dir":"test"},{"name":"correctly generates a hash from a Uint8Array","suites":["MurmurHash3_64"],"line":34,"updatePoint":{"line":34,"column":50,"index":1390},"code":"  it(\"correctly generates a hash from a Uint8Array\", function () {\n    const hash = new MurmurHash3_64();\n    hash.update(new Uint8Array(sourceCharCodes));\n    expect(hash.hexdigest()).toEqual(hexDigestExpected);\n  });","file":"unit/murmurhash3_spec.js","skipped":false,"dir":"test"},{"name":"correctly generates a hash from a Uint32Array","suites":["MurmurHash3_64"],"line":39,"updatePoint":{"line":39,"column":51,"index":1610},"code":"  it(\"correctly generates a hash from a Uint32Array\", function () {\n    const hash = new MurmurHash3_64();\n    hash.update(new Uint32Array(new Uint8Array(sourceCharCodes).buffer));\n    expect(hash.hexdigest()).toEqual(hexDigestExpected);\n  });","file":"unit/murmurhash3_spec.js","skipped":false,"dir":"test"},{"name":"changes the hash after update without seed","suites":["MurmurHash3_64"],"line":44,"updatePoint":{"line":44,"column":48,"index":1851},"code":"  it(\"changes the hash after update without seed\", function () {\n    const hash = new MurmurHash3_64();\n    hash.update(sourceText);\n    const hexdigest1 = hash.hexdigest();\n    hash.update(sourceText);\n    const hexdigest2 = hash.hexdigest();\n    expect(hexdigest1).not.toEqual(hexdigest2);\n  });","file":"unit/murmurhash3_spec.js","skipped":false,"dir":"test"},{"name":"changes the hash after update with seed","suites":["MurmurHash3_64"],"line":52,"updatePoint":{"line":52,"column":45,"index":2146},"code":"  it(\"changes the hash after update with seed\", function () {\n    const hash = new MurmurHash3_64(1);\n    hash.update(sourceText);\n    const hexdigest1 = hash.hexdigest();\n    hash.update(sourceText);\n    const hexdigest2 = hash.hexdigest();\n    expect(hexdigest1).not.toEqual(hexdigest2);\n  });","file":"unit/murmurhash3_spec.js","skipped":false,"dir":"test"},{"name":"read without stream and range","suites":["network"],"line":20,"updatePoint":{"line":20,"column":35,"index":896},"code":"  it(\"read without stream and range\", async function () {\n    const stream = new PDFNetworkStream({\n      url: pdf1,\n      rangeChunkSize: 65536,\n      disableStream: true,\n      disableRange: true\n    });\n    const fullReader = stream.getFullReader();\n    let isStreamingSupported, isRangeSupported;\n    const promise = fullReader.headersReady.then(function () {\n      isStreamingSupported = fullReader.isStreamingSupported;\n      isRangeSupported = fullReader.isRangeSupported;\n    });\n    let len = 0,\n        count = 0;\n\n    const read = function () {\n      return fullReader.read().then(function (result) {\n        if (result.done) {\n          return undefined;\n        }\n\n        count++;\n        len += result.value.byteLength;\n        return read();\n      });\n    };\n\n    await Promise.all([read(), promise]);\n    expect(len).toEqual(pdf1Length);\n    expect(count).toEqual(1);\n    expect(isStreamingSupported).toEqual(false);\n    expect(isRangeSupported).toEqual(false);\n  });","file":"unit/network_spec.js","skipped":false,"dir":"test"},{"name":"read custom ranges","suites":["network"],"line":54,"updatePoint":{"line":54,"column":24,"index":1870},"code":"  it(\"read custom ranges\", async function () {\n    // We don't test on browsers that don't support range request, so\n    // requiring this test to pass.\n    const rangeSize = 32768;\n    const stream = new PDFNetworkStream({\n      url: pdf1,\n      length: pdf1Length,\n      rangeChunkSize: rangeSize,\n      disableStream: true,\n      disableRange: false\n    });\n    const fullReader = stream.getFullReader();\n    let isStreamingSupported, isRangeSupported, fullReaderCancelled;\n    const promise = fullReader.headersReady.then(function () {\n      isStreamingSupported = fullReader.isStreamingSupported;\n      isRangeSupported = fullReader.isRangeSupported; // we shall be able to close the full reader without issues\n\n      fullReader.cancel(new AbortException(\"Don't need fullReader.\"));\n      fullReaderCancelled = true;\n    }); // Skipping fullReader results, requesting something from the PDF end.\n\n    const tailSize = pdf1Length % rangeSize || rangeSize;\n    const range1Reader = stream.getRangeReader(pdf1Length - tailSize - rangeSize, pdf1Length - tailSize);\n    const range2Reader = stream.getRangeReader(pdf1Length - tailSize, pdf1Length);\n    const result1 = {\n      value: 0\n    },\n          result2 = {\n      value: 0\n    };\n\n    const read = function (reader, lenResult) {\n      return reader.read().then(function (result) {\n        if (result.done) {\n          return undefined;\n        }\n\n        lenResult.value += result.value.byteLength;\n        return read(reader, lenResult);\n      });\n    };\n\n    await Promise.all([read(range1Reader, result1), read(range2Reader, result2), promise]);\n    expect(result1.value).toEqual(rangeSize);\n    expect(result2.value).toEqual(tailSize);\n    expect(isStreamingSupported).toEqual(false);\n    expect(isRangeSupported).toEqual(true);\n    expect(fullReaderCancelled).toEqual(true);\n  });","file":"unit/network_spec.js","skipped":false,"dir":"test"},{"name":"rejects invalid rangeChunkSize","suites":["network_utils","validateRangeRequestCapabilities"],"line":19,"updatePoint":{"line":19,"column":38,"index":997},"code":"    it(\"rejects invalid rangeChunkSize\", function () {\n      expect(function () {\n        validateRangeRequestCapabilities({\n          rangeChunkSize: \"abc\"\n        });\n      }).toThrow(new Error(\"rangeChunkSize must be an integer larger than zero.\"));\n      expect(function () {\n        validateRangeRequestCapabilities({\n          rangeChunkSize: 0\n        });\n      }).toThrow(new Error(\"rangeChunkSize must be an integer larger than zero.\"));\n    });","file":"unit/network_utils_spec.js","skipped":false,"dir":"test"},{"name":"rejects disabled or non-HTTP range requests","suites":["network_utils","validateRangeRequestCapabilities"],"line":31,"updatePoint":{"line":31,"column":51,"index":1465},"code":"    it(\"rejects disabled or non-HTTP range requests\", function () {\n      expect(validateRangeRequestCapabilities({\n        disableRange: true,\n        isHttp: true,\n        getResponseHeader: headerName => {\n          if (headerName === \"Content-Length\") {\n            return 8;\n          }\n\n          throw new Error(`Unexpected headerName: ${headerName}`);\n        },\n        rangeChunkSize: 64\n      })).toEqual({\n        allowRangeRequests: false,\n        suggestedLength: 8\n      });\n      expect(validateRangeRequestCapabilities({\n        disableRange: false,\n        isHttp: false,\n        getResponseHeader: headerName => {\n          if (headerName === \"Content-Length\") {\n            return 8;\n          }\n\n          throw new Error(`Unexpected headerName: ${headerName}`);\n        },\n        rangeChunkSize: 64\n      })).toEqual({\n        allowRangeRequests: false,\n        suggestedLength: 8\n      });\n    });","file":"unit/network_utils_spec.js","skipped":false,"dir":"test"},{"name":"rejects invalid Accept-Ranges header values","suites":["network_utils","validateRangeRequestCapabilities"],"line":63,"updatePoint":{"line":63,"column":51,"index":2387},"code":"    it(\"rejects invalid Accept-Ranges header values\", function () {\n      expect(validateRangeRequestCapabilities({\n        disableRange: false,\n        isHttp: true,\n        getResponseHeader: headerName => {\n          if (headerName === \"Accept-Ranges\") {\n            return \"none\";\n          } else if (headerName === \"Content-Length\") {\n            return 8;\n          }\n\n          throw new Error(`Unexpected headerName: ${headerName}`);\n        },\n        rangeChunkSize: 64\n      })).toEqual({\n        allowRangeRequests: false,\n        suggestedLength: 8\n      });\n    });","file":"unit/network_utils_spec.js","skipped":false,"dir":"test"},{"name":"rejects invalid Content-Encoding header values","suites":["network_utils","validateRangeRequestCapabilities"],"line":82,"updatePoint":{"line":82,"column":54,"index":2971},"code":"    it(\"rejects invalid Content-Encoding header values\", function () {\n      expect(validateRangeRequestCapabilities({\n        disableRange: false,\n        isHttp: true,\n        getResponseHeader: headerName => {\n          if (headerName === \"Accept-Ranges\") {\n            return \"bytes\";\n          } else if (headerName === \"Content-Encoding\") {\n            return \"gzip\";\n          } else if (headerName === \"Content-Length\") {\n            return 8;\n          }\n\n          throw new Error(`Unexpected headerName: ${headerName}`);\n        },\n        rangeChunkSize: 64\n      })).toEqual({\n        allowRangeRequests: false,\n        suggestedLength: 8\n      });\n    });","file":"unit/network_utils_spec.js","skipped":false,"dir":"test"},{"name":"rejects invalid Content-Length header values","suites":["network_utils","validateRangeRequestCapabilities"],"line":103,"updatePoint":{"line":103,"column":52,"index":3639},"code":"    it(\"rejects invalid Content-Length header values\", function () {\n      expect(validateRangeRequestCapabilities({\n        disableRange: false,\n        isHttp: true,\n        getResponseHeader: headerName => {\n          if (headerName === \"Accept-Ranges\") {\n            return \"bytes\";\n          } else if (headerName === \"Content-Encoding\") {\n            return null;\n          } else if (headerName === \"Content-Length\") {\n            return \"eight\";\n          }\n\n          throw new Error(`Unexpected headerName: ${headerName}`);\n        },\n        rangeChunkSize: 64\n      })).toEqual({\n        allowRangeRequests: false,\n        suggestedLength: undefined\n      });\n    });","file":"unit/network_utils_spec.js","skipped":false,"dir":"test"},{"name":"rejects file sizes that are too small for range requests","suites":["network_utils","validateRangeRequestCapabilities"],"line":124,"updatePoint":{"line":124,"column":64,"index":4331},"code":"    it(\"rejects file sizes that are too small for range requests\", function () {\n      expect(validateRangeRequestCapabilities({\n        disableRange: false,\n        isHttp: true,\n        getResponseHeader: headerName => {\n          if (headerName === \"Accept-Ranges\") {\n            return \"bytes\";\n          } else if (headerName === \"Content-Encoding\") {\n            return null;\n          } else if (headerName === \"Content-Length\") {\n            return 8;\n          }\n\n          throw new Error(`Unexpected headerName: ${headerName}`);\n        },\n        rangeChunkSize: 64\n      })).toEqual({\n        allowRangeRequests: false,\n        suggestedLength: 8\n      });\n    });","file":"unit/network_utils_spec.js","skipped":false,"dir":"test"},{"name":"accepts file sizes large enough for range requests","suites":["network_utils","validateRangeRequestCapabilities"],"line":145,"updatePoint":{"line":145,"column":58,"index":5003},"code":"    it(\"accepts file sizes large enough for range requests\", function () {\n      expect(validateRangeRequestCapabilities({\n        disableRange: false,\n        isHttp: true,\n        getResponseHeader: headerName => {\n          if (headerName === \"Accept-Ranges\") {\n            return \"bytes\";\n          } else if (headerName === \"Content-Encoding\") {\n            return null;\n          } else if (headerName === \"Content-Length\") {\n            return 8192;\n          }\n\n          throw new Error(`Unexpected headerName: ${headerName}`);\n        },\n        rangeChunkSize: 64\n      })).toEqual({\n        allowRangeRequests: true,\n        suggestedLength: 8192\n      });\n    });","file":"unit/network_utils_spec.js","skipped":false,"dir":"test"},{"name":"returns null when content disposition header is blank","suites":["network_utils","extractFilenameFromHeader"],"line":168,"updatePoint":{"line":168,"column":61,"index":5743},"code":"    it(\"returns null when content disposition header is blank\", function () {\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return null;\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toBeNull();\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return undefined;\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toBeNull();\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return \"\";\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toBeNull();\n    });","file":"unit/network_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets the filename from the response header","suites":["network_utils","extractFilenameFromHeader"],"line":191,"updatePoint":{"line":191,"column":50,"index":6505},"code":"    it(\"gets the filename from the response header\", function () {\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return \"inline\";\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toBeNull();\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return \"attachment\";\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toBeNull();\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return 'attachment; filename=\"filename.pdf\"';\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toEqual(\"filename.pdf\");\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return 'attachment; filename=\"filename.pdf and spaces.pdf\"';\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toEqual(\"filename.pdf and spaces.pdf\");\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return 'attachment; filename=\"tl;dr.pdf\"';\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toEqual(\"tl;dr.pdf\");\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return \"attachment; filename=filename.pdf\";\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toEqual(\"filename.pdf\");\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return \"attachment; filename=filename.pdf someotherparam\";\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toEqual(\"filename.pdf\");\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return 'attachment; filename=\"%e4%b8%ad%e6%96%87.pdf\"';\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toEqual(\"中文.pdf\");\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return 'attachment; filename=\"100%.pdf\"';\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toEqual(\"100%.pdf\");\n    });","file":"unit/network_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets the filename from the response header (RFC 6266)","suites":["network_utils","extractFilenameFromHeader"],"line":256,"updatePoint":{"line":256,"column":61,"index":9008},"code":"    it(\"gets the filename from the response header (RFC 6266)\", function () {\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return \"attachment; filename*=filename.pdf\";\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toEqual(\"filename.pdf\");\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return \"attachment; filename*=''filename.pdf\";\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toEqual(\"filename.pdf\");\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return \"attachment; filename*=utf-8''filename.pdf\";\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toEqual(\"filename.pdf\");\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return \"attachment; filename=no.pdf; filename*=utf-8''filename.pdf\";\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toEqual(\"filename.pdf\");\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return \"attachment; filename*=utf-8''filename.pdf; filename=no.pdf\";\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toEqual(\"filename.pdf\");\n    });","file":"unit/network_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets the filename from the response header (RFC 2231)","suites":["network_utils","extractFilenameFromHeader"],"line":293,"updatePoint":{"line":293,"column":61,"index":10516},"code":"    it(\"gets the filename from the response header (RFC 2231)\", function () {\n      // Tests continuations (RFC 2231 section 3, via RFC 5987 section 3.1).\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return \"attachment; filename*0=filename; filename*1=.pdf\";\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toEqual(\"filename.pdf\");\n    });","file":"unit/network_utils_spec.js","skipped":false,"dir":"test"},{"name":"only extracts filename with pdf extension","suites":["network_utils","extractFilenameFromHeader"],"line":303,"updatePoint":{"line":303,"column":49,"index":10954},"code":"    it(\"only extracts filename with pdf extension\", function () {\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return 'attachment; filename=\"filename.png\"';\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toBeNull();\n    });","file":"unit/network_utils_spec.js","skipped":false,"dir":"test"},{"name":"extension validation is case insensitive","suites":["network_utils","extractFilenameFromHeader"],"line":312,"updatePoint":{"line":312,"column":48,"index":11288},"code":"    it(\"extension validation is case insensitive\", function () {\n      expect(extractFilenameFromHeader(headerName => {\n        if (headerName === \"Content-Disposition\") {\n          return 'form-data; name=\"fieldName\"; filename=\"file.PdF\"';\n        }\n\n        throw new Error(`Unexpected headerName: ${headerName}`);\n      })).toEqual(\"file.PdF\");\n    });","file":"unit/network_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles missing PDF file responses","suites":["network_utils","createResponseStatusError"],"line":323,"updatePoint":{"line":323,"column":42,"index":11698},"code":"    it(\"handles missing PDF file responses\", function () {\n      expect(createResponseStatusError(404, \"https://foo.com/bar.pdf\")).toEqual(new MissingPDFException('Missing PDF \"https://foo.com/bar.pdf\".'));\n      expect(createResponseStatusError(0, \"file://foo.pdf\")).toEqual(new MissingPDFException('Missing PDF \"file://foo.pdf\".'));\n    });","file":"unit/network_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles unexpected responses","suites":["network_utils","createResponseStatusError"],"line":327,"updatePoint":{"line":327,"column":36,"index":12035},"code":"    it(\"handles unexpected responses\", function () {\n      expect(createResponseStatusError(302, \"https://foo.com/bar.pdf\")).toEqual(new UnexpectedResponseException(\"Unexpected server response (302) while retrieving PDF \" + '\"https://foo.com/bar.pdf\".'));\n      expect(createResponseStatusError(0, \"https://foo.com/bar.pdf\")).toEqual(new UnexpectedResponseException(\"Unexpected server response (0) while retrieving PDF \" + '\"https://foo.com/bar.pdf\".'));\n    });","file":"unit/network_utils_spec.js","skipped":false,"dir":"test"},{"name":"accepts valid response statuses","suites":["network_utils","validateResponseStatus"],"line":333,"updatePoint":{"line":333,"column":39,"index":12558},"code":"    it(\"accepts valid response statuses\", function () {\n      expect(validateResponseStatus(200)).toEqual(true);\n      expect(validateResponseStatus(206)).toEqual(true);\n    });","file":"unit/network_utils_spec.js","skipped":false,"dir":"test"},{"name":"rejects invalid response statuses","suites":["network_utils","validateResponseStatus"],"line":337,"updatePoint":{"line":337,"column":41,"index":12738},"code":"    it(\"rejects invalid response statuses\", function () {\n      expect(validateResponseStatus(302)).toEqual(false);\n      expect(validateResponseStatus(404)).toEqual(false);\n      expect(validateResponseStatus(null)).toEqual(false);\n      expect(validateResponseStatus(undefined)).toEqual(false);\n    });","file":"unit/network_utils_spec.js","skipped":false,"dir":"test"},{"name":"read both http(s) and filesystem pdf files","suites":["node_stream"],"line":81,"updatePoint":{"line":81,"column":48,"index":2815},"code":"  it(\"read both http(s) and filesystem pdf files\", async function () {\n    const stream1 = new PDFNodeStream({\n      url: `http://127.0.0.1:${port}/tracemonkey.pdf`,\n      rangeChunkSize: 65536,\n      disableStream: true,\n      disableRange: true\n    });\n    const stream2 = new PDFNodeStream({\n      url: pdf,\n      rangeChunkSize: 65536,\n      disableStream: true,\n      disableRange: true\n    });\n    const fullReader1 = stream1.getFullReader();\n    const fullReader2 = stream2.getFullReader();\n    let isStreamingSupported1, isRangeSupported1;\n    const promise1 = fullReader1.headersReady.then(() => {\n      isStreamingSupported1 = fullReader1.isStreamingSupported;\n      isRangeSupported1 = fullReader1.isRangeSupported;\n    });\n    let isStreamingSupported2, isRangeSupported2;\n    const promise2 = fullReader2.headersReady.then(() => {\n      isStreamingSupported2 = fullReader2.isStreamingSupported;\n      isRangeSupported2 = fullReader2.isRangeSupported;\n    });\n    let len1 = 0,\n        len2 = 0;\n\n    const read1 = function () {\n      return fullReader1.read().then(function (result) {\n        if (result.done) {\n          return undefined;\n        }\n\n        len1 += result.value.byteLength;\n        return read1();\n      });\n    };\n\n    const read2 = function () {\n      return fullReader2.read().then(function (result) {\n        if (result.done) {\n          return undefined;\n        }\n\n        len2 += result.value.byteLength;\n        return read2();\n      });\n    };\n\n    await Promise.all([read1(), read2(), promise1, promise2]);\n    expect(isStreamingSupported1).toEqual(false);\n    expect(isRangeSupported1).toEqual(false);\n    expect(isStreamingSupported2).toEqual(false);\n    expect(isRangeSupported2).toEqual(false);\n    expect(len1).toEqual(pdfLength);\n    expect(len1).toEqual(len2);\n  });","file":"unit/node_stream_spec.js","skipped":false,"dir":"test"},{"name":"read custom ranges for both http(s) and filesystem urls","suites":["node_stream"],"line":139,"updatePoint":{"line":139,"column":61,"index":4643},"code":"  it(\"read custom ranges for both http(s) and filesystem urls\", async function () {\n    const rangeSize = 32768;\n    const stream1 = new PDFNodeStream({\n      url: `http://127.0.0.1:${port}/tracemonkey.pdf`,\n      length: pdfLength,\n      rangeChunkSize: rangeSize,\n      disableStream: true,\n      disableRange: false\n    });\n    const stream2 = new PDFNodeStream({\n      url: pdf,\n      length: pdfLength,\n      rangeChunkSize: rangeSize,\n      disableStream: true,\n      disableRange: false\n    });\n    const fullReader1 = stream1.getFullReader();\n    const fullReader2 = stream2.getFullReader();\n    let isStreamingSupported1, isRangeSupported1, fullReaderCancelled1;\n    let isStreamingSupported2, isRangeSupported2, fullReaderCancelled2;\n    const promise1 = fullReader1.headersReady.then(function () {\n      isStreamingSupported1 = fullReader1.isStreamingSupported;\n      isRangeSupported1 = fullReader1.isRangeSupported; // we shall be able to close the full reader without issues\n\n      fullReader1.cancel(new AbortException(\"Don't need fullReader1.\"));\n      fullReaderCancelled1 = true;\n    });\n    const promise2 = fullReader2.headersReady.then(function () {\n      isStreamingSupported2 = fullReader2.isStreamingSupported;\n      isRangeSupported2 = fullReader2.isRangeSupported;\n      fullReader2.cancel(new AbortException(\"Don't need fullReader2.\"));\n      fullReaderCancelled2 = true;\n    }); // Skipping fullReader results, requesting something from the PDF end.\n\n    const tailSize = pdfLength % rangeSize || rangeSize;\n    const range11Reader = stream1.getRangeReader(pdfLength - tailSize - rangeSize, pdfLength - tailSize);\n    const range12Reader = stream1.getRangeReader(pdfLength - tailSize, pdfLength);\n    const range21Reader = stream2.getRangeReader(pdfLength - tailSize - rangeSize, pdfLength - tailSize);\n    const range22Reader = stream2.getRangeReader(pdfLength - tailSize, pdfLength);\n    const result11 = {\n      value: 0\n    },\n          result12 = {\n      value: 0\n    };\n    const result21 = {\n      value: 0\n    },\n          result22 = {\n      value: 0\n    };\n\n    const read = function (reader, lenResult) {\n      return reader.read().then(function (result) {\n        if (result.done) {\n          return undefined;\n        }\n\n        lenResult.value += result.value.byteLength;\n        return read(reader, lenResult);\n      });\n    };\n\n    await Promise.all([read(range11Reader, result11), read(range12Reader, result12), read(range21Reader, result21), read(range22Reader, result22), promise1, promise2]);\n    expect(result11.value).toEqual(rangeSize);\n    expect(result12.value).toEqual(tailSize);\n    expect(result21.value).toEqual(rangeSize);\n    expect(result22.value).toEqual(tailSize);\n    expect(isStreamingSupported1).toEqual(false);\n    expect(isRangeSupported1).toEqual(true);\n    expect(fullReaderCancelled1).toEqual(true);\n    expect(isStreamingSupported2).toEqual(false);\n    expect(isRangeSupported2).toEqual(true);\n    expect(fullReaderCancelled2).toEqual(true);\n  });","file":"unit/node_stream_spec.js","skipped":false,"dir":"test"},{"name":"should skip over the EI marker if it is found","suites":["parser","Parser","inlineStreamSkipEI"],"line":22,"updatePoint":{"line":22,"column":55,"index":1021},"code":"      it(\"should skip over the EI marker if it is found\", function () {\n        const string = \"q 1 0 0 1 0 0 cm BI /W 10 /H 10 /BPC 1 \" + \"/F /A85 ID abc123~> EI Q\";\n        const input = new StringStream(string);\n        const parser = new Parser({\n          lexer: new Lexer(input),\n          xref: null,\n          allowStreams: true\n        });\n        parser.inlineStreamSkipEI(input);\n        expect(input.pos).toEqual(string.indexOf(\"Q\"));\n        expect(input.peekByte()).toEqual(0x51); // 'Q'\n      });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should skip to the end of stream if the EI marker is not found","suites":["parser","Parser","inlineStreamSkipEI"],"line":34,"updatePoint":{"line":34,"column":72,"index":1550},"code":"      it(\"should skip to the end of stream if the EI marker is not found\", function () {\n        const string = \"q 1 0 0 1 0 0 cm BI /W 10 /H 10 /BPC 1 /F /A85 ID abc123~> Q\";\n        const input = new StringStream(string);\n        const parser = new Parser({\n          lexer: new Lexer(input),\n          xref: null,\n          allowStreams: true\n        });\n        parser.inlineStreamSkipEI(input);\n        expect(input.pos).toEqual(string.length);\n        expect(input.peekByte()).toEqual(-1);\n      });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should return and set -1 when the end of the stream is reached","suites":["parser","Lexer","nextChar"],"line":50,"updatePoint":{"line":50,"column":72,"index":2143},"code":"      it(\"should return and set -1 when the end of the stream is reached\", function () {\n        const input = new StringStream(\"\");\n        const lexer = new Lexer(input);\n        expect(lexer.nextChar()).toEqual(-1);\n        expect(lexer.currentChar).toEqual(-1);\n      });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should return and set the character after the current position","suites":["parser","Lexer","nextChar"],"line":56,"updatePoint":{"line":56,"column":72,"index":2419},"code":"      it(\"should return and set the character after the current position\", function () {\n        const input = new StringStream(\"123\");\n        const lexer = new Lexer(input);\n        expect(lexer.nextChar()).toEqual(0x32); // '2'\n\n        expect(lexer.currentChar).toEqual(0x32); // '2'\n      });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should only return -1 when the end of the stream is reached","suites":["parser","Lexer","peekChar"],"line":65,"updatePoint":{"line":65,"column":69,"index":2761},"code":"      it(\"should only return -1 when the end of the stream is reached\", function () {\n        const input = new StringStream(\"\");\n        const lexer = new Lexer(input);\n        expect(lexer.peekChar()).toEqual(-1);\n        expect(lexer.currentChar).toEqual(-1);\n      });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should only return the character after the current position","suites":["parser","Lexer","peekChar"],"line":71,"updatePoint":{"line":71,"column":69,"index":3034},"code":"      it(\"should only return the character after the current position\", function () {\n        const input = new StringStream(\"123\");\n        const lexer = new Lexer(input);\n        expect(lexer.peekChar()).toEqual(0x32); // '2'\n\n        expect(lexer.currentChar).toEqual(0x31); // '1'\n      });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should stop parsing numbers at the end of stream","suites":["parser","Lexer","getNumber"],"line":80,"updatePoint":{"line":80,"column":58,"index":3366},"code":"      it(\"should stop parsing numbers at the end of stream\", function () {\n        const input = new StringStream(\"11.234\");\n        const lexer = new Lexer(input);\n        expect(lexer.getNumber()).toEqual(11.234);\n      });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should parse PostScript numbers","suites":["parser","Lexer","getNumber"],"line":85,"updatePoint":{"line":85,"column":41,"index":3575},"code":"      it(\"should parse PostScript numbers\", function () {\n        const numbers = [\"-.002\", \"34.5\", \"-3.62\", \"123.6e10\", \"1E-5\", \"-1.\", \"0.0\", \"123\", \"-98\", \"43445\", \"0\", \"+17\"];\n\n        for (const number of numbers) {\n          const input = new StringStream(number);\n          const lexer = new Lexer(input);\n          const result = lexer.getNumber(),\n                expected = parseFloat(number);\n\n          if (result !== expected && Math.abs(result - expected) < 1e-15) {\n            console.error(`Fuzzy matching \"${result}\" with \"${expected}\" to ` + \"work-around rounding bugs in Chromium browsers.\");\n            expect(true).toEqual(true);\n            continue;\n          }\n\n          expect(result).toEqual(expected);\n        }\n      });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should ignore double negative before number","suites":["parser","Lexer","getNumber"],"line":103,"updatePoint":{"line":103,"column":53,"index":4338},"code":"      it(\"should ignore double negative before number\", function () {\n        const input = new StringStream(\"--205.88\");\n        const lexer = new Lexer(input);\n        expect(lexer.getNumber()).toEqual(-205.88);\n      });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should ignore minus signs in the middle of number","suites":["parser","Lexer","getNumber"],"line":108,"updatePoint":{"line":108,"column":59,"index":4568},"code":"      it(\"should ignore minus signs in the middle of number\", function () {\n        const input = new StringStream(\"205--.88\");\n        const lexer = new Lexer(input);\n        expect(lexer.getNumber()).toEqual(205.88);\n      });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should ignore line-breaks between operator and digit in number","suites":["parser","Lexer","getNumber"],"line":113,"updatePoint":{"line":113,"column":72,"index":4810},"code":"      it(\"should ignore line-breaks between operator and digit in number\", function () {\n        const minusInput = new StringStream(\"-\\r\\n205.88\");\n        const minusLexer = new Lexer(minusInput);\n        expect(minusLexer.getNumber()).toEqual(-205.88);\n        const plusInput = new StringStream(\"+\\r\\n205.88\");\n        const plusLexer = new Lexer(plusInput);\n        expect(plusLexer.getNumber()).toEqual(205.88);\n      });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should treat a single decimal point, or minus sign, as zero","suites":["parser","Lexer","getNumber"],"line":121,"updatePoint":{"line":121,"column":69,"index":5235},"code":"      it(\"should treat a single decimal point, or minus sign, as zero\", function () {\n        const dotInput = new StringStream(\".\");\n        const dotLexer = new Lexer(dotInput);\n        expect(dotLexer.getNumber()).toEqual(0);\n        const minusInput = new StringStream(\"-\");\n        const minusLexer = new Lexer(minusInput);\n        expect(minusLexer.getNumber()).toEqual(0);\n        const numbers = [\"..\", \"-.\", \"+.\", \"-\\r\\n.\", \"+\\r\\n.\"];\n\n        for (const number of numbers) {\n          const invalidInput = new StringStream(number);\n          const invalidLexer = new Lexer(invalidInput);\n          expect(function () {\n            return invalidLexer.getNumber();\n          }).toThrowError(FormatError, /^Invalid number:\\s/);\n        }\n      });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should handle glued numbers and operators","suites":["parser","Lexer","getNumber"],"line":138,"updatePoint":{"line":138,"column":51,"index":5973},"code":"      it(\"should handle glued numbers and operators\", function () {\n        const input = new StringStream(\"123ET\");\n        const lexer = new Lexer(input);\n        expect(lexer.getNumber()).toEqual(123); // The lexer must not have consumed the 'E'\n\n        expect(lexer.currentChar).toEqual(0x45); // 'E'\n      });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should stop parsing strings at the end of stream","suites":["parser","Lexer","getString"],"line":147,"updatePoint":{"line":147,"column":58,"index":6344},"code":"      it(\"should stop parsing strings at the end of stream\", function () {\n        const input = new StringStream(\"(1$4)\");\n\n        input.getByte = function (super_getByte) {\n          // Simulating end of file using null (see issue 2766).\n          const ch = super_getByte.call(input);\n          return ch === 0x24\n          /* '$' */\n          ? -1 : ch;\n        }.bind(input, input.getByte);\n\n        const lexer = new Lexer(input);\n        expect(lexer.getString()).toEqual(\"1\");\n      });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should ignore escaped CR and LF","suites":["parser","Lexer","getString"],"line":161,"updatePoint":{"line":161,"column":41,"index":6823},"code":"      it(\"should ignore escaped CR and LF\", function () {\n        // '(\\101\\<CR><LF>\\102)' should be parsed as 'AB'.\n        const input = new StringStream(\"(\\\\101\\\\\\r\\n\\\\102\\\\\\r\\\\103\\\\\\n\\\\104)\");\n        const lexer = new Lexer(input);\n        expect(lexer.getString()).toEqual(\"ABCD\");\n      });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should not throw exception on bad input","suites":["parser","Lexer","getHexString"],"line":169,"updatePoint":{"line":169,"column":49,"index":7180},"code":"      it(\"should not throw exception on bad input\", function () {\n        // '7 0 2 15 5 2 2 2 4 3 2 4' should be parsed as '70 21 55 22 24 32'.\n        const input = new StringStream(\"<7 0 2 15 5 2 2 2 4 3 2 4>\");\n        const lexer = new Lexer(input);\n        expect(lexer.getHexString()).toEqual('p!U\"$2');\n      });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should handle Names with invalid usage of NUMBER SIGN (#)","suites":["parser","Lexer","getName"],"line":177,"updatePoint":{"line":177,"column":67,"index":7565},"code":"      it(\"should handle Names with invalid usage of NUMBER SIGN (#)\", function () {\n        const inputNames = [\"/# 680 0 R\", \"/#AQwerty\", \"/#A<</B\"];\n        const expectedNames = [\"#\", \"#AQwerty\", \"#A\"];\n\n        for (let i = 0, ii = inputNames.length; i < ii; i++) {\n          const input = new StringStream(inputNames[i]);\n          const lexer = new Lexer(input);\n          expect(lexer.getName()).toEqual(Name.get(expectedNames[i]));\n        }\n      });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should not find a linearization dictionary","suites":["parser","Linearization"],"line":207,"updatePoint":{"line":207,"column":50,"index":8766},"code":"    it(\"should not find a linearization dictionary\", function () {\n      // Not an actual linearization dictionary.\n      // prettier-ignore\n      const stream1 = new StringStream(\"3 0 obj\\n\" + \"<<\\n\" + \"/Length 4622\\n\" + \"/Filter /FlateDecode\\n\" + \">>\\n\" + \"endobj\");\n      expect(Linearization.create(stream1)).toEqual(null); // Linearization dictionary with invalid version number.\n      // prettier-ignore\n\n      const stream2 = new StringStream(\"1 0 obj\\n\" + \"<<\\n\" + \"/Linearized 0\\n\" + \">>\\n\" + \"endobj\");\n      expect(Linearization.create(stream2)).toEqual(null);\n    });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should accept a valid linearization dictionary","suites":["parser","Linearization"],"line":217,"updatePoint":{"line":217,"column":54,"index":9350},"code":"    it(\"should accept a valid linearization dictionary\", function () {\n      // prettier-ignore\n      const stream = new StringStream(\"131 0 obj\\n\" + \"<<\\n\" + \"/Linearized 1\\n\" + \"/O 133\\n\" + \"/H [ 1388 863 ]\\n\" + \"/L 90\\n\" + \"/E 43573\\n\" + \"/N 18\\n\" + \"/T 193883\\n\" + \">>\\n\" + \"endobj\");\n      const expectedLinearizationDict = {\n        length: 90,\n        hints: [1388, 863],\n        objectNumberFirst: 133,\n        endFirst: 43573,\n        numPages: 18,\n        mainXRefEntriesOffset: 193883,\n        pageFirst: 0\n      };\n      expect(Linearization.create(stream)).toEqual(expectedLinearizationDict);\n    });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"should reject a linearization dictionary with invalid hint parameters","suites":["parser","Linearization"],"line":251,"updatePoint":{"line":251,"column":77,"index":11425},"code":"    it(\"should reject a linearization dictionary with invalid hint parameters\", function () {\n      // The /H parameter should be an array.\n      // prettier-ignore\n      const stream1 = new StringStream(\"1 0 obj\\n\" + \"<<\\n\" + \"/Linearized 1\\n\" + \"/O 133\\n\" + \"/H 1388\\n\" + \"/L 80\\n\" + \"/E 43573\\n\" + \"/N 18\\n\" + \"/T 193883\\n\" + \">>\\n\" + \"endobj\");\n      expect(function () {\n        return Linearization.create(stream1);\n      }).toThrow(new Error(\"Hint array in the linearization dictionary is invalid.\")); // The hint array should contain two, or four, elements.\n      // prettier-ignore\n\n      const stream2 = new StringStream(\"1 0 obj\\n\" + \"<<\\n\" + \"/Linearized 1\\n\" + \"/O 133\\n\" + \"/H [ 1388 ]\\n\" + \"/L 84\\n\" + \"/E 43573\\n\" + \"/N 18\\n\" + \"/T 193883\\n\" + \">>\\n\" + \"endobj\");\n      expect(function () {\n        return Linearization.create(stream2);\n      }).toThrow(new Error(\"Hint array in the linearization dictionary is invalid.\")); // The hint array should not contain zero.\n      // prettier-ignore\n\n      const stream3 = new StringStream(\"1 0 obj\\n\" + \"<<\\n\" + \"/Linearized 1\\n\" + \"/O 133\\n\" + \"/H [ 1388 863 0 234]\\n\" + \"/L 93\\n\" + \"/E 43573\\n\" + \"/N 18\\n\" + \"/T 193883\\n\" + \">>\\n\" + \"endobj\");\n      expect(function () {\n        return Linearization.create(stream3);\n      }).toThrow(new Error(\"Hint (2) in the linearization dictionary is invalid.\"));\n    });","file":"unit/parser_spec.js","skipped":false,"dir":"test"},{"name":"performs a normal search","suites":["pdf_find_controller"],"line":141,"updatePoint":{"line":141,"column":30,"index":4475},"code":"  it(\"performs a normal search\", async function () {\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController();\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"Dynamic\"\n      },\n      matchesPerPage: [11, 5, 0, 3, 0, 0, 0, 1, 1, 1, 0, 3, 4, 4],\n      selectedMatch: {\n        pageIndex: 0,\n        matchIndex: 0\n      }\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"performs a normal search and finds the previous result","suites":["pdf_find_controller"],"line":159,"updatePoint":{"line":159,"column":60,"index":4918},"code":"  it(\"performs a normal search and finds the previous result\", async function () {\n    // Page 14 (with page index 13) contains five results. By default, the\n    // first result (match index 0) is selected, so the previous result\n    // should be the fifth result (match index 4).\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController();\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"conference\",\n        findPrevious: true\n      },\n      matchesPerPage: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5],\n      selectedMatch: {\n        pageIndex: 13,\n        matchIndex: 4\n      }\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"performs a case sensitive search","suites":["pdf_find_controller"],"line":181,"updatePoint":{"line":181,"column":38,"index":5568},"code":"  it(\"performs a case sensitive search\", async function () {\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController();\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"Dynamic\",\n        caseSensitive: true\n      },\n      matchesPerPage: [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3],\n      selectedMatch: {\n        pageIndex: 0,\n        matchIndex: 0\n      }\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"performs an entire word search","suites":["pdf_find_controller"],"line":200,"updatePoint":{"line":200,"column":36,"index":6015},"code":"  it(\"performs an entire word search\", async function () {\n    // Page 13 contains both 'Government' and 'Governmental', so the latter\n    // should not be found with entire word search.\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController();\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"Government\",\n        entireWord: true\n      },\n      matchesPerPage: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\n      selectedMatch: {\n        pageIndex: 12,\n        matchIndex: 0\n      }\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"performs a multiple term (no phrase) search","suites":["pdf_find_controller"],"line":221,"updatePoint":{"line":221,"column":49,"index":6604},"code":"  it(\"performs a multiple term (no phrase) search\", async function () {\n    // Page 9 contains 'alternate' and pages 6 and 9 contain 'solution'.\n    // Both should be found for multiple term (no phrase) search.\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController();\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"alternate solution\",\n        phraseSearch: false\n      },\n      matchesPerPage: [0, 0, 0, 0, 0, 1, 0, 0, 4, 0, 0, 0, 0, 0],\n      selectedMatch: {\n        pageIndex: 5,\n        matchIndex: 0\n      }\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"performs a normal search, where the text is normalized","suites":["pdf_find_controller"],"line":242,"updatePoint":{"line":242,"column":60,"index":7225},"code":"  it(\"performs a normal search, where the text is normalized\", async function () {\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController(\"fraction-highlight.pdf\");\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"fraction\"\n      },\n      matchesPerPage: [3],\n      selectedMatch: {\n        pageIndex: 0,\n        matchIndex: 0\n      },\n      pageMatches: [[19, 46, 62]],\n      pageMatchesLength: [[8, 8, 8]]\n    });\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"1/2\"\n      },\n      matchesPerPage: [2],\n      selectedMatch: {\n        pageIndex: 0,\n        matchIndex: 0\n      },\n      pageMatches: [[27, 54]],\n      pageMatchesLength: [[1, 1]]\n    });\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"½\"\n      },\n      matchesPerPage: [2],\n      selectedMatch: {\n        pageIndex: 0,\n        matchIndex: 0\n      },\n      pageMatches: [[27, 54]],\n      pageMatchesLength: [[1, 1]]\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"performs a normal search, where the text with diacritics is normalized","suites":["pdf_find_controller"],"line":290,"updatePoint":{"line":290,"column":76,"index":8310},"code":"  it(\"performs a normal search, where the text with diacritics is normalized\", async function () {\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController(\"french_diacritics.pdf\");\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"a\"\n      },\n      matchesPerPage: [6],\n      selectedMatch: {\n        pageIndex: 0,\n        matchIndex: 0\n      },\n      pageMatches: [[0, 2, 4, 6, 8, 10]],\n      pageMatchesLength: [[1, 1, 1, 1, 1, 1]]\n    });\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"u\"\n      },\n      matchesPerPage: [6],\n      selectedMatch: {\n        pageIndex: 0,\n        matchIndex: 0\n      },\n      pageMatches: [[44, 46, 48, 50, 52, 54]],\n      pageMatchesLength: [[1, 1, 1, 1, 1, 1]]\n    });\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"ë\",\n        matchDiacritics: true\n      },\n      matchesPerPage: [2],\n      selectedMatch: {\n        pageIndex: 0,\n        matchIndex: 0\n      },\n      pageMatches: [[28, 30]],\n      pageMatchesLength: [[1, 1]]\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"performs a search where one of the results contains an hyphen","suites":["pdf_find_controller"],"line":339,"updatePoint":{"line":339,"column":67,"index":9451},"code":"  it(\"performs a search where one of the results contains an hyphen\", async function () {\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController();\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"optimiz\"\n      },\n      matchesPerPage: [1, 4, 2, 3, 3, 0, 2, 9, 1, 0, 0, 6, 3, 4],\n      selectedMatch: {\n        pageIndex: 0,\n        matchIndex: 0\n      }\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"performs a search where the result is on two lines","suites":["pdf_find_controller"],"line":357,"updatePoint":{"line":357,"column":56,"index":9889},"code":"  it(\"performs a search where the result is on two lines\", async function () {\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController();\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"user experience\"\n      },\n      matchesPerPage: [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      selectedMatch: {\n        pageIndex: 0,\n        matchIndex: 0\n      },\n      pageMatches: [[2743]],\n      pageMatchesLength: [[14]]\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"performs a search where the result is on two lines with a punctuation at eol","suites":["pdf_find_controller"],"line":377,"updatePoint":{"line":377,"column":82,"index":10423},"code":"  it(\"performs a search where the result is on two lines with a punctuation at eol\", async function () {\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController();\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"version.the\"\n      },\n      matchesPerPage: [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      selectedMatch: {\n        pageIndex: 1,\n        matchIndex: 0\n      },\n      pageMatches: [[], [1493]],\n      pageMatchesLength: [[], [11]]\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"performs a search with a minus sign in the query","suites":["pdf_find_controller"],"line":397,"updatePoint":{"line":397,"column":54,"index":10933},"code":"  it(\"performs a search with a minus sign in the query\", async function () {\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController();\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"trace-based  just-in-time\"\n      },\n      matchesPerPage: [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\n      selectedMatch: {\n        pageIndex: 0,\n        matchIndex: 0\n      },\n      pageMatches: [[0], [], [], [], [], [], [], [], [], [], [], [], [], [2087]],\n      pageMatchesLength: [[24], [], [], [], [], [], [], [], [], [], [], [], [], [24]]\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"performs a search with square brackets in the query","suites":["pdf_find_controller"],"line":417,"updatePoint":{"line":417,"column":57,"index":11559},"code":"  it(\"performs a search with square brackets in the query\", async function () {\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController();\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"[Programming Languages]\"\n      },\n      matchesPerPage: [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      selectedMatch: {\n        pageIndex: 0,\n        matchIndex: 0\n      },\n      pageMatches: [[1501]],\n      pageMatchesLength: [[25]]\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"performs a search with parenthesis in the query","suites":["pdf_find_controller"],"line":437,"updatePoint":{"line":437,"column":53,"index":12072},"code":"  it(\"performs a search with parenthesis in the query\", async function () {\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController();\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"\\t   (checks)\"\n      },\n      matchesPerPage: [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      selectedMatch: {\n        pageIndex: 1,\n        matchIndex: 0\n      },\n      pageMatches: [[], [201]],\n      pageMatchesLength: [[], [9]]\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"performs a search with a final dot in the query","suites":["pdf_find_controller"],"line":457,"updatePoint":{"line":457,"column":53,"index":12581},"code":"  it(\"performs a search with a final dot in the query\", async function () {\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController(); // The whitespace after the dot mustn't be matched.\n\n    const query = \"complex applications.\";\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query\n      },\n      matchesPerPage: [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      selectedMatch: {\n        pageIndex: 0,\n        matchIndex: 0\n      },\n      pageMatches: [[1946]],\n      pageMatchesLength: [[21]]\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"performs a search with a dot in the query and a missing whitespace","suites":["pdf_find_controller"],"line":479,"updatePoint":{"line":479,"column":72,"index":13182},"code":"  it(\"performs a search with a dot in the query and a missing whitespace\", async function () {\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController(); // The whitespace after the dot must be matched.\n\n    const query = \"complex applications.J\";\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query\n      },\n      matchesPerPage: [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      selectedMatch: {\n        pageIndex: 0,\n        matchIndex: 0\n      },\n      pageMatches: [[1946]],\n      pageMatchesLength: [[23]]\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"performs a search with a dot followed by a whitespace in the query","suites":["pdf_find_controller"],"line":501,"updatePoint":{"line":501,"column":72,"index":13781},"code":"  it(\"performs a search with a dot followed by a whitespace in the query\", async function () {\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController();\n    const query = \"complex applications. j\";\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query\n      },\n      matchesPerPage: [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      selectedMatch: {\n        pageIndex: 0,\n        matchIndex: 0\n      },\n      pageMatches: [[1946]],\n      pageMatchesLength: [[23]]\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"performs a search in a text containing diacritics before -\\n","suites":["pdf_find_controller"],"line":522,"updatePoint":{"line":522,"column":67,"index":14326},"code":"  it(\"performs a search in a text containing diacritics before -\\\\n\", async function () {\n    if (isNodeJS) {\n      pending(\"Linked test-cases are not supported in Node.js.\");\n    }\n\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController(\"issue14562.pdf\");\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"ä\",\n        matchDiacritics: true\n      },\n      matchesPerPage: [80],\n      selectedMatch: {\n        pageIndex: 0,\n        matchIndex: 0\n      },\n      pageMatches: [[302, 340, 418, 481, 628, 802, 983, 989, 1015, 1063, 1084, 1149, 1157, 1278, 1346, 1394, 1402, 1424, 1500, 1524, 1530, 1686, 1776, 1788, 1859, 1881, 1911, 1948, 2066, 2076, 2163, 2180, 2215, 2229, 2274, 2324, 2360, 2402, 2413, 2424, 2463, 2532, 2538, 2553, 2562, 2576, 2602, 2613, 2638, 2668, 2792, 2805, 2836, 2847, 2858, 2895, 2901, 2915, 2939, 2959, 3089, 3236, 3246, 3336, 3384, 3391, 3465, 3474, 3482, 3499, 3687, 3693, 3708, 3755, 3786, 3862, 3974, 4049, 4055, 4068]],\n      pageMatchesLength: [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"performs a search in a text containing some Hangul syllables","suites":["pdf_find_controller"],"line":547,"updatePoint":{"line":547,"column":66,"index":15634},"code":"  it(\"performs a search in a text containing some Hangul syllables\", async function () {\n    const {\n      eventBus,\n      pdfFindController\n    } = await initPdfFindController(\"bug1771477.pdf\");\n    await testSearch({\n      eventBus,\n      pdfFindController,\n      state: {\n        query: \"안녕하세요 세계\"\n      },\n      matchesPerPage: [1],\n      selectedMatch: {\n        pageIndex: 0,\n        matchIndex: 0\n      },\n      pageMatches: [[139]],\n      pageMatchesLength: [[8]]\n    });\n  });","file":"unit/pdf_find_controller_spec.js","skipped":false,"dir":"test"},{"name":"gets expected character types","suites":["pdf_find_utils","getCharacterType"],"line":18,"updatePoint":{"line":18,"column":37,"index":802},"code":"    it(\"gets expected character types\", function () {\n      const characters = {\n        A: CharacterType.ALPHA_LETTER,\n        a: CharacterType.ALPHA_LETTER,\n        0: CharacterType.ALPHA_LETTER,\n        5: CharacterType.ALPHA_LETTER,\n        \"\\xC4\": CharacterType.ALPHA_LETTER,\n        // \"Ä\"\n        \"\\xE4\": CharacterType.ALPHA_LETTER,\n        // \"ä\"\n        _: CharacterType.ALPHA_LETTER,\n        \" \": CharacterType.SPACE,\n        \"\\t\": CharacterType.SPACE,\n        \"\\r\": CharacterType.SPACE,\n        \"\\n\": CharacterType.SPACE,\n        \"\\xA0\": CharacterType.SPACE,\n        // nbsp\n        \"-\": CharacterType.PUNCT,\n        \",\": CharacterType.PUNCT,\n        \".\": CharacterType.PUNCT,\n        \";\": CharacterType.PUNCT,\n        \":\": CharacterType.PUNCT,\n        \"\\u2122\": CharacterType.ALPHA_LETTER,\n        // trademark\n        \"\\u0E25\": CharacterType.THAI_LETTER,\n        \"\\u4000\": CharacterType.HAN_LETTER,\n        \"\\uF950\": CharacterType.HAN_LETTER,\n        \"\\u30C0\": CharacterType.KATAKANA_LETTER,\n        \"\\u3050\": CharacterType.HIRAGANA_LETTER,\n        \"\\uFF80\": CharacterType.HALFWIDTH_KATAKANA_LETTER\n      };\n\n      for (const character in characters) {\n        const charCode = character.charCodeAt(0);\n        const type = characters[character];\n        expect(getCharacterType(charCode)).toEqual(type);\n      }\n    });","file":"unit/pdf_find_utils_spec.js","skipped":false,"dir":"test"},{"name":"should reject non-equal destination hashes","suites":["pdf_history","isDestHashesEqual"],"line":18,"updatePoint":{"line":18,"column":50,"index":815},"code":"    it(\"should reject non-equal destination hashes\", function () {\n      expect(isDestHashesEqual(null, \"page.157\")).toEqual(false);\n      expect(isDestHashesEqual(\"title.0\", \"page.157\")).toEqual(false);\n      expect(isDestHashesEqual(\"page=1&zoom=auto\", \"page.157\")).toEqual(false);\n      expect(isDestHashesEqual(\"nameddest-page.157\", \"page.157\")).toEqual(false);\n      expect(isDestHashesEqual(\"page.157\", \"nameddest=page.157\")).toEqual(false);\n      const destArrayString = JSON.stringify([{\n        num: 3757,\n        gen: 0\n      }, {\n        name: \"XYZ\"\n      }, 92.918, 748.972, null]);\n      expect(isDestHashesEqual(destArrayString, \"page.157\")).toEqual(false);\n      expect(isDestHashesEqual(\"page.157\", destArrayString)).toEqual(false);\n    });","file":"unit/pdf_history_spec.js","skipped":false,"dir":"test"},{"name":"should accept equal destination hashes","suites":["pdf_history","isDestHashesEqual"],"line":33,"updatePoint":{"line":33,"column":46,"index":1568},"code":"    it(\"should accept equal destination hashes\", function () {\n      expect(isDestHashesEqual(\"page.157\", \"page.157\")).toEqual(true);\n      expect(isDestHashesEqual(\"nameddest=page.157\", \"page.157\")).toEqual(true);\n      expect(isDestHashesEqual(\"nameddest=page.157&zoom=100\", \"page.157\")).toEqual(true);\n    });","file":"unit/pdf_history_spec.js","skipped":false,"dir":"test"},{"name":"should reject non-equal destination arrays","suites":["pdf_history","isDestArraysEqual"],"line":70,"updatePoint":{"line":70,"column":50,"index":2443},"code":"    it(\"should reject non-equal destination arrays\", function () {\n      expect(isDestArraysEqual(firstDest, undefined)).toEqual(false);\n      expect(isDestArraysEqual(firstDest, [1, 2, 3, 4, 5])).toEqual(false);\n      expect(isDestArraysEqual(firstDest, secondDest)).toEqual(false);\n      expect(isDestArraysEqual(firstDest, thirdDest)).toEqual(false);\n      expect(isDestArraysEqual(firstDest, fourthDest)).toEqual(false);\n    });","file":"unit/pdf_history_spec.js","skipped":false,"dir":"test"},{"name":"should accept equal destination arrays","suites":["pdf_history","isDestArraysEqual"],"line":77,"updatePoint":{"line":77,"column":46,"index":2872},"code":"    it(\"should accept equal destination arrays\", function () {\n      expect(isDestArraysEqual(firstDest, firstDest)).toEqual(true);\n      expect(isDestArraysEqual(firstDest, fifthDest)).toEqual(true);\n      const firstDestCopy = firstDest.slice();\n      expect(firstDest).not.toBe(firstDestCopy);\n      expect(isDestArraysEqual(firstDest, firstDestCopy)).toEqual(true);\n    });","file":"unit/pdf_history_spec.js","skipped":false,"dir":"test"},{"name":"should retain the given name","suites":["primitives","Name"],"line":20,"updatePoint":{"line":20,"column":36,"index":933},"code":"    it(\"should retain the given name\", function () {\n      const givenName = \"Font\";\n      const name = Name.get(givenName);\n      expect(name.name).toEqual(givenName);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should create only one object for a name and cache it","suites":["primitives","Name"],"line":25,"updatePoint":{"line":25,"column":61,"index":1135},"code":"    it(\"should create only one object for a name and cache it\", function () {\n      const firstFont = Name.get(\"Font\");\n      const secondFont = Name.get(\"Font\");\n      const firstSubtype = Name.get(\"Subtype\");\n      const secondSubtype = Name.get(\"Subtype\");\n      expect(firstFont).toBe(secondFont);\n      expect(firstSubtype).toBe(secondSubtype);\n      expect(firstFont).not.toBe(firstSubtype);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should create only one object for *empty* names and cache it","suites":["primitives","Name"],"line":34,"updatePoint":{"line":34,"column":68,"index":1548},"code":"    it(\"should create only one object for *empty* names and cache it\", function () {\n      const firstEmpty = Name.get(\"\");\n      const secondEmpty = Name.get(\"\");\n      const normalName = Name.get(\"string\");\n      expect(firstEmpty).toBe(secondEmpty);\n      expect(firstEmpty).not.toBe(normalName);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should not accept to create a non-string name","suites":["primitives","Name"],"line":41,"updatePoint":{"line":41,"column":53,"index":1841},"code":"    it(\"should not accept to create a non-string name\", function () {\n      expect(function () {\n        Name.get(123);\n      }).toThrow(new Error('Name: The \"name\" must be a string.'));\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should retain the given cmd name","suites":["primitives","Cmd"],"line":48,"updatePoint":{"line":48,"column":40,"index":2061},"code":"    it(\"should retain the given cmd name\", function () {\n      const givenCmd = \"BT\";\n      const cmd = Cmd.get(givenCmd);\n      expect(cmd.cmd).toEqual(givenCmd);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should create only one object for a command and cache it","suites":["primitives","Cmd"],"line":53,"updatePoint":{"line":53,"column":64,"index":2257},"code":"    it(\"should create only one object for a command and cache it\", function () {\n      const firstBT = Cmd.get(\"BT\");\n      const secondBT = Cmd.get(\"BT\");\n      const firstET = Cmd.get(\"ET\");\n      const secondET = Cmd.get(\"ET\");\n      expect(firstBT).toBe(secondBT);\n      expect(firstET).toBe(secondET);\n      expect(firstBT).not.toBe(firstET);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should not accept to create a non-string cmd","suites":["primitives","Cmd"],"line":62,"updatePoint":{"line":62,"column":52,"index":2601},"code":"    it(\"should not accept to create a non-string cmd\", function () {\n      expect(function () {\n        Cmd.get(123);\n      }).toThrow(new Error('Cmd: The \"cmd\" must be a string.'));\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should allow assigning an XRef table after creation","suites":["primitives","Dict"],"line":98,"updatePoint":{"line":98,"column":59,"index":3896},"code":"    it(\"should allow assigning an XRef table after creation\", function () {\n      const dict = new Dict(null);\n      expect(dict.xref).toEqual(null);\n      const xref = new XRefMock([]);\n      dict.assignXref(xref);\n      expect(dict.xref).toEqual(xref);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should return correct size","suites":["primitives","Dict"],"line":105,"updatePoint":{"line":105,"column":34,"index":4134},"code":"    it(\"should return correct size\", function () {\n      const dict = new Dict(null);\n      expect(dict.size).toEqual(0);\n      dict.set(\"Type\", Name.get(\"Page\"));\n      expect(dict.size).toEqual(1);\n      dict.set(\"Contents\", Ref.get(10, 0));\n      expect(dict.size).toEqual(2);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should return invalid values for unknown keys","suites":["primitives","Dict"],"line":113,"updatePoint":{"line":113,"column":53,"index":4441},"code":"    it(\"should return invalid values for unknown keys\", function () {\n      checkInvalidHasValues(emptyDict);\n      checkInvalidKeyValues(emptyDict);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should return correct value for stored Size key","suites":["primitives","Dict"],"line":117,"updatePoint":{"line":117,"column":55,"index":4601},"code":"    it(\"should return correct value for stored Size key\", function () {\n      expect(dictWithSizeKey.has(\"Size\")).toBeTruthy();\n      expect(dictWithSizeKey.get(\"Size\")).toEqual(storedSize);\n      expect(dictWithSizeKey.get(\"Prev\", \"Size\")).toEqual(storedSize);\n      expect(dictWithSizeKey.get(\"Prev\", \"Root\", \"Size\")).toEqual(storedSize);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should return invalid values for unknown keys when Size key is stored","suites":["primitives","Dict"],"line":123,"updatePoint":{"line":123,"column":77,"index":4972},"code":"    it(\"should return invalid values for unknown keys when Size key is stored\", function () {\n      checkInvalidHasValues(dictWithSizeKey);\n      checkInvalidKeyValues(dictWithSizeKey);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should not accept to set a non-string key","suites":["primitives","Dict"],"line":127,"updatePoint":{"line":127,"column":49,"index":5138},"code":"    it(\"should not accept to set a non-string key\", function () {\n      const dict = new Dict();\n      expect(function () {\n        dict.set(123, \"val\");\n      }).toThrow(new Error('Dict.set: The \"key\" must be a string.'));\n      expect(dict.has(123)).toBeFalsy();\n      checkInvalidKeyValues(dict);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should not accept to set a key with an undefined value","suites":["primitives","Dict"],"line":135,"updatePoint":{"line":135,"column":62,"index":5459},"code":"    it(\"should not accept to set a key with an undefined value\", function () {\n      const dict = new Dict();\n      expect(function () {\n        dict.set(\"Size\");\n      }).toThrow(new Error('Dict.set: The \"value\" cannot be undefined.'));\n      expect(dict.has(\"Size\")).toBeFalsy();\n      checkInvalidKeyValues(dict);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should return correct values for multiple stored keys","suites":["primitives","Dict"],"line":143,"updatePoint":{"line":143,"column":61,"index":5783},"code":"    it(\"should return correct values for multiple stored keys\", function () {\n      expect(dictWithManyKeys.has(\"FontFile\")).toBeTruthy();\n      expect(dictWithManyKeys.has(\"FontFile2\")).toBeTruthy();\n      expect(dictWithManyKeys.has(\"FontFile3\")).toBeTruthy();\n      expect(dictWithManyKeys.get(\"FontFile3\")).toEqual(testFontFile3);\n      expect(dictWithManyKeys.get(\"FontFile2\", \"FontFile3\")).toEqual(testFontFile2);\n      expect(dictWithManyKeys.get(\"FontFile\", \"FontFile2\", \"FontFile3\")).toEqual(testFontFile);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should asynchronously fetch unknown keys","suites":["primitives","Dict"],"line":151,"updatePoint":{"line":151,"column":48,"index":6294},"code":"    it(\"should asynchronously fetch unknown keys\", async function () {\n      const keyPromises = [dictWithManyKeys.getAsync(\"Size\"), dictWithSizeKey.getAsync(\"FontFile\", \"FontFile2\", \"FontFile3\")];\n      const values = await Promise.all(keyPromises);\n      expect(values[0]).toBeUndefined();\n      expect(values[1]).toBeUndefined();\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should asynchronously fetch correct values for multiple stored keys","suites":["primitives","Dict"],"line":157,"updatePoint":{"line":157,"column":75,"index":6662},"code":"    it(\"should asynchronously fetch correct values for multiple stored keys\", async function () {\n      const keyPromises = [dictWithManyKeys.getAsync(\"FontFile3\"), dictWithManyKeys.getAsync(\"FontFile2\", \"FontFile3\"), dictWithManyKeys.getAsync(\"FontFile\", \"FontFile2\", \"FontFile3\")];\n      const values = await Promise.all(keyPromises);\n      expect(values[0]).toEqual(testFontFile3);\n      expect(values[1]).toEqual(testFontFile2);\n      expect(values[2]).toEqual(testFontFile);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should callback for each stored key","suites":["primitives","Dict"],"line":164,"updatePoint":{"line":164,"column":43,"index":7118},"code":"    it(\"should callback for each stored key\", function () {\n      const callbackSpy = jasmine.createSpy(\"spy on callback in dictionary\");\n      dictWithManyKeys.forEach(callbackSpy);\n      expect(callbackSpy).toHaveBeenCalled();\n      const callbackSpyCalls = callbackSpy.calls;\n      expect(callbackSpyCalls.argsFor(0)).toEqual([\"FontFile\", testFontFile]);\n      expect(callbackSpyCalls.argsFor(1)).toEqual([\"FontFile2\", testFontFile2]);\n      expect(callbackSpyCalls.argsFor(2)).toEqual([\"FontFile3\", testFontFile3]);\n      expect(callbackSpyCalls.count()).toEqual(3);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should handle keys pointing to indirect objects, both sync and async","suites":["primitives","Dict"],"line":174,"updatePoint":{"line":174,"column":76,"index":7730},"code":"    it(\"should handle keys pointing to indirect objects, both sync and async\", async function () {\n      const fontRef = Ref.get(1, 0);\n      const xref = new XRefMock([{\n        ref: fontRef,\n        data: testFontFile\n      }]);\n      const fontDict = new Dict(xref);\n      fontDict.set(\"FontFile\", fontRef);\n      expect(fontDict.getRaw(\"FontFile\")).toEqual(fontRef);\n      expect(fontDict.get(\"FontFile\", \"FontFile2\", \"FontFile3\")).toEqual(testFontFile);\n      const value = await fontDict.getAsync(\"FontFile\", \"FontFile2\", \"FontFile3\");\n      expect(value).toEqual(testFontFile);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should handle arrays containing indirect objects","suites":["primitives","Dict"],"line":187,"updatePoint":{"line":187,"column":56,"index":8303},"code":"    it(\"should handle arrays containing indirect objects\", function () {\n      const minCoordRef = Ref.get(1, 0);\n      const maxCoordRef = Ref.get(2, 0);\n      const minCoord = 0;\n      const maxCoord = 1;\n      const xref = new XRefMock([{\n        ref: minCoordRef,\n        data: minCoord\n      }, {\n        ref: maxCoordRef,\n        data: maxCoord\n      }]);\n      const xObjectDict = new Dict(xref);\n      xObjectDict.set(\"BBox\", [minCoord, maxCoord, minCoordRef, maxCoordRef]);\n      expect(xObjectDict.get(\"BBox\")).toEqual([minCoord, maxCoord, minCoordRef, maxCoordRef]);\n      expect(xObjectDict.getArray(\"BBox\")).toEqual([minCoord, maxCoord, minCoord, maxCoord]);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should get all key names","suites":["primitives","Dict"],"line":204,"updatePoint":{"line":204,"column":32,"index":8959},"code":"    it(\"should get all key names\", function () {\n      const expectedKeys = [\"FontFile\", \"FontFile2\", \"FontFile3\"];\n      const keys = dictWithManyKeys.getKeys();\n      expect(keys.sort()).toEqual(expectedKeys);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should get all raw values","suites":["primitives","Dict"],"line":209,"updatePoint":{"line":209,"column":33,"index":9180},"code":"    it(\"should get all raw values\", function () {\n      // Test direct objects:\n      const expectedRawValues1 = [testFontFile, testFontFile2, testFontFile3];\n      const rawValues1 = dictWithManyKeys.getRawValues();\n      expect(rawValues1.sort()).toEqual(expectedRawValues1); // Test indirect objects:\n\n      const typeName = Name.get(\"Page\");\n      const resources = new Dict(null),\n            resourcesRef = Ref.get(5, 0);\n      const contents = new StringStream(\"data\"),\n            contentsRef = Ref.get(10, 0);\n      const xref = new XRefMock([{\n        ref: resourcesRef,\n        data: resources\n      }, {\n        ref: contentsRef,\n        data: contents\n      }]);\n      const dict = new Dict(xref);\n      dict.set(\"Type\", typeName);\n      dict.set(\"Resources\", resourcesRef);\n      dict.set(\"Contents\", contentsRef);\n      const expectedRawValues2 = [contentsRef, resourcesRef, typeName];\n      const rawValues2 = dict.getRawValues();\n      expect(rawValues2.sort()).toEqual(expectedRawValues2);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should create only one object for Dict.empty","suites":["primitives","Dict"],"line":235,"updatePoint":{"line":235,"column":52,"index":10215},"code":"    it(\"should create only one object for Dict.empty\", function () {\n      const firstDictEmpty = Dict.empty;\n      const secondDictEmpty = Dict.empty;\n      expect(firstDictEmpty).toBe(secondDictEmpty);\n      expect(firstDictEmpty).not.toBe(emptyDict);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should correctly merge dictionaries","suites":["primitives","Dict"],"line":241,"updatePoint":{"line":241,"column":43,"index":10468},"code":"    it(\"should correctly merge dictionaries\", function () {\n      const expectedKeys = [\"FontFile\", \"FontFile2\", \"FontFile3\", \"Size\"];\n      const fontFileDict = new Dict();\n      fontFileDict.set(\"FontFile\", \"Type1 font file\");\n      const mergedDict = Dict.merge({\n        xref: null,\n        dictArray: [dictWithManyKeys, dictWithSizeKey, fontFileDict]\n      });\n      const mergedKeys = mergedDict.getKeys();\n      expect(mergedKeys.sort()).toEqual(expectedKeys);\n      expect(mergedDict.get(\"FontFile\")).toEqual(testFontFile);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should correctly merge sub-dictionaries","suites":["primitives","Dict"],"line":253,"updatePoint":{"line":253,"column":47,"index":11012},"code":"    it(\"should correctly merge sub-dictionaries\", function () {\n      const localFontDict = new Dict();\n      localFontDict.set(\"F1\", \"Local font one\");\n      const globalFontDict = new Dict();\n      globalFontDict.set(\"F1\", \"Global font one\");\n      globalFontDict.set(\"F2\", \"Global font two\");\n      globalFontDict.set(\"F3\", \"Global font three\");\n      const localDict = new Dict();\n      localDict.set(\"Font\", localFontDict);\n      const globalDict = new Dict();\n      globalDict.set(\"Font\", globalFontDict);\n      const mergedDict = Dict.merge({\n        xref: null,\n        dictArray: [localDict, globalDict]\n      });\n      const mergedSubDict = Dict.merge({\n        xref: null,\n        dictArray: [localDict, globalDict],\n        mergeSubDicts: true\n      });\n      const mergedFontDict = mergedDict.get(\"Font\");\n      const mergedSubFontDict = mergedSubDict.get(\"Font\");\n      expect(mergedFontDict instanceof Dict).toEqual(true);\n      expect(mergedSubFontDict instanceof Dict).toEqual(true);\n      const mergedFontDictKeys = mergedFontDict.getKeys();\n      const mergedSubFontDictKeys = mergedSubFontDict.getKeys();\n      expect(mergedFontDictKeys).toEqual([\"F1\"]);\n      expect(mergedSubFontDictKeys).toEqual([\"F1\", \"F2\", \"F3\"]);\n      const mergedFontDictValues = mergedFontDict.getRawValues();\n      const mergedSubFontDictValues = mergedSubFontDict.getRawValues();\n      expect(mergedFontDictValues).toEqual([\"Local font one\"]);\n      expect(mergedSubFontDictValues).toEqual([\"Local font one\", \"Global font two\", \"Global font three\"]);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should get a string representation","suites":["primitives","Ref"],"line":288,"updatePoint":{"line":288,"column":42,"index":12602},"code":"    it(\"should get a string representation\", function () {\n      const nonZeroRef = Ref.get(4, 2);\n      expect(nonZeroRef.toString()).toEqual(\"4R2\"); // If the generation number is 0, a shorter representation is used.\n\n      const zeroRef = Ref.get(4, 0);\n      expect(zeroRef.toString()).toEqual(\"4R\");\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should retain the stored values","suites":["primitives","Ref"],"line":295,"updatePoint":{"line":295,"column":39,"index":12912},"code":"    it(\"should retain the stored values\", function () {\n      const storedNum = 4;\n      const storedGen = 2;\n      const ref = Ref.get(storedNum, storedGen);\n      expect(ref.num).toEqual(storedNum);\n      expect(ref.gen).toEqual(storedGen);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should create only one object for a reference and cache it","suites":["primitives","Ref"],"line":302,"updatePoint":{"line":302,"column":66,"index":13190},"code":"    it(\"should create only one object for a reference and cache it\", function () {\n      const firstRef = Ref.get(4, 2);\n      const secondRef = Ref.get(4, 2);\n      const firstOtherRef = Ref.get(5, 2);\n      const secondOtherRef = Ref.get(5, 2);\n      expect(firstRef).toBe(secondRef);\n      expect(firstOtherRef).toBe(secondOtherRef);\n      expect(firstRef).not.toBe(firstOtherRef);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should have a stored value","suites":["primitives","RefSet"],"line":322,"updatePoint":{"line":322,"column":34,"index":13795},"code":"    it(\"should have a stored value\", function () {\n      refSet.put(ref1);\n      expect(refSet.has(ref1)).toBeTruthy();\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should not have an unknown value","suites":["primitives","RefSet"],"line":326,"updatePoint":{"line":326,"column":40,"index":13929},"code":"    it(\"should not have an unknown value\", function () {\n      expect(refSet.has(ref1)).toBeFalsy();\n      refSet.put(ref1);\n      expect(refSet.has(ref2)).toBeFalsy();\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should support iteration","suites":["primitives","RefSet"],"line":331,"updatePoint":{"line":331,"column":32,"index":14098},"code":"    it(\"should support iteration\", function () {\n      refSet.put(ref1);\n      refSet.put(ref2);\n      expect([...refSet]).toEqual([ref1.toString(), ref2.toString()]);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should put, have and get a value","suites":["primitives","RefSetCache"],"line":349,"updatePoint":{"line":349,"column":40,"index":14601},"code":"    it(\"should put, have and get a value\", function () {\n      cache.put(ref1, obj1);\n      expect(cache.has(ref1)).toBeTruthy();\n      expect(cache.has(ref2)).toBeFalsy();\n      expect(cache.get(ref1)).toBe(obj1);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should put, have and get a value by alias","suites":["primitives","RefSetCache"],"line":355,"updatePoint":{"line":355,"column":49,"index":14833},"code":"    it(\"should put, have and get a value by alias\", function () {\n      cache.put(ref1, obj1);\n      cache.putAlias(ref2, ref1);\n      expect(cache.has(ref1)).toBeTruthy();\n      expect(cache.has(ref2)).toBeTruthy();\n      expect(cache.get(ref1)).toBe(obj1);\n      expect(cache.get(ref2)).toBe(obj1);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should report the size of the cache","suites":["primitives","RefSetCache"],"line":363,"updatePoint":{"line":363,"column":43,"index":15136},"code":"    it(\"should report the size of the cache\", function () {\n      cache.put(ref1, obj1);\n      expect(cache.size).toEqual(1);\n      cache.put(ref2, obj2);\n      expect(cache.size).toEqual(2);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should clear the cache","suites":["primitives","RefSetCache"],"line":369,"updatePoint":{"line":369,"column":30,"index":15323},"code":"    it(\"should clear the cache\", function () {\n      cache.put(ref1, obj1);\n      expect(cache.size).toEqual(1);\n      cache.clear();\n      expect(cache.size).toEqual(0);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should support iteration","suites":["primitives","RefSetCache"],"line":375,"updatePoint":{"line":375,"column":32,"index":15504},"code":"    it(\"should support iteration\", function () {\n      cache.put(ref1, obj1);\n      cache.put(ref2, obj2);\n      expect([...cache]).toEqual([obj1, obj2]);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"handles non-names","suites":["primitives","isName"],"line":383,"updatePoint":{"line":383,"column":25,"index":15747},"code":"    it(\"handles non-names\", function () {\n      const nonName = {};\n      expect(isName(nonName)).toEqual(false);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"handles names","suites":["primitives","isName"],"line":387,"updatePoint":{"line":387,"column":21,"index":15865},"code":"    it(\"handles names\", function () {\n      const name = Name.get(\"Font\");\n      expect(isName(name)).toEqual(true);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"handles names with name check","suites":["primitives","isName"],"line":391,"updatePoint":{"line":391,"column":37,"index":16006},"code":"    it(\"handles names with name check\", function () {\n      const name = Name.get(\"Font\");\n      expect(isName(name, \"Font\")).toEqual(true);\n      expect(isName(name, \"Subtype\")).toEqual(false);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"handles *empty* names, with name check","suites":["primitives","isName"],"line":396,"updatePoint":{"line":396,"column":46,"index":16218},"code":"    it(\"handles *empty* names, with name check\", function () {\n      const emptyName = Name.get(\"\");\n      expect(isName(emptyName)).toEqual(true);\n      expect(isName(emptyName, \"\")).toEqual(true);\n      expect(isName(emptyName, \"string\")).toEqual(false);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"handles non-commands","suites":["primitives","isCmd"],"line":406,"updatePoint":{"line":406,"column":28,"index":16596},"code":"    it(\"handles non-commands\", function () {\n      const nonCmd = {};\n      expect(isCmd(nonCmd)).toEqual(false);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"handles commands","suites":["primitives","isCmd"],"line":410,"updatePoint":{"line":410,"column":24,"index":16714},"code":"    it(\"handles commands\", function () {\n      const cmd = Cmd.get(\"BT\");\n      expect(isCmd(cmd)).toEqual(true);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"handles commands with cmd check","suites":["primitives","isCmd"],"line":414,"updatePoint":{"line":414,"column":39,"index":16851},"code":"    it(\"handles commands with cmd check\", function () {\n      const cmd = Cmd.get(\"BT\");\n      expect(isCmd(cmd, \"BT\")).toEqual(true);\n      expect(isCmd(cmd, \"ET\")).toEqual(false);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"handles non-dictionaries","suites":["primitives","isDict"],"line":423,"updatePoint":{"line":423,"column":32,"index":17166},"code":"    it(\"handles non-dictionaries\", function () {\n      const nonDict = {};\n      expect(isDict(nonDict)).toEqual(false);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"handles empty dictionaries with type check","suites":["primitives","isDict"],"line":427,"updatePoint":{"line":427,"column":50,"index":17313},"code":"    it(\"handles empty dictionaries with type check\", function () {\n      const dict = Dict.empty;\n      expect(isDict(dict)).toEqual(true);\n      expect(isDict(dict, \"Page\")).toEqual(false);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"handles dictionaries with type check","suites":["primitives","isDict"],"line":432,"updatePoint":{"line":432,"column":44,"index":17506},"code":"    it(\"handles dictionaries with type check\", function () {\n      const dict = new Dict();\n      dict.set(\"Type\", Name.get(\"Page\"));\n      expect(isDict(dict, \"Page\")).toEqual(true);\n      expect(isDict(dict, \"Contents\")).toEqual(false);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should handle Refs pointing to the same object","suites":["primitives","isRefsEqual"],"line":441,"updatePoint":{"line":441,"column":54,"index":17854},"code":"    it(\"should handle Refs pointing to the same object\", function () {\n      const ref1 = Ref.get(1, 0);\n      const ref2 = Ref.get(1, 0);\n      expect(isRefsEqual(ref1, ref2)).toEqual(true);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should handle Refs pointing to different objects","suites":["primitives","isRefsEqual"],"line":446,"updatePoint":{"line":446,"column":56,"index":18056},"code":"    it(\"should handle Refs pointing to different objects\", function () {\n      const ref1 = Ref.get(1, 0);\n      const ref2 = Ref.get(2, 0);\n      expect(isRefsEqual(ref1, ref2)).toEqual(false);\n    });","file":"unit/primitives_spec.js","skipped":false,"dir":"test"},{"name":"should send a value, execute an action and get back a new value","suites":["Scripting","Sandbox"],"line":89,"updatePoint":{"line":89,"column":71,"index":2511},"code":"    it(\"should send a value, execute an action and get back a new value\", async () => {\n      function compute(n) {\n        let s = 0;\n\n        for (let i = 0; i < n; i++) {\n          s += i;\n        }\n\n        return s;\n      }\n\n      const number = 123;\n      const expected = (number - 1) * number / 2;\n      const refId = getId();\n      const data = {\n        objects: {\n          field: [{\n            id: refId,\n            value: \"\",\n            actions: {\n              Keystroke: [`${compute.toString()}event.value = compute(parseInt(event.value));`]\n            },\n            type: \"text\"\n          }]\n        },\n        calculationOrder: [],\n        appInfo: {\n          language: \"en-US\",\n          platform: \"Linux x86_64\"\n        }\n      };\n      sandbox.createSandbox(data);\n      await sandbox.dispatchEventInSandbox({\n        id: refId,\n        value: `${number}`,\n        name: \"Keystroke\",\n        willCommit: true\n      });\n      expect(send_queue.has(refId)).toEqual(true);\n      expect(send_queue.get(refId)).toEqual({\n        id: refId,\n        siblings: null,\n        value: expected,\n        formattedValue: null\n      });\n    });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should treat globalThis as the doc","suites":["Scripting","Doc"],"line":137,"updatePoint":{"line":137,"column":42,"index":3677},"code":"    it(\"should treat globalThis as the doc\", async () => {\n      const refId = getId();\n      const data = {\n        objects: {\n          field: [{\n            id: refId,\n            value: \"\",\n            actions: {},\n            type: \"text\"\n          }]\n        },\n        appInfo: {\n          language: \"en-US\",\n          platform: \"Linux x86_64\"\n        },\n        calculationOrder: [],\n        dispatchEventName: \"_dispatchMe\"\n      };\n      sandbox.createSandbox(data);\n      await myeval(`(this.foobar = 123456, 0)`);\n      const value = await myeval(`this.getField(\"field\").doc.foobar`);\n      expect(value).toEqual(123456);\n    });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should get field using a path","suites":["Scripting","Doc"],"line":160,"updatePoint":{"line":160,"column":37,"index":4314},"code":"    it(\"should get field using a path\", async () => {\n      const base = value => {\n        return {\n          id: getId(),\n          value,\n          actions: {},\n          type: \"text\"\n        };\n      };\n\n      const data = {\n        objects: {\n          A: [base(1)],\n          \"A.B\": [base(2)],\n          \"A.B.C\": [base(3)],\n          \"A.B.C.D\": [base(4)],\n          \"A.B.C.D.E\": [base(5)],\n          \"A.B.C.D.E.F\": [base(6)],\n          \"A.B.C.D.G\": [base(7)],\n          C: [base(8)]\n        },\n        appInfo: {\n          language: \"en-US\",\n          platform: \"Linux x86_64\"\n        },\n        calculationOrder: [],\n        dispatchEventName: \"_dispatchMe\"\n      };\n      sandbox.createSandbox(data);\n      let value = await myeval(`this.getField(\"A\").value`);\n      expect(value).toEqual(1);\n      value = await myeval(`this.getField(\"B.C\").value`);\n      expect(value).toEqual(3); // path has been cached so try again\n\n      value = await myeval(`this.getField(\"B.C\").value`);\n      expect(value).toEqual(3);\n      value = await myeval(`this.getField(\"B.C.D#0\").value`);\n      expect(value).toEqual(5);\n      value = await myeval(`this.getField(\"B.C.D#1\").value`);\n      expect(value).toEqual(7);\n      value = await myeval(`this.getField(\"C\").value`);\n      expect(value).toEqual(8);\n      value = await myeval(`this.getField(\"A.B.C.D\").getArray().map((x) => x.value)`);\n      expect(value).toEqual([5, 7]);\n    });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should print a date according to a format","suites":["Scripting","Util","printd"],"line":218,"updatePoint":{"line":218,"column":51,"index":6051},"code":"      it(\"should print a date according to a format\", async () => {\n        const date = `new Date(\"Sun Apr 15 2007 03:14:15\")`;\n        let value = await myeval(`util.printd(0, ${date})`);\n        expect(value).toEqual(\"D:20070415031415\");\n        value = await myeval(`util.printd(1, ${date})`);\n        expect(value).toEqual(\"2007.04.15 03:14:15\");\n        value = await myeval(`util.printd(2, ${date})`);\n        expect(value).toEqual(\"4/15/07 3:14:15 am\");\n        value = await myeval(`util.printd(\"mmmm mmm mm m\", ${date})`);\n        expect(value).toEqual(\"April Apr 04 4\");\n        value = await myeval(`util.printd(\"dddd ddd dd d\", ${date})`);\n        expect(value).toEqual(\"Sunday Sun 15 15\");\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should parse a date according to a format","suites":["Scripting","Util","scand"],"line":233,"updatePoint":{"line":233,"column":51,"index":6809},"code":"      it(\"should parse a date according to a format\", async () => {\n        const date = new Date(\"Sun Apr 15 2007 03:14:15\");\n        let value = await myeval(`util.scand(0, \"D:20070415031415\").toString()`);\n        expect(new Date(value)).toEqual(date);\n        value = await myeval(`util.scand(1, \"2007.04.15 03:14:15\").toString()`);\n        expect(new Date(value)).toEqual(date);\n        value = await myeval(`util.scand(2, \"4/15/07 3:14:15 am\").toString()`);\n        expect(new Date(value)).toEqual(date);\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should print some data according to a format","suites":["Scripting","Util","printf"],"line":244,"updatePoint":{"line":244,"column":54,"index":7378},"code":"      it(\"should print some data according to a format\", async () => {\n        let value = await myeval(`util.printf(\"Integer numbers: %d, %d,...\", 1.234, 56.789)`);\n        expect(value).toEqual(\"Integer numbers: 1, 56,...\");\n        value = await myeval(`util.printf(\"Hex numbers: %x, %x,...\", 1234, 56789)`);\n        expect(value).toEqual(\"Hex numbers: 4D2, DDD5,...\");\n        value = await myeval(`util.printf(\"Hex numbers with 0x: %#x, %#x,...\", 1234, 56789)`);\n        expect(value).toEqual(\"Hex numbers with 0x: 0x4D2, 0xDDD5,...\");\n        value = await myeval(`util.printf(\"Decimal number: %,0+.3f\", 1234567.89123)`);\n        expect(value).toEqual(\"Decimal number: +1,234,567.891\");\n        value = await myeval(`util.printf(\"Decimal number: %,0+8.3f\", 1.234567)`);\n        expect(value).toEqual(\"Decimal number: +  1.235\");\n        value = await myeval(`util.printf(\"Decimal number: %,0.2f\", -12.34567)`);\n        expect(value).toEqual(\"Decimal number: -12.35\");\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should print a string with no argument","suites":["Scripting","Util","printf"],"line":258,"updatePoint":{"line":258,"column":48,"index":8356},"code":"      it(\"should print a string with no argument\", async () => {\n        const value = await myeval(`util.printf(\"hello world\")`);\n        expect(value).toEqual(\"hello world\");\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"print a string with a percent","suites":["Scripting","Util","printf"],"line":262,"updatePoint":{"line":262,"column":39,"index":8534},"code":"      it(\"print a string with a percent\", async () => {\n        const value = await myeval(`util.printf(\"%%s\")`);\n        expect(value).toEqual(\"%%s\");\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should print some data according to a format","suites":["Scripting","Util","printx"],"line":268,"updatePoint":{"line":268,"column":54,"index":8756},"code":"      it(\"should print some data according to a format\", async () => {\n        const value = await myeval(`util.printx(\"9 (999) 999-9999\", \"aaa14159697489zzz\")`);\n        expect(value).toEqual(\"1 (415) 969-7489\");\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should trigger an event and modify the source","suites":["Scripting","Events"],"line":275,"updatePoint":{"line":275,"column":53,"index":9028},"code":"    it(\"should trigger an event and modify the source\", async () => {\n      const refId = getId();\n      const data = {\n        objects: {\n          field: [{\n            id: refId,\n            value: \"\",\n            actions: {\n              test: [`event.source.value = \"123\";`]\n            },\n            type: \"text\"\n          }]\n        },\n        appInfo: {\n          language: \"en-US\",\n          platform: \"Linux x86_64\"\n        },\n        calculationOrder: []\n      };\n      sandbox.createSandbox(data);\n      await sandbox.dispatchEventInSandbox({\n        id: refId,\n        value: \"\",\n        name: \"test\",\n        willCommit: true\n      });\n      expect(send_queue.has(refId)).toEqual(true);\n      expect(send_queue.get(refId)).toEqual({\n        id: refId,\n        value: \"123\"\n      });\n    });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should trigger a Keystroke event and invalidate it","suites":["Scripting","Events"],"line":307,"updatePoint":{"line":307,"column":58,"index":9839},"code":"    it(\"should trigger a Keystroke event and invalidate it\", async () => {\n      const refId = getId();\n      const data = {\n        objects: {\n          field: [{\n            id: refId,\n            value: \"\",\n            actions: {\n              Keystroke: [`event.rc = false;`]\n            },\n            type: \"text\"\n          }]\n        },\n        appInfo: {\n          language: \"en-US\",\n          platform: \"Linux x86_64\"\n        },\n        calculationOrder: []\n      };\n      sandbox.createSandbox(data);\n      await sandbox.dispatchEventInSandbox({\n        id: refId,\n        value: \"hell\",\n        name: \"Keystroke\",\n        willCommit: false,\n        change: \"o\",\n        selStart: 4,\n        selEnd: 4\n      });\n      expect(send_queue.has(refId)).toEqual(true);\n      expect(send_queue.get(refId)).toEqual({\n        id: refId,\n        siblings: null,\n        value: \"hell\",\n        selRange: [4, 4]\n      });\n    });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should trigger a Keystroke event and change it","suites":["Scripting","Events"],"line":344,"updatePoint":{"line":344,"column":54,"index":10763},"code":"    it(\"should trigger a Keystroke event and change it\", async () => {\n      const refId = getId();\n      const data = {\n        objects: {\n          field: [{\n            id: refId,\n            value: \"\",\n            actions: {\n              Keystroke: [`event.change = \"a\";`]\n            },\n            type: \"text\"\n          }]\n        },\n        appInfo: {\n          language: \"en-US\",\n          platform: \"Linux x86_64\"\n        },\n        calculationOrder: []\n      };\n      sandbox.createSandbox(data);\n      await sandbox.dispatchEventInSandbox({\n        id: refId,\n        value: \"hell\",\n        name: \"Keystroke\",\n        willCommit: false,\n        change: \"o\",\n        selStart: 4,\n        selEnd: 4\n      });\n      expect(send_queue.has(refId)).toEqual(true);\n      expect(send_queue.get(refId)).toEqual({\n        id: refId,\n        siblings: null,\n        value: \"hella\",\n        selRange: [5, 5]\n      });\n    });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should trigger an invalid commit Keystroke event","suites":["Scripting","Events"],"line":381,"updatePoint":{"line":381,"column":56,"index":11692},"code":"    it(\"should trigger an invalid commit Keystroke event\", async () => {\n      const refId = getId();\n      const data = {\n        objects: {\n          field: [{\n            id: refId,\n            value: \"\",\n            actions: {\n              test: [`event.rc = false;`]\n            },\n            type: \"text\"\n          }]\n        },\n        appInfo: {\n          language: \"en-US\",\n          platform: \"Linux x86_64\"\n        },\n        calculationOrder: []\n      };\n      sandbox.createSandbox(data);\n      await sandbox.dispatchEventInSandbox({\n        id: refId,\n        value: \"\",\n        name: \"test\",\n        willCommit: true\n      });\n      expect(send_queue.has(refId)).toEqual(false);\n    });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should trigger a valid commit Keystroke event","suites":["Scripting","Events"],"line":409,"updatePoint":{"line":409,"column":53,"index":12393},"code":"    it(\"should trigger a valid commit Keystroke event\", async () => {\n      const refId1 = getId();\n      const refId2 = getId();\n      const data = {\n        objects: {\n          field1: [{\n            id: refId1,\n            value: \"\",\n            actions: {\n              Validate: [`event.value = \"world\";`]\n            },\n            type: \"text\"\n          }],\n          field2: [{\n            id: refId2,\n            value: \"\",\n            actions: {\n              Calculate: [`event.value = \"hello\";`]\n            },\n            type: \"text\"\n          }]\n        },\n        appInfo: {\n          language: \"en-US\",\n          platform: \"Linux x86_64\"\n        },\n        calculationOrder: [refId2]\n      };\n      sandbox.createSandbox(data);\n      await sandbox.dispatchEventInSandbox({\n        id: refId1,\n        value: \"hello\",\n        name: \"Keystroke\",\n        willCommit: true\n      });\n      expect(send_queue.has(refId1)).toEqual(true);\n      expect(send_queue.get(refId1)).toEqual({\n        id: refId1,\n        siblings: null,\n        value: \"world\",\n        formattedValue: null\n      });\n    });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should convert RGB color for different color spaces","suites":["Scripting","Color"],"line":469,"updatePoint":{"line":469,"column":59,"index":13888},"code":"    it(\"should convert RGB color for different color spaces\", async () => {\n      let value = await myeval(`color.convert([\"RGB\", 0.1, 0.2, 0.3], \"T\")`);\n      expect(round(value)).toEqual([\"T\"]);\n      value = await myeval(`color.convert([\"RGB\", 0.1, 0.2, 0.3], \"G\")`);\n      expect(round(value)).toEqual([\"G\", 0.181]);\n      value = await myeval(`color.convert([\"RGB\", 0.1, 0.2, 0.3], \"RGB\")`);\n      expect(round(value)).toEqual([\"RGB\", 0.1, 0.2, 0.3]);\n      value = await myeval(`color.convert([\"RGB\", 0.1, 0.2, 0.3], \"CMYK\")`);\n      expect(round(value)).toEqual([\"CMYK\", 0.9, 0.8, 0.7, 0.7]);\n    });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should convert CMYK color for different color spaces","suites":["Scripting","Color"],"line":479,"updatePoint":{"line":479,"column":60,"index":14497},"code":"    it(\"should convert CMYK color for different color spaces\", async () => {\n      let value = await myeval(`color.convert([\"CMYK\", 0.1, 0.2, 0.3, 0.4], \"T\")`);\n      expect(round(value)).toEqual([\"T\"]);\n      value = await myeval(`color.convert([\"CMYK\", 0.1, 0.2, 0.3, 0.4], \"G\")`);\n      expect(round(value)).toEqual([\"G\", 0.371]);\n      value = await myeval(`color.convert([\"CMYK\", 0.1, 0.2, 0.3, 0.4], \"RGB\")`);\n      expect(round(value)).toEqual([\"RGB\", 0.5, 0.3, 0.4]);\n      value = await myeval(`color.convert([\"CMYK\", 0.1, 0.2, 0.3, 0.4], \"CMYK\")`);\n      expect(round(value)).toEqual([\"CMYK\", 0.1, 0.2, 0.3, 0.4]);\n    });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should convert Gray color for different color spaces","suites":["Scripting","Color"],"line":489,"updatePoint":{"line":489,"column":60,"index":15130},"code":"    it(\"should convert Gray color for different color spaces\", async () => {\n      let value = await myeval(`color.convert([\"G\", 0.1], \"T\")`);\n      expect(round(value)).toEqual([\"T\"]);\n      value = await myeval(`color.convert([\"G\", 0.1], \"G\")`);\n      expect(round(value)).toEqual([\"G\", 0.1]);\n      value = await myeval(`color.convert([\"G\", 0.1], \"RGB\")`);\n      expect(round(value)).toEqual([\"RGB\", 0.1, 0.1, 0.1]);\n      value = await myeval(`color.convert([\"G\", 0.1], \"CMYK\")`);\n      expect(round(value)).toEqual([\"CMYK\", 0, 0, 0, 0.9]);\n    });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should convert Transparent color for different color spaces","suites":["Scripting","Color"],"line":499,"updatePoint":{"line":499,"column":67,"index":15690},"code":"    it(\"should convert Transparent color for different color spaces\", async () => {\n      let value = await myeval(`color.convert([\"T\"], \"T\")`);\n      expect(round(value)).toEqual([\"T\"]);\n      value = await myeval(`color.convert([\"T\"], \"G\")`);\n      expect(round(value)).toEqual([\"G\", 0]);\n      value = await myeval(`color.convert([\"T\"], \"RGB\")`);\n      expect(round(value)).toEqual([\"RGB\", 0, 0, 0]);\n      value = await myeval(`color.convert([\"T\"], \"CMYK\")`);\n      expect(round(value)).toEqual([\"CMYK\", 0, 0, 0, 1]);\n    });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should test language","suites":["Scripting","App"],"line":521,"updatePoint":{"line":521,"column":28,"index":16439},"code":"    it(\"should test language\", async () => {\n      let value = await myeval(`app.language`);\n      expect(value).toEqual(\"ENU\");\n      value = await myeval(`app.language = \"hello\"`);\n      expect(value).toEqual(\"app.language is read-only\");\n    });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should test platform","suites":["Scripting","App"],"line":527,"updatePoint":{"line":527,"column":28,"index":16688},"code":"    it(\"should test platform\", async () => {\n      let value = await myeval(`app.platform`);\n      expect(value).toEqual(\"UNIX\");\n      value = await myeval(`app.platform = \"hello\"`);\n      expect(value).toEqual(\"app.platform is read-only\");\n    });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should parse a date with a format","suites":["Scripting","AForm","AFParseDateEx"],"line":547,"updatePoint":{"line":547,"column":43,"index":17299},"code":"      it(\"should parse a date with a format\", async () => {\n        const check = async (date, format, expected) => {\n          const value = await myeval(`AFParseDateEx(\"${date}\", \"${format}\").toISOString()`);\n          expect(value).toEqual(new Date(expected).toISOString());\n        };\n\n        await check(\"05\", \"dd\", \"2000/01/05\");\n        await check(\"12\", \"mm\", \"2000/12/01\");\n        await check(\"2022\", \"yyyy\", \"2022/01/01\");\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should extract numbers","suites":["Scripting","AForm","AFExtractNums"],"line":559,"updatePoint":{"line":559,"column":32,"index":17785},"code":"      it(\"should extract numbers\", async () => {\n        let value = await myeval(`AFExtractNums(\"123 456 789\")`);\n        expect(value).toEqual([\"123\", \"456\", \"789\"]);\n        value = await myeval(`AFExtractNums(\"123.456\")`);\n        expect(value).toEqual([\"123\", \"456\"]);\n        value = await myeval(`AFExtractNums(\"123\")`);\n        expect(value).toEqual([\"123\"]);\n        value = await myeval(`AFExtractNums(\".123\")`);\n        expect(value).toEqual([\"0\", \"123\"]);\n        value = await myeval(`AFExtractNums(\",123\")`);\n        expect(value).toEqual([\"0\", \"123\"]);\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should convert string to number","suites":["Scripting","AForm","AFMakeNumber"],"line":573,"updatePoint":{"line":573,"column":41,"index":18423},"code":"      it(\"should convert string to number\", async () => {\n        let value = await myeval(`AFMakeNumber(\"123.456\")`);\n        expect(value).toEqual(123.456);\n        value = await myeval(`AFMakeNumber(123.456)`);\n        expect(value).toEqual(123.456);\n        value = await myeval(`AFMakeNumber(\"-123.456\")`);\n        expect(value).toEqual(-123.456);\n        value = await myeval(`AFMakeNumber(\"-123,456\")`);\n        expect(value).toEqual(-123.456);\n        value = await myeval(`AFMakeNumber(\"not a number\")`);\n        expect(value).toEqual(null);\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should split a string into an array of strings","suites":["Scripting","AForm","AFMakeArrayFromList"],"line":587,"updatePoint":{"line":587,"column":56,"index":19057},"code":"      it(\"should split a string into an array of strings\", async () => {\n        const value = await myeval(`AFMakeArrayFromList(\"aaaa,  bbbbbbb,cc,ddd, e\")`);\n        expect(value).toEqual([\"aaaa\", \" bbbbbbb\", \"cc\", \"ddd\", \"e\"]);\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should format a number","suites":["Scripting","AForm","AFNumber_format"],"line":593,"updatePoint":{"line":593,"column":32,"index":19328},"code":"      it(\"should format a number\", async () => {\n        const refId = getId();\n        const data = {\n          objects: {\n            field: [{\n              id: refId,\n              value: \"\",\n              actions: {\n                test1: [`AFNumber_Format(2, 0, 0, 0, \"€\", false);` + `event.source.value = event.value;`],\n                test2: [`AFNumber_Format(1, 3, 0, 0, \"$\", true);` + `event.source.value = event.value;`],\n                test3: [`AFNumber_Format(2, 0, 1, 0, \"€\", false);` + `event.source.value = event.value;`],\n                test4: [`AFNumber_Format(2, 0, 2, 0, \"€\", false);` + `event.source.value = event.value;`],\n                test5: [`AFNumber_Format(2, 0, 3, 0, \"€\", false);` + `event.source.value = event.value;`]\n              },\n              type: \"text\"\n            }]\n          },\n          appInfo: {\n            language: \"en-US\",\n            platform: \"Linux x86_64\"\n          },\n          calculationOrder: [],\n          dispatchEventName: \"_dispatchMe\"\n        };\n        sandbox.createSandbox(data);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"123456.789\",\n          name: \"test1\"\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        expect(send_queue.get(refId)).toEqual({\n          id: refId,\n          value: \"123,456.79€\"\n        });\n        send_queue.delete(refId);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"223456.789\",\n          name: \"test2\"\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        expect(send_queue.get(refId)).toEqual({\n          id: refId,\n          value: \"$223456,8\"\n        });\n        send_queue.delete(refId);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"-323456.789\",\n          name: \"test3\"\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        expect(send_queue.get(refId)).toEqual({\n          id: refId,\n          value: \"323,456.79€\",\n          textColor: [\"RGB\", 1, 0, 0]\n        });\n        send_queue.delete(refId);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"-423456.789\",\n          name: \"test4\"\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        expect(send_queue.get(refId)).toEqual({\n          id: refId,\n          value: \"(423,456.79€)\"\n        });\n        send_queue.delete(refId);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"-52345.678\",\n          name: \"test5\"\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        expect(send_queue.get(refId)).toEqual({\n          id: refId,\n          value: \"(52,345.68€)\",\n          textColor: [\"RGB\", 1, 0, 0]\n        });\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should validate a number on a keystroke event","suites":["Scripting","AForm","AFNumber_Keystroke"],"line":677,"updatePoint":{"line":677,"column":55,"index":22186},"code":"      it(\"should validate a number on a keystroke event\", async () => {\n        const refId = getId();\n        const data = {\n          objects: {\n            field: [{\n              id: refId,\n              value: \"\",\n              actions: {\n                Validate: [`AFNumber_Keystroke(null, 0, null, null, null, null);`]\n              },\n              type: \"text\",\n              name: \"MyField\"\n            }]\n          },\n          appInfo: {\n            language: \"en-US\",\n            platform: \"Linux x86_64\"\n          },\n          calculationOrder: [],\n          dispatchEventName: \"_dispatchMe\"\n        };\n        sandbox.createSandbox(data);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"123456.789\",\n          name: \"Keystroke\",\n          willCommit: true\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        expect(send_queue.get(refId)).toEqual({\n          id: refId,\n          siblings: null,\n          value: \"123456.789\",\n          formattedValue: null\n        });\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should not validate a number on a keystroke event","suites":["Scripting","AForm","AFNumber_Keystroke"],"line":713,"updatePoint":{"line":713,"column":59,"index":23244},"code":"      it(\"should not validate a number on a keystroke event\", async () => {\n        const refId = getId();\n        const data = {\n          objects: {\n            field: [{\n              id: refId,\n              value: \"\",\n              actions: {\n                Validate: [`AFNumber_Keystroke(null, 0, null, null, null, null);`]\n              },\n              type: \"text\",\n              name: \"MyField\"\n            }]\n          },\n          appInfo: {\n            language: \"en-US\",\n            platform: \"Linux x86_64\"\n          },\n          calculationOrder: [],\n          dispatchEventName: \"_dispatchMe\"\n        };\n        sandbox.createSandbox(data);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"123s456.789\",\n          name: \"Keystroke\",\n          willCommit: true\n        });\n        expect(send_queue.has(\"alert\")).toEqual(true);\n        expect(send_queue.get(\"alert\")).toEqual({\n          command: \"alert\",\n          value: \"The value entered does not match the format of the field [ MyField ]\"\n        });\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should format a percentage","suites":["Scripting","AForm","AFPercent_Format"],"line":749,"updatePoint":{"line":749,"column":36,"index":24346},"code":"      it(\"should format a percentage\", async () => {\n        const refId = getId();\n        const data = {\n          objects: {\n            field: [{\n              id: refId,\n              value: \"\",\n              actions: {\n                test1: [`AFPercent_Format(2, 1, false);` + `event.source.value = event.value;`],\n                test2: [`AFPercent_Format(2, 1, true);` + `event.source.value = event.value;`]\n              },\n              type: \"text\"\n            }]\n          },\n          appInfo: {\n            language: \"en-US\",\n            platform: \"Linux x86_64\"\n          },\n          calculationOrder: [],\n          dispatchEventName: \"_dispatchMe\"\n        };\n        sandbox.createSandbox(data);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"0.456789\",\n          name: \"test1\"\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        expect(send_queue.get(refId)).toEqual({\n          id: refId,\n          value: \"45.68%\"\n        });\n        send_queue.delete(refId);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"0.456789\",\n          name: \"test2\"\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        expect(send_queue.get(refId)).toEqual({\n          id: refId,\n          value: \"%45.68\"\n        });\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should format a date","suites":["Scripting","AForm","AFDate_Format"],"line":795,"updatePoint":{"line":795,"column":30,"index":25736},"code":"      it(\"should format a date\", async () => {\n        const refId = getId();\n        const data = {\n          objects: {\n            field: [{\n              id: refId,\n              value: \"\",\n              actions: {\n                test1: [`AFDate_Format(0);event.source.value = event.value;`],\n                test2: [`AFDate_Format(12);event.source.value = event.value;`]\n              },\n              type: \"text\"\n            }]\n          },\n          appInfo: {\n            language: \"en-US\",\n            platform: \"Linux x86_64\"\n          },\n          calculationOrder: [],\n          dispatchEventName: \"_dispatchMe\"\n        };\n        sandbox.createSandbox(data);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"Sun Apr 15 2007 03:14:15\",\n          name: \"test1\"\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        expect(send_queue.get(refId)).toEqual({\n          id: refId,\n          value: \"4/15\"\n        });\n        send_queue.delete(refId);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"Sun Apr 15 2007 03:14:15\",\n          name: \"test2\"\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        expect(send_queue.get(refId)).toEqual({\n          id: refId,\n          value: \"4/15/07 3:14 am\"\n        });\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should validate a number in range [a, b]","suites":["Scripting","AForm","AFRange_Validate"],"line":841,"updatePoint":{"line":841,"column":50,"index":27154},"code":"      it(\"should validate a number in range [a, b]\", async () => {\n        const refId = getId();\n        const data = {\n          objects: {\n            field: [{\n              id: refId,\n              value: \"\",\n              actions: {\n                Validate: [`AFRange_Validate(true, 123, true, 456);`]\n              },\n              type: \"text\"\n            }]\n          },\n          appInfo: {\n            language: \"en-US\",\n            platform: \"Linux x86_64\"\n          },\n          calculationOrder: [],\n          dispatchEventName: \"_dispatchMe\"\n        };\n        sandbox.createSandbox(data);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"321\",\n          name: \"Keystroke\",\n          willCommit: true\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        expect(send_queue.get(refId)).toEqual({\n          id: refId,\n          siblings: null,\n          value: \"321\",\n          formattedValue: null\n        });\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should invalidate a number out of range [a, b]","suites":["Scripting","AForm","AFRange_Validate"],"line":876,"updatePoint":{"line":876,"column":56,"index":28151},"code":"      it(\"should invalidate a number out of range [a, b]\", async () => {\n        const refId = getId();\n        const data = {\n          objects: {\n            field: [{\n              id: refId,\n              value: \"\",\n              actions: {\n                Validate: [`AFRange_Validate(true, 123, true, 456);`]\n              },\n              type: \"text\"\n            }]\n          },\n          appInfo: {\n            language: \"en-US\",\n            platform: \"Linux x86_64\"\n          },\n          calculationOrder: [],\n          dispatchEventName: \"_dispatchMe\"\n        };\n        sandbox.createSandbox(data);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"12\",\n          name: \"Keystroke\",\n          willCommit: true\n        });\n        expect(send_queue.has(\"alert\")).toEqual(true);\n        expect(send_queue.get(\"alert\")).toEqual({\n          command: \"alert\",\n          value: \"Invalid value: must be greater than or equal to 123 and less than or equal to 456.\"\n        });\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should compute the sum of several fields","suites":["Scripting","AForm","ASSimple_Calculate"],"line":911,"updatePoint":{"line":911,"column":50,"index":29230},"code":"      it(\"should compute the sum of several fields\", async () => {\n        const refIds = [0, 1, 2, 3].map(_ => getId());\n        const data = {\n          objects: {\n            field1: [{\n              id: refIds[0],\n              value: \"\",\n              actions: {},\n              type: \"text\"\n            }],\n            field2: [{\n              id: refIds[1],\n              value: \"\",\n              actions: {},\n              type: \"text\"\n            }],\n            field3: [{\n              id: refIds[2],\n              value: \"\",\n              actions: {},\n              type: \"text\"\n            }],\n            field4: [{\n              id: refIds[3],\n              value: \"\",\n              actions: {\n                Calculate: [`AFSimple_Calculate(\"SUM\", [\"field1\", \"field2\", \"field3\"]);`]\n              },\n              type: \"text\"\n            }]\n          },\n          appInfo: {\n            language: \"en-US\",\n            platform: \"Linux x86_64\"\n          },\n          calculationOrder: [refIds[3]],\n          dispatchEventName: \"_dispatchMe\"\n        };\n        sandbox.createSandbox(data);\n        await sandbox.dispatchEventInSandbox({\n          id: refIds[0],\n          value: \"1\",\n          name: \"Keystroke\",\n          willCommit: true\n        });\n        expect(send_queue.has(refIds[3])).toEqual(true);\n        expect(send_queue.get(refIds[3])).toEqual({\n          id: refIds[3],\n          siblings: null,\n          value: 1,\n          formattedValue: null\n        });\n        await sandbox.dispatchEventInSandbox({\n          id: refIds[1],\n          value: \"2\",\n          name: \"Keystroke\",\n          willCommit: true\n        });\n        expect(send_queue.has(refIds[3])).toEqual(true);\n        expect(send_queue.get(refIds[3])).toEqual({\n          id: refIds[3],\n          siblings: null,\n          value: 3,\n          formattedValue: null\n        });\n        await sandbox.dispatchEventInSandbox({\n          id: refIds[2],\n          value: \"3\",\n          name: \"Keystroke\",\n          willCommit: true\n        });\n        expect(send_queue.has(refIds[3])).toEqual(true);\n        expect(send_queue.get(refIds[3])).toEqual({\n          id: refIds[3],\n          siblings: null,\n          value: 6,\n          formattedValue: null\n        });\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should validate a phone number on a keystroke event","suites":["Scripting","AForm","AFSpecial_KeystrokeEx"],"line":992,"updatePoint":{"line":992,"column":61,"index":31571},"code":"      it(\"should validate a phone number on a keystroke event\", async () => {\n        const refId = getId();\n        const data = {\n          objects: {\n            field: [{\n              id: refId,\n              value: \"\",\n              actions: {\n                Keystroke: [`AFSpecial_KeystrokeEx(\"9AXO\");`]\n              },\n              type: \"text\"\n            }]\n          },\n          appInfo: {\n            language: \"en-US\",\n            platform: \"Linux x86_64\"\n          },\n          calculationOrder: [],\n          dispatchEventName: \"_dispatchMe\"\n        };\n        sandbox.createSandbox(data);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"\",\n          change: \"3\",\n          name: \"Keystroke\",\n          willCommit: false,\n          selStart: 0,\n          selEnd: 0\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        send_queue.delete(refId);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"3\",\n          change: \"F\",\n          name: \"Keystroke\",\n          willCommit: false,\n          selStart: 1,\n          selEnd: 1\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        send_queue.delete(refId);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"3F\",\n          change: \"?\",\n          name: \"Keystroke\",\n          willCommit: false,\n          selStart: 2,\n          selEnd: 2\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        send_queue.delete(refId);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"3F?\",\n          change: \"@\",\n          name: \"Keystroke\",\n          willCommit: false,\n          selStart: 3,\n          selEnd: 3\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        expect(send_queue.get(refId)).toEqual({\n          id: refId,\n          siblings: null,\n          value: \"3F?\",\n          selRange: [3, 3]\n        });\n        send_queue.delete(refId);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"3F?\",\n          change: \"0\",\n          name: \"Keystroke\",\n          willCommit: false,\n          selStart: 3,\n          selEnd: 3\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        send_queue.delete(refId);\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value: \"3F?0\",\n          name: \"Keystroke\",\n          willCommit: true,\n          selStart: 4,\n          selEnd: 4\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        expect(send_queue.get(refId)).toEqual({\n          id: refId,\n          siblings: null,\n          value: \"3F?0\",\n          formattedValue: null\n        });\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should validate a zip code on a keystroke event","suites":["Scripting","AForm","AFSpecial_Keystroke"],"line":1092,"updatePoint":{"line":1092,"column":57,"index":34392},"code":"      it(\"should validate a zip code on a keystroke event\", async () => {\n        const refId = getId();\n        const data = {\n          objects: {\n            field: [{\n              id: refId,\n              value: \"\",\n              actions: {\n                Keystroke: [`AFSpecial_Keystroke(0);`]\n              },\n              type: \"text\"\n            }]\n          },\n          appInfo: {\n            language: \"en-US\",\n            platform: \"Linux x86_64\"\n          },\n          calculationOrder: [],\n          dispatchEventName: \"_dispatchMe\"\n        };\n        sandbox.createSandbox(data);\n        let value = \"\";\n        const changes = \"12345\";\n        let i = 0;\n\n        for (; i < changes.length; i++) {\n          const change = changes.charAt(i);\n          await sandbox.dispatchEventInSandbox({\n            id: refId,\n            value,\n            change,\n            name: \"Keystroke\",\n            willCommit: false,\n            selStart: i,\n            selEnd: i\n          });\n          expect(send_queue.has(refId)).toEqual(true);\n          send_queue.delete(refId);\n          value += change;\n        }\n\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value,\n          change: \"A\",\n          name: \"Keystroke\",\n          willCommit: false,\n          selStart: i,\n          selEnd: i\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        expect(send_queue.get(refId)).toEqual({\n          id: refId,\n          siblings: null,\n          value,\n          selRange: [i, i]\n        });\n        send_queue.delete(refId);\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should validate a US phone number (long) on a keystroke event","suites":["Scripting","AForm","AFSpecial_Keystroke"],"line":1151,"updatePoint":{"line":1151,"column":71,"index":35999},"code":"      it(\"should validate a US phone number (long) on a keystroke event\", async () => {\n        const refId = getId();\n        const data = {\n          objects: {\n            field: [{\n              id: refId,\n              value: \"\",\n              actions: {\n                Keystroke: [`AFSpecial_Keystroke(2);`]\n              },\n              type: \"text\"\n            }]\n          },\n          appInfo: {\n            language: \"en-US\",\n            platform: \"Linux x86_64\"\n          },\n          calculationOrder: [],\n          dispatchEventName: \"_dispatchMe\"\n        };\n        sandbox.createSandbox(data);\n        let value = \"\";\n        const changes = \"(123) 456-7890\";\n        let i = 0;\n\n        for (; i < changes.length; i++) {\n          const change = changes.charAt(i);\n          await sandbox.dispatchEventInSandbox({\n            id: refId,\n            value,\n            change,\n            name: \"Keystroke\",\n            willCommit: false,\n            selStart: i,\n            selEnd: i\n          });\n          expect(send_queue.has(refId)).toEqual(true);\n          send_queue.delete(refId);\n          value += change;\n        }\n\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value,\n          change: \"A\",\n          name: \"Keystroke\",\n          willCommit: false,\n          selStart: i,\n          selEnd: i\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        expect(send_queue.get(refId)).toEqual({\n          id: refId,\n          siblings: null,\n          value,\n          selRange: [i, i]\n        });\n        send_queue.delete(refId);\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should validate a US phone number (short) on a keystroke event","suites":["Scripting","AForm","AFSpecial_Keystroke"],"line":1210,"updatePoint":{"line":1210,"column":72,"index":37616},"code":"      it(\"should validate a US phone number (short) on a keystroke event\", async () => {\n        const refId = getId();\n        const data = {\n          objects: {\n            field: [{\n              id: refId,\n              value: \"\",\n              actions: {\n                Keystroke: [`AFSpecial_Keystroke(2);`]\n              },\n              type: \"text\"\n            }]\n          },\n          appInfo: {\n            language: \"en-US\",\n            platform: \"Linux x86_64\"\n          },\n          calculationOrder: [],\n          dispatchEventName: \"_dispatchMe\"\n        };\n        sandbox.createSandbox(data);\n        let value = \"\";\n        const changes = \"123-4567\";\n        let i = 0;\n\n        for (; i < changes.length; i++) {\n          const change = changes.charAt(i);\n          await sandbox.dispatchEventInSandbox({\n            id: refId,\n            value,\n            change,\n            name: \"Keystroke\",\n            willCommit: false,\n            selStart: i,\n            selEnd: i\n          });\n          expect(send_queue.has(refId)).toEqual(true);\n          send_queue.delete(refId);\n          value += change;\n        }\n\n        await sandbox.dispatchEventInSandbox({\n          id: refId,\n          value,\n          change: \"A\",\n          name: \"Keystroke\",\n          willCommit: false,\n          selStart: i,\n          selEnd: i\n        });\n        expect(send_queue.has(refId)).toEqual(true);\n        expect(send_queue.get(refId)).toEqual({\n          id: refId,\n          siblings: null,\n          value,\n          selRange: [i, i]\n        });\n        send_queue.delete(refId);\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should validate an e-mail address","suites":["Scripting","AForm","eMailValidate"],"line":1271,"updatePoint":{"line":1271,"column":43,"index":39250},"code":"      it(\"should validate an e-mail address\", async () => {\n        let value = await myeval(`eMailValidate(123)`);\n        expect(value).toEqual(false);\n        value = await myeval(`eMailValidate(\"foo@bar.com\")`);\n        expect(value).toEqual(true);\n        value = await myeval(`eMailValidate(\"foo bar\")`);\n        expect(value).toEqual(false);\n      });","file":"unit/scripting_spec.js","skipped":false,"dir":"test"},{"name":"should decode simple predictor data","suites":["stream","PredictorStream"],"line":20,"updatePoint":{"line":20,"column":43,"index":894},"code":"    it(\"should decode simple predictor data\", function () {\n      const dict = new Dict();\n      dict.set(\"Predictor\", 12);\n      dict.set(\"Colors\", 1);\n      dict.set(\"BitsPerComponent\", 8);\n      dict.set(\"Columns\", 2);\n      const input = new Stream(new Uint8Array([2, 100, 3, 2, 1, 255, 2, 1, 255]), 0, 9, dict);\n      const predictor = new PredictorStream(input,\n      /* length = */\n      9, dict);\n      const result = predictor.getBytes(6);\n      expect(result).toEqual(new Uint8Array([100, 3, 101, 2, 102, 1]));\n    });","file":"unit/stream_spec.js","skipped":false,"dir":"test"},{"name":"parses basic structure","suites":["struct tree","getStructTree"],"line":41,"updatePoint":{"line":41,"column":30,"index":1290},"code":"    it(\"parses basic structure\", async function () {\n      const filename = \"structure_simple.pdf\";\n      const params = buildGetDocumentParams(filename);\n      const loadingTask = getDocument(params);\n      const doc = await loadingTask.promise;\n      const page = await doc.getPage(1);\n      const struct = await page.getStructTree();\n      equalTrees({\n        role: \"Root\",\n        children: [{\n          role: \"Document\",\n          lang: \"en-US\",\n          children: [{\n            role: \"H1\",\n            children: [{\n              role: \"NonStruct\",\n              children: [{\n                type: \"content\"\n              }]\n            }]\n          }, {\n            role: \"P\",\n            children: [{\n              role: \"NonStruct\",\n              children: [{\n                type: \"content\"\n              }]\n            }]\n          }, {\n            role: \"H2\",\n            children: [{\n              role: \"NonStruct\",\n              children: [{\n                type: \"content\"\n              }]\n            }]\n          }, {\n            role: \"P\",\n            children: [{\n              role: \"NonStruct\",\n              children: [{\n                type: \"content\"\n              }]\n            }]\n          }]\n        }]\n      }, struct);\n      await loadingTask.destroy();\n    });","file":"unit/struct_tree_spec.js","skipped":false,"dir":"test"},{"name":"parses structure with marked content reference","suites":["struct tree","getStructTree"],"line":90,"updatePoint":{"line":90,"column":54,"index":2609},"code":"    it(\"parses structure with marked content reference\", async function () {\n      const filename = \"issue6782.pdf\";\n      const params = buildGetDocumentParams(filename);\n      const loadingTask = getDocument(params);\n      const doc = await loadingTask.promise;\n      const page = await doc.getPage(1);\n      const struct = await page.getStructTree();\n      equalTrees({\n        role: \"Root\",\n        children: [{\n          role: \"Part\",\n          children: [{\n            role: \"P\",\n            children: Array(27).fill({\n              type: \"content\"\n            })\n          }]\n        }]\n      }, struct);\n      await loadingTask.destroy();\n    });","file":"unit/struct_tree_spec.js","skipped":false,"dir":"test"},{"name":"creates textLayer from ReadableStream","suites":["textLayer"],"line":20,"updatePoint":{"line":20,"column":43,"index":937},"code":"  it(\"creates textLayer from ReadableStream\", async function () {\n    if (isNodeJS) {\n      pending(\"document.createDocumentFragment is not supported in Node.js.\");\n    }\n\n    const loadingTask = getDocument(buildGetDocumentParams(\"basicapi.pdf\"));\n    const pdfDocument = await loadingTask.promise;\n    const page = await pdfDocument.getPage(1);\n    const textContentItemsStr = [];\n    const textLayerRenderTask = renderTextLayer({\n      textContentStream: page.streamTextContent(),\n      container: document.createDocumentFragment(),\n      viewport: page.getViewport(),\n      textContentItemsStr\n    });\n    expect(textLayerRenderTask instanceof TextLayerRenderTask).toEqual(true);\n    await textLayerRenderTask.promise;\n    expect(textContentItemsStr).toEqual([\"Table Of Content\", \"\", \"Chapter 1\", \" \", \"..........................................................\", \" \", \"2\", \"\", \"Paragraph 1.1\", \" \", \"......................................................\", \" \", \"3\", \"\", \"page 1 / 3\"]);\n  });","file":"unit/text_layer_spec.js","skipped":false,"dir":"test"},{"name":"splits tokens","suites":["Type1Parser"],"line":19,"updatePoint":{"line":19,"column":19,"index":847},"code":"  it(\"splits tokens\", function () {\n    const stream = new StringStream(\"/BlueValues[-17 0]noaccess def\");\n    const parser = new Type1Parser(stream, false, SEAC_ANALYSIS_ENABLED);\n    expect(parser.getToken()).toEqual(\"/\");\n    expect(parser.getToken()).toEqual(\"BlueValues\");\n    expect(parser.getToken()).toEqual(\"[\");\n    expect(parser.getToken()).toEqual(\"-17\");\n    expect(parser.getToken()).toEqual(\"0\");\n    expect(parser.getToken()).toEqual(\"]\");\n    expect(parser.getToken()).toEqual(\"noaccess\");\n    expect(parser.getToken()).toEqual(\"def\");\n    expect(parser.getToken()).toEqual(null);\n  });","file":"unit/type1_parser_spec.js","skipped":false,"dir":"test"},{"name":"handles glued tokens","suites":["Type1Parser"],"line":32,"updatePoint":{"line":32,"column":26,"index":1458},"code":"  it(\"handles glued tokens\", function () {\n    const stream = new StringStream(\"dup/CharStrings\");\n    const parser = new Type1Parser(stream, false, SEAC_ANALYSIS_ENABLED);\n    expect(parser.getToken()).toEqual(\"dup\");\n    expect(parser.getToken()).toEqual(\"/\");\n    expect(parser.getToken()).toEqual(\"CharStrings\");\n  });","file":"unit/type1_parser_spec.js","skipped":false,"dir":"test"},{"name":"ignores whitespace","suites":["Type1Parser"],"line":39,"updatePoint":{"line":39,"column":24,"index":1779},"code":"  it(\"ignores whitespace\", function () {\n    const stream = new StringStream(\"\\nab   c\\t\");\n    const parser = new Type1Parser(stream, false, SEAC_ANALYSIS_ENABLED);\n    expect(parser.getToken()).toEqual(\"ab\");\n    expect(parser.getToken()).toEqual(\"c\");\n  });","file":"unit/type1_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses numbers","suites":["Type1Parser"],"line":45,"updatePoint":{"line":45,"column":20,"index":2036},"code":"  it(\"parses numbers\", function () {\n    const stream = new StringStream(\"123\");\n    const parser = new Type1Parser(stream, false, SEAC_ANALYSIS_ENABLED);\n    expect(parser.readNumber()).toEqual(123);\n  });","file":"unit/type1_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses booleans","suites":["Type1Parser"],"line":50,"updatePoint":{"line":50,"column":21,"index":2244},"code":"  it(\"parses booleans\", function () {\n    const stream = new StringStream(\"true false\");\n    const parser = new Type1Parser(stream, false, SEAC_ANALYSIS_ENABLED);\n    expect(parser.readBoolean()).toEqual(1);\n    expect(parser.readBoolean()).toEqual(0);\n  });","file":"unit/type1_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses number arrays","suites":["Type1Parser"],"line":56,"updatePoint":{"line":56,"column":26,"index":2508},"code":"  it(\"parses number arrays\", function () {\n    let stream = new StringStream(\"[1 2]\");\n    let parser = new Type1Parser(stream, false, SEAC_ANALYSIS_ENABLED);\n    expect(parser.readNumberArray()).toEqual([1, 2]); // Variation on spacing.\n\n    stream = new StringStream(\"[ 1 2 ]\");\n    parser = new Type1Parser(stream, false, SEAC_ANALYSIS_ENABLED);\n    expect(parser.readNumberArray()).toEqual([1, 2]);\n  });","file":"unit/type1_parser_spec.js","skipped":false,"dir":"test"},{"name":"skips comments","suites":["Type1Parser"],"line":65,"updatePoint":{"line":65,"column":20,"index":2911},"code":"  it(\"skips comments\", function () {\n    const stream = new StringStream(\"%!PS-AdobeFont-1.0: CMSY10 003.002\\n\" + \"%%Title: CMSY10\\n\" + \"%Version: 003.002\\n\" + \"FontDirectory\");\n    const parser = new Type1Parser(stream, false, SEAC_ANALYSIS_ENABLED);\n    expect(parser.getToken()).toEqual(\"FontDirectory\");\n  });","file":"unit/type1_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses font program","suites":["Type1Parser"],"line":70,"updatePoint":{"line":70,"column":25,"index":3230},"code":"  it(\"parses font program\", function () {\n    const stream = new StringStream(\"/ExpansionFactor  99\\n\" + \"/Subrs 1 array\\n\" + \"dup 0 1 RD x noaccess put\\n\" + \"end\\n\" + \"/CharStrings 46 dict dup begin\\n\" + \"/.notdef 1 RD x ND\\n\" + \"end\");\n    const parser = new Type1Parser(stream, false, SEAC_ANALYSIS_ENABLED);\n    const program = parser.extractFontProgram({});\n    expect(program.charstrings.length).toEqual(1);\n    expect(program.properties.privateData.ExpansionFactor).toEqual(99);\n  });","file":"unit/type1_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses font header font matrix","suites":["Type1Parser"],"line":77,"updatePoint":{"line":77,"column":36,"index":3733},"code":"  it(\"parses font header font matrix\", function () {\n    const stream = new StringStream(\"/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def\\n\");\n    const parser = new Type1Parser(stream, false, SEAC_ANALYSIS_ENABLED);\n    const props = {};\n    parser.extractFontHeader(props);\n    expect(props.fontMatrix).toEqual([0.001, 0, 0, 0.001, 0, 0]);\n  });","file":"unit/type1_parser_spec.js","skipped":false,"dir":"test"},{"name":"parses font header encoding","suites":["Type1Parser"],"line":84,"updatePoint":{"line":84,"column":33,"index":4077},"code":"  it(\"parses font header encoding\", function () {\n    const stream = new StringStream(\"/Encoding 256 array\\n\" + \"0 1 255 {1 index exch /.notdef put} for\\n\" + \"dup 33 /arrowright put\\n\" + \"readonly def\\n\");\n    const parser = new Type1Parser(stream, false, SEAC_ANALYSIS_ENABLED);\n    const props = {\n      overridableEncoding: true\n    };\n    parser.extractFontHeader(props);\n    expect(props.builtInEncoding[33]).toEqual(\"arrowright\");\n  });","file":"unit/type1_parser_spec.js","skipped":false,"dir":"test"},{"name":"should reject non-integer angles","suites":["ui_utils","isValidRotation"],"line":18,"updatePoint":{"line":18,"column":40,"index":913},"code":"    it(\"should reject non-integer angles\", function () {\n      expect(isValidRotation()).toEqual(false);\n      expect(isValidRotation(null)).toEqual(false);\n      expect(isValidRotation(NaN)).toEqual(false);\n      expect(isValidRotation([90])).toEqual(false);\n      expect(isValidRotation(\"90\")).toEqual(false);\n      expect(isValidRotation(90.5)).toEqual(false);\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"should reject non-multiple of 90 degree angles","suites":["ui_utils","isValidRotation"],"line":26,"updatePoint":{"line":26,"column":54,"index":1299},"code":"    it(\"should reject non-multiple of 90 degree angles\", function () {\n      expect(isValidRotation(45)).toEqual(false);\n      expect(isValidRotation(-123)).toEqual(false);\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"should accept valid angles","suites":["ui_utils","isValidRotation"],"line":30,"updatePoint":{"line":30,"column":34,"index":1460},"code":"    it(\"should accept valid angles\", function () {\n      expect(isValidRotation(0)).toEqual(true);\n      expect(isValidRotation(90)).toEqual(true);\n      expect(isValidRotation(-270)).toEqual(true);\n      expect(isValidRotation(540)).toEqual(true);\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"should be portrait orientation","suites":["ui_utils","isPortraitOrientation"],"line":38,"updatePoint":{"line":38,"column":38,"index":1777},"code":"    it(\"should be portrait orientation\", function () {\n      expect(isPortraitOrientation({\n        width: 200,\n        height: 400\n      })).toEqual(true);\n      expect(isPortraitOrientation({\n        width: 500,\n        height: 500\n      })).toEqual(true);\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"should be landscape orientation","suites":["ui_utils","isPortraitOrientation"],"line":48,"updatePoint":{"line":48,"column":39,"index":2045},"code":"    it(\"should be landscape orientation\", function () {\n      expect(isPortraitOrientation({\n        width: 600,\n        height: 300\n      })).toEqual(false);\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"should parse one key/value pair","suites":["ui_utils","parseQueryString"],"line":56,"updatePoint":{"line":56,"column":39,"index":2263},"code":"    it(\"should parse one key/value pair\", function () {\n      const parameters = parseQueryString(\"key1=value1\");\n      expect(parameters.size).toEqual(1);\n      expect(parameters.get(\"key1\")).toEqual(\"value1\");\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"should parse multiple key/value pairs","suites":["ui_utils","parseQueryString"],"line":61,"updatePoint":{"line":61,"column":45,"index":2489},"code":"    it(\"should parse multiple key/value pairs\", function () {\n      const parameters = parseQueryString(\"key1=value1&key2=value2&key3=value3\");\n      expect(parameters.size).toEqual(3);\n      expect(parameters.get(\"key1\")).toEqual(\"value1\");\n      expect(parameters.get(\"key2\")).toEqual(\"value2\");\n      expect(parameters.get(\"key3\")).toEqual(\"value3\");\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"should parse keys without values","suites":["ui_utils","parseQueryString"],"line":68,"updatePoint":{"line":68,"column":40,"index":2846},"code":"    it(\"should parse keys without values\", function () {\n      const parameters = parseQueryString(\"key1\");\n      expect(parameters.size).toEqual(1);\n      expect(parameters.get(\"key1\")).toEqual(\"\");\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"should decode encoded key/value pairs","suites":["ui_utils","parseQueryString"],"line":73,"updatePoint":{"line":73,"column":45,"index":3059},"code":"    it(\"should decode encoded key/value pairs\", function () {\n      const parameters = parseQueryString(\"k%C3%ABy1=valu%C3%AB1\");\n      expect(parameters.size).toEqual(1);\n      expect(parameters.get(\"këy1\")).toEqual(\"valuë1\");\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"should convert keys to lowercase","suites":["ui_utils","parseQueryString"],"line":78,"updatePoint":{"line":78,"column":40,"index":3290},"code":"    it(\"should convert keys to lowercase\", function () {\n      const parameters = parseQueryString(\"Key1=Value1&KEY2=Value2\");\n      expect(parameters.size).toEqual(2);\n      expect(parameters.get(\"key1\")).toEqual(\"Value1\");\n      expect(parameters.get(\"key2\")).toEqual(\"Value2\");\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"should not modify string without null characters","suites":["ui_utils","removeNullCharacters"],"line":86,"updatePoint":{"line":86,"column":56,"index":3650},"code":"    it(\"should not modify string without null characters\", function () {\n      const str = \"string without null chars\";\n      expect(removeNullCharacters(str)).toEqual(\"string without null chars\");\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"should modify string with null characters","suites":["ui_utils","removeNullCharacters"],"line":90,"updatePoint":{"line":90,"column":49,"index":3849},"code":"    it(\"should modify string with null characters\", function () {\n      const str = \"string\\x00With\\x00Null\\x00Chars\";\n      expect(removeNullCharacters(str)).toEqual(\"stringWithNullChars\");\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"should modify string with non-displayable characters","suites":["ui_utils","removeNullCharacters"],"line":94,"updatePoint":{"line":94,"column":60,"index":4059},"code":"    it(\"should modify string with non-displayable characters\", function () {\n      const str = Array.from(Array(32).keys()).map(x => String.fromCharCode(x) + \"a\").join(\"\"); // \\x00 is replaced by an empty string.\n\n      const expected = \"a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a\";\n      expect(removeNullCharacters(str,\n      /* replaceInvisible */\n      true)).toEqual(expected);\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets page size (in inches)","suites":["ui_utils","getPageSizeInches"],"line":104,"updatePoint":{"line":104,"column":34,"index":4497},"code":"    it(\"gets page size (in inches)\", function () {\n      const page = {\n        view: [0, 0, 595.28, 841.89],\n        userUnit: 1.0,\n        rotate: 0\n      };\n      const {\n        width,\n        height\n      } = getPageSizeInches(page);\n      expect(+width.toPrecision(3)).toEqual(8.27);\n      expect(+height.toPrecision(4)).toEqual(11.69);\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"gets page size (in inches), for non-default /Rotate entry","suites":["ui_utils","getPageSizeInches"],"line":117,"updatePoint":{"line":117,"column":65,"index":4879},"code":"    it(\"gets page size (in inches), for non-default /Rotate entry\", function () {\n      const pdfPage1 = {\n        view: [0, 0, 612, 792],\n        userUnit: 1,\n        rotate: 0\n      };\n      const {\n        width: width1,\n        height: height1\n      } = getPageSizeInches(pdfPage1);\n      expect(width1).toEqual(8.5);\n      expect(height1).toEqual(11);\n      const pdfPage2 = {\n        view: [0, 0, 612, 792],\n        userUnit: 1,\n        rotate: 90\n      };\n      const {\n        width: width2,\n        height: height2\n      } = getPageSizeInches(pdfPage2);\n      expect(width2).toEqual(11);\n      expect(height2).toEqual(8.5);\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"with pages of varying height","suites":["ui_utils","getVisibleElements"],"line":293,"updatePoint":{"line":293,"column":36,"index":11471},"code":"    it(\"with pages of varying height\", function () {\n      const pages = makePages([[[50, 20], [20, 50]], [[30, 12], [12, 30]], [[20, 50], [50, 20]], [[50, 20], [20, 50]]]);\n      scrollOverDocument(pages);\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"widescreen challenge","suites":["ui_utils","getVisibleElements"],"line":297,"updatePoint":{"line":297,"column":28,"index":11678},"code":"    it(\"widescreen challenge\", function () {\n      const pages = makePages([[[10, 50], [10, 60], [10, 70], [10, 80], [10, 90]], [[10, 90], [10, 80], [10, 70], [10, 60], [10, 50]], [[10, 50], [10, 60], [10, 70], [10, 80], [10, 90]]]);\n      scrollOverDocument(pages);\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"works with horizontal scrolling","suites":["ui_utils","getVisibleElements"],"line":301,"updatePoint":{"line":301,"column":39,"index":11964},"code":"    it(\"works with horizontal scrolling\", function () {\n      const pages = makePages([[[10, 50], [20, 20], [30, 10]]]);\n      scrollOverDocument(pages,\n      /* horizontal = */\n      true);\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"works with horizontal scrolling with RTL-documents","suites":["ui_utils","getVisibleElements"],"line":307,"updatePoint":{"line":307,"column":58,"index":12182},"code":"    it(\"works with horizontal scrolling with RTL-documents\", function () {\n      const pages = makePages([[[-10, 50], [-20, 20], [-30, 10]]]);\n      scrollOverDocument(pages,\n      /* horizontal = */\n      true,\n      /* rtl = */\n      true);\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles `sortByVisibility` correctly","suites":["ui_utils","getVisibleElements"],"line":315,"updatePoint":{"line":315,"column":44,"index":12419},"code":"    it(\"handles `sortByVisibility` correctly\", function () {\n      const scrollEl = {\n        scrollTop: 75,\n        scrollLeft: 0,\n        clientHeight: 750,\n        clientWidth: 1500\n      };\n      const views = makePages([[[100, 150]], [[100, 150]], [[100, 150]]]);\n      const visible = getVisibleElements({\n        scrollEl,\n        views\n      });\n      const visibleSorted = getVisibleElements({\n        scrollEl,\n        views,\n        sortByVisibility: true\n      });\n      const viewsOrder = [],\n            viewsSortedOrder = [];\n\n      for (const view of visible.views) {\n        viewsOrder.push(view.id);\n      }\n\n      for (const view of visibleSorted.views) {\n        viewsSortedOrder.push(view.id);\n      }\n\n      expect(viewsOrder).toEqual([0, 1, 2]);\n      expect(viewsSortedOrder).toEqual([1, 2, 0]);\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles views being empty","suites":["ui_utils","getVisibleElements"],"line":346,"updatePoint":{"line":346,"column":33,"index":13236},"code":"    it(\"handles views being empty\", function () {\n      const scrollEl = {\n        scrollTop: 10,\n        scrollLeft: 0,\n        clientHeight: 750,\n        clientWidth: 1500\n      };\n      const views = [];\n      expect(getVisibleElements({\n        scrollEl,\n        views\n      })).toEqual({\n        first: undefined,\n        last: undefined,\n        views: [],\n        ids: new Set()\n      });\n    });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles all views being hidden (without errors)","suites":["ui_utils","getVisibleElements"],"line":364,"updatePoint":{"line":364,"column":55,"index":13662},"code":"    it(\"handles all views being hidden (without errors)\", function () {\n      const scrollEl = {\n        scrollTop: 100000,\n        scrollLeft: 0,\n        clientHeight: 750,\n        clientWidth: 1500\n      };\n      const views = makePages([[[100, 150]], [[100, 150]], [[100, 150]]]);\n      expect(getVisibleElements({\n        scrollEl,\n        views\n      })).toEqual({\n        first: undefined,\n        last: undefined,\n        views: [],\n        ids: new Set()\n      });\n    }); // This sub-suite is for a notionally internal helper function for","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles case 1","suites":["ui_utils","getVisibleElements","backtrackBeforeAllVisibleElements"],"line":401,"updatePoint":{"line":401,"column":24,"index":15042},"code":"      it(\"handles case 1\", function () {\n        const pages = makePages([[[10, 20], [10, 20], [10, 20], [10, 20]], [tallPage, shortPage, tallPage, shortPage], [[10, 50], [10, 50], [10, 50], [10, 50]], [[10, 20], [10, 20], [10, 20], [10, 20]], [[10, 20]]]); // binary search would land on the second row, first page\n\n        const bsResult = 4;\n        expect(backtrackBeforeAllVisibleElements(bsResult, pages, top1)).toEqual(4);\n      });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles case 2","suites":["ui_utils","getVisibleElements","backtrackBeforeAllVisibleElements"],"line":407,"updatePoint":{"line":407,"column":24,"index":15482},"code":"      it(\"handles case 2\", function () {\n        const pages = makePages([[[10, 20], [10, 20], [10, 20], [10, 20]], [tallPage, shortPage, tallPage, tallPage], [[10, 50], [10, 50], [10, 50], [10, 50]], [[10, 20], [10, 20], [10, 20], [10, 20]]]); // binary search would land on the second row, third page\n\n        const bsResult = 6;\n        expect(backtrackBeforeAllVisibleElements(bsResult, pages, top1)).toEqual(4);\n      });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles case 3","suites":["ui_utils","getVisibleElements","backtrackBeforeAllVisibleElements"],"line":413,"updatePoint":{"line":413,"column":24,"index":15909},"code":"      it(\"handles case 3\", function () {\n        const pages = makePages([[[10, 20], [10, 20], [10, 20], [10, 20]], [tallPage, shortPage, tallPage, shortPage], [[10, 50], [10, 50], [10, 50], [10, 50]], [[10, 20], [10, 20], [10, 20], [10, 20]]]); // binary search would land on the third row, first page\n\n        const bsResult = 8;\n        expect(backtrackBeforeAllVisibleElements(bsResult, pages, top1)).toEqual(4);\n      });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"handles case 4","suites":["ui_utils","getVisibleElements","backtrackBeforeAllVisibleElements"],"line":419,"updatePoint":{"line":419,"column":24,"index":16336},"code":"      it(\"handles case 4\", function () {\n        const pages = makePages([[[10, 20], [10, 20], [10, 20], [10, 20]], [tallPage, shortPage, tallPage, shortPage], [[10, 50], [10, 50], [10, 50], [10, 50]], [[10, 20], [10, 20], [10, 20], [10, 20]]]); // binary search would land on the second row, first page\n\n        const bsResult = 4;\n        expect(backtrackBeforeAllVisibleElements(bsResult, pages, top2)).toEqual(4);\n      });","file":"unit/ui_utils_spec.js","skipped":false,"dir":"test"},{"name":"should not re-map normal Unicode values","suites":["unicode","mapSpecialUnicodeValues"],"line":19,"updatePoint":{"line":19,"column":47,"index":993},"code":"    it(\"should not re-map normal Unicode values\", function () {\n      // A\n      expect(mapSpecialUnicodeValues(0x0041)).toEqual(0x0041); // fi\n\n      expect(mapSpecialUnicodeValues(0xfb01)).toEqual(0xfb01);\n    });","file":"unit/unicode_spec.js","skipped":false,"dir":"test"},{"name":"should re-map special Unicode values","suites":["unicode","mapSpecialUnicodeValues"],"line":25,"updatePoint":{"line":25,"column":44,"index":1206},"code":"    it(\"should re-map special Unicode values\", function () {\n      // copyrightsans => copyright\n      expect(mapSpecialUnicodeValues(0xf8e9)).toEqual(0x00a9); // Private Use Area characters\n\n      expect(mapSpecialUnicodeValues(0xffff)).toEqual(0);\n    });","file":"unit/unicode_spec.js","skipped":false,"dir":"test"},{"name":"should correctly determine the character category","suites":["unicode","getCharUnicodeCategory"],"line":33,"updatePoint":{"line":33,"column":57,"index":1534},"code":"    it(\"should correctly determine the character category\", function () {\n      const tests = {\n        // Whitespace\n        \" \": {\n          isZeroWidthDiacritic: false,\n          isInvisibleFormatMark: false,\n          isWhitespace: true\n        },\n        \"\\t\": {\n          isZeroWidthDiacritic: false,\n          isInvisibleFormatMark: false,\n          isWhitespace: true\n        },\n        \"\\u2001\": {\n          isZeroWidthDiacritic: false,\n          isInvisibleFormatMark: false,\n          isWhitespace: true\n        },\n        \"\\uFEFF\": {\n          isZeroWidthDiacritic: false,\n          isInvisibleFormatMark: false,\n          isWhitespace: true\n        },\n        // Diacritic\n        \"\\u0302\": {\n          isZeroWidthDiacritic: true,\n          isInvisibleFormatMark: false,\n          isWhitespace: false\n        },\n        \"\\u0344\": {\n          isZeroWidthDiacritic: true,\n          isInvisibleFormatMark: false,\n          isWhitespace: false\n        },\n        \"\\u0361\": {\n          isZeroWidthDiacritic: true,\n          isInvisibleFormatMark: false,\n          isWhitespace: false\n        },\n        // Invisible format mark\n        \"\\u200B\": {\n          isZeroWidthDiacritic: false,\n          isInvisibleFormatMark: true,\n          isWhitespace: false\n        },\n        \"\\u200D\": {\n          isZeroWidthDiacritic: false,\n          isInvisibleFormatMark: true,\n          isWhitespace: false\n        },\n        // No whitespace or diacritic or invisible format mark\n        a: {\n          isZeroWidthDiacritic: false,\n          isInvisibleFormatMark: false,\n          isWhitespace: false\n        },\n        1: {\n          isZeroWidthDiacritic: false,\n          isInvisibleFormatMark: false,\n          isWhitespace: false\n        }\n      };\n\n      for (const [character, expectation] of Object.entries(tests)) {\n        expect(getCharUnicodeCategory(character)).toEqual(expectation);\n      }\n    });","file":"unit/unicode_spec.js","skipped":false,"dir":"test"},{"name":"should get Unicode values for valid glyph names","suites":["unicode","getUnicodeForGlyph"],"line":110,"updatePoint":{"line":110,"column":55,"index":3728},"code":"    it(\"should get Unicode values for valid glyph names\", function () {\n      expect(getUnicodeForGlyph(\"A\", standardMap)).toEqual(0x0041);\n      expect(getUnicodeForGlyph(\"a1\", dingbatsMap)).toEqual(0x2701);\n    });","file":"unit/unicode_spec.js","skipped":false,"dir":"test"},{"name":"should recover Unicode values from uniXXXX/uXXXX{XX} glyph names","suites":["unicode","getUnicodeForGlyph"],"line":114,"updatePoint":{"line":114,"column":72,"index":3962},"code":"    it(\"should recover Unicode values from uniXXXX/uXXXX{XX} glyph names\", function () {\n      expect(getUnicodeForGlyph(\"uni0041\", standardMap)).toEqual(0x0041);\n      expect(getUnicodeForGlyph(\"u0041\", standardMap)).toEqual(0x0041);\n      expect(getUnicodeForGlyph(\"uni2701\", dingbatsMap)).toEqual(0x2701);\n      expect(getUnicodeForGlyph(\"u2701\", dingbatsMap)).toEqual(0x2701);\n    });","file":"unit/unicode_spec.js","skipped":false,"dir":"test"},{"name":"should not get Unicode values for invalid glyph names","suites":["unicode","getUnicodeForGlyph"],"line":120,"updatePoint":{"line":120,"column":61,"index":4340},"code":"    it(\"should not get Unicode values for invalid glyph names\", function () {\n      expect(getUnicodeForGlyph(\"Qwerty\", standardMap)).toEqual(-1);\n      expect(getUnicodeForGlyph(\"Qwerty\", dingbatsMap)).toEqual(-1);\n    });","file":"unit/unicode_spec.js","skipped":false,"dir":"test"},{"name":"should get correct Unicode range","suites":["unicode","getUnicodeRangeFor"],"line":126,"updatePoint":{"line":126,"column":40,"index":4596},"code":"    it(\"should get correct Unicode range\", function () {\n      // A (Basic Latin)\n      expect(getUnicodeRangeFor(0x0041)).toEqual(0); // fi (Alphabetic Presentation Forms)\n\n      expect(getUnicodeRangeFor(0xfb01)).toEqual(62);\n    });","file":"unit/unicode_spec.js","skipped":false,"dir":"test"},{"name":"should not get a Unicode range","suites":["unicode","getUnicodeRangeFor"],"line":132,"updatePoint":{"line":132,"column":38,"index":4830},"code":"    it(\"should not get a Unicode range\", function () {\n      expect(getUnicodeRangeFor(0x05ff)).toEqual(-1);\n    });","file":"unit/unicode_spec.js","skipped":false,"dir":"test"},{"name":"should get normalized Unicode values for ligatures","suites":["unicode","getNormalizedUnicodes"],"line":144,"updatePoint":{"line":144,"column":58,"index":5207},"code":"    it(\"should get normalized Unicode values for ligatures\", function () {\n      // fi => f + i\n      expect(NormalizedUnicodes[\"\\uFB01\"]).toEqual(\"fi\"); // Arabic\n\n      expect(NormalizedUnicodes[\"\\u0675\"]).toEqual(\"\\u0627\\u0674\");\n    });","file":"unit/unicode_spec.js","skipped":false,"dir":"test"},{"name":"should not normalize standard characters","suites":["unicode","getNormalizedUnicodes"],"line":150,"updatePoint":{"line":150,"column":48,"index":5438},"code":"    it(\"should not normalize standard characters\", function () {\n      expect(NormalizedUnicodes.A).toEqual(undefined);\n    });","file":"unit/unicode_spec.js","skipped":false,"dir":"test"},{"name":"should not reverse LTR characters","suites":["unicode","reverseIfRtl"],"line":171,"updatePoint":{"line":171,"column":41,"index":5956},"code":"    it(\"should not reverse LTR characters\", function () {\n      const A = getGlyphUnicode(\"A\");\n      expect(reverseIfRtl(A)).toEqual(\"A\");\n      const fi = getGlyphUnicode(\"\\uFB01\");\n      expect(reverseIfRtl(fi)).toEqual(\"fi\");\n    });","file":"unit/unicode_spec.js","skipped":false,"dir":"test"},{"name":"should reverse RTL characters","suites":["unicode","reverseIfRtl"],"line":177,"updatePoint":{"line":177,"column":37,"index":6190},"code":"    it(\"should reverse RTL characters\", function () {\n      // Hebrew (no-op, since it's not a combined character)\n      const heAlef = getGlyphUnicode(\"\\u05D0\");\n      expect(reverseIfRtl(heAlef)).toEqual(\"\\u05D0\"); // Arabic\n\n      const arAlef = getGlyphUnicode(\"\\u0675\");\n      expect(reverseIfRtl(arAlef)).toEqual(\"\\u0674\\u0627\");\n    });","file":"unit/unicode_spec.js","skipped":false,"dir":"test"},{"name":"handles non-array arguments","suites":["util","bytesToString"],"line":18,"updatePoint":{"line":18,"column":35,"index":941},"code":"    it(\"handles non-array arguments\", function () {\n      expect(function () {\n        bytesToString(null);\n      }).toThrow(new Error(\"Invalid argument for bytesToString\"));\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"handles array arguments with a length not exceeding the maximum","suites":["util","bytesToString"],"line":23,"updatePoint":{"line":23,"column":71,"index":1160},"code":"    it(\"handles array arguments with a length not exceeding the maximum\", function () {\n      expect(bytesToString(new Uint8Array([]))).toEqual(\"\");\n      expect(bytesToString(new Uint8Array([102, 111, 111]))).toEqual(\"foo\");\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"handles array arguments with a length exceeding the maximum","suites":["util","bytesToString"],"line":27,"updatePoint":{"line":27,"column":67,"index":1390},"code":"    it(\"handles array arguments with a length exceeding the maximum\", function () {\n      const length = 10000; // Larger than MAX_ARGUMENT_COUNT = 8192.\n      // Create an array with `length` 'a' character codes.\n\n      const bytes = new Uint8Array(length);\n\n      for (let i = 0; i < length; i++) {\n        bytes[i] = \"a\".charCodeAt(0);\n      } // Create a string with `length` 'a' characters.\n\n\n      const string = \"a\".repeat(length);\n      expect(bytesToString(bytes)).toEqual(string);\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"handles array buffer values","suites":["util","isArrayBuffer"],"line":43,"updatePoint":{"line":43,"column":35,"index":1905},"code":"    it(\"handles array buffer values\", function () {\n      expect(isArrayBuffer(new ArrayBuffer(0))).toEqual(true);\n      expect(isArrayBuffer(new Uint8Array(0))).toEqual(true);\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"handles non-array buffer values","suites":["util","isArrayBuffer"],"line":47,"updatePoint":{"line":47,"column":39,"index":2094},"code":"    it(\"handles non-array buffer values\", function () {\n      expect(isArrayBuffer(\"true\")).toEqual(false);\n      expect(isArrayBuffer(1)).toEqual(false);\n      expect(isArrayBuffer(null)).toEqual(false);\n      expect(isArrayBuffer(undefined)).toEqual(false);\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"converts unsigned 32-bit integers to strings","suites":["util","string32"],"line":55,"updatePoint":{"line":55,"column":52,"index":2418},"code":"    it(\"converts unsigned 32-bit integers to strings\", function () {\n      expect(string32(0x74727565)).toEqual(\"true\");\n      expect(string32(0x74797031)).toEqual(\"typ1\");\n      expect(string32(0x4f54544f)).toEqual(\"OTTO\");\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"handles non-string arguments","suites":["util","stringToBytes"],"line":62,"updatePoint":{"line":62,"column":36,"index":2683},"code":"    it(\"handles non-string arguments\", function () {\n      expect(function () {\n        stringToBytes(null);\n      }).toThrow(new Error(\"Invalid argument for stringToBytes\"));\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"handles string arguments","suites":["util","stringToBytes"],"line":67,"updatePoint":{"line":67,"column":32,"index":2863},"code":"    it(\"handles string arguments\", function () {\n      expect(stringToBytes(\"\")).toEqual(new Uint8Array([]));\n      expect(stringToBytes(\"foo\")).toEqual(new Uint8Array([102, 111, 111]));\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"handles ISO Latin 1 strings","suites":["util","stringToPDFString"],"line":73,"updatePoint":{"line":73,"column":35,"index":3113},"code":"    it(\"handles ISO Latin 1 strings\", function () {\n      const str = \"\\x8Dstring\\x8E\";\n      expect(stringToPDFString(str)).toEqual(\"\\u201Cstring\\u201D\");\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"handles UTF-16 big-endian strings","suites":["util","stringToPDFString"],"line":77,"updatePoint":{"line":77,"column":41,"index":3283},"code":"    it(\"handles UTF-16 big-endian strings\", function () {\n      const str = \"\\xFE\\xFF\\x00\\x73\\x00\\x74\\x00\\x72\\x00\\x69\\x00\\x6E\\x00\\x67\";\n      expect(stringToPDFString(str)).toEqual(\"string\");\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"handles UTF-16 little-endian strings","suites":["util","stringToPDFString"],"line":81,"updatePoint":{"line":81,"column":44,"index":3486},"code":"    it(\"handles UTF-16 little-endian strings\", function () {\n      const str = \"\\xFF\\xFE\\x73\\x00\\x74\\x00\\x72\\x00\\x69\\x00\\x6E\\x00\\x67\\x00\";\n      expect(stringToPDFString(str)).toEqual(\"string\");\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"handles UTF-8 strings","suites":["util","stringToPDFString"],"line":85,"updatePoint":{"line":85,"column":29,"index":3674},"code":"    it(\"handles UTF-8 strings\", function () {\n      const simpleStr = \"\\xEF\\xBB\\xBF\\x73\\x74\\x72\\x69\\x6E\\x67\";\n      expect(stringToPDFString(simpleStr)).toEqual(\"string\");\n      const complexStr = \"\\xEF\\xBB\\xBF\\xE8\\xA1\\xA8\\xE3\\x83\\x9D\\xE3\\x81\\x82\\x41\\xE9\\xB7\\x97\" + \"\\xC5\\x92\\xC3\\xA9\\xEF\\xBC\\xA2\\xE9\\x80\\x8D\\xC3\\x9C\\xC3\\x9F\\xC2\\xAA\" + \"\\xC4\\x85\\xC3\\xB1\\xE4\\xB8\\x82\\xE3\\x90\\x80\\xF0\\xA0\\x80\\x80\";\n      expect(stringToPDFString(complexStr)).toEqual(\"表ポあA鷗ŒéＢ逍Üßªąñ丂㐀𠀀\");\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"handles empty strings","suites":["util","stringToPDFString"],"line":91,"updatePoint":{"line":91,"column":29,"index":4152},"code":"    it(\"handles empty strings\", function () {\n      // ISO Latin 1\n      const str1 = \"\";\n      expect(stringToPDFString(str1)).toEqual(\"\"); // UTF-16BE\n\n      const str2 = \"\\xFE\\xFF\";\n      expect(stringToPDFString(str2)).toEqual(\"\"); // UTF-16LE\n\n      const str3 = \"\\xFF\\xFE\";\n      expect(stringToPDFString(str3)).toEqual(\"\"); // UTF-8\n\n      const str4 = \"\\xEF\\xBB\\xBF\";\n      expect(stringToPDFString(str4)).toEqual(\"\");\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"should return an Object","suites":["util","ReadableStream"],"line":107,"updatePoint":{"line":107,"column":31,"index":4638},"code":"    it(\"should return an Object\", function () {\n      const readable = new ReadableStream();\n      expect(typeof readable).toEqual(\"object\");\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"should have property getReader","suites":["util","ReadableStream"],"line":111,"updatePoint":{"line":111,"column":38,"index":4795},"code":"    it(\"should have property getReader\", function () {\n      const readable = new ReadableStream();\n      expect(typeof readable.getReader).toEqual(\"function\");\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"should return an Object","suites":["util","URL"],"line":117,"updatePoint":{"line":117,"column":31,"index":4995},"code":"    it(\"should return an Object\", function () {\n      const url = new URL(\"https://example.com\");\n      expect(typeof url).toEqual(\"object\");\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"should have property `href`","suites":["util","URL"],"line":121,"updatePoint":{"line":121,"column":35,"index":5149},"code":"    it(\"should have property `href`\", function () {\n      const url = new URL(\"https://example.com\");\n      expect(typeof url.href).toEqual(\"string\");\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"handles invalid URLs","suites":["util","createValidAbsoluteUrl"],"line":127,"updatePoint":{"line":127,"column":28,"index":5358},"code":"    it(\"handles invalid URLs\", function () {\n      expect(createValidAbsoluteUrl(undefined, undefined)).toEqual(null);\n      expect(createValidAbsoluteUrl(null, null)).toEqual(null);\n      expect(createValidAbsoluteUrl(\"/foo\", \"/bar\")).toEqual(null);\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"handles URLs that do not use an allowed protocol","suites":["util","createValidAbsoluteUrl"],"line":132,"updatePoint":{"line":132,"column":56,"index":5645},"code":"    it(\"handles URLs that do not use an allowed protocol\", function () {\n      expect(createValidAbsoluteUrl(\"magnet:?foo\", null)).toEqual(null);\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"correctly creates a valid URL for allowed protocols","suites":["util","createValidAbsoluteUrl"],"line":135,"updatePoint":{"line":135,"column":59,"index":5802},"code":"    it(\"correctly creates a valid URL for allowed protocols\", function () {\n      // `http` protocol\n      expect(createValidAbsoluteUrl(\"http://www.mozilla.org/foo\", null)).toEqual(new URL(\"http://www.mozilla.org/foo\"));\n      expect(createValidAbsoluteUrl(\"/foo\", \"http://www.mozilla.org\")).toEqual(new URL(\"http://www.mozilla.org/foo\")); // `https` protocol\n\n      expect(createValidAbsoluteUrl(\"https://www.mozilla.org/foo\", null)).toEqual(new URL(\"https://www.mozilla.org/foo\"));\n      expect(createValidAbsoluteUrl(\"/foo\", \"https://www.mozilla.org\")).toEqual(new URL(\"https://www.mozilla.org/foo\")); // `ftp` protocol\n\n      expect(createValidAbsoluteUrl(\"ftp://www.mozilla.org/foo\", null)).toEqual(new URL(\"ftp://www.mozilla.org/foo\"));\n      expect(createValidAbsoluteUrl(\"/foo\", \"ftp://www.mozilla.org\")).toEqual(new URL(\"ftp://www.mozilla.org/foo\")); // `mailto` protocol (base URLs have no meaning and should yield `null`)\n\n      expect(createValidAbsoluteUrl(\"mailto:foo@bar.baz\", null)).toEqual(new URL(\"mailto:foo@bar.baz\"));\n      expect(createValidAbsoluteUrl(\"/foo\", \"mailto:foo@bar.baz\")).toEqual(null); // `tel` protocol (base URLs have no meaning and should yield `null`)\n\n      expect(createValidAbsoluteUrl(\"tel:+0123456789\", null)).toEqual(new URL(\"tel:+0123456789\"));\n      expect(createValidAbsoluteUrl(\"/foo\", \"tel:0123456789\")).toEqual(null);\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"should resolve with correct data","suites":["util","createPromiseCapability"],"line":154,"updatePoint":{"line":154,"column":40,"index":7219},"code":"    it(\"should resolve with correct data\", async function () {\n      const promiseCapability = createPromiseCapability();\n      expect(promiseCapability.settled).toEqual(false);\n      promiseCapability.resolve({\n        test: \"abc\"\n      });\n      const data = await promiseCapability.promise;\n      expect(promiseCapability.settled).toEqual(true);\n      expect(data).toEqual({\n        test: \"abc\"\n      });\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"should reject with correct reason","suites":["util","createPromiseCapability"],"line":166,"updatePoint":{"line":166,"column":41,"index":7636},"code":"    it(\"should reject with correct reason\", async function () {\n      const promiseCapability = createPromiseCapability();\n      expect(promiseCapability.settled).toEqual(false);\n      promiseCapability.reject(new Error(\"reason\"));\n\n      try {\n        await promiseCapability.promise; // Shouldn't get here.\n\n        expect(false).toEqual(true);\n      } catch (reason) {\n        expect(promiseCapability.settled).toEqual(true);\n        expect(reason instanceof Error).toEqual(true);\n        expect(reason.message).toEqual(\"reason\");\n      }\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"should escape (, ), \\n, \\r, and \\","suites":["util","escapeString"],"line":183,"updatePoint":{"line":183,"column":44,"index":8236},"code":"    it(\"should escape (, ), \\\\n, \\\\r, and \\\\\", function () {\n      expect(escapeString(\"((a\\\\a))\\n(b(b\\\\b)\\rb)\")).toEqual(\"\\\\(\\\\(a\\\\\\\\a\\\\)\\\\)\\\\n\\\\(b\\\\(b\\\\\\\\b\\\\)\\\\rb\\\\)\");\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"should get a correctly formatted date","suites":["util","getModificationDate"],"line":188,"updatePoint":{"line":188,"column":45,"index":8470},"code":"    it(\"should get a correctly formatted date\", function () {\n      const date = new Date(Date.UTC(3141, 5, 9, 2, 6, 53));\n      expect(getModificationDate(date)).toEqual(\"31410609020653\");\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"handles ascii/non-ascii strings","suites":["util","isAscii"],"line":194,"updatePoint":{"line":194,"column":39,"index":8704},"code":"    it(\"handles ascii/non-ascii strings\", function () {\n      expect(isAscii(\"hello world\")).toEqual(true);\n      expect(isAscii(\"こんにちは世界の\")).toEqual(false);\n      expect(isAscii(\"hello world in Japanese is こんにちは世界の\")).toEqual(false);\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"should encode a string in UTF16BE with a BOM","suites":["util","stringToUTF16BEString"],"line":201,"updatePoint":{"line":201,"column":52,"index":9016},"code":"    it(\"should encode a string in UTF16BE with a BOM\", function () {\n      expect(stringToUTF16BEString(\"hello world\")).toEqual(\"\\xfe\\xff\\0h\\0e\\0l\\0l\\0o\\0 \\0w\\0o\\0r\\0l\\0d\");\n      expect(stringToUTF16BEString(\"こんにちは世界の\")).toEqual(\"\\xfe\\xff\\x30\\x53\\x30\\x93\\x30\\x6b\\x30\\x61\" + \"\\x30\\x6f\\x4e\\x16\\x75\\x4c\\x30\\x6e\");\n    });","file":"unit/util_spec.js","skipped":false,"dir":"test"},{"name":"should update a file with new objects","suites":["Writer","Incremental update"],"line":21,"updatePoint":{"line":21,"column":45,"index":977},"code":"    it(\"should update a file with new objects\", function () {\n      const originalData = new Uint8Array();\n      const newRefs = [{\n        ref: Ref.get(123, 0x2d),\n        data: \"abc\\n\"\n      }, {\n        ref: Ref.get(456, 0x4e),\n        data: \"defg\\n\"\n      }];\n      const xrefInfo = {\n        newRef: Ref.get(789, 0),\n        startXRef: 314,\n        fileIds: [\"id\", \"\"],\n        rootRef: null,\n        infoRef: null,\n        encryptRef: null,\n        filename: \"foo.pdf\",\n        info: {}\n      };\n      let data = incrementalUpdate({\n        originalData,\n        xrefInfo,\n        newRefs\n      });\n      data = bytesToString(data);\n      const expected = \"\\nabc\\n\" + \"defg\\n\" + \"789 0 obj\\n\" + \"<< /Size 790 /Prev 314 /Type /XRef /Index [0 1 123 1 456 1 789 1] \" + \"/ID [(id) (\\x01#Eg\\x89\\xab\\xcd\\xef\\xfe\\xdc\\xba\\x98vT2\\x10)] \" + \"/W [1 1 2] /Length 16>> stream\\n\" + \"\\x00\\x01\\xff\\xff\" + \"\\x01\\x01\\x00\\x2d\" + \"\\x01\\x05\\x00\\x4e\" + \"\\x01\\x0a\\x00\\x00\\n\" + \"endstream\\n\" + \"endobj\\n\" + \"startxref\\n\" + \"10\\n\" + \"%%EOF\\n\";\n      expect(data).toEqual(expected);\n    });","file":"unit/writer_spec.js","skipped":false,"dir":"test"},{"name":"should update a file, missing the /ID-entry, with new objects","suites":["Writer","Incremental update"],"line":49,"updatePoint":{"line":49,"column":69,"index":2072},"code":"    it(\"should update a file, missing the /ID-entry, with new objects\", function () {\n      const originalData = new Uint8Array();\n      const newRefs = [{\n        ref: Ref.get(123, 0x2d),\n        data: \"abc\\n\"\n      }];\n      const xrefInfo = {\n        newRef: Ref.get(789, 0),\n        startXRef: 314,\n        fileIds: null,\n        rootRef: null,\n        infoRef: null,\n        encryptRef: null,\n        filename: \"foo.pdf\",\n        info: {}\n      };\n      let data = incrementalUpdate({\n        originalData,\n        xrefInfo,\n        newRefs\n      });\n      data = bytesToString(data);\n      const expected = \"\\nabc\\n\" + \"789 0 obj\\n\" + \"<< /Size 790 /Prev 314 /Type /XRef /Index [0 1 123 1 789 1] \" + \"/W [1 1 2] /Length 12>> stream\\n\" + \"\\x00\\x01\\xff\\xff\" + \"\\x01\\x01\\x00\\x2d\" + \"\\x01\\x05\\x00\\x00\\n\" + \"endstream\\n\" + \"endobj\\n\" + \"startxref\\n\" + \"5\\n\" + \"%%EOF\\n\";\n      expect(data).toEqual(expected);\n    });","file":"unit/writer_spec.js","skipped":false,"dir":"test"},{"name":"should write a Dict","suites":["Writer","writeDict"],"line":76,"updatePoint":{"line":76,"column":27,"index":2992},"code":"    it(\"should write a Dict\", function () {\n      const dict = new Dict(null);\n      dict.set(\"A\", Name.get(\"B\"));\n      dict.set(\"B\", Ref.get(123, 456));\n      dict.set(\"C\", 789);\n      dict.set(\"D\", \"hello world\");\n      dict.set(\"E\", \"(hello\\\\world)\");\n      dict.set(\"F\", [1.23001, 4.50001, 6]);\n      const gdict = new Dict(null);\n      gdict.set(\"H\", 123.00001);\n      const string = \"a stream\";\n      const stream = new StringStream(string);\n      stream.dict = new Dict(null);\n      stream.dict.set(\"Length\", string.length);\n      gdict.set(\"I\", stream);\n      dict.set(\"G\", gdict);\n      dict.set(\"J\", true);\n      dict.set(\"K\", false);\n      dict.set(\"NullArr\", [null, 10]);\n      dict.set(\"NullVal\", null);\n      const buffer = [];\n      writeDict(dict, buffer, null);\n      const expected = \"<< /A /B /B 123 456 R /C 789 /D (hello world) \" + \"/E (\\\\(hello\\\\\\\\world\\\\)) /F [1.23 4.5 6] \" + \"/G << /H 123 /I << /Length 8>> stream\\n\" + \"a stream\\n\" + \"endstream\\n>> /J true /K false \" + \"/NullArr [null 10] /NullVal null>>\";\n      expect(buffer.join(\"\")).toEqual(expected);\n    });","file":"unit/writer_spec.js","skipped":false,"dir":"test"},{"name":"should write a Dict in escaping PDF names","suites":["Writer","writeDict"],"line":101,"updatePoint":{"line":101,"column":49,"index":4105},"code":"    it(\"should write a Dict in escaping PDF names\", function () {\n      const dict = new Dict(null);\n      dict.set(\"\\xfeA#\", Name.get(\"hello\"));\n      dict.set(\"B\", Name.get(\"#hello\"));\n      dict.set(\"C\", Name.get(\"he\\xfello\\xff\"));\n      const buffer = [];\n      writeDict(dict, buffer, null);\n      const expected = \"<< /#feA#23 /hello /B /#23hello /C /he#fello#ff>>\";\n      expect(buffer.join(\"\")).toEqual(expected);\n    });","file":"unit/writer_spec.js","skipped":false,"dir":"test"},{"name":"should update AcroForm when no datasets in XFA array","suites":["Writer","XFA"],"line":113,"updatePoint":{"line":113,"column":60,"index":4584},"code":"    it(\"should update AcroForm when no datasets in XFA array\", function () {\n      const originalData = new Uint8Array();\n      const newRefs = [];\n      const acroForm = new Dict(null);\n      acroForm.set(\"XFA\", [\"preamble\", Ref.get(123, 0), \"postamble\", Ref.get(456, 0)]);\n      const acroFormRef = Ref.get(789, 0);\n      const xfaDatasetsRef = Ref.get(101112, 0);\n      const xfaData = \"<hello>world</hello>\";\n      const xrefInfo = {\n        newRef: Ref.get(131415, 0),\n        startXRef: 314,\n        fileIds: null,\n        rootRef: null,\n        infoRef: null,\n        encryptRef: null,\n        filename: \"foo.pdf\",\n        info: {}\n      };\n      let data = incrementalUpdate({\n        originalData,\n        xrefInfo,\n        newRefs,\n        hasXfa: true,\n        xfaDatasetsRef,\n        hasXfaDatasetsEntry: false,\n        acroFormRef,\n        acroForm,\n        xfaData,\n        xref: {}\n      });\n      data = bytesToString(data);\n      const expected = \"\\n\" + \"789 0 obj\\n\" + \"<< /XFA [(preamble) 123 0 R (datasets) 101112 0 R (postamble) 456 0 R]>>\\n\" + \"101112 0 obj\\n\" + \"<< /Type /EmbeddedFile /Length 20>>\\n\" + \"stream\\n\" + \"<hello>world</hello>\\n\" + \"endstream\\n\" + \"endobj\\n\" + \"131415 0 obj\\n\" + \"<< /Size 131416 /Prev 314 /Type /XRef /Index [0 1 789 1 101112 1 131415 1] /W [1 1 2] /Length 16>> stream\\n\" + \"\\u0000\\u0001ÿÿ\\u0001\\u0001\\u0000\\u0000\\u0001T\\u0000\\u0000\\u0001²\\u0000\\u0000\\n\" + \"endstream\\n\" + \"endobj\\n\" + \"startxref\\n\" + \"178\\n\" + \"%%EOF\\n\";\n      expect(data).toEqual(expected);\n    });","file":"unit/writer_spec.js","skipped":false,"dir":"test"},{"name":"should lex numbers","suites":["FormCalc expression parser","FormCalc lexer"],"line":20,"updatePoint":{"line":20,"column":26,"index":906},"code":"    it(\"should lex numbers\", function () {\n      const lexer = new Lexer(\"12 1.2345 .7 .12345 1e-2 1.2E+3 1e2 1.2E3 nan 12. 2.e3 infinity 99999999999999999 123456789.012345678 9e99999\");\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, 12));\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, 1.2345));\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, 0.7));\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, 0.12345));\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, 1e-2));\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, 1.2e3));\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, 1e2));\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, 1.2e3));\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, NaN));\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, 12));\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, 2e3));\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, Infinity));\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, 100000000000000000));\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, 123456789.01234567));\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, Infinity));\n      expect(lexer.next()).toEqual(EOF);\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should lex strings","suites":["FormCalc expression parser","FormCalc lexer"],"line":39,"updatePoint":{"line":39,"column":26,"index":2182},"code":"    it(\"should lex strings\", function () {\n      const lexer = new Lexer(`\"hello world\" \"hello \"\"world\" \"hello \"\"world\"\" \"\"world\"\"\"\"hello\"\"\" \"hello \\\\uabcdeh \\\\Uabcd \\\\u00000123abc\" \"a \\\\a \\\\ub \\\\Uc \\\\b\"`);\n      expect(lexer.next()).toEqual(new Token(TOKEN.string, `hello world`));\n      expect(lexer.next()).toEqual(new Token(TOKEN.string, `hello \"world`));\n      expect(lexer.next()).toEqual(new Token(TOKEN.string, `hello \"world\" \"world\"\"hello\"`));\n      expect(lexer.next()).toEqual(new Token(TOKEN.string, `hello \\uabcdeh \\uabcd \\u0123abc`));\n      expect(lexer.next()).toEqual(new Token(TOKEN.string, `a \\\\a \\\\ub \\\\Uc \\\\b`));\n      expect(lexer.next()).toEqual(EOF);\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should lex operators","suites":["FormCalc expression parser","FormCalc lexer"],"line":48,"updatePoint":{"line":48,"column":28,"index":2866},"code":"    it(\"should lex operators\", function () {\n      const lexer = new Lexer(\"( , ) <= <> = == >= < > / * . .* .# [ ] & |\");\n      expect(lexer.next()).toEqual(new Token(TOKEN.leftParen));\n      expect(lexer.next()).toEqual(new Token(TOKEN.comma));\n      expect(lexer.next()).toEqual(new Token(TOKEN.rightParen));\n      expect(lexer.next()).toEqual(new Token(TOKEN.le));\n      expect(lexer.next()).toEqual(new Token(TOKEN.ne));\n      expect(lexer.next()).toEqual(new Token(TOKEN.assign));\n      expect(lexer.next()).toEqual(new Token(TOKEN.eq));\n      expect(lexer.next()).toEqual(new Token(TOKEN.ge));\n      expect(lexer.next()).toEqual(new Token(TOKEN.lt));\n      expect(lexer.next()).toEqual(new Token(TOKEN.gt));\n      expect(lexer.next()).toEqual(new Token(TOKEN.divide));\n      expect(lexer.next()).toEqual(new Token(TOKEN.times));\n      expect(lexer.next()).toEqual(new Token(TOKEN.dot));\n      expect(lexer.next()).toEqual(new Token(TOKEN.dotStar));\n      expect(lexer.next()).toEqual(new Token(TOKEN.dotHash));\n      expect(lexer.next()).toEqual(new Token(TOKEN.leftBracket));\n      expect(lexer.next()).toEqual(new Token(TOKEN.rightBracket));\n      expect(lexer.next()).toEqual(new Token(TOKEN.and));\n      expect(lexer.next()).toEqual(new Token(TOKEN.or));\n      expect(lexer.next()).toEqual(EOF);\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should skip comments","suites":["FormCalc expression parser","FormCalc lexer"],"line":71,"updatePoint":{"line":71,"column":28,"index":4181},"code":"    it(\"should skip comments\", function () {\n      const lexer = new Lexer(`\n\n  \\t\\t  1 \\r\\n\\r\\n\n\n  ;  blah blah blah\n\n  2\n\n  // blah blah blah blah blah\n\n\n  3\n      `);\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, 1));\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, 2));\n      expect(lexer.next()).toEqual(new Token(TOKEN.number, 3));\n      expect(lexer.next()).toEqual(EOF);\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should lex identifiers","suites":["FormCalc expression parser","FormCalc lexer"],"line":90,"updatePoint":{"line":90,"column":30,"index":4594},"code":"    it(\"should lex identifiers\", function () {\n      const lexer = new Lexer(\"eq for fore while continue hello こんにちは世界 $!hello今日は12今日は\");\n      expect(lexer.next()).toEqual(new Token(TOKEN.eq));\n      expect(lexer.next()).toEqual(new Token(TOKEN.for));\n      expect(lexer.next()).toEqual(new Token(TOKEN.identifier, \"fore\"));\n      expect(lexer.next()).toEqual(new Token(TOKEN.while));\n      expect(lexer.next()).toEqual(new Token(TOKEN.continue));\n      expect(lexer.next()).toEqual(new Token(TOKEN.identifier, \"hello\"));\n      expect(lexer.next()).toEqual(new Token(TOKEN.identifier, \"こんにちは世界\"));\n      expect(lexer.next()).toEqual(new Token(TOKEN.identifier, \"$\"));\n      expect(lexer.next()).toEqual(new Token(TOKEN.identifier, \"!hello今日は12今日は\"));\n      expect(lexer.next()).toEqual(EOF);\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse basic arithmetic expression","suites":["FormCalc expression parser","FormCalc parser"],"line":105,"updatePoint":{"line":105,"column":48,"index":5463},"code":"    it(\"should parse basic arithmetic expression\", function () {\n      const parser = new Parser(\"1 + 2 * 3\");\n      expect(parser.parse().dump()[0]).toEqual(7);\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse basic arithmetic expression with the same operator","suites":["FormCalc expression parser","FormCalc parser"],"line":109,"updatePoint":{"line":109,"column":71,"index":5656},"code":"    it(\"should parse basic arithmetic expression with the same operator\", function () {\n      const parser = new Parser(\"1 + a + 3\");\n      expect(parser.parse().dump()[0]).toEqual({\n        operator: \"+\",\n        left: {\n          operator: \"+\",\n          left: 1,\n          right: {\n            id: \"a\"\n          }\n        },\n        right: 3\n      });\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse expressions with unary operators","suites":["FormCalc expression parser","FormCalc parser"],"line":123,"updatePoint":{"line":123,"column":53,"index":6001},"code":"    it(\"should parse expressions with unary operators\", function () {\n      const parser = new Parser(`\n  s = +x + 1\n  t = -+u * 2\n  t = +-u * 2\n  u = -foo()\n      `);\n      expect(parser.parse().dump()).toEqual([{\n        assignment: \"s\",\n        expr: {\n          operator: \"+\",\n          left: {\n            operator: \"+\",\n            arg: {\n              id: \"x\"\n            }\n          },\n          right: 1\n        }\n      }, {\n        assignment: \"t\",\n        expr: {\n          operator: \"*\",\n          left: {\n            operator: \"-\",\n            arg: {\n              operator: \"+\",\n              arg: {\n                id: \"u\"\n              }\n            }\n          },\n          right: 2\n        }\n      }, {\n        assignment: \"t\",\n        expr: {\n          operator: \"*\",\n          left: {\n            operator: \"+\",\n            arg: {\n              operator: \"-\",\n              arg: {\n                id: \"u\"\n              }\n            }\n          },\n          right: 2\n        }\n      }, {\n        assignment: \"u\",\n        expr: {\n          operator: \"-\",\n          arg: {\n            callee: {\n              id: \"foo\"\n            },\n            params: []\n          }\n        }\n      }]);\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse basic expression with a string","suites":["FormCalc expression parser","FormCalc parser"],"line":185,"updatePoint":{"line":185,"column":51,"index":7215},"code":"    it(\"should parse basic expression with a string\", function () {\n      const parser = new Parser(`(5 - \"abc\") * 3`);\n      expect(parser.parse().dump()[0]).toEqual(15);\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse basic expression with a calls","suites":["FormCalc expression parser","FormCalc parser"],"line":189,"updatePoint":{"line":189,"column":50,"index":7394},"code":"    it(\"should parse basic expression with a calls\", function () {\n      const parser = new Parser(`foo(2, 3, a & b) or c * d + 1.234 / e`);\n      expect(parser.parse().dump()[0]).toEqual({\n        operator: \"||\",\n        left: {\n          callee: {\n            id: \"foo\"\n          },\n          params: [2, 3, {\n            operator: \"&&\",\n            left: {\n              id: \"a\"\n            },\n            right: {\n              id: \"b\"\n            }\n          }]\n        },\n        right: {\n          operator: \"+\",\n          left: {\n            operator: \"*\",\n            left: {\n              id: \"c\"\n            },\n            right: {\n              id: \"d\"\n            }\n          },\n          right: {\n            operator: \"/\",\n            left: 1.234,\n            right: {\n              id: \"e\"\n            }\n          }\n        }\n      });\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse basic expression with a subscript","suites":["FormCalc expression parser","FormCalc parser"],"line":228,"updatePoint":{"line":228,"column":54,"index":8258},"code":"    it(\"should parse basic expression with a subscript\", function () {\n      let parser = new Parser(`こんにちは世界[-0]`);\n      let dump = parser.parse().dump()[0];\n      expect(dump).toEqual({\n        operand: {\n          id: \"こんにちは世界\"\n        },\n        index: -0\n      });\n      expect(Object.is(-0, dump.index)).toBe(true);\n      parser = new Parser(`こんにちは世界[+0]`);\n      dump = parser.parse().dump()[0];\n      expect(dump).toEqual({\n        operand: {\n          id: \"こんにちは世界\"\n        },\n        index: +0\n      });\n      expect(Object.is(+0, dump.index)).toBe(true);\n      parser = new Parser(`こんにちは世界[*]`);\n      expect(parser.parse().dump()[0]).toEqual({\n        operand: {\n          id: \"こんにちは世界\"\n        },\n        index: {\n          special: \"*\"\n        }\n      });\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse basic expression with dots","suites":["FormCalc expression parser","FormCalc parser"],"line":257,"updatePoint":{"line":257,"column":47,"index":9030},"code":"    it(\"should parse basic expression with dots\", function () {\n      const parser = new Parser(\"a.b.c.#d..e.f..g.*\");\n      expect(parser.parse().dump()[0]).toEqual({\n        operator: \".\",\n        left: {\n          id: \"a\"\n        },\n        right: {\n          operator: \".\",\n          left: {\n            id: \"b\"\n          },\n          right: {\n            operator: \".#\",\n            left: {\n              id: \"c\"\n            },\n            right: {\n              operator: \"..\",\n              left: {\n                id: \"d\"\n              },\n              right: {\n                operator: \".\",\n                left: {\n                  id: \"e\"\n                },\n                right: {\n                  operator: \"..\",\n                  left: {\n                    id: \"f\"\n                  },\n                  right: {\n                    operator: \".\",\n                    left: {\n                      id: \"g\"\n                    },\n                    right: {\n                      special: \"*\"\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      });\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse var declaration with error","suites":["FormCalc expression parser","FormCalc parser"],"line":305,"updatePoint":{"line":305,"column":47,"index":10171},"code":"    it(\"should parse var declaration with error\", function () {\n      let parser = new Parser(\"var 123 = a\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.var));\n      parser = new Parser(`var \"123\" = a`);\n      expect(() => parser.parse()).toThrow(new Error(Errors.var));\n      parser = new Parser(`var for var a`);\n      expect(() => parser.parse()).toThrow(new Error(Errors.var));\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse for declaration with a step","suites":["FormCalc expression parser","FormCalc parser"],"line":313,"updatePoint":{"line":313,"column":48,"index":10579},"code":"    it(\"should parse for declaration with a step\", function () {\n      const parser = new Parser(`\nvar s = 0\nfor var i = 1 upto 10 + x step 1 do\n  s = s + i * 2\nendfor`);\n      expect(parser.parse().dump()).toEqual([{\n        var: \"s\",\n        expr: 0\n      }, {\n        decl: \"for\",\n        assignment: {\n          var: \"i\",\n          expr: 1\n        },\n        type: \"upto\",\n        end: {\n          operator: \"+\",\n          left: 10,\n          right: {\n            id: \"x\"\n          }\n        },\n        step: 1,\n        body: [{\n          assignment: \"s\",\n          expr: {\n            operator: \"+\",\n            left: {\n              id: \"s\"\n            },\n            right: {\n              operator: \"*\",\n              left: {\n                id: \"i\"\n              },\n              right: 2\n            }\n          }\n        }]\n      }]);\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse for declaration without a step","suites":["FormCalc expression parser","FormCalc parser"],"line":355,"updatePoint":{"line":355,"column":51,"index":11436},"code":"    it(\"should parse for declaration without a step\", function () {\n      const parser = new Parser(`\nfor i = 1 + 2 downto 10 do\n  s = foo()\nendfor`);\n      expect(parser.parse().dump()).toEqual([{\n        decl: \"for\",\n        assignment: {\n          assignment: \"i\",\n          expr: 3\n        },\n        type: \"downto\",\n        end: 10,\n        step: null,\n        body: [{\n          assignment: \"s\",\n          expr: {\n            callee: {\n              id: \"foo\"\n            },\n            params: []\n          }\n        }]\n      }]);\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse for declaration with error","suites":["FormCalc expression parser","FormCalc parser"],"line":380,"updatePoint":{"line":380,"column":47,"index":11978},"code":"    it(\"should parse for declaration with error\", function () {\n      let parser = new Parser(\"for 123 = i upto 1 do a = 1 endfor\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.assignment));\n      parser = new Parser(\"for var 123 = i upto 1 do a = 1 endfor\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.assignment));\n      parser = new Parser(\"for var i = 123 upt 1 do a = 1 endfor\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.for));\n      parser = new Parser(\"for var i = 123 var 1 do a = 1 endfor\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.for));\n      parser = new Parser(\"for var i = 123 upto 1 step for var j = 1 do endfor do a = 1 endfor\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.for));\n      parser = new Parser(\"for var i = 123 downto 1 do a = 1 endfunc\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.for));\n      parser = new Parser(\"for var i = 123 downto 1 do a = 1\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.for));\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse foreach declaration","suites":["FormCalc expression parser","FormCalc parser"],"line":396,"updatePoint":{"line":396,"column":40,"index":13034},"code":"    it(\"should parse foreach declaration\", function () {\n      const parser = new Parser(`\nforeach i in (a, b, c, d) do\n  s = foo()[i]\nendfor`);\n      expect(parser.parse().dump()).toEqual([{\n        decl: \"foreach\",\n        id: \"i\",\n        params: [{\n          id: \"a\"\n        }, {\n          id: \"b\"\n        }, {\n          id: \"c\"\n        }, {\n          id: \"d\"\n        }],\n        body: [{\n          assignment: \"s\",\n          expr: {\n            operand: {\n              callee: {\n                id: \"foo\"\n              },\n              params: []\n            },\n            index: {\n              id: \"i\"\n            }\n          }\n        }]\n      }]);\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse foreach declaration with error","suites":["FormCalc expression parser","FormCalc parser"],"line":429,"updatePoint":{"line":429,"column":51,"index":13712},"code":"    it(\"should parse foreach declaration with error\", function () {\n      let parser = new Parser(\"foreach 123 in (1, 2, 3) do a = 1 endfor\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.foreach));\n      parser = new Parser(\"foreach foo in 1, 2, 3) do a = 1 endfor\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.foreach));\n      parser = new Parser(\"foreach foo in (1, 2, 3 do a = 1 endfor\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.params));\n      parser = new Parser(\"foreach foo in (1, 2 3) do a = 1 endfor\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.params));\n      parser = new Parser(\"foreach foo in (1, 2, 3) od a = 1 endfor\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.foreach));\n      parser = new Parser(\"foreach foo in (1, 2, 3) do a = 1 endforeach\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.foreach));\n      parser = new Parser(\"foreach foo in (1, 2, 3) do a = 1  123\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.foreach));\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse while declaration","suites":["FormCalc expression parser","FormCalc parser"],"line":445,"updatePoint":{"line":445,"column":38,"index":14770},"code":"    it(\"should parse while declaration\", function () {\n      const parser = new Parser(`\nwhile (1) do\n  if (0) then\n    break\n  else\n    continue\n  endif\nendwhile\n      `);\n      expect(parser.parse().dump()).toEqual([{\n        decl: \"while\",\n        condition: 1,\n        body: [{\n          decl: \"if\",\n          condition: 0,\n          then: [{\n            special: \"break\"\n          }],\n          elseif: null,\n          else: [{\n            special: \"continue\"\n          }]\n        }]\n      }]);\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse while declaration with error","suites":["FormCalc expression parser","FormCalc parser"],"line":471,"updatePoint":{"line":471,"column":49,"index":15289},"code":"    it(\"should parse while declaration with error\", function () {\n      let parser = new Parser(\"while a == 1 do a = 2 endwhile\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.while));\n      parser = new Parser(\"while (a == 1 do a = 2 endwhile\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.while));\n      parser = new Parser(\"while (a == 1) var a = 2 endwhile\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.while));\n      parser = new Parser(\"while (a == 1) do var a = 2 end\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.while));\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse do declaration","suites":["FormCalc expression parser","FormCalc parser"],"line":481,"updatePoint":{"line":481,"column":35,"index":15878},"code":"    it(\"should parse do declaration\", function () {\n      const parser = new Parser(`\ndo\n  x = 1\n; a comment in the middle of the block\n  y = 2\nend\n    `);\n      expect(parser.parse().dump()).toEqual([{\n        decl: \"block\",\n        body: [{\n          assignment: \"x\",\n          expr: 1\n        }, {\n          assignment: \"y\",\n          expr: 2\n        }]\n      }]);\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse do declaration with error","suites":["FormCalc expression parser","FormCalc parser"],"line":500,"updatePoint":{"line":500,"column":46,"index":16265},"code":"    it(\"should parse do declaration with error\", function () {\n      const parser = new Parser(`\ndo\n  x = 1\n  y = 2\nendfunc\n      `);\n      expect(() => parser.parse()).toThrow(new Error(Errors.block));\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse func declaration","suites":["FormCalc expression parser","FormCalc parser"],"line":509,"updatePoint":{"line":509,"column":37,"index":16467},"code":"    it(\"should parse func declaration\", function () {\n      const parser = new Parser(`\nfunc こんにちは世界123(a, b) do\n  a + b\nendfunc\n      `);\n      expect(parser.parse().dump()).toEqual([{\n        func: \"こんにちは世界123\",\n        params: [\"a\", \"b\"],\n        body: [{\n          operator: \"+\",\n          left: {\n            id: \"a\"\n          },\n          right: {\n            id: \"b\"\n          }\n        }]\n      }]);\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse func declaration with error","suites":["FormCalc expression parser","FormCalc parser"],"line":529,"updatePoint":{"line":529,"column":48,"index":16894},"code":"    it(\"should parse func declaration with error\", function () {\n      let parser = new Parser(\"func 123(a, b) do a = 1 endfunc\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.func));\n      parser = new Parser(\"func foo(a, b) for a = 1 endfunc\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.func));\n      parser = new Parser(\"func foo(a, b) do a = 1 endfun\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.func));\n      parser = new Parser(\"func foo(a, b, c do a = 1 endfunc\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.func));\n      parser = new Parser(\"func foo(a, b, 123) do a = 1 endfunc\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.func));\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse if declaration","suites":["FormCalc expression parser","FormCalc parser"],"line":541,"updatePoint":{"line":541,"column":35,"index":17615},"code":"    it(\"should parse if declaration\", function () {\n      const parser = new Parser(`\n  if (a & b) then\n    var s = 1\n  endif\n\n  if (a or b) then\n    var s = 1\n  else\n    var x = 2\n  endif\n\n  if (0) then\n    s = 1\n  elseif (1) then\n    s = 2\n  elseif (2) then\n    s = 3\n  elseif (3) then\n    s = 4\n  else\n    s = 5\n  endif\n\n// a comment\n\n  if (0) then\n    s = 1\n  elseif (1) then\n    s = 2\n  endif\n      `);\n      expect(parser.parse().dump()).toEqual([{\n        decl: \"if\",\n        condition: {\n          operator: \"&&\",\n          left: {\n            id: \"a\"\n          },\n          right: {\n            id: \"b\"\n          }\n        },\n        then: [{\n          var: \"s\",\n          expr: 1\n        }],\n        elseif: null,\n        else: null\n      }, {\n        decl: \"if\",\n        condition: {\n          operator: \"||\",\n          left: {\n            id: \"a\"\n          },\n          right: {\n            id: \"b\"\n          }\n        },\n        then: [{\n          var: \"s\",\n          expr: 1\n        }],\n        elseif: null,\n        else: [{\n          var: \"x\",\n          expr: 2\n        }]\n      }, {\n        decl: \"if\",\n        condition: 0,\n        then: [{\n          assignment: \"s\",\n          expr: 1\n        }],\n        elseif: [{\n          decl: \"elseif\",\n          condition: 1,\n          then: [{\n            assignment: \"s\",\n            expr: 2\n          }]\n        }, {\n          decl: \"elseif\",\n          condition: 2,\n          then: [{\n            assignment: \"s\",\n            expr: 3\n          }]\n        }, {\n          decl: \"elseif\",\n          condition: 3,\n          then: [{\n            assignment: \"s\",\n            expr: 4\n          }]\n        }],\n        else: [{\n          assignment: \"s\",\n          expr: 5\n        }]\n      }, {\n        decl: \"if\",\n        condition: 0,\n        then: [{\n          assignment: \"s\",\n          expr: 1\n        }],\n        elseif: [{\n          decl: \"elseif\",\n          condition: 1,\n          then: [{\n            assignment: \"s\",\n            expr: 2\n          }]\n        }],\n        else: null\n      }]);\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse if declaration with error","suites":["FormCalc expression parser","FormCalc parser"],"line":661,"updatePoint":{"line":661,"column":46,"index":19692},"code":"    it(\"should parse if declaration with error\", function () {\n      let parser = new Parser(\"if foo == 1 then a = 1 endif\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.if));\n      parser = new Parser(\"if (foo == 1 then a = 1 endif\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.if));\n      parser = new Parser(\"if (foo == 1) then a = 1 elseiff (foo == 2) then a = 2 endif\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.if));\n      parser = new Parser(\"if (foo == 1) then a = 1 elseif (foo == 2) then a = 2 end\");\n      expect(() => parser.parse()).toThrow(new Error(Errors.if));\n    });","file":"unit/xfa_formcalc_spec.js","skipped":false,"dir":"test"},{"name":"should parse a xfa document and create an object to represent it","suites":["XFAParser","Parse XFA"],"line":21,"updatePoint":{"line":21,"column":72,"index":1033},"code":"    it(\"should parse a xfa document and create an object to represent it\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\" uuid=\"1234\" invalid=\"foo\">\n  <config xmlns=\"http://www.xfa.org/schema/xci/3.1/\">\n    <present>\n      <pdf name=\"hello\">\n        <adobeExtensionLevel>\n          7\n        </adobeExtensionLevel>\n      </pdf>\n      <invalid><a>foobar</a></invalid>\n    </present>\n    <acrobat>\n      <submitUrl>http://a.b.c</submitUrl>\n      <acrobat7>\n        <dynamicRender>\n          forbidden\n        </dynamicRender>\n      </acrobat7>\n      <autoSave>enabled</autoSave>\n      <submitUrl>\n                 http://d.e.f\n      </submitUrl>\n      <submitUrl>http://g.h.i</submitUrl>\n      <validate>foobar</validate>\n    </acrobat>\n  </config>\n  <template baseProfile=\"full\" xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <extras>\n      <float>1.23</float>\n      <boolean>1</boolean>\n      <integer>314</integer>\n      <float>2.71</float>\n    </extras>\n    <subform>\n      <proto>\n        <area x=\"hello\" y=\"-3.14in\" relevant=\"-foo +bar\" />\n        <color value=\"111, 222, 123\" />\n        <color value=\"111, abc, 123\" />\n        <medium imagingBBox=\"1,2in,3.4cm,5.67px\" />\n        <medium imagingBBox=\"1,2in,-3cm,4px\" />\n      </proto>\n    </subform>\n  </template>\n</xdp:xdp>\n      `;\n      const attributes = {\n        id: \"\",\n        name: \"\",\n        use: \"\",\n        usehref: \"\"\n      };\n      const mediumAttributes = {\n        id: \"\",\n        long: 0,\n        orientation: \"portrait\",\n        short: 0,\n        stock: \"\",\n        trayIn: \"auto\",\n        trayOut: \"auto\",\n        use: \"\",\n        usehref: \"\"\n      };\n      const colorAttributes = {\n        cSpace: \"SRGB\",\n        id: \"\",\n        use: \"\",\n        usehref: \"\"\n      };\n      const root = new XFAParser().parse(xml);\n      const expected = {\n        uuid: \"1234\",\n        timeStamp: \"\",\n        template: {\n          baseProfile: \"full\",\n          extras: { ...attributes,\n            float: [{ ...attributes,\n              $content: 1.23\n            }, { ...attributes,\n              $content: 2.71\n            }],\n            boolean: { ...attributes,\n              $content: 1\n            },\n            integer: { ...attributes,\n              $content: 314\n            }\n          },\n          subform: {\n            access: \"open\",\n            allowMacro: 0,\n            anchorType: \"topLeft\",\n            colSpan: 1,\n            columnWidths: [0],\n            h: \"\",\n            hAlign: \"left\",\n            id: \"\",\n            layout: \"position\",\n            locale: \"\",\n            maxH: 0,\n            maxW: 0,\n            mergeMode: \"consumeData\",\n            minH: 0,\n            minW: 0,\n            name: \"\",\n            presence: \"visible\",\n            relevant: [],\n            restoreState: \"manual\",\n            scope: \"name\",\n            use: \"\",\n            usehref: \"\",\n            w: \"\",\n            x: 0,\n            y: 0,\n            proto: {\n              area: { ...attributes,\n                colSpan: 1,\n                x: 0,\n                y: -226.08,\n                relevant: [{\n                  excluded: true,\n                  viewname: \"foo\"\n                }, {\n                  excluded: false,\n                  viewname: \"bar\"\n                }]\n              },\n              color: [{ ...colorAttributes,\n                value: {\n                  r: 111,\n                  g: 222,\n                  b: 123\n                }\n              }, { ...colorAttributes,\n                value: {\n                  r: 111,\n                  g: 0,\n                  b: 123\n                }\n              }],\n              medium: [{ ...mediumAttributes,\n                imagingBBox: {\n                  x: 1,\n                  y: 144,\n                  width: 96.3779527559055,\n                  height: 5.67\n                }\n              }, { ...mediumAttributes,\n                imagingBBox: {\n                  x: -1,\n                  y: -1,\n                  width: -1,\n                  height: -1\n                }\n              }]\n            }\n          }\n        },\n        config: {\n          acrobat: {\n            acrobat7: {\n              dynamicRender: {\n                $content: \"forbidden\"\n              }\n            },\n            autoSave: {\n              $content: \"enabled\"\n            },\n            validate: {\n              $content: \"preSubmit\"\n            },\n            submitUrl: [{\n              $content: \"http://a.b.c\"\n            }, {\n              $content: \"http://d.e.f\"\n            }, {\n              $content: \"http://g.h.i\"\n            }]\n          },\n          present: {\n            pdf: {\n              name: \"hello\",\n              adobeExtensionLevel: {\n                $content: 7\n              }\n            }\n          }\n        }\n      };\n      expect(root[$dump]()).toEqual(expected);\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should parse a xfa document and check namespaces","suites":["XFAParser","Parse XFA"],"line":213,"updatePoint":{"line":213,"column":56,"index":5933},"code":"    it(\"should parse a xfa document and check namespaces\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <config xmlns:foo=\"http:/www.foo.com\" xmlns=\"http://www.xfa.org/schema/xci/3.1/\">\n    <present xmlns=\"http://www.mozilla.org\">\n      <pdf name=\"hello\">\n        <adobeExtensionLevel>\n          7\n        </adobeExtensionLevel>\n      </pdf>\n    </present>\n    <acrobat>\n      <foo:submitUrl>http://a.b.c</foo:submitUrl>\n      <submitUrl>http://c.b.a</submitUrl>\n    </acrobat>\n  </config>\n  <template baseProfile=\"full\" xmlns=\"http://www.allizom.org\">\n    <extras>\n      <float>1.23</float>\n    </extras>\n  </template>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const expected = {\n        uuid: \"\",\n        timeStamp: \"\",\n        config: {\n          acrobat: {\n            submitUrl: {\n              $content: \"http://c.b.a\"\n            }\n          }\n        }\n      };\n      expect(root[$dump]()).toEqual(expected);\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should parse a xfa document and parse CDATA when needed","suites":["XFAParser","Parse XFA"],"line":251,"updatePoint":{"line":251,"column":63,"index":6956},"code":"    it(\"should parse a xfa document and parse CDATA when needed\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform>\n      <field>\n        <extras>\n          <exData contentType=\"text/html\" name=\"foo\">\n            <![CDATA[<body xmlns=\"http://www.w3.org/1999/xhtml\">\n              <span>hello</span></body>]]>\n          </exData>\n        </extra>\n      </field>\n    </subform>\n  </template>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const exdata = searchNode(root, root, \"foo\")[0];\n      const body = exdata[$dump]().$content[$dump]();\n      const expected = {\n        $name: \"body\",\n        attributes: {},\n        children: [{\n          $content: \"hello\",\n          $name: \"span\",\n          attributes: {},\n          children: []\n        }]\n      };\n      expect(body).toEqual(expected);\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should parse a xfa document and apply some prototypes","suites":["XFAParser","Parse XFA"],"line":284,"updatePoint":{"line":284,"column":61,"index":7913},"code":"    it(\"should parse a xfa document and apply some prototypes\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform>\n      <proto>\n        <font id=\"id1\" typeface=\"Foo\" size=\"123pt\" weight=\"bold\" posture=\"italic\">\n          <fill>\n            <color value=\"1,2,3\"/>\n          </fill>\n        </font>\n      </proto>\n      <field>\n        <font use=\"#id1\"/>\n      </field>\n      <field>\n        <font use=\"#id1\" size=\"456pt\" weight=\"bold\" posture=\"normal\">\n          <fill>\n            <color value=\"4,5,6\"/>\n          </fill>\n          <extras id=\"id2\"/>\n        </font>\n      </field>\n    </subform>\n  </template>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml)[$dump]();\n      let font = root.template.subform.field[0].font;\n      expect(font.typeface).toEqual(\"Foo\");\n      expect(font.overline).toEqual(0);\n      expect(font.size).toEqual(123);\n      expect(font.weight).toEqual(\"bold\");\n      expect(font.posture).toEqual(\"italic\");\n      expect(font.fill.color.value).toEqual({\n        r: 1,\n        g: 2,\n        b: 3\n      });\n      expect(font.extras).toEqual(undefined);\n      font = root.template.subform.field[1].font;\n      expect(font.typeface).toEqual(\"Foo\");\n      expect(font.overline).toEqual(0);\n      expect(font.size).toEqual(456);\n      expect(font.weight).toEqual(\"bold\");\n      expect(font.posture).toEqual(\"normal\");\n      expect(font.fill.color.value).toEqual({\n        r: 4,\n        g: 5,\n        b: 6\n      });\n      expect(font.extras.id).toEqual(\"id2\");\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should parse a xfa document and apply some prototypes through usehref","suites":["XFAParser","Parse XFA"],"line":338,"updatePoint":{"line":338,"column":77,"index":9566},"code":"    it(\"should parse a xfa document and apply some prototypes through usehref\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform>\n      <proto>\n        <draw name=\"foo\">\n          <font typeface=\"Foo\" size=\"123pt\" weight=\"bold\" posture=\"italic\">\n            <fill>\n              <color value=\"1,2,3\"/>\n            </fill>\n          </font>\n        </draw>\n      </proto>\n      <field>\n        <font usehref=\".#som($template.#subform.foo.#font)\"/>\n      </field>\n      <field>\n        <font usehref=\".#som($template.#subform.foo.#font)\" size=\"456pt\" weight=\"bold\" posture=\"normal\">\n          <fill>\n            <color value=\"4,5,6\"/>\n          </fill>\n          <extras id=\"id2\"/>\n        </font>\n      </field>\n    </subform>\n  </template>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml)[$dump]();\n      let font = root.template.subform.field[0].font;\n      expect(font.typeface).toEqual(\"Foo\");\n      expect(font.overline).toEqual(0);\n      expect(font.size).toEqual(123);\n      expect(font.weight).toEqual(\"bold\");\n      expect(font.posture).toEqual(\"italic\");\n      expect(font.fill.color.value).toEqual({\n        r: 1,\n        g: 2,\n        b: 3\n      });\n      expect(font.extras).toEqual(undefined);\n      font = root.template.subform.field[1].font;\n      expect(font.typeface).toEqual(\"Foo\");\n      expect(font.overline).toEqual(0);\n      expect(font.size).toEqual(456);\n      expect(font.weight).toEqual(\"bold\");\n      expect(font.posture).toEqual(\"normal\");\n      expect(font.fill.color.value).toEqual({\n        r: 4,\n        g: 5,\n        b: 6\n      });\n      expect(font.extras.id).toEqual(\"id2\");\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should parse a xfa document with xhtml","suites":["XFAParser","Parse XFA"],"line":394,"updatePoint":{"line":394,"column":46,"index":11301},"code":"    it(\"should parse a xfa document with xhtml\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <extras>\n      <text>\n        <body xmlns=\"http://www.w3.org/1999/xhtml\">\n          <p style=\"foo: bar; text-indent:0.5in; line-height:11px;bar:foo;tab-stop: left 0.5in\">\n            The first line of this paragraph is indented a half-inch.<br/>\n            Successive lines are not indented.<br/>\n            This is the last line of the paragraph.<br/>\n          </p>\n        </body>\n      </text>\n    </extras>\n  </template>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml)[$dump]();\n      const p = root.template.extras.text.$content[$getChildren]()[0];\n      expect(p.style).toEqual(\"text-indent:0.5in;line-height:11px;tab-stop:left 0.5in\");\n      expect(p[$text]()).toEqual([\" The first line of this paragraph is indented a half-inch.\\n\", \" Successive lines are not indented.\\n\", \" This is the last line of the paragraph.\\n \"].join(\"\"));\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should parse a xfa document and apply some prototypes with cycle","suites":["XFAParser","Parse XFA"],"line":418,"updatePoint":{"line":418,"column":72,"index":12416},"code":"    it(\"should parse a xfa document and apply some prototypes with cycle\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform>\n      <proto>\n        <subform id=\"id1\">\n          <subform use=\"#id1\"/>\n        </subform>\n      </proto>\n    </subform>\n    <subform use=\"#id1\"/>\n  </template>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml)[$dump]();\n      const subform = root.template.subform[1];\n      expect(subform.id).toEqual(\"id1\");\n      expect(subform.subform.id).toEqual(\"id1\");\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should parse a xfa document and apply some nested prototypes","suites":["XFAParser","Parse XFA"],"line":439,"updatePoint":{"line":439,"column":68,"index":13052},"code":"    it(\"should parse a xfa document and apply some nested prototypes\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform>\n      <proto>\n        <color id=\"RED\" value=\"7, 8, 9\"/>\n        <font id=\"HELV\" typeface=\"helvetica\" size=\"31pt\" weight=\"normal\" posture=\"italic\"> </font>\n        <font id=\"HELV-RED\" use=\"#HELV\">\n          <fill>\n            <color use=\"#RED\"/>\n          </fill>\n        </font>\n      </proto>\n      <field>\n        <font use=\"#HELV-RED\"/>\n      </field>\n    </subform>\n  </template>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml)[$dump]();\n      const font = root.template.subform.field.font;\n      expect(font.typeface).toEqual(\"helvetica\");\n      expect(font.overline).toEqual(0);\n      expect(font.size).toEqual(31);\n      expect(font.weight).toEqual(\"normal\");\n      expect(font.posture).toEqual(\"italic\");\n      expect(font.fill.color.value).toEqual({\n        r: 7,\n        g: 8,\n        b: 9\n      });\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should parse a xfa document and apply a prototype with content","suites":["XFAParser","Parse XFA"],"line":474,"updatePoint":{"line":474,"column":70,"index":14142},"code":"    it(\"should parse a xfa document and apply a prototype with content\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform>\n      <proto>\n        <text id=\"TEXT\">default TEXT</text>\n      </proto>\n      <field>\n        <value>\n          <text use=\"#TEXT\"></text>\n        </value>\n      </field>\n      <field>\n        <value>\n          <text use=\"#TEXT\">Overriding text</text>\n        </value>\n      </field>\n    </subform>\n  </template>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml)[$dump]();\n      let field = root.template.subform.field[0];\n      expect(field.value.text.$content).toEqual(\"default TEXT\");\n      field = root.template.subform.field[1];\n      expect(field.value.text.$content).toEqual(\"Overriding text\");\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should search some nodes in a template object","suites":["XFAParser","Search in XFA"],"line":505,"updatePoint":{"line":505,"column":53,"index":15053},"code":"    it(\"should search some nodes in a template object\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n    <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n      <subform name=\"Receipt\" id=\"l\">\n        <subform id=\"m\">\n          <field name=\"Description\" id=\"a\">  </field>\n          <field name=\"Units\" id=\"b\">  </field>\n          <field name=\"Unit_Price\" id=\"c\">  </field>\n          <field name=\"Total_Price\" id=\"d\">  </field>\n        </subform>\n        <subform id=\"n\">\n          <field name=\"Description\" id=\"e\">  </field>\n          <field name=\"Units\" id=\"f\">  </field>\n          <field name=\"Unit_Price\" id=\"g\">  </field>\n          <field name=\"Total_Price\" id=\"h\">  </field>\n        </subform>\n        <subform name=\"foo\" id=\"o\">\n          <field name=\"Description\" id=\"p\">  </field>\n          <field name=\"Units\" id=\"q\">  </field>\n          <field name=\"Unit_Price\" id=\"r\">  </field>\n          <field name=\"Total_Price\" id=\"s\">  </field>\n        </subform>\n        <field name=\"Sub_Total\" id=\"i\">  </field>\n        <field name=\"Tax\" id=\"j\">  </field>\n        <field name=\"Total_Price\" id=\"k\">  </field>\n      </subform>\n    </template>\n</xdp:xdp>\n        `;\n      const root = new XFAParser().parse(xml);\n      let found = root[$getChildrenByName](\"subform\", true);\n      expect(found.map(x => x.id)).toEqual([\"l\", \"m\", \"n\", \"o\"]);\n      found = root[$getChildrenByName](\"Total_Price\", true);\n      expect(found.map(x => x.id)).toEqual([\"d\", \"h\", \"s\", \"k\"]);\n      found = root.template[$getChildrenByName](\"Receipt\", false);\n      const receipt = found[0];\n      found = receipt[$getChildrenByName](\"Total_Price\", false);\n      expect(found.map(x => x.id)).toEqual([\"d\", \"h\", \"k\"]);\n      expect(receipt[$getChildrenByClass](\"name\")).toEqual(\"Receipt\");\n      const subforms = receipt[$getChildrenByClass](\"subform\");\n      expect(subforms.children.map(x => x.id)).toEqual([\"m\", \"n\", \"o\"]);\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should search some nodes in a template object using SOM","suites":["XFAParser","Search in XFA"],"line":549,"updatePoint":{"line":549,"column":63,"index":17039},"code":"    it(\"should search some nodes in a template object using SOM\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n    <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n      <subform name=\"Receipt\" id=\"l\">\n        <subform id=\"m\">\n          <field name=\"Description\" id=\"a\">  </field>\n          <field name=\"Units\" id=\"b\">  </field>\n          <field name=\"Unit_Price\" id=\"c\">  </field>\n          <field name=\"Total_Price\" id=\"d\">  </field>\n        </subform>\n        <subform id=\"n\">\n          <field name=\"Description\" id=\"e\">  </field>\n          <field name=\"Units\" id=\"f\">  </field>\n          <field name=\"Unit_Price\" id=\"g\">  </field>\n          <field name=\"Total_Price\" id=\"h\">  </field>\n        </subform>\n        <subform name=\"foo\" id=\"o\">\n          <field name=\"Description\" id=\"p\">  </field>\n          <field name=\"Units\" id=\"q\">  </field>\n          <field name=\"Unit_Price\" id=\"r\">  </field>\n          <field name=\"Total_Price\" id=\"s\">  </field>\n        </subform>\n        <field name=\"Sub_Total\" id=\"i\">  </field>\n        <field name=\"Tax\" id=\"j\">  </field>\n        <field name=\"Total_Price\" id=\"k\">  </field>\n      </subform>\n    </template>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      expect(searchNode(root, null, \"$template..Description.id\")[0][$text]()).toBe(\"a\");\n      expect(searchNode(root, null, \"$template..Description.id\")[0][$text]()).toBe(\"a\");\n      expect(searchNode(root, null, \"$template..Description[0].id\")[0][$text]()).toBe(\"a\");\n      expect(searchNode(root, null, \"$template..Description[1].id\")[0][$text]()).toBe(\"e\");\n      expect(searchNode(root, null, \"$template..Description[2].id\")[0][$text]()).toBe(\"p\");\n      expect(searchNode(root, null, \"$template.Receipt.id\")[0][$text]()).toBe(\"l\");\n      expect(searchNode(root, null, \"$template.Receipt.Description[1].id\")[0][$text]()).toBe(\"e\");\n      expect(searchNode(root, null, \"$template.Receipt.Description[2]\")).toBe(null);\n      expect(searchNode(root, null, \"$template.Receipt.foo.Description.id\")[0][$text]()).toBe(\"p\");\n      expect(searchNode(root, null, \"$template.#subform.Sub_Total.id\")[0][$text]()).toBe(\"i\");\n      expect(searchNode(root, null, \"$template.#subform.Units.id\")[0][$text]()).toBe(\"b\");\n      expect(searchNode(root, null, \"$template.#subform.Units.parent.id\")[0][$text]()).toBe(\"m\");\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should search some nodes in a datasets object","suites":["XFAParser","Search in XFA"],"line":594,"updatePoint":{"line":594,"column":53,"index":19432},"code":"    it(\"should search some nodes in a datasets object\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <Receipt>\n        <Page>1</Page>\n        <Detail PartNo=\"GS001\">\n          <Description>Giant Slingshot</Description>\n          <Units>1</Units>\n          <Unit_Price>250.00</Unit_Price>\n          <Total_Price>250.00</Total_Price>\n        </Detail>\n        <Page>2</Page>\n        <Detail PartNo=\"RRB-LB\">\n          <Description>Road Runner Bait, large bag</Description>\n          <Units>5</Units>\n          <Unit_Price>12.00</Unit_Price>\n          <Total_Price>60.00</Total_Price>\n        </Detail>\n        <Sub_Total>310.00</Sub_Total>\n        <Tax>24.80</Tax>\n        <Total_Price>334.80</Total_Price>\n      </Receipt>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const data = root.datasets.data;\n      let found = data[$getChildrenByName](\"Description\", true);\n      expect(found.map(x => x[$text]())).toEqual([\"Giant Slingshot\", \"Road Runner Bait, large bag\"]);\n      found = data[$getChildrenByName](\"Total_Price\", true);\n      expect(found.map(x => x[$text]())).toEqual([\"250.00\", \"60.00\", \"334.80\"]);\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should search some nodes using SOM from a non-root node","suites":["XFAParser","Search in XFA"],"line":630,"updatePoint":{"line":630,"column":63,"index":20769},"code":"    it(\"should search some nodes using SOM from a non-root node\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <Receipt>\n        <Page>1</Page>\n        <Detail PartNo=\"GS001\">\n          <Description>Giant Slingshot</Description>\n          <Units>1</Units>\n          <Unit_Price>250.00</Unit_Price>\n          <Total_Price>250.00</Total_Price>\n        </Detail>\n        <Page>2</Page>\n        <Detail PartNo=\"RRB-LB\">\n          <Description>Road Runner Bait, large bag</Description>\n          <Units>5</Units>\n          <Unit_Price>12.00</Unit_Price>\n          <Total_Price>60.00</Total_Price>\n        </Detail>\n        <Sub_Total>310.00</Sub_Total>\n        <Tax>24.80</Tax>\n        <Total_Price>334.80</Total_Price>\n      </Receipt>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const [receipt] = root.datasets.data[$getChildren](\"Receipt\");\n      expect(searchNode(root, receipt, \"Detail[*].Total_Price\").map(x => x[$text]())).toEqual([\"250.00\", \"60.00\"]);\n      const [units] = searchNode(root, receipt, \"Detail[1].Units\");\n      expect(units[$text]()).toBe(\"5\");\n      let [found] = searchNode(root, units, \"Total_Price\");\n      expect(found[$text]()).toBe(\"60.00\");\n      found = searchNode(root, units, \"Total_Pric\");\n      expect(found).toEqual(null);\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should search some nodes in a datasets object using SOM","suites":["XFAParser","Search in XFA"],"line":669,"updatePoint":{"line":669,"column":63,"index":22243},"code":"    it(\"should search some nodes in a datasets object using SOM\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <Receipt Detail=\"Acme\">\n        <Detail>foo</Detail>\n        <Detail>bar</Detail>\n     </Receipt>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      expect(searchNode(root, null, \"$data.Receipt.Detail\")[0][$text]()).toBe(\"Acme\");\n      expect(searchNode(root, null, \"$data.Receipt.Detail[0]\")[0][$text]()).toBe(\"Acme\");\n      expect(searchNode(root, null, \"$data.Receipt.Detail[1]\")[0][$text]()).toBe(\"foo\");\n      expect(searchNode(root, null, \"$data.Receipt.Detail[2]\")[0][$text]()).toBe(\"bar\");\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should make a basic binding","suites":["XFAParser","Bind data into form"],"line":691,"updatePoint":{"line":691,"column":35,"index":23090},"code":"    it(\"should make a basic binding\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"A\">\n      <subform name=\"B\">\n        <field name=\"C\">\n        </field>\n        <field name=\"D\">\n        </field>\n      </subform>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <A>\n        <C>xyz</C>\n      </A>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const form = new Binder(root).bind();\n      expect(searchNode(form, form, \"A.B.C.value.text\")[0][$dump]().$content).toBe(\"xyz\");\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should make a basic binding and create a non-existing node","suites":["XFAParser","Bind data into form"],"line":718,"updatePoint":{"line":718,"column":66,"index":23872},"code":"    it(\"should make a basic binding and create a non-existing node\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"A\" mergeMode=\"matchTemplate\">\n      <subform name=\"B\">\n        <field name=\"C\">\n        </field>\n        <field name=\"D\">\n          <value>\n            <text>foobar</text>\n          </value>\n        </field>\n      </subform>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <A>\n      </A>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const binder = new Binder(root);\n      const form = binder.bind();\n      const data = binder.getData();\n      expect(searchNode(form, form, \"A.B.D.value.text\")[0][$dump]().$content).toBe(\"foobar\");\n      const expected = {\n        $name: \"A\",\n        attributes: {},\n        children: [{\n          $name: \"B\",\n          attributes: {},\n          children: [{\n            $name: \"C\",\n            attributes: {},\n            children: []\n          }, {\n            $name: \"D\",\n            attributes: {},\n            children: []\n          }]\n        }]\n      };\n      expect(searchNode(data, data, \"A\")[0][$dump]()).toEqual(expected);\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should make a basic binding and create a non-existing node with namespaceId equal to -1","suites":["XFAParser","Bind data into form"],"line":767,"updatePoint":{"line":767,"column":95,"index":25264},"code":"    it(\"should make a basic binding and create a non-existing node with namespaceId equal to -1\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"A\">\n      <subform name=\"B\">\n        <field name=\"C\">\n        </field>\n        <field name=\"D\">\n          <value>\n            <text>foobar</text>\n          </value>\n        </field>\n      </subform>\n    </subform>\n  </template>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const binder = new Binder(root);\n      const form = binder.bind();\n      const data = binder.getData();\n      expect(searchNode(form, form, \"A.B.D.value.text\")[0][$dump]().$content).toBe(\"foobar\"); // Created nodes mustn't belong to xfa:datasets namespace.\n\n      const expected = {\n        $name: \"A\",\n        $ns: -1,\n        attributes: {},\n        children: [{\n          $name: \"B\",\n          $ns: -1,\n          attributes: {},\n          children: [{\n            $name: \"C\",\n            $ns: -1,\n            attributes: {},\n            children: []\n          }, {\n            $name: \"D\",\n            $ns: -1,\n            attributes: {},\n            children: []\n          }]\n        }]\n      };\n      expect(searchNode(data, data, \"A\")[0][$dump](\n      /* hasNS */\n      true)).toEqual(expected);\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should make another basic binding","suites":["XFAParser","Bind data into form"],"line":817,"updatePoint":{"line":817,"column":41,"index":26604},"code":"    it(\"should make another basic binding\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"registration\">\n      <field name=\"first\"> </field>\n      <field name=\"last\">  </field>\n      <field name=\"apt\">  </field>\n      <field name=\"street\">  </field>\n      <field name=\"city\">  </field>\n      <field name=\"country\">  </field>\n      <field name=\"postalcode\"/>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <registration>\n        <first>Jack</first>\n        <last>Spratt</last>\n        <apt/>\n        <street>99 Candlestick Lane</street>\n        <city>London</city>\n        <country>UK</country>\n        <postalcode>SW1</postalcode>\n      </registration>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const form = new Binder(root).bind();\n      expect(searchNode(form, form, \"registration.first..text\")[0][$dump]().$content).toBe(\"Jack\");\n      expect(searchNode(form, form, \"registration.last..text\")[0][$dump]().$content).toBe(\"Spratt\");\n      expect(searchNode(form, form, \"registration.apt..text\")[0][$dump]().$content).toBe(undefined);\n      expect(searchNode(form, form, \"registration.street..text\")[0][$dump]().$content).toBe(\"99 Candlestick Lane\");\n      expect(searchNode(form, form, \"registration.city..text\")[0][$dump]().$content).toBe(\"London\");\n      expect(searchNode(form, form, \"registration.country..text\")[0][$dump]().$content).toBe(\"UK\");\n      expect(searchNode(form, form, \"registration.postalcode..text\")[0][$dump]().$content).toBe(\"SW1\");\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should make basic binding with extra subform","suites":["XFAParser","Bind data into form"],"line":857,"updatePoint":{"line":857,"column":52,"index":28356},"code":"    it(\"should make basic binding with extra subform\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"registration\">\n      <field name=\"first\"> </field>\n      <field name=\"last\">  </field>\n      <subform name=\"address\">\n        <field name=\"apt\">  </field>\n        <field name=\"street\">  </field>\n        <field name=\"city\">  </field>\n        <field name=\"country\">  </field>\n        <field name=\"postalcode\">  </field>\n      </subform>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <registration>\n        <first>Jack</first>\n        <last>Spratt</last>\n        <apt/>\n        <street>99 Candlestick Lane</street>\n        <city>London</city>\n        <country>UK</country>\n        <postalcode>SW1</postalcode>\n      </registration>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const form = new Binder(root).bind();\n      expect(searchNode(form, form, \"registration..first..text\")[0][$dump]().$content).toBe(\"Jack\");\n      expect(searchNode(form, form, \"registration..last..text\")[0][$dump]().$content).toBe(\"Spratt\");\n      expect(searchNode(form, form, \"registration..apt..text\")[0][$dump]().$content).toBe(undefined);\n      expect(searchNode(form, form, \"registration..street..text\")[0][$dump]().$content).toBe(\"99 Candlestick Lane\");\n      expect(searchNode(form, form, \"registration..city..text\")[0][$dump]().$content).toBe(\"London\");\n      expect(searchNode(form, form, \"registration..country..text\")[0][$dump]().$content).toBe(\"UK\");\n      expect(searchNode(form, form, \"registration..postalcode..text\")[0][$dump]().$content).toBe(\"SW1\");\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should make basic binding with extra subform","suites":["XFAParser","Bind data into form"],"line":899,"updatePoint":{"line":899,"column":52,"index":30182},"code":"    it(\"should make basic binding with extra subform\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"registration\" mergeMode=\"consumeData\">\n      <subform name=\"address\">\n        <field name=\"first\"/>\n        <field name=\"last\"/>\n        <field name=\"apt\"/>\n        <field name=\"street\"/>\n        <field name=\"city\"/>\n      </subform>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <registration>\n        <first>Jack</first>\n        <last>Spratt</last>\n        <address>\n          <apt>7</apt>\n          <street>99 Candlestick Lane</street>\n          <city>London</city>\n        </address>\n      </registration>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const form = new Binder(root).bind();\n      expect(searchNode(form, form, \"registration..first..text\")[0][$dump]().$content).toBe(\"Jack\");\n      expect(searchNode(form, form, \"registration..last..text\")[0][$dump]().$content).toBe(\"Spratt\");\n      expect(searchNode(form, form, \"registration..apt..text\")[0][$dump]().$content).toBe(\"7\");\n      expect(searchNode(form, form, \"registration..street..text\")[0][$dump]().$content).toBe(\"99 Candlestick Lane\");\n      expect(searchNode(form, form, \"registration..city..text\")[0][$dump]().$content).toBe(\"London\");\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should make basic binding with same names in different parts","suites":["XFAParser","Bind data into form"],"line":937,"updatePoint":{"line":937,"column":68,"index":31693},"code":"    it(\"should make basic binding with same names in different parts\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"application\" mergeMode=\"consumeData\">\n      <subform name=\"sponsor\">\n        <field name=\"lastname\">  </field>\n        <!-- sponsor's last name -->\n      </subform>\n      <field name=\"lastname\">  </field>\n      <!-- applicant's last name -->\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <application>\n        <lastname>Abott</lastname>\n        <sponsor>\n          <lastname>Costello</lastname>\n        </sponsor>\n      </application>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const form = new Binder(root).bind();\n      expect(searchNode(form, form, \"application.sponsor.lastname..text\")[0][$dump]().$content).toBe(\"Costello\");\n      expect(searchNode(form, form, \"application.lastname..text\")[0][$dump]().$content).toBe(\"Abott\");\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should make binding and create nodes in data","suites":["XFAParser","Bind data into form"],"line":968,"updatePoint":{"line":968,"column":52,"index":32812},"code":"    it(\"should make binding and create nodes in data\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"root\" mergeMode=\"matchTemplate\">\n      <subform name=\"A\">\n        <field name=\"a\"/>\n        <field name=\"b\"/>\n        <subform name=\"B\">\n          <field name=\"c\"/>\n          <field name=\"d\"/>\n          <subform name=\"C\">\n            <field name=\"e\"/>\n            <field name=\"f\"/>\n          </subform>\n        </subform>\n      </subform>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <root>\n        <A>\n          <b>1</b>\n        </A>\n      </root>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const binder = new Binder(root);\n      const form = binder.bind();\n      const data = binder.getData();\n      expect(searchNode(form, form, \"root..b..text\")[0][$dump]().$content).toBe(\"1\");\n      expect(searchNode(data, data, \"root.A.a\")[0][$dump]().$name).toBe(\"a\");\n      expect(searchNode(data, data, \"root.A.B.c\")[0][$dump]().$name).toBe(\"c\");\n      expect(searchNode(data, data, \"root.A.B.d\")[0][$dump]().$name).toBe(\"d\");\n      expect(searchNode(data, data, \"root.A.B.C.e\")[0][$dump]().$name).toBe(\"e\");\n      expect(searchNode(data, data, \"root.A.B.C.f\")[0][$dump]().$name).toBe(\"f\");\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should make binding and set properties","suites":["XFAParser","Bind data into form"],"line":1010,"updatePoint":{"line":1010,"column":46,"index":34277},"code":"    it(\"should make binding and set properties\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"Id\">\n      <field name=\"LastName\">\n        <setProperty ref=\"$data.Main.Style.NameFont\" target=\"font.typeface\"/>\n        <setProperty ref=\"$data.Main.Style.NameSize\" target=\"font.size\"/>\n        <setProperty ref=\"$data.Main.Help.LastName\" target=\"assist.toolTip\"/>\n        <font></font>\n        <assist>\n          <toolTip>\n          </toolTip>\n        </assist>\n      </field>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <Id>\n        <LastName>foo</LastName>\n      </Id>\n      <Main>\n        <Style>\n          <NameFont>myfont</NameFont>\n          <NameSize>123.4pt</NameSize>\n        </Style>\n        <Help>\n          <LastName>Give the name!</LastName>\n        </Help>\n      </Main>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const form = new Binder(root).bind();\n      expect(searchNode(form, form, \"Id.LastName..text\")[0][$dump]().$content).toBe(\"foo\");\n      expect(searchNode(form, form, \"Id.LastName.font.typeface\")[0][$text]()).toBe(\"myfont\");\n      expect(searchNode(form, form, \"Id.LastName.font.size\")[0][$text]()).toEqual(123.4);\n      expect(searchNode(form, form, \"Id.LastName.assist.toolTip\")[0][$dump]().$content).toBe(\"Give the name!\");\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should make binding and bind items","suites":["XFAParser","Bind data into form"],"line":1053,"updatePoint":{"line":1053,"column":42,"index":35810},"code":"    it(\"should make binding and bind items\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"main\">\n      <field name=\"CardName\">\n        <bindItems ref=\"$data.main.ccs.cc[*]\" labelRef=\"uiname\" valueRef=\"token\"/>\n        <ui>\n          <choiceList/>\n        </ui>\n      </field>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <main>\n        <ccs>\n          <cc uiname=\"Visa\" token=\"VISA\"/>\n          <cc uiname=\"Mastercard\" token=\"MC\"/>\n          <cc uiname=\"American Express\" token=\"AMEX\"/>\n        </ccs>\n        <CardName>MC</CardName>\n      </main>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const form = new Binder(root).bind();\n      expect(searchNode(form, form, \"subform.CardName.items[*].text[*]\").map(x => x[$text]())).toEqual([\"Visa\", \"Mastercard\", \"American Express\", \"VISA\", \"MC\", \"AMEX\"]);\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should make binding and bind items with a ref","suites":["XFAParser","Bind data into form"],"line":1085,"updatePoint":{"line":1085,"column":53,"index":36907},"code":"    it(\"should make binding and bind items with a ref\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"main\">\n      <field name=\"CardName\">\n        <bind match=\"dataRef\" ref=\"$data.main.value\"/>\n        <bindItems ref=\"$data.main.ccs.cc[*]\" labelRef=\"uiname\" valueRef=\"token\"/>\n        <ui>\n          <choiceList/>\n        </ui>\n      </field>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <main>\n        <value>VISA</value>\n        <ccs>\n          <cc uiname=\"Visa\" token=\"VISA\"/>\n          <cc uiname=\"Mastercard\" token=\"MC\"/>\n          <cc uiname=\"American Express\" token=\"AMEX\"/>\n        </ccs>\n        <CardName>MC</CardName>\n      </main>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const form = new Binder(root).bind();\n      expect(searchNode(form, form, \"subform.CardName.value.text\").map(x => x[$text]())).toEqual([\"VISA\"]);\n      expect(searchNode(form, form, \"subform.CardName.items[*].text[*]\").map(x => x[$text]())).toEqual([\"Visa\", \"Mastercard\", \"American Express\", \"VISA\", \"MC\", \"AMEX\"]);\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should make binding with occurrences in consumeData mode","suites":["XFAParser","Bind data into form"],"line":1120,"updatePoint":{"line":1120,"column":64,"index":38206},"code":"    it(\"should make binding with occurrences in consumeData mode\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"root\" mergeMode=\"consumeData\">\n      <subform name=\"section\" id=\"section1\">\n        <occur min=\"0\" max=\"-1\"/>\n        <bind match=\"dataRef\" ref=\"$.section[*]\"/>\n        <field name=\"line-item\"/>\n      </subform>\n      <subform name=\"section\" id=\"section2\">\n        <occur min=\"0\" max=\"-1\"/>\n        <bind match=\"dataRef\" ref=\"$.section[*]\"/>\n        <field name=\"line-item\"/>\n      </subform>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <root>\n        <section>\n          <line-item>item1</line-item>\n        </section>\n        <section>\n          <line-item>item2</line-item>\n        </section>\n      </root>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const form = new Binder(root).bind();\n      expect(searchNode(form, form, \"root.section[*].id\").map(x => x[$text]())).toEqual([\"section1\", \"section1\"]);\n      expect(searchNode(form, form, \"root.section[*].line-item..text\").map(x => x[$text]())).toEqual([\"item1\", \"item2\"]);\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should make binding with occurrences in matchTemplate mode","suites":["XFAParser","Bind data into form"],"line":1157,"updatePoint":{"line":1157,"column":66,"index":39536},"code":"    it(\"should make binding with occurrences in matchTemplate mode\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"root\" mergeMode=\"matchTemplate\">\n      <subform name=\"section\" id=\"section1\">\n        <occur min=\"0\" max=\"-1\"/>\n        <bind match=\"dataRef\" ref=\"$.section[*]\"/>\n        <field name=\"line-item\"/>\n      </subform>\n      <subform name=\"section\" id=\"section2\">\n        <occur min=\"0\" max=\"-1\"/>\n        <bind match=\"dataRef\" ref=\"$.section[*]\"/>\n        <field name=\"line-item\"/>\n      </subform>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <root>\n        <section>\n          <line-item>item1</line-item>\n        </section>\n        <section>\n          <line-item>item2</line-item>\n        </section>\n      </root>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const form = new Binder(root).bind();\n      expect(searchNode(form, form, \"root.section[*].id\").map(x => x[$text]())).toEqual([\"section1\", \"section1\", \"section2\", \"section2\"]);\n      expect(searchNode(form, form, \"root.section[*].line-item..text\").map(x => x[$text]())).toEqual([\"item1\", \"item2\", \"item1\", \"item2\"]);\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should make binding and create nodes in data with some bind tag","suites":["XFAParser","Bind data into form"],"line":1194,"updatePoint":{"line":1194,"column":71,"index":40915},"code":"    it(\"should make binding and create nodes in data with some bind tag\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"root\" mergeMode=\"matchTemplate\">\n      <subform name=\"A\">\n        <occur max=\"-1\"/>\n        <bind ref=\"$.root.foo[*]\" match=\"dataRef\"/>\n      </subform>\n      <subform name=\"B\">\n        <occur max=\"2\"/>\n        <bind ref=\"$.root.bar[2]\" match=\"dataRef\"/>\n      </subform>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <root>\n      </root>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const binder = new Binder(root);\n      binder.bind();\n      const data = binder.getData();\n      const expected = {\n        $name: \"root\",\n        children: [{\n          $name: \"root\",\n          children: [{\n            $name: \"foo\",\n            children: [],\n            attributes: {}\n          }, {\n            $name: \"bar\",\n            children: [],\n            attributes: {}\n          }, {\n            $name: \"bar\",\n            children: [],\n            attributes: {}\n          }, {\n            $name: \"bar\",\n            children: [],\n            attributes: {}\n          }],\n          attributes: {}\n        }],\n        attributes: {}\n      };\n      expect(searchNode(data, data, \"root\")[0][$dump]()).toEqual(expected);\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should make a binding with a bindItems","suites":["XFAParser","Bind data into form"],"line":1249,"updatePoint":{"line":1249,"column":46,"index":42405},"code":"    it(\"should make a binding with a bindItems\", function () {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"A\" mergeMode=\"matchTemplate\">\n      <subform name=\"B\">\n        <field name=\"C\">\n          <ui>\n            <choicelist/>\n          </ui>\n          <bindItems ref=\"xfa.datasets.foo.bar[*]\" labelRef=\"$\" valueRef=\"oof\"/>\n        </field>\n      </subform>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <foo>\n      <bar oof=\"a\">1</bar>\n      <bar oof=\"b\">2</bar>\n      <bar oof=\"c\">3</bar>\n      <bar oof=\"d\">4</bar>\n      <bar oof=\"e\">5</bar>\n    </foo>\n    <xfa:data>\n      <A><B></B></A>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const root = new XFAParser().parse(xml);\n      const form = new Binder(root).bind();\n      expect(searchNode(form, form, \"A.B.C.items[0].text[*]\").map(x => x[$dump]().$content)).toEqual([\"1\", \"2\", \"3\", \"4\", \"5\"]);\n      expect(searchNode(form, form, \"A.B.C.items[1].text[*]\").map(x => x[$dump]().$content)).toEqual([\"a\", \"b\", \"c\", \"d\", \"e\"]);\n    });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should make a binding with a element in an area","suites":["XFAParser","Bind data into form"],"line":1285,"updatePoint":{"line":1285,"column":53,"index":43606},"code":"  it(\"should make a binding with a element in an area\", function () {\n    const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"A\" mergeMode=\"matchTemplate\">\n      <area>\n        <field name=\"B\"/>\n      </area>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <A><B>foobar</B></A>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n    `;\n    const root = new XFAParser().parse(xml);\n    const form = new Binder(root).bind();\n    expect(searchNode(form, form, \"A..B..text\")[0][$dump]().$content).toBe(\"foobar\");\n  });","file":"unit/xfa_parser_spec.js","skipped":false,"dir":"test"},{"name":"should serialize data with an annotationStorage","suites":["Data serializer"],"line":20,"updatePoint":{"line":20,"column":53,"index":924},"code":"  it(\"should serialize data with an annotationStorage\", function () {\n    const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <foo>bar</foo>\n    <xfa:data>\n      <Receipt>\n        <Page>1</Page>\n        <Detail PartNo=\"GS001\">\n          <Description>Giant Slingshot</Description>\n          <Units>1</Units>\n          <Unit_Price>250.00</Unit_Price>\n          <Total_Price>250.00</Total_Price>\n          <àé></àé>\n        </Detail>\n        <Page>2</Page>\n        <Detail PartNo=\"RRB-LB\">\n          <Description>Road Runner Bait, large bag</Description>\n          <Units>5</Units>\n          <Unit_Price>12.00</Unit_Price>\n          <Total_Price>60.00</Total_Price>\n        </Detail>\n        <Sub_Total>310.00</Sub_Total>\n        <Tax>24.80</Tax>\n        <Total_Price>334.80</Total_Price>\n      </Receipt>\n    </xfa:data>\n    <bar>foo</bar>\n  </xfa:datasets>\n</xdp:xdp>\n    `;\n    const root = new XFAParser().parse(xml);\n    const data = root.datasets.data;\n    const dataHandler = new DataHandler(root, data);\n    const storage = new Map();\n\n    for (const [path, value] of [[\"Receipt.Detail[0].Units\", \"12&3\"], [\"Receipt.Detail[0].Unit_Price\", \"456>\"], [\"Receipt.Detail[0].Total_Price\", \"789\"], [\"Receipt.Detail[0].àé\", \"1011\"], [\"Receipt.Detail[1].PartNo\", \"foo-bar😀\"], [\"Receipt.Detail[1].Description\", \"hello world\"]]) {\n      storage.set(searchNode(root, data, path)[0][$uid], {\n        value\n      });\n    }\n\n    const serialized = dataHandler.serialize(storage);\n    const expected = `<xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\"><foo>bar</foo><bar>foo</bar><xfa:data><Receipt><Page>1</Page><Detail PartNo=\"GS001\"><Description>Giant Slingshot</Description><Units>12&amp;3</Units><Unit_Price>456&gt;</Unit_Price><Total_Price>789</Total_Price><\\xC3\\xA0\\xC3\\xA9>1011</\\xC3\\xA0\\xC3\\xA9></Detail><Page>2</Page><Detail PartNo=\"foo-bar&#x1F600;\"><Description>hello world</Description><Units>5</Units><Unit_Price>12.00</Unit_Price><Total_Price>60.00</Total_Price></Detail><Sub_Total>310.00</Sub_Total><Tax>24.80</Tax><Total_Price>334.80</Total_Price></Receipt></xfa:data></xfa:datasets>`;\n    expect(serialized).toEqual(expected);\n  });","file":"unit/xfa_serialize_data_spec.js","skipped":false,"dir":"test"},{"name":"should convert some basic properties to CSS","suites":["XFAFactory","toHTML"],"line":41,"updatePoint":{"line":41,"column":51,"index":1346},"code":"    it(\"should convert some basic properties to CSS\", async () => {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"root\" mergeMode=\"matchTemplate\">\n      <pageSet>\n        <pageArea>\n          <contentArea x=\"123pt\" w=\"456pt\" h=\"789pt\"/>\n          <medium stock=\"default\" short=\"456pt\" long=\"789pt\"/>\n          <draw y=\"1pt\" w=\"11pt\" h=\"22pt\" rotate=\"90\" x=\"2pt\">\n            <assist><toolTip>A tooltip !!</toolTip></assist>\n            <font size=\"7pt\" typeface=\"FooBar\" baselineShift=\"2pt\">\n              <fill>\n                <color value=\"12,23,34\"/>\n                <solid/>\n              </fill>\n            </font>\n            <value/>\n            <margin topInset=\"1pt\" bottomInset=\"2pt\" leftInset=\"3pt\" rightInset=\"4pt\"/>\n            <para spaceAbove=\"1pt\" spaceBelow=\"2pt\" textIndent=\"3pt\" marginLeft=\"4pt\" marginRight=\"5pt\"/>\n          </draw>\n        </pageArea>\n      </pageSet>\n      <subform name=\"second\">\n        <breakBefore targetType=\"pageArea\" startNew=\"1\"/>\n        <subform>\n          <draw w=\"1pt\" h=\"1pt\"><value><text>foo</text></value></draw>\n        </subform>\n      </subform>\n      <subform name=\"third\">\n        <breakBefore targetType=\"pageArea\" startNew=\"1\"/>\n        <subform>\n          <draw w=\"1pt\" h=\"1pt\"><value><text>bar</text></value></draw>\n        </subform>\n      </subform>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const factory = new XFAFactory({\n        \"xdp:xdp\": xml\n      });\n      factory.setFonts([]);\n      expect(await factory.getNumPages()).toEqual(2);\n      const pages = await factory.getPages();\n      const page1 = pages.children[0];\n      expect(page1.attributes.style).toEqual({\n        height: \"789px\",\n        width: \"456px\"\n      });\n      expect(page1.children.length).toEqual(2);\n      const container = page1.children[1];\n      expect(container.attributes.class).toEqual([\"xfaContentarea\"]);\n      expect(container.attributes.style).toEqual({\n        height: \"789px\",\n        width: \"456px\",\n        left: \"123px\",\n        top: \"0px\"\n      });\n      const wrapper = page1.children[0];\n      const draw = wrapper.children[0];\n      expect(wrapper.attributes.class).toEqual([\"xfaWrapper\"]);\n      expect(wrapper.attributes.style).toEqual({\n        alignSelf: \"start\",\n        height: \"22px\",\n        left: \"2px\",\n        position: \"absolute\",\n        top: \"1px\",\n        transform: \"rotate(-90deg)\",\n        transformOrigin: \"top left\",\n        width: \"11px\"\n      });\n      expect(draw.attributes.class).toEqual([\"xfaDraw\", \"xfaFont\", \"xfaWrapped\"]);\n      expect(draw.attributes.title).toEqual(\"A tooltip !!\");\n      expect(draw.attributes.style).toEqual({\n        color: \"#0c1722\",\n        fontFamily: '\"FooBar\"',\n        fontKerning: \"none\",\n        letterSpacing: \"0px\",\n        fontStyle: \"normal\",\n        fontWeight: \"normal\",\n        fontSize: \"6.93px\",\n        padding: \"1px 4px 2px 3px\",\n        verticalAlign: \"2px\"\n      }); // draw element must be on each page.\n\n      expect(draw.attributes.style).toEqual(pages.children[1].children[0].children[0].attributes.style);\n    });","file":"unit/xfa_tohtml_spec.js","skipped":false,"dir":"test"},{"name":"should have an alt attribute from toolTip","suites":["XFAFactory","toHTML"],"line":134,"updatePoint":{"line":134,"column":49,"index":4655},"code":"    it(\"should have an alt attribute from toolTip\", async () => {\n      if (isNodeJS) {\n        pending(\"Image is not supported in Node.js.\");\n      }\n\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"root\" mergeMode=\"matchTemplate\">\n      <pageSet>\n        <pageArea>\n          <contentArea x=\"0pt\" w=\"456pt\" h=\"789pt\"/>\n          <draw name=\"BA-Logo\" y=\"5.928mm\" x=\"128.388mm\" w=\"71.237mm\" h=\"9.528mm\">\n            <value>\n              <image contentType=\"image/png\">iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=</image>\n            </value>\n            <assist><toolTip>alt text</toolTip></assist>\n          </draw>\n        </pageArea>\n      </pageSet>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const factory = new XFAFactory({\n        \"xdp:xdp\": xml\n      });\n      expect(await factory.getNumPages()).toEqual(1);\n      const pages = await factory.getPages();\n      const field = searchHtmlNode(pages, \"name\", \"img\");\n      expect(field.attributes.alt).toEqual(\"alt text\");\n    });","file":"unit/xfa_tohtml_spec.js","skipped":false,"dir":"test"},{"name":"should have a aria heading role and level","suites":["XFAFactory","toHTML"],"line":171,"updatePoint":{"line":171,"column":49,"index":5943},"code":"    it(\"should have a aria heading role and level\", async () => {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"root\" mergeMode=\"matchTemplate\">\n      <pageSet>\n        <pageArea>\n          <contentArea x=\"0pt\" w=\"456pt\" h=\"789pt\"/>\n          <medium stock=\"default\" short=\"456pt\" long=\"789pt\"/>\n          <draw name=\"BA-Logo\" y=\"5.928mm\" x=\"128.388mm\" w=\"71.237mm\" h=\"9.528mm\">\n            <value><text>foo</text></value>\n            <assist role=\"H2\"></assist>\n          </draw>\n        </pageArea>\n      </pageSet>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const factory = new XFAFactory({\n        \"xdp:xdp\": xml\n      });\n      expect(await factory.getNumPages()).toEqual(1);\n      const pages = await factory.getPages();\n      const page1 = pages.children[0];\n      const wrapper = page1.children[0];\n      const draw = wrapper.children[0];\n      expect(draw.attributes.role).toEqual(\"heading\");\n      expect(draw.attributes[\"aria-level\"]).toEqual(\"2\");\n    });","file":"unit/xfa_tohtml_spec.js","skipped":false,"dir":"test"},{"name":"should have aria table role","suites":["XFAFactory","toHTML"],"line":206,"updatePoint":{"line":206,"column":35,"index":7153},"code":"    it(\"should have aria table role\", async () => {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"root\" mergeMode=\"matchTemplate\">\n      <pageSet>\n        <pageArea>\n          <contentArea x=\"0pt\" w=\"456pt\" h=\"789pt\"/>\n          <medium stock=\"default\" short=\"456pt\" long=\"789pt\"/>\n          <font size=\"7pt\" typeface=\"FooBar\" baselineShift=\"2pt\">\n          </font>\n        </pageArea>\n      </pageSet>\n      <subform name=\"table\" mergeMode=\"matchTemplate\" layout=\"table\">\n        <subform layout=\"row\" name=\"row1\">\n          <assist role=\"TH\"></assist>\n          <draw name=\"header1\" y=\"5.928mm\" x=\"128.388mm\" w=\"71.237mm\" h=\"9.528mm\">\n            <value><text>Header Col 1</text></value>\n          </draw>\n          <draw name=\"header2\" y=\"5.928mm\" x=\"128.388mm\" w=\"71.237mm\" h=\"9.528mm\">\n            <value><text>Header Col 2</text></value>\n          </draw>\n        </subform>\n        <subform layout=\"row\" name=\"row2\">\n          <draw name=\"cell1\" y=\"5.928mm\" x=\"128.388mm\" w=\"71.237mm\" h=\"9.528mm\">\n            <value><text>Cell 1</text></value>\n          </draw>\n          <draw name=\"cell2\" y=\"5.928mm\" x=\"128.388mm\" w=\"71.237mm\" h=\"9.528mm\">\n            <value><text>Cell 2</text></value>\n          </draw>\n        </subform>\n      </subform>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const factory = new XFAFactory({\n        \"xdp:xdp\": xml\n      });\n      factory.setFonts([]);\n      expect(await factory.getNumPages()).toEqual(1);\n      const pages = await factory.getPages();\n      const table = searchHtmlNode(pages, \"xfaName\", \"table\",\n      /* byAttributes */\n      true);\n      expect(table.attributes.role).toEqual(\"table\");\n      const headerRow = searchHtmlNode(pages, \"xfaName\", \"row1\",\n      /* byAttributes */\n      true);\n      expect(headerRow.attributes.role).toEqual(\"row\");\n      const headerCell = searchHtmlNode(pages, \"xfaName\", \"header2\",\n      /* byAttributes */\n      true);\n      expect(headerCell.attributes.role).toEqual(\"columnheader\");\n      const row = searchHtmlNode(pages, \"xfaName\", \"row2\",\n      /* byAttributes */\n      true);\n      expect(row.attributes.role).toEqual(\"row\");\n      const cell = searchHtmlNode(pages, \"xfaName\", \"cell2\",\n      /* byAttributes */\n      true);\n      expect(cell.attributes.role).toEqual(\"cell\");\n    });","file":"unit/xfa_tohtml_spec.js","skipped":false,"dir":"test"},{"name":"should have a maxLength property","suites":["XFAFactory","toHTML"],"line":274,"updatePoint":{"line":274,"column":40,"index":9695},"code":"    it(\"should have a maxLength property\", async () => {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"root\" mergeMode=\"matchTemplate\">\n      <pageSet>\n        <pageArea>\n          <contentArea x=\"0pt\" w=\"456pt\" h=\"789pt\"/>\n          <medium stock=\"default\" short=\"456pt\" long=\"789pt\"/>\n          <field y=\"1pt\" w=\"11pt\" h=\"22pt\" x=\"2pt\">\n            <ui>\n              <textEdit multiLine=\"0\"/>\n            </ui>\n            <value>\n              <text maxChars=\"123\"/>\n            </value>\n          </field>\n        </pageArea>\n      </pageSet>\n      <subform name=\"first\">\n        <draw w=\"1pt\" h=\"1pt\"><value><text>foo</text></value></draw>\n      </subform>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const factory = new XFAFactory({\n        \"xdp:xdp\": xml\n      });\n      expect(await factory.getNumPages()).toEqual(1);\n      const pages = await factory.getPages();\n      const field = searchHtmlNode(pages, \"name\", \"input\");\n      expect(field.attributes.maxLength).toEqual(123);\n    });","file":"unit/xfa_tohtml_spec.js","skipped":false,"dir":"test"},{"name":"should have an aria-label property from speak","suites":["XFAFactory","toHTML"],"line":313,"updatePoint":{"line":313,"column":53,"index":10959},"code":"    it(\"should have an aria-label property from speak\", async () => {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"root\" mergeMode=\"matchTemplate\">\n      <pageSet>\n        <pageArea>\n          <contentArea x=\"0pt\" w=\"456pt\" h=\"789pt\"/>\n          <medium stock=\"default\" short=\"456pt\" long=\"789pt\"/>\n          <field y=\"1pt\" w=\"11pt\" h=\"22pt\" x=\"2pt\">\n            <assist><speak>Screen Reader</speak></assist>\n            <ui>\n              <textEdit multiLine=\"0\"/>\n            </ui>\n            <value>\n              <text maxChars=\"123\"/>\n            </value>\n          </field>\n        </pageArea>\n      </pageSet>\n      <subform name=\"first\">\n        <draw w=\"1pt\" h=\"1pt\"><value><text>foo</text></value></draw>\n      </subform>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const factory = new XFAFactory({\n        \"xdp:xdp\": xml\n      });\n      expect(await factory.getNumPages()).toEqual(1);\n      const pages = await factory.getPages();\n      const field = searchHtmlNode(pages, \"name\", \"input\");\n      expect(field.attributes[\"aria-label\"]).toEqual(\"Screen Reader\");\n    });","file":"unit/xfa_tohtml_spec.js","skipped":false,"dir":"test"},{"name":"should have an aria-label property from toolTip","suites":["XFAFactory","toHTML"],"line":353,"updatePoint":{"line":353,"column":55,"index":12299},"code":"    it(\"should have an aria-label property from toolTip\", async () => {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"root\" mergeMode=\"matchTemplate\">\n      <pageSet>\n        <pageArea>\n          <contentArea x=\"0pt\" w=\"456pt\" h=\"789pt\"/>\n          <medium stock=\"default\" short=\"456pt\" long=\"789pt\"/>\n          <field y=\"1pt\" w=\"11pt\" h=\"22pt\" x=\"2pt\">\n            <assist><toolTip>Screen Reader</toolTip></assist>\n            <ui>\n              <textEdit multiLine=\"0\"/>\n            </ui>\n            <value>\n              <text maxChars=\"123\"/>\n            </value>\n          </field>\n        </pageArea>\n      </pageSet>\n      <subform name=\"first\">\n        <draw w=\"1pt\" h=\"1pt\"><value><text>foo</text></value></draw>\n      </subform>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const factory = new XFAFactory({\n        \"xdp:xdp\": xml\n      });\n      expect(await factory.getNumPages()).toEqual(1);\n      const pages = await factory.getPages();\n      const field = searchHtmlNode(pages, \"name\", \"input\");\n      expect(field.attributes[\"aria-label\"]).toEqual(\"Screen Reader\");\n    });","file":"unit/xfa_tohtml_spec.js","skipped":false,"dir":"test"},{"name":"should have an input or textarea","suites":["XFAFactory","toHTML"],"line":393,"updatePoint":{"line":393,"column":40,"index":13628},"code":"    it(\"should have an input or textarea\", async () => {\n      const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"root\" mergeMode=\"matchTemplate\">\n      <pageSet>\n        <pageArea>\n          <contentArea x=\"123pt\" w=\"456pt\" h=\"789pt\"/>\n          <medium stock=\"default\" short=\"456pt\" long=\"789pt\"/>\n          <field y=\"1pt\" w=\"11pt\" h=\"22pt\" x=\"2pt\">\n            <ui>\n              <textEdit/>\n            </ui>\n          </field>\n          <field y=\"1pt\" w=\"11pt\" h=\"22pt\" x=\"2pt\">\n            <ui>\n              <textEdit multiLine=\"1\"/>\n            </ui>\n          </field>\n        </pageArea>\n      </pageSet>\n      <subform name=\"first\">\n        <draw w=\"1pt\" h=\"1pt\"><value><text>foo</text></value></draw>\n      </subform>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n      const factory = new XFAFactory({\n        \"xdp:xdp\": xml\n      });\n      expect(await factory.getNumPages()).toEqual(1);\n      const pages = await factory.getPages();\n      const field1 = searchHtmlNode(pages, \"name\", \"input\");\n      expect(field1).not.toEqual(null);\n      const field2 = searchHtmlNode(pages, \"name\", \"textarea\");\n      expect(field2).not.toEqual(null);\n    });","file":"unit/xfa_tohtml_spec.js","skipped":false,"dir":"test"},{"name":"should have an input or textarea","suites":["XFAFactory","toHTML"],"line":437,"updatePoint":{"line":437,"column":38,"index":15029},"code":"  it(\"should have an input or textarea\", async () => {\n    const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"root\" mergeMode=\"matchTemplate\">\n      <pageSet>\n        <pageArea>\n          <contentArea x=\"123pt\" w=\"456pt\" h=\"789pt\"/>\n          <medium stock=\"default\" short=\"456pt\" long=\"789pt\"/>\n          <field y=\"1pt\" w=\"11pt\" h=\"22pt\" x=\"2pt\">\n            <ui>\n              <textEdit multiLine=\"1\"/>\n            </ui>\n          </field>\n        </pageArea>\n      </pageSet>\n      <subform name=\"first\">\n        <field y=\"1pt\" w=\"11pt\" h=\"22pt\" x=\"2pt\" name=\"hello\">\n          <ui>\n            <textEdit/>\n          </ui>\n          <value>\n            <integer/>\n          </value>\n        </field>\n      </subform>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n      <toto>\n        <first>\n          <hello>123\n          </hello>\n        </first>\n      </toto>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n    `;\n    const factory = new XFAFactory({\n      \"xdp:xdp\": xml\n    });\n    expect(await factory.getNumPages()).toEqual(1);\n    const pages = await factory.getPages();\n    const field1 = searchHtmlNode(pages, \"name\", \"input\");\n    expect(field1).not.toEqual(null);\n    expect(field1.attributes.value).toEqual(\"123\");\n  });","file":"unit/xfa_tohtml_spec.js","skipped":false,"dir":"test"},{"name":"should parse URLs correctly","suites":["XFAFactory","toHTML"],"line":487,"updatePoint":{"line":487,"column":33,"index":16441},"code":"  it(\"should parse URLs correctly\", async () => {\n    function getXml(href) {\n      return `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"root\" mergeMode=\"matchTemplate\">\n      <pageSet>\n        <pageArea>\n          <contentArea x=\"0pt\" w=\"456pt\" h=\"789pt\"/>\n          <medium stock=\"default\" short=\"456pt\" long=\"789pt\"/>\n          <draw name=\"url\" y=\"5.928mm\" x=\"128.388mm\" w=\"71.237mm\" h=\"9.528mm\">\n            <value>\n              <exData contentType=\"text/html\">\n                <body xmlns=\"http://www.w3.org/1999/xhtml\">\n                  <a href=\"${href}\">${href}</a>\n                </body>\n              </exData>\n            </value>\n          </draw>\n        </pageArea>\n      </pageSet>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n      `;\n    }\n\n    let factory, pages, a; // A valid, and complete, URL.\n\n    factory = new XFAFactory({\n      \"xdp:xdp\": getXml(\"https://www.example.com/\")\n    });\n    expect(await factory.getNumPages()).toEqual(1);\n    pages = await factory.getPages();\n    a = searchHtmlNode(pages, \"name\", \"a\");\n    expect(a.value).toEqual(\"https://www.example.com/\");\n    expect(a.attributes.href).toEqual(\"https://www.example.com/\"); // A valid, but incomplete, URL.\n\n    factory = new XFAFactory({\n      \"xdp:xdp\": getXml(\"www.example.com/\")\n    });\n    expect(await factory.getNumPages()).toEqual(1);\n    pages = await factory.getPages();\n    a = searchHtmlNode(pages, \"name\", \"a\");\n    expect(a.value).toEqual(\"www.example.com/\");\n    expect(a.attributes.href).toEqual(\"http://www.example.com/\"); // A valid email-address.\n\n    factory = new XFAFactory({\n      \"xdp:xdp\": getXml(\"mailto:test@example.com\")\n    });\n    expect(await factory.getNumPages()).toEqual(1);\n    pages = await factory.getPages();\n    a = searchHtmlNode(pages, \"name\", \"a\");\n    expect(a.value).toEqual(\"mailto:test@example.com\");\n    expect(a.attributes.href).toEqual(\"mailto:test@example.com\"); // Not a valid URL.\n\n    factory = new XFAFactory({\n      \"xdp:xdp\": getXml(\"qwerty/\")\n    });\n    expect(await factory.getNumPages()).toEqual(1);\n    pages = await factory.getPages();\n    a = searchHtmlNode(pages, \"name\", \"a\");\n    expect(a.value).toEqual(\"qwerty/\");\n    expect(a.attributes.href).toEqual(\"\");\n  });","file":"unit/xfa_tohtml_spec.js","skipped":false,"dir":"test"},{"name":"should replace button with an URL by a link","suites":["XFAFactory","toHTML"],"line":557,"updatePoint":{"line":557,"column":49,"index":18903},"code":"  it(\"should replace button with an URL by a link\", async () => {\n    const xml = `\n<?xml version=\"1.0\"?>\n<xdp:xdp xmlns:xdp=\"http://ns.adobe.com/xdp/\">\n  <template xmlns=\"http://www.xfa.org/schema/xfa-template/3.3\">\n    <subform name=\"root\" mergeMode=\"matchTemplate\">\n      <pageSet>\n        <pageArea>\n          <contentArea x=\"123pt\" w=\"456pt\" h=\"789pt\"/>\n          <medium stock=\"default\" short=\"456pt\" long=\"789pt\"/>\n        </pageArea>\n      </pageSet>\n      <subform name=\"first\">\n        <field y=\"1pt\" w=\"11pt\" h=\"22pt\" x=\"2pt\">\n          <ui>\n            <button/>\n          </ui>\n          <event activity=\"click\" name=\"event__click\">\n            <script contentType=\"application/x-javascript\">\n              app.launchURL(\"https://github.com/mozilla/pdf.js\", true);\n            </script>\n          </event>\n        </field>\n        <field y=\"1pt\" w=\"11pt\" h=\"22pt\" x=\"2pt\">\n          <ui>\n            <button/>\n          </ui>\n          <event activity=\"click\" name=\"event__click\">\n            <script contentType=\"application/x-javascript\">\n              xfa.host.gotoURL(\"https://github.com/allizom/pdf.js\");\n            </script>\n          </event>\n        </field>\n      </subform>\n    </subform>\n  </template>\n  <xfa:datasets xmlns:xfa=\"http://www.xfa.org/schema/xfa-data/1.0/\">\n    <xfa:data>\n    </xfa:data>\n  </xfa:datasets>\n</xdp:xdp>\n    `;\n    const factory = new XFAFactory({\n      \"xdp:xdp\": xml\n    });\n    expect(await factory.getNumPages()).toEqual(1);\n    const pages = await factory.getPages();\n    let a = searchHtmlNode(pages, \"name\", \"a\");\n    expect(a.attributes.href).toEqual(\"https://github.com/mozilla/pdf.js\");\n    expect(a.attributes.newWindow).toEqual(true);\n    a = searchHtmlNode(pages, \"name\", \"a\", false, [1]);\n    expect(a.attributes.href).toEqual(\"https://github.com/allizom/pdf.js\");\n    expect(a.attributes.newWindow).toEqual(false);\n  });","file":"unit/xfa_tohtml_spec.js","skipped":false,"dir":"test"},{"name":"should search a node with a given path in xml tree","suites":["XML","searchNode"],"line":19,"updatePoint":{"line":19,"column":58,"index":867},"code":"    it(\"should search a node with a given path in xml tree\", function () {\n      const xml = `\n      <a>\n          <b>\n              <c a=\"123\"/>\n              <d/>\n              <e>\n                  <f>\n                      <g a=\"321\"/>\n                  </f>\n              </e>\n              <c a=\"456\"/>\n              <c a=\"789\"/>\n              <h/>\n              <c a=\"101112\"/>\n          </b>\n          <h>\n              <i/>\n              <j/>\n              <k>\n                  <g a=\"654\"/>\n              </k>\n          </h>\n          <b>\n              <g a=\"987\"/>\n              <h/>\n              <g a=\"121110\"/>\n          </b>\n      </a>`;\n      const root = new SimpleXMLParser({\n        hasAttributes: true\n      }).parseFromString(xml).documentElement;\n\n      function getAttr(path) {\n        return root.searchNode(parseXFAPath(path), 0).attributes[0].value;\n      }\n\n      expect(getAttr(\"b.g\")).toEqual(\"321\");\n      expect(getAttr(\"e.f.g\")).toEqual(\"321\");\n      expect(getAttr(\"e.g\")).toEqual(\"321\");\n      expect(getAttr(\"g\")).toEqual(\"321\");\n      expect(getAttr(\"h.g\")).toEqual(\"654\");\n      expect(getAttr(\"b[0].g\")).toEqual(\"321\");\n      expect(getAttr(\"b[1].g\")).toEqual(\"987\");\n      expect(getAttr(\"b[1].g[0]\")).toEqual(\"987\");\n      expect(getAttr(\"b[1].g[1]\")).toEqual(\"121110\");\n      expect(getAttr(\"c\")).toEqual(\"123\");\n      expect(getAttr(\"c[1]\")).toEqual(\"456\");\n      expect(getAttr(\"c[2]\")).toEqual(\"789\");\n      expect(getAttr(\"c[3]\")).toEqual(\"101112\");\n    });","file":"unit/xml_spec.js","skipped":false,"dir":"test"},{"name":"should dump a xml tree","suites":["XML","searchNode"],"line":70,"updatePoint":{"line":70,"column":30,"index":2342},"code":"    it(\"should dump a xml tree\", function () {\n      const xml = `\n      <a>\n          <b>\n              <c a=\"123\"/>\n              <d>hello</d>\n              <e>\n                  <f>\n                      <g a=\"321\"/>\n                  </f>\n              </e>\n              <c a=\"456\"/>\n              <c a=\"789\"/>\n              <h/>\n              <c a=\"101112\"/>\n          </b>\n          <h>\n              <i/>\n              <j/>\n              <k>&#xA;W&#x1F602;rld&#xA;<g a=\"654\"/>\n              </k>\n          </h>\n          <b>\n              <g a=\"987\"/>\n              <h/>\n              <g a=\"121110\"/>\n          </b>\n      </a>`;\n      const root = new SimpleXMLParser({\n        hasAttributes: true\n      }).parseFromString(xml).documentElement;\n      const buffer = [];\n      root.dump(buffer);\n      expect(buffer.join(\"\").replace(/\\s+/g, \"\")).toEqual(xml.replace(/\\s+/g, \"\"));\n    });","file":"unit/xml_spec.js","skipped":false,"dir":"test"},{"name":"should parse processing instructions","suites":["XML","searchNode"],"line":106,"updatePoint":{"line":106,"column":42,"index":3255},"code":"  it(\"should parse processing instructions\", function () {\n    const xml = `\n      <a>\n          <?foo bar?>\n          <?foo bar oof?>\n          <?foo?>\n      </a>`;\n    const pi = [];\n\n    class MyParser extends XMLParserBase {\n      onPi(name, value) {\n        pi.push([name, value]);\n      }\n\n    }\n\n    new MyParser().parseXml(xml);\n    expect(pi).toEqual([[\"foo\", \"bar\"], [\"foo\", \"bar oof\"], [\"foo\", \"\"]]);\n  });","file":"unit/xml_spec.js","skipped":false,"dir":"test"}]}