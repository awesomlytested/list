{
    "repo": "typescript-eslint/typescript-eslint",
    "url": "https://github.com/typescript-eslint/typescript-eslint",
    "branch": "main",
    "configs": [
        {
            "package": "@typescript-eslint/typescript-eslint",
            "lang": "js",
            "dir": "tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@typescript-eslint/ast-spec",
            "lang": "ts",
            "dir": "packages/ast-spec/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@typescript-eslint/eslint-plugin-internal",
            "lang": "ts",
            "dir": "packages/eslint-plugin-internal/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@typescript-eslint/eslint-plugin-tslint",
            "lang": "ts",
            "dir": "packages/eslint-plugin-tslint/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@typescript-eslint/eslint-plugin",
            "lang": "ts",
            "dir": "packages/eslint-plugin/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@typescript-eslint/experimental-utils",
            "lang": "js",
            "dir": "packages/experimental-utils/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@typescript-eslint/parser",
            "lang": "js",
            "dir": "packages/parser/tests",
            "framework": "jest",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@typescript-eslint/scope-manager",
            "lang": "ts",
            "dir": "packages/scope-manager/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@typescript-eslint/typescript-estree",
            "lang": "ts",
            "dir": "packages/typescript-estree/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@typescript-eslint/visitor-keys",
            "lang": "ts",
            "dir": "packages/visitor-keys/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        }
    ],
    "tests": [
        {
            "name": "should error on missing project",
            "suites": [
                "tslint/error"
            ],
            "updatePoint": {
                "line": 164,
                "column": 37
            },
            "line": 164,
            "code": "  it('should error on missing project', () => {\n    testOutput('foo;', {\n      rules: {\n        'tslint/config': [2, tslintRulesConfig],\n      },\n      parser: '@typescript-eslint/parser',\n    });\n  });",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin-tslint/tests"
        },
        {
            "name": "should error on default parser",
            "suites": [
                "tslint/error"
            ],
            "updatePoint": {
                "line": 173,
                "column": 36
            },
            "line": 173,
            "code": "  it('should error on default parser', () => {\n    testOutput('foo;', {\n      parserOptions: {\n        project: `${__dirname}/test-project/tsconfig.json`,\n      },\n      rules: {\n        'tslint/config': [2, tslintRulesConfig],\n      },\n    });\n  });",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin-tslint/tests"
        },
        {
            "name": "should not crash if there are no tslint rules specified",
            "suites": [
                "tslint/error"
            ],
            "updatePoint": {
                "line": 184,
                "column": 61
            },
            "line": 184,
            "code": "  it('should not crash if there are no tslint rules specified', () => {\n    const linter = new TSESLint.Linter();\n    jest.spyOn(console, 'warn').mockImplementation();\n    linter.defineRule('tslint/config', rule);\n    linter.defineParser('@typescript-eslint/parser', parser);\n    expect(() =>\n      linter.verify(\n        'foo;',\n        {\n          parserOptions: {\n            project: `${__dirname}/test-project/tsconfig.json`,\n          },\n          rules: {\n            'tslint/config': [2, {}],\n          },\n          parser: '@typescript-eslint/parser',\n        },\n        `${__dirname}/test-project/extra.ts`,\n      ),\n    ).not.toThrow();\n\n    expect(console.warn).toHaveBeenCalledWith(\n      expect.stringContaining(\n        `Tried to lint ${__dirname}/test-project/extra.ts but found no valid, enabled rules for this file type and file path in the resolved configuration.`,\n      ),\n    );\n    jest.resetAllMocks();\n  });",
            "file": "index.spec.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin-tslint/tests"
        },
        {
            "name": "has the base rules overriden by the appropriate extension rules",
            "suites": [],
            "updatePoint": {
                "line": 33,
                "column": 69
            },
            "line": 33,
            "code": "  it('has the base rules overriden by the appropriate extension rules', () => {\n    const ruleNames = new Set(Object.keys(unfilteredConfigRules));\n    EXTENSION_RULES.forEach(([ruleName, extRuleName]) => {\n      if (ruleNames.has(ruleName)) {\n        // this looks a little weird, but it provides the cleanest test output style\n        expect(unfilteredConfigRules).toMatchObject({\n          ...unfilteredConfigRules,\n          [extRuleName]: 'off',\n        });\n      }\n    });\n  });",
            "file": "configs.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "contains all of the rules, excluding the deprecated ones",
            "suites": [
                "all.json config"
            ],
            "updatePoint": {
                "line": 56,
                "column": 62
            },
            "line": 56,
            "code": "  it('contains all of the rules, excluding the deprecated ones', () => {\n    expect(entriesToObject(ruleConfigs)).toEqual(entriesToObject(configRules));\n  });",
            "file": "configs.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "contains all recommended rules that don't require typechecking, excluding the deprecated ones",
            "suites": [
                "recommended.json config"
            ],
            "updatePoint": {
                "line": 79,
                "column": 99
            },
            "line": 79,
            "code": "  it(\"contains all recommended rules that don't require typechecking, excluding the deprecated ones\", () => {\n    expect(entriesToObject(ruleConfigs)).toEqual(entriesToObject(configRules));\n  });",
            "file": "configs.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "contains all recommended rules that require type checking, excluding the deprecated ones",
            "suites": [
                "recommended-requiring-type-checking.json config"
            ],
            "updatePoint": {
                "line": 102,
                "column": 94
            },
            "line": 102,
            "code": "  it('contains all recommended rules that require type checking, excluding the deprecated ones', () => {\n    expect(entriesToObject(ruleConfigs)).toEqual(entriesToObject(configRules));\n  });",
            "file": "configs.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "All rules must have a corresponding rule doc",
            "suites": [
                "Validating rule docs"
            ],
            "updatePoint": {
                "line": 46,
                "column": 50
            },
            "line": 46,
            "code": "  it('All rules must have a corresponding rule doc', () => {\n    const files = fs\n      .readdirSync(docsRoot)\n      // this rule doc was left behind on purpose for legacy reasons\n      .filter(rule => rule !== 'camelcase.md' && rule !== 'README.md');\n    const ruleFiles = Object.keys(rules)\n      .map(rule => `${rule}.md`)\n      .sort();\n\n    expect(files.sort()).toEqual(ruleFiles);\n  });",
            "file": "docs.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "Description of .md must match",
            "suites": [
                "Validating rule docs"
            ],
            "updatePoint": {
                "line": 60,
                "column": 48
            },
            "line": 60,
            "code": "    it(`Description of ${ruleName}.md must match`, () => {\n      // validate if description of rule is same as in docs\n      const tokens = parseMarkdownFile(filePath);\n\n      // Rule title not found.\n      // Rule title does not match the rule metadata.\n      expect(tokens[0]).toMatchObject({\n        type: 'heading',\n        depth: 1,\n        text: `${rule.meta.docs?.description} (\\`${ruleName}\\`)`,\n      });\n    });",
            "file": "docs.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "Headers in .md must be title-cased",
            "suites": [
                "Validating rule docs"
            ],
            "updatePoint": {
                "line": 73,
                "column": 53
            },
            "line": 73,
            "code": "    it(`Headers in ${ruleName}.md must be title-cased`, () => {\n      const tokens = parseMarkdownFile(filePath);\n\n      // Get all H2 headers objects as the other levels are variable by design.\n      const headers = tokens.filter(\n        token => token.type === 'heading' && token.depth === 2,\n      ) as marked.Tokens.Heading[];\n\n      headers.forEach(header =>\n        expect(header.text).toBe(titleCase(header.text)),\n      );\n    });",
            "file": "docs.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "Attributes in .md must match the metadata",
            "suites": [
                "Validating rule docs"
            ],
            "updatePoint": {
                "line": 86,
                "column": 60
            },
            "line": 86,
            "code": "    it(`Attributes in ${ruleName}.md must match the metadata`, () => {\n      const tokens = parseMarkdownFile(filePath);\n\n      // Verify attributes header exists\n      const attributesHeaderIndex = tokens.findIndex(\n        token => token.type === 'heading' && token.text === 'Attributes',\n      );\n      expect(attributesHeaderIndex).toBeGreaterThan(-1);\n\n      // Verify attributes content\n      const attributesList = tokens[\n        attributesHeaderIndex + 1\n      ] as marked.Tokens.List;\n      const recommended = attributesList.items[0];\n      expect(rule.meta.docs?.recommended !== false).toBe(recommended.checked);\n      const fixable = attributesList.items[1];\n      expect(rule.meta.fixable !== undefined).toBe(fixable.checked);\n      const requiresTypeChecking = attributesList.items[2];\n      expect(rule.meta.docs?.requiresTypeChecking === true).toBe(\n        requiresTypeChecking.checked,\n      );\n    });",
            "file": "docs.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "`name` field in rule must match the filename",
            "suites": [
                "Validating rule metadata",
                ""
            ],
            "updatePoint": {
                "line": 118,
                "column": 54
            },
            "line": 118,
            "code": "      it('`name` field in rule must match the filename', () => {\n        // validate if rule name is same as url\n        // there is no way to access this field but its used only in generation of docs url\n        expect(rule.meta.docs?.url).toBe(\n          `https://typescript-eslint.io/rules/${ruleName}`,\n        );\n      });",
            "file": "docs.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "`requiresTypeChecking` should be set if the rule uses type information",
            "suites": [
                "Validating rule metadata",
                ""
            ],
            "updatePoint": {
                "line": 126,
                "column": 80
            },
            "line": 126,
            "code": "      it('`requiresTypeChecking` should be set if the rule uses type information', () => {\n        // quick-and-dirty check to see if it uses parserServices\n        // not perfect but should be good enough\n        const ruleFileContents = fs.readFileSync(\n          path.resolve(__dirname, `../src/rules/${ruleName}.ts`),\n          'utf-8',\n        );\n\n        expect(requiresFullTypeInformation(ruleFileContents)).toEqual(\n          rule.meta.docs?.requiresTypeChecking ?? false,\n        );\n      });",
            "file": "docs.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "All non-deprecated base rules should have a row in the base rules table, and the table should be ordered alphabetically",
            "suites": [
                "Validating README.md"
            ],
            "updatePoint": {
                "line": 152,
                "column": 125
            },
            "line": 152,
            "code": "  it('All non-deprecated base rules should have a row in the base rules table, and the table should be ordered alphabetically', () => {\n    const baseRuleNames = baseRules\n      .map(([ruleName]) => ruleName)\n      .sort()\n      .map(createRuleLink);\n\n    expect(rulesTables.base.rows.map(row => row[0].text)).toStrictEqual(\n      baseRuleNames,\n    );\n  });",
            "file": "docs.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "All non-deprecated extension rules should have a row in the base rules table, and the table should be ordered alphabetically",
            "suites": [
                "Validating README.md"
            ],
            "updatePoint": {
                "line": 162,
                "column": 130
            },
            "line": 162,
            "code": "  it('All non-deprecated extension rules should have a row in the base rules table, and the table should be ordered alphabetically', () => {\n    const extensionRuleNames = extensionRules\n      .map(([ruleName]) => ruleName)\n      .sort()\n      .map(createRuleLink);\n\n    expect(rulesTables.extension.rows.map(row => row[0].text)).toStrictEqual(\n      extensionRuleNames,\n    );\n  });",
            "file": "docs.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "Link column should be correct",
            "suites": [
                "Validating README.md",
                "Checking rule "
            ],
            "updatePoint": {
                "line": 188,
                "column": 39
            },
            "line": 188,
            "code": "      it('Link column should be correct', () => {\n        expect(ruleRow[0]).toBe(createRuleLink(ruleName));\n      });",
            "file": "docs.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "Description column should be correct",
            "suites": [
                "Validating README.md",
                "Checking rule "
            ],
            "updatePoint": {
                "line": 192,
                "column": 46
            },
            "line": 192,
            "code": "      it('Description column should be correct', () => {\n        expect(ruleRow[1]).toBe(rule.meta.docs?.description);\n      });",
            "file": "docs.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "Recommended column should be correct",
            "suites": [
                "Validating README.md",
                "Checking rule "
            ],
            "updatePoint": {
                "line": 196,
                "column": 46
            },
            "line": 196,
            "code": "      it('Recommended column should be correct', () => {\n        expect(ruleRow[2]).toBe(\n          rule.meta.docs?.recommended ? ':white_check_mark:' : '',\n        );\n      });",
            "file": "docs.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "Fixable column should be correct",
            "suites": [
                "Validating README.md",
                "Checking rule "
            ],
            "updatePoint": {
                "line": 202,
                "column": 42
            },
            "line": 202,
            "code": "      it('Fixable column should be correct', () => {\n        expect(ruleRow[3]).toBe(\n          rule.meta.fixable !== undefined ? ':wrench:' : '',\n        );\n      });",
            "file": "docs.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "Requiring type information column should be correct",
            "suites": [
                "Validating README.md",
                "Checking rule "
            ],
            "updatePoint": {
                "line": 208,
                "column": 61
            },
            "line": 208,
            "code": "      it('Requiring type information column should be correct', () => {\n        expect(ruleRow[4]).toBe(\n          rule.meta.docs?.requiresTypeChecking === true\n            ? ':thought_balloon:'\n            : '',\n        );\n      });",
            "file": "docs.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "exports all available rules",
            "suites": [
                "eslint-plugin (\"./src/index.ts\")"
            ],
            "updatePoint": {
                "line": 17,
                "column": 33
            },
            "line": 17,
            "code": "  it('exports all available rules', () => {\n    expect(ruleKeys).toEqual(expect.arrayContaining(eslintPluginRuleKeys));\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "exports all available configs",
            "suites": [
                "eslint-plugin (\"./src/index.ts\")"
            ],
            "updatePoint": {
                "line": 21,
                "column": 35
            },
            "line": 21,
            "code": "  it('exports all available configs', () => {\n    expect(configs).toEqual(expect.arrayContaining(eslintPluginConfigKeys));\n  });",
            "file": "index.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "imports all available rule modules",
            "suites": [
                "./src/rules/index.ts"
            ],
            "updatePoint": {
                "line": 11,
                "column": 40
            },
            "line": 11,
            "code": "  it('imports all available rule modules', () => {\n    expect(ruleNames).toEqual(expect.arrayContaining(files));\n  });",
            "file": "rules/index.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "returns false for non-definition files",
            "suites": [
                "isDefinitionFile"
            ],
            "updatePoint": {
                "line": 4,
                "column": 44
            },
            "line": 4,
            "code": "  it('returns false for non-definition files', () => {\n    const invalid = [\n      'test.js',\n      'test.jsx',\n      'README.md',\n      'test.d.js',\n      'test.ts.js',\n      'test.ts.map',\n      'test.ts-js',\n      'test.ts',\n      'ts',\n      'test.tsx',\n      'test.TS',\n      'test.TSX',\n    ];\n\n    invalid.forEach(f => {\n      expect(util.isDefinitionFile(f)).toBe(false);\n    });\n  });",
            "file": "util.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "returns true for definition files",
            "suites": [
                "isDefinitionFile"
            ],
            "updatePoint": {
                "line": 25,
                "column": 39
            },
            "line": 25,
            "code": "  it('returns true for definition files', () => {\n    const valid = ['test.d.ts', 'test.d.tsx', 'test.D.TS', 'test.D.TSX'];\n\n    valid.forEach(f => {\n      expect(util.isDefinitionFile(f)).toBe(true);\n    });\n  });",
            "file": "util.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "upper cases first",
            "suites": [
                "upperCaseFirst"
            ],
            "updatePoint": {
                "line": 35,
                "column": 23
            },
            "line": 35,
            "code": "  it('upper cases first', () => {\n    expect(util.upperCaseFirst('hello')).toBe('Hello');\n  });",
            "file": "util.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "can format with no words",
            "suites": [
                "formatWordList"
            ],
            "updatePoint": {
                "line": 4,
                "column": 30
            },
            "line": 4,
            "code": "  it('can format with no words', () => {\n    expect(misc.formatWordList([])).toBe('');\n  });",
            "file": "util/misc.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "can format with 1 word",
            "suites": [
                "formatWordList"
            ],
            "updatePoint": {
                "line": 8,
                "column": 28
            },
            "line": 8,
            "code": "  it('can format with 1 word', () => {\n    expect(misc.formatWordList(['foo'])).toBe('foo');\n  });",
            "file": "util/misc.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "can format with 2 words",
            "suites": [
                "formatWordList"
            ],
            "updatePoint": {
                "line": 12,
                "column": 29
            },
            "line": 12,
            "code": "  it('can format with 2 words', () => {\n    expect(misc.formatWordList(['foo', 'bar'])).toBe('foo and bar');\n  });",
            "file": "util/misc.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "can format with 3 words",
            "suites": [
                "formatWordList"
            ],
            "updatePoint": {
                "line": 16,
                "column": 29
            },
            "line": 16,
            "code": "  it('can format with 3 words', () => {\n    expect(misc.formatWordList(['foo', 'bar', 'baz'])).toBe('foo, bar and baz');\n  });",
            "file": "util/misc.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "can format with 4 words",
            "suites": [
                "formatWordList"
            ],
            "updatePoint": {
                "line": 20,
                "column": 29
            },
            "line": 20,
            "code": "  it('can format with 4 words', () => {\n    expect(misc.formatWordList(['foo', 'bar', 'baz', 'boz'])).toBe(\n      'foo, bar, baz and boz',\n    );\n  });",
            "file": "util/misc.test.ts",
            "skipped": false,
            "dir": "packages/eslint-plugin/tests"
        },
        {
            "name": "returns a clone of the default if no options given",
            "suites": [
                "applyDefault"
            ],
            "updatePoint": {
                "line": 3,
                "column": 56
            },
            "line": 3,
            "code": "  it('returns a clone of the default if no options given', () => {\n    const defaults = [{\n      prop: 'setting'\n    }];\n    const user = null;\n    const result = ESLintUtils.applyDefault(defaults, user);\n    expect(result).toStrictEqual(defaults);\n    expect(result).not.toBe(defaults);\n  });",
            "file": "eslint-utils/applyDefault.test.ts",
            "skipped": false,
            "dir": "packages/experimental-utils/tests"
        },
        {
            "name": "returns applies a deepMerge to each element in the array",
            "suites": [
                "applyDefault"
            ],
            "updatePoint": {
                "line": 12,
                "column": 62
            },
            "line": 12,
            "code": "  it('returns applies a deepMerge to each element in the array', () => {\n    const defaults = [{\n      prop: 'setting1',\n      other: 'other'\n    }, {\n      prop: 'setting2'\n    }];\n    const user = [{\n      prop: 'new',\n      other: 'something'\n    }];\n    const result = ESLintUtils.applyDefault(defaults, user);\n    expect(result).toStrictEqual([{\n      prop: 'new',\n      other: 'something'\n    }, {\n      prop: 'setting2'\n    }]);\n    expect(result).not.toBe(defaults);\n    expect(result).not.toBe(user);\n  });",
            "file": "eslint-utils/applyDefault.test.ts",
            "skipped": false,
            "dir": "packages/experimental-utils/tests"
        },
        {
            "name": "returns a brand new array",
            "suites": [
                "applyDefault"
            ],
            "updatePoint": {
                "line": 33,
                "column": 31
            },
            "line": 33,
            "code": "  it('returns a brand new array', () => {\n    const defaults = [];\n    const user = [];\n    const result = ESLintUtils.applyDefault(defaults, user);\n    expect(result).not.toBe(defaults);\n    expect(result).not.toBe(user);\n  });",
            "file": "eslint-utils/applyDefault.test.ts",
            "skipped": false,
            "dir": "packages/experimental-utils/tests"
        },
        {
            "name": "should work with array of options",
            "suites": [
                "applyDefault"
            ],
            "updatePoint": {
                "line": 40,
                "column": 39
            },
            "line": 40,
            "code": "  it('should work with array of options', () => {\n    const defaults = ['1tbs'];\n    const user = ['2tbs'];\n    const result = ESLintUtils.applyDefault(defaults, user);\n    expect(result).toStrictEqual(['2tbs']);\n    expect(result).not.toBe(defaults);\n    expect(result).not.toBe(user);\n  });",
            "file": "eslint-utils/applyDefault.test.ts",
            "skipped": false,
            "dir": "packages/experimental-utils/tests"
        },
        {
            "name": "should work without options",
            "suites": [
                "batchedSingleLineTests"
            ],
            "updatePoint": {
                "line": 21,
                "column": 33
            },
            "line": 21,
            "code": "  it('should work without options', () => {\n    expect(ESLintUtils.batchedSingleLineTests({\n      code: FIXTURES\n    })).toEqual([{\n      code: 'a',\n      errors: []\n    }, {\n      code: 'b',\n      errors: []\n    }, {\n      code: 'c',\n      errors: []\n    }]);\n  });",
            "file": "eslint-utils/batchedSingleLineTests.test.ts",
            "skipped": false,
            "dir": "packages/experimental-utils/tests"
        },
        {
            "name": "should work with errors",
            "suites": [
                "batchedSingleLineTests"
            ],
            "updatePoint": {
                "line": 35,
                "column": 29
            },
            "line": 35,
            "code": "  it('should work with errors', () => {\n    expect(ESLintUtils.batchedSingleLineTests({\n      code: FIXTURES,\n      errors\n    })).toEqual([{\n      code: 'a',\n      errors: [{\n        messageId: 'someMessage1',\n        line: 1\n      }]\n    }, {\n      code: 'b',\n      errors: [{\n        messageId: 'someMessage2',\n        line: 1\n      }]\n    }, {\n      code: 'c',\n      errors: [{\n        messageId: 'someMessage3',\n        line: 1\n      }]\n    }]);\n  });",
            "file": "eslint-utils/batchedSingleLineTests.test.ts",
            "skipped": false,
            "dir": "packages/experimental-utils/tests"
        },
        {
            "name": "should work with all fields",
            "suites": [
                "batchedSingleLineTests"
            ],
            "updatePoint": {
                "line": 59,
                "column": 33
            },
            "line": 59,
            "code": "  it('should work with all fields', () => {\n    const filename = 'foo.ts';\n    const parser = 'some-parser';\n    expect(ESLintUtils.batchedSingleLineTests({\n      code: FIXTURES,\n      errors,\n      options,\n      parser,\n      output: FIXTURES,\n      filename\n    })).toEqual([{\n      code: 'a',\n      output: 'a',\n      errors: [{\n        messageId: 'someMessage1',\n        line: 1\n      }],\n      parser,\n      filename,\n      options\n    }, {\n      code: 'b',\n      output: 'b',\n      errors: [{\n        messageId: 'someMessage2',\n        line: 1\n      }],\n      parser,\n      filename,\n      options\n    }, {\n      code: 'c',\n      output: 'c',\n      errors: [{\n        messageId: 'someMessage3',\n        line: 1\n      }],\n      parser,\n      filename,\n      options\n    }]);\n  });",
            "file": "eslint-utils/batchedSingleLineTests.test.ts",
            "skipped": false,
            "dir": "packages/experimental-utils/tests"
        },
        {
            "name": "creates a brand new object",
            "suites": [
                "deepMerge"
            ],
            "updatePoint": {
                "line": 3,
                "column": 32
            },
            "line": 3,
            "code": "  it('creates a brand new object', () => {\n    const a = {};\n    const b = {};\n    const result = ESLintUtils.deepMerge(a, b);\n    expect(result).not.toBe(a);\n    expect(result).not.toBe(b);\n  });",
            "file": "eslint-utils/deepMerge.test.ts",
            "skipped": false,
            "dir": "packages/experimental-utils/tests"
        },
        {
            "name": "deeply merges objects",
            "suites": [
                "deepMerge"
            ],
            "updatePoint": {
                "line": 10,
                "column": 27
            },
            "line": 10,
            "code": "  it('deeply merges objects', () => {\n    const a = {\n      stringA1: 'asdf',\n      numberA1: 1,\n      boolA1: true,\n      arrayA1: [1, 2, 3],\n      objA1: {\n        stringA2: 'fsda',\n        numberA2: 2,\n        boolA2: false,\n        arrayA2: [3, 2, 1],\n        objA2: {}\n      }\n    };\n    const b = {\n      stringB1: 'asdf',\n      numberB1: 1,\n      boolB1: true,\n      arrayB1: [1, 2, 3],\n      objB1: {\n        stringB2: 'fsda',\n        numberB2: 2,\n        boolB2: false,\n        arrayB2: [3, 2, 1],\n        objB2: {}\n      }\n    };\n    expect(ESLintUtils.deepMerge(a, b)).toStrictEqual(Object.assign({}, a, b));\n  });",
            "file": "eslint-utils/deepMerge.test.ts",
            "skipped": false,
            "dir": "packages/experimental-utils/tests"
        },
        {
            "name": "deeply overwrites properties in the first one with the second",
            "suites": [
                "deepMerge"
            ],
            "updatePoint": {
                "line": 39,
                "column": 67
            },
            "line": 39,
            "code": "  it('deeply overwrites properties in the first one with the second', () => {\n    const a = {\n      prop1: {\n        prop2: 'hi'\n      }\n    };\n    const b = {\n      prop1: {\n        prop2: 'bye'\n      }\n    };\n    expect(ESLintUtils.deepMerge(a, b)).toStrictEqual(b);\n  });",
            "file": "eslint-utils/deepMerge.test.ts",
            "skipped": false,
            "dir": "packages/experimental-utils/tests"
        },
        {
            "name": "createRule should be a function",
            "suites": [
                "RuleCreator"
            ],
            "updatePoint": {
                "line": 4,
                "column": 37
            },
            "line": 4,
            "code": "  it('createRule should be a function', () => {\n    expect(typeof createRule).toBe('function');\n  });",
            "file": "eslint-utils/RuleCreator.test.ts",
            "skipped": false,
            "dir": "packages/experimental-utils/tests"
        },
        {
            "name": "should create rule correctly",
            "suites": [
                "RuleCreator"
            ],
            "updatePoint": {
                "line": 7,
                "column": 34
            },
            "line": 7,
            "code": "  it('should create rule correctly', () => {\n    const rule = createRule({\n      name: 'test',\n      meta: {\n        docs: {\n          description: 'some description',\n          recommended: 'error',\n          requiresTypeChecking: true\n        },\n        messages: {\n          foo: 'some message'\n        },\n        schema: [],\n        type: 'problem'\n      },\n      defaultOptions: [],\n\n      create() {\n        return {};\n      }\n\n    });\n    expect(rule.meta).toEqual({\n      docs: {\n        description: 'some description',\n        url: 'test/test',\n        recommended: 'error',\n        requiresTypeChecking: true\n      },\n      messages: {\n        foo: 'some message'\n      },\n      schema: [],\n      type: 'problem'\n    });\n  });",
            "file": "eslint-utils/RuleCreator.test.ts",
            "skipped": false,
            "dir": "packages/experimental-utils/tests"
        },
        {
            "name": " services",
            "suites": [
                "services"
            ],
            "updatePoint": {
                "line": 33,
                "column": 32
            },
            "line": 33,
            "code": "    it(`${snapshotName} services`, () => {\n      testServices(code, config);\n    });",
            "file": "lib/services.ts",
            "skipped": false,
            "dir": "packages/parser/tests"
        },
        {
            "name": " services with provided program",
            "suites": [
                "services"
            ],
            "updatePoint": {
                "line": 36,
                "column": 54
            },
            "line": 36,
            "code": "    it(`${snapshotName} services with provided program`, () => {\n      testServices(code, { ...config,\n        program\n      });\n    });",
            "file": "lib/services.ts",
            "skipped": false,
            "dir": "packages/parser/tests"
        },
        {
            "name": "filePath was not provided",
            "suites": [
                "TSX",
                "if the filename ends with '.tsx', enable jsx option automatically."
            ],
            "updatePoint": {
                "line": 18,
                "column": 33
            },
            "line": 18,
            "code": "    it('filePath was not provided', () => {\n      const code = 'const element = <T/>';\n      expect(parseWithError(code)).toMatchInlineSnapshot(`\n        TSError {\n          \"column\": 18,\n          \"index\": 18,\n          \"lineNumber\": 1,\n          \"message\": \"'>' expected.\",\n        }\n      `);\n    });",
            "file": "lib/tsx.ts",
            "skipped": false,
            "dir": "packages/parser/tests"
        },
        {
            "name": "filePath was not provided and 'jsx:true' option",
            "suites": [
                "TSX",
                "if the filename ends with '.tsx', enable jsx option automatically."
            ],
            "updatePoint": {
                "line": 29,
                "column": 55
            },
            "line": 29,
            "code": "    it(\"filePath was not provided and 'jsx:true' option\", () => {\n      const code = 'const element = <T/>';\n      expect(() => parseForESLint(code, {\n        ecmaFeatures: {\n          jsx: true\n        }\n      })).not.toThrow();\n    });",
            "file": "lib/tsx.ts",
            "skipped": false,
            "dir": "packages/parser/tests"
        },
        {
            "name": "test.ts",
            "suites": [
                "TSX",
                "if the filename ends with '.tsx', enable jsx option automatically."
            ],
            "updatePoint": {
                "line": 37,
                "column": 15
            },
            "line": 37,
            "code": "    it('test.ts', () => {\n      const code = 'const element = <T/>';\n      expect(parseWithError(code, {\n        filePath: 'test.ts'\n      })).toMatchInlineSnapshot(`\n        TSError {\n          \"column\": 18,\n          \"index\": 18,\n          \"lineNumber\": 1,\n          \"message\": \"'>' expected.\",\n        }\n      `);\n    });",
            "file": "lib/tsx.ts",
            "skipped": false,
            "dir": "packages/parser/tests"
        },
        {
            "name": "test.ts with 'jsx:true' option",
            "suites": [
                "TSX",
                "if the filename ends with '.tsx', enable jsx option automatically."
            ],
            "updatePoint": {
                "line": 50,
                "column": 38
            },
            "line": 50,
            "code": "    it(\"test.ts with 'jsx:true' option\", () => {\n      const code = 'const element = <T/>';\n      expect(parseWithError(code, {\n        filePath: 'test.ts',\n        ecmaFeatures: {\n          jsx: true\n        }\n      })).toMatchInlineSnapshot(`\n        TSError {\n          \"column\": 18,\n          \"index\": 18,\n          \"lineNumber\": 1,\n          \"message\": \"'>' expected.\",\n        }\n      `);\n    });",
            "file": "lib/tsx.ts",
            "skipped": false,
            "dir": "packages/parser/tests"
        },
        {
            "name": "test.tsx",
            "suites": [
                "TSX",
                "if the filename ends with '.tsx', enable jsx option automatically."
            ],
            "updatePoint": {
                "line": 66,
                "column": 16
            },
            "line": 66,
            "code": "    it('test.tsx', () => {\n      const code = 'const element = <T/>';\n      expect(() => parseForESLint(code, {\n        filePath: 'test.tsx'\n      })).not.toThrow();\n    });",
            "file": "lib/tsx.ts",
            "skipped": false,
            "dir": "packages/parser/tests"
        },
        {
            "name": "test.tsx with 'jsx:false' option",
            "suites": [
                "TSX",
                "if the filename ends with '.tsx', enable jsx option automatically."
            ],
            "updatePoint": {
                "line": 72,
                "column": 40
            },
            "line": 72,
            "code": "    it(\"test.tsx with 'jsx:false' option\", () => {\n      const code = 'const element = <T/>';\n      expect(() => parseForESLint(code, {\n        ecmaFeatures: {\n          jsx: false\n        },\n        filePath: 'test.tsx'\n      })).not.toThrow();\n    });",
            "file": "lib/tsx.ts",
            "skipped": false,
            "dir": "packages/parser/tests"
        }
    ],
    "error": "Exclusive tests detected. `.only` call found in fixtures.test.ts:165\nRemove `.only` to restore test checks"
}