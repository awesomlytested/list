{"repo":"javascript-obfuscator/javascript-obfuscator","url":"https://github.com/javascript-obfuscator/javascript-obfuscator","branch":"master","configs":[{"package":"javascript-obfuscator","lang":"ts","dir":"test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should return correct calls graph data","suites":["CallsGraphAnalyzer","extract","Variant #1: basic-1"],"updatePoint":{"line":210,"column":54},"line":210,"code":"            it('should return correct calls graph data', () => {\n                assert.deepEqual(callsGraphData, expectedCallsGraphData);\n            });","file":"functional-tests/analyzers/calls-graph-analyzer/CallsGraphAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct calls graph data","suites":["CallsGraphAnalyzer","extract","Variant #2: basic-2"],"updatePoint":{"line":249,"column":54},"line":249,"code":"            it('should return correct calls graph data', () => {\n                assert.deepEqual(callsGraphData, expectedCallsGraphData);\n            });","file":"functional-tests/analyzers/calls-graph-analyzer/CallsGraphAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct calls graph data","suites":["CallsGraphAnalyzer","extract","Variant #3: deep conditions nesting"],"updatePoint":{"line":288,"column":54},"line":288,"code":"            it('should return correct calls graph data', () => {\n                assert.deepEqual(callsGraphData, expectedCallsGraphData);\n            });","file":"functional-tests/analyzers/calls-graph-analyzer/CallsGraphAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct calls graph data","suites":["CallsGraphAnalyzer","extract","Variant #4: call before declaration"],"updatePoint":{"line":311,"column":54},"line":311,"code":"            it('should return correct calls graph data', () => {\n                assert.deepEqual(callsGraphData, expectedCallsGraphData);\n            });","file":"functional-tests/analyzers/calls-graph-analyzer/CallsGraphAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct calls graph data","suites":["CallsGraphAnalyzer","extract","Variant #5: call expression of object member #1"],"updatePoint":{"line":370,"column":54},"line":370,"code":"            it('should return correct calls graph data', () => {\n                assert.deepEqual(callsGraphData, expectedCallsGraphData);\n            });","file":"functional-tests/analyzers/calls-graph-analyzer/CallsGraphAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct calls graph data","suites":["CallsGraphAnalyzer","extract","Variant #5: call expression of object member #2"],"updatePoint":{"line":398,"column":54},"line":398,"code":"            it('should return correct calls graph data', () => {\n                assert.deepEqual(callsGraphData, expectedCallsGraphData);\n            });","file":"functional-tests/analyzers/calls-graph-analyzer/CallsGraphAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct calls graph data","suites":["CallsGraphAnalyzer","extract","Variant #6: no call expressions"],"updatePoint":{"line":415,"column":54},"line":415,"code":"            it('should return correct calls graph data', () => {\n                assert.deepEqual(callsGraphData, expectedCallsGraphData);\n            });","file":"functional-tests/analyzers/calls-graph-analyzer/CallsGraphAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct calls graph data","suites":["CallsGraphAnalyzer","extract","Variant #7: only call expression"],"updatePoint":{"line":432,"column":54},"line":432,"code":"            it('should return correct calls graph data', () => {\n                assert.deepEqual(callsGraphData, expectedCallsGraphData);\n            });","file":"functional-tests/analyzers/calls-graph-analyzer/CallsGraphAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct calls graph data","suites":["CallsGraphAnalyzer","extract","Variant #8: self-invoking functions"],"updatePoint":{"line":467,"column":54},"line":467,"code":"            it('should return correct calls graph data', () => {\n                assert.deepEqual(callsGraphData, expectedCallsGraphData);\n            });","file":"functional-tests/analyzers/calls-graph-analyzer/CallsGraphAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct calls graph data","suites":["CallsGraphAnalyzer","extract","Variant #9: no recursion"],"updatePoint":{"line":490,"column":54},"line":490,"code":"            it('should return correct calls graph data', () => {\n                assert.deepEqual(callsGraphData, expectedCallsGraphData);\n            });","file":"functional-tests/analyzers/calls-graph-analyzer/CallsGraphAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should attach missing ranges based on the parent node and rename identifiers without errors","suites":["ScopeAnalyzer","analyze","Variant #1: should attach a valid missing ranges"],"updatePoint":{"line":45,"column":107},"line":45,"code":"            it('should attach missing ranges based on the parent node and rename identifiers without errors', () => {\n                assert.equal(error, null);\n            });","file":"functional-tests/analyzers/scope-analyzer/ScopeAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should create file with obfuscated code in `--output` directory","suites":["JavaScriptObfuscatorCLI","run","Variant #1: obfuscation of single file","--output` option is set","Variant #1: input file path is before options"],"updatePoint":{"line":59,"column":87},"line":59,"code":"                    it('should create file with obfuscated code in `--output` directory', () => {\n                        assert.equal(isFileExist, true);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create file with obfuscated code in `--output` directory","suites":["JavaScriptObfuscatorCLI","run","Variant #1: obfuscation of single file","--output` option is set","Variant #2: input file path is after options"],"updatePoint":{"line":87,"column":87},"line":87,"code":"                    it('should create file with obfuscated code in `--output` directory', () => {\n                        assert.equal(isFileExist, true);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create file \\`\\` with obfuscated code in \\`\\` directory","suites":["JavaScriptObfuscatorCLI","run","Variant #1: obfuscation of single file","`--output` option isn't set","Variant #1: default behaviour"],"updatePoint":{"line":114,"column":121},"line":114,"code":"                    it(`should create file \\`${outputFileName}\\` with obfuscated code in \\`${fixturesDirName}\\` directory`, () => {\n                        assert.equal(isFileExist, true);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error","suites":["JavaScriptObfuscatorCLI","run","Variant #1: obfuscation of single file","`--output` option isn't set","Variant #2: invalid input file path"],"updatePoint":{"line":134,"column":45},"line":134,"code":"                    it(`should throw an error`, () => {\n                        assert.throws(testFunc, expectedError);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error","suites":["JavaScriptObfuscatorCLI","run","Variant #1: obfuscation of single file","`--output` option isn't set","Variant #3: input file extension isn't `.js`"],"updatePoint":{"line":156,"column":45},"line":156,"code":"                    it(`should throw an error`, () => {\n                        assert.throws(testFunc, expectedError);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create file with obfuscated code in `--output` directory","suites":["JavaScriptObfuscatorCLI","run","Variant #1: obfuscation of single file","--exclude option","Variant #1: --exclude option is pointed on different file"],"updatePoint":{"line":184,"column":87},"line":184,"code":"                    it('should create file with obfuscated code in `--output` directory', () => {\n                        assert.equal(isFileExist, true);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error","suites":["JavaScriptObfuscatorCLI","run","Variant #1: obfuscation of single file","--exclude option","Variant #2: --exclude option is pointed on input file"],"updatePoint":{"line":204,"column":45},"line":204,"code":"                    it('should throw an error', () => {\n                        assert.throws(testFunc, expectedError);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create file \\`\\` with obfuscated code in \\`\\` directory","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #1: default behaviour"],"updatePoint":{"line":255,"column":118},"line":255,"code":"                it(`should create file \\`${outputFileName1}\\` with obfuscated code in \\`${fixturesDirName}\\` directory`, () => {\n                    assert.equal(isFileExist1, true);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create file \\`\\` with obfuscated code in \\`\\` directory","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #1: default behaviour"],"updatePoint":{"line":259,"column":118},"line":259,"code":"                it(`should create file \\`${outputFileName2}\\` with obfuscated code in \\`${fixturesDirName}\\` directory`, () => {\n                    assert.equal(isFileExist2, true);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't create file \\`\\` in \\`\\` directory","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #1: default behaviour"],"updatePoint":{"line":263,"column":100},"line":263,"code":"                it(`shouldn't create file \\`${outputFileName3}\\` in \\`${fixturesDirName}\\` directory`, () => {\n                    assert.equal(isFileExist3, false);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should create file with obfuscated code with prefixed identifier","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #1: default behaviour"],"updatePoint":{"line":267,"column":94},"line":267,"code":"                it(`match #1: should create file with obfuscated code with prefixed identifier`, () => {\n                    assert.match(fileContent1, regExp1);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should create file with obfuscated code with prefixed identifier","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #1: default behaviour"],"updatePoint":{"line":271,"column":94},"line":271,"code":"                it(`match #2: should create file with obfuscated code with prefixed identifier`, () => {\n                    assert.match(fileContent2, regExp2);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create file \\`\\` with obfuscated code in \\`\\` directory","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #2: obfuscation of directory with `identifiersPrefix` option value"],"updatePoint":{"line":318,"column":118},"line":318,"code":"                it(`should create file \\`${outputFileName1}\\` with obfuscated code in \\`${fixturesDirName}\\` directory`, () => {\n                    assert.equal(isFileExist1, true);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create file \\`\\` with obfuscated code in \\`\\` directory","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #2: obfuscation of directory with `identifiersPrefix` option value"],"updatePoint":{"line":322,"column":118},"line":322,"code":"                it(`should create file \\`${outputFileName2}\\` with obfuscated code in \\`${fixturesDirName}\\` directory`, () => {\n                    assert.equal(isFileExist2, true);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should create file with obfuscated code with prefixed identifier","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #2: obfuscation of directory with `identifiersPrefix` option value"],"updatePoint":{"line":326,"column":94},"line":326,"code":"                it(`match #1: should create file with obfuscated code with prefixed identifier`, () => {\n                    assert.match(fileContent1, regExp1);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should create file with obfuscated code with prefixed identifier","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #2: obfuscation of directory with `identifiersPrefix` option value"],"updatePoint":{"line":330,"column":94},"line":330,"code":"                it(`match #2: should create file with obfuscated code with prefixed identifier`, () => {\n                    assert.match(fileContent2, regExp2);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create file \\`\\` with obfuscated code in \\`\\` directory","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #4: --exclude option","Variant #1: --exclude option is pointed on different file"],"updatePoint":{"line":444,"column":122},"line":444,"code":"                    it(`should create file \\`${outputFileName1}\\` with obfuscated code in \\`${fixturesDirName}\\` directory`, () => {\n                        assert.equal(isFileExist1, true);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create file \\`\\` with obfuscated code in \\`\\` directory","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #4: --exclude option","Variant #1: --exclude option is pointed on different file"],"updatePoint":{"line":448,"column":122},"line":448,"code":"                    it(`should create file \\`${outputFileName2}\\` with obfuscated code in \\`${fixturesDirName}\\` directory`, () => {\n                        assert.equal(isFileExist2, true);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't create file \\`\\` in \\`\\` directory","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #4: --exclude option","Variant #1: --exclude option is pointed on different file"],"updatePoint":{"line":452,"column":104},"line":452,"code":"                    it(`shouldn't create file \\`${outputFileName3}\\` in \\`${fixturesDirName}\\` directory`, () => {\n                        assert.equal(isFileExist3, false);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should create file with obfuscated code with prefixed identifier","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #4: --exclude option","Variant #1: --exclude option is pointed on different file"],"updatePoint":{"line":456,"column":98},"line":456,"code":"                    it(`match #1: should create file with obfuscated code with prefixed identifier`, () => {\n                        assert.match(fileContent1, regExp1);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should create file with obfuscated code with prefixed identifier","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #4: --exclude option","Variant #1: --exclude option is pointed on different file"],"updatePoint":{"line":460,"column":98},"line":460,"code":"                    it(`match #2: should create file with obfuscated code with prefixed identifier`, () => {\n                        assert.match(fileContent2, regExp2);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't create file \\`\\` in \\`\\` directory","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #4: --exclude option","Variant #2: --exclude option is pointed on file under obfuscating directory"],"updatePoint":{"line":508,"column":104},"line":508,"code":"                    it(`shouldn't create file \\`${outputFileName1}\\` in \\`${fixturesDirName}\\` directory`, () => {\n                        assert.equal(isFileExist1, false);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create file \\`\\` with obfuscated code in \\`\\` directory","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #4: --exclude option","Variant #2: --exclude option is pointed on file under obfuscating directory"],"updatePoint":{"line":512,"column":122},"line":512,"code":"                    it(`should create file \\`${outputFileName2}\\` with obfuscated code in \\`${fixturesDirName}\\` directory`, () => {\n                        assert.equal(isFileExist2, true);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't create file \\`\\` in \\`\\` directory","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #4: --exclude option","Variant #2: --exclude option is pointed on file under obfuscating directory"],"updatePoint":{"line":516,"column":104},"line":516,"code":"                    it(`shouldn't create file \\`${outputFileName3}\\` in \\`${fixturesDirName}\\` directory`, () => {\n                        assert.equal(isFileExist3, false);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should create file with obfuscated code with prefixed identifier","suites":["JavaScriptObfuscatorCLI","run","Variant #2: obfuscation of directory","Variant #4: --exclude option","Variant #2: --exclude option is pointed on file under obfuscating directory"],"updatePoint":{"line":520,"column":98},"line":520,"code":"                    it(`match #1: should create file with obfuscated code with prefixed identifier`, () => {\n                        assert.match(fileContent1, regExp1);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create file with source map in the same directory as output file","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #1: default behaviour"],"updatePoint":{"line":575,"column":95},"line":575,"code":"                    it('should create file with source map in the same directory as output file', () => {\n                        assert.equal(isFileExist, true);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map from created file should contains property `version`","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #1: default behaviour"],"updatePoint":{"line":579,"column":87},"line":579,"code":"                    it('source map from created file should contains property `version`', () => {\n                        assert.property(sourceMapObject, 'version');\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map from created file should contains property `names`","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #1: default behaviour"],"updatePoint":{"line":583,"column":85},"line":583,"code":"                    it('source map from created file should contains property `names`', () => {\n                        assert.property(sourceMapObject, 'names');\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should resolve correct sources from source map","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #1: default behaviour"],"updatePoint":{"line":587,"column":70},"line":587,"code":"                    it('should resolve correct sources from source map', () => {\n                        assert.equal(resolvedSources, sourceCodeContent);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create file with source map in the same directory as output file","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #2: `sourceMapBaseUrl` option is set"],"updatePoint":{"line":638,"column":95},"line":638,"code":"                    it('should create file with source map in the same directory as output file', () => {\n                        assert.equal(isFileExist, true);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map from created file should contains property `version`","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #2: `sourceMapBaseUrl` option is set"],"updatePoint":{"line":642,"column":87},"line":642,"code":"                    it('source map from created file should contains property `version`', () => {\n                        assert.property(sourceMapObject, 'version');\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map from created file should contains property `names`","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #2: `sourceMapBaseUrl` option is set"],"updatePoint":{"line":646,"column":85},"line":646,"code":"                    it('source map from created file should contains property `names`', () => {\n                        assert.property(sourceMapObject, 'names');\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should resolve correct sources from source map","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #2: `sourceMapBaseUrl` option is set"],"updatePoint":{"line":650,"column":70},"line":650,"code":"                    it('should resolve correct sources from source map', () => {\n                        assert.equal(resolvedSources, sourceCodeContent);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create source map file with given name in the same directory as output file","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #3: `--sourceMapFileName` option is set"],"updatePoint":{"line":705,"column":106},"line":705,"code":"                    it('should create source map file with given name in the same directory as output file', () => {\n                        assert.equal(isFileExist, true);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map from created file should contains property `version`","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #3: `--sourceMapFileName` option is set"],"updatePoint":{"line":709,"column":87},"line":709,"code":"                    it('source map from created file should contains property `version`', () => {\n                        assert.property(sourceMapObject, 'version');\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map from created file should contains property `names`","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #3: `--sourceMapFileName` option is set"],"updatePoint":{"line":713,"column":85},"line":713,"code":"                    it('source map from created file should contains property `names`', () => {\n                        assert.property(sourceMapObject, 'names');\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should resolve correct sources from source map","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #3: `--sourceMapFileName` option is set"],"updatePoint":{"line":717,"column":70},"line":717,"code":"                    it('should resolve correct sources from source map', () => {\n                        assert.equal(resolvedSources, sourceCodeContent);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create file with source map in the same directory as output file","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #4: `sourceMapSourcesMode` option is set","Variant #1: `sourcesContent` value"],"updatePoint":{"line":771,"column":99},"line":771,"code":"                        it('should create file with source map in the same directory as output file', () => {\n                            assert.equal(isFileExist, true);\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map from created file should contains property `sources`","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #4: `sourceMapSourcesMode` option is set","Variant #1: `sourcesContent` value"],"updatePoint":{"line":775,"column":91},"line":775,"code":"                        it('source map from created file should contains property `sources`', () => {\n                            assert.property(sourceMapObject, 'sources');\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map from created file should contains property `sourcesContent`","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #4: `sourceMapSourcesMode` option is set","Variant #1: `sourcesContent` value"],"updatePoint":{"line":779,"column":98},"line":779,"code":"                        it('source map from created file should contains property `sourcesContent`', () => {\n                            assert.property(sourceMapObject, 'sourcesContent');\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map source should has correct sources","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #4: `sourceMapSourcesMode` option is set","Variant #1: `sourcesContent` value"],"updatePoint":{"line":783,"column":72},"line":783,"code":"                        it('source map source should has correct sources', () => {\n                            assert.equal(sourceMapObject.sources[0], expectedSourceMapSourceName);\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map source should has correct sources content","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #4: `sourceMapSourcesMode` option is set","Variant #1: `sourcesContent` value"],"updatePoint":{"line":787,"column":80},"line":787,"code":"                        it('source map source should has correct sources content', () => {\n                            assert.equal(sourceMapObject.sourcesContent[0], sourceCodeContent);\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should resolve correct sources from source map","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #4: `sourceMapSourcesMode` option is set","Variant #1: `sourcesContent` value"],"updatePoint":{"line":791,"column":74},"line":791,"code":"                        it('should resolve correct sources from source map', () => {\n                            assert.equal(resolvedSources, sourceCodeContent);\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create file with source map in the same directory as output file","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #4: `sourceMapSourcesMode` option is set","Variant #2: `sources` value"],"updatePoint":{"line":844,"column":99},"line":844,"code":"                        it('should create file with source map in the same directory as output file', () => {\n                            assert.equal(isFileExist, true);\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map from created file should contains property `sources`","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #4: `sourceMapSourcesMode` option is set","Variant #2: `sources` value"],"updatePoint":{"line":848,"column":91},"line":848,"code":"                        it('source map from created file should contains property `sources`', () => {\n                            assert.property(sourceMapObject, 'sources');\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map from created file should not contains property `sourcesContent`","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #4: `sourceMapSourcesMode` option is set","Variant #2: `sources` value"],"updatePoint":{"line":852,"column":102},"line":852,"code":"                        it('source map from created file should not contains property `sourcesContent`', () => {\n                            assert.notProperty(sourceMapObject, 'sourcesContent');\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map source should has correct sources","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #4: `sourceMapSourcesMode` option is set","Variant #2: `sources` value"],"updatePoint":{"line":856,"column":72},"line":856,"code":"                        it('source map source should has correct sources', () => {\n                            assert.equal(sourceMapObject.sources[0], expectedSourceMapSourceName);\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should resolve correct sources from source map","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #1: `--sourceMapMode` option value is `separate`","Variant #4: `sourceMapSourcesMode` option is set","Variant #2: `sources` value"],"updatePoint":{"line":860,"column":74},"line":860,"code":"                        it('should resolve correct sources from source map', () => {\n                            assert.equal(resolvedSources, sourceCodeContent);\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't create file with source map","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #2: `--sourceMapMode` option is `inline`","Variant #1: default behaviour"],"updatePoint":{"line":911,"column":62},"line":911,"code":"                    it('shouldn\\'t create file with source map', () => {\n                        assert.equal(isFileExist, false);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should resolve correct sources from source map","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #2: `--sourceMapMode` option is `inline`","Variant #1: default behaviour"],"updatePoint":{"line":915,"column":70},"line":915,"code":"                    it('should resolve correct sources from source map', () => {\n                        assert.equal(resolvedSources, sourceCodeContent);\n                    });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't create file with source map","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #2: `--sourceMapMode` option is `inline`","Variant #2: `sourceMapSourcesMode` option is set","Variant #1: `sourcesContent` value"],"updatePoint":{"line":966,"column":66},"line":966,"code":"                        it('shouldn\\'t create file with source map', () => {\n                            assert.equal(isFileExist, false);\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map from created file should contains property `sources`","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #2: `--sourceMapMode` option is `inline`","Variant #2: `sourceMapSourcesMode` option is set","Variant #1: `sourcesContent` value"],"updatePoint":{"line":970,"column":91},"line":970,"code":"                        it('source map from created file should contains property `sources`', () => {\n                            assert.property(sourceMapObject, 'sources');\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map from created file should contains property `sourcesContent`","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #2: `--sourceMapMode` option is `inline`","Variant #2: `sourceMapSourcesMode` option is set","Variant #1: `sourcesContent` value"],"updatePoint":{"line":974,"column":98},"line":974,"code":"                        it('source map from created file should contains property `sourcesContent`', () => {\n                            assert.property(sourceMapObject, 'sourcesContent');\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map source should has correct sources","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #2: `--sourceMapMode` option is `inline`","Variant #2: `sourceMapSourcesMode` option is set","Variant #1: `sourcesContent` value"],"updatePoint":{"line":978,"column":72},"line":978,"code":"                        it('source map source should has correct sources', () => {\n                            assert.equal(sourceMapObject.sources[0], expectedSourceMapSourceName);\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map source should has correct sources content","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #2: `--sourceMapMode` option is `inline`","Variant #2: `sourceMapSourcesMode` option is set","Variant #1: `sourcesContent` value"],"updatePoint":{"line":982,"column":80},"line":982,"code":"                        it('source map source should has correct sources content', () => {\n                            assert.equal(sourceMapObject.sourcesContent[0], sourceCodeContent);\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should resolve correct sources from source map","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #2: `--sourceMapMode` option is `inline`","Variant #2: `sourceMapSourcesMode` option is set","Variant #1: `sourcesContent` value"],"updatePoint":{"line":986,"column":74},"line":986,"code":"                        it('should resolve correct sources from source map', () => {\n                            assert.equal(resolvedSources, sourceCodeContent);\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't create file with source map","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #2: `--sourceMapMode` option is `inline`","Variant #2: `sourceMapSourcesMode` option is set","Variant #2: `sources` value"],"updatePoint":{"line":1036,"column":66},"line":1036,"code":"                        it('shouldn\\'t create file with source map', () => {\n                            assert.equal(isFileExist, false);\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map from created file should contains property `sources`","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #2: `--sourceMapMode` option is `inline`","Variant #2: `sourceMapSourcesMode` option is set","Variant #2: `sources` value"],"updatePoint":{"line":1040,"column":91},"line":1040,"code":"                        it('source map from created file should contains property `sources`', () => {\n                            assert.property(sourceMapObject, 'sources');\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map from created file should contains property `sourcesContent`","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #2: `--sourceMapMode` option is `inline`","Variant #2: `sourceMapSourcesMode` option is set","Variant #2: `sources` value"],"updatePoint":{"line":1044,"column":98},"line":1044,"code":"                        it('source map from created file should contains property `sourcesContent`', () => {\n                            assert.notProperty(sourceMapObject, 'sourcesContent');\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map source should has correct sources","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #2: `--sourceMapMode` option is `inline`","Variant #2: `sourceMapSourcesMode` option is set","Variant #2: `sources` value"],"updatePoint":{"line":1048,"column":72},"line":1048,"code":"                        it('source map source should has correct sources', () => {\n                            assert.equal(sourceMapObject.sources[0], expectedSourceMapSourceName);\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should resolve correct sources from source map","suites":["JavaScriptObfuscatorCLI","run","`--sourceMap` option is set","Variant #2: `--sourceMapMode` option is `inline`","Variant #2: `sourceMapSourcesMode` option is set","Variant #2: `sources` value"],"updatePoint":{"line":1052,"column":74},"line":1052,"code":"                        it('should resolve correct sources from source map', () => {\n                            assert.equal(resolvedSources, sourceCodeContent);\n                        });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should print `console.log` help","suites":["JavaScriptObfuscatorCLI","run","help output","`--help` option is set without any additional parameters"],"updatePoint":{"line":1091,"column":51},"line":1091,"code":"                it('should print `console.log` help', () => {\n                    assert.equal(isConsoleLogCalled, true);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should print `console.log` help","suites":["JavaScriptObfuscatorCLI","run","help output","`--help` option is set before file path"],"updatePoint":{"line":1113,"column":51},"line":1113,"code":"                it('should print `console.log` help', () => {\n                    assert.equal(isConsoleLogCalled, true);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should print `console.log` help","suites":["JavaScriptObfuscatorCLI","run","help output","`--help` option is set after file path"],"updatePoint":{"line":1135,"column":51},"line":1135,"code":"                it('should print `console.log` help', () => {\n                    assert.equal(isConsoleLogCalled, true);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should print `console.log` help","suites":["JavaScriptObfuscatorCLI","run","help output","no arguments passed"],"updatePoint":{"line":1155,"column":51},"line":1155,"code":"                it('should print `console.log` help', () => {\n                    assert.equal(isConsoleLogCalled, true);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create file with source map in the same directory as output file","suites":["JavaScriptObfuscatorCLI","run","`--config` option is set","Base options"],"updatePoint":{"line":1194,"column":91},"line":1194,"code":"                it('should create file with source map in the same directory as output file', () => {\n                    assert.equal(isFileExist, true);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map from created file should contains property `version`","suites":["JavaScriptObfuscatorCLI","run","`--config` option is set","Base options"],"updatePoint":{"line":1198,"column":83},"line":1198,"code":"                it('source map from created file should contains property `version`', () => {\n                    assert.property(sourceMapObject, 'version');\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map from created file should contains property `sources`","suites":["JavaScriptObfuscatorCLI","run","`--config` option is set","Base options"],"updatePoint":{"line":1202,"column":83},"line":1202,"code":"                it('source map from created file should contains property `sources`', () => {\n                    assert.property(sourceMapObject, 'sources');\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"source map from created file should contains property `names`","suites":["JavaScriptObfuscatorCLI","run","`--config` option is set","Base options"],"updatePoint":{"line":1206,"column":81},"line":1206,"code":"                it('source map from created file should contains property `names`', () => {\n                    assert.property(sourceMapObject, 'names');\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't create file \\`\\` in \\`\\` directory","suites":["JavaScriptObfuscatorCLI","run","`--config` option is set","`--exclude` option"],"updatePoint":{"line":1242,"column":100},"line":1242,"code":"                it(`shouldn't create file \\`${outputFileName1}\\` in \\`${fixturesDirName}\\` directory`, () => {\n                    assert.equal(isFileExist1, false);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create file \\`\\` with obfuscated code in \\`\\` directory","suites":["JavaScriptObfuscatorCLI","run","`--config` option is set","`--exclude` option"],"updatePoint":{"line":1246,"column":118},"line":1246,"code":"                it(`should create file \\`${outputFileName2}\\` with obfuscated code in \\`${fixturesDirName}\\` directory`, () => {\n                    assert.equal(isFileExist2, true);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should create file without source map in the same directory as output file","suites":["JavaScriptObfuscatorCLI","run","`--config` option is set but overridden by CLI option"],"updatePoint":{"line":1284,"column":90},"line":1284,"code":"            it('should create file without source map in the same directory as output file', () => {\n                assert.equal(isFileExist, false);\n            });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: should log file name to the console","suites":["JavaScriptObfuscatorCLI","run","Logging","Obfuscating file message"],"updatePoint":{"line":1329,"column":67},"line":1329,"code":"                it('Variant #1: should log file name to the console', () => {\n                    assert.include(loggingMessageResult1, expectedLoggingMessage1);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #2: should log file name to the console","suites":["JavaScriptObfuscatorCLI","run","Logging","Obfuscating file message"],"updatePoint":{"line":1333,"column":67},"line":1333,"code":"                it('Variant #2: should log file name to the console', () => {\n                    assert.include(loggingMessageResult2, expectedLoggingMessage2);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"Should log file name to the console","suites":["JavaScriptObfuscatorCLI","run","Logging","Error message"],"updatePoint":{"line":1371,"column":55},"line":1371,"code":"                it('Should log file name to the console', () => {\n                    assert.include(loggingMessageResult, expectedLoggingMessage1);\n                });","file":"functional-tests/cli/JavaScriptObfuscatorCLI.spec.ts","skipped":false,"dir":"test"},{"name":"should remove hashbang operator before ast transformation and append it after","suites":["HashbangOperatorTransformer","Variant #1: simple"],"updatePoint":{"line":32,"column":89},"line":32,"code":"        it('should remove hashbang operator before ast transformation and append it after', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/code-transformers/preparing-transformers/hashbang-operator-transformer/HashbangOperatorTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should remove hashbang operator before ast transformation and append it after","suites":["HashbangOperatorTransformer","Variant #2: multiple new lines"],"updatePoint":{"line":56,"column":89},"line":56,"code":"        it('should remove hashbang operator before ast transformation and append it after', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/code-transformers/preparing-transformers/hashbang-operator-transformer/HashbangOperatorTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should remove hashbang operator before ast transformation and append it after","suites":["HashbangOperatorTransformer","Variant #3: `stringArray` option enabled"],"updatePoint":{"line":82,"column":89},"line":82,"code":"        it('should remove hashbang operator before ast transformation and append it after', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/code-transformers/preparing-transformers/hashbang-operator-transformer/HashbangOperatorTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should remove invalid hashbang operator","suites":["HashbangOperatorTransformer","Variant #4: invalid hashbang indent"],"updatePoint":{"line":105,"column":51},"line":105,"code":"        it('should remove invalid hashbang operator', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/code-transformers/preparing-transformers/hashbang-operator-transformer/HashbangOperatorTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep hashbang operator as a string value","suites":["HashbangOperatorTransformer","Variant #5: hashbang as a string value"],"updatePoint":{"line":128,"column":59},"line":128,"code":"        it('should keep hashbang operator as a string value', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/code-transformers/preparing-transformers/hashbang-operator-transformer/HashbangOperatorTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly return global object","suites":["GlobalVariableNoEvalTemplate","Variant #1: simple"],"updatePoint":{"line":25,"column":49},"line":25,"code":"        it('should correctly return global object', () => {\n            assert.deepEqual(globalObject, expectedGlobalObject);\n        });","file":"functional-tests/custom-code-helpers/common/templates/GlobalVariableNoEvalTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly return global object","suites":["GlobalVariableNoEvalTemplate","Variant #2: call inside function"],"updatePoint":{"line":47,"column":49},"line":47,"code":"        it('should correctly return global object', () => {\n            assert.deepEqual(globalObject, expectedGlobalObject);\n        });","file":"functional-tests/custom-code-helpers/common/templates/GlobalVariableNoEvalTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly return `window` object","suites":["GlobalVariableNoEvalTemplate","Variant #3: return `window`"],"updatePoint":{"line":76,"column":51},"line":76,"code":"        it('should correctly return `window` object', () => {\n            assert.deepEqual(globalObject, expectedGlobalObject);\n        });","file":"functional-tests/custom-code-helpers/common/templates/GlobalVariableNoEvalTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should correctly append code helper into the obfuscated code","suites":["ConsoleOutputDisableExpressionCodeHelper","`disableConsoleOutput` option is set"],"updatePoint":{"line":27,"column":82},"line":27,"code":"        it('match #1: should correctly append code helper into the obfuscated code', () => {\n            assert.match(obfuscatedCode, consoleGetterRegExp);\n        });","file":"functional-tests/custom-code-helpers/console-output/ConsoleOutputDisableExpressionCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't append code helper into the obfuscated code","suites":["ConsoleOutputDisableExpressionCodeHelper","`disableConsoleOutput` option isn't set"],"updatePoint":{"line":47,"column":76},"line":47,"code":"        it('match #1: shouldn\\'t append code helper into the obfuscated code', () => {\n            assert.notMatch(obfuscatedCode, consoleGetterRegExp);\n        });","file":"functional-tests/custom-code-helpers/console-output/ConsoleOutputDisableExpressionCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"should replace \\`console.\\` call with an empty function","suites":["ConsoleOutputDisableTemplate","Base behaviour","Variant #: \\`console.\\` call"],"updatePoint":{"line":114,"column":95},"line":114,"code":"                it(`should replace \\`console.${consoleMethodName}\\` call with an empty function`, () => {\n                    assert.isNull(processStdoutWriteSpy.getCall(0));\n                });","file":"functional-tests/custom-code-helpers/console-output/templates/ConsoleOutputDisableTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should replace \\`console.\\` call with an empty function","suites":["ConsoleOutputDisableTemplate","Partial `console` object","Variant #: \\`console.\\` call"],"updatePoint":{"line":138,"column":95},"line":138,"code":"                it(`should replace \\`console.${consoleMethodName}\\` call with an empty function`, () => {\n                    assert.isNull(processStdoutWriteSpy.getCall(0));\n                });","file":"functional-tests/custom-code-helpers/console-output/templates/ConsoleOutputDisableTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should replace \\`console.\\` call with an empty function","suites":["ConsoleOutputDisableTemplate","Undefined `console` object","Variant #: \\`console.\\` call"],"updatePoint":{"line":162,"column":95},"line":162,"code":"                it(`should replace \\`console.${consoleMethodName}\\` call with an empty function`, () => {\n                    assert.isNull(processStdoutWriteSpy.getCall(0));\n                });","file":"functional-tests/custom-code-helpers/console-output/templates/ConsoleOutputDisableTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should not replace \\`console.\\` call with an empty function","suites":["ConsoleOutputDisableTemplate","Wrong global variable template","Variant #: \\`console.\\` call"],"updatePoint":{"line":186,"column":99},"line":186,"code":"                it(`should not replace \\`console.${consoleMethodName}\\` call with an empty function`, () => {\n                    assert.isNotNull(processStdoutWriteSpy.getCall(0));\n                });","file":"functional-tests/custom-code-helpers/console-output/templates/ConsoleOutputDisableTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should does not throw error during \\`console..bind\\` call","suites":["ConsoleOutputDisableTemplate","`bind` call","Variant #: \\`console.\\` call"],"updatePoint":{"line":211,"column":97},"line":211,"code":"                it(`should does not throw error during \\`console.${consoleMethodName}.bind\\` call`, () => {\n                    assert.doesNotThrow(testFunc);\n                });","file":"functional-tests/custom-code-helpers/console-output/templates/ConsoleOutputDisableTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate code with enabled debug protection","suites":["DebugProtectionFunctionCallTemplate","Variant #1: correctly obfuscate code with `HexadecimalIdentifierNamesGenerator``"],"updatePoint":{"line":47,"column":72},"line":47,"code":"        it('should correctly evaluate code with enabled debug protection', () => {\n            assert.equal(evaluationResult, expectedEvaluationResult);\n        });","file":"functional-tests/custom-code-helpers/debug-protection/templates/debug-protection-function-call-template/DebugProtectionFunctionCallTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate code with enabled debug protection","suites":["DebugProtectionFunctionCallTemplate","Variant #2: correctly obfuscate code with `MangledIdentifierNamesGenerator` option"],"updatePoint":{"line":80,"column":72},"line":80,"code":"        it('should correctly evaluate code with enabled debug protection', () => {\n            assert.equal(evaluationResult, expectedEvaluationResult);\n        });","file":"functional-tests/custom-code-helpers/debug-protection/templates/debug-protection-function-call-template/DebugProtectionFunctionCallTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate code with enabled debug protection","suites":["DebugProtectionFunctionCallTemplate","Variant #3: correctly obfuscate code with `DictionaryIdentifierNamesGenerator` option"],"updatePoint":{"line":114,"column":72},"line":114,"code":"        it('should correctly evaluate code with enabled debug protection', () => {\n            assert.equal(evaluationResult, expectedEvaluationResult);\n        });","file":"functional-tests/custom-code-helpers/debug-protection/templates/debug-protection-function-call-template/DebugProtectionFunctionCallTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate code with enabled debug protection","suites":["DebugProtectionFunctionCallTemplate","Variant #4: correctly obfuscated code with target `BrowserNoEval`"],"updatePoint":{"line":147,"column":72},"line":147,"code":"        it('should correctly evaluate code with enabled debug protection', () => {\n            assert.equal(evaluationResult, expectedEvaluationResult);\n        });","file":"functional-tests/custom-code-helpers/debug-protection/templates/debug-protection-function-call-template/DebugProtectionFunctionCallTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should enter code in infinity loop","suites":["DebugProtectionFunctionCallTemplate","Variant #5: obfuscated code with removed debug protection code"],"updatePoint":{"line":180,"column":46},"line":180,"code":"        it('should enter code in infinity loop', () => {\n            assert.equal(evaluationResult, expectedEvaluationResult);\n        });","file":"functional-tests/custom-code-helpers/debug-protection/templates/debug-protection-function-call-template/DebugProtectionFunctionCallTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate code with enabled debug protection","suites":["DebugProtectionFunctionCallTemplate","Variant #6: single call of debug protection code"],"updatePoint":{"line":212,"column":72},"line":212,"code":"        it('should correctly evaluate code with enabled debug protection', () => {\n            assert.equal(evaluationResult, expectedEvaluationResult);\n        });","file":"functional-tests/custom-code-helpers/debug-protection/templates/debug-protection-function-call-template/DebugProtectionFunctionCallTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should add debug protection interval code with default interval value","suites":["DebugProtectionFunctionIntervalTemplate","Variant #1 - `high-obfuscation` preset interval"],"updatePoint":{"line":37,"column":81},"line":37,"code":"        it('Should add debug protection interval code with default interval value', () => {\n            assert.match(obfuscatedCode, debugProtectionIntervalRegExp);\n        });","file":"functional-tests/custom-code-helpers/debug-protection/templates/debug-protection-function-interval-template/DebugProtectionFunctionIntervalTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should add debug protection interval code with default interval value","suites":["DebugProtectionFunctionIntervalTemplate","Variant #2 - custom interval"],"updatePoint":{"line":64,"column":81},"line":64,"code":"        it('Should add debug protection interval code with default interval value', () => {\n            assert.match(obfuscatedCode, debugProtectionIntervalRegExp);\n        });","file":"functional-tests/custom-code-helpers/debug-protection/templates/debug-protection-function-interval-template/DebugProtectionFunctionIntervalTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should not add debug protection interval code","suites":["DebugProtectionFunctionIntervalTemplate","Variant #3 - no interval"],"updatePoint":{"line":86,"column":57},"line":86,"code":"        it('Should not add debug protection interval code', () => {\n            assert.notMatch(obfuscatedCode, debugProtectionIntervalRegExp);\n        });","file":"functional-tests/custom-code-helpers/debug-protection/templates/debug-protection-function-interval-template/DebugProtectionFunctionIntervalTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly append code helper into the obfuscated code","suites":["DomainLockCodeHelper","`domainLock` option is set","Variant #1: base behaviour"],"updatePoint":{"line":30,"column":76},"line":30,"code":"            it('should correctly append code helper into the obfuscated code', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/DomainLockCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"should add prefix to the helper identifiers inside global scope","suites":["DomainLockCodeHelper","`domainLock` option is set","Variant #2: identifier names when appended inside global scope"],"updatePoint":{"line":53,"column":79},"line":53,"code":"            it('should add prefix to the helper identifiers inside global scope', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/DomainLockCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"should not add prefix to the helper identifiers inside global scope","suites":["DomainLockCodeHelper","`domainLock` option is set","Variant #3: identifier names when appended inside function scope"],"updatePoint":{"line":76,"column":83},"line":76,"code":"            it('should not add prefix to the helper identifiers inside global scope', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/DomainLockCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't append code helper into the obfuscated code","suites":["DomainLockCodeHelper","`domainLock` option isn't set"],"updatePoint":{"line":99,"column":66},"line":99,"code":"        it('shouldn\\'t append code helper into the obfuscated code', () => {\n            assert.notMatch(obfuscatedCode, regExp);\n        });","file":"functional-tests/custom-code-helpers/domain-lock/DomainLockCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly run code inside template","suites":["DomainLockTemplate","Variant #1: current domain matches with `domainsString`"],"updatePoint":{"line":103,"column":53},"line":103,"code":"        it('should correctly run code inside template', () => {\n            assert.doesNotThrow(() => testFunc.apply(root));\n            assert.isUndefined(root.document.location);\n        });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly run code inside template","suites":["DomainLockTemplate","Variant #2: current domain matches with base domain of `domainsString`"],"updatePoint":{"line":150,"column":53},"line":150,"code":"        it('should correctly run code inside template', () => {\n            assert.doesNotThrow(() => testFunc.apply(root));\n            assert.isUndefined(root.document.location);\n        });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly run code inside template","suites":["DomainLockTemplate","Variant #3: current domain matches with root domain of `domainsString`"],"updatePoint":{"line":197,"column":53},"line":197,"code":"        it('should correctly run code inside template', () => {\n            assert.doesNotThrow(() => testFunc.apply(root));\n            assert.isUndefined(root.document.location);\n        });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly run code inside template","suites":["DomainLockTemplate","Variant #4: current root domain matches with `domainsString`","Variant #1"],"updatePoint":{"line":245,"column":57},"line":245,"code":"            it('should correctly run code inside template', () => {\n                assert.doesNotThrow(() => testFunc.apply(root));\n                assert.isUndefined(root.document.location);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly run code inside template","suites":["DomainLockTemplate","Variant #4: current root domain matches with `domainsString`","Variant #2"],"updatePoint":{"line":292,"column":57},"line":292,"code":"            it('should correctly run code inside template', () => {\n                assert.doesNotThrow(() => testFunc.apply(root));\n                assert.isUndefined(root.document.location);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly run code inside template","suites":["DomainLockTemplate","Variant #4: current root domain matches with `domainsString`","Variant #3"],"updatePoint":{"line":339,"column":57},"line":339,"code":"            it('should correctly run code inside template', () => {\n                assert.doesNotThrow(() => testFunc.apply(root));\n                assert.isUndefined(root.document.location);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly run code inside template","suites":["DomainLockTemplate","Variant #4: current root domain matches with `domainsString`","Variant #4"],"updatePoint":{"line":386,"column":57},"line":386,"code":"            it('should correctly run code inside template', () => {\n                assert.doesNotThrow(() => testFunc.apply(root));\n                assert.isUndefined(root.document.location);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly run code inside template","suites":["DomainLockTemplate","Variant #5: current domain matches with base domain of `domainsString` item"],"updatePoint":{"line":434,"column":53},"line":434,"code":"        it('should correctly run code inside template', () => {\n            assert.doesNotThrow(() => testFunc.apply(root));\n            assert.isUndefined(root.document.location);\n        });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should change document.location","suites":["DomainLockTemplate","Variant #6: current domain doesn't match with `domainsString`","Variant #1"],"updatePoint":{"line":482,"column":47},"line":482,"code":"            it('should change document.location', () => {\n                assert.doesNotThrow(() => testFunc.apply(root));\n                assert.equal(root.document.location, domainLockRedirectUrl);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should change document.location","suites":["DomainLockTemplate","Variant #6: current domain doesn't match with `domainsString`","Variant #2"],"updatePoint":{"line":528,"column":47},"line":528,"code":"            it('should change document.location', () => {\n                assert.doesNotThrow(() => testFunc.apply(root));\n                assert.equal(root.document.location, domainLockRedirectUrl);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should change document.location","suites":["DomainLockTemplate","Variant #6: current domain doesn't match with `domainsString`","Variant #3"],"updatePoint":{"line":575,"column":47},"line":575,"code":"            it('should change document.location', () => {\n                assert.doesNotThrow(() => testFunc.apply(root));\n                assert.equal(root.document.location, domainLockRedirectUrl);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should change document.location","suites":["DomainLockTemplate","Variant #6: current domain doesn't match with `domainsString`","Variant #4"],"updatePoint":{"line":622,"column":47},"line":622,"code":"            it('should change document.location', () => {\n                assert.doesNotThrow(() => testFunc.apply(root));\n                assert.equal(root.document.location, domainLockRedirectUrl);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should change document.location","suites":["DomainLockTemplate","Variant #6: current domain doesn't match with `domainsString`","Variant #5"],"updatePoint":{"line":669,"column":47},"line":669,"code":"            it('should change document.location', () => {\n                assert.doesNotThrow(() => testFunc.apply(root));\n                assert.equal(root.document.location, domainLockRedirectUrl);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly run code inside template","suites":["DomainLockTemplate","Variant #7: location.hostname","Variant #1: current location.hostname matches with `domainsString`"],"updatePoint":{"line":719,"column":57},"line":719,"code":"            it('should correctly run code inside template', () => {\n                assert.doesNotThrow(() => testFunc.apply(root));\n                assert.isObject(root.document.location);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should change document.location","suites":["DomainLockTemplate","Variant #7: location.hostname","Variant #2: current location.hostname doesn't match with `domainsString`"],"updatePoint":{"line":767,"column":47},"line":767,"code":"            it('should change document.location', () => {\n                assert.doesNotThrow(() => testFunc.apply(root));\n                assert.equal(root.document.location, domainLockRedirectUrl);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly run code inside template","suites":["DomainLockTemplate","Variant #8: domain and location.hostname presented","Variant #1: current domain matches with `domainsString`"],"updatePoint":{"line":818,"column":57},"line":818,"code":"            it('should correctly run code inside template', () => {\n                assert.doesNotThrow(() => testFunc.apply(root));\n                assert.isObject(root.document.location);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should change document.location","suites":["DomainLockTemplate","Variant #8: domain and location.hostname presented","Variant #2: current domain doesn't match with `domainsString`"],"updatePoint":{"line":867,"column":47},"line":867,"code":"            it('should change document.location', () => {\n                assert.doesNotThrow(() => testFunc.apply(root));\n                assert.equal(root.document.location, domainLockRedirectUrl);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should return correct kind of variables for domain lock code","suites":["DomainLockTemplate","Prevailing kind of variables","`var` kind"],"updatePoint":{"line":901,"column":76},"line":901,"code":"            it('Should return correct kind of variables for domain lock code', () => {\n                assert.match(obfuscatedCode, domainLockVariableRegExp);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should does not break on obfuscating","suites":["DomainLockTemplate","Prevailing kind of variables","`var` kind"],"updatePoint":{"line":905,"column":52},"line":905,"code":"            it('Should does not break on obfuscating', () => {\n                assert.doesNotThrow(() => eval(getCodeTemplate(obfuscatedCode)));\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should return correct kind of variables for domain lock code","suites":["DomainLockTemplate","Prevailing kind of variables","`const` kind"],"updatePoint":{"line":929,"column":76},"line":929,"code":"            it('Should return correct kind of variables for domain lock code', () => {\n                assert.match(obfuscatedCode, domainLockVariableRegExp);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should does not break on obfuscating","suites":["DomainLockTemplate","Prevailing kind of variables","`const` kind"],"updatePoint":{"line":933,"column":52},"line":933,"code":"            it('Should does not break on obfuscating', () => {\n                assert.doesNotThrow(() => eval(getCodeTemplate(obfuscatedCode)));\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should return correct kind of variables for domain lock code","suites":["DomainLockTemplate","Prevailing kind of variables","`let` kind"],"updatePoint":{"line":957,"column":76},"line":957,"code":"            it('Should return correct kind of variables for domain lock code', () => {\n                assert.match(obfuscatedCode, domainLockVariableRegExp);\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should does not break on obfuscating","suites":["DomainLockTemplate","Prevailing kind of variables","`let` kind"],"updatePoint":{"line":961,"column":52},"line":961,"code":"            it('Should does not break on obfuscating', () => {\n                assert.doesNotThrow(() => eval(getCodeTemplate(obfuscatedCode)));\n            });","file":"functional-tests/custom-code-helpers/domain-lock/templates/DomainLockNodeTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should add prefix to the helper identifiers inside global scope","suites":["SelfDefendingCodeHelper","`selfDefending` option is set","Variant #1: identifier names when appended inside global scope"],"updatePoint":{"line":31,"column":79},"line":31,"code":"            it('should add prefix to the helper identifiers inside global scope', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/custom-code-helpers/self-defending/SelfDefendingCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"should not add prefix to the helper identifiers inside global scope","suites":["SelfDefendingCodeHelper","`selfDefending` option is set","Variant #2: identifier names when appended inside function scope"],"updatePoint":{"line":54,"column":83},"line":54,"code":"            it('should not add prefix to the helper identifiers inside global scope', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/custom-code-helpers/self-defending/SelfDefendingCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate code with enabled self defending","suites":["SelfDefendingTemplate","Variant #1: correctly obfuscate code with `HexadecimalIdentifierNamesGenerator``"],"updatePoint":{"line":52,"column":70},"line":52,"code":"        it('should correctly evaluate code with enabled self defending', () => {\n            assert.equal(evaluationResult, expectedEvaluationResult);\n        });","file":"functional-tests/custom-code-helpers/self-defending/templates/SelfDefendingTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate code with enabled self defending","suites":["SelfDefendingTemplate","Variant #2: correctly obfuscate code with `MangledIdentifierNamesGenerator` option"],"updatePoint":{"line":85,"column":70},"line":85,"code":"        it('should correctly evaluate code with enabled self defending', () => {\n            assert.equal(evaluationResult, expectedEvaluationResult);\n        });","file":"functional-tests/custom-code-helpers/self-defending/templates/SelfDefendingTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate code with enabled self defending","suites":["SelfDefendingTemplate","Variant #3: correctly obfuscate code with `DictionaryIdentifierNamesGenerator` option"],"updatePoint":{"line":119,"column":70},"line":119,"code":"        it('should correctly evaluate code with enabled self defending', () => {\n            assert.equal(evaluationResult, expectedEvaluationResult);\n        });","file":"functional-tests/custom-code-helpers/self-defending/templates/SelfDefendingTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should enter code in infinity loop","suites":["SelfDefendingTemplate","Variant #4: obfuscated code with beautified self defending code","Variant #1: beautify with spaces"],"updatePoint":{"line":153,"column":50},"line":153,"code":"            it('should enter code in infinity loop', () => {\n                assert.equal(evaluationResult, expectedEvaluationResult);\n            });","file":"functional-tests/custom-code-helpers/self-defending/templates/SelfDefendingTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should enter code in infinity loop","suites":["SelfDefendingTemplate","Variant #4: obfuscated code with beautified self defending code","Variant #2: beautify with tabs"],"updatePoint":{"line":186,"column":50},"line":186,"code":"            it('should enter code in infinity loop', () => {\n                assert.equal(evaluationResult, expectedEvaluationResult);\n            });","file":"functional-tests/custom-code-helpers/self-defending/templates/SelfDefendingTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate code with enabled self defending","suites":["SelfDefendingTemplate","Variant #5: JavaScript obfuscator code","Variant #1: correct evaluation"],"updatePoint":{"line":224,"column":74},"line":224,"code":"            it('should correctly evaluate code with enabled self defending', () => {\n                assert.equal(evaluationResult, expectedEvaluationResult);\n            });","file":"functional-tests/custom-code-helpers/self-defending/templates/SelfDefendingTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should enter code in infinity loop","suites":["SelfDefendingTemplate","Variant #5: JavaScript obfuscator code","Variant #2: beautify with spaces"],"updatePoint":{"line":260,"column":50},"line":260,"code":"            it('should enter code in infinity loop', () => {\n                assert.equal(evaluationResult, expectedEvaluationResult);\n            });","file":"functional-tests/custom-code-helpers/self-defending/templates/SelfDefendingTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correct place all StringArrayCallsWrapper code helpers","suites":["StringArrayCodeHelperGroup","StringArrayCallsWrapper code helper names"],"updatePoint":{"line":57,"column":73},"line":57,"code":"        it('should correct place all StringArrayCallsWrapper code helpers', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/custom-code-helpers/string-array/group/StringArrayCodeHelperGroup.spec.ts","skipped":false,"dir":"test"},{"name":"should place multiple StringArrayCallsWrapper code helper names in the random order","suites":["StringArrayCodeHelperGroup","StringArrayCallsWrapper code helper names"],"updatePoint":{"line":61,"column":95},"line":61,"code":"        it('should place multiple StringArrayCallsWrapper code helper names in the random order', () => {\n            assert.equal(stringArrayCallsWrapperNames.size, expectedUniqStringArrayCallsWrapperNamesCount);\n        });","file":"functional-tests/custom-code-helpers/string-array/group/StringArrayCodeHelperGroup.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should correctly append code helper into the obfuscated code at random index","suites":["StringArrayCallsWrapperCodeHelper","`stringArray` option is set"],"updatePoint":{"line":47,"column":98},"line":47,"code":"        it('Match #1: should correctly append code helper into the obfuscated code at random index', () => {\n            assert.isAbove(stringArrayCallsWrapperAtFirstPositionMatchesCount, 1);\n        });","file":"functional-tests/custom-code-helpers/string-array/StringArrayCallsWrapperCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should correctly append code helper into the obfuscated code at random index","suites":["StringArrayCallsWrapperCodeHelper","`stringArray` option is set"],"updatePoint":{"line":51,"column":98},"line":51,"code":"        it('Match #2: should correctly append code helper into the obfuscated code at random index', () => {\n            assert.isAbove(variableDeclarationAtFirstPositionMatchesCount, 1);\n        });","file":"functional-tests/custom-code-helpers/string-array/StringArrayCallsWrapperCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly append code helper into the obfuscated code","suites":["StringArrayCallsWrapperCodeHelper","`stringArray` option is set"],"updatePoint":{"line":72,"column":72},"line":72,"code":"        it('should correctly append code helper into the obfuscated code', () => {\n            assert.match(obfuscatedCode, stringCallsWrapperRegExp);\n        });","file":"functional-tests/custom-code-helpers/string-array/StringArrayCallsWrapperCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't append code helper into the obfuscated code","suites":["StringArrayCallsWrapperCodeHelper","`stringArray` option isn't set"],"updatePoint":{"line":92,"column":66},"line":92,"code":"        it('shouldn\\'t append code helper into the obfuscated code', () => {\n            assert.notMatch(obfuscatedCode, stringCallsWrapperRegExp);\n        });","file":"functional-tests/custom-code-helpers/string-array/StringArrayCallsWrapperCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"should preserve string array name","suites":["StringArrayCallsWrapperCodeHelper","Preserve string array name"],"updatePoint":{"line":123,"column":45},"line":123,"code":"        it('should preserve string array name', () => {\n            assert.match(obfuscatedCode, callsWrapperRegExp);\n        });","file":"functional-tests/custom-code-helpers/string-array/StringArrayCallsWrapperCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should correctly append code helper into the obfuscated code at random index","suites":["StringArrayCodeHelper","`stringArray` option is set"],"updatePoint":{"line":45,"column":98},"line":45,"code":"        it('Match #1: should correctly append code helper into the obfuscated code at random index', () => {\n            assert.isAbove(stringArrayAtFirstPositionMatchesCount, 1);\n        });","file":"functional-tests/custom-code-helpers/string-array/StringArrayCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should correctly append code helper into the obfuscated code at random index","suites":["StringArrayCodeHelper","`stringArray` option is set"],"updatePoint":{"line":49,"column":98},"line":49,"code":"        it('Match #2: should correctly append code helper into the obfuscated code at random index', () => {\n            assert.isAbove(variableDeclarationAtFirstPositionMatchesCount, 1);\n        });","file":"functional-tests/custom-code-helpers/string-array/StringArrayCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't append code helper into the obfuscated code","suites":["StringArrayCodeHelper","`stringArray` option isn't set"],"updatePoint":{"line":69,"column":66},"line":69,"code":"        it('shouldn\\'t append code helper into the obfuscated code', () => {\n            assert.notMatch(obfuscatedCode, stringArrayRegExp);\n        });","file":"functional-tests/custom-code-helpers/string-array/StringArrayCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly append code helper into the obfuscated code","suites":["StringArrayRotateFunctionCodeHelper","Base behaviour","`stringArray` option is set"],"updatePoint":{"line":32,"column":76},"line":32,"code":"            it('should correctly append code helper into the obfuscated code', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/custom-code-helpers/string-array/StringArrayRotateFunctionCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't append code helper into the obfuscated code","suites":["StringArrayRotateFunctionCodeHelper","Base behaviour","`stringArray` option isn't set"],"updatePoint":{"line":54,"column":70},"line":54,"code":"            it('shouldn\\'t append code helper into the obfuscated code', () => {\n                assert.notMatch(obfuscatedCode, regExp);\n            });","file":"functional-tests/custom-code-helpers/string-array/StringArrayRotateFunctionCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"should add comparison expression to the code","suites":["StringArrayRotateFunctionCodeHelper","Comparison expression","Should add comparison expression to the code helper"],"updatePoint":{"line":80,"column":60},"line":80,"code":"            it('should add comparison expression to the code', () => {\n                assert.match(obfuscatedCode, comparisonExpressionRegExp);\n            });","file":"functional-tests/custom-code-helpers/string-array/StringArrayRotateFunctionCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"should preserve string array name","suites":["StringArrayRotateFunctionCodeHelper","Preserve string array name"],"updatePoint":{"line":107,"column":45},"line":107,"code":"        it('should preserve string array name', () => {\n            assert.match(obfuscatedCode, arrayRotateRegExp);\n        });","file":"functional-tests/custom-code-helpers/string-array/StringArrayRotateFunctionCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"generate valid identifier names","suites":["StringArrayRotateFunctionCodeHelper","Preserve string array name"],"updatePoint":{"line":111,"column":43},"line":111,"code":"        it('generate valid identifier names', () => {\n            assert.match(obfuscatedCode, comparisonRegExp);\n        });","file":"functional-tests/custom-code-helpers/string-array/StringArrayRotateFunctionCodeHelper.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly return decoded value","suites":["StringArrayCallsWrapperTemplate","Variant #1: `base64` encoding","Variant #1: `selfDefending` option is disabled","Variant #1: index shift amount is `0`"],"updatePoint":{"line":99,"column":57},"line":99,"code":"                it('should correctly return decoded value', () => {\n                    assert.deepEqual(decodedValue, expectedDecodedValue);\n                });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-calls-wrapper-node-template/StringArrayCallsWrapperTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly return decoded value","suites":["StringArrayCallsWrapperTemplate","Variant #1: `base64` encoding","Variant #1: `selfDefending` option is disabled","Variant #2: index shift amount is `5`"],"updatePoint":{"line":149,"column":57},"line":149,"code":"                it('should correctly return decoded value', () => {\n                    assert.deepEqual(decodedValue, expectedDecodedValue);\n                });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-calls-wrapper-node-template/StringArrayCallsWrapperTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly return RegExp.$1 match without mutation by atob template","suites":["StringArrayCallsWrapperTemplate","Variant #1: `base64` encoding","Variant #1: `selfDefending` option is disabled","Variant #3: no regexp inside atob template"],"updatePoint":{"line":200,"column":93},"line":200,"code":"                it('should correctly return RegExp.$1 match without mutation by atob template', () => {\n                    assert.deepEqual(decodedValue, expectedRegExpTestValue);\n                });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-calls-wrapper-node-template/StringArrayCallsWrapperTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly return decoded value","suites":["StringArrayCallsWrapperTemplate","Variant #1: `base64` encoding","Variant #2: `selfDefending` option is enabled","Variant #1: correct code evaluation for single-line code","Variant #1: long decoded string"],"updatePoint":{"line":257,"column":61},"line":257,"code":"                    it('should correctly return decoded value', () => {\n                        assert.deepEqual(decodedValue, expectedDecodedValue);\n                    });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-calls-wrapper-node-template/StringArrayCallsWrapperTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly return decoded value","suites":["StringArrayCallsWrapperTemplate","Variant #1: `base64` encoding","Variant #2: `selfDefending` option is enabled","Variant #1: correct code evaluation for single-line code","Variant #2: 3-characters decoded string"],"updatePoint":{"line":309,"column":61},"line":309,"code":"                    it('should correctly return decoded value', () => {\n                        assert.deepEqual(decodedValue, expectedDecodedValue);\n                    });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-calls-wrapper-node-template/StringArrayCallsWrapperTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should return invalid decoded value","suites":["StringArrayCallsWrapperTemplate","Variant #1: `base64` encoding","Variant #2: `selfDefending` option is enabled","Variant #2: invalid code evaluation for multi-line code","Variant #1: long decoded string"],"updatePoint":{"line":361,"column":59},"line":361,"code":"                    it('should return invalid decoded value', () => {\n                        assert.deepEqual(decodedValue, expectedDecodedValue);\n                    });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-calls-wrapper-node-template/StringArrayCallsWrapperTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should return invalid decoded value","suites":["StringArrayCallsWrapperTemplate","Variant #1: `base64` encoding","Variant #2: `selfDefending` option is enabled","Variant #2: invalid code evaluation for multi-line code","Variant #2: 3-characters decoded string"],"updatePoint":{"line":411,"column":59},"line":411,"code":"                    it('should return invalid decoded value', () => {\n                        assert.deepEqual(decodedValue, expectedDecodedValue);\n                    });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-calls-wrapper-node-template/StringArrayCallsWrapperTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly return decoded value","suites":["StringArrayCallsWrapperTemplate","Variant #2: `rc4` encoding","Variant #1: `selfDefending` option is disabled","Variant #1: index shift amount is `0`"],"updatePoint":{"line":474,"column":57},"line":474,"code":"                it('should correctly return decoded value', () => {\n                    assert.deepEqual(decodedValue, expectedDecodedValue);\n                });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-calls-wrapper-node-template/StringArrayCallsWrapperTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly return decoded value","suites":["StringArrayCallsWrapperTemplate","Variant #2: `rc4` encoding","Variant #1: `selfDefending` option is disabled","Variant #2: index shift amount is `5`"],"updatePoint":{"line":530,"column":57},"line":530,"code":"                it('should correctly return decoded value', () => {\n                    assert.deepEqual(decodedValue, expectedDecodedValue);\n                });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-calls-wrapper-node-template/StringArrayCallsWrapperTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly return decoded value","suites":["StringArrayCallsWrapperTemplate","Variant #2: `rc4` encoding","Variant #2: `selfDefending` option is enabled","Variant #1: correct code evaluation for single-line code","Variant #1: long decoded string"],"updatePoint":{"line":595,"column":61},"line":595,"code":"                    it('should correctly return decoded value', () => {\n                        assert.deepEqual(decodedValue, expectedDecodedValue);\n                    });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-calls-wrapper-node-template/StringArrayCallsWrapperTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly return decoded value","suites":["StringArrayCallsWrapperTemplate","Variant #2: `rc4` encoding","Variant #2: `selfDefending` option is enabled","Variant #2: invalid code evaluation for multi-line code","Variant #1: long decoded string"],"updatePoint":{"line":653,"column":61},"line":653,"code":"                    it('should correctly return decoded value', () => {\n                        assert.deepEqual(decodedValue, expectedDecodedValue);\n                    });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-calls-wrapper-node-template/StringArrayCallsWrapperTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should return correct kind of variables for string array calls wrapper code","suites":["StringArrayCallsWrapperTemplate","Prevailing kind of variables","`var` kind"],"updatePoint":{"line":680,"column":91},"line":680,"code":"            it('Should return correct kind of variables for string array calls wrapper code', () => {\n                assert.match(obfuscatedCode, stringArrayCallsWrapperVariableRegExp);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-calls-wrapper-node-template/StringArrayCallsWrapperTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should does not break on obfuscating","suites":["StringArrayCallsWrapperTemplate","Prevailing kind of variables","`var` kind"],"updatePoint":{"line":684,"column":52},"line":684,"code":"            it('Should does not break on obfuscating', () => {\n                assert.doesNotThrow(() => obfuscatedCode);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-calls-wrapper-node-template/StringArrayCallsWrapperTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should return correct kind of variables for string array calls wrapper code","suites":["StringArrayCallsWrapperTemplate","Prevailing kind of variables","`const` kind"],"updatePoint":{"line":707,"column":91},"line":707,"code":"            it('Should return correct kind of variables for string array calls wrapper code', () => {\n                assert.match(obfuscatedCode, stringArrayCallsWrapperVariableRegExp);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-calls-wrapper-node-template/StringArrayCallsWrapperTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should does not break on obfuscating","suites":["StringArrayCallsWrapperTemplate","Prevailing kind of variables","`const` kind"],"updatePoint":{"line":711,"column":52},"line":711,"code":"            it('Should does not break on obfuscating', () => {\n                assert.doesNotThrow(() => obfuscatedCode);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-calls-wrapper-node-template/StringArrayCallsWrapperTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should return correct kind of variables for string array calls wrapper code","suites":["StringArrayCallsWrapperTemplate","Prevailing kind of variables","`let` kind"],"updatePoint":{"line":734,"column":91},"line":734,"code":"            it('Should return correct kind of variables for string array calls wrapper code', () => {\n                assert.match(obfuscatedCode, stringArrayCallsWrapperVariableRegExp);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-calls-wrapper-node-template/StringArrayCallsWrapperTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should does not break on obfuscating","suites":["StringArrayCallsWrapperTemplate","Prevailing kind of variables","`let` kind"],"updatePoint":{"line":738,"column":52},"line":738,"code":"            it('Should does not break on obfuscating', () => {\n                assert.doesNotThrow(() => obfuscatedCode);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-calls-wrapper-node-template/StringArrayCallsWrapperTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should use computed member expression in `array.push` method","suites":["StringArrayRotateFunctionTemplate","Computed member expressions as array method calls","Array push"],"updatePoint":{"line":35,"column":76},"line":35,"code":"            it('Should use computed member expression in `array.push` method', () => {\n                assert.match(obfuscatedCode, arrayPushComputedRegExp);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-rotate-function-template/StringArrayRotateFunctionTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should not use base member expression in `array.push` method","suites":["StringArrayRotateFunctionTemplate","Computed member expressions as array method calls","Array push"],"updatePoint":{"line":39,"column":76},"line":39,"code":"            it('Should not use base member expression in `array.push` method', () => {\n                assert.notMatch(obfuscatedCode, arrayPushBaseRegExp);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-rotate-function-template/StringArrayRotateFunctionTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should use computed member expression in `array.shift` method","suites":["StringArrayRotateFunctionTemplate","Computed member expressions as array method calls","Array shift"],"updatePoint":{"line":65,"column":77},"line":65,"code":"            it('Should use computed member expression in `array.shift` method', () => {\n                assert.match(obfuscatedCode, arrayShiftComputedRegExp);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-rotate-function-template/StringArrayRotateFunctionTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should not use base member expression in `array.shift` method","suites":["StringArrayRotateFunctionTemplate","Computed member expressions as array method calls","Array shift"],"updatePoint":{"line":69,"column":77},"line":69,"code":"            it('Should not use base member expression in `array.shift` method', () => {\n                assert.notMatch(obfuscatedCode, arrayShiftBaseRegExp);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-rotate-function-template/StringArrayRotateFunctionTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should return correct kind of variables for string array rotate function","suites":["StringArrayRotateFunctionTemplate","Prevailing kind of variables","`var` kind"],"updatePoint":{"line":95,"column":88},"line":95,"code":"            it('Should return correct kind of variables for string array rotate function', () => {\n                assert.match(obfuscatedCode, stringArrayRotateFunctionTryCatchRegExp);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-rotate-function-template/StringArrayRotateFunctionTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should does not break on obfuscating","suites":["StringArrayRotateFunctionTemplate","Prevailing kind of variables","`var` kind"],"updatePoint":{"line":99,"column":52},"line":99,"code":"            it('Should does not break on obfuscating', () => {\n                assert.doesNotThrow(() => obfuscatedCode);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-rotate-function-template/StringArrayRotateFunctionTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should return correct kind of variables for string array rotate function","suites":["StringArrayRotateFunctionTemplate","Prevailing kind of variables","`const` kind"],"updatePoint":{"line":123,"column":88},"line":123,"code":"            it('Should return correct kind of variables for string array rotate function', () => {\n                assert.match(obfuscatedCode, stringArrayRotateFunctionTryCatchRegExp);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-rotate-function-template/StringArrayRotateFunctionTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should does not break on obfuscating","suites":["StringArrayRotateFunctionTemplate","Prevailing kind of variables","`const` kind"],"updatePoint":{"line":127,"column":52},"line":127,"code":"            it('Should does not break on obfuscating', () => {\n                assert.doesNotThrow(() => obfuscatedCode);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-rotate-function-template/StringArrayRotateFunctionTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should return correct kind of variables for string array rotate function","suites":["StringArrayRotateFunctionTemplate","Prevailing kind of variables","`let` kind"],"updatePoint":{"line":151,"column":88},"line":151,"code":"            it('Should return correct kind of variables for string array rotate function', () => {\n                assert.match(obfuscatedCode, stringArrayRotateFunctionTryCatchRegExp);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-rotate-function-template/StringArrayRotateFunctionTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should does not break on obfuscating","suites":["StringArrayRotateFunctionTemplate","Prevailing kind of variables","`let` kind"],"updatePoint":{"line":155,"column":52},"line":155,"code":"            it('Should does not break on obfuscating', () => {\n                assert.doesNotThrow(() => obfuscatedCode);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-rotate-function-template/StringArrayRotateFunctionTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should return correct kind of variables for string array","suites":["StringArrayTemplate","Prevailing kind of variables","`var` kind"],"updatePoint":{"line":33,"column":72},"line":33,"code":"            it('Should return correct kind of variables for string array', () => {\n                assert.match(obfuscatedCode, stringArrayRegExp);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-template/StringArrayTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should does not break on obfuscating","suites":["StringArrayTemplate","Prevailing kind of variables","`var` kind"],"updatePoint":{"line":37,"column":52},"line":37,"code":"            it('Should does not break on obfuscating', () => {\n                assert.doesNotThrow(() => obfuscatedCode);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-template/StringArrayTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should return correct kind of variables for string array","suites":["StringArrayTemplate","Prevailing kind of variables","`const` kind"],"updatePoint":{"line":60,"column":72},"line":60,"code":"            it('Should return correct kind of variables for string array', () => {\n                assert.match(obfuscatedCode, stringArrayRegExp);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-template/StringArrayTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should does not break on obfuscating","suites":["StringArrayTemplate","Prevailing kind of variables","`const` kind"],"updatePoint":{"line":64,"column":52},"line":64,"code":"            it('Should does not break on obfuscating', () => {\n                assert.doesNotThrow(() => obfuscatedCode);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-template/StringArrayTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should return correct kind of variables for string array","suites":["StringArrayTemplate","Prevailing kind of variables","`let` kind"],"updatePoint":{"line":87,"column":72},"line":87,"code":"            it('Should return correct kind of variables for string array', () => {\n                assert.match(obfuscatedCode, stringArrayRegExp);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-template/StringArrayTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should does not break on obfuscating","suites":["StringArrayTemplate","Prevailing kind of variables","`let` kind"],"updatePoint":{"line":91,"column":52},"line":91,"code":"            it('Should does not break on obfuscating', () => {\n                assert.doesNotThrow(() => obfuscatedCode);\n            });","file":"functional-tests/custom-code-helpers/string-array/templates/string-array-template/StringArrayTemplate.spec.ts","skipped":false,"dir":"test"},{"name":"Should generate correct identifier for string array","suites":["DictionaryIdentifierNamesGenerator","generateWithPrefix","Variant #1: should not generate same name for string array as existing name in code","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":60,"column":71},"line":60,"code":"                it('Should generate correct identifier for string array', () => {\n                    assert.match(obfuscatedCode, stringArrayStorageRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/dictionary-identifier-names-generator/DictionaryIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Should keep identifier name for existing variable declaration #1","suites":["DictionaryIdentifierNamesGenerator","generateWithPrefix","Variant #1: should not generate same name for string array as existing name in code","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":64,"column":84},"line":64,"code":"                it('Should keep identifier name for existing variable declaration #1', () => {\n                    assert.notEqual(stringArrayName, variableDeclarationIdentifierName1);\n                });","file":"functional-tests/generators/identifier-names-generators/dictionary-identifier-names-generator/DictionaryIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Should keep identifier name for existing variable declaration #2","suites":["DictionaryIdentifierNamesGenerator","generateWithPrefix","Variant #1: should not generate same name for string array as existing name in code","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":68,"column":84},"line":68,"code":"                it('Should keep identifier name for existing variable declaration #2', () => {\n                    assert.notEqual(stringArrayName, variableDeclarationIdentifierName2);\n                });","file":"functional-tests/generators/identifier-names-generators/dictionary-identifier-names-generator/DictionaryIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Should generate correct identifier for string array","suites":["DictionaryIdentifierNamesGenerator","generateWithPrefix","Variant #1: should not generate same name for string array as existing name in code","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":117,"column":71},"line":117,"code":"                it('Should generate correct identifier for string array', () => {\n                    assert.match(obfuscatedCode, stringArrayStorageRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/dictionary-identifier-names-generator/DictionaryIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Should keep identifier name for existing variable declaration #1","suites":["DictionaryIdentifierNamesGenerator","generateWithPrefix","Variant #1: should not generate same name for string array as existing name in code","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":121,"column":84},"line":121,"code":"                it('Should keep identifier name for existing variable declaration #1', () => {\n                    assert.notEqual(stringArrayName, variableDeclarationIdentifierName1);\n                });","file":"functional-tests/generators/identifier-names-generators/dictionary-identifier-names-generator/DictionaryIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Should keep identifier name for existing variable declaration #2","suites":["DictionaryIdentifierNamesGenerator","generateWithPrefix","Variant #1: should not generate same name for string array as existing name in code","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":125,"column":84},"line":125,"code":"                it('Should keep identifier name for existing variable declaration #2', () => {\n                    assert.notEqual(stringArrayName, variableDeclarationIdentifierName2);\n                });","file":"functional-tests/generators/identifier-names-generators/dictionary-identifier-names-generator/DictionaryIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Should not generate same name for string array and last variable","suites":["DictionaryIdentifierNamesGenerator","generateWithPrefix","Variant #2: should not generate same prefixed name for identifier in code as prefixed name of string array","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":176,"column":84},"line":176,"code":"                it('Should not generate same name for string array and last variable', () => {\n                    assert.equal(isIdentifiersAreConflicted, false);\n                });","file":"functional-tests/generators/identifier-names-generators/dictionary-identifier-names-generator/DictionaryIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Should not generate same name for string array and last variable","suites":["DictionaryIdentifierNamesGenerator","generateWithPrefix","Variant #2: should not generate same prefixed name for identifier in code as prefixed name of string array","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":222,"column":84},"line":222,"code":"                it('Should not generate same name for string array and last variable', () => {\n                    assert.equal(isIdentifiersAreConflicted, false);\n                });","file":"functional-tests/generators/identifier-names-generators/dictionary-identifier-names-generator/DictionaryIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should generate correct identifier for string array","suites":["MangledIdentifierNamesGenerator","generateWithPrefix","Variant #1: should not generate same name for string array as existing name in code","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":40,"column":81},"line":40,"code":"                it('Match #1: should generate correct identifier for string array', () => {\n                    assert.match(obfuscatedCode, stringArrayStorageRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should keep identifier name for last variable declaration","suites":["MangledIdentifierNamesGenerator","generateWithPrefix","Variant #1: should not generate same name for string array as existing name in code","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":44,"column":87},"line":44,"code":"                it('Match #2: should keep identifier name for last variable declaration', () => {\n                    assert.match(obfuscatedCode, lastVariableDeclarationIdentifierNameRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should generate correct identifier for string array","suites":["MangledIdentifierNamesGenerator","generateWithPrefix","Variant #1: should not generate same name for string array as existing name in code","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":75,"column":81},"line":75,"code":"                it('Match #1: should generate correct identifier for string array', () => {\n                    assert.match(obfuscatedCode, stringArrayStorageRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should keep identifier name for last variable declaration","suites":["MangledIdentifierNamesGenerator","generateWithPrefix","Variant #1: should not generate same name for string array as existing name in code","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":79,"column":87},"line":79,"code":"                it('Match #2: should keep identifier name for last variable declaration', () => {\n                    assert.match(obfuscatedCode, lastVariableDeclarationIdentifierNameRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should generate correct identifier name for string array","suites":["MangledIdentifierNamesGenerator","generateWithPrefix","Variant #2: should not generate same prefixed name for identifier in code as prefixed name of string array","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":112,"column":86},"line":112,"code":"                it('Match #1: should generate correct identifier name for string array', () => {\n                    assert.match(obfuscatedCode, stringArrayStorageRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should keep identifier name for function declaration","suites":["MangledIdentifierNamesGenerator","generateWithPrefix","Variant #2: should not generate same prefixed name for identifier in code as prefixed name of string array","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":116,"column":82},"line":116,"code":"                it('Match #2: should keep identifier name for function declaration', () => {\n                    assert.match(obfuscatedCode, functionDeclarationIdentifierNameRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should keep identifier name for last variable declaration","suites":["MangledIdentifierNamesGenerator","generateWithPrefix","Variant #2: should not generate same prefixed name for identifier in code as prefixed name of string array","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":120,"column":87},"line":120,"code":"                it('Match #3: should keep identifier name for last variable declaration', () => {\n                    assert.match(obfuscatedCode, lastVariableDeclarationIdentifierNameRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should generate correct identifier name for string array","suites":["MangledIdentifierNamesGenerator","generateWithPrefix","Variant #2: should not generate same prefixed name for identifier in code as prefixed name of string array","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":152,"column":86},"line":152,"code":"                it('Match #1: should generate correct identifier name for string array', () => {\n                    assert.match(obfuscatedCode, stringArrayStorageRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should generate correct identifier name for function declaration","suites":["MangledIdentifierNamesGenerator","generateWithPrefix","Variant #2: should not generate same prefixed name for identifier in code as prefixed name of string array","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":156,"column":94},"line":156,"code":"                it('Match #2: should generate correct identifier name for function declaration', () => {\n                    assert.match(obfuscatedCode, functionDeclarationIdentifierNameRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should keep identifier name for last variable declaration","suites":["MangledIdentifierNamesGenerator","generateWithPrefix","Variant #2: should not generate same prefixed name for identifier in code as prefixed name of string array","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":160,"column":87},"line":160,"code":"                it('Match #3: should keep identifier name for last variable declaration', () => {\n                    assert.match(obfuscatedCode, lastVariableDeclarationIdentifierNameRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should keep identifier name for variable declaration","suites":["MangledIdentifierNamesGenerator","generateForLexicalScope","Variant #1: Should generate different names set for different lexical scopes","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":188,"column":82},"line":188,"code":"                it('Match #1: should keep identifier name for variable declaration', () => {\n                    assert.match(obfuscatedCode, variableIdentifierRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should generate valid identifier names for function","suites":["MangledIdentifierNamesGenerator","generateForLexicalScope","Variant #1: Should generate different names set for different lexical scopes","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":192,"column":81},"line":192,"code":"                it('Match #2: should generate valid identifier names for function', () => {\n                    assert.match(obfuscatedCode, functionDeclarationRegExp1);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should generate valid identifier names for function","suites":["MangledIdentifierNamesGenerator","generateForLexicalScope","Variant #1: Should generate different names set for different lexical scopes","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":196,"column":81},"line":196,"code":"                it('Match #3: should generate valid identifier names for function', () => {\n                    assert.match(obfuscatedCode, functionDeclarationRegExp2);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should generate valid identifier name for variable declaration","suites":["MangledIdentifierNamesGenerator","generateForLexicalScope","Variant #1: Should generate different names set for different lexical scopes","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":221,"column":92},"line":221,"code":"                it('Match #1: should generate valid identifier name for variable declaration', () => {\n                    assert.match(obfuscatedCode, variableIdentifierRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should generate valid identifier names for function","suites":["MangledIdentifierNamesGenerator","generateForLexicalScope","Variant #1: Should generate different names set for different lexical scopes","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":225,"column":81},"line":225,"code":"                it('Match #2: should generate valid identifier names for function', () => {\n                    assert.match(obfuscatedCode, functionDeclarationRegExp1);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should generate valid identifier names for function","suites":["MangledIdentifierNamesGenerator","generateForLexicalScope","Variant #1: Should generate different names set for different lexical scopes","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":229,"column":81},"line":229,"code":"                it('Match #3: should generate valid identifier names for function', () => {\n                    assert.match(obfuscatedCode, functionDeclarationRegExp2);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should generate valid identifier names for string array","suites":["MangledIdentifierNamesGenerator","generateForLexicalScope","Variant #2: Should generate different names set for different lexical scopes when string array is enabled","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":261,"column":85},"line":261,"code":"                it('Match #1: should generate valid identifier names for string array', () => {\n                    assert.match(obfuscatedCode, stringArrayIdentifierRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should keep identifier name for variable declaration","suites":["MangledIdentifierNamesGenerator","generateForLexicalScope","Variant #2: Should generate different names set for different lexical scopes when string array is enabled","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":265,"column":82},"line":265,"code":"                it('Match #2: should keep identifier name for variable declaration', () => {\n                    assert.match(obfuscatedCode, variableIdentifierRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should generate valid identifier names for function","suites":["MangledIdentifierNamesGenerator","generateForLexicalScope","Variant #2: Should generate different names set for different lexical scopes when string array is enabled","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":269,"column":81},"line":269,"code":"                it('Match #3: should generate valid identifier names for function', () => {\n                    assert.match(obfuscatedCode, functionDeclarationRegExp1);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #4: should generate valid identifier names for function","suites":["MangledIdentifierNamesGenerator","generateForLexicalScope","Variant #2: Should generate different names set for different lexical scopes when string array is enabled","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":273,"column":81},"line":273,"code":"                it('Match #4: should generate valid identifier names for function', () => {\n                    assert.match(obfuscatedCode, functionDeclarationRegExp2);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should generate valid identifier names for string array","suites":["MangledIdentifierNamesGenerator","generateForLexicalScope","Variant #2: Should generate different names set for different lexical scopes when string array is enabled","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":304,"column":85},"line":304,"code":"                it('Match #1: should generate valid identifier names for string array', () => {\n                    assert.match(obfuscatedCode, stringArrayIdentifierRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should generate valid identifier name for variable declaration","suites":["MangledIdentifierNamesGenerator","generateForLexicalScope","Variant #2: Should generate different names set for different lexical scopes when string array is enabled","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":308,"column":92},"line":308,"code":"                it('Match #2: should generate valid identifier name for variable declaration', () => {\n                    assert.match(obfuscatedCode, variableIdentifierRegExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should generate valid identifier names for function","suites":["MangledIdentifierNamesGenerator","generateForLexicalScope","Variant #2: Should generate different names set for different lexical scopes when string array is enabled","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":312,"column":81},"line":312,"code":"                it('Match #3: should generate valid identifier names for function', () => {\n                    assert.match(obfuscatedCode, functionDeclarationRegExp1);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #4: should generate valid identifier names for function","suites":["MangledIdentifierNamesGenerator","generateForLexicalScope","Variant #2: Should generate different names set for different lexical scopes when string array is enabled","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":316,"column":81},"line":316,"code":"                it('Match #4: should generate valid identifier names for function', () => {\n                    assert.match(obfuscatedCode, functionDeclarationRegExp2);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should generate valid identifier names","suites":["MangledIdentifierNamesGenerator","generateForLexicalScope","Variant #3: Should generate different names set for different lexical scopes: nested functions","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":350,"column":68},"line":350,"code":"                it('Match #1: should generate valid identifier names', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should generate valid identifier names","suites":["MangledIdentifierNamesGenerator","generateForLexicalScope","Variant #3: Should generate different names set for different lexical scopes: nested functions","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":383,"column":68},"line":383,"code":"                it('Match #1: should generate valid identifier names', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/generators/identifier-names-generators/mangled-identifier-names-generator/MangledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Should not mutate name sequences between mangled generators","suites":["MangledShuffledIdentifierNamesGenerator","Variant #1: prevent name sequence mutation of base `mangled` generator"],"updatePoint":{"line":40,"column":71},"line":40,"code":"        it('Should not mutate name sequences between mangled generators', () => {\n            assert.notMatch(obfuscatedCode, functionsRegExp);\n        });","file":"functional-tests/generators/identifier-names-generators/mangled-shuffled-identifier-names-generator/MangledShuffledIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"does not break on run","suites":["Issue #321","Fixture code should not break"],"updatePoint":{"line":26,"column":33},"line":26,"code":"        it('does not break on run', () => {\n            assert.doesNotThrow(() => eval(obfuscatedCode));\n        });","file":"functional-tests/issues/issue321.spec.ts","skipped":false,"dir":"test"},{"name":"does not break on run","suites":["Issue #355","Fixture code should not break"],"updatePoint":{"line":28,"column":33},"line":28,"code":"        it('does not break on run', () => {\n            assert.doesNotThrow(() => eval(obfuscatedCode));\n        });","file":"functional-tests/issues/issue355.spec.ts","skipped":false,"dir":"test"},{"name":"does not break on obfuscating","suites":["Issue #419","Fixture code should not break"],"updatePoint":{"line":27,"column":41},"line":27,"code":"        it('does not break on obfuscating', () => {\n            assert.doesNotThrow(() => eval(obfuscatedCode));\n        });","file":"functional-tests/issues/issue419.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct `for-await-of` statement","suites":["Issue #419","Fixture code should not break"],"updatePoint":{"line":31,"column":58},"line":31,"code":"        it('should return correct `for-await-of` statement', () => {\n            assert.match(obfuscatedCode, codeRegExp);\n        });","file":"functional-tests/issues/issue419.spec.ts","skipped":false,"dir":"test"},{"name":"does not break on run","suites":["Issue #424","Fixture code should not break"],"updatePoint":{"line":26,"column":33},"line":26,"code":"        it('does not break on run', () => {\n            assert.doesNotThrow(() => eval(obfuscatedCode));\n        });","file":"functional-tests/issues/issue424.spec.ts","skipped":false,"dir":"test"},{"name":"does not break on obfuscating","suites":["Issue #437","Fixture code should not break on obfuscating"],"updatePoint":{"line":25,"column":41},"line":25,"code":"        it('does not break on obfuscating', () => {\n            assert.doesNotThrow(testFunc);\n        });","file":"functional-tests/issues/issue437.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","correct source code"],"updatePoint":{"line":52,"column":53},"line":52,"code":"            it('should return correct obfuscated code', () => {\n                assert.isOk(obfuscatedCode);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return empty source map","suites":["JavaScriptObfuscator","obfuscate","correct source code"],"updatePoint":{"line":56,"column":46},"line":56,"code":"            it('should return empty source map', () => {\n                assert.isNotOk(sourceMap);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return an empty obfuscated code","suites":["JavaScriptObfuscator","obfuscate","Empty or invalid source code","empty source code"],"updatePoint":{"line":73,"column":58},"line":73,"code":"                it('should return an empty obfuscated code', () => {\n                    assert.isNotOk(obfuscatedCode);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return an empty obfuscated code","suites":["JavaScriptObfuscator","obfuscate","Empty or invalid source code","empty source code with comments"],"updatePoint":{"line":93,"column":58},"line":93,"code":"                it('should return an empty obfuscated code', () => {\n                    assert.isNotOk(obfuscatedCode);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return an empty obfuscated code","suites":["JavaScriptObfuscator","obfuscate","Empty or invalid source code","invalid source code type"],"updatePoint":{"line":107,"column":58},"line":107,"code":"                it('should return an empty obfuscated code', () => {\n                    assert.isNotOk(obfuscatedCode);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapMode` is `separate`"],"updatePoint":{"line":140,"column":57},"line":140,"code":"                it('should return correct obfuscated code', () => {\n                    assert.isOk(obfuscatedCode);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct source map mappings","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapMode` is `separate`"],"updatePoint":{"line":144,"column":61},"line":144,"code":"                it('should return correct source map mappings', () => {\n                    assert.isOk(sourceMap.mappings);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should define placeholder `sources` field for source map","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapMode` is `separate`"],"updatePoint":{"line":148,"column":76},"line":148,"code":"                it('should define placeholder `sources` field for source map', () => {\n                    assert.deepEqual(sourceMap.sources, ['sourceMap']);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should define `sourcesContent` field for source map","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapMode` is `separate`"],"updatePoint":{"line":152,"column":71},"line":152,"code":"                it('should define `sourcesContent` field for source map', () => {\n                    assert.isOk(sourceMap.sourcesContent);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should resolve correct sources from source map","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapMode` is `separate`"],"updatePoint":{"line":156,"column":66},"line":156,"code":"                it('should resolve correct sources from source map', () => {\n                    assert.equal(resolvedSources, code);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapMode` is `inline`"],"updatePoint":{"line":190,"column":57},"line":190,"code":"                it('should return correct obfuscated code', () => {\n                    assert.isOk(obfuscatedCode);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return obfuscated code with inline source map as Base64 string","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapMode` is `inline`"],"updatePoint":{"line":194,"column":89},"line":194,"code":"                it('should return obfuscated code with inline source map as Base64 string', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct source map mappings","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapMode` is `inline`"],"updatePoint":{"line":198,"column":61},"line":198,"code":"                it('should return correct source map mappings', () => {\n                    assert.isOk(sourceMap.mappings);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should define placeholder `sources` field for source map","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapMode` is `inline`"],"updatePoint":{"line":202,"column":76},"line":202,"code":"                it('should define placeholder `sources` field for source map', () => {\n                    assert.deepEqual(sourceMap.sources, ['sourceMap']);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should define `sourcesContent` field for source map","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapMode` is `inline`"],"updatePoint":{"line":206,"column":71},"line":206,"code":"                it('should define `sourcesContent` field for source map', () => {\n                    assert.isOk(sourceMap.sourcesContent);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should resolve correct sources from source map","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapMode` is `inline`"],"updatePoint":{"line":210,"column":66},"line":210,"code":"                it('should resolve correct sources from source map', () => {\n                    console.log(resolvedSources);\n                    assert.equal(resolvedSources, code);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return empty obfuscated code","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","empty source code"],"updatePoint":{"line":240,"column":55},"line":240,"code":"                it('should return empty obfuscated code', () => {\n                    assert.isNotOk(obfuscatedCode);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return empty source map property `names`","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","empty source code"],"updatePoint":{"line":244,"column":67},"line":244,"code":"                it('should return empty source map property `names`', () => {\n                    assert.deepEqual(sourceMapNames, []);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return empty source map property `sources`","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","empty source code"],"updatePoint":{"line":248,"column":69},"line":248,"code":"                it('should return empty source map property `sources`', () => {\n                    assert.deepEqual(sourceMapSources, []);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return empty source map property `mappings`","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","empty source code"],"updatePoint":{"line":252,"column":70},"line":252,"code":"                it('should return empty source map property `mappings`', () => {\n                    assert.isNotOk(sourceMapMappings);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapSourceMode` is set","`sourcesContent` value"],"updatePoint":{"line":285,"column":61},"line":285,"code":"                    it('should return correct obfuscated code', () => {\n                        assert.isOk(obfuscatedCode);\n                    });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct source map mappings","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapSourceMode` is set","`sourcesContent` value"],"updatePoint":{"line":289,"column":65},"line":289,"code":"                    it('should return correct source map mappings', () => {\n                        assert.isOk(sourceMap.mappings);\n                    });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should define `sources` field for source map","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapSourceMode` is set","`sourcesContent` value"],"updatePoint":{"line":293,"column":68},"line":293,"code":"                    it('should define `sources` field for source map', () => {\n                        assert.property(sourceMap, 'sources');\n                    });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should define `sourcesContent` field for source map","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapSourceMode` is set","`sourcesContent` value"],"updatePoint":{"line":297,"column":75},"line":297,"code":"                    it('should define `sourcesContent` field for source map', () => {\n                        assert.property(sourceMap, 'sourcesContent');\n                    });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should define placeholder `sources` field for source map","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapSourceMode` is set","`sourcesContent` value"],"updatePoint":{"line":301,"column":80},"line":301,"code":"                    it('should define placeholder `sources` field for source map', () => {\n                        assert.deepEqual(sourceMap.sources, ['sourceMap']);\n                    });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should define `sourcesContent` value with source code","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapSourceMode` is set","`sourcesContent` value"],"updatePoint":{"line":305,"column":77},"line":305,"code":"                    it('should define `sourcesContent` value with source code', () => {\n                        assert.deepEqual(sourceMap.sourcesContent[0], code);\n                    });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should resolve correct sources from source map","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapSourceMode` is set","`sourcesContent` value"],"updatePoint":{"line":309,"column":70},"line":309,"code":"                    it('should resolve correct sources from source map', () => {\n                        assert.equal(resolvedSources, code);\n                    });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapSourceMode` is set","`sources` value","`inputFileName` option is set"],"updatePoint":{"line":336,"column":65},"line":336,"code":"                        it('should return correct obfuscated code', () => {\n                            assert.isOk(obfuscatedCode);\n                        });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct source map mappings","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapSourceMode` is set","`sources` value","`inputFileName` option is set"],"updatePoint":{"line":340,"column":69},"line":340,"code":"                        it('should return correct source map mappings', () => {\n                            assert.isOk(sourceMap.mappings);\n                        });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should define `sources` field for source map","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapSourceMode` is set","`sources` value","`inputFileName` option is set"],"updatePoint":{"line":344,"column":72},"line":344,"code":"                        it('should define `sources` field for source map', () => {\n                            assert.property(sourceMap, 'sources');\n                        });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should not define `sourcesContent` field for source map","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapSourceMode` is set","`sources` value","`inputFileName` option is set"],"updatePoint":{"line":348,"column":83},"line":348,"code":"                        it('should not define `sourcesContent` field for source map', () => {\n                            assert.notProperty(sourceMap, 'sourcesContent');\n                        });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should define placeholder `sources` field for source map","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapSourceMode` is set","`sources` value","`inputFileName` option is set"],"updatePoint":{"line":352,"column":84},"line":352,"code":"                        it('should define placeholder `sources` field for source map', () => {\n                            assert.deepEqual(sourceMap.sources, ['someFile.js']);\n                        });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error","suites":["JavaScriptObfuscator","obfuscate","`sourceMap` option is `true`","`sourceMapSourceMode` is set","`sources` value","`inputFileName` option is not set"],"updatePoint":{"line":372,"column":49},"line":372,"code":"                        it('should throw an error', () => {\n                            assert.throws(testFunc, Error);\n                        });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","variable inside global scope","Variant #1: without `renameGlobals` option"],"updatePoint":{"line":397,"column":57},"line":397,"code":"                it('should return correct obfuscated code', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","variable inside global scope","Variant #2: with `renameGlobals` option"],"updatePoint":{"line":419,"column":57},"line":419,"code":"                it('should return correct obfuscated code', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","variable inside global scope","Variant #3: with `renameGlobals` and `identifiersPrefix` options"],"updatePoint":{"line":442,"column":57},"line":442,"code":"                it('should return correct obfuscated code', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","variable inside global scope","Variant #4: with `stringArray`, `renameGlobals` and `identifiersPrefix` options"],"updatePoint":{"line":473,"column":67},"line":473,"code":"                it('match #1: should return correct obfuscated code', () => {\n                    assert.match(obfuscatedCode, stringArrayRegExp);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","variable inside global scope","Variant #4: with `stringArray`, `renameGlobals` and `identifiersPrefix` options"],"updatePoint":{"line":477,"column":67},"line":477,"code":"                it('match #2: should return correct obfuscated code', () => {\n                    assert.match(obfuscatedCode, stringArrayCallRegExp);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","variable inside block scope"],"updatePoint":{"line":499,"column":53},"line":499,"code":"            it('should return correct obfuscated code', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","variables inside global and block scopes","Variant #1: with `renameGlobals` and `identifiersPrefix` options"],"updatePoint":{"line":526,"column":67},"line":526,"code":"                it('match #1: should return correct obfuscated code', () => {\n                    assert.match(obfuscatedCode, variableDeclaration1);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","variables inside global and block scopes","Variant #1: with `renameGlobals` and `identifiersPrefix` options"],"updatePoint":{"line":530,"column":67},"line":530,"code":"                it('match #2: should return correct obfuscated code', () => {\n                    assert.match(obfuscatedCode, variableDeclaration2);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","variables inside global and block scopes","Variant #1: with `renameGlobals` and `identifiersPrefix` options"],"updatePoint":{"line":534,"column":67},"line":534,"code":"                it('match #3: should return correct obfuscated code', () => {\n                    assert.match(obfuscatedCode, variableDeclaration3);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"match #4: should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","variables inside global and block scopes","Variant #1: with `renameGlobals` and `identifiersPrefix` options"],"updatePoint":{"line":538,"column":67},"line":538,"code":"                it('match #4: should return correct obfuscated code', () => {\n                    assert.match(obfuscatedCode, functionDeclaration);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","latin literal variable value"],"updatePoint":{"line":563,"column":63},"line":563,"code":"            it('match #1: should return correct obfuscated code', () => {\n                assert.match(obfuscatedCode, stringArrayLatinRegExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","latin literal variable value"],"updatePoint":{"line":567,"column":63},"line":567,"code":"            it('match #2: should return correct obfuscated code', () => {\n                assert.match(obfuscatedCode, stringArrayCallRegExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","cyrillic literal variable value"],"updatePoint":{"line":596,"column":63},"line":596,"code":"            it('match #1: should return correct obfuscated code', () => {\n                assert.match(obfuscatedCode, stringArrayCyrillicRegExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscate","cyrillic literal variable value"],"updatePoint":{"line":600,"column":63},"line":600,"code":"            it('match #2: should return correct obfuscated code', () => {\n                assert.match(obfuscatedCode, stringArrayCallRegExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return same code every time with same `seed`","suites":["JavaScriptObfuscator","obfuscate","seed","same seed on each run"],"updatePoint":{"line":642,"column":71},"line":642,"code":"                it('should return same code every time with same `seed`', () => {\n                    assert.equal(equalsCount, samples);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return different obfuscated code with different `seed` option value","suites":["JavaScriptObfuscator","obfuscate","seed","Variant #1: different seed on each run"],"updatePoint":{"line":668,"column":94},"line":668,"code":"                it('should return different obfuscated code with different `seed` option value', () => {\n                    assert.notEqual(obfuscatedCode1, obfuscatedCode2);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return different obfuscated code with different `seed` option value","suites":["JavaScriptObfuscator","obfuscate","seed","Variant #2: different seed on each run"],"updatePoint":{"line":694,"column":94},"line":694,"code":"                it('should return different obfuscated code with different `seed` option value', () => {\n                    assert.notEqual(obfuscatedCode1, obfuscatedCode2);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return different String Array names for different source code with same seed","suites":["JavaScriptObfuscator","obfuscate","seed","Variant #3: same seed for different source code"],"updatePoint":{"line":733,"column":103},"line":733,"code":"                it('should return different String Array names for different source code with same seed', () => {\n                    assert.notEqual(match1, match2);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should not break on `ObjectPattern` with single `RestElement`","suites":["JavaScriptObfuscator","obfuscate","`ObjectPattern` with single `RestElement`"],"updatePoint":{"line":758,"column":77},"line":758,"code":"            it('should not break on `ObjectPattern` with single `RestElement`', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should generate a valid js code","suites":["JavaScriptObfuscator","obfuscate","Precedence of `SequenceExpression` in computed property"],"updatePoint":{"line":782,"column":47},"line":782,"code":"            it('should generate a valid js code', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should keep new.target MetaProperty","suites":["JavaScriptObfuscator","obfuscate","new.target MetaProperty"],"updatePoint":{"line":803,"column":51},"line":803,"code":"            it('should keep new.target MetaProperty', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should support `import.meta`","suites":["JavaScriptObfuscator","obfuscate","import.meta support"],"updatePoint":{"line":824,"column":44},"line":824,"code":"            it('should support `import.meta`', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should support `export * as` syntax","suites":["JavaScriptObfuscator","obfuscate","export * as"],"updatePoint":{"line":848,"column":51},"line":848,"code":"            it('should support `export * as` syntax', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should support exponentiation operator","suites":["JavaScriptObfuscator","obfuscate","valid exponentiation operator precedence"],"updatePoint":{"line":872,"column":54},"line":872,"code":"            it('should support exponentiation operator', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should support BigInt","suites":["JavaScriptObfuscator","obfuscate","BigInt support"],"updatePoint":{"line":893,"column":37},"line":893,"code":"            it('should support BigInt', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should support optional chaining","suites":["JavaScriptObfuscator","obfuscate","Optional chaining support"],"updatePoint":{"line":919,"column":48},"line":919,"code":"            it('should support optional chaining', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should support nullish coalescing operator","suites":["JavaScriptObfuscator","obfuscate","Nullish coalescing support"],"updatePoint":{"line":940,"column":58},"line":940,"code":"            it('should support nullish coalescing operator', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should support numeric separators","suites":["JavaScriptObfuscator","obfuscate","Numeric separators support"],"updatePoint":{"line":961,"column":49},"line":961,"code":"            it('should support numeric separators', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should support top-level await","suites":["JavaScriptObfuscator","obfuscate","Top-level await support"],"updatePoint":{"line":982,"column":46},"line":982,"code":"            it('should support top-level await', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should support class static block await","suites":["JavaScriptObfuscator","obfuscate","Class static block support"],"updatePoint":{"line":1018,"column":55},"line":1018,"code":"            it('should support class static block await', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should support private identifiers","suites":["JavaScriptObfuscator","obfuscate","Private identifiers support"],"updatePoint":{"line":1047,"column":50},"line":1047,"code":"            it('should support private identifiers', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should mangle obfuscated code","suites":["JavaScriptObfuscator","obfuscate","mangled identifier names generator"],"updatePoint":{"line":1071,"column":45},"line":1071,"code":"            it('should mangle obfuscated code', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should mangle obfuscated code","suites":["JavaScriptObfuscator","obfuscate","mangled shuffled identifier names generator"],"updatePoint":{"line":1092,"column":45},"line":1092,"code":"            it('should mangle obfuscated code', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should generate identifier based on the dictionary","suites":["JavaScriptObfuscator","obfuscate","dictionary identifier names generator"],"updatePoint":{"line":1116,"column":76},"line":1116,"code":"            it('Match #1: should generate identifier based on the dictionary', () => {\n                assert.match(obfuscatedCode, regExp1);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should generate identifier based on the dictionary","suites":["JavaScriptObfuscator","obfuscate","dictionary identifier names generator"],"updatePoint":{"line":1120,"column":76},"line":1120,"code":"            it('Match #2: should generate identifier based on the dictionary', () => {\n                assert.match(obfuscatedCode, regExp2);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should correctly obfuscate a import","suites":["JavaScriptObfuscator","obfuscate","parse module","Variant #1: import"],"updatePoint":{"line":1138,"column":65},"line":1138,"code":"                it('Match #1: should correctly obfuscate a import', () => {\n                    assert.match(obfuscatedCode, importRegExp);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should correctly obfuscate a module","suites":["JavaScriptObfuscator","obfuscate","parse module","Variant #1: import"],"updatePoint":{"line":1142,"column":65},"line":1142,"code":"                it('Match #2: should correctly obfuscate a module', () => {\n                    assert.match(obfuscatedCode, variableDeclarationRegExp);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly obfuscate a module","suites":["JavaScriptObfuscator","obfuscate","parse module","Variant #2: export"],"updatePoint":{"line":1158,"column":55},"line":1158,"code":"                it('should correctly obfuscate a module', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should correctly generate identifier names cache","suites":["JavaScriptObfuscator","obfuscate","identifier names cache generation","Variant #1: `identifierNamesCache` and `renameGlobal` options are enabled. Existing cache is passed"],"updatePoint":{"line":1196,"column":78},"line":1196,"code":"                it('Match #1: should correctly generate identifier names cache', () => {\n                    assert.deepEqual(identifierNamesCache, expectedIdentifierNamesCache);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should correctly generate identifier names cache","suites":["JavaScriptObfuscator","obfuscate","identifier names cache generation","Variant #2: `identifierNamesCache` and `renameGlobal` options are enabled"],"updatePoint":{"line":1229,"column":78},"line":1229,"code":"                it('Match #1: should correctly generate identifier names cache', () => {\n                    assert.deepEqual(identifierNamesCache, expectedIdentifierNamesCache);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should correctly generate identifier names cache","suites":["JavaScriptObfuscator","obfuscate","identifier names cache generation","Variant #3: `identifierNamesCache` and `renameGlobal` options are enabled. Source code without global variables"],"updatePoint":{"line":1259,"column":78},"line":1259,"code":"                it('Match #1: should correctly generate identifier names cache', () => {\n                    assert.deepEqual(identifierNamesCache, expectedIdentifierNamesCache);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should correctly generate identifier names cache","suites":["JavaScriptObfuscator","obfuscate","identifier names cache generation","Variant #4: `identifierNamesCache` option is disabled"],"updatePoint":{"line":1283,"column":78},"line":1283,"code":"                it('Match #1: should correctly generate identifier names cache', () => {\n                    assert.deepEqual(identifierNamesCache, expectedIdentifierNamesCache);\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly obfuscate 3.5k variables","suites":["JavaScriptObfuscator","obfuscate","3.5k variables"],"updatePoint":{"line":1337,"column":57},"line":1337,"code":"            it('should correctly obfuscate 3.5k variables', () => {\n                assert.equal(result, expectedValue);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate obfuscated code","suites":["JavaScriptObfuscator","obfuscate","Eval `Hello World`"],"updatePoint":{"line":1383,"column":57},"line":1383,"code":"            it('should correctly evaluate obfuscated code', () => {\n                assert.equal(isEvaluationSuccessful, true);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"It does not create identifier names collision","suites":["JavaScriptObfuscator","obfuscate","Identifier names collision between base code and appended string array nodes"],"updatePoint":{"line":1432,"column":61},"line":1432,"code":"            it('It does not create identifier names collision', () => {\n                assert.isNull(collisionError);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"does not break on run","suites":["JavaScriptObfuscator","obfuscate","Prevailing kind of variables","`var` kind"],"updatePoint":{"line":1471,"column":41},"line":1471,"code":"                it('does not break on run', () => {\n                    assert.doesNotThrow(() => eval(obfuscatedCode));\n                });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"does not break on run","suites":["JavaScriptObfuscator","obfuscate","Prevailing kind of variables","`const` kind","Variant #1: StringArrayEncoding: rc4"],"updatePoint":{"line":1494,"column":45},"line":1494,"code":"                    it('does not break on run', () => {\n                        assert.doesNotThrow(() => eval(obfuscatedCode));\n                    });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"does not break on run","suites":["JavaScriptObfuscator","obfuscate","Prevailing kind of variables","`const` kind","Variant #2: StringArrayEncoding: base64"],"updatePoint":{"line":1515,"column":45},"line":1515,"code":"                    it('does not break on run', () => {\n                        assert.doesNotThrow(() => eval(obfuscatedCode));\n                    });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"does not break on run","suites":["JavaScriptObfuscator","obfuscate","Prevailing kind of variables","`let` kind","Variant #1: StringArrayEncoding: rc4"],"updatePoint":{"line":1539,"column":45},"line":1539,"code":"                    it('does not break on run', () => {\n                        assert.doesNotThrow(() => eval(obfuscatedCode));\n                    });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"does not break on run","suites":["JavaScriptObfuscator","obfuscate","Prevailing kind of variables","`let` kind","Variant #2: StringArrayEncoding: base64"],"updatePoint":{"line":1561,"column":45},"line":1561,"code":"                    it('does not break on run', () => {\n                        assert.doesNotThrow(() => eval(obfuscatedCode));\n                    });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscateMultiple","multiple source codes"],"updatePoint":{"line":1595,"column":63},"line":1595,"code":"            it('Match #1: should return correct obfuscated code', () => {\n                assert.match(obfuscatedCode1, regExp1);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should return correct obfuscated code","suites":["JavaScriptObfuscator","obfuscateMultiple","multiple source codes"],"updatePoint":{"line":1599,"column":63},"line":1599,"code":"            it('Match #2: should return correct obfuscated code', () => {\n                assert.match(obfuscatedCode2, regExp2);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"Should throw an error if source codes object is not a plain object","suites":["JavaScriptObfuscator","obfuscateMultiple","invalid source codes object"],"updatePoint":{"line":1617,"column":82},"line":1617,"code":"            it('Should throw an error if source codes object is not a plain object', () => {\n                assert.throw(testFunc, Error);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"Should return options for passed options preset name","suites":["JavaScriptObfuscator","getOptionsByPreset","Variant #1: base behaviour"],"updatePoint":{"line":1633,"column":68},"line":1633,"code":"            it('Should return options for passed options preset name', () => {\n                assert.deepEqual(options, HIGH_OBFUSCATION_PRESET);\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"Should throws an error when unknown option preset is passed","suites":["JavaScriptObfuscator","getOptionsByPreset","Variant #2: unknown options preset name"],"updatePoint":{"line":1647,"column":75},"line":1647,"code":"            it('Should throws an error when unknown option preset is passed', () => {\n                assert.throws(testFunc, 'Options for preset name `foobar` are not found');\n            });","file":"functional-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should save statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #1: 5 simple statements","`console.log` statements"],"updatePoint":{"line":45,"column":41},"line":45,"code":"                it('should save statement', () => {\n                    assert.match(obfuscatedCode, statementRegExp1);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should save statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #1: 5 simple statements","`console.log` statements"],"updatePoint":{"line":49,"column":41},"line":49,"code":"                it('should save statement', () => {\n                    assert.match(obfuscatedCode, statementRegExp2);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should save statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #1: 5 simple statements","`console.log` statements"],"updatePoint":{"line":53,"column":41},"line":53,"code":"                it('should save statement', () => {\n                    assert.match(obfuscatedCode, statementRegExp3);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should save statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #1: 5 simple statements","`console.log` statements"],"updatePoint":{"line":57,"column":41},"line":57,"code":"                it('should save statement', () => {\n                    assert.match(obfuscatedCode, statementRegExp4);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should save statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #1: 5 simple statements","`console.log` statements"],"updatePoint":{"line":61,"column":41},"line":61,"code":"                it('should save statement', () => {\n                    assert.match(obfuscatedCode, statementRegExp5);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should wrap block statement statements in switch-case structure","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #1: 5 simple statements","block statement statements"],"updatePoint":{"line":77,"column":83},"line":77,"code":"                it('should wrap block statement statements in switch-case structure', () => {\n                    assert.match(obfuscatedCode, switchCaseRegExp);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"each statement should be wrapped by switch-case structure","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #1: 5 simple statements","block statement statements"],"updatePoint":{"line":81,"column":77},"line":81,"code":"                it('each statement should be wrapped by switch-case structure', () => {\n                    assert.equal(switchCaseLength, expectedSwitchCaseLength);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should create switch-case map variable","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #1: 5 simple statements","switch-case map"],"updatePoint":{"line":100,"column":58},"line":100,"code":"                it('should create switch-case map variable', () => {\n                    assert.match(obfuscatedCode, switchCaseMapVariableRegExp);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of index variable for switch-case map","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #1: 5 simple statements","switch-case map"],"updatePoint":{"line":104,"column":81},"line":104,"code":"                it('should use correct kind of index variable for switch-case map', () => {\n                    assert.match(obfuscatedCode, switchCaseMapIndexVariableRegExp);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should create valid switch-case map variable with order of switch cases sequence","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #1: 5 simple statements","switch-case map"],"updatePoint":{"line":108,"column":100},"line":108,"code":"                it('should create valid switch-case map variable with order of switch cases sequence', () => {\n                    assert.deepEqual(switchCaseMap, expectedSwitchCasesSequence);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should save statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #2: 5 simple statements inside while loop without break or continue statement","`console.log` statements"],"updatePoint":{"line":138,"column":41},"line":138,"code":"                it('should save statement', () => {\n                    assert.match(obfuscatedCode, statementRegExp1);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should save statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #2: 5 simple statements inside while loop without break or continue statement","`console.log` statements"],"updatePoint":{"line":142,"column":41},"line":142,"code":"                it('should save statement', () => {\n                    assert.match(obfuscatedCode, statementRegExp2);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should save statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #2: 5 simple statements inside while loop without break or continue statement","`console.log` statements"],"updatePoint":{"line":146,"column":41},"line":146,"code":"                it('should save statement', () => {\n                    assert.match(obfuscatedCode, statementRegExp3);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should save statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #2: 5 simple statements inside while loop without break or continue statement","`console.log` statements"],"updatePoint":{"line":150,"column":41},"line":150,"code":"                it('should save statement', () => {\n                    assert.match(obfuscatedCode, statementRegExp4);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should save statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #2: 5 simple statements inside while loop without break or continue statement","`console.log` statements"],"updatePoint":{"line":154,"column":41},"line":154,"code":"                it('should save statement', () => {\n                    assert.match(obfuscatedCode, statementRegExp5);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should wrap block statement statements in switch-case structure","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #2: 5 simple statements inside while loop without break or continue statement","block statement statements"],"updatePoint":{"line":170,"column":83},"line":170,"code":"                it('should wrap block statement statements in switch-case structure', () => {\n                    assert.match(obfuscatedCode, switchCaseRegExp);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"each statement should be wrapped by switch-case structure","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #2: 5 simple statements inside while loop without break or continue statement","block statement statements"],"updatePoint":{"line":174,"column":77},"line":174,"code":"                it('each statement should be wrapped by switch-case structure', () => {\n                    assert.equal(switchCaseLength, expectedSwitchCaseLength);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should create switch-case map variable","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #2: 5 simple statements inside while loop without break or continue statement","switch-case map"],"updatePoint":{"line":192,"column":58},"line":192,"code":"                it('should create switch-case map variable', () => {\n                    assert.match(obfuscatedCode, switchCaseMapVariableRegExp);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should create valid switch-case map variable with order of switch cases sequence","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #2: 5 simple statements inside while loop without break or continue statement","switch-case map"],"updatePoint":{"line":196,"column":100},"line":196,"code":"                it('should create valid switch-case map variable with order of switch cases sequence', () => {\n                    assert.deepEqual(switchCaseMap, expectedSwitchCasesSequence);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform block statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #3: statements length less then 5 statements"],"updatePoint":{"line":220,"column":52},"line":220,"code":"            it('shouldn\\'t transform block statement', () => {\n                assert.match(obfuscatedCode, statementRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform block statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #4: block statement contain variable declaration with `const` kind"],"updatePoint":{"line":243,"column":52},"line":243,"code":"            it('shouldn\\'t transform block statement', () => {\n                assert.match(obfuscatedCode, statementRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform block statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #5: block statement contain variable declaration with `let` kind"],"updatePoint":{"line":266,"column":52},"line":266,"code":"            it('shouldn\\'t transform block statement', () => {\n                assert.match(obfuscatedCode, statementRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform block statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #6: block statement contain break statement #1"],"updatePoint":{"line":289,"column":52},"line":289,"code":"            it('shouldn\\'t transform block statement', () => {\n                assert.match(obfuscatedCode, statementRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform block statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #7: block statement contain break statement #2"],"updatePoint":{"line":312,"column":52},"line":312,"code":"            it('shouldn\\'t transform block statement', () => {\n                assert.match(obfuscatedCode, statementRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform block statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #8: block statement contain break statement #3"],"updatePoint":{"line":335,"column":52},"line":335,"code":"            it('shouldn\\'t transform block statement', () => {\n                assert.match(obfuscatedCode, statementRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should wrap block statement statements in switch-case structure","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #9: block statement contain while statement with break statement"],"updatePoint":{"line":362,"column":79},"line":362,"code":"            it('should wrap block statement statements in switch-case structure', () => {\n                assert.match(obfuscatedCode, switchCaseRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"each statement should be wrapped by switch-case structure","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #9: block statement contain while statement with break statement"],"updatePoint":{"line":366,"column":73},"line":366,"code":"            it('each statement should be wrapped by switch-case structure', () => {\n                assert.equal(switchCaseLength, expectedSwitchCaseLength);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should wrap block statement statements in switch-case structure","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #10: block statement contain while statement with break statement"],"updatePoint":{"line":393,"column":79},"line":393,"code":"            it('should wrap block statement statements in switch-case structure', () => {\n                assert.match(obfuscatedCode, switchCaseRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"each statement should be wrapped by switch-case structure","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #10: block statement contain while statement with break statement"],"updatePoint":{"line":397,"column":73},"line":397,"code":"            it('each statement should be wrapped by switch-case structure', () => {\n                assert.equal(switchCaseLength, expectedSwitchCaseLength);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform block statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #11: block statement contain continue statement #1"],"updatePoint":{"line":420,"column":52},"line":420,"code":"            it('shouldn\\'t transform block statement', () => {\n                assert.match(obfuscatedCode, statementRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform block statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #12: block statement contain continue statement #2"],"updatePoint":{"line":443,"column":52},"line":443,"code":"            it('shouldn\\'t transform block statement', () => {\n                assert.match(obfuscatedCode, statementRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform block statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #13: block statement contain continue statement #3"],"updatePoint":{"line":466,"column":52},"line":466,"code":"            it('shouldn\\'t transform block statement', () => {\n                assert.match(obfuscatedCode, statementRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should wrap block statement statements in switch-case structure","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #14: block statement contain while statement with continue statement"],"updatePoint":{"line":493,"column":79},"line":493,"code":"            it('should wrap block statement statements in switch-case structure', () => {\n                assert.match(obfuscatedCode, switchCaseRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"each statement should be wrapped by switch-case structure","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #14: block statement contain while statement with continue statement"],"updatePoint":{"line":497,"column":73},"line":497,"code":"            it('each statement should be wrapped by switch-case structure', () => {\n                assert.equal(switchCaseLength, expectedSwitchCaseLength);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should wrap block statement statements in switch-case structure","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #15: block statement contain continue statement #4"],"updatePoint":{"line":524,"column":79},"line":524,"code":"            it('should wrap block statement statements in switch-case structure', () => {\n                assert.match(obfuscatedCode, switchCaseRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"each statement should be wrapped by switch-case structure","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #15: block statement contain continue statement #4"],"updatePoint":{"line":528,"column":73},"line":528,"code":"            it('each statement should be wrapped by switch-case structure', () => {\n                assert.equal(switchCaseLength, expectedSwitchCaseLength);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform block statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #16: block statement contain function declaration"],"updatePoint":{"line":551,"column":52},"line":551,"code":"            it('shouldn\\'t transform block statement', () => {\n                assert.match(obfuscatedCode, statementRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform block statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #17: block statement contain class declaration"],"updatePoint":{"line":574,"column":52},"line":574,"code":"            it('shouldn\\'t transform block statement', () => {\n                assert.match(obfuscatedCode, statementRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform block statement with `controlFlowFlatteningThreshold` chance","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #18: `controlFlowFlatteningThreshold` chance"],"updatePoint":{"line":614,"column":93},"line":614,"code":"            it('should transform block statement with `controlFlowFlatteningThreshold` chance', () => {\n                assert.closeTo(transformedStatementPercentage, controlFlowFlatteningThreshold, delta);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep block statement with (1 - `controlFlowFlatteningThreshold`) chance","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #18: `controlFlowFlatteningThreshold` chance"],"updatePoint":{"line":618,"column":94},"line":618,"code":"            it('should keep block statement with (1 - `controlFlowFlatteningThreshold`) chance', () => {\n                assert.closeTo(untouchedStatementPercentage, controlFlowFlatteningThreshold, delta);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should wrap block statement statements in switch-case structure","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #19: No `unreachable code after return statement` warning"],"updatePoint":{"line":646,"column":79},"line":646,"code":"            it('should wrap block statement statements in switch-case structure', () => {\n                assert.match(obfuscatedCode, switchCaseRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"each statement should be wrapped by switch-case structure","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #19: No `unreachable code after return statement` warning"],"updatePoint":{"line":650,"column":73},"line":650,"code":"            it('each statement should be wrapped by switch-case structure', () => {\n                assert.equal(switchCaseLength, expectedSwitchCaseLength);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not add `continue` statement after `return` statement","suites":["BlockStatementControlFlowTransformer","transformNode","Variant #19: No `unreachable code after return statement` warning"],"updatePoint":{"line":654,"column":76},"line":654,"code":"            it('should not add `continue` statement after `return` statement', () => {\n                assert.match(obfuscatedCode, returnStatementRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of variable for switch-case map","suites":["BlockStatementControlFlowTransformer","transformNode","Prevailing kind of variables","`var` kind","switch-case map"],"updatePoint":{"line":690,"column":79},"line":690,"code":"                    it('should use correct kind of variable for switch-case map', () => {\n                        assert.match(obfuscatedCode, switchCaseMapVariableRegExp);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of index variable for switch-case map","suites":["BlockStatementControlFlowTransformer","transformNode","Prevailing kind of variables","`var` kind","switch-case map"],"updatePoint":{"line":694,"column":85},"line":694,"code":"                    it('should use correct kind of index variable for switch-case map', () => {\n                        assert.match(obfuscatedCode, switchCaseMapIndexVariableRegExp);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of variable for switch cases sequence","suites":["BlockStatementControlFlowTransformer","transformNode","Prevailing kind of variables","`var` kind","switch-case map"],"updatePoint":{"line":698,"column":85},"line":698,"code":"                    it('should use correct kind of variable for switch cases sequence', () => {\n                        assert.deepEqual(switchCaseMap, expectedSwitchCasesSequence);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of variable for switch-case map","suites":["BlockStatementControlFlowTransformer","transformNode","Prevailing kind of variables","`const` kind","switch-case map"],"updatePoint":{"line":734,"column":79},"line":734,"code":"                    it('should use correct kind of variable for switch-case map', () => {\n                        assert.match(obfuscatedCode, switchCaseMapVariableRegExp);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of index variable for switch-case map","suites":["BlockStatementControlFlowTransformer","transformNode","Prevailing kind of variables","`const` kind","switch-case map"],"updatePoint":{"line":738,"column":85},"line":738,"code":"                    it('should use correct kind of index variable for switch-case map', () => {\n                        assert.match(obfuscatedCode, switchCaseMapIndexVariableRegExp);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of variable for switch cases sequence","suites":["BlockStatementControlFlowTransformer","transformNode","Prevailing kind of variables","`const` kind","switch-case map"],"updatePoint":{"line":742,"column":85},"line":742,"code":"                    it('should use correct kind of variable for switch cases sequence', () => {\n                        assert.deepEqual(switchCaseMap, expectedSwitchCasesSequence);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of variable for switch-case map","suites":["BlockStatementControlFlowTransformer","transformNode","Prevailing kind of variables","`let` kind","switch-case map"],"updatePoint":{"line":778,"column":79},"line":778,"code":"                    it('should use correct kind of variable for switch-case map', () => {\n                        assert.match(obfuscatedCode, switchCaseMapVariableRegExp);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of index variable for switch-case map","suites":["BlockStatementControlFlowTransformer","transformNode","Prevailing kind of variables","`let` kind","switch-case map"],"updatePoint":{"line":782,"column":85},"line":782,"code":"                    it('should use correct kind of index variable for switch-case map', () => {\n                        assert.match(obfuscatedCode, switchCaseMapIndexVariableRegExp);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of variable for switch cases sequence","suites":["BlockStatementControlFlowTransformer","transformNode","Prevailing kind of variables","`let` kind","switch-case map"],"updatePoint":{"line":786,"column":85},"line":786,"code":"                    it('should use correct kind of variable for switch cases sequence', () => {\n                        assert.deepEqual(switchCaseMap, expectedSwitchCasesSequence);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/block-statement-control-flow-transformer/BlockStatementControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace binary expression node with call to control flow storage node","suites":["BinaryExpressionControlFlowReplacer","replace","Variant #1 - single binary expression"],"updatePoint":{"line":35,"column":92},"line":35,"code":"            it('should replace binary expression node with call to control flow storage node', () => {\n                assert.match(obfuscatedCode, controlFlowStorageCallRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/binary-expression-control-flow-replacer/BinaryExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace binary expression node with call to control flow storage node","suites":["BinaryExpressionControlFlowReplacer","replace","Variant #2 - multiple binary expressions with threshold = 1"],"updatePoint":{"line":97,"column":92},"line":97,"code":"            it('should replace binary expression node with call to control flow storage node', () => {\n                assert.equal(matchErrorsCount, expectedMatchErrorsCount);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/binary-expression-control-flow-replacer/BinaryExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should use existing identifier for control flow storage with expected chance","suites":["BinaryExpressionControlFlowReplacer","replace","Variant #2 - multiple binary expressions with threshold = 1"],"updatePoint":{"line":101,"column":92},"line":101,"code":"            it('should use existing identifier for control flow storage with expected chance', () => {\n                assert.closeTo(usingExistingIdentifierChance, expectedChance, delta);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/binary-expression-control-flow-replacer/BinaryExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace call expression node with call to control flow storage node","suites":["CallExpressionControlFlowReplacer","replace","Variant #1 - single call expression"],"updatePoint":{"line":35,"column":90},"line":35,"code":"            it('should replace call expression node with call to control flow storage node', () => {\n                assert.match(obfuscatedCode, controlFlowStorageCallRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/call-expression-control-flow-replacer/CallExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace call expression node by call to control flow storage node","suites":["CallExpressionControlFlowReplacer","replace","Variant #2 - multiple call expressions with threshold = 1"],"updatePoint":{"line":97,"column":88},"line":97,"code":"            it('should replace call expression node by call to control flow storage node', () => {\n                assert.equal(matchErrorsCount, expectedMatchErrorsCount);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/call-expression-control-flow-replacer/CallExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should use existing identifier for control flow storage with expected chance","suites":["CallExpressionControlFlowReplacer","replace","Variant #2 - multiple call expressions with threshold = 1"],"updatePoint":{"line":101,"column":92},"line":101,"code":"            it('should use existing identifier for control flow storage with expected chance', () => {\n                assert.closeTo(usingExistingIdentifierChance, expectedChance, delta);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/call-expression-control-flow-replacer/CallExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't replace call expression node with call to control flow storage node","suites":["CallExpressionControlFlowReplacer","replace","Variant #3 - call expression callee is member expression node"],"updatePoint":{"line":126,"column":94},"line":126,"code":"            it('shouldn\\'t replace call expression node with call to control flow storage node', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/call-expression-control-flow-replacer/CallExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace call expression node with call to control flow storage node","suites":["CallExpressionControlFlowReplacer","replace","Variant #4 - rest as start call argument"],"updatePoint":{"line":156,"column":90},"line":156,"code":"            it('should replace call expression node with call to control flow storage node', () => {\n                assert.match(obfuscatedCode, controlFlowStorageCallRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/call-expression-control-flow-replacer/CallExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep rest parameter and rest call argument, but remove all function parameters after rest parameter","suites":["CallExpressionControlFlowReplacer","replace","Variant #4 - rest as start call argument"],"updatePoint":{"line":160,"column":122},"line":160,"code":"            it('should keep rest parameter and rest call argument, but remove all function parameters after rest parameter', () => {\n                assert.match(obfuscatedCode, controlFlowStorageNodeRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/call-expression-control-flow-replacer/CallExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace call expression node with call to control flow storage node","suites":["CallExpressionControlFlowReplacer","replace","Variant #5 - rest as middle call argument"],"updatePoint":{"line":190,"column":90},"line":190,"code":"            it('should replace call expression node with call to control flow storage node', () => {\n                assert.match(obfuscatedCode, controlFlowStorageCallRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/call-expression-control-flow-replacer/CallExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep rest parameter and rest call argument, but remove all function parameters after rest parameter","suites":["CallExpressionControlFlowReplacer","replace","Variant #5 - rest as middle call argument"],"updatePoint":{"line":194,"column":122},"line":194,"code":"            it('should keep rest parameter and rest call argument, but remove all function parameters after rest parameter', () => {\n                assert.match(obfuscatedCode, controlFlowStorageNodeRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/call-expression-control-flow-replacer/CallExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace call expression node with call to control flow storage node","suites":["CallExpressionControlFlowReplacer","replace","Variant #6 - rest as last call argument"],"updatePoint":{"line":224,"column":90},"line":224,"code":"            it('should replace call expression node with call to control flow storage node', () => {\n                assert.match(obfuscatedCode, controlFlowStorageCallRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/call-expression-control-flow-replacer/CallExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep rest parameter and rest call argument inside control flow storage node function","suites":["CallExpressionControlFlowReplacer","replace","Variant #6 - rest as last call argument"],"updatePoint":{"line":228,"column":107},"line":228,"code":"            it('should keep rest parameter and rest call argument inside control flow storage node function', () => {\n                assert.match(obfuscatedCode, controlFlowStorageNodeRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/call-expression-control-flow-replacer/CallExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace logical expression node with call to control flow storage node","suites":["LogicalExpressionControlFlowReplacer","replace","Variant #1 - single logical expression"],"updatePoint":{"line":35,"column":93},"line":35,"code":"            it('should replace logical expression node with call to control flow storage node', () => {\n                assert.match(obfuscatedCode, controlFlowStorageCallRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/logical-expression-control-flow-replacer/LogicalExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace logical expression node by call to control flow storage node","suites":["LogicalExpressionControlFlowReplacer","replace","Variant #2 - multiple logical expressions with threshold = 1"],"updatePoint":{"line":97,"column":91},"line":97,"code":"            it('should replace logical expression node by call to control flow storage node', () => {\n                assert.equal(matchErrorsCount, expectedMatchErrorsCount);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/logical-expression-control-flow-replacer/LogicalExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should use existing identifier for control flow storage with expected chance","suites":["LogicalExpressionControlFlowReplacer","replace","Variant #2 - multiple logical expressions with threshold = 1"],"updatePoint":{"line":101,"column":92},"line":101,"code":"            it('should use existing identifier for control flow storage with expected chance', () => {\n                assert.closeTo(usingExistingIdentifierChance, expectedChance, delta);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/logical-expression-control-flow-replacer/LogicalExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace logical unary expression with call to control flow storage node","suites":["LogicalExpressionControlFlowReplacer","replace","Variant #3 - single logical expression with unary expression"],"updatePoint":{"line":126,"column":94},"line":126,"code":"            it('should replace logical unary expression with call to control flow storage node', () => {\n                assert.match(obfuscatedCode, controlFlowStorageCallRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/logical-expression-control-flow-replacer/LogicalExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't replace prohibited expression nodes","suites":["LogicalExpressionControlFlowReplacer","replace","prohibited nodes Variant #1"],"updatePoint":{"line":151,"column":62},"line":151,"code":"            it('shouldn\\'t replace prohibited expression nodes', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/logical-expression-control-flow-replacer/LogicalExpressionControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should add string literal node as property of control flow storage node","suites":["StringLiteralControlFlowReplacer","replace","Variant #1 - base behavior"],"updatePoint":{"line":38,"column":87},"line":38,"code":"            it('should add string literal node as property of control flow storage node', () => {\n                assert.match(obfuscatedCode, controlFlowStorageStringLiteralRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/string-litertal-control-flow-replacer/StringLiteralControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace string literal node with call to control flow storage node","suites":["StringLiteralControlFlowReplacer","replace","Variant #1 - base behavior"],"updatePoint":{"line":42,"column":89},"line":42,"code":"            it('should replace string literal node with call to control flow storage node', () => {\n                assert.match(obfuscatedCode, controlFlowStorageCallRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/string-litertal-control-flow-replacer/StringLiteralControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should add string literal nodes with same values under same storage item","suites":["StringLiteralControlFlowReplacer","replace","Variant #2 - same storage key for same string values"],"updatePoint":{"line":72,"column":88},"line":72,"code":"            it('should add string literal nodes with same values under same storage item', () => {\n                assert.equal(storageCallsMatchesCount, expectedStorageCallsMatchesCount);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/control-flow-replacers/string-litertal-control-flow-replacer/StringLiteralControlFlowReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should add `control flow storage` node to the obfuscated code","suites":["FunctionControlFlowTransformer","transformNode","Variant #1 - single `control flow storage` node with single item"],"updatePoint":{"line":47,"column":77},"line":47,"code":"            it('should add `control flow storage` node to the obfuscated code', () => {\n                assert.match(obfuscatedCode, regexp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/function-control-flow-transformer/FunctionControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add two `control flow storage` nodes (root and inner) to the obfuscated code in different scopes","suites":["FunctionControlFlowTransformer","transformNode","Variant #2 - two `control flow storage` nodes: root and inner"],"updatePoint":{"line":97,"column":119},"line":97,"code":"            it('should add two `control flow storage` nodes (root and inner) to the obfuscated code in different scopes', () => {\n                assert.closeTo(appendToScopeThreshold, expectedAppendToScopeThreshold, delta);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/function-control-flow-transformer/FunctionControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add `control flow storage` node with multiple items to the obfuscated code","suites":["FunctionControlFlowTransformer","transformNode","Variant #3 - single `control flow storage` node with multiple items"],"updatePoint":{"line":129,"column":97},"line":129,"code":"            it('should add `control flow storage` node with multiple items to the obfuscated code', () => {\n                assert.match(obfuscatedCode, regexp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/function-control-flow-transformer/FunctionControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should't add control flow storage node","suites":["FunctionControlFlowTransformer","transformNode","Variant #4 - transformed node in the root block scope"],"updatePoint":{"line":152,"column":55},"line":152,"code":"            it('should\\'t add control flow storage node', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/function-control-flow-transformer/FunctionControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should't add control flow storage node to the root block scope","suites":["FunctionControlFlowTransformer","transformNode","Variant #5 - transformed nodes not in the root block scope"],"updatePoint":{"line":191,"column":79},"line":191,"code":"            it('should\\'t add control flow storage node to the root block scope', () => {\n                assert.equal(totalValue, expectedValue);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/function-control-flow-transformer/FunctionControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't add call to control flow storage node to the obfuscated code","suites":["FunctionControlFlowTransformer","transformNode","Variant #6 - threshold is `0`"],"updatePoint":{"line":215,"column":87},"line":215,"code":"            it('shouldn\\'t add call to control flow storage node to the obfuscated code', () => {\n                assert.match(obfuscatedCode, regexp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/function-control-flow-transformer/FunctionControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't add `control flow storage` node to the obfuscated code","suites":["FunctionControlFlowTransformer","transformNode","Variant #6 - threshold is `0`"],"updatePoint":{"line":219,"column":81},"line":219,"code":"            it('shouldn\\'t add `control flow storage` node to the obfuscated code', () => {\n                assert.notMatch(obfuscatedCode, controlFlowStorageRegExp);\n            });","file":"functional-tests/node-transformers/control-flow-transformers/function-control-flow-transformer/FunctionControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add `control flow storage` node to the obfuscated code","suites":["FunctionControlFlowTransformer","transformNode","Variant #7 - arrow function expression","Variant #1 - arrow function expression with body"],"updatePoint":{"line":243,"column":81},"line":243,"code":"                it('should add `control flow storage` node to the obfuscated code', () => {\n                    assert.match(obfuscatedCode, regexp);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/function-control-flow-transformer/FunctionControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't add `control flow storage` node to the obfuscated code","suites":["FunctionControlFlowTransformer","transformNode","Variant #7 - arrow function expression","Variant #2 - arrow function expression without body"],"updatePoint":{"line":266,"column":85},"line":266,"code":"                it('shouldn\\'t add `control flow storage` node to the obfuscated code', () => {\n                    assert.match(obfuscatedCode, regexp);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/function-control-flow-transformer/FunctionControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of variables for `control flow storage`","suites":["FunctionControlFlowTransformer","transformNode","Variant #8 - prevailing kind of variables","Variant #1 - `var` kind"],"updatePoint":{"line":291,"column":83},"line":291,"code":"                it('should use correct kind of variables for `control flow storage`', () => {\n                    assert.match(obfuscatedCode, regexp);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/function-control-flow-transformer/FunctionControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of variables for `control flow storage`","suites":["FunctionControlFlowTransformer","transformNode","Variant #8 - prevailing kind of variables","Variant #2 - `const` kind"],"updatePoint":{"line":314,"column":83},"line":314,"code":"                it('should use correct kind of variables for `control flow storage`', () => {\n                    assert.match(obfuscatedCode, regexp);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/function-control-flow-transformer/FunctionControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of variables for `control flow storage`","suites":["FunctionControlFlowTransformer","transformNode","Variant #8 - prevailing kind of variables","Variant #3 - `let` kind"],"updatePoint":{"line":337,"column":83},"line":337,"code":"                it('should use correct kind of variables for `control flow storage`', () => {\n                    assert.match(obfuscatedCode, regexp);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/function-control-flow-transformer/FunctionControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add `control flow storage` node to the obfuscated code","suites":["StringArrayControlFlowTransformer","transformNode","Variant #1 - hexadecimal number generator","Variant #1 - positive cases","Variant #1 - hexadecimal number items"],"updatePoint":{"line":57,"column":85},"line":57,"code":"                    it('should add `control flow storage` node to the obfuscated code', () => {\n                        assert.match(obfuscatedCode, controlFlowStorageRegExp);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/string-array-control-flow-transformer/StringArrayControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add calls to `control flow storage` node to the obfuscated code","suites":["StringArrayControlFlowTransformer","transformNode","Variant #1 - hexadecimal number generator","Variant #1 - positive cases","Variant #1 - hexadecimal number items"],"updatePoint":{"line":61,"column":94},"line":61,"code":"                    it('should add calls to `control flow storage` node to the obfuscated code', () => {\n                        assert.match(obfuscatedCode, controlFlowStorageCallRegExp);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/string-array-control-flow-transformer/StringArrayControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add `control flow storage` node to the obfuscated code","suites":["StringArrayControlFlowTransformer","transformNode","Variant #1 - hexadecimal number generator","Variant #1 - positive cases","Variant #2 - hexadecimal numeric string items"],"updatePoint":{"line":96,"column":85},"line":96,"code":"                    it('should add `control flow storage` node to the obfuscated code', () => {\n                        assert.match(obfuscatedCode, controlFlowStorageRegExp);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/string-array-control-flow-transformer/StringArrayControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add calls to `control flow storage` node to the obfuscated code","suites":["StringArrayControlFlowTransformer","transformNode","Variant #1 - hexadecimal number generator","Variant #1 - positive cases","Variant #2 - hexadecimal numeric string items"],"updatePoint":{"line":100,"column":94},"line":100,"code":"                    it('should add calls to `control flow storage` node to the obfuscated code', () => {\n                        assert.match(obfuscatedCode, controlFlowStorageCallRegExp);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/string-array-control-flow-transformer/StringArrayControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add `control flow storage` node to the obfuscated code in one of the scopes","suites":["StringArrayControlFlowTransformer","transformNode","Variant #1 - hexadecimal number generator","Variant #1 - positive cases","Variant #3 - two scopes for `control flow storage` node"],"updatePoint":{"line":157,"column":106},"line":157,"code":"                    it('should add `control flow storage` node to the obfuscated code in one of the scopes', () => {\n                        assert.closeTo(appendToScopeThreshold1, expectedAppendToScopeThreshold, delta);\n                        assert.closeTo(appendToScopeThreshold2, expectedAppendToScopeThreshold, delta);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/string-array-control-flow-transformer/StringArrayControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add `control flow storage` node with multiple items to the obfuscated code","suites":["StringArrayControlFlowTransformer","transformNode","Variant #1 - hexadecimal number generator","Variant #1 - positive cases","Variant #4 - single `control flow storage` node with four items"],"updatePoint":{"line":190,"column":105},"line":190,"code":"                    it('should add `control flow storage` node with multiple items to the obfuscated code', () => {\n                        assert.match(obfuscatedCode, regexp);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/string-array-control-flow-transformer/StringArrayControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add `control flow storage` node with multiple items to the obfuscated code","suites":["StringArrayControlFlowTransformer","transformNode","Variant #1 - hexadecimal number generator","Variant #1 - positive cases","Variant #5 - multiple `control flow storages` on the same block scope"],"updatePoint":{"line":227,"column":105},"line":227,"code":"                    it('should add `control flow storage` node with multiple items to the obfuscated code', () => {\n                        assert.match(obfuscatedCode, regexp);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/string-array-control-flow-transformer/StringArrayControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't add control flow storage node","suites":["StringArrayControlFlowTransformer","transformNode","Variant #1 - hexadecimal number generator","Variant #2 - negative cases","Variant #1 - string array call in the root block scope"],"updatePoint":{"line":258,"column":64},"line":258,"code":"                    it('shouldn\\'t add control flow storage node', () => {\n                        assert.notMatch(obfuscatedCode, controlFlowStorageRegExp);\n                        assert.match(obfuscatedCode, stringArrayCallsRegExp);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/string-array-control-flow-transformer/StringArrayControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't add control flow storage node","suites":["StringArrayControlFlowTransformer","transformNode","Variant #1 - hexadecimal number generator","Variant #2 - negative cases","Variant #2 - threshold is `0`"],"updatePoint":{"line":289,"column":64},"line":289,"code":"                    it('shouldn\\'t add control flow storage node', () => {\n                        assert.notMatch(obfuscatedCode, controlFlowStorageRegExp);\n                        assert.match(obfuscatedCode, stringArrayCallsRegExp);\n                    });","file":"functional-tests/node-transformers/control-flow-transformers/string-array-control-flow-transformer/StringArrayControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add `control flow storage` node to the obfuscated code","suites":["StringArrayControlFlowTransformer","transformNode","Variant #2 - mangled number generator","Variant #1 - single control flow storage"],"updatePoint":{"line":327,"column":81},"line":327,"code":"                it('should add `control flow storage` node to the obfuscated code', () => {\n                    assert.match(obfuscatedCode, controlFlowStorageRegExp);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/string-array-control-flow-transformer/StringArrayControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add calls to `control flow storage` node to the obfuscated code","suites":["StringArrayControlFlowTransformer","transformNode","Variant #2 - mangled number generator","Variant #1 - single control flow storage"],"updatePoint":{"line":331,"column":90},"line":331,"code":"                it('should add calls to `control flow storage` node to the obfuscated code', () => {\n                    assert.match(obfuscatedCode, controlFlowStorageCallRegExp);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/string-array-control-flow-transformer/StringArrayControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should add `control flow storage` №1 and its calls to the obfuscated code","suites":["StringArrayControlFlowTransformer","transformNode","Variant #2 - mangled number generator","Variant #2 - multiple control flow storages"],"updatePoint":{"line":375,"column":103},"line":375,"code":"                it('Match #1: should add `control flow storage` №1 and its calls to the obfuscated code', () => {\n                    assert.match(obfuscatedCode, controlFlowStorageRegExp1);\n                    assert.match(obfuscatedCode, controlFlowStorageCallRegExp1);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/string-array-control-flow-transformer/StringArrayControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should add `control flow storage` №2 and its calls to the obfuscated code","suites":["StringArrayControlFlowTransformer","transformNode","Variant #2 - mangled number generator","Variant #2 - multiple control flow storages"],"updatePoint":{"line":380,"column":103},"line":380,"code":"                it('Match #2: should add `control flow storage` №2 and its calls to the obfuscated code', () => {\n                    assert.match(obfuscatedCode, controlFlowStorageRegExp2);\n                    assert.match(obfuscatedCode, controlFlowStorageCallRegExp2);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/string-array-control-flow-transformer/StringArrayControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of variables for `control flow storage`","suites":["StringArrayControlFlowTransformer","transformNode","Variant #3 - prevailing kind of variables","Variant #1 - `var` kind"],"updatePoint":{"line":408,"column":83},"line":408,"code":"                it('should use correct kind of variables for `control flow storage`', () => {\n                    assert.match(obfuscatedCode, regexp);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/string-array-control-flow-transformer/StringArrayControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of variables for `control flow storage`","suites":["StringArrayControlFlowTransformer","transformNode","Variant #3 - prevailing kind of variables","Variant #2 - `const` kind"],"updatePoint":{"line":433,"column":83},"line":433,"code":"                it('should use correct kind of variables for `control flow storage`', () => {\n                    assert.match(obfuscatedCode, regexp);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/string-array-control-flow-transformer/StringArrayControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of variables for `control flow storage`","suites":["StringArrayControlFlowTransformer","transformNode","Variant #3 - prevailing kind of variables","Variant #3 - `let` kind"],"updatePoint":{"line":458,"column":83},"line":458,"code":"                it('should use correct kind of variables for `control flow storage`', () => {\n                    assert.match(obfuscatedCode, regexp);\n                });","file":"functional-tests/node-transformers/control-flow-transformers/string-array-control-flow-transformer/StringArrayControlFlowTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform boolean literal node","suites":["BooleanLiteralTransformer","transformation `true` boolean literal"],"updatePoint":{"line":28,"column":49},"line":28,"code":"        it('should transform boolean literal node', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/boolean-literal-transformer/BooleanLiteralTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform boolean literal node","suites":["BooleanLiteralTransformer","transformation `false` boolean literal"],"updatePoint":{"line":51,"column":49},"line":51,"code":"        it('should transform boolean literal node', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/boolean-literal-transformer/BooleanLiteralTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace method definition node `key` property with square brackets literal","suites":["ClassFieldTransformer","Variant #1: `MethodDefinition` node","Variant #1: identifier key","Variant #1: default behaviour"],"updatePoint":{"line":29,"column":101},"line":29,"code":"                it('should replace method definition node `key` property with square brackets literal', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add method definition node `key` property to string array","suites":["ClassFieldTransformer","Variant #1: `MethodDefinition` node","Variant #1: identifier key","Variant #2: `stringArray` option is enabled"],"updatePoint":{"line":53,"column":84},"line":53,"code":"                it('should add method definition node `key` property to string array', () => {\n                    assert.match(obfuscatedCode,  stringArrayRegExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace method definition node `key` property with call to string array","suites":["ClassFieldTransformer","Variant #1: `MethodDefinition` node","Variant #1: identifier key","Variant #2: `stringArray` option is enabled"],"updatePoint":{"line":57,"column":98},"line":57,"code":"                it('should replace method definition node `key` property with call to string array', () => {\n                    assert.match(obfuscatedCode,  stringArrayCallRegExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform method definition node with `constructor` key","suites":["ClassFieldTransformer","Variant #1: `MethodDefinition` node","Variant #1: identifier key","Variant #3: `constructor` key"],"updatePoint":{"line":78,"column":86},"line":78,"code":"                it('shouldn\\'t transform method definition node with `constructor` key', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace method definition node `key` property with square brackets literal","suites":["ClassFieldTransformer","Variant #1: `MethodDefinition` node","Variant #2: literal key","Variant #1: Default behaviour"],"updatePoint":{"line":101,"column":101},"line":101,"code":"                it('should replace method definition node `key` property with square brackets literal', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add method definition node `key` property to string array","suites":["ClassFieldTransformer","Variant #1: `MethodDefinition` node","Variant #2: literal key","Variant #2: `stringArray` option is enabled"],"updatePoint":{"line":125,"column":84},"line":125,"code":"                it('should add method definition node `key` property to string array', () => {\n                    assert.match(obfuscatedCode,  stringArrayRegExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace method definition node `key` property with call to string array","suites":["ClassFieldTransformer","Variant #1: `MethodDefinition` node","Variant #2: literal key","Variant #2: `stringArray` option is enabled"],"updatePoint":{"line":129,"column":98},"line":129,"code":"                it('should replace method definition node `key` property with call to string array', () => {\n                    assert.match(obfuscatedCode,  stringArrayCallRegExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform method definition node with `constructor` key","suites":["ClassFieldTransformer","Variant #1: `MethodDefinition` node","Variant #2: literal key","Variant #3: `constructor` key"],"updatePoint":{"line":150,"column":86},"line":150,"code":"                it('shouldn\\'t transform method definition node with `constructor` key', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should rename class declaration name","suites":["ClassFieldTransformer","Variant #1: `MethodDefinition` node","Variant #3: async `get()` method"],"updatePoint":{"line":173,"column":62},"line":173,"code":"            it('Match #1: should rename class declaration name', () => {\n                assert.match(obfuscatedCode, classDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should correctly rename async method name","suites":["ClassFieldTransformer","Variant #1: `MethodDefinition` node","Variant #3: async `get()` method"],"updatePoint":{"line":177,"column":67},"line":177,"code":"            it('Match #2: should correctly rename async method name', () => {\n                assert.match(obfuscatedCode, asyncMethodRegExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace property definition node `key` property with square brackets literal","suites":["ClassFieldTransformer","Variant #2: `PropertyDefinition` node","Variant #1: identifier key","Variant #1: default behaviour"],"updatePoint":{"line":201,"column":103},"line":201,"code":"                it('should replace property definition node `key` property with square brackets literal', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add property definition node `key` property to string array","suites":["ClassFieldTransformer","Variant #2: `PropertyDefinition` node","Variant #1: identifier key","Variant #2: `stringArray` option is enabled"],"updatePoint":{"line":225,"column":86},"line":225,"code":"                it('should add property definition node `key` property to string array', () => {\n                    assert.match(obfuscatedCode,  stringArrayRegExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace property definition node `key` property with call to string array","suites":["ClassFieldTransformer","Variant #2: `PropertyDefinition` node","Variant #1: identifier key","Variant #2: `stringArray` option is enabled"],"updatePoint":{"line":229,"column":100},"line":229,"code":"                it('should replace property definition node `key` property with call to string array', () => {\n                    assert.match(obfuscatedCode,  stringArrayCallRegExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace property definition node `key` property with square brackets literal","suites":["ClassFieldTransformer","Variant #2: `PropertyDefinition` node","Variant #2: literal key","Variant #1: Default behaviour"],"updatePoint":{"line":252,"column":103},"line":252,"code":"                it('should replace property definition node `key` property with square brackets literal', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add property definition node `key` property to string array","suites":["ClassFieldTransformer","Variant #2: `PropertyDefinition` node","Variant #2: literal key","Variant #2: `stringArray` option is enabled"],"updatePoint":{"line":276,"column":86},"line":276,"code":"                it('should add property definition node `key` property to string array', () => {\n                    assert.match(obfuscatedCode,  stringArrayRegExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace property definition node `key` property with call to string array","suites":["ClassFieldTransformer","Variant #2: `PropertyDefinition` node","Variant #2: literal key","Variant #2: `stringArray` option is enabled"],"updatePoint":{"line":280,"column":100},"line":280,"code":"                it('should replace property definition node `key` property with call to string array', () => {\n                    assert.match(obfuscatedCode,  stringArrayCallRegExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should rename class declaration name","suites":["ClassFieldTransformer","Variant #2: `PropertyDefinition` node","Variant #3: async `property` method"],"updatePoint":{"line":303,"column":62},"line":303,"code":"            it('Match #1: should rename class declaration name', () => {\n                assert.match(obfuscatedCode, classDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should correctly rename async property method name","suites":["ClassFieldTransformer","Variant #2: `PropertyDefinition` node","Variant #3: async `property` method"],"updatePoint":{"line":307,"column":76},"line":307,"code":"            it('Match #2: should correctly rename async property method name', () => {\n                assert.match(obfuscatedCode, asyncMethodRegExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/class-field-transformer/ClassFieldTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform export specifier node","suites":["ExportSpecifierTransformer","Variant #1: exported constant","Variant #1:`renameGlobals` option is enabled"],"updatePoint":{"line":31,"column":54},"line":31,"code":"            it('should transform export specifier node', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/export-specifier-transformer/ExportSpecifierTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not transform export specifier node","suites":["ExportSpecifierTransformer","Variant #1: exported constant","Variant #2: `renameGlobals` option is disabled"],"updatePoint":{"line":56,"column":58},"line":56,"code":"            it('should not transform export specifier node', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/export-specifier-transformer/ExportSpecifierTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform export specifier node","suites":["ExportSpecifierTransformer","Variant #2: exported import","Variant #1:`renameGlobals` option is enabled"],"updatePoint":{"line":83,"column":54},"line":83,"code":"            it('should transform export specifier node', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/export-specifier-transformer/ExportSpecifierTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform export specifier node","suites":["ExportSpecifierTransformer","Variant #2: exported import","Variant #2: `renameGlobals` option is disabled"],"updatePoint":{"line":108,"column":54},"line":108,"code":"            it('should transform export specifier node', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/export-specifier-transformer/ExportSpecifierTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace member expression dot notation call with literal value","suites":["MemberExpressionTransformer","transformation of member expression node with dot notation","`stringArray` option is disabled"],"updatePoint":{"line":28,"column":85},"line":28,"code":"            it('should replace member expression dot notation call with literal value', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/member-expression-transformer/MemberExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add member expression identifier to string array","suites":["MemberExpressionTransformer","transformation of member expression node with dot notation","`stringArray` option is enabled"],"updatePoint":{"line":52,"column":71},"line":52,"code":"            it('should add member expression identifier to string array', () => {\n                assert.match(obfuscatedCode, stringArrayRegExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/member-expression-transformer/MemberExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace member expression dot notation call with call to string array","suites":["MemberExpressionTransformer","transformation of member expression node with dot notation","`stringArray` option is enabled"],"updatePoint":{"line":56,"column":92},"line":56,"code":"            it('should replace member expression dot notation call with call to string array', () => {\n                assert.match(obfuscatedCode, stringArrayCallRegExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/member-expression-transformer/MemberExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add member expression square brackets literal to string array","suites":["MemberExpressionTransformer","transformation of member expression node with square brackets","Variant #1: square brackets literal "],"updatePoint":{"line":82,"column":84},"line":82,"code":"            it('should add member expression square brackets literal to string array', () => {\n                assert.match(obfuscatedCode, stringArrayRegExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/member-expression-transformer/MemberExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace member expression square brackets identifier with call to string array","suites":["MemberExpressionTransformer","transformation of member expression node with square brackets","Variant #1: square brackets literal "],"updatePoint":{"line":86,"column":101},"line":86,"code":"            it('should replace member expression square brackets identifier with call to string array', () => {\n                assert.match(obfuscatedCode, stringArrayCallRegExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/member-expression-transformer/MemberExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should ignore square brackets call with identifier value","suites":["MemberExpressionTransformer","transformation of member expression node with square brackets","Variant #2: square brackets identifier"],"updatePoint":{"line":107,"column":72},"line":107,"code":"            it('should ignore square brackets call with identifier value', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/member-expression-transformer/MemberExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform literal node","suites":["NumberLiteralTransformer","transformation of literal node with number value"],"updatePoint":{"line":28,"column":41},"line":28,"code":"        it('should transform literal node', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/number-literal-transformer/NumberLiteralTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform literal node","suites":["NumberLiteralTransformer","transformation of literal node with bigint value"],"updatePoint":{"line":51,"column":41},"line":51,"code":"        it('should transform literal node', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/number-literal-transformer/NumberLiteralTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform numbers to expressions","suites":["NumbersToNumericalExpressionsTransformer","Variant #1: base"],"updatePoint":{"line":37,"column":61},"line":37,"code":"        it('should correctly transform numbers to expressions', () => {\n            assert.isTrue(areValidExpressions);\n        });","file":"functional-tests/node-transformers/converting-transformers/numbers-to-numerical-expressions-transformer/NumbersToNumericalExpressionsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform numbers to expressions","suites":["NumbersToNumericalExpressionsTransformer","Variant #2: float number","Variant #1: Number `50.5`"],"updatePoint":{"line":68,"column":65},"line":68,"code":"            it('should correctly transform numbers to expressions', () => {\n                assert.isTrue(areValidExpressions);\n            });","file":"functional-tests/node-transformers/converting-transformers/numbers-to-numerical-expressions-transformer/NumbersToNumericalExpressionsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform numbers to expressions","suites":["NumbersToNumericalExpressionsTransformer","Variant #2: float number","Variant #2: Number `1e-13`"],"updatePoint":{"line":98,"column":65},"line":98,"code":"            it('should correctly transform numbers to expressions', () => {\n                assert.isTrue(areValidExpressions);\n            });","file":"functional-tests/node-transformers/converting-transformers/numbers-to-numerical-expressions-transformer/NumbersToNumericalExpressionsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform numbers to expressions","suites":["NumbersToNumericalExpressionsTransformer","Variant #2: float number","Variant #3: Number `-1e-100`"],"updatePoint":{"line":128,"column":65},"line":128,"code":"            it('should correctly transform numbers to expressions', () => {\n                assert.isTrue(areValidExpressions);\n            });","file":"functional-tests/node-transformers/converting-transformers/numbers-to-numerical-expressions-transformer/NumbersToNumericalExpressionsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform numbers to expressions","suites":["NumbersToNumericalExpressionsTransformer","Variant #3: safe integers","Variant #1: max safe integer"],"updatePoint":{"line":160,"column":65},"line":160,"code":"            it('should correctly transform numbers to expressions', () => {\n                assert.isTrue(areValidExpressions);\n            });","file":"functional-tests/node-transformers/converting-transformers/numbers-to-numerical-expressions-transformer/NumbersToNumericalExpressionsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not transform unsafe integer to expressions","suites":["NumbersToNumericalExpressionsTransformer","Variant #3: safe integers","Variant #2: max unsafe integer"],"updatePoint":{"line":181,"column":66},"line":181,"code":"            it('should not transform unsafe integer to expressions', () => {\n                assert.match(obfuscatedCode, unsafeIntegerRegExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/numbers-to-numerical-expressions-transformer/NumbersToNumericalExpressionsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform numbers to expressions","suites":["NumbersToNumericalExpressionsTransformer","Variant #3: safe integers","Variant #3: min safe integer"],"updatePoint":{"line":211,"column":65},"line":211,"code":"            it('should correctly transform numbers to expressions', () => {\n                assert.isTrue(areValidExpressions);\n            });","file":"functional-tests/node-transformers/converting-transformers/numbers-to-numerical-expressions-transformer/NumbersToNumericalExpressionsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not transform unsafe integer to expressions","suites":["NumbersToNumericalExpressionsTransformer","Variant #3: safe integers","Variant #4: min unsafe integer"],"updatePoint":{"line":232,"column":66},"line":232,"code":"            it('should not transform unsafe integer to expressions', () => {\n                assert.match(obfuscatedCode, unsafeIntegerRegExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/numbers-to-numerical-expressions-transformer/NumbersToNumericalExpressionsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not replace non-computed object property literal with expression","suites":["NumbersToNumericalExpressionsTransformer","Variant #4: parent node is non-computed object property"],"updatePoint":{"line":255,"column":83},"line":255,"code":"        it('should not replace non-computed object property literal with expression', () => {\n            assert.match(obfuscatedCode,  regExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/numbers-to-numerical-expressions-transformer/NumbersToNumericalExpressionsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace member expression with literal object with expression","suites":["NumbersToNumericalExpressionsTransformer","Variant #5: parent node is member expression"],"updatePoint":{"line":277,"column":80},"line":277,"code":"        it('should replace member expression with literal object with expression', () => {\n            assert.match(obfuscatedCode,  regExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/numbers-to-numerical-expressions-transformer/NumbersToNumericalExpressionsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #1: simple"],"updatePoint":{"line":37,"column":54},"line":37,"code":"            it('should correctly transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #2: variable declaration without initialization"],"updatePoint":{"line":66,"column":44},"line":66,"code":"            it('should transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #3: return statement"],"updatePoint":{"line":94,"column":45},"line":94,"code":"            it('shouldn transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #4: object expression inside array expression"],"updatePoint":{"line":122,"column":45},"line":122,"code":"            it('shouldn transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #5: object expression inside call expression"],"updatePoint":{"line":150,"column":45},"line":150,"code":"            it('shouldn transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #6: nested objects #1"],"updatePoint":{"line":182,"column":54},"line":182,"code":"            it('should correctly transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #7: nested objects #2"],"updatePoint":{"line":217,"column":54},"line":217,"code":"            it('should correctly transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #8: nested objects #3"],"updatePoint":{"line":252,"column":54},"line":252,"code":"            it('should correctly transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #9: correct integration with control flow flattening object #1"],"updatePoint":{"line":284,"column":54},"line":284,"code":"            it('should correctly transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #10: correct integration with control flow flattening object #2"],"updatePoint":{"line":320,"column":54},"line":320,"code":"            it('should correctly transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #11: variable declarator object call inside other variable declarator","Variant #1"],"updatePoint":{"line":349,"column":48},"line":349,"code":"                it('should transform object keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #11: variable declarator object call inside other variable declarator","Variant #2"],"updatePoint":{"line":377,"column":48},"line":377,"code":"                it('should transform object keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #11: variable declarator object call inside other variable declarator","Variant #3"],"updatePoint":{"line":402,"column":48},"line":402,"code":"                it('should transform object keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #12: assignment expression and member expression"],"updatePoint":{"line":431,"column":44},"line":431,"code":"            it('should transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #13: should keep numeric object keys"],"updatePoint":{"line":459,"column":54},"line":459,"code":"            it('should correctly transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #14: template literal"],"updatePoint":{"line":487,"column":45},"line":487,"code":"            it('shouldn transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore default parameter object if it references other parameter","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #15: function default values","Variant #1: base"],"updatePoint":{"line":516,"column":92},"line":516,"code":"                it('shouldn ignore default parameter object if it references other parameter', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: shouldn generate correct name for object host node","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #15: function default values","Variant #2: mangled name of object host node"],"updatePoint":{"line":550,"column":80},"line":550,"code":"                it('Match #1: shouldn generate correct name for object host node', () => {\n                    assert.match(obfuscatedCode,  regExp1);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: shouldn generate correct name for object host node","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #15: function default values","Variant #2: mangled name of object host node"],"updatePoint":{"line":554,"column":80},"line":554,"code":"                it('Match #2: shouldn generate correct name for object host node', () => {\n                    assert.match(obfuscatedCode,  regExp2);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform object expression keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #16: object expression inside variable declaration","Without reference on other property","Variant #1: Single variable declarator and object expression parent node is expression node"],"updatePoint":{"line":586,"column":63},"line":586,"code":"                    it('should transform object expression keys', () => {\n                        assert.match(obfuscatedCode,  regExp);\n                    });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform object expressions keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #16: object expression inside variable declaration","Without reference on other property","Variant #2: Multiple variable declarators and object expression parent node is variable declarator node"],"updatePoint":{"line":615,"column":64},"line":615,"code":"                    it('should transform object expressions keys', () => {\n                        assert.match(obfuscatedCode,  regExp);\n                    });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform first object expression keys and ignore second object expression keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #16: object expression inside variable declaration","With reference on other property","Variant #1: Object expression parent node is variable declarator node"],"updatePoint":{"line":645,"column":110},"line":645,"code":"                    it('should transform first object expression keys and ignore second object expression keys', () => {\n                        assert.match(obfuscatedCode,  regExp);\n                    });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform first object expression keys and ignore second object expression keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #16: object expression inside variable declaration","With reference on other property","Variant #2: Object expression parent node is any expression node"],"updatePoint":{"line":673,"column":110},"line":673,"code":"                    it('should transform first object expression keys and ignore second object expression keys', () => {\n                        assert.match(obfuscatedCode,  regExp);\n                    });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn transform sequence expression object expressions keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #17: sequence expression object expressions"],"updatePoint":{"line":707,"column":77},"line":707,"code":"            it('shouldn transform sequence expression object expressions keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn transform sequence expression object expressions keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #18: return statement sequence expression object expressions"],"updatePoint":{"line":740,"column":77},"line":740,"code":"            it('shouldn transform sequence expression object expressions keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn transform object expressions keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #19: object spread as member","Variant #1: object spread as first member"],"updatePoint":{"line":772,"column":61},"line":772,"code":"                it('shouldn transform object expressions keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn transform object expressions keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #19: object spread as member","Variant #2: object spread as middle member"],"updatePoint":{"line":805,"column":61},"line":805,"code":"                it('shouldn transform object expressions keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #20: `this` expression","Variant #1: base","Variant #1: `this` expression as object expression"],"updatePoint":{"line":836,"column":62},"line":836,"code":"                    it('should correctly transform object keys', () => {\n                        assert.match(obfuscatedCode,  regExp);\n                    });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #20: `this` expression","Variant #1: base","Variant #2: `this` expression as property value without `this` reference"],"updatePoint":{"line":863,"column":62},"line":863,"code":"                    it('should correctly transform object keys', () => {\n                        assert.match(obfuscatedCode,  regExp);\n                    });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #20: `this` expression","Variant #1: base","Variant #3: `this` expression as property value with `this` reference after object expression"],"updatePoint":{"line":891,"column":62},"line":891,"code":"                    it('should correctly transform object keys', () => {\n                        assert.match(obfuscatedCode,  regExp);\n                    });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #20: `this` expression","Variant #1: base","Variant #4: `this` expression as property value with `this` reference before and after object expression"],"updatePoint":{"line":920,"column":62},"line":920,"code":"                    it('should correctly transform object keys', () => {\n                        assert.match(obfuscatedCode,  regExp);\n                    });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","transformation of object keys","Variant #20: `this` expression","Variant #2: Sequence expression","Variant #1: sequence expression, `this` reference after object expression"],"updatePoint":{"line":950,"column":62},"line":950,"code":"                    it('should correctly transform object keys', () => {\n                        assert.match(obfuscatedCode,  regExp);\n                    });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","member expression as host of object expression","Variant #1: simple"],"updatePoint":{"line":982,"column":54},"line":982,"code":"            it('should correctly transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","member expression as host of object expression","Variant #2: long members chain"],"updatePoint":{"line":1010,"column":54},"line":1010,"code":"            it('should correctly transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #1: if statement","Variant #1: with block statement"],"updatePoint":{"line":1042,"column":58},"line":1042,"code":"                it('should correctly transform object keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #1: if statement","Variant #2: without block statement"],"updatePoint":{"line":1075,"column":58},"line":1075,"code":"                it('should correctly transform object keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #1: if statement","Variant #3: inside condition"],"updatePoint":{"line":1103,"column":58},"line":1103,"code":"                it('should correctly transform object keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #2: for statement","Variant #1: with block statement"],"updatePoint":{"line":1134,"column":58},"line":1134,"code":"                it('should correctly transform object keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #2: for statement","Variant #2: without block statement"],"updatePoint":{"line":1163,"column":58},"line":1163,"code":"                it('should correctly transform object keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #3: for in statement","Variant #1: with block statement"],"updatePoint":{"line":1195,"column":58},"line":1195,"code":"                it('should correctly transform object keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #3: for in statement","Variant #2: without block statement"],"updatePoint":{"line":1224,"column":58},"line":1224,"code":"                it('should correctly transform object keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #4: for of statement","Variant #1: with block statement"],"updatePoint":{"line":1256,"column":58},"line":1256,"code":"                it('should correctly transform object keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #4: for of statement","Variant #2: without block statement"],"updatePoint":{"line":1285,"column":58},"line":1285,"code":"                it('should correctly transform object keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #5: while statement","Variant #1: with block statement"],"updatePoint":{"line":1316,"column":58},"line":1316,"code":"                it('should correctly transform object keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #5: while statement","Variant #2: without block statement"],"updatePoint":{"line":1345,"column":58},"line":1345,"code":"                it('should correctly transform object keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #5: while statement","Variant #3: inside condition"],"updatePoint":{"line":1373,"column":58},"line":1373,"code":"                it('should correctly transform object keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #6: try statement"],"updatePoint":{"line":1404,"column":54},"line":1404,"code":"            it('should correctly transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #7: catch clause statement"],"updatePoint":{"line":1434,"column":54},"line":1434,"code":"            it('should correctly transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform object keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #8: switch catch statement"],"updatePoint":{"line":1464,"column":44},"line":1464,"code":"            it('should transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #9: variable declarator with object call","Variant #1"],"updatePoint":{"line":1493,"column":58},"line":1493,"code":"                it('should correctly transform object keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform object keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #9: variable declarator with object call","Variant #2"],"updatePoint":{"line":1522,"column":58},"line":1522,"code":"                it('should correctly transform object keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform objects keys","suites":["ObjectExpressionKeysTransformer","correct placement of expression statements","Variant #9: variable declarator with object call","Variant #3: two objects"],"updatePoint":{"line":1554,"column":59},"line":1554,"code":"                it('should correctly transform objects keys', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of variables","suites":["ObjectExpressionKeysTransformer","prevailing kind of variables","Variant #1: `var` kind`"],"updatePoint":{"line":1584,"column":52},"line":1584,"code":"            it('should use correct kind of variables', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of variables","suites":["ObjectExpressionKeysTransformer","prevailing kind of variables","Variant #2: `const` kind`"],"updatePoint":{"line":1611,"column":52},"line":1611,"code":"            it('should use correct kind of variables', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should use correct kind of variables","suites":["ObjectExpressionKeysTransformer","prevailing kind of variables","Variant #3: `let` kind`"],"updatePoint":{"line":1638,"column":52},"line":1638,"code":"            it('should use correct kind of variables', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform object keys","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #1: disabled option"],"updatePoint":{"line":1667,"column":48},"line":1667,"code":"            it('shouldn\\'t transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform object keys","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #2: empty object expression"],"updatePoint":{"line":1689,"column":48},"line":1689,"code":"            it('shouldn\\'t transform object keys', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore default parameter object if it references other parameter","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #3: function default value reference"],"updatePoint":{"line":1714,"column":88},"line":1714,"code":"            it('shouldn ignore default parameter object if it references other parameter', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore extraction of property with member expression key","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #4: member expression node as property key"],"updatePoint":{"line":1744,"column":80},"line":1744,"code":"            it('shouldn ignore extraction of property with member expression key', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore sequence expression object expression if it references other sequence expression identifier","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #5: sequence expression identifier reference"],"updatePoint":{"line":1774,"column":122},"line":1774,"code":"            it('shouldn ignore sequence expression object expression if it references other sequence expression identifier', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore sequence expression object expression if it references other sequence expression identifier","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #6: return statement sequence expression identifier reference","Variant #1: reference on other sequence expression identifier"],"updatePoint":{"line":1806,"column":126},"line":1806,"code":"                it('shouldn ignore sequence expression object expression if it references other sequence expression identifier', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore sequence expression object expression if it references other sequence expression identifier","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #6: return statement sequence expression identifier reference","Variant #2: reference on same sequence expression identifier"],"updatePoint":{"line":1835,"column":126},"line":1835,"code":"                it('shouldn ignore sequence expression object expression if it references other sequence expression identifier', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore conditional expression object expression if it references other conditional expression identifier","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #7: conditional expression identifier reference","Variant #1: conditional expression identifier reference"],"updatePoint":{"line":1865,"column":132},"line":1865,"code":"                it('shouldn ignore conditional expression object expression if it references other conditional expression identifier', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore conditional expression object expression if it references other conditional expression identifier","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #7: conditional expression identifier reference","Variant #2: return statement conditional expression identifier reference"],"updatePoint":{"line":1893,"column":132},"line":1893,"code":"                it('shouldn ignore conditional expression object expression if it references other conditional expression identifier', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore conditional expression object expression if it references other conditional expression identifier","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #7: conditional expression identifier reference","Variant #3: assignment expression conditional expression identifier reference"],"updatePoint":{"line":1922,"column":132},"line":1922,"code":"                it('shouldn ignore conditional expression object expression if it references other conditional expression identifier', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore conditional expression object expression if it references other conditional expression identifier","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #7: conditional expression identifier reference","Variant #4: variable declarator conditional expression identifier reference"],"updatePoint":{"line":1950,"column":132},"line":1950,"code":"                it('shouldn ignore conditional expression object expression if it references other conditional expression identifier', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore variable declarator object expression if it references other variable declarator identifier","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #8: variable declarator identifier reference"],"updatePoint":{"line":1977,"column":122},"line":1977,"code":"            it('shouldn ignore variable declarator object expression if it references other variable declarator identifier', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't ignore sequence expression object expression if this sequence expression contains super call expression","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #9: sequence expression super call expression"],"updatePoint":{"line":2003,"column":130},"line":2003,"code":"            it('shouldn\\'t ignore sequence expression object expression if this sequence expression contains super call expression', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly generate name for the computed key identifier","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #10: computed property key name"],"updatePoint":{"line":2031,"column":78},"line":2031,"code":"            it('should correctly generate name for the computed key identifier', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep property nodes with `get` and `set` kind in the object","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #11: `get` and `set` property kinds"],"updatePoint":{"line":2060,"column":82},"line":2060,"code":"            it('should keep property nodes with `get` and `set` kind in the object', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore object expressions keys transformation","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #12: object spread as last member"],"updatePoint":{"line":2093,"column":69},"line":2093,"code":"            it('shouldn ignore object expressions keys transformation', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore object expressions keys transformation","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #13: object expression as body of arrow function expression"],"updatePoint":{"line":2120,"column":69},"line":2120,"code":"            it('shouldn ignore object expressions keys transformation', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore sequence expression object expression if it references other sequence expression `this` expression`","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #14: sequence expression `this` reference"],"updatePoint":{"line":2146,"column":130},"line":2146,"code":"            it('shouldn ignore sequence expression object expression if it references other sequence expression `this` expression`', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore sequence expression object expression if it references other sequence expression `this` expression","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #15: return statement sequence expression `this` reference","Variant #1: reference on other sequence expression `this` expression`"],"updatePoint":{"line":2173,"column":133},"line":2173,"code":"                it('shouldn ignore sequence expression object expression if it references other sequence expression `this` expression', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore sequence expression object expression if it references other sequence expression `this` expression","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #15: return statement sequence expression `this` reference","Variant #2: reference on same sequence expression `this` expression"],"updatePoint":{"line":2199,"column":133},"line":2199,"code":"                it('shouldn ignore sequence expression object expression if it references other sequence expression `this` expression', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore conditional expression object expression if it references other conditional expression `this` expression","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #16: conditional expression `this` reference","Variant #1: conditional expression identifier reference"],"updatePoint":{"line":2228,"column":139},"line":2228,"code":"                it('shouldn ignore conditional expression object expression if it references other conditional expression `this` expression', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore conditional expression object expression if it references other conditional expression `this` expression","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #16: conditional expression `this` reference","Variant #2: return statement conditional expression `this` reference"],"updatePoint":{"line":2255,"column":139},"line":2255,"code":"                it('shouldn ignore conditional expression object expression if it references other conditional expression `this` expression', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore conditional expression object expression if it references other conditional expression `this` expression","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #16: conditional expression `this` reference","Variant #3: assignment expression conditional expression `this` reference"],"updatePoint":{"line":2282,"column":139},"line":2282,"code":"                it('shouldn ignore conditional expression object expression if it references other conditional expression `this` expression', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore variable declarator object expression if it references other variable declarator `this` expression","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #17: variable declarator `this` reference"],"updatePoint":{"line":2309,"column":129},"line":2309,"code":"            it('shouldn ignore variable declarator object expression if it references other variable declarator `this` expression', () => {\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore object expression if it contains a call expression as a direct property value","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #18: call expression as property value","Variant #1: call expression as a direct property value"],"updatePoint":{"line":2338,"column":112},"line":2338,"code":"                it('shouldn ignore object expression if it contains a call expression as a direct property value', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore object expression if it contains a call expression as an indirect property value","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #18: call expression as property value","Variant #2: call expression as an indirect property value"],"updatePoint":{"line":2366,"column":115},"line":2366,"code":"                it('shouldn ignore object expression if it contains a call expression as an indirect property value', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore object expression if it contains a call expression as a nested object expression as property value","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #18: call expression as property value","Variant #3: call expression as a nested object expression as property value"],"updatePoint":{"line":2396,"column":133},"line":2396,"code":"                it('shouldn ignore object expression if it contains a call expression as a nested object expression as property value', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore object expression if it contains a call expression and the previous property value is object expression","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #18: call expression as property value","Variant #4: call expression as a a property value after object expression property"],"updatePoint":{"line":2425,"column":138},"line":2425,"code":"                it('shouldn ignore object expression if it contains a call expression and the previous property value is object expression', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore object expression if it contains a new expression as a direct property value","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #19: new expression as property value","Variant #1: new expression as a direct property value"],"updatePoint":{"line":2455,"column":111},"line":2455,"code":"                it('shouldn ignore object expression if it contains a new expression as a direct property value', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore object expression if it contains a new expression as an indirect property value","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #19: new expression as property value","Variant #2: new expression as an indirect property value"],"updatePoint":{"line":2483,"column":114},"line":2483,"code":"                it('shouldn ignore object expression if it contains a new expression as an indirect property value', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore object expression if it contains a new expression as a nested object expression as property value","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #19: new expression as property value","Variant #3: new expression as a nested object expression as property value"],"updatePoint":{"line":2513,"column":132},"line":2513,"code":"                it('shouldn ignore object expression if it contains a new expression as a nested object expression as property value', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn ignore object expression if it contains a new expression and the previous property value is object expression","suites":["ObjectExpressionKeysTransformer","Ignore transformation","Variant #19: new expression as property value","Variant #4: new expression as a a property value after object expression property"],"updatePoint":{"line":2542,"column":137},"line":2542,"code":"                it('shouldn ignore object expression if it contains a new expression and the previous property value is object expression', () => {\n                    assert.match(obfuscatedCode,  regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-keys-transformer/ObjectExpressionKeysTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace object expression node `key` property with identifier value by property with literal value","suites":["ObjectExpressionTransformer","default behaviour","Variant #1: `unicodeEscapeSequence` option is disabled'"],"updatePoint":{"line":30,"column":121},"line":30,"code":"            it('should replace object expression node `key` property with identifier value by property with literal value', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-transformer/ObjectExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace object expression node `key` property with identifier value by property with encoded literal value","suites":["ObjectExpressionTransformer","default behaviour","Variant #2: `unicodeEscapeSequence` option is enabled"],"updatePoint":{"line":52,"column":129},"line":52,"code":"            it('should replace object expression node `key` property with identifier value by property with encoded literal value', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-transformer/ObjectExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correct convert shorthand ES6 object expression to non-shorthand object expression","suites":["ObjectExpressionTransformer","shorthand ES6 object expression"],"updatePoint":{"line":74,"column":101},"line":74,"code":"        it('should correct convert shorthand ES6 object expression to non-shorthand object expression', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/object-expression-transformer/ObjectExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should ignore computed property identifier","suites":["ObjectExpressionTransformer","computed property name","Variant #1: computed property name with identifier"],"updatePoint":{"line":96,"column":58},"line":96,"code":"            it('should ignore computed property identifier', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-expression-transformer/ObjectExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should ignore computed property literal value","suites":["ObjectExpressionTransformer","computed property name","Variant #2: computed property name with literal","Variant #1: `unicodeEscapeSequence` option is disabled"],"updatePoint":{"line":119,"column":65},"line":119,"code":"                it('should ignore computed property literal value', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-transformer/ObjectExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should encode computed property literal value","suites":["ObjectExpressionTransformer","computed property name","Variant #2: computed property name with literal","Variant #2: `unicodeEscapeSequence` option is enabled"],"updatePoint":{"line":141,"column":65},"line":141,"code":"                it('should encode computed property literal value', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/converting-transformers/object-expression-transformer/ObjectExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should transform object name","suites":["ObjectExpressionTransformer","object rest"],"updatePoint":{"line":167,"column":50},"line":167,"code":"        it('Match #1: should transform object name', () => {\n            assert.match(obfuscatedCode, objectRegExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/object-expression-transformer/ObjectExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should transform object rest construction","suites":["ObjectExpressionTransformer","object rest"],"updatePoint":{"line":171,"column":63},"line":171,"code":"        it('Match #2: should transform object rest construction', () => {\n            assert.match(obfuscatedCode, objectRestRegExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/object-expression-transformer/ObjectExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should transform object name","suites":["ObjectExpressionTransformer","object spread"],"updatePoint":{"line":194,"column":50},"line":194,"code":"        it('Match #1: should transform object name', () => {\n            assert.match(obfuscatedCode, object1RegExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/object-expression-transformer/ObjectExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should transform object name","suites":["ObjectExpressionTransformer","object spread"],"updatePoint":{"line":198,"column":50},"line":198,"code":"        it('Match #2: should transform object name', () => {\n            assert.match(obfuscatedCode, object2RegExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/object-expression-transformer/ObjectExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should transform object spread construction","suites":["ObjectExpressionTransformer","object spread"],"updatePoint":{"line":202,"column":65},"line":202,"code":"        it('Match #3: should transform object spread construction', () => {\n            assert.match(obfuscatedCode, objectSpreadRegExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/object-expression-transformer/ObjectExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should transform object declaration","suites":["ObjectExpressionTransformer","object spread: unicode escape sequence"],"updatePoint":{"line":229,"column":57},"line":229,"code":"        it('Match #1: should transform object declaration', () => {\n            assert.match(obfuscatedCode, object1RegExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/object-expression-transformer/ObjectExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should transform object name once","suites":["ObjectExpressionTransformer","object spread: unicode escape sequence"],"updatePoint":{"line":233,"column":55},"line":233,"code":"        it('Match #2: should transform object name once', () => {\n            assert.match(obfuscatedCode, object2RegExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/object-expression-transformer/ObjectExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: do not transform object name in spread assignment","suites":["ObjectExpressionTransformer","object spread: unicode escape sequence"],"updatePoint":{"line":237,"column":71},"line":237,"code":"        it('Match #3: do not transform object name in spread assignment', () => {\n            assert.match(obfuscatedCode, object3RegExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/object-expression-transformer/ObjectExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform object properties","suites":["ObjectPatternPropertiesTransformer","Variant #1: function scope","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":35,"column":50},"line":35,"code":"            it('should transform object properties', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-pattern-properties-transformer/ObjectPatternPropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform object properties","suites":["ObjectPatternPropertiesTransformer","Variant #1: function scope","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":64,"column":50},"line":64,"code":"            it('should transform object properties', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-pattern-properties-transformer/ObjectPatternPropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform object properties","suites":["ObjectPatternPropertiesTransformer","Variant #1: function scope","Variant #3: issue 781. Wrong parentize of cloned `propertyNode` value"],"updatePoint":{"line":95,"column":50},"line":95,"code":"            it('should transform object properties', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-pattern-properties-transformer/ObjectPatternPropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform object properties","suites":["ObjectPatternPropertiesTransformer","Variant #2: global scope","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":126,"column":50},"line":126,"code":"            it('should transform object properties', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-pattern-properties-transformer/ObjectPatternPropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform object properties","suites":["ObjectPatternPropertiesTransformer","Variant #2: global scope","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":155,"column":50},"line":155,"code":"            it('should transform object properties', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/object-pattern-properties-transformer/ObjectPatternPropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform string literal to binary expression","suites":["SplitStringTransformer","Variant #1: simple string literal"],"updatePoint":{"line":15,"column":64},"line":15,"code":"        it('should transform string literal to binary expression', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/simple-input.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    splitStrings: true,\n                    splitStringsChunkLength: 2\n                }\n            ).getObfuscatedCode();\n\n            assert.match(obfuscatedCode,  /^var test *= *'ab' *\\+ *'cd' *\\+ *'ef' *\\+ *'g';$/);\n        });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep original string literal","suites":["SplitStringTransformer","Variant #2: `splitStrings` option is disabled"],"updatePoint":{"line":32,"column":47},"line":32,"code":"        it('should keep original string literal', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/simple-input.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    splitStrings: false,\n                    splitStringsChunkLength: 10\n                }\n            ).getObfuscatedCode();\n\n            assert.match(obfuscatedCode,  /^var test *= *'abcdefg';$/);\n        });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep original string literal","suites":["SplitStringTransformer","Variant #3: `splitStringsChunkLength` value larger than string size"],"updatePoint":{"line":49,"column":47},"line":49,"code":"        it('should keep original string literal', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/simple-input.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    splitStrings: true,\n                    splitStringsChunkLength: 10\n                }\n            ).getObfuscatedCode();\n\n            assert.match(obfuscatedCode,  /^var test *= *'abcdefg';$/);\n        });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an validation error ","suites":["SplitStringTransformer","Variant #4: `splitStringsChunkLength` value is `0`"],"updatePoint":{"line":66,"column":45},"line":66,"code":"        it('should throw an validation error ', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/simple-input.js');\n\n            const testFunc = () => JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    splitStrings: true,\n                    splitStringsChunkLength: 0\n                }\n            );\n\n            assert.throws(testFunc, /validation failed/i);\n        });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform string literals to binary expressions","suites":["SplitStringTransformer","Variant #5: strings concatenation"],"updatePoint":{"line":83,"column":66},"line":83,"code":"        it('should transform string literals to binary expressions', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/strings-concatenation.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    splitStrings: true,\n                    splitStringsChunkLength: 2\n                }\n            ).getObfuscatedCode();\n\n            assert.match(obfuscatedCode,  /^var test *= *'ab' *\\+ *'cd' *\\+ *\\( *'ef' *\\+ *'g' *\\);$/);\n        });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should convert strings to unicode escape sequence view","suites":["SplitStringTransformer","Variant #6: unicode escape sequence"],"updatePoint":{"line":100,"column":66},"line":100,"code":"        it('should convert strings to unicode escape sequence view', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/simple-input.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    splitStrings: true,\n                    splitStringsChunkLength: 2,\n                    unicodeEscapeSequence: true\n                }\n            ).getObfuscatedCode();\n\n            assert.match(obfuscatedCode,  /^var test *= *'\\\\x61\\\\x62' *\\+ *'\\\\x63\\\\x64' *\\+ *'\\\\x65\\\\x66' *\\+ *'\\\\x67';$/);\n        });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should apply string splitting on template literal strings","suites":["SplitStringTransformer","Variant #7: template literal string"],"updatePoint":{"line":118,"column":69},"line":118,"code":"        it('should apply string splitting on template literal strings', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/template-literal-string.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    splitStrings: true,\n                    splitStringsChunkLength: 2\n                }\n            ).getObfuscatedCode();\n\n            assert.match(obfuscatedCode,  /^var test *= *'ab' *\\+ *'cd' *\\+ *'ef' *\\+ *'g';$/);\n        });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep original key string literal and transform value string literal","suites":["SplitStringTransformer","Variant #8: object string literal"],"updatePoint":{"line":135,"column":86},"line":135,"code":"        it('should keep original key string literal and transform value string literal', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/object-string-literal.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    splitStrings: true,\n                    splitStringsChunkLength: 2\n                }\n            ).getObfuscatedCode();\n\n            assert.match(obfuscatedCode,  /^var test *= *{'abcdefg' *: *'ab' *\\+ *'cd' *\\+ *'ef' *\\+ *'g'};$/);\n        });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform string literal to binary expression","suites":["SplitStringTransformer","Variant #9: object computed key string literal"],"updatePoint":{"line":152,"column":64},"line":152,"code":"        it('should transform string literal to binary expression', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/object-computed-key-string-literal.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    splitStrings: true,\n                    splitStringsChunkLength: 2\n                }\n            ).getObfuscatedCode();\n\n            assert.match(obfuscatedCode,  /^var test *= *{\\['ab' *\\+ *'cd' *\\+ *'ef' *\\+ *'g'] *: *0x1};$/);\n        });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly split string with emoji","suites":["SplitStringTransformer","Variant #10: string with emoji","Variant #1: single emoji"],"updatePoint":{"line":170,"column":56},"line":170,"code":"            it('should correctly split string with emoji', () => {\n                const regExp: RegExp = /^var test *= *'a' *\\+ *'b' *\\+ *'👋🏼' *\\+ *'c' *\\+ *'d'; *test;$/;\n\n                const code: string = readFileAsString(__dirname + '/fixtures/string-with-emoji-1.js');\n\n                obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                    code,\n                    {\n                        ...NO_ADDITIONAL_NODES_PRESET,\n                        splitStrings: true,\n                        splitStringsChunkLength: 1\n                    }\n                ).getObfuscatedCode();\n\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate splitted string with emoji","suites":["SplitStringTransformer","Variant #10: string with emoji","Variant #1: single emoji"],"updatePoint":{"line":187,"column":68},"line":187,"code":"            it('should correctly evaluate splitted string with emoji', () => {\n                const expectedResultString: string = 'ab👋🏼cd';\n\n                const code: string = readFileAsString(__dirname + '/fixtures/string-with-emoji-1.js');\n\n                obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                    code,\n                    {\n                        ...NO_ADDITIONAL_NODES_PRESET,\n                        splitStrings: true,\n                        splitStringsChunkLength: 1\n                    }\n                ).getObfuscatedCode();\n\n                const resultString: string = eval(obfuscatedCode);\n\n                assert.equal(resultString, expectedResultString);\n            });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly split string with emoji","suites":["SplitStringTransformer","Variant #10: string with emoji","Variant #2: multiple emoji"],"updatePoint":{"line":208,"column":56},"line":208,"code":"            it('should correctly split string with emoji', () => {\n                const regExp: RegExp = /^var test *= *'a' *\\+ *'b' *\\+ *'😴' *\\+ *'😄' *\\+ *'c' *\\+ *'d'; *test;$/;\n\n                const code: string = readFileAsString(__dirname + '/fixtures/string-with-emoji-2.js');\n\n                obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                    code,\n                    {\n                        ...NO_ADDITIONAL_NODES_PRESET,\n                        splitStrings: true,\n                        splitStringsChunkLength: 1\n                    }\n                ).getObfuscatedCode();\n\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate splitted string with emoji","suites":["SplitStringTransformer","Variant #10: string with emoji","Variant #2: multiple emoji"],"updatePoint":{"line":225,"column":68},"line":225,"code":"            it('should correctly evaluate splitted string with emoji', () => {\n                const expectedResultString: string = 'ab😴😄cd';\n\n                const code: string = readFileAsString(__dirname + '/fixtures/string-with-emoji-2.js');\n\n                obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                    code,\n                    {\n                        ...NO_ADDITIONAL_NODES_PRESET,\n                        splitStrings: true,\n                        splitStringsChunkLength: 1\n                    }\n                ).getObfuscatedCode();\n\n                const resultString: string = eval(obfuscatedCode);\n\n                assert.equal(resultString, expectedResultString);\n            });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly split string with emoji","suites":["SplitStringTransformer","Variant #10: string with emoji","Variant #3: correct split emoji"],"updatePoint":{"line":246,"column":56},"line":246,"code":"            it('should correctly split string with emoji', () => {\n                const regExp: RegExp = /^var test *= *'ab👋🏼' *\\+ *'cd'; *test;$/;\n\n                const code: string = readFileAsString(__dirname + '/fixtures/string-with-emoji-1.js');\n\n                obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                    code,\n                    {\n                        ...NO_ADDITIONAL_NODES_PRESET,\n                        splitStrings: true,\n                        splitStringsChunkLength: 3\n                    }\n                ).getObfuscatedCode();\n\n                assert.match(obfuscatedCode,  regExp);\n            });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate splitted string with emoji","suites":["SplitStringTransformer","Variant #10: string with emoji","Variant #3: correct split emoji"],"updatePoint":{"line":263,"column":68},"line":263,"code":"            it('should correctly evaluate splitted string with emoji', () => {\n                const expectedResultString: string = 'ab👋🏼cd';\n\n                const code: string = readFileAsString(__dirname + '/fixtures/string-with-emoji-1.js');\n\n                obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                    code,\n                    {\n                        ...NO_ADDITIONAL_NODES_PRESET,\n                        splitStrings: true,\n                        splitStringsChunkLength: 3\n                    }\n                ).getObfuscatedCode();\n\n                const resultString: string = eval(obfuscatedCode);\n\n                assert.equal(resultString, expectedResultString);\n            });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate splitted string with emoji","suites":["SplitStringTransformer","Variant #11: Integration with `stringArrayEncoding` option","Variant #1: base64 encoding","Variant #1: string with emoji","Variant #1: prevent URI-malformed error"],"updatePoint":{"line":288,"column":76},"line":288,"code":"                    it('should correctly evaluate splitted string with emoji', () => {\n                        const expectedResultString: string = 'ab👋🏼cd';\n\n                        const code: string = readFileAsString(__dirname + '/fixtures/string-with-emoji-1.js');\n\n                        obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                            code,\n                            {\n                                ...NO_ADDITIONAL_NODES_PRESET,\n                                splitStrings: true,\n                                splitStringsChunkLength: 3,\n                                stringArray: true,\n                                stringArrayThreshold: 1,\n                                stringArrayEncoding: [\n                                    StringArrayEncoding.Base64\n                                ]\n                            }\n                        ).getObfuscatedCode();\n\n                        const resultString: string = eval(obfuscatedCode);\n\n                        assert.equal(resultString, expectedResultString);\n                    });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform string when `transformObjectKeys` option is enabled","suites":["SplitStringTransformer","Variant #12: Integration with `transformObjectKeys` option"],"updatePoint":{"line":317,"column":90},"line":317,"code":"        it('should correctly transform string when `transformObjectKeys` option is enabled', () => {\n            const regExp: RegExp = new RegExp(`` +\n                `var _0x[a-f0-9]{4,6} *= *{};` +\n                `*_0x[a-f0-9]{4,6}\\\\['ab' *\\\\+ *'cd' *\\\\+ *'ef' *\\\\+ *'g'] *= *'ab' *\\\\+ *'cd' *\\\\+ *'ef' *\\\\+ *'g';` +\n                `var test *= *_0x[a-f0-9]{4,6};` +\n            ``);\n            const code: string = readFileAsString(__dirname + '/fixtures/object-string-literal.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    splitStrings: true,\n                    splitStringsChunkLength: 2,\n                    transformObjectKeys: true\n                }\n            ).getObfuscatedCode();\n\n            assert.match(\n                obfuscatedCode,\n                regExp\n            );\n        });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly ignore strings from `reservedStrings` option","suites":["SplitStringTransformer","Variant #13: Integration with `reservedStrings` option"],"updatePoint":{"line":343,"column":73},"line":343,"code":"        it('should correctly ignore strings from `reservedStrings` option', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/ignore-reserved-strings.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    splitStrings: true,\n                    splitStringsChunkLength: 3,\n                    reservedStrings: ['bar']\n                }\n            ).getObfuscatedCode();\n\n            assert.match(\n                obfuscatedCode,\n                /^var foo *= *'foo' *\\+ *'foo'; *var bar *= *'barbar'; *var baz *= *'baz' *\\+ *'baz';$/\n            );\n        });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should does not throw `Maximum call stack size exceeded` error on a large string","suites":["SplitStringTransformer","Variant #14: Large string"],"updatePoint":{"line":364,"column":92},"line":364,"code":"        it('Should does not throw `Maximum call stack size exceeded` error on a large string', () => {\n            const code: string = `var foo = '${'a'.repeat(10000)}';`;\n\n            const testFunc = () => JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    splitStrings: true,\n                    splitStringsChunkLength: 2\n                }\n            );\n\n            assert.doesNotThrow(\n                testFunc,\n                Error\n            );\n        });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should not split `ImportDeclaration` source literal","suites":["SplitStringTransformer","Variant #15: import declaration source literal"],"updatePoint":{"line":401,"column":63},"line":401,"code":"        it('Should not split `ImportDeclaration` source literal', () => {\n            assert.match(obfuscatedCode, importDeclarationRegExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should not split `ExportAllDeclaration` source literal","suites":["SplitStringTransformer","Variant #16: export all declaration source literal"],"updatePoint":{"line":424,"column":66},"line":424,"code":"        it('Should not split `ExportAllDeclaration` source literal', () => {\n            assert.match(obfuscatedCode, exportAllDeclarationRegExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should not split `ExportNamedDeclaration` source literal","suites":["SplitStringTransformer","Variant #17: export named declaration source literal"],"updatePoint":{"line":447,"column":68},"line":447,"code":"        it('Should not split `ExportNamedDeclaration` source literal', () => {\n            assert.match(obfuscatedCode, exportNamedDeclarationRegExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/split-string-transformer/SplitStringTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform es6 template literal to es5","suites":["TemplateLiteralTransformer","Variant #1: simple template literal"],"updatePoint":{"line":13,"column":56},"line":13,"code":"        it('should transform es6 template literal to es5', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/simple-input.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    unicodeEscapeSequence: false\n                }\n            ).getObfuscatedCode();\n\n            assert.match(obfuscatedCode,  /^var test *= *'abc\\\\x20' *\\+ *foo;$/);\n        });","file":"functional-tests/node-transformers/converting-transformers/template-literal-transformer/TemplateLiteralTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: should transform es6 multiline template literal to es5","suites":["TemplateLiteralTransformer","Variant #2: multiline template literals"],"updatePoint":{"line":29,"column":78},"line":29,"code":"        it('Variant #1: should transform es6 multiline template literal to es5', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/multiline-template-literal.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    unicodeEscapeSequence: false\n                }\n            ).getObfuscatedCode();\n\n            assert.match(obfuscatedCode,  /^var test *= *'foo\\\\x0abar';$/);\n        });","file":"functional-tests/node-transformers/converting-transformers/template-literal-transformer/TemplateLiteralTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #2: should transform es6 multiline template literal inside return statement","suites":["TemplateLiteralTransformer","Variant #2: multiline template literals"],"updatePoint":{"line":43,"column":95},"line":43,"code":"        it('Variant #2: should transform es6 multiline template literal inside return statement', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/multiline-template-literal-return-statement-1.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    unicodeEscapeSequence: false\n                }\n            ).getObfuscatedCode();\n\n            assert.match(obfuscatedCode,  /{ *return *'foo\\\\x0abar'; *}$/);\n        });","file":"functional-tests/node-transformers/converting-transformers/template-literal-transformer/TemplateLiteralTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #3: should transform es6 multiline template literal inside return statement","suites":["TemplateLiteralTransformer","Variant #2: multiline template literals"],"updatePoint":{"line":57,"column":95},"line":57,"code":"        it('Variant #3: should transform es6 multiline template literal inside return statement', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/multiline-template-literal-return-statement-2.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    unicodeEscapeSequence: false\n                }\n            ).getObfuscatedCode();\n\n            assert.match(obfuscatedCode,  /case *!!\\[] *: *return *'foo\\\\x0abar'; *} *}$/);\n        });","file":"functional-tests/node-transformers/converting-transformers/template-literal-transformer/TemplateLiteralTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #4: should transform es6 multiline template literal inside binary expression inside return statement","suites":["TemplateLiteralTransformer","Variant #2: multiline template literals"],"updatePoint":{"line":71,"column":120},"line":71,"code":"        it('Variant #4: should transform es6 multiline template literal inside binary expression inside return statement', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/multiline-template-literal-binary-expression-return-statement-1.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    unicodeEscapeSequence: false\n                }\n            ).getObfuscatedCode();\n\n            assert.match(obfuscatedCode,  /{ *return *'foo\\\\x0abar' *\\+ *0x1; *}$/);\n        });","file":"functional-tests/node-transformers/converting-transformers/template-literal-transformer/TemplateLiteralTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #5: should transform es6 multiline template literal inside binary expression inside return statement","suites":["TemplateLiteralTransformer","Variant #2: multiline template literals"],"updatePoint":{"line":85,"column":120},"line":85,"code":"        it('Variant #5: should transform es6 multiline template literal inside binary expression inside return statement', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/multiline-template-literal-binary-expression-return-statement-2.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    unicodeEscapeSequence: false\n                }\n            ).getObfuscatedCode();\n\n            assert.match(obfuscatedCode,  /case *!!\\[] *: *return *'foo\\\\x0abar' *\\+ *0x1; *} *}$/);\n        });","file":"functional-tests/node-transformers/converting-transformers/template-literal-transformer/TemplateLiteralTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform es6 template literal to es5 and add empty literal node before expression node","suites":["TemplateLiteralTransformer","Variant #3: simple template literal with expression only"],"updatePoint":{"line":101,"column":106},"line":101,"code":"        it('should transform es6 template literal to es5 and add empty literal node before expression node', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/expression-only.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    unicodeEscapeSequence: false\n                }\n            ).getObfuscatedCode();\n\n            assert.match(obfuscatedCode,  /^var test *= *'' *\\+ *foo;$/);\n        });","file":"functional-tests/node-transformers/converting-transformers/template-literal-transformer/TemplateLiteralTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform es6 template literal to es5","suites":["TemplateLiteralTransformer","Variant #4: literal node inside expression"],"updatePoint":{"line":117,"column":56},"line":117,"code":"        it('should transform es6 template literal to es5', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/literal-inside-expression.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    unicodeEscapeSequence: false\n                }\n            ).getObfuscatedCode();\n\n            assert.match(obfuscatedCode,  /^var test *= *'abc';$/);\n        });","file":"functional-tests/node-transformers/converting-transformers/template-literal-transformer/TemplateLiteralTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform es6 template literal to es5","suites":["TemplateLiteralTransformer","Variant #5: multiple expressions"],"updatePoint":{"line":133,"column":56},"line":133,"code":"        it('should transform es6 template literal to es5', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/multiple-expressions.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    unicodeEscapeSequence: false\n                }\n            ).getObfuscatedCode();\n\n            assert.match(\n                obfuscatedCode,\n                /^var test *= *0x1 *\\+ *0x1 *\\+ *'\\\\x20abc\\\\x20' *\\+ *\\(0x1 *\\+ *0x1\\);$/\n            );\n        });","file":"functional-tests/node-transformers/converting-transformers/template-literal-transformer/TemplateLiteralTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform es6 tagged template literal to es5","suites":["TemplateLiteralTransformer","Variant #6: tagged template literal"],"updatePoint":{"line":152,"column":67},"line":152,"code":"        it('shouldn\\'t transform es6 tagged template literal to es5', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/tagged-template-literal.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    unicodeEscapeSequence: false\n                }\n            ).getObfuscatedCode();\n\n            assert.match(\n                obfuscatedCode,\n                /tag`foo *\\${0x1 *\\+ *0x1} *bar`;/\n            );\n        });","file":"functional-tests/node-transformers/converting-transformers/template-literal-transformer/TemplateLiteralTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should parentize transformed template literal node","suites":["TemplateLiteralTransformer","Variant #7: template literal parentize"],"updatePoint":{"line":171,"column":62},"line":171,"code":"        it('should parentize transformed template literal node', () => {\n            const code: string = readFileAsString(__dirname + '/fixtures/template-literal-parentize.js');\n\n            obfuscatedCode = JavaScriptObfuscator.obfuscate(\n                code,\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    unicodeEscapeSequence: false\n                }\n            ).getObfuscatedCode();\n\n            assert.match(obfuscatedCode,  /^\\[]\\['map']\\(\\(\\) *=> *'foo'\\);$/);\n        });","file":"functional-tests/node-transformers/converting-transformers/template-literal-transformer/TemplateLiteralTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly obfuscate code without maximum call stack error","suites":["TemplateLiteralTransformer","Variant #8: parentize node"],"updatePoint":{"line":208,"column":76},"line":208,"code":"        it('should correctly obfuscate code without maximum call stack error', () => {\n            assert.match(obfuscatedCode,  regExp);\n        });","file":"functional-tests/node-transformers/converting-transformers/template-literal-transformer/TemplateLiteralTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace block statements with condition with original block statements and dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #1 - 5 simple block statements"],"updatePoint":{"line":53,"column":107},"line":53,"code":"            it('should replace block statements with condition with original block statements and dead code', () => {\n                assert.equal(matchesLength, expectedMatchesLength);\n            });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #2 - block statements count is less than `5`"],"updatePoint":{"line":89,"column":40},"line":89,"code":"            it('shouldn\\'t add dead code', () => {\n                assert.equal(matchesLength, expectedMatchesLength);\n            });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #3 - deadCodeInjectionThreshold: 0"],"updatePoint":{"line":125,"column":40},"line":125,"code":"            it('shouldn\\'t add dead code', () => {\n                assert.equal(matchesLength, expectedMatchesLength);\n            });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #4 - prohibited node inside collected block statement","Variant #1 - function declaration in block statement"],"updatePoint":{"line":173,"column":54},"line":173,"code":"                it('match #1: shouldn\\'t add dead code', () => {\n                    assert.equal(functionMatchesLength, expectedFunctionMatchesLength);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #4 - prohibited node inside collected block statement","Variant #1 - function declaration in block statement"],"updatePoint":{"line":177,"column":54},"line":177,"code":"                it('match #2: shouldn\\'t add dead code', () => {\n                    assert.equal(functionDeclarationMatchesLength, expectedFunctionDeclarationMatchesLength);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #4 - prohibited node inside collected block statement","Variant #2 - break or continue statement in block statement","Variant #1"],"updatePoint":{"line":227,"column":58},"line":227,"code":"                    it('match #1: shouldn\\'t add dead code', () => {\n                        assert.equal(functionMatchesLength, expectedFunctionMatchesLength);\n                    });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #4 - prohibited node inside collected block statement","Variant #2 - break or continue statement in block statement","Variant #1"],"updatePoint":{"line":231,"column":58},"line":231,"code":"                    it('match #2: shouldn\\'t add dead code', () => {\n                        assert.equal(loopMatchesLength, expectedLoopMatchesLength);\n                    });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #4 - prohibited node inside collected block statement","Variant #2 - break or continue statement in block statement","Variant #2"],"updatePoint":{"line":279,"column":58},"line":279,"code":"                    it('match #1: shouldn\\'t add dead code', () => {\n                        assert.equal(functionMatchesLength, expectedFunctionMatchesLength);\n                    });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #4 - prohibited node inside collected block statement","Variant #2 - break or continue statement in block statement","Variant #2"],"updatePoint":{"line":283,"column":58},"line":283,"code":"                    it('match #2: shouldn\\'t add dead code', () => {\n                        assert.equal(loopMatchesLength, expectedLoopMatchesLength);\n                    });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #4 - prohibited node inside collected block statement","Variant #3 - await expression in block statement"],"updatePoint":{"line":331,"column":54},"line":331,"code":"                it('match #1: shouldn\\'t add dead code', () => {\n                    assert.equal(functionMatchesLength, expectedFunctionMatchesLength);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #4 - prohibited node inside collected block statement","Variant #3 - await expression in block statement"],"updatePoint":{"line":335,"column":54},"line":335,"code":"                it('match #2: shouldn\\'t add dead code', () => {\n                    assert.equal(awaitExpressionMatchesLength, expectedAwaitExpressionMatchesLength);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #4 - prohibited node inside collected block statement","Variant #4 - yield expression in block statement"],"updatePoint":{"line":382,"column":54},"line":382,"code":"                it('match #1: shouldn\\'t add dead code', () => {\n                    assert.equal(functionMatchesLength, expectedFunctionMatchesLength);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #4 - prohibited node inside collected block statement","Variant #4 - yield expression in block statement"],"updatePoint":{"line":386,"column":54},"line":386,"code":"                it('match #2: shouldn\\'t add dead code', () => {\n                    assert.equal(yieldExpressionMatchesLength, expectedAwaitExpressionMatchesLength);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #4 - prohibited node inside collected block statement","Variant #5 - super expression in block statement"],"updatePoint":{"line":433,"column":54},"line":433,"code":"                it('match #1: shouldn\\'t add dead code', () => {\n                    assert.equal(functionMatchesLength, expectedFunctionMatchesLength);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #4 - prohibited node inside collected block statement","Variant #5 - super expression in block statement"],"updatePoint":{"line":437,"column":54},"line":437,"code":"                it('match #2: shouldn\\'t add dead code', () => {\n                    assert.equal(superExpressionMatchesLength, expectedSuperExpressionMatchesLength);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #4 - prohibited node inside collected block statement","Variant #6 - for-await expression in block statement"],"updatePoint":{"line":484,"column":54},"line":484,"code":"                it('match #1: shouldn\\'t add dead code', () => {\n                    assert.equal(functionMatchesLength, expectedFunctionMatchesLength);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #4 - prohibited node inside collected block statement","Variant #6 - for-await expression in block statement"],"updatePoint":{"line":488,"column":54},"line":488,"code":"                it('match #2: shouldn\\'t add dead code', () => {\n                    assert.equal(awaitExpressionMatchesLength, expectedAwaitExpressionMatchesLength);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #4 - prohibited node inside collected block statement","Variant #7 - private identifier in block statement"],"updatePoint":{"line":535,"column":54},"line":535,"code":"                it('match #1: shouldn\\'t add dead code', () => {\n                    assert.equal(functionMatchesLength, expectedFunctionMatchesLength);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't add dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #4 - prohibited node inside collected block statement","Variant #7 - private identifier in block statement"],"updatePoint":{"line":539,"column":54},"line":539,"code":"                it('match #2: shouldn\\'t add dead code', () => {\n                    assert.equal(privateIdentifierMatchesLength, expectedPrivateIdentifierMatchesLength);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: `IfStatement` variant should have distribution close to `0.25`","suites":["DeadCodeInjectionTransformer","transformNode","Variant #5 - chance of `IfStatement` variant"],"updatePoint":{"line":630,"column":90},"line":630,"code":"            it('Variant #1: `IfStatement` variant should have distribution close to `0.25`', () => {\n                assert.closeTo(distribution1, expectedDistribution, delta);\n            });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #2: `IfStatement` variant should have distribution close to `0.25`","suites":["DeadCodeInjectionTransformer","transformNode","Variant #5 - chance of `IfStatement` variant"],"updatePoint":{"line":634,"column":90},"line":634,"code":"            it('Variant #2: `IfStatement` variant should have distribution close to `0.25`', () => {\n                assert.closeTo(distribution2, expectedDistribution, delta);\n            });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #3: `IfStatement` variant should have distribution close to `0.25`","suites":["DeadCodeInjectionTransformer","transformNode","Variant #5 - chance of `IfStatement` variant"],"updatePoint":{"line":638,"column":90},"line":638,"code":"            it('Variant #3: `IfStatement` variant should have distribution close to `0.25`', () => {\n                assert.closeTo(distribution3, expectedDistribution, delta);\n            });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #4: `IfStatement` variant should have distribution close to `0.25`","suites":["DeadCodeInjectionTransformer","transformNode","Variant #5 - chance of `IfStatement` variant"],"updatePoint":{"line":642,"column":90},"line":642,"code":"            it('Variant #4: `IfStatement` variant should have distribution close to `0.25`', () => {\n                assert.closeTo(distribution4, expectedDistribution, delta);\n            });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't add dead code in block statements with `ProgramNode` block scope","suites":["DeadCodeInjectionTransformer","transformNode","Variant #6 - block scope of block statement is `ProgramNode`"],"updatePoint":{"line":671,"column":91},"line":671,"code":"            it('shouldn\\'t add dead code in block statements with `ProgramNode` block scope', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly obfuscate dead-code block statements and prevent any exposing of internal variable names","suites":["DeadCodeInjectionTransformer","transformNode","Variant #7 - correct obfuscation of dead-code block statements"],"updatePoint":{"line":695,"column":121},"line":695,"code":"            it('should correctly obfuscate dead-code block statements and prevent any exposing of internal variable names', () => {\n                assert.notInclude(obfuscatedCode, variableName);\n            });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should generate separate identifiers for common AST and dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #8 - unique names for dead code identifiers","Variant #1"],"updatePoint":{"line":818,"column":85},"line":818,"code":"                it('should generate separate identifiers for common AST and dead code', () => {\n                    assert.isOk(result, 'wrong identifier names');\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should generate separate identifiers for common AST and dead code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #8 - unique names for dead code identifiers","Variant #2"],"updatePoint":{"line":883,"column":85},"line":883,"code":"                it('should generate separate identifiers for common AST and dead code', () => {\n                    assert.isOk(result, 'wrong identifier names');\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't add dead code conditions to the block empty block statements","suites":["DeadCodeInjectionTransformer","transformNode","Variant #9 - block statements with empty body"],"updatePoint":{"line":920,"column":87},"line":920,"code":"            it('shouldn\\'t add dead code conditions to the block empty block statements', () => {\n                assert.isAtLeast(matchesLength, expectedMatchesLength);\n            });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't collect block statements with scope-hoisting","suites":["DeadCodeInjectionTransformer","transformNode","Variant #10 - block statement with scope-hoisting","Variant #1: collecting of block statements"],"updatePoint":{"line":958,"column":75},"line":958,"code":"                it('shouldn\\'t collect block statements with scope-hoisting', () => {\n                    assert.equal(matchesLength, expectedMatchesLength);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't wrap block statements in dead code conditions","suites":["DeadCodeInjectionTransformer","transformNode","Variant #10 - block statement with scope-hoisting","Variant #2: wrapping of block statements in dead code conditions"],"updatePoint":{"line":992,"column":76},"line":992,"code":"                it('shouldn\\'t wrap block statements in dead code conditions', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: shouldn't replace kinds of variables of inserted original code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #11 - prevailing kind of variables of inserted code","Variant #1: base"],"updatePoint":{"line":1035,"column":93},"line":1035,"code":"                it('Match #1: shouldn\\'t replace kinds of variables of inserted original code', () => {\n                    assert.match(obfuscatedCode, variableDeclarationsRegExp);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: shouldn't replace kinds of variables of inserted original code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #11 - prevailing kind of variables of inserted code","Variant #1: base"],"updatePoint":{"line":1039,"column":93},"line":1039,"code":"                it('Match #2: shouldn\\'t replace kinds of variables of inserted original code', () => {\n                    assert.notMatch(obfuscatedCode, invalidVariableDeclarationsRegExp);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: shouldn't replace kinds of variables of inserted original code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #11 - prevailing kind of variables of inserted code","Variant #1: base"],"updatePoint":{"line":1043,"column":93},"line":1043,"code":"                it('Match #3: shouldn\\'t replace kinds of variables of inserted original code', () => {\n                    assert.match(obfuscatedCode, forLoopRegExp);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #4: shouldn't replace kinds of variables of inserted original code","suites":["DeadCodeInjectionTransformer","transformNode","Variant #11 - prevailing kind of variables of inserted code","Variant #1: base"],"updatePoint":{"line":1047,"column":93},"line":1047,"code":"                it('Match #4: shouldn\\'t replace kinds of variables of inserted original code', () => {\n                    assert.notMatch(obfuscatedCode, invalidForLoopRegExp);\n                });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should unwrap dead code injection root AST host node before the string array transformer","suites":["DeadCodeInjectionTransformer","transformNode","Variant #12 - correct integration with `stringArrayWrappersChainedCalls` option"],"updatePoint":{"line":1089,"column":104},"line":1089,"code":"            it('should unwrap dead code injection root AST host node before the string array transformer', () => {\n                assert.equal(matchesLength, expectedMatchesLength);\n            });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't add dead code to the eval call expression","suites":["DeadCodeInjectionTransformer","transformNode","Variant #13 - correct integration with `EvalCallExpressionTransformer`"],"updatePoint":{"line":1118,"column":78},"line":1118,"code":"            it('match #1: shouldn\\'t add dead code to the eval call expression', () => {\n                assert.notMatch(obfuscatedCode, evalWithDeadCodeRegExp);\n            });","file":"functional-tests/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep directive at the top of program scope","suites":["DirectivePlacementTransformer","Variant #1: program scope","Variant #1: directive at the top of program scope"],"updatePoint":{"line":35,"column":65},"line":35,"code":"            it('should keep directive at the top of program scope', () => {\n                assert.match(obfuscatedCode, directiveRegExp);\n            });","file":"functional-tests/node-transformers/finalizing-transformers/directive-placement-transformer/DirectivePlacementTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add directive-like string literal to the string array","suites":["DirectivePlacementTransformer","Variant #1: program scope","Variant #2: directive-like string literal at the middle of program scope"],"updatePoint":{"line":62,"column":76},"line":62,"code":"            it('should add directive-like string literal to the string array', () => {\n                assert.match(obfuscatedCode, stringArrayStorageRegExp);\n            });","file":"functional-tests/node-transformers/finalizing-transformers/directive-placement-transformer/DirectivePlacementTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add call to the directive-like string literal from the string array","suites":["DirectivePlacementTransformer","Variant #1: program scope","Variant #2: directive-like string literal at the middle of program scope"],"updatePoint":{"line":66,"column":90},"line":66,"code":"            it('should add call to the directive-like string literal from the string array', () => {\n                assert.match(obfuscatedCode, directiveRegExp);\n            });","file":"functional-tests/node-transformers/finalizing-transformers/directive-placement-transformer/DirectivePlacementTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep directive at the top of function declaration scope","suites":["DirectivePlacementTransformer","Variant #2: function declaration scope","Variant #1: directive at the top of function declaration scope"],"updatePoint":{"line":97,"column":78},"line":97,"code":"            it('should keep directive at the top of function declaration scope', () => {\n                assert.match(obfuscatedCode, directiveRegExp);\n            });","file":"functional-tests/node-transformers/finalizing-transformers/directive-placement-transformer/DirectivePlacementTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep directive-like string literal at the middle of function declaration scope","suites":["DirectivePlacementTransformer","Variant #2: function declaration scope","Variant #2: directive-like string literal at the middle of function-declaration scope"],"updatePoint":{"line":126,"column":101},"line":126,"code":"            it('should keep directive-like string literal at the middle of function declaration scope', () => {\n                assert.match(obfuscatedCode, directiveRegExp);\n            });","file":"functional-tests/node-transformers/finalizing-transformers/directive-placement-transformer/DirectivePlacementTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep directive at the top of function expression scope","suites":["DirectivePlacementTransformer","Variant #3: function expression scope","Variant #1: directive at the top of function expression scope"],"updatePoint":{"line":157,"column":77},"line":157,"code":"            it('should keep directive at the top of function expression scope', () => {\n                assert.match(obfuscatedCode, directiveRegExp);\n            });","file":"functional-tests/node-transformers/finalizing-transformers/directive-placement-transformer/DirectivePlacementTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep directive-like string literal at the middle of function expression scope","suites":["DirectivePlacementTransformer","Variant #3: function expression scope","Variant #2: directive-like string literal at the middle of function-expression scope"],"updatePoint":{"line":186,"column":100},"line":186,"code":"            it('should keep directive-like string literal at the middle of function expression scope', () => {\n                assert.match(obfuscatedCode, directiveRegExp);\n            });","file":"functional-tests/node-transformers/finalizing-transformers/directive-placement-transformer/DirectivePlacementTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep directive at the top of arrow function expression scope","suites":["DirectivePlacementTransformer","Variant #4: arrow function expression scope","Variant #1: directive at the top of arrow function expression scope"],"updatePoint":{"line":217,"column":83},"line":217,"code":"            it('should keep directive at the top of arrow function expression scope', () => {\n                assert.match(obfuscatedCode, directiveRegExp);\n            });","file":"functional-tests/node-transformers/finalizing-transformers/directive-placement-transformer/DirectivePlacementTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep directive-like string literal at the middle of arrow function expression scope","suites":["DirectivePlacementTransformer","Variant #4: arrow function expression scope","Variant #2: directive-like string literal at the middle of arrow function-expression scope"],"updatePoint":{"line":246,"column":106},"line":246,"code":"            it('should keep directive-like string literal at the middle of arrow function expression scope', () => {\n                assert.match(obfuscatedCode, directiveRegExp);\n            });","file":"functional-tests/node-transformers/finalizing-transformers/directive-placement-transformer/DirectivePlacementTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should't throw an error","suites":["EscapeSequenceTransformer","Variant #1: string contains non-latin and non-digit characters and `unicodeEscapeSequence` is disabled"],"updatePoint":{"line":32,"column":36},"line":32,"code":"        it('should\\'t throw an error', () => {\n            assert.doesNotThrow(testFunc);\n        });","file":"functional-tests/node-transformers/finalizing-transformers/escape-sequence-transformer/EscapeSequenceTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace literal node value with unicode escape sequence","suites":["EscapeSequenceTransformer","Variant #2: `unicodeEscapeSequence` option is enabled"],"updatePoint":{"line":55,"column":74},"line":55,"code":"        it('should replace literal node value with unicode escape sequence', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/finalizing-transformers/escape-sequence-transformer/EscapeSequenceTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should replace literal node value with unicode escape sequence from string array","suites":["EscapeSequenceTransformer","Variant #3: `unicodeEscapeSequence` and `stringArray` options are enabled"],"updatePoint":{"line":83,"column":102},"line":83,"code":"        it('match #1: should replace literal node value with unicode escape sequence from string array', () => {\n            assert.match(obfuscatedCode, stringArrayRegExp);\n        });","file":"functional-tests/node-transformers/finalizing-transformers/escape-sequence-transformer/EscapeSequenceTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should replace literal node value with unicode escape sequence from string array","suites":["EscapeSequenceTransformer","Variant #3: `unicodeEscapeSequence` and `stringArray` options are enabled"],"updatePoint":{"line":87,"column":102},"line":87,"code":"        it('match #2: should replace literal node value with unicode escape sequence from string array', () => {\n            assert.match(obfuscatedCode, stringArrayCallRegExp);\n        });","file":"functional-tests/node-transformers/finalizing-transformers/escape-sequence-transformer/EscapeSequenceTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should ignore reserved strings","suites":["EscapeSequenceTransformer","Variant #4: `reservedStrings` option is enabled","Variant #1: base"],"updatePoint":{"line":112,"column":56},"line":112,"code":"            it('match #1: should ignore reserved strings', () => {\n                assert.match(obfuscatedCode, stringLiteralRegExp1);\n            });","file":"functional-tests/node-transformers/finalizing-transformers/escape-sequence-transformer/EscapeSequenceTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform non-reserved strings","suites":["EscapeSequenceTransformer","Variant #4: `reservedStrings` option is enabled","Variant #1: base"],"updatePoint":{"line":116,"column":63},"line":116,"code":"            it('match #2: should transform non-reserved strings', () => {\n                assert.match(obfuscatedCode, stringLiteralRegExp2);\n            });","file":"functional-tests/node-transformers/finalizing-transformers/escape-sequence-transformer/EscapeSequenceTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should ignore reserved strings","suites":["EscapeSequenceTransformer","Variant #4: `reservedStrings` option is enabled","Variant #2: correct escape of special characters"],"updatePoint":{"line":138,"column":56},"line":138,"code":"            it('match #1: should ignore reserved strings', () => {\n                assert.match(obfuscatedCode, stringLiteralRegExp);\n            });","file":"functional-tests/node-transformers/finalizing-transformers/escape-sequence-transformer/EscapeSequenceTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should not encode force transform string with unicode escape sequence","suites":["EscapeSequenceTransformer","Variant #5: `forceTransformStrings` option is enabled"],"updatePoint":{"line":163,"column":91},"line":163,"code":"        it('match #1: should not encode force transform string with unicode escape sequence', () => {\n            assert.match(obfuscatedCode, stringLiteralRegExp1);\n        });","file":"functional-tests/node-transformers/finalizing-transformers/escape-sequence-transformer/EscapeSequenceTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should not encode force transform string with unicode escape sequence","suites":["EscapeSequenceTransformer","Variant #5: `forceTransformStrings` option is enabled"],"updatePoint":{"line":167,"column":91},"line":167,"code":"        it('match #2: should not encode force transform string with unicode escape sequence', () => {\n            assert.match(obfuscatedCode, stringLiteralRegExp2);\n        });","file":"functional-tests/node-transformers/finalizing-transformers/escape-sequence-transformer/EscapeSequenceTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should encode calls to the string array wrappers","suites":["EscapeSequenceTransformer","Variant #6: `stringArrayWrappersCount` option enabled"],"updatePoint":{"line":208,"column":60},"line":208,"code":"        it('should encode calls to the string array wrappers', () => {\n            assert.match(obfuscatedCode, stringArrayCallRegExp);\n        });","file":"functional-tests/node-transformers/finalizing-transformers/escape-sequence-transformer/EscapeSequenceTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should remove comments without preserved words","suites":["CommentsTransformer","Variant #1: simple comment without preserved words"],"updatePoint":{"line":29,"column":58},"line":29,"code":"        it('should remove comments without preserved words', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/initializing-transformers/comments-transformer/CommentsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep comments with preserved words","suites":["CommentsTransformer","Variant #2: simple comment with preserved words"],"updatePoint":{"line":50,"column":53},"line":50,"code":"        it('should keep comments with preserved words', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/initializing-transformers/comments-transformer/CommentsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep comments with preserved words","suites":["CommentsTransformer","Variant #3: comment with preserved and non-preserved words"],"updatePoint":{"line":71,"column":53},"line":71,"code":"        it('should keep comments with preserved words', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/initializing-transformers/comments-transformer/CommentsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep comments with preserved words","suites":["CommentsTransformer","Variant #4: comment with preserved and non-preserved words"],"updatePoint":{"line":99,"column":53},"line":99,"code":"        it('should keep comments with preserved words', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/initializing-transformers/comments-transformer/CommentsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should remove comment without preserved words","suites":["CommentsTransformer","Variant #5: only comment without preserved words"],"updatePoint":{"line":118,"column":57},"line":118,"code":"        it('should remove comment without preserved words', () => {\n            assert.isNotOk(obfuscatedCode);\n        });","file":"functional-tests/node-transformers/initializing-transformers/comments-transformer/CommentsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep comments with preserved words","suites":["CommentsTransformer","Variant #6: only comment with preserved words"],"updatePoint":{"line":139,"column":53},"line":139,"code":"        it('should keep comments with preserved words', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/initializing-transformers/comments-transformer/CommentsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep comments with preserved words and move heading comment to the top","suites":["CommentsTransformer","Variant #7: simple comment with preserved words and additional code helper is inserted","Variant #1: `stringArray` code helper"],"updatePoint":{"line":166,"column":93},"line":166,"code":"            it('should keep comments with preserved words and move heading comment to the top', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/initializing-transformers/comments-transformer/CommentsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep comments with preserved words and move heading comment to the top","suites":["CommentsTransformer","Variant #7: simple comment with preserved words and additional code helper is inserted","Variant #2: `transformObjectKeys` code helper"],"updatePoint":{"line":192,"column":93},"line":192,"code":"            it('should keep comments with preserved words and move heading comment to the top', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/initializing-transformers/comments-transformer/CommentsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should obfuscate eval string","suites":["EvalCallExpressionTransformer","Variant #1: identifier reference"],"updatePoint":{"line":36,"column":40},"line":36,"code":"        it('should obfuscate eval string', () => {\n            assert.match(obfuscatedCode, evalExpressionRegExp);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform function parameter inside eval expression","suites":["EvalCallExpressionTransformer","Variant #1: identifier reference"],"updatePoint":{"line":40,"column":80},"line":40,"code":"        it('should correctly transform function parameter inside eval expression', () => {\n            assert.equal(functionIdentifierName, variableReferenceIdentifierName);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should obfuscate eval string","suites":["EvalCallExpressionTransformer","Variant #2: call expression with identifier reference"],"updatePoint":{"line":67,"column":40},"line":67,"code":"        it('should obfuscate eval string', () => {\n            assert.match(obfuscatedCode, evalExpressionRegExp);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform function parameter inside eval expression","suites":["EvalCallExpressionTransformer","Variant #2: call expression with identifier reference"],"updatePoint":{"line":71,"column":80},"line":71,"code":"        it('should correctly transform function parameter inside eval expression', () => {\n            assert.equal(functionIdentifierName, variableReferenceIdentifierName);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should obfuscate eval string","suites":["EvalCallExpressionTransformer","Variant #3: multiple statements in eval"],"updatePoint":{"line":92,"column":40},"line":92,"code":"        it('should obfuscate eval string', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should add strings from eval expression to the string array","suites":["EvalCallExpressionTransformer","Variant #4: string array calls wrapper call","Variant #1: hexadecimal number indexes type"],"updatePoint":{"line":120,"column":85},"line":120,"code":"            it('match #1: should add strings from eval expression to the string array', () => {\n                assert.match(obfuscatedCode, stringArrayRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should replace string with call to the string array calls wrapper","suites":["EvalCallExpressionTransformer","Variant #4: string array calls wrapper call","Variant #1: hexadecimal number indexes type"],"updatePoint":{"line":124,"column":91},"line":124,"code":"            it('match #1: should replace string with call to the string array calls wrapper', () => {\n                assert.match(obfuscatedCode, stringArrayCallsWrapperRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should add strings from eval expression to the string array","suites":["EvalCallExpressionTransformer","Variant #4: string array calls wrapper call","Variant #1: hexadecimal numeric string indexes type"],"updatePoint":{"line":151,"column":85},"line":151,"code":"            it('match #1: should add strings from eval expression to the string array', () => {\n                assert.match(obfuscatedCode, stringArrayRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should replace string with call to the string array calls wrapper","suites":["EvalCallExpressionTransformer","Variant #4: string array calls wrapper call","Variant #1: hexadecimal numeric string indexes type"],"updatePoint":{"line":155,"column":91},"line":155,"code":"            it('match #1: should replace string with call to the string array calls wrapper', () => {\n                assert.match(obfuscatedCode, stringArrayCallsWrapperRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should obfuscate eval string","suites":["EvalCallExpressionTransformer","Variant #5: eval expression as argument"],"updatePoint":{"line":183,"column":40},"line":183,"code":"        it('should obfuscate eval string', () => {\n            assert.match(obfuscatedCode, evalExpressionRegExp);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform function parameter inside eval expression","suites":["EvalCallExpressionTransformer","Variant #5: eval expression as argument"],"updatePoint":{"line":187,"column":80},"line":187,"code":"        it('should correctly transform function parameter inside eval expression', () => {\n            assert.equal(functionIdentifierName, variableReferenceIdentifierName);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should obfuscate eval string","suites":["EvalCallExpressionTransformer","Variant #6: nested eval expressions"],"updatePoint":{"line":242,"column":40},"line":242,"code":"        it('should obfuscate eval string', () => {\n            assert.match(obfuscatedCode, evalExpressionRegExp);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should generate correct code","suites":["EvalCallExpressionTransformer","Variant #6: nested eval expressions"],"updatePoint":{"line":246,"column":40},"line":246,"code":"        it('should generate correct code', () => {\n            assert.equal(evaluationResult, expectedEvaluationResult);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should correctly transform function parameter `a` inside eval expression","suites":["EvalCallExpressionTransformer","Variant #6: nested eval expressions"],"updatePoint":{"line":250,"column":94},"line":250,"code":"        it('match #1: should correctly transform function parameter `a` inside eval expression', () => {\n            assert.equal(functionIdentifierAName, variableReferenceIdentifierAName1);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should correctly transform function parameter `a` inside nested eval expression","suites":["EvalCallExpressionTransformer","Variant #6: nested eval expressions"],"updatePoint":{"line":254,"column":101},"line":254,"code":"        it('match #2: should correctly transform function parameter `a` inside nested eval expression', () => {\n            assert.equal(functionIdentifierAName, variableReferenceIdentifierAName2);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should correctly transform function parameter `b` inside eval expression","suites":["EvalCallExpressionTransformer","Variant #6: nested eval expressions"],"updatePoint":{"line":258,"column":94},"line":258,"code":"        it('match #3: should correctly transform function parameter `b` inside eval expression', () => {\n            assert.equal(functionIdentifierBName, variableReferenceIdentifierBName);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #4: should correctly transform variable declaration and variable reference inside eval and nested eval expressions","suites":["EvalCallExpressionTransformer","Variant #6: nested eval expressions"],"updatePoint":{"line":262,"column":132},"line":262,"code":"        it('match #4: should correctly transform variable declaration and variable reference inside eval and nested eval expressions', () => {\n            assert.equal(variableReferenceIdentifierCName1, variableReferenceIdentifierCName2);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should skip obfuscation of eval string","suites":["EvalCallExpressionTransformer","Variant #7: wrong eval string"],"updatePoint":{"line":283,"column":50},"line":283,"code":"        it('should skip obfuscation of eval string', () => {\n            assert.match(obfuscatedCode, evalExpressionRegExp);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should obfuscate eval string","suites":["EvalCallExpressionTransformer","Variant #8: template literal inside eval expression"],"updatePoint":{"line":310,"column":40},"line":310,"code":"        it('should obfuscate eval string', () => {\n            assert.match(obfuscatedCode, evalExpressionRegExp);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform function parameter inside eval expression","suites":["EvalCallExpressionTransformer","Variant #8: template literal inside eval expression"],"updatePoint":{"line":314,"column":80},"line":314,"code":"        it('should correctly transform function parameter inside eval expression', () => {\n            assert.equal(functionIdentifierName, variableReferenceIdentifierName);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add control flow storage node","suites":["EvalCallExpressionTransformer","Variant #9: integration with control flow flattening"],"updatePoint":{"line":348,"column":48},"line":348,"code":"        it('should add control flow storage node', () => {\n            assert.match(obfuscatedCode, controlFlowStorageNodeRegExp);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should obfuscate eval string","suites":["EvalCallExpressionTransformer","Variant #9: integration with control flow flattening"],"updatePoint":{"line":352,"column":40},"line":352,"code":"        it('should obfuscate eval string', () => {\n            assert.match(obfuscatedCode, evalExpressionRegExp);\n        });","file":"functional-tests/node-transformers/preparing-transformers/eval-call-expression-transformer/EvalCallExpressionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't obfuscate `use strict` operator","suites":["BlackListObfuscatingGuard","check","`'use strict';` operator"],"updatePoint":{"line":32,"column":68},"line":32,"code":"            it('match #1: shouldn\\'t obfuscate `use strict` operator', () => {\n                assert.match(obfuscatedCode, useStrictOperatorRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/black-list-obfuscating-guard/BlackListObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should return correct obfuscated code","suites":["BlackListObfuscatingGuard","check","`'use strict';` operator"],"updatePoint":{"line":36,"column":63},"line":36,"code":"            it('match #2: should return correct obfuscated code', () => {\n                assert.match(obfuscatedCode, stringArrayLatinRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/black-list-obfuscating-guard/BlackListObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should return correct obfuscated code","suites":["BlackListObfuscatingGuard","check","`'use strict';` operator"],"updatePoint":{"line":40,"column":63},"line":40,"code":"            it('match #3: should return correct obfuscated code', () => {\n                assert.match(obfuscatedCode, stringArrayCallRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/black-list-obfuscating-guard/BlackListObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should remove `disable` conditional comment from the code","suites":["ConditionalCommentObfuscatingGuard","check","Variant #1: `disable` conditional comment"],"updatePoint":{"line":30,"column":83},"line":30,"code":"            it('match #1: should remove `disable` conditional comment from the code', () => {\n                assert.notMatch(obfuscatedCode, disableConditionalCommentRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should obfuscate variable declaration before `disable` conditional comment","suites":["ConditionalCommentObfuscatingGuard","check","Variant #1: `disable` conditional comment"],"updatePoint":{"line":34,"column":100},"line":34,"code":"            it('match #2: should obfuscate variable declaration before `disable` conditional comment', () => {\n                assert.match(obfuscatedCode, obfuscatedVariableDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should ignore variable declaration after `disable` conditional comment","suites":["ConditionalCommentObfuscatingGuard","check","Variant #1: `disable` conditional comment"],"updatePoint":{"line":38,"column":96},"line":38,"code":"            it('match #3: should ignore variable declaration after `disable` conditional comment', () => {\n                assert.match(obfuscatedCode, ignoredVariableDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #4: should obfuscate variable name in `console.log`","suites":["ConditionalCommentObfuscatingGuard","check","Variant #1: `disable` conditional comment"],"updatePoint":{"line":42,"column":73},"line":42,"code":"            it('match #4: should obfuscate variable name in `console.log`', () => {\n                assert.match(obfuscatedCode, consoleLogRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should remove `disable` conditional comment from the code","suites":["ConditionalCommentObfuscatingGuard","check","Variant #2: `disable` and `enable` conditional comments #1"],"updatePoint":{"line":67,"column":83},"line":67,"code":"            it('match #1: should remove `disable` conditional comment from the code', () => {\n                assert.notMatch(obfuscatedCode, disableConditionalCommentRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should remove `enable` conditional comment from the code","suites":["ConditionalCommentObfuscatingGuard","check","Variant #2: `disable` and `enable` conditional comments #1"],"updatePoint":{"line":71,"column":82},"line":71,"code":"            it('match #2: should remove `enable` conditional comment from the code', () => {\n                assert.notMatch(obfuscatedCode, enableConditionalCommentRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should obfuscate variable declaration before `disable` conditional comment","suites":["ConditionalCommentObfuscatingGuard","check","Variant #2: `disable` and `enable` conditional comments #1"],"updatePoint":{"line":75,"column":100},"line":75,"code":"            it('match #3: should obfuscate variable declaration before `disable` conditional comment', () => {\n                assert.match(obfuscatedCode, obfuscatedVariableDeclaration1RegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #4: should ignore variable declaration after `disable` conditional comment","suites":["ConditionalCommentObfuscatingGuard","check","Variant #2: `disable` and `enable` conditional comments #1"],"updatePoint":{"line":79,"column":96},"line":79,"code":"            it('match #4: should ignore variable declaration after `disable` conditional comment', () => {\n                assert.match(obfuscatedCode, ignoredVariableDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #5: should obfuscate variable declaration after `enable` conditional comment","suites":["ConditionalCommentObfuscatingGuard","check","Variant #2: `disable` and `enable` conditional comments #1"],"updatePoint":{"line":83,"column":98},"line":83,"code":"            it('match #5: should obfuscate variable declaration after `enable` conditional comment', () => {\n                assert.match(obfuscatedCode, obfuscatedVariableDeclaration2RegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should ignore variable declaration after `disable` conditional comment","suites":["ConditionalCommentObfuscatingGuard","check","Variant #3: `disable` and `enable` conditional comments #2"],"updatePoint":{"line":106,"column":96},"line":106,"code":"            it('match #1: should ignore variable declaration after `disable` conditional comment', () => {\n                assert.match(obfuscatedCode, ignoredVariableDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should obfuscate variable declaration before `disable` conditional comment","suites":["ConditionalCommentObfuscatingGuard","check","Variant #3: `disable` and `enable` conditional comments #2"],"updatePoint":{"line":110,"column":100},"line":110,"code":"            it('match #2: should obfuscate variable declaration before `disable` conditional comment', () => {\n                assert.match(obfuscatedCode, obfuscatedVariableDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should ignore variable declaration after `disable` conditional comment","suites":["ConditionalCommentObfuscatingGuard","check","Variant #4: `disable` conditional comment from beginning of the code"],"updatePoint":{"line":132,"column":96},"line":132,"code":"            it('match #1: should ignore variable declaration after `disable` conditional comment', () => {\n                assert.match(obfuscatedCode, ignoredVariableDeclaration1RegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should ignore variable declaration after `disable` conditional comment","suites":["ConditionalCommentObfuscatingGuard","check","Variant #4: `disable` conditional comment from beginning of the code"],"updatePoint":{"line":136,"column":96},"line":136,"code":"            it('match #2: should ignore variable declaration after `disable` conditional comment', () => {\n                assert.match(obfuscatedCode, ignoredVariableDeclaration2RegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should ignore function expression after `disable` conditional comment","suites":["ConditionalCommentObfuscatingGuard","check","Variant #5: `disable` and `enable` conditional comments with dead code injection"],"updatePoint":{"line":186,"column":95},"line":186,"code":"            it('match #1: should ignore function expression after `disable` conditional comment', () => {\n                assert.match(obfuscatedCode, ignoredFunctionExpression1RegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should ignore function expression after `disable` conditional comment","suites":["ConditionalCommentObfuscatingGuard","check","Variant #5: `disable` and `enable` conditional comments with dead code injection"],"updatePoint":{"line":190,"column":95},"line":190,"code":"            it('match #2: should ignore function expression after `disable` conditional comment', () => {\n                assert.match(obfuscatedCode, ignoredFunctionExpression2RegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should ignore function expression call","suites":["ConditionalCommentObfuscatingGuard","check","Variant #5: `disable` and `enable` conditional comments with dead code injection"],"updatePoint":{"line":194,"column":64},"line":194,"code":"            it('match #3: should ignore function expression call', () => {\n                assert.match(obfuscatedCode, ignoredFunctionCall1RegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #4: should ignore function expression call","suites":["ConditionalCommentObfuscatingGuard","check","Variant #5: `disable` and `enable` conditional comments with dead code injection"],"updatePoint":{"line":198,"column":64},"line":198,"code":"            it('match #4: should ignore function expression call', () => {\n                assert.match(obfuscatedCode, ignoredFunctionCall2RegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"should obfuscate 3 function expressions","suites":["ConditionalCommentObfuscatingGuard","check","Variant #5: `disable` and `enable` conditional comments with dead code injection"],"updatePoint":{"line":202,"column":55},"line":202,"code":"            it('should obfuscate 3 function expressions', () => {\n                assert.equal(obfuscatedFunctionExpressionMatchesLength, expectedObfuscatedFunctionExpressionLength);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"should obfuscate 3 function expression calls","suites":["ConditionalCommentObfuscatingGuard","check","Variant #5: `disable` and `enable` conditional comments with dead code injection"],"updatePoint":{"line":206,"column":60},"line":206,"code":"            it('should obfuscate 3 function expression calls', () => {\n                assert.equal(obfuscatedFunctionCallMatchesLength, expectedObfuscatedFunctionCallsLength);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should obfuscate variable declaration before `disable` conditional comment","suites":["ConditionalCommentObfuscatingGuard","check","Variant #6: `disable` and `enable` conditional comments with control flow flattening"],"updatePoint":{"line":230,"column":100},"line":230,"code":"            it('match #1: should obfuscate variable declaration before `disable` conditional comment', () => {\n                assert.match(obfuscatedCode, obfuscatedVariableDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should ignore variable declaration after `disable` conditional comment","suites":["ConditionalCommentObfuscatingGuard","check","Variant #6: `disable` and `enable` conditional comments with control flow flattening"],"updatePoint":{"line":234,"column":96},"line":234,"code":"            it('match #2: should ignore variable declaration after `disable` conditional comment', () => {\n                assert.match(obfuscatedCode, ignoredVariableDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/conditional-comment-obfuscating-guard/ConditionalCommentObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should obfuscate force transform strings","suites":["ForceTransformStringObfuscatingGuard","check","`forceTransformStrings` option is enabled"],"updatePoint":{"line":36,"column":66},"line":36,"code":"            it('match #1: should obfuscate force transform strings', () => {\n                assert.match(obfuscatedCode, obfuscatingGuardRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/force-transform-string-obfuscating-guard/ForceTransformStringObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't obfuscate strings","suites":["ForceTransformStringObfuscatingGuard","check","`forceTransformStrings` option is disabled"],"updatePoint":{"line":64,"column":54},"line":64,"code":"            it('match #1: shouldn\\'t obfuscate strings', () => {\n                assert.match(obfuscatedCode, obfuscatingGuardRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/force-transform-string-obfuscating-guard/ForceTransformStringObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't obfuscate imports","suites":["IgnoredImportObfuscatingGuard","check","`ignoreImports` option is enabled"],"updatePoint":{"line":35,"column":54},"line":35,"code":"            it('match #1: shouldn\\'t obfuscate imports', () => {\n                assert.match(obfuscatedCode, obfuscatingGuardRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/ignored-import-obfuscating-guard/IgnoredImportObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should obfuscate imports","suites":["IgnoredImportObfuscatingGuard","check","`ignoreImports` option is disabled"],"updatePoint":{"line":64,"column":50},"line":64,"code":"            it('match #1: should obfuscate imports', () => {\n                assert.match(obfuscatedCode, obfuscatingGuardRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/ignored-import-obfuscating-guard/IgnoredImportObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't obfuscate reserved strings","suites":["ReservedStringObfuscatingGuard","check","`reservedStrings` option is enabled"],"updatePoint":{"line":30,"column":63},"line":30,"code":"            it('match #1: shouldn\\'t obfuscate reserved strings', () => {\n                assert.match(obfuscatedCode, obfuscatingGuardRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/reserved-string-obfuscating-guard/ReservedStringObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should obfuscate all strings","suites":["ReservedStringObfuscatingGuard","check","`reservedStrings` option is disabled"],"updatePoint":{"line":54,"column":54},"line":54,"code":"            it('match #1: should obfuscate all strings', () => {\n                assert.match(obfuscatedCode, obfuscatingGuardRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/obfuscating-guards/reserved-string-obfuscating-guard/ReservedStringObfuscatingGuard.spec.ts","skipped":false,"dir":"test"},{"name":"should generate non-preserved name for string array storage","suites":["VariablePreserveTransformer","Variant #1: string array storage name conflicts with identifier name","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":37,"column":75},"line":37,"code":"            it('should generate non-preserved name for string array storage', () => {\n                assert.match(obfuscatedCode, stringArrayStorageNameRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep the original name for global identifier","suites":["VariablePreserveTransformer","Variant #1: string array storage name conflicts with identifier name","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":41,"column":67},"line":41,"code":"            it('should keep the original name for global identifier', () => {\n                assert.match(obfuscatedCode, identifierNameRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should generate non-preserved name for string array storage","suites":["VariablePreserveTransformer","Variant #1: string array storage name conflicts with identifier name","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":70,"column":75},"line":70,"code":"            it('should generate non-preserved name for string array storage', () => {\n                assert.match(obfuscatedCode, stringArrayStorageNameRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should rename global identifier","suites":["VariablePreserveTransformer","Variant #1: string array storage name conflicts with identifier name","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":74,"column":47},"line":74,"code":"            it('should rename global identifier', () => {\n                assert.match(obfuscatedCode, identifierNameRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should generate non-preserved name for `transformObjectKeys` identifier","suites":["VariablePreserveTransformer","Variant #2: `transformObjectKeys` identifier name conflicts with identifier name","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":100,"column":87},"line":100,"code":"            it('should generate non-preserved name for `transformObjectKeys` identifier', () => {\n                assert.match(obfuscatedCode, transformObjectKeysNameRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep the original name for global identifier","suites":["VariablePreserveTransformer","Variant #2: `transformObjectKeys` identifier name conflicts with identifier name","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":104,"column":67},"line":104,"code":"            it('should keep the original name for global identifier', () => {\n                assert.match(obfuscatedCode, identifierNameRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should generate non-preserved name for `transformObjectKeys` identifier","suites":["VariablePreserveTransformer","Variant #2: `transformObjectKeys` identifier name conflicts with identifier name","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":129,"column":87},"line":129,"code":"            it('should generate non-preserved name for `transformObjectKeys` identifier', () => {\n                assert.match(obfuscatedCode, transformObjectKeysNameRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep the original name for global identifier","suites":["VariablePreserveTransformer","Variant #2: `transformObjectKeys` identifier name conflicts with identifier name","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":133,"column":67},"line":133,"code":"            it('should keep the original name for global identifier', () => {\n                assert.match(obfuscatedCode, identifierNameRegExp);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should generate non-preserved name for global identifier","suites":["VariablePreserveTransformer","Variant #3: ignored node identifier name conflict with identifier name","Variant #1: global scope"],"updatePoint":{"line":159,"column":72},"line":159,"code":"            it('should generate non-preserved name for global identifier', () => {\n                assert.match(obfuscatedCode, functionExpressionIdentifierName);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep the original name for ignored identifier","suites":["VariablePreserveTransformer","Variant #3: ignored node identifier name conflict with identifier name","Variant #1: global scope"],"updatePoint":{"line":163,"column":68},"line":163,"code":"            it('should keep the original name for ignored identifier', () => {\n                assert.match(obfuscatedCode, functionDeclarationIdentifierName);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should generate non-preserved name for variable name","suites":["VariablePreserveTransformer","Variant #4: destructed object property identifier name conflict with identifier name","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":191,"column":68},"line":191,"code":"            it('should generate non-preserved name for variable name', () => {\n                assert.match(obfuscatedCode, variableDeclarationIdentifierName);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep the original name for destructed object property identifier","suites":["VariablePreserveTransformer","Variant #4: destructed object property identifier name conflict with identifier name","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":195,"column":87},"line":195,"code":"            it('should keep the original name for destructed object property identifier', () => {\n                assert.match(obfuscatedCode, destructedObjectPropertyIdentifierName);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should generate non-preserved name for variable declaration","suites":["VariablePreserveTransformer","Variant #4: destructed object property identifier name conflict with identifier name","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":220,"column":75},"line":220,"code":"            it('should generate non-preserved name for variable declaration', () => {\n                assert.match(obfuscatedCode, variableDeclarationIdentifierName);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should generate non-preserved name for function declaration","suites":["VariablePreserveTransformer","Variant #4: destructed object property identifier name conflict with identifier name","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":224,"column":75},"line":224,"code":"            it('should generate non-preserved name for function declaration', () => {\n                assert.match(obfuscatedCode, functionDeclarationIdentifierName);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep the original name for destructed object property identifier","suites":["VariablePreserveTransformer","Variant #4: destructed object property identifier name conflict with identifier name","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":228,"column":87},"line":228,"code":"            it('should keep the original name for destructed object property identifier', () => {\n                assert.match(obfuscatedCode, destructedObjectPropertyIdentifierName);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should generate non-preserved name for variable declaration","suites":["VariablePreserveTransformer","Variant #4: destructed object property identifier name conflict with identifier name","Variant #3: function destructed object property"],"updatePoint":{"line":253,"column":75},"line":253,"code":"            it('should generate non-preserved name for variable declaration', () => {\n                assert.match(obfuscatedCode, variableDeclarationIdentifierName);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep the original name for destructed object property identifier","suites":["VariablePreserveTransformer","Variant #4: destructed object property identifier name conflict with identifier name","Variant #3: function destructed object property"],"updatePoint":{"line":257,"column":87},"line":257,"code":"            it('should keep the original name for destructed object property identifier', () => {\n                assert.match(obfuscatedCode, destructedObjectPropertyIdentifierName);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should generate valid identifier names for console.log call","suites":["VariablePreserveTransformer","Variant #4: destructed object property identifier name conflict with identifier name","Variant #3: function destructed object property"],"updatePoint":{"line":261,"column":75},"line":261,"code":"            it('should generate valid identifier names for console.log call', () => {\n                assert.match(obfuscatedCode, consoleLogIdentifierNames);\n            });","file":"functional-tests/node-transformers/preparing-transformers/variable-preserve-transformer/VariablePreserveTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should keep reserved names without transformations when `reservedNames` option is enabled","suites":["IdentifierReplacer","Reserved names","Variant #1: ignore local reserved names"],"updatePoint":{"line":26,"column":105},"line":26,"code":"            it('Should keep reserved names without transformations when `reservedNames` option is enabled', () => {\n                assert.match(\n                    obfuscatedCode,\n                    /var abc *= *0x1; *var _0x([a-f0-9]){4,6} *= *0x2; *var ghi *= *0x3;/\n                );\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/identifier-replacer/IdentifierReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"Should keep reserved names without transformations when `reservedNames` option is enabled","suites":["IdentifierReplacer","Reserved names","Variant #1: ignore global reserved names"],"updatePoint":{"line":50,"column":105},"line":50,"code":"            it('Should keep reserved names without transformations when `reservedNames` option is enabled', () => {\n                assert.match(\n                    obfuscatedCode,\n                    /var abc *= *0x1; *var _0x([a-f0-9]){4,6} *= *0x2; *var ghi *= *0x3;/\n                );\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/identifier-replacer/IdentifierReplacer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform `labeledStatement` identifier","suites":["LabeledStatementTransformer","transformNode"],"updatePoint":{"line":36,"column":58},"line":36,"code":"        it('should transform `labeledStatement` identifier', () => {\n            assert.match(obfuscatedCode, labeledStatementRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/labeled-statement-transformer/LabeledStatementTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform `continueStatement` identifier","suites":["LabeledStatementTransformer","transformNode"],"updatePoint":{"line":40,"column":59},"line":40,"code":"        it('should transform `continueStatement` identifier', () => {\n            assert.match(obfuscatedCode, continueStatementRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/labeled-statement-transformer/LabeledStatementTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform `breakStatement` identifier","suites":["LabeledStatementTransformer","transformNode"],"updatePoint":{"line":44,"column":56},"line":44,"code":"        it('should transform `breakStatement` identifier', () => {\n            assert.match(obfuscatedCode, breakStatementRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/labeled-statement-transformer/LabeledStatementTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"equal #1: `labeledStatement` identifier name and `labeledStatement` body `breakStatement` should be same","suites":["LabeledStatementTransformer","transformNode"],"updatePoint":{"line":48,"column":116},"line":48,"code":"        it('equal #1: `labeledStatement` identifier name and `labeledStatement` body `breakStatement` should be same', () => {\n            assert.equal(firstMatch, secondMatch);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/labeled-statement-transformer/LabeledStatementTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"equal #2: `labeledStatement` identifier name and `labeledStatement` body `breakStatement` should be same","suites":["LabeledStatementTransformer","transformNode"],"updatePoint":{"line":52,"column":116},"line":52,"code":"        it('equal #2: `labeledStatement` identifier name and `labeledStatement` body `breakStatement` should be same', () => {\n            assert.equal(secondMatch, thirdMatch);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/labeled-statement-transformer/LabeledStatementTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform catch clause node","suites":["ScopeIdentifiersTransformer CatchClause identifiers","Variant #1: base transform of catch clause parameter"],"updatePoint":{"line":35,"column":56},"line":35,"code":"        it('match #1: should transform catch clause node', () => {\n            assert.match(obfuscatedCode, paramNameRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/catch-clause/CatchClause.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform catch clause node","suites":["ScopeIdentifiersTransformer CatchClause identifiers","Variant #1: base transform of catch clause parameter"],"updatePoint":{"line":39,"column":56},"line":39,"code":"        it('match #2: should transform catch clause node', () => {\n            assert.match(obfuscatedCode, bodyParamNameRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/catch-clause/CatchClause.spec.ts","skipped":false,"dir":"test"},{"name":"catch clause arguments param name and param name in body should be same","suites":["ScopeIdentifiersTransformer CatchClause identifiers","Variant #1: base transform of catch clause parameter"],"updatePoint":{"line":43,"column":83},"line":43,"code":"        it('catch clause arguments param name and param name in body should be same', () => {\n            assert.equal(firstMatch, secondMatch);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/catch-clause/CatchClause.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't transform function parameter object pattern identifier","suites":["ScopeIdentifiersTransformer CatchClause identifiers","Variant #2: object pattern as parameter"],"updatePoint":{"line":65,"column":87},"line":65,"code":"        it('match #1: shouldn\\'t transform function parameter object pattern identifier', () => {\n            assert.match(obfuscatedCode, functionParameterMatch);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/catch-clause/CatchClause.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't transform function parameter object pattern identifier","suites":["ScopeIdentifiersTransformer CatchClause identifiers","Variant #2: object pattern as parameter"],"updatePoint":{"line":69,"column":87},"line":69,"code":"        it('match #2: shouldn\\'t transform function parameter object pattern identifier', () => {\n            assert.match(obfuscatedCode, functionBodyMatch);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/catch-clause/CatchClause.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform catch clause node","suites":["ScopeIdentifiersTransformer CatchClause identifiers","Variant #3: optional catch binding support"],"updatePoint":{"line":89,"column":56},"line":89,"code":"        it('match #1: should transform catch clause node', () => {\n            assert.match(obfuscatedCode, optionalCatchClauseRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/catch-clause/CatchClause.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform catch clause node","suites":["ScopeIdentifiersTransformer CatchClause identifiers","Variant #3: optional catch binding support"],"updatePoint":{"line":93,"column":56},"line":93,"code":"        it('match #2: should transform catch clause node', () => {\n            assert.match(obfuscatedCode, bodyParamNameRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/catch-clause/CatchClause.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't transform variable identifier if `renameGlobals` option is disabled","suites":["ScopeIdentifiersTransformer CatchClause identifiers","Variant #4: global variable scope","Variant #1: `renameGlobals` is disabled"],"updatePoint":{"line":113,"column":104},"line":113,"code":"            it('match #1: shouldn\\'t transform variable identifier if `renameGlobals` option is disabled', () => {\n                assert.match(obfuscatedCode, globalVariableRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/catch-clause/CatchClause.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform variable identifier if `renameGlobals` option is enabled","suites":["ScopeIdentifiersTransformer CatchClause identifiers","Variant #4: global variable scope","Variant #2: `renameGlobals` is enabled"],"updatePoint":{"line":133,"column":99},"line":133,"code":"            it('match #1: should transform variable identifier if `renameGlobals` option is enabled', () => {\n                assert.match(obfuscatedCode, globalVariableRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/catch-clause/CatchClause.spec.ts","skipped":false,"dir":"test"},{"name":"should transform class name","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #1: `classDeclaration` parent block scope is not a `ProgramNode`"],"updatePoint":{"line":36,"column":43},"line":36,"code":"            it('should transform class name', () => {\n                assert.equal(classNameIdentifier, classCallIdentifier);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't transform class name","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #1: base"],"updatePoint":{"line":60,"column":65},"line":60,"code":"                    it('match #1: shouldn\\'t transform class name', () => {\n                        assert.match(obfuscatedCode, classNameIdentifierRegExp);\n                    });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't transform class name","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #1: base"],"updatePoint":{"line":64,"column":65},"line":64,"code":"                    it('match #2: shouldn\\'t transform class name', () => {\n                        assert.match(obfuscatedCode, classCallIdentifierRegExp);\n                    });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't transform class name","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #2: target `browser","Variant #1: correct class name references in global scope"],"updatePoint":{"line":89,"column":69},"line":89,"code":"                        it('match #1: shouldn\\'t transform class name', () => {\n                            assert.match(obfuscatedCode, classNameIdentifierRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't transform class name reference outside of class","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #2: target `browser","Variant #1: correct class name references in global scope"],"updatePoint":{"line":93,"column":96},"line":93,"code":"                        it('match #2: shouldn\\'t transform class name reference outside of class', () => {\n                            assert.match(obfuscatedCode, outerClassNameReferenceRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: shouldn't transform class name reference inside class","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #2: target `browser","Variant #1: correct class name references in global scope"],"updatePoint":{"line":97,"column":92},"line":97,"code":"                        it('match #3: shouldn\\'t transform class name reference inside class', () => {\n                            assert.match(obfuscatedCode, innerClassNameReferenceRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform class name","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #2: target `browser","Variant #2: correct class name references in function scope"],"updatePoint":{"line":128,"column":65},"line":128,"code":"                        it('match #1: should transform class name', () => {\n                            assert.match(obfuscatedCode, classNameIdentifierRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform class name reference outside of class","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #2: target `browser","Variant #2: correct class name references in function scope"],"updatePoint":{"line":132,"column":92},"line":132,"code":"                        it('match #2: should transform class name reference outside of class', () => {\n                            assert.match(obfuscatedCode, outerClassNameReferenceRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should transform class name reference inside class","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #2: target `browser","Variant #2: correct class name references in function scope"],"updatePoint":{"line":136,"column":88},"line":136,"code":"                        it('match #3: should transform class name reference inside class', () => {\n                            assert.match(obfuscatedCode, innerClassNameReferenceRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #4: should generate same identifier names for class name and outer class name reference","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #2: target `browser","Variant #2: correct class name references in function scope"],"updatePoint":{"line":140,"column":121},"line":140,"code":"                        it('match #4: should generate same identifier names for class name and outer class name reference', () => {\n                            assert.equal(classNameIdentifier, outerClassNameReferenceIdentifierName);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #5: should generate same identifier names for class name and inner class name reference","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #2: target `browser","Variant #2: correct class name references in function scope"],"updatePoint":{"line":144,"column":121},"line":144,"code":"                        it('match #5: should generate same identifier names for class name and inner class name reference', () => {\n                            assert.equal(classNameIdentifier, innerClassNameReferenceIdentifierName);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't transform class name","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #3: target `node","Variant #1: correct class name references in global scope"],"updatePoint":{"line":170,"column":69},"line":170,"code":"                        it('match #1: shouldn\\'t transform class name', () => {\n                            assert.match(obfuscatedCode, classNameIdentifierRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't transform class name reference outside of class","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #3: target `node","Variant #1: correct class name references in global scope"],"updatePoint":{"line":174,"column":96},"line":174,"code":"                        it('match #2: shouldn\\'t transform class name reference outside of class', () => {\n                            assert.match(obfuscatedCode, outerClassNameReferenceRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: shouldn't transform class name reference inside class","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #3: target `node","Variant #1: correct class name references in global scope"],"updatePoint":{"line":178,"column":92},"line":178,"code":"                        it('match #3: shouldn\\'t transform class name reference inside class', () => {\n                            assert.match(obfuscatedCode, innerClassNameReferenceRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform class name","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #3: target `node","Variant #2: correct class name references in function scope"],"updatePoint":{"line":209,"column":65},"line":209,"code":"                        it('match #1: should transform class name', () => {\n                            assert.match(obfuscatedCode, classNameIdentifierRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform class name reference outside of class","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #3: target `node","Variant #2: correct class name references in function scope"],"updatePoint":{"line":213,"column":92},"line":213,"code":"                        it('match #2: should transform class name reference outside of class', () => {\n                            assert.match(obfuscatedCode, outerClassNameReferenceRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should transform class name reference inside class","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #3: target `node","Variant #2: correct class name references in function scope"],"updatePoint":{"line":217,"column":88},"line":217,"code":"                        it('match #3: should transform class name reference inside class', () => {\n                            assert.match(obfuscatedCode, innerClassNameReferenceRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #4: should generate same identifier names for class name and outer class name reference","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #3: target `node","Variant #2: correct class name references in function scope"],"updatePoint":{"line":221,"column":121},"line":221,"code":"                        it('match #4: should generate same identifier names for class name and outer class name reference', () => {\n                            assert.equal(classNameIdentifier, outerClassNameReferenceIdentifierName);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #5: should generate same identifier names for class name and inner class name reference","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled","Variant #3: target `node","Variant #2: correct class name references in function scope"],"updatePoint":{"line":225,"column":121},"line":225,"code":"                        it('match #5: should generate same identifier names for class name and inner class name reference', () => {\n                            assert.equal(classNameIdentifier, innerClassNameReferenceIdentifierName);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform class name","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #1: Base"],"updatePoint":{"line":251,"column":61},"line":251,"code":"                    it('match #1: should transform class name', () => {\n                        assert.match(obfuscatedCode, classNameIdentifierRegExp);\n                    });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform class name","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #1: Base"],"updatePoint":{"line":255,"column":61},"line":255,"code":"                    it('match #2: should transform class name', () => {\n                        assert.match(obfuscatedCode, classCallIdentifierRegExp);\n                    });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform identifier name inside class method","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #2: Two classes. Transformation of identifier inside class method"],"updatePoint":{"line":278,"column":86},"line":278,"code":"                    it('match #1: should transform identifier name inside class method', () => {\n                        assert.match(obfuscatedCode, identifierRegExp1);\n                    });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform identifier name inside class method","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #2: Two classes. Transformation of identifier inside class method"],"updatePoint":{"line":282,"column":86},"line":282,"code":"                    it('match #2: should transform identifier name inside class method', () => {\n                        assert.match(obfuscatedCode, identifierRegExp2);\n                    });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform class name","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `browser","Variant #1: correct class name references in global scope"],"updatePoint":{"line":315,"column":65},"line":315,"code":"                        it('match #1: should transform class name', () => {\n                            assert.match(obfuscatedCode, classNameIdentifierRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform class name reference outside of class","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `browser","Variant #1: correct class name references in global scope"],"updatePoint":{"line":319,"column":92},"line":319,"code":"                        it('match #2: should transform class name reference outside of class', () => {\n                            assert.match(obfuscatedCode, outerClassNameReferenceRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should transform class name reference inside class","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `browser","Variant #1: correct class name references in global scope"],"updatePoint":{"line":323,"column":88},"line":323,"code":"                        it('match #3: should transform class name reference inside class', () => {\n                            assert.match(obfuscatedCode, innerClassNameReferenceRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #4: should generate same identifier names for class name and outer class name reference","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `browser","Variant #1: correct class name references in global scope"],"updatePoint":{"line":327,"column":121},"line":327,"code":"                        it('match #4: should generate same identifier names for class name and outer class name reference', () => {\n                            assert.equal(classNameIdentifier, outerClassNameReferenceIdentifierName);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #5: should generate same identifier names for class name and inner class name reference","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `browser","Variant #1: correct class name references in global scope"],"updatePoint":{"line":331,"column":121},"line":331,"code":"                        it('match #5: should generate same identifier names for class name and inner class name reference', () => {\n                            assert.equal(classNameIdentifier, innerClassNameReferenceIdentifierName);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform class name","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `browser","Variant #2: correct class name references in function scope"],"updatePoint":{"line":363,"column":65},"line":363,"code":"                        it('match #1: should transform class name', () => {\n                            assert.match(obfuscatedCode, classNameIdentifierRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform class name reference outside of class","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `browser","Variant #2: correct class name references in function scope"],"updatePoint":{"line":367,"column":92},"line":367,"code":"                        it('match #2: should transform class name reference outside of class', () => {\n                            assert.match(obfuscatedCode, outerClassNameReferenceRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should transform class name reference inside class","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `browser","Variant #2: correct class name references in function scope"],"updatePoint":{"line":371,"column":88},"line":371,"code":"                        it('match #3: should transform class name reference inside class', () => {\n                            assert.match(obfuscatedCode, innerClassNameReferenceRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #4: should generate same identifier names for class name and outer class name reference","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `browser","Variant #2: correct class name references in function scope"],"updatePoint":{"line":375,"column":121},"line":375,"code":"                        it('match #4: should generate same identifier names for class name and outer class name reference', () => {\n                            assert.equal(classNameIdentifier, outerClassNameReferenceIdentifierName);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #5: should generate same identifier names for class name and inner class name reference","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `browser","Variant #2: correct class name references in function scope"],"updatePoint":{"line":379,"column":121},"line":379,"code":"                        it('match #5: should generate same identifier names for class name and inner class name reference', () => {\n                            assert.equal(classNameIdentifier, innerClassNameReferenceIdentifierName);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform class name","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `node","Variant #1: correct class name references in global scope"],"updatePoint":{"line":413,"column":65},"line":413,"code":"                        it('match #1: should transform class name', () => {\n                            assert.match(obfuscatedCode, classNameIdentifierRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform class name reference outside of class","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `node","Variant #1: correct class name references in global scope"],"updatePoint":{"line":417,"column":92},"line":417,"code":"                        it('match #2: should transform class name reference outside of class', () => {\n                            assert.match(obfuscatedCode, outerClassNameReferenceRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should transform class name reference inside class","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `node","Variant #1: correct class name references in global scope"],"updatePoint":{"line":421,"column":88},"line":421,"code":"                        it('match #3: should transform class name reference inside class', () => {\n                            assert.match(obfuscatedCode, innerClassNameReferenceRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #4: should generate same identifier names for class name and outer class name reference","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `node","Variant #1: correct class name references in global scope"],"updatePoint":{"line":425,"column":121},"line":425,"code":"                        it('match #4: should generate same identifier names for class name and outer class name reference', () => {\n                            assert.equal(classNameIdentifier, outerClassNameReferenceIdentifierName);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #5: should generate same identifier names for class name and inner class name reference","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `node","Variant #1: correct class name references in global scope"],"updatePoint":{"line":429,"column":121},"line":429,"code":"                        it('match #5: should generate same identifier names for class name and inner class name reference', () => {\n                            assert.equal(classNameIdentifier, innerClassNameReferenceIdentifierName);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform class name","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `node","Variant #2: correct class name references in function scope"],"updatePoint":{"line":461,"column":65},"line":461,"code":"                        it('match #1: should transform class name', () => {\n                            assert.match(obfuscatedCode, classNameIdentifierRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform class name reference outside of class","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `node","Variant #2: correct class name references in function scope"],"updatePoint":{"line":465,"column":92},"line":465,"code":"                        it('match #2: should transform class name reference outside of class', () => {\n                            assert.match(obfuscatedCode, outerClassNameReferenceRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should transform class name reference inside class","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `node","Variant #2: correct class name references in function scope"],"updatePoint":{"line":469,"column":88},"line":469,"code":"                        it('match #3: should transform class name reference inside class', () => {\n                            assert.match(obfuscatedCode, innerClassNameReferenceRegExp);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #4: should generate same identifier names for class name and outer class name reference","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `node","Variant #2: correct class name references in function scope"],"updatePoint":{"line":473,"column":121},"line":473,"code":"                        it('match #4: should generate same identifier names for class name and outer class name reference', () => {\n                            assert.equal(classNameIdentifier, outerClassNameReferenceIdentifierName);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #5: should generate same identifier names for class name and inner class name reference","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #2: `classDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled","Variant #3: target: `node","Variant #2: correct class name references in function scope"],"updatePoint":{"line":477,"column":121},"line":477,"code":"                        it('match #5: should generate same identifier names for class name and inner class name reference', () => {\n                            assert.equal(classNameIdentifier, innerClassNameReferenceIdentifierName);\n                        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: shouldn't use preserved identifier name as class declaration name","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #3: preserved identifier names shouldn't be used as identifier names"],"updatePoint":{"line":504,"column":92},"line":504,"code":"            it('Match #1: shouldn\\'t use preserved identifier name as class declaration name', () => {\n                assert.match(obfuscatedCode, classDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: shouldn't use preserved identifier name as variable declarations","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #3: preserved identifier names shouldn't be used as identifier names"],"updatePoint":{"line":508,"column":91},"line":508,"code":"            it('Match #2: shouldn\\'t use preserved identifier name as variable declarations', () => {\n                assert.match(obfuscatedCode, variableDeclarationsRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: shouldn't use preserved identifier name as class reference identifier","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #3: preserved identifier names shouldn't be used as identifier names"],"updatePoint":{"line":512,"column":96},"line":512,"code":"            it('Match #3: shouldn\\'t use preserved identifier name as class reference identifier', () => {\n                assert.match(obfuscatedCode, classReferenceRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform identifiers in named export","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #5: named export"],"updatePoint":{"line":534,"column":64},"line":534,"code":"            it('shouldn\\'t transform identifiers in named export', () => {\n                assert.match(obfuscatedCode, namedExportRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should transform identifiers in variable declaration","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #6: default export"],"updatePoint":{"line":557,"column":78},"line":557,"code":"            it('Match #1: should transform identifiers in variable declaration', () => {\n                assert.match(obfuscatedCode, classDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should transform identifiers in default export","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #6: default export"],"updatePoint":{"line":561,"column":72},"line":561,"code":"            it('Match #2: should transform identifiers in default export', () => {\n                assert.match(obfuscatedCode, defaultExportRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should produce correct code","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #7: default export inline"],"updatePoint":{"line":583,"column":53},"line":583,"code":"            it('Match #1: should produce correct code', () => {\n                assert.match(obfuscatedCode, defaultExportRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should keep super class expression parenthesis","suites":["ScopeIdentifiersTransformer ClassDeclaration identifiers","transformation of `classDeclaration` node names","Variant #8: super class expression parenthesis"],"updatePoint":{"line":604,"column":72},"line":604,"code":"            it('Match #1: should keep super class expression parenthesis', () => {\n                assert.match(obfuscatedCode, defaultExportRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should transform class variable name","suites":["ScopeIdentifiersTransformer ClassExpression identifiers","transformation of ClassExpression identifiers","Variant #1: `ClassExpression` parent block scope is not a `ProgramNode`"],"updatePoint":{"line":33,"column":52},"line":33,"code":"            it('should transform class variable name', () => {\n                assert.equal(classNameIdentifier, classCallIdentifier);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-expression/ClassExpression.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't transform class name","suites":["ScopeIdentifiersTransformer ClassExpression identifiers","transformation of ClassExpression identifiers","Variant #2: `ClassExpression` parent block scope is a `ProgramNode`"],"updatePoint":{"line":55,"column":57},"line":55,"code":"            it('match #1: shouldn\\'t transform class name', () => {\n                assert.match(obfuscatedCode, classNameIdentifierRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-expression/ClassExpression.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't transform class name","suites":["ScopeIdentifiersTransformer ClassExpression identifiers","transformation of ClassExpression identifiers","Variant #2: `ClassExpression` parent block scope is a `ProgramNode`"],"updatePoint":{"line":59,"column":57},"line":59,"code":"            it('match #2: shouldn\\'t transform class name', () => {\n                assert.match(obfuscatedCode, classCallIdentifierRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/class-expression/ClassExpression.spec.ts","skipped":false,"dir":"test"},{"name":"should transform function name","suites":["ScopeIdentifiersTransformer FunctionDeclaration identifiers","transformation of `functionDeclaration` node names","Variant #1: `functionDeclaration` parent block scope is not a `ProgramNode`"],"updatePoint":{"line":34,"column":46},"line":34,"code":"            it('should transform function name', () => {\n                assert.equal(functionNameIdentifier, functionCallIdentifier);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function-declaration/FunctionDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't transform function name","suites":["ScopeIdentifiersTransformer FunctionDeclaration identifiers","transformation of `functionDeclaration` node names","Variant #2: `functionDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":57,"column":64},"line":57,"code":"                it('match #1: shouldn\\'t transform function name', () => {\n                    assert.match(obfuscatedCode, functionNameIdentifierRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function-declaration/FunctionDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't transform function name","suites":["ScopeIdentifiersTransformer FunctionDeclaration identifiers","transformation of `functionDeclaration` node names","Variant #2: `functionDeclaration` parent block scope is a `ProgramNode`","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":61,"column":64},"line":61,"code":"                it('match #2: shouldn\\'t transform function name', () => {\n                    assert.match(obfuscatedCode, functionCallIdentifierRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function-declaration/FunctionDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform function name","suites":["ScopeIdentifiersTransformer FunctionDeclaration identifiers","transformation of `functionDeclaration` node names","Variant #2: `functionDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":84,"column":60},"line":84,"code":"                it('match #1: should transform function name', () => {\n                    assert.match(obfuscatedCode, functionNameIdentifierRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function-declaration/FunctionDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform function name","suites":["ScopeIdentifiersTransformer FunctionDeclaration identifiers","transformation of `functionDeclaration` node names","Variant #2: `functionDeclaration` parent block scope is a `ProgramNode`","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":88,"column":60},"line":88,"code":"                it('match #2: should transform function name', () => {\n                    assert.match(obfuscatedCode, functionCallIdentifierRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function-declaration/FunctionDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should transform generator function name","suites":["ScopeIdentifiersTransformer FunctionDeclaration identifiers","transformation of `functionDeclaration` node names","Variant #3: generator `functionDeclaration`"],"updatePoint":{"line":115,"column":56},"line":115,"code":"            it('should transform generator function name', () => {\n                assert.equal(functionNameIdentifier, functionCallIdentifier);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function-declaration/FunctionDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should transform async function name","suites":["ScopeIdentifiersTransformer FunctionDeclaration identifiers","transformation of `functionDeclaration` node names","Variant #4: async `functionDeclaration`"],"updatePoint":{"line":141,"column":52},"line":141,"code":"            it('should transform async function name', () => {\n                assert.equal(functionNameIdentifier, functionCallIdentifier);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function-declaration/FunctionDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: shouldn't use preserved identifier name as function declaration name","suites":["ScopeIdentifiersTransformer FunctionDeclaration identifiers","transformation of `functionDeclaration` node names","Variant #5: preserved identifier names shouldn't be used as identifier names","Variant #1"],"updatePoint":{"line":165,"column":99},"line":165,"code":"                it('Match #1: shouldn\\'t use preserved identifier name as function declaration name', () => {\n                    assert.match(obfuscatedCode, functionDeclarationRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function-declaration/FunctionDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: shouldn't use preserved identifier name as variable declarations","suites":["ScopeIdentifiersTransformer FunctionDeclaration identifiers","transformation of `functionDeclaration` node names","Variant #5: preserved identifier names shouldn't be used as identifier names","Variant #1"],"updatePoint":{"line":169,"column":95},"line":169,"code":"                it('Match #2: shouldn\\'t use preserved identifier name as variable declarations', () => {\n                    assert.match(obfuscatedCode, variableDeclarationsRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function-declaration/FunctionDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform identifiers in named export","suites":["ScopeIdentifiersTransformer FunctionDeclaration identifiers","transformation of `functionDeclaration` node names","Variant #6: named export"],"updatePoint":{"line":192,"column":64},"line":192,"code":"            it('shouldn\\'t transform identifiers in named export', () => {\n                assert.match(obfuscatedCode, namedExportRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function-declaration/FunctionDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should transform identifiers in variable declaration","suites":["ScopeIdentifiersTransformer FunctionDeclaration identifiers","transformation of `functionDeclaration` node names","Variant #7: default export"],"updatePoint":{"line":215,"column":78},"line":215,"code":"            it('Match #1: should transform identifiers in variable declaration', () => {\n                assert.match(obfuscatedCode, functionDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function-declaration/FunctionDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should transform identifiers in default export","suites":["ScopeIdentifiersTransformer FunctionDeclaration identifiers","transformation of `functionDeclaration` node names","Variant #7: default export"],"updatePoint":{"line":219,"column":72},"line":219,"code":"            it('Match #2: should transform identifiers in default export', () => {\n                assert.match(obfuscatedCode, defaultExportRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function-declaration/FunctionDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should produce correct code","suites":["ScopeIdentifiersTransformer FunctionDeclaration identifiers","transformation of `functionDeclaration` node names","Variant #8: default export inline"],"updatePoint":{"line":241,"column":53},"line":241,"code":"            it('Match #1: should produce correct code', () => {\n                assert.match(obfuscatedCode, defaultExportRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function-declaration/FunctionDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should generate same names for function parameter identifier and function body identifier with same name","suites":["ScopeIdentifiersTransformer Function identifiers","identifiers transformation inside `FunctionDeclaration` and `FunctionExpression` node body"],"updatePoint":{"line":51,"column":116},"line":51,"code":"        it('should generate same names for function parameter identifier and function body identifier with same name', () => {\n            assert.equal(functionParamIdentifierName, functionBodyIdentifierName);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should generate same names for function parameter identifier and variable declaration identifier with same name","suites":["ScopeIdentifiersTransformer Function identifiers","identifiers transformation inside `FunctionDeclaration` and `FunctionExpression` node body"],"updatePoint":{"line":55,"column":123},"line":55,"code":"        it('should generate same names for function parameter identifier and variable declaration identifier with same name', () => {\n            assert.equal(functionParamIdentifierName, variableDeclarationIdentifierName);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform both variable declaration identifier and return statement identifier with same name","suites":["ScopeIdentifiersTransformer Function identifiers","identifiers transformation inside `FunctionDeclaration` and `FunctionExpression` node body"],"updatePoint":{"line":59,"column":122},"line":59,"code":"        it('should correctly transform both variable declaration identifier and return statement identifier with same name', () => {\n            assert.equal(variableDeclarationIdentifierName, returnStatementIdentifierName);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform other variables in function body","suites":["ScopeIdentifiersTransformer Function identifiers","identifiers transformation inside `FunctionDeclaration` and `FunctionExpression` node body"],"updatePoint":{"line":63,"column":65},"line":63,"code":"        it('shouldn\\'t transform other variables in function body', () => {\n            assert.match(obfuscatedCode, variableReferenceRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform function expression parameter identifier","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #1"],"updatePoint":{"line":101,"column":83},"line":101,"code":"            it('should correctly transform function expression parameter identifier', () => {\n                assert.match(obfuscatedCode, functionExpressionParamIdentifierRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform function parameter identifier","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #1"],"updatePoint":{"line":105,"column":72},"line":105,"code":"            it('should correctly transform function parameter identifier', () => {\n                assert.match(obfuscatedCode, innerFunctionNameIdentifierRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform function object parameter identifier","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #1"],"updatePoint":{"line":109,"column":79},"line":109,"code":"            it('should correctly transform function object parameter identifier', () => {\n                assert.match(obfuscatedCode, functionObjectIdentifierRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should generate same names for function parameter and function object identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #1"],"updatePoint":{"line":113,"column":97},"line":113,"code":"            it('should generate same names for function parameter and function object identifiers', () => {\n                assert.equal(innerFunctionNameIdentifierName, functionObjectIdentifierName);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should generate same names for function parameter identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #1"],"updatePoint":{"line":117,"column":77},"line":117,"code":"            it('should generate same names for function parameter identifiers', () => {\n                assert.equal(functionExpressionParamIdentifierName, innerFunctionNameIdentifierName);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should generate same names for function expression parameter and function object identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #1"],"updatePoint":{"line":121,"column":108},"line":121,"code":"            it('should generate same names for function expression parameter and function object identifiers', () => {\n                assert.equal(functionExpressionParamIdentifierName, functionObjectIdentifierName);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform function identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #2"],"updatePoint":{"line":155,"column":63},"line":155,"code":"            it('should correctly transform function identifiers', () => {\n                assert.match(obfuscatedCode, functionIdentifiersRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform function object parameter identifier","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #2"],"updatePoint":{"line":159,"column":79},"line":159,"code":"            it('should correctly transform function object parameter identifier', () => {\n                assert.match(obfuscatedCode, functionObjectIdentifierRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should generate same names for function id and function object identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #2"],"updatePoint":{"line":163,"column":90},"line":163,"code":"            it('should generate same names for function id and function object identifiers', () => {\n                assert.equal(functionIdentifierName, functionObjectIdentifierName);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should't generate same names for function id and parameter identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #2"],"updatePoint":{"line":167,"column":87},"line":167,"code":"            it('should\\'t generate same names for function id and parameter identifiers', () => {\n                assert.notEqual(functionIdentifierName, functionParamIdentifierName);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform function identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #3: global function declaration identifier","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":203,"column":67},"line":203,"code":"                it('should correctly transform function identifiers', () => {\n                    assert.match(obfuscatedCode, functionIdentifiersRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform function object parameter identifier","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #3: global function declaration identifier","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":207,"column":83},"line":207,"code":"                it('should correctly transform function object parameter identifier', () => {\n                    assert.match(obfuscatedCode, functionObjectIdentifierRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should generate same names for function id and function object identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #3: global function declaration identifier","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":211,"column":94},"line":211,"code":"                it('should generate same names for function id and function object identifiers', () => {\n                    assert.equal(functionIdentifierName, functionObjectIdentifierName);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should generate different names for function parameter and function object identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #3: global function declaration identifier","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":215,"column":106},"line":215,"code":"                it('should generate different names for function parameter and function object identifiers', () => {\n                    assert.notEqual(functionParamIdentifierName, functionObjectIdentifierName);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should generate different names for function id and parameter identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #3: global function declaration identifier","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":219,"column":93},"line":219,"code":"                it('should generate different names for function id and parameter identifiers', () => {\n                    assert.notEqual(functionIdentifierName, functionParamIdentifierName);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform function identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #3: global function declaration identifier","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":254,"column":67},"line":254,"code":"                it('should correctly transform function identifiers', () => {\n                    assert.match(obfuscatedCode, functionIdentifiersRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly transform function object parameter identifier","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #3: global function declaration identifier","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":258,"column":83},"line":258,"code":"                it('should correctly transform function object parameter identifier', () => {\n                    assert.match(obfuscatedCode, functionObjectIdentifierRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should generate same names for function id and function object identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #3: global function declaration identifier","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":262,"column":94},"line":262,"code":"                it('should generate same names for function id and function object identifiers', () => {\n                    assert.equal(functionIdentifierName, functionObjectIdentifierName);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't generate same names for function parameter and function object identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #3: global function declaration identifier","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":266,"column":105},"line":266,"code":"                it('shouldn\\'t generate same names for function parameter and function object identifiers', () => {\n                    assert.notEqual(functionParamIdentifierName, functionObjectIdentifierName);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't generate same names for function id and parameter identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","function id name obfuscation","Variant #3: global function declaration identifier","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":270,"column":92},"line":270,"code":"                it('shouldn\\'t generate same names for function id and parameter identifiers', () => {\n                    assert.notEqual(functionIdentifierName, functionParamIdentifierName);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't transform function parameter object pattern identifier","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #1: simple"],"updatePoint":{"line":297,"column":91},"line":297,"code":"            it('match #1: shouldn\\'t transform function parameter object pattern identifier', () => {\n                assert.match(obfuscatedCode, functionParameterRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't transform function parameter object pattern identifier","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #1: simple"],"updatePoint":{"line":301,"column":91},"line":301,"code":"            it('match #2: shouldn\\'t transform function parameter object pattern identifier', () => {\n                assert.match(obfuscatedCode, functionBodyRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform function parameter identifier","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #2: correct transformation when identifier with same name in parent scope exist"],"updatePoint":{"line":325,"column":72},"line":325,"code":"            it('match #1: should transform function parameter identifier', () => {\n                assert.match(obfuscatedCode, functionParameterRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't transform callback parameter object pattern identifier","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #2: correct transformation when identifier with same name in parent scope exist"],"updatePoint":{"line":329,"column":91},"line":329,"code":"            it('match #2: shouldn\\'t transform callback parameter object pattern identifier', () => {\n                assert.match(obfuscatedCode, callbackParameterRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: shouldn't transform callback body identifier","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #2: correct transformation when identifier with same name in parent scope exist"],"updatePoint":{"line":333,"column":71},"line":333,"code":"            it('match #3: shouldn\\'t transform callback body identifier', () => {\n                assert.match(obfuscatedCode, callbackBodyRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #4: should transform identifier in `ReturnStatement`","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #2: correct transformation when identifier with same name in parent scope exist"],"updatePoint":{"line":337,"column":74},"line":337,"code":"            it('match #4: should transform identifier in `ReturnStatement`', () => {\n                assert.match(obfuscatedCode, returnRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform function parameter object pattern rest identifier","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #3: correct transformation when parent scope identifier conflicts with current scope object pattern identifier"],"updatePoint":{"line":361,"column":92},"line":361,"code":"            it('match #1: should transform function parameter object pattern rest identifier', () => {\n                assert.match(obfuscatedCode, functionObjectPatternParameterRegExp1);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform function parameter object pattern rest identifier","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #3: correct transformation when parent scope identifier conflicts with current scope object pattern identifier"],"updatePoint":{"line":365,"column":92},"line":365,"code":"            it('match #2: should transform function parameter object pattern rest identifier', () => {\n                assert.match(obfuscatedCode, functionObjectPatternParameterRegExp2);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should transform identifier in `ReturnStatement` of inner function","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #3: correct transformation when parent scope identifier conflicts with current scope object pattern identifier"],"updatePoint":{"line":369,"column":92},"line":369,"code":"            it('match #3: should transform identifier in `ReturnStatement` of inner function', () => {\n                assert.match(obfuscatedCode, returnRegExp1);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #4: should transform identifier in `ReturnStatement` of outer function","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #3: correct transformation when parent scope identifier conflicts with current scope object pattern identifier"],"updatePoint":{"line":373,"column":92},"line":373,"code":"            it('match #4: should transform identifier in `ReturnStatement` of outer function', () => {\n                assert.match(obfuscatedCode, returnRegExp2);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform function parameter object pattern rest identifier","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #4: shorthand property node"],"updatePoint":{"line":397,"column":92},"line":397,"code":"            it('match #1: should transform function parameter object pattern rest identifier', () => {\n                assert.match(obfuscatedCode, functionObjectPatternParameterRegExp1);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform function parameter object pattern rest identifier","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #4: shorthand property node"],"updatePoint":{"line":401,"column":92},"line":401,"code":"            it('match #2: should transform function parameter object pattern rest identifier', () => {\n                assert.match(obfuscatedCode, functionObjectPatternParameterRegExp2);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should transform identifier in `console.log` of outer function","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #4: shorthand property node"],"updatePoint":{"line":405,"column":88},"line":405,"code":"            it('match #3: should transform identifier in `console.log` of outer function', () => {\n                assert.match(obfuscatedCode, consoleLogRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #4: should transform identifier in `ReturnStatement` of inner function","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #4: shorthand property node"],"updatePoint":{"line":409,"column":92},"line":409,"code":"            it('match #4: should transform identifier in `ReturnStatement` of inner function', () => {\n                assert.match(obfuscatedCode, returnRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't transform function parameter identifier and reference identifier","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #5: skip rename of object pattern referenced identifier"],"updatePoint":{"line":429,"column":101},"line":429,"code":"            it('match #1: shouldn\\'t transform function parameter identifier and reference identifier', () => {\n                assert.match(obfuscatedCode, objectPatternRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't transform function parameter object pattern property identifier","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #6: skip rename of object pattern property identifier with default value"],"updatePoint":{"line":451,"column":100},"line":451,"code":"            it('match #1: shouldn\\'t transform function parameter object pattern property identifier', () => {\n                assert.match(obfuscatedCode, functionParameterRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't transform function body identifier","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #6: skip rename of object pattern property identifier with default value"],"updatePoint":{"line":455,"column":71},"line":455,"code":"            it('match #2: shouldn\\'t transform function body identifier', () => {\n                assert.match(obfuscatedCode, functionBodyRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should correctly transform function parameter identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #7: skip rename of object pattern property identifier with default value and property alias"],"updatePoint":{"line":477,"column":83},"line":477,"code":"            it('match #1: should correctly transform function parameter identifiers', () => {\n                assert.match(obfuscatedCode, functionParameterRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #2:should correctly transform function body identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","object pattern as parameter","Variant #7: skip rename of object pattern property identifier with default value and property alias"],"updatePoint":{"line":481,"column":77},"line":481,"code":"            it('match #2:should correctly transform function body identifiers', () => {\n                assert.match(obfuscatedCode, functionBodyRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform function parameter assignment pattern identifier","suites":["ScopeIdentifiersTransformer Function identifiers","assignment pattern as parameter","Variant #1: literal as right value"],"updatePoint":{"line":505,"column":91},"line":505,"code":"            it('match #1: should transform function parameter assignment pattern identifier', () => {\n                assert.match(obfuscatedCode, functionParameterRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform function parameter assignment pattern identifier","suites":["ScopeIdentifiersTransformer Function identifiers","assignment pattern as parameter","Variant #1: literal as right value"],"updatePoint":{"line":509,"column":91},"line":509,"code":"            it('match #2: should transform function parameter assignment pattern identifier', () => {\n                assert.match(obfuscatedCode, functionBodyRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform function parameter assignment pattern identifier","suites":["ScopeIdentifiersTransformer Function identifiers","assignment pattern as parameter","Variant #2: identifier as right value"],"updatePoint":{"line":540,"column":91},"line":540,"code":"            it('match #1: should transform function parameter assignment pattern identifier', () => {\n                assert.match(obfuscatedCode, variableDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform function parameter assignment pattern identifier","suites":["ScopeIdentifiersTransformer Function identifiers","assignment pattern as parameter","Variant #2: identifier as right value"],"updatePoint":{"line":544,"column":91},"line":544,"code":"            it('match #2: should transform function parameter assignment pattern identifier', () => {\n                assert.match(obfuscatedCode, functionParameterRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should transform function parameter assignment pattern identifier","suites":["ScopeIdentifiersTransformer Function identifiers","assignment pattern as parameter","Variant #2: identifier as right value"],"updatePoint":{"line":548,"column":91},"line":548,"code":"            it('match #3: should transform function parameter assignment pattern identifier', () => {\n                assert.match(obfuscatedCode, functionBodyRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should keep same names for identifier in variable declaration and default value identifier of function parameter","suites":["ScopeIdentifiersTransformer Function identifiers","assignment pattern as parameter","Variant #2: identifier as right value"],"updatePoint":{"line":552,"column":128},"line":552,"code":"            it('should keep same names for identifier in variable declaration and default value identifier of function parameter', () => {\n                assert.equal(variableDeclarationIdentifierName, functionDefaultParameterIdentifierName);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should keep same names for identifiers in function params and function body","suites":["ScopeIdentifiersTransformer Function identifiers","assignment pattern as parameter","Variant #2: identifier as right value"],"updatePoint":{"line":556,"column":91},"line":556,"code":"            it('should keep same names for identifiers in function params and function body', () => {\n                assert.equal(functionParameterIdentifierName, functionBodyIdentifierName);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform function parameter assignment pattern identifier","suites":["ScopeIdentifiersTransformer Function identifiers","assignment pattern as parameter","Variant #3: identifier as right value"],"updatePoint":{"line":593,"column":91},"line":593,"code":"            it('match #1: should transform function parameter assignment pattern identifier', () => {\n                assert.match(obfuscatedCode, variableDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform function parameter assignment pattern identifier","suites":["ScopeIdentifiersTransformer Function identifiers","assignment pattern as parameter","Variant #3: identifier as right value"],"updatePoint":{"line":597,"column":91},"line":597,"code":"            it('match #2: should transform function parameter assignment pattern identifier', () => {\n                assert.match(obfuscatedCode, functionParameterRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should transform function parameter assignment pattern identifier","suites":["ScopeIdentifiersTransformer Function identifiers","assignment pattern as parameter","Variant #3: identifier as right value"],"updatePoint":{"line":601,"column":91},"line":601,"code":"            it('match #3: should transform function parameter assignment pattern identifier', () => {\n                assert.match(obfuscatedCode, functionBodyRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"equal #1:shouldn't keep same names for variable declaration identifier and function parameters identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","assignment pattern as parameter","Variant #3: identifier as right value"],"updatePoint":{"line":605,"column":123},"line":605,"code":"            it('equal #1:shouldn\\'t keep same names for variable declaration identifier and function parameters identifiers', () => {\n                assert.notEqual(variableDeclarationIdentifierName, functionParameterIdentifierName);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"equal #2: shouldn't keep same names for variable declaration identifier and function parameters identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","assignment pattern as parameter","Variant #3: identifier as right value"],"updatePoint":{"line":609,"column":124},"line":609,"code":"            it('equal #2: shouldn\\'t keep same names for variable declaration identifier and function parameters identifiers', () => {\n                assert.notEqual(variableDeclarationIdentifierName, functionDefaultParameterIdentifierName1);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"equal #3: shouldn't keep same names for variable declaration identifier and function parameters identifiers","suites":["ScopeIdentifiersTransformer Function identifiers","assignment pattern as parameter","Variant #3: identifier as right value"],"updatePoint":{"line":613,"column":124},"line":613,"code":"            it('equal #3: shouldn\\'t keep same names for variable declaration identifier and function parameters identifiers', () => {\n                assert.notEqual(variableDeclarationIdentifierName, functionDefaultParameterIdentifierName2);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"equal #4: should keep same names for identifier in first function parameter and default value identifier of second function parameter","suites":["ScopeIdentifiersTransformer Function identifiers","assignment pattern as parameter","Variant #3: identifier as right value"],"updatePoint":{"line":617,"column":149},"line":617,"code":"            it('equal #4: should keep same names for identifier in first function parameter and default value identifier of second function parameter', () => {\n                assert.equal(functionParameterIdentifierName, functionDefaultParameterIdentifierName2);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"equal #5: should keep same names for identifiers in function params and function body","suites":["ScopeIdentifiersTransformer Function identifiers","assignment pattern as parameter","Variant #3: identifier as right value"],"updatePoint":{"line":621,"column":101},"line":621,"code":"            it('equal #5: should keep same names for identifiers in function params and function body', () => {\n                assert.equal(functionParameterIdentifierName, functionBodyIdentifierName1);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"equal #6: should keep same names for identifiers in function params and function body","suites":["ScopeIdentifiersTransformer Function identifiers","assignment pattern as parameter","Variant #3: identifier as right value"],"updatePoint":{"line":625,"column":101},"line":625,"code":"            it('equal #6: should keep same names for identifiers in function params and function body', () => {\n                assert.equal(functionDefaultParameterIdentifierName1, functionBodyIdentifierName2);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"equal #1: should keep same names for identifiers in function parameter array pattern and function body","suites":["ScopeIdentifiersTransformer Function identifiers","array pattern as parameter"],"updatePoint":{"line":656,"column":114},"line":656,"code":"        it('equal #1: should keep same names for identifiers in function parameter array pattern and function body', () => {\n            assert.equal(arrayPatternIdentifierName1, functionBodyIdentifierName1);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"equal #2: should keep same names for identifiers in function parameter array pattern and function body","suites":["ScopeIdentifiersTransformer Function identifiers","array pattern as parameter"],"updatePoint":{"line":660,"column":114},"line":660,"code":"        it('equal #2: should keep same names for identifiers in function parameter array pattern and function body', () => {\n            assert.equal(arrayPatternIdentifierName2, functionBodyIdentifierName2);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should transform function rest parameter","suites":["ScopeIdentifiersTransformer Function identifiers","rest parameters"],"updatePoint":{"line":682,"column":62},"line":682,"code":"        it('Match #1: should transform function rest parameter', () => {\n            assert.match(obfuscatedCode, functionRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should transform identifiers inside function body","suites":["ScopeIdentifiersTransformer Function identifiers","rest parameters"],"updatePoint":{"line":686,"column":71},"line":686,"code":"        it('Match #2: should transform identifiers inside function body', () => {\n            assert.match(obfuscatedCode, returnRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should transform function rest parameter","suites":["ScopeIdentifiersTransformer Function identifiers","array rest parameter"],"updatePoint":{"line":708,"column":62},"line":708,"code":"        it('Match #1: should transform function rest parameter', () => {\n            assert.match(obfuscatedCode, functionRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should transform identifiers inside function body","suites":["ScopeIdentifiersTransformer Function identifiers","array rest parameter"],"updatePoint":{"line":712,"column":71},"line":712,"code":"        it('Match #2: should transform identifiers inside function body', () => {\n            assert.match(obfuscatedCode, returnRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should transform function rest parameter","suites":["ScopeIdentifiersTransformer Function identifiers","object rest parameter"],"updatePoint":{"line":736,"column":62},"line":736,"code":"        it('Match #1: should transform function rest parameter', () => {\n            assert.match(obfuscatedCode, functionRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should transform identifiers inside function body","suites":["ScopeIdentifiersTransformer Function identifiers","object rest parameter"],"updatePoint":{"line":740,"column":71},"line":740,"code":"        it('Match #2: should transform identifiers inside function body', () => {\n            assert.match(obfuscatedCode, returnRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn transform variable declaration","suites":["ScopeIdentifiersTransformer Function identifiers","parameter default value","Variant #1: default parameter as identifier"],"updatePoint":{"line":764,"column":64},"line":764,"code":"            it('match #1: shouldn transform variable declaration', () => {\n                assert.match(obfuscatedCode, variableDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn transform function parameters","suites":["ScopeIdentifiersTransformer Function identifiers","parameter default value","Variant #1: default parameter as identifier"],"updatePoint":{"line":768,"column":63},"line":768,"code":"            it('match #2: shouldn transform function parameters', () => {\n                assert.match(obfuscatedCode, functionParameterRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: shouldn transform function body","suites":["ScopeIdentifiersTransformer Function identifiers","parameter default value","Variant #1: default parameter as identifier"],"updatePoint":{"line":772,"column":57},"line":772,"code":"            it('match #3: shouldn transform function body', () => {\n                assert.match(obfuscatedCode, functionBodyRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should transform identifiers in function body","suites":["ScopeIdentifiersTransformer Function identifiers","ignored identifier names set","Variant #1: avoid to add `ObjectPattern` identifier to the set when same identifier exist in function parameter"],"updatePoint":{"line":797,"column":61},"line":797,"code":"            it('should transform identifiers in function body', () => {\n                assert.match(obfuscatedCode, functionBodyRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should transform identifiers in arrow function expression body","suites":["ScopeIdentifiersTransformer Function identifiers","correct block scope detection of arrow function expression","Variant #1: block statement body"],"updatePoint":{"line":825,"column":78},"line":825,"code":"            it('should transform identifiers in arrow function expression body', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should transform identifiers in arrow function expression body","suites":["ScopeIdentifiersTransformer Function identifiers","correct block scope detection of arrow function expression","Variant #2: expression statement body"],"updatePoint":{"line":851,"column":78},"line":851,"code":"            it('should transform identifiers in arrow function expression body', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/function/Function.spec.ts","skipped":false,"dir":"test"},{"name":"should transform import specifier identifier name","suites":["ScopeIdentifiersTransformer ImportDeclaration identifiers","transformation of `importSpecifier` node identifiers","Variant #1: `defaultImportSpecifier` node"],"updatePoint":{"line":33,"column":65},"line":33,"code":"            it('should transform import specifier identifier name', () => {\n                assert.equal(importSpecifierIdentifier, consoleLogIdentifier);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/import-declaration/ImportDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should transform import specifier identifier name","suites":["ScopeIdentifiersTransformer ImportDeclaration identifiers","transformation of `importSpecifier` node identifiers","Variant #2: `namespaceImportSpecifier` node"],"updatePoint":{"line":59,"column":65},"line":59,"code":"            it('should transform import specifier identifier name', () => {\n                assert.equal(importSpecifierIdentifier, consoleLogIdentifier);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/import-declaration/ImportDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: shouldn't transform import specifier identifier name","suites":["ScopeIdentifiersTransformer ImportDeclaration identifiers","transformation of `importSpecifier` node identifiers","Variant #3: named `importSpecifier` node","Variant #1: named import specifier with same `import` and `local` names"],"updatePoint":{"line":82,"column":83},"line":82,"code":"                it('Match #1: shouldn\\'t transform import specifier identifier name', () => {\n                    assert.match(obfuscatedCode, importSpecifierRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/import-declaration/ImportDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: shouldn't transform import specifier identifier name","suites":["ScopeIdentifiersTransformer ImportDeclaration identifiers","transformation of `importSpecifier` node identifiers","Variant #3: named `importSpecifier` node","Variant #1: named import specifier with same `import` and `local` names"],"updatePoint":{"line":86,"column":83},"line":86,"code":"                it('Match #2: shouldn\\'t transform import specifier identifier name', () => {\n                    assert.match(obfuscatedCode, consoleLogRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/import-declaration/ImportDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should transform import specifier identifier name","suites":["ScopeIdentifiersTransformer ImportDeclaration identifiers","transformation of `importSpecifier` node identifiers","Variant #3: named `importSpecifier` node","Variant #2: named import specifier with different `import` and `local` names"],"updatePoint":{"line":112,"column":69},"line":112,"code":"                it('should transform import specifier identifier name', () => {\n                    assert.equal(importSpecifierIdentifier, consoleLogIdentifier);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/import-declaration/ImportDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should transform import specifier identifier name","suites":["ScopeIdentifiersTransformer ImportDeclaration identifiers","transformation of `importSpecifier` node identifiers","Variant #4: `identifiersPrefix` option"],"updatePoint":{"line":140,"column":65},"line":140,"code":"            it('should transform import specifier identifier name', () => {\n                assert.equal(importSpecifierIdentifier, consoleLogIdentifier);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/import-declaration/ImportDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match 1: should transform first import specifier identifier name","suites":["ScopeIdentifiersTransformer ImportDeclaration identifiers","transformation of `importSpecifier` node identifiers","Variant #5: Issue-360, prevent of set `renamedIdentifier` metadata property of all traversed identifiers"],"updatePoint":{"line":164,"column":80},"line":164,"code":"            it('Match 1: should transform first import specifier identifier name', () => {\n                assert.match(obfuscatedCode, importSpecifierRegExp1);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/import-declaration/ImportDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match 2: should transform second import specifier identifier name","suites":["ScopeIdentifiersTransformer ImportDeclaration identifiers","transformation of `importSpecifier` node identifiers","Variant #5: Issue-360, prevent of set `renamedIdentifier` metadata property of all traversed identifiers"],"updatePoint":{"line":168,"column":81},"line":168,"code":"            it('Match 2: should transform second import specifier identifier name', () => {\n                assert.match(obfuscatedCode, importSpecifierRegExp2);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/import-declaration/ImportDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match 3: should transform variable declaration identifier name","suites":["ScopeIdentifiersTransformer ImportDeclaration identifiers","transformation of `importSpecifier` node identifiers","Variant #5: Issue-360, prevent of set `renamedIdentifier` metadata property of all traversed identifiers"],"updatePoint":{"line":172,"column":78},"line":172,"code":"            it('Match 3: should transform variable declaration identifier name', () => {\n                assert.match(obfuscatedCode, variableDeclarationIdentifierRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/import-declaration/ImportDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should support dynamic import","suites":["ScopeIdentifiersTransformer ImportDeclaration identifiers","transformation of `importSpecifier` node identifiers","Variant #6: dynamic import support"],"updatePoint":{"line":194,"column":45},"line":194,"code":"            it('should support dynamic import', () => {\n                assert.match(obfuscatedCode, dynamicImportRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/import-declaration/ImportDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform `variableDeclaration` node","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #1: default behaviour"],"updatePoint":{"line":32,"column":65},"line":32,"code":"        it('match #1: should transform `variableDeclaration` node', () => {\n            assert.match(obfuscatedCode, variableDeclarationRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform `variableDeclaration` node","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #1: default behaviour"],"updatePoint":{"line":36,"column":65},"line":36,"code":"        it('match #2: should transform `variableDeclaration` node', () => {\n            assert.match(obfuscatedCode, variableCallRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't transform `variableDeclaration` node","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #2: parent block scope node is `Program` node","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":59,"column":73},"line":59,"code":"            it('match #1: shouldn\\'t transform `variableDeclaration` node', () => {\n                assert.match(obfuscatedCode, variableDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't transform `variableDeclaration` node","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #2: parent block scope node is `Program` node","Variant #1: `renameGlobals` option is disabled"],"updatePoint":{"line":63,"column":73},"line":63,"code":"            it('match #2: shouldn\\'t transform `variableDeclaration` node', () => {\n                assert.match(obfuscatedCode, variableCallRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform `variableDeclaration` node","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #2: parent block scope node is `Program` node","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":86,"column":69},"line":86,"code":"            it('match #1: should transform `variableDeclaration` node', () => {\n                assert.match(obfuscatedCode, variableDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform `variableDeclaration` node","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #2: parent block scope node is `Program` node","Variant #2: `renameGlobals` option is enabled"],"updatePoint":{"line":90,"column":69},"line":90,"code":"            it('match #2: should transform `variableDeclaration` node', () => {\n                assert.match(obfuscatedCode, variableCallRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should transform variable call (`identifier` node) outside of block scope of node in which this variable was declared with `var` kind","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #3: scope of `var` kind"],"updatePoint":{"line":112,"column":145},"line":112,"code":"        it('should transform variable call (`identifier` node) outside of block scope of node in which this variable was declared with `var` kind', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform variable call (`identifier` node) outside of block scope of node in which this variable was declared with `let` kind","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #4: scope of `let` kind"],"updatePoint":{"line":133,"column":149},"line":133,"code":"        it('shouldn\\'t transform variable call (`identifier` node) outside of block scope of node in which this variable was declared with `let` kind', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should transform variable call (`identifier` node name) before variable declaration if this call is inside function body","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #5: variable calls before variable declaration"],"updatePoint":{"line":155,"column":132},"line":155,"code":"        it('should transform variable call (`identifier` node name) before variable declaration if this call is inside function body', () => {\n            assert.match(obfuscatedCode, functionBodyVariableCallRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should transform variable call (`identifier` node name) before variable declaration","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #5: variable calls before variable declaration"],"updatePoint":{"line":159,"column":95},"line":159,"code":"        it('should transform variable call (`identifier` node name) before variable declaration', () => {\n            assert.match(obfuscatedCode, variableCallBeforeDeclarationRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"equal #1: should generate different names for identifiers inside inner function and outer function params","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #6: variable calls before variable declaration when function param has the same name as variables name"],"updatePoint":{"line":194,"column":117},"line":194,"code":"        it('equal #1: should generate different names for identifiers inside inner function and outer function params', () => {\n            assert.notEqual(outerFunctionParamIdentifierName, consoleLogIdentifierName);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"equal #2: should generate same names for identifiers of outer function params and inner function params","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #6: variable calls before variable declaration when function param has the same name as variables name"],"updatePoint":{"line":198,"column":115},"line":198,"code":"        it('equal #2: should generate same names for identifiers of outer function params and inner function params', () => {\n            assert.notEqual(outerFunctionParamIdentifierName, innerFunctionParamIdentifierName);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"equal #1: should correct transform variables inside outer function body","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #6: variable calls before variable declaration when function param has the same name as variables name"],"updatePoint":{"line":202,"column":83},"line":202,"code":"        it('equal #1: should correct transform variables inside outer function body', () => {\n            assert.notEqual(outerFunctionParamIdentifierName, objectIdentifierName);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"equal #2: should correct transform variables inside outer function body","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #6: variable calls before variable declaration when function param has the same name as variables name"],"updatePoint":{"line":206,"column":83},"line":206,"code":"        it('equal #2: should correct transform variables inside outer function body', () => {\n            assert.notEqual(outerFunctionParamIdentifierName, variableDeclarationIdentifierName);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"equal #3: should correct transform variables inside outer function body","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #6: variable calls before variable declaration when function param has the same name as variables name"],"updatePoint":{"line":210,"column":83},"line":210,"code":"        it('equal #3: should correct transform variables inside outer function body', () => {\n            assert.equal(variableDeclarationIdentifierName, objectIdentifierName);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should correct transform variables inside inner function body","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #6: variable calls before variable declaration when function param has the same name as variables name"],"updatePoint":{"line":214,"column":73},"line":214,"code":"        it('should correct transform variables inside inner function body', () => {\n            assert.equal(innerFunctionParamIdentifierName, consoleLogIdentifierName);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should generate different names for identifiers inside inner function and catch clause param","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #7: variable calls before variable declaration when catch clause param has the same name as variables name"],"updatePoint":{"line":249,"column":114},"line":249,"code":"        it('match #1: should generate different names for identifiers inside inner function and catch clause param', () => {\n            assert.notEqual(catchClauseParamIdentifierName, consoleLogIdentifierName);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should generate different names for identifiers inside inner function and catch clause param","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #7: variable calls before variable declaration when catch clause param has the same name as variables name"],"updatePoint":{"line":253,"column":114},"line":253,"code":"        it('match #2: should generate different names for identifiers inside inner function and catch clause param', () => {\n            assert.notEqual(catchClauseParamIdentifierName, innerFunctionParamIdentifierName);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"equal #1: should correct transform variables inside catch clause body","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #7: variable calls before variable declaration when catch clause param has the same name as variables name"],"updatePoint":{"line":257,"column":81},"line":257,"code":"        it('equal #1: should correct transform variables inside catch clause body', () => {\n            assert.notEqual(catchClauseParamIdentifierName, objectIdentifierName);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"equal #2: should correct transform variables inside catch clause body","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #7: variable calls before variable declaration when catch clause param has the same name as variables name"],"updatePoint":{"line":261,"column":81},"line":261,"code":"        it('equal #2: should correct transform variables inside catch clause body', () => {\n            assert.notEqual(catchClauseParamIdentifierName, variableDeclarationIdentifierName);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should correct transform variables inside inner function body","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #7: variable calls before variable declaration when catch clause param has the same name as variables name"],"updatePoint":{"line":265,"column":73},"line":265,"code":"        it('should correct transform variables inside inner function body', () => {\n            assert.equal(innerFunctionParamIdentifierName, consoleLogIdentifierName);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should keep equal names after transformation for variables with same names","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #7: variable calls before variable declaration when catch clause param has the same name as variables name"],"updatePoint":{"line":269,"column":86},"line":269,"code":"        it('should keep equal names after transformation for variables with same names', () => {\n            assert.equal(variableDeclarationIdentifierName, objectIdentifierName);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't replace property node identifier","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #8: wrong replacement","Variant #1: property node identifier"],"updatePoint":{"line":291,"column":59},"line":291,"code":"            it('shouldn\\'t replace property node identifier', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't replace computed member expression identifier","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #8: wrong replacement","Variant #2: computed member expression identifier"],"updatePoint":{"line":312,"column":72},"line":312,"code":"            it('shouldn\\'t replace computed member expression identifier', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't transform object pattern variable declarator","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #9: object pattern as variable declarator","Variant #1: single level object pattern"],"updatePoint":{"line":339,"column":81},"line":339,"code":"            it('match #1: shouldn\\'t transform object pattern variable declarator', () => {\n                assert.match(obfuscatedCode, objectPatternVariableDeclaratorRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't transform object pattern variable declarator","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #9: object pattern as variable declarator","Variant #1: single level object pattern"],"updatePoint":{"line":343,"column":81},"line":343,"code":"            it('match #2: shouldn\\'t transform object pattern variable declarator', () => {\n                assert.match(obfuscatedCode, variableUsageRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: shouldn't transform object pattern variable declarator","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #9: object pattern as variable declarator","Variant #2: nested object pattern with property alias"],"updatePoint":{"line":366,"column":81},"line":366,"code":"            it('match #1: shouldn\\'t transform object pattern variable declarator', () => {\n                assert.match(obfuscatedCode, objectPatternVariableDeclaratorRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: shouldn't transform object pattern variable declarator","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #9: object pattern as variable declarator","Variant #2: nested object pattern with property alias"],"updatePoint":{"line":370,"column":81},"line":370,"code":"            it('match #2: shouldn\\'t transform object pattern variable declarator', () => {\n                assert.match(obfuscatedCode, variableUsageRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform array pattern variable declarator","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #10: array pattern as variable declarator"],"updatePoint":{"line":402,"column":72},"line":402,"code":"        it('match #1: should transform array pattern variable declarator', () => {\n            assert.match(obfuscatedCode, objectPatternVariableDeclaratorRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform array pattern variable declarator","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #10: array pattern as variable declarator"],"updatePoint":{"line":406,"column":72},"line":406,"code":"        it('match #2: should transform array pattern variable declarator', () => {\n            assert.match(obfuscatedCode, variableUsageRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"equal #1: should keep same identifier names same for identifiers in variable declaration and after variable declaration","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #10: array pattern as variable declarator"],"updatePoint":{"line":410,"column":131},"line":410,"code":"        it('equal #1: should keep same identifier names same for identifiers in variable declaration and after variable declaration', () => {\n            assert.equal(objectPatternIdentifierName1, identifierName1);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"equal #2: should keep same identifier names same for identifiers in variable declaration and after variable declaration","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #10: array pattern as variable declarator"],"updatePoint":{"line":414,"column":131},"line":414,"code":"        it('equal #2: should keep same identifier names same for identifiers in variable declaration and after variable declaration', () => {\n            assert.equal(objectPatternIdentifierName2, identifierName2);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should transform computed object expression identifier","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #11: computed object expression identifier"],"updatePoint":{"line":435,"column":66},"line":435,"code":"        it('should transform computed object expression identifier', () => {\n            assert.match(obfuscatedCode, computedObjectExpressionRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform method definition node key identifier","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #12: method definition key identifier"],"updatePoint":{"line":456,"column":70},"line":456,"code":"        it('shouldn\\'t transform method definition node key identifier', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: shouldn't use preserved identifier name as variable declaration name","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #13: preserved identifier names shouldn't be used as identifier names","Variant #1"],"updatePoint":{"line":483,"column":95},"line":483,"code":"            it('Match #1: shouldn\\'t use preserved identifier name as variable declaration name', () => {\n                assert.match(obfuscatedCode, variableDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: shouldn't use preserved identifier name as function declaration name","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #13: preserved identifier names shouldn't be used as identifier names","Variant #1"],"updatePoint":{"line":487,"column":95},"line":487,"code":"            it('Match #2: shouldn\\'t use preserved identifier name as function declaration name', () => {\n                assert.match(obfuscatedCode, functionDeclarationRegExp1);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: shouldn't use preserved identifier name as function declaration name","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #13: preserved identifier names shouldn't be used as identifier names","Variant #1"],"updatePoint":{"line":491,"column":95},"line":491,"code":"            it('Match #3: shouldn\\'t use preserved identifier name as function declaration name', () => {\n                assert.match(obfuscatedCode, functionDeclarationRegExp2);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #4: shouldn't use preserved identifier name as function declaration name","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #13: preserved identifier names shouldn't be used as identifier names","Variant #1"],"updatePoint":{"line":495,"column":95},"line":495,"code":"            it('Match #4: shouldn\\'t use preserved identifier name as function declaration name', () => {\n                assert.match(obfuscatedCode, functionDeclarationRegExp3);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #5: shouldn't use preserved identifier name as function declaration name","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #13: preserved identifier names shouldn't be used as identifier names","Variant #1"],"updatePoint":{"line":499,"column":95},"line":499,"code":"            it('Match #5: shouldn\\'t use preserved identifier name as function declaration name', () => {\n                assert.match(obfuscatedCode, functionDeclarationRegExp4);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: shouldn't use preserved identifier name as variable declaration name","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #13: preserved identifier names shouldn't be used as identifier names","Variant #2"],"updatePoint":{"line":524,"column":95},"line":524,"code":"            it('Match #1: shouldn\\'t use preserved identifier name as variable declaration name', () => {\n                assert.match(obfuscatedCode, variableDeclarationRegExp1);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: shouldn't use preserved identifier name as variable declaration name","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #13: preserved identifier names shouldn't be used as identifier names","Variant #2"],"updatePoint":{"line":528,"column":95},"line":528,"code":"            it('Match #2: shouldn\\'t use preserved identifier name as variable declaration name', () => {\n                assert.match(obfuscatedCode, variableDeclarationRegExp2);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: shouldn't use preserved identifier name as function declaration name","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #13: preserved identifier names shouldn't be used as identifier names","Variant #2"],"updatePoint":{"line":532,"column":95},"line":532,"code":"            it('Match #3: shouldn\\'t use preserved identifier name as function declaration name', () => {\n                assert.match(obfuscatedCode, functionDeclarationRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #4: shouldn't use preserved identifier name as variable declaration name","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #13: preserved identifier names shouldn't be used as identifier names","Variant #2"],"updatePoint":{"line":536,"column":95},"line":536,"code":"            it('Match #4: shouldn\\'t use preserved identifier name as variable declaration name', () => {\n                assert.match(obfuscatedCode, variableDeclarationRegExp3);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't transform identifiers in named export","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #14: named export"],"updatePoint":{"line":559,"column":60},"line":559,"code":"        it('shouldn\\'t transform identifiers in named export', () => {\n            assert.match(obfuscatedCode, namedExportRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should transform identifiers in variable declaration","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #15: default export"],"updatePoint":{"line":582,"column":74},"line":582,"code":"        it('Match #1: should transform identifiers in variable declaration', () => {\n            assert.match(obfuscatedCode, variableDeclarationRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should transform identifiers in default export","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #15: default export"],"updatePoint":{"line":586,"column":68},"line":586,"code":"        it('Match #2: should transform identifiers in default export', () => {\n            assert.match(obfuscatedCode, defaultExportRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should transform object name","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #16: array rest"],"updatePoint":{"line":608,"column":50},"line":608,"code":"        it('Match #1: should transform object name', () => {\n            assert.match(obfuscatedCode, objectRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should transform object rest construction","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #16: array rest"],"updatePoint":{"line":612,"column":63},"line":612,"code":"        it('Match #2: should transform object rest construction', () => {\n            assert.match(obfuscatedCode, objectRestRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should transform object name","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #17: object rest"],"updatePoint":{"line":636,"column":50},"line":636,"code":"        it('Match #1: should transform object name', () => {\n            assert.match(obfuscatedCode, objectRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should transform object rest construction","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #17: object rest"],"updatePoint":{"line":640,"column":63},"line":640,"code":"        it('Match #2: should transform object rest construction', () => {\n            assert.match(obfuscatedCode, objectRestRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform variables declaration","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #18: destructing assignment without declaration #1"],"updatePoint":{"line":666,"column":60},"line":666,"code":"        it('match #1: should transform variables declaration', () => {\n            assert.match(obfuscatedCode, variablesDeclaration);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform destructing assignment without declaration","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #18: destructing assignment without declaration #1"],"updatePoint":{"line":670,"column":81},"line":670,"code":"        it('match #2: should transform destructing assignment without declaration', () => {\n            assert.match(obfuscatedCode, destructingAssignmentRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should transform identifier assignment","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #18: destructing assignment without declaration #1"],"updatePoint":{"line":674,"column":60},"line":674,"code":"        it('match #3: should transform identifier assignment', () => {\n            assert.match(obfuscatedCode, identifierAssignmentRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #4: should transform variables usage","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #18: destructing assignment without declaration #1"],"updatePoint":{"line":678,"column":54},"line":678,"code":"        it('match #4: should transform variables usage', () => {\n            assert.match(obfuscatedCode, variablesUsageRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform variables declaration","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #19: destructing assignment without declaration #2"],"updatePoint":{"line":702,"column":60},"line":702,"code":"        it('match #1: should transform variables declaration', () => {\n            assert.match(obfuscatedCode, variablesDeclaration);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform destructing assignment without declaration","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #19: destructing assignment without declaration #2"],"updatePoint":{"line":706,"column":81},"line":706,"code":"        it('match #2: should transform destructing assignment without declaration', () => {\n            assert.match(obfuscatedCode, destructingAssignmentRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should transform identifier assignment","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #19: destructing assignment without declaration #2"],"updatePoint":{"line":710,"column":60},"line":710,"code":"        it('match #3: should transform identifier assignment', () => {\n            assert.match(obfuscatedCode, identifierAssignmentRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #4: should transform variables usage","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #19: destructing assignment without declaration #2"],"updatePoint":{"line":714,"column":54},"line":714,"code":"        it('match #4: should transform variables usage', () => {\n            assert.match(obfuscatedCode, variablesUsageRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform variables declaration","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #20: destructing assignment without declaration #3"],"updatePoint":{"line":739,"column":60},"line":739,"code":"        it('match #1: should transform variables declaration', () => {\n            assert.match(obfuscatedCode, variablesDeclaration);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform destructing assignment without declaration","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #20: destructing assignment without declaration #3"],"updatePoint":{"line":743,"column":81},"line":743,"code":"        it('match #2: should transform destructing assignment without declaration', () => {\n            assert.match(obfuscatedCode, destructingAssignmentRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should transform variables usage","suites":["ScopeIdentifiersTransformer VariableDeclaration identifiers","Variant #20: destructing assignment without declaration #3"],"updatePoint":{"line":747,"column":54},"line":747,"code":"        it('match #3: should transform variables usage', () => {\n            assert.match(obfuscatedCode, variablesUsageRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should skip transformation of class name","suites":["ScopeThroughIdentifiersTransformer ClassDeclaration identifiers","Variant #1: class declaration is exist"],"updatePoint":{"line":34,"column":52},"line":34,"code":"        it('should skip transformation of class name', () => {\n            assert.match(obfuscatedCode, classNameIdentifierRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-through-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should skip transformation of class name","suites":["ScopeThroughIdentifiersTransformer ClassDeclaration identifiers","Variant #1: class declaration is exist"],"updatePoint":{"line":38,"column":52},"line":38,"code":"        it('should skip transformation of class name', () => {\n            assert.match(obfuscatedCode, classCallIdentifierRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-through-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should transform class name","suites":["ScopeThroughIdentifiersTransformer ClassDeclaration identifiers","Variant #2: class declaration is missing","Variant #1: transformation of class call identifier node name based on identifier names cache"],"updatePoint":{"line":67,"column":43},"line":67,"code":"            it('should transform class name', () => {\n                assert.match(obfuscatedCode, classCallIdentifierRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-through-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should not transform class name","suites":["ScopeThroughIdentifiersTransformer ClassDeclaration identifiers","Variant #2: class declaration is missing","Variant #2: ignore transformation of class call identifier node name when no identifier names cache value is available"],"updatePoint":{"line":93,"column":47},"line":93,"code":"            it('should not transform class name', () => {\n                assert.match(obfuscatedCode, classCallIdentifierRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-through-identifiers-transformer/class-declaration/ClassDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should skip transformation of function name","suites":["ScopeThroughIdentifiersTransformer FunctionDeclaration identifiers","Variant #1: function declaration is exist"],"updatePoint":{"line":34,"column":55},"line":34,"code":"        it('should skip transformation of function name', () => {\n            assert.match(obfuscatedCode, functionNameIdentifierRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-through-identifiers-transformer/function-declaration/FunctionDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should skip transformation of function name","suites":["ScopeThroughIdentifiersTransformer FunctionDeclaration identifiers","Variant #1: function declaration is exist"],"updatePoint":{"line":38,"column":55},"line":38,"code":"        it('should skip transformation of function name', () => {\n            assert.match(obfuscatedCode, functionCallIdentifierRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-through-identifiers-transformer/function-declaration/FunctionDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should transform function name","suites":["ScopeThroughIdentifiersTransformer FunctionDeclaration identifiers","Variant #2: function declaration is missing","Variant #1: transformation of function call identifier node name based on identifier names cache"],"updatePoint":{"line":67,"column":46},"line":67,"code":"            it('should transform function name', () => {\n                assert.match(obfuscatedCode, functionCallIdentifierRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-through-identifiers-transformer/function-declaration/FunctionDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should not transform function name","suites":["ScopeThroughIdentifiersTransformer FunctionDeclaration identifiers","Variant #2: function declaration is missing","Variant #2: ignore transformation of function call identifier node name when no identifier names cache value is available"],"updatePoint":{"line":93,"column":50},"line":93,"code":"            it('should not transform function name', () => {\n                assert.match(obfuscatedCode, functionCallIdentifierRegExp);\n            });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-through-identifiers-transformer/function-declaration/FunctionDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should skip transformation of variable declaration name","suites":["ScopeThroughIdentifiersTransformer VariableDeclaration identifiers","Variant #1: variable declaration is exist"],"updatePoint":{"line":34,"column":67},"line":34,"code":"        it('should skip transformation of variable declaration name', () => {\n            assert.match(obfuscatedCode, variableIdentifierRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-through-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should skip transformation of variable reference name","suites":["ScopeThroughIdentifiersTransformer VariableDeclaration identifiers","Variant #1: variable declaration is exist"],"updatePoint":{"line":38,"column":65},"line":38,"code":"        it('should skip transformation of variable reference name', () => {\n            assert.match(obfuscatedCode, variableReferenceIdentifierRegExp);\n        });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-through-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should transform variable reference name","suites":["ScopeThroughIdentifiersTransformer VariableDeclaration identifiers","Variant #2: variable declaration is missing","Variant #1: global variable reference scope","Variant #1: identifier names cache value is exists"],"updatePoint":{"line":68,"column":60},"line":68,"code":"                it('should transform variable reference name', () => {\n                    assert.match(obfuscatedCode, variableReferenceIdentifierRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-through-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should not transform variable reference name","suites":["ScopeThroughIdentifiersTransformer VariableDeclaration identifiers","Variant #2: variable declaration is missing","Variant #1: global variable reference scope","Variant #2: ignore transformation of variable reference identifier node name when no identifier names cache value is available"],"updatePoint":{"line":94,"column":64},"line":94,"code":"                it('should not transform variable reference name', () => {\n                    assert.match(obfuscatedCode, variableReferenceIdentifierRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-through-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should not transform variable reference name","suites":["ScopeThroughIdentifiersTransformer VariableDeclaration identifiers","Variant #2: variable declaration is missing","Variant #1: global variable reference scope","Variant #3: ignore transformation of variable reference identifier node name when this name is reserved"],"updatePoint":{"line":123,"column":64},"line":123,"code":"                it('should not transform variable reference name', () => {\n                    assert.match(obfuscatedCode, variableReferenceIdentifierRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-through-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should transform variable reference name","suites":["ScopeThroughIdentifiersTransformer VariableDeclaration identifiers","Variant #2: variable declaration is missing","Variant #2: local variable reference scope","Variant #1: identifier names cache value is exists"],"updatePoint":{"line":153,"column":60},"line":153,"code":"                it('should transform variable reference name', () => {\n                    assert.match(obfuscatedCode, variableReferenceIdentifierRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-through-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should not transform variable reference name","suites":["ScopeThroughIdentifiersTransformer VariableDeclaration identifiers","Variant #2: variable declaration is missing","Variant #2: local variable reference scope","Variant #2: ignore transformation of variable reference identifier node name when no identifier names cache value is available"],"updatePoint":{"line":179,"column":64},"line":179,"code":"                it('should not transform variable reference name', () => {\n                    assert.match(obfuscatedCode, variableReferenceIdentifierRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-through-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"should not transform variable reference name","suites":["ScopeThroughIdentifiersTransformer VariableDeclaration identifiers","Variant #2: variable declaration is missing","Variant #2: local variable reference scope","Variant #3 ignore transformation of variable reference identifier node name when this name is reserved"],"updatePoint":{"line":208,"column":64},"line":208,"code":"                it('should not transform variable reference name', () => {\n                    assert.match(obfuscatedCode, variableReferenceIdentifierRegExp);\n                });","file":"functional-tests/node-transformers/rename-identifiers-transformers/scope-through-identifiers-transformer/variable-declaration/VariableDeclaration.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should rename property","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #1: Hexadecimal identifier names generator","Variant #1: object properties rename"],"updatePoint":{"line":39,"column":56},"line":39,"code":"                    it('Match #1: should rename property', () => {\n                        assert.match(obfuscatedCode, property1RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should rename property","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #1: Hexadecimal identifier names generator","Variant #1: object properties rename"],"updatePoint":{"line":43,"column":56},"line":43,"code":"                    it('Match #2: should rename property', () => {\n                        assert.match(obfuscatedCode, property2RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should rename property","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #1: Hexadecimal identifier names generator","Variant #1: object properties rename"],"updatePoint":{"line":47,"column":56},"line":47,"code":"                    it('Match #3: should rename property', () => {\n                        assert.match(obfuscatedCode, property3RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #4: should rename property","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #1: Hexadecimal identifier names generator","Variant #1: object properties rename"],"updatePoint":{"line":51,"column":56},"line":51,"code":"                    it('Match #4: should rename property', () => {\n                        assert.match(obfuscatedCode, property4RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should rename property definition","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #1: Hexadecimal identifier names generator","Variant #2: class property definitions rename"],"updatePoint":{"line":78,"column":67},"line":78,"code":"                    it('Match #1: should rename property definition', () => {\n                        assert.match(obfuscatedCode, propertyDefinition1RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should rename property definition","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #1: Hexadecimal identifier names generator","Variant #2: class property definitions rename"],"updatePoint":{"line":82,"column":67},"line":82,"code":"                    it('Match #2: should rename property definition', () => {\n                        assert.match(obfuscatedCode, propertyDefinition2RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should rename property definition","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #1: Hexadecimal identifier names generator","Variant #2: class property definitions rename"],"updatePoint":{"line":86,"column":67},"line":86,"code":"                    it('Match #3: should rename property definition', () => {\n                        assert.match(obfuscatedCode, propertyDefinition3RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #4: should rename property definition","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #1: Hexadecimal identifier names generator","Variant #2: class property definitions rename"],"updatePoint":{"line":90,"column":67},"line":90,"code":"                    it('Match #4: should rename property definition', () => {\n                        assert.match(obfuscatedCode, propertyDefinition4RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should rename property","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #1: object properties mangle"],"updatePoint":{"line":120,"column":56},"line":120,"code":"                    it('Match #1: should rename property', () => {\n                        assert.match(obfuscatedCode, property1RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should rename property","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #1: object properties mangle"],"updatePoint":{"line":124,"column":56},"line":124,"code":"                    it('Match #2: should rename property', () => {\n                        assert.match(obfuscatedCode, property2RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should rename property","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #1: object properties mangle"],"updatePoint":{"line":128,"column":56},"line":128,"code":"                    it('Match #3: should rename property', () => {\n                        assert.match(obfuscatedCode, property3RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #4: should rename property","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #1: object properties mangle"],"updatePoint":{"line":132,"column":56},"line":132,"code":"                    it('Match #4: should rename property', () => {\n                        assert.match(obfuscatedCode, property4RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should rename property definition","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #2: class property definitions rename"],"updatePoint":{"line":159,"column":67},"line":159,"code":"                    it('Match #1: should rename property definition', () => {\n                        assert.match(obfuscatedCode, propertyDefinition1RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should rename property definition","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #2: class property definitions rename"],"updatePoint":{"line":163,"column":67},"line":163,"code":"                    it('Match #2: should rename property definition', () => {\n                        assert.match(obfuscatedCode, propertyDefinition2RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should rename property definition","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #2: class property definitions rename"],"updatePoint":{"line":167,"column":67},"line":167,"code":"                    it('Match #3: should rename property definition', () => {\n                        assert.match(obfuscatedCode, propertyDefinition3RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #4: should rename property definition","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #2: class property definitions rename"],"updatePoint":{"line":171,"column":67},"line":171,"code":"                    it('Match #4: should rename property definition', () => {\n                        assert.match(obfuscatedCode, propertyDefinition4RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should rename variable name","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #3: base properties rename with rename globals"],"updatePoint":{"line":202,"column":61},"line":202,"code":"                    it('Match #1: should rename variable name', () => {\n                        assert.match(obfuscatedCode, variable1RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should rename variable name","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #3: base properties rename with rename globals"],"updatePoint":{"line":206,"column":61},"line":206,"code":"                    it('Match #2: should rename variable name', () => {\n                        assert.match(obfuscatedCode, variable2RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should rename property","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #3: base properties rename with rename globals"],"updatePoint":{"line":210,"column":56},"line":210,"code":"                    it('Match #3: should rename property', () => {\n                        assert.match(obfuscatedCode, property1RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #4: should rename property","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #3: base properties rename with rename globals"],"updatePoint":{"line":214,"column":56},"line":214,"code":"                    it('Match #4: should rename property', () => {\n                        assert.match(obfuscatedCode, property2RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #5: should rename property","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #3: base properties rename with rename globals"],"updatePoint":{"line":218,"column":56},"line":218,"code":"                    it('Match #5: should rename property', () => {\n                        assert.match(obfuscatedCode, property3RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #6: should rename property","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #3: base properties rename with rename globals"],"updatePoint":{"line":222,"column":56},"line":222,"code":"                    it('Match #6: should rename property', () => {\n                        assert.match(obfuscatedCode, property4RegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should rename property","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #4: properties rename of nested objects"],"updatePoint":{"line":253,"column":46},"line":253,"code":"                    it('Should rename property', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should rename property","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #5: properties rename of rest element"],"updatePoint":{"line":283,"column":46},"line":283,"code":"                    it('Should rename property', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should rename non-reserved properties","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #6: reserved dom properties"],"updatePoint":{"line":315,"column":61},"line":315,"code":"                    it('Should rename non-reserved properties', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should rename non-reserved properties","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #7: reserved names properties"],"updatePoint":{"line":348,"column":61},"line":348,"code":"                    it('Should rename non-reserved properties', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should rename class method name","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #8: class methods"],"updatePoint":{"line":379,"column":55},"line":379,"code":"                    it('Should rename class method name', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should rename property before `splitStrings` option will applied","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #9: integration with `splitStrings` option"],"updatePoint":{"line":410,"column":88},"line":410,"code":"                    it('Should rename property before `splitStrings` option will applied', () => {\n                        assert.match(obfuscatedCode, propertyRegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should correctly rename property when `controlFlowFlattening` option is enabled","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #10: integration with `controlFlowFlattening` option"],"updatePoint":{"line":444,"column":103},"line":444,"code":"                    it('Should correctly rename property when `controlFlowFlattening` option is enabled', () => {\n                        assert.match(obfuscatedCode, propertyRegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should correctly rename property when `transformObjectKeys` option is enabled","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #2: Mangled identifier names generator","Variant #11: integration with `transformObjectKeys` option"],"updatePoint":{"line":474,"column":101},"line":474,"code":"                    it('Should correctly rename property when `transformObjectKeys` option is enabled', () => {\n                        assert.match(obfuscatedCode, propertyRegExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should skip literal property with invalid type","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #3: Ignored literal node type","Variant #1: boolean literal node"],"updatePoint":{"line":499,"column":80},"line":499,"code":"                    it('Match #1: should skip literal property with invalid type', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should skip literal property with invalid type","suites":["RenamePropertiesTransformer","transformNode","Mode: `unsafe`","Variant #4: Prevent generation of the property names that are equal to the existing object property names"],"updatePoint":{"line":525,"column":76},"line":525,"code":"                it('Match #1: should skip literal property with invalid type', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should rename property declarations","suites":["RenamePropertiesTransformer","transformNode","Mode: `safe`","Variant #1: base properties rename"],"updatePoint":{"line":572,"column":55},"line":572,"code":"                it('Should rename property declarations', () => {\n                    assert.match(obfuscatedCode, declarationsRegExp);\n                });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should rename property references","suites":["RenamePropertiesTransformer","transformNode","Mode: `safe`","Variant #1: base properties rename"],"updatePoint":{"line":576,"column":53},"line":576,"code":"                it('Should rename property references', () => {\n                    assert.match(obfuscatedCode, referencesRegExp);\n                });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should skip literal property with invalid type","suites":["RenamePropertiesTransformer","transformNode","Mode: `safe`","Variant #2: Prevent generation of the property names that are equal to the existing object property names"],"updatePoint":{"line":601,"column":76},"line":601,"code":"                it('Match #1: should skip literal property with invalid type', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should rename property","suites":["RenamePropertiesTransformer","transformNode","Property identifier names from property identifier names cache","Variant #1: no property identifier names in the cache"],"updatePoint":{"line":631,"column":52},"line":631,"code":"                it('Match #1: should rename property', () => {\n                    assert.match(obfuscatedCode, property1RegExp);\n                });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should rename property","suites":["RenamePropertiesTransformer","transformNode","Property identifier names from property identifier names cache","Variant #1: no property identifier names in the cache"],"updatePoint":{"line":635,"column":52},"line":635,"code":"                it('Match #2: should rename property', () => {\n                    assert.match(obfuscatedCode, property2RegExp);\n                });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should rename property","suites":["RenamePropertiesTransformer","transformNode","Property identifier names from property identifier names cache","Variant #1: no property identifier names in the cache"],"updatePoint":{"line":639,"column":52},"line":639,"code":"                it('Match #3: should rename property', () => {\n                    assert.match(obfuscatedCode, property3RegExp);\n                });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should rename property based on the cache value","suites":["RenamePropertiesTransformer","transformNode","Property identifier names from property identifier names cache","Variant #2: existing property identifier names in the cache"],"updatePoint":{"line":670,"column":77},"line":670,"code":"                it('Match #1: should rename property based on the cache value', () => {\n                    assert.match(obfuscatedCode, property1RegExp);\n                });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should rename property based on the cache value","suites":["RenamePropertiesTransformer","transformNode","Property identifier names from property identifier names cache","Variant #2: existing property identifier names in the cache"],"updatePoint":{"line":674,"column":77},"line":674,"code":"                it('Match #2: should rename property based on the cache value', () => {\n                    assert.match(obfuscatedCode, property2RegExp);\n                });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should rename property","suites":["RenamePropertiesTransformer","transformNode","Property identifier names from property identifier names cache","Variant #2: existing property identifier names in the cache"],"updatePoint":{"line":678,"column":52},"line":678,"code":"                it('Match #3: should rename property', () => {\n                    assert.match(obfuscatedCode, property3RegExp);\n                });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should rename property based on the cache value","suites":["RenamePropertiesTransformer","transformNode","Property identifier names from property identifier names cache","Variant #3: existing property identifier names in the cache, reserved name is defined"],"updatePoint":{"line":710,"column":77},"line":710,"code":"                it('Match #1: should rename property based on the cache value', () => {\n                    assert.match(obfuscatedCode, property1RegExp);\n                });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should keep original property name","suites":["RenamePropertiesTransformer","transformNode","Property identifier names from property identifier names cache","Variant #3: existing property identifier names in the cache, reserved name is defined"],"updatePoint":{"line":714,"column":64},"line":714,"code":"                it('Match #2: should keep original property name', () => {\n                    assert.match(obfuscatedCode, property2RegExp);\n                });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should rename property","suites":["RenamePropertiesTransformer","transformNode","Property identifier names from property identifier names cache","Variant #3: existing property identifier names in the cache, reserved name is defined"],"updatePoint":{"line":718,"column":52},"line":718,"code":"                it('Match #3: should rename property', () => {\n                    assert.match(obfuscatedCode, property3RegExp);\n                });","file":"functional-tests/node-transformers/rename-properties-transformers/rename-properties-transformer/RenamePropertiesTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not simplify block statement","suites":["BlockStatementSimplifyTransformer","Full `BlockStatement` simplify cases","No `ReturnStatement`","Variant #1: single statement"],"updatePoint":{"line":34,"column":55},"line":34,"code":"                it('should not simplify block statement', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/simplifying-transformers/block-statement-simplify-transformer/BlockStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify block statement","suites":["BlockStatementSimplifyTransformer","Full `BlockStatement` simplify cases","No `ReturnStatement`","Variant #2: multiple statements"],"updatePoint":{"line":61,"column":51},"line":61,"code":"                it('should simplify block statement', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/simplifying-transformers/block-statement-simplify-transformer/BlockStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not simplify block statement","suites":["BlockStatementSimplifyTransformer","Full `BlockStatement` simplify cases","With `ReturnStatement`","Variant #1: single statement"],"updatePoint":{"line":90,"column":55},"line":90,"code":"                it('should not simplify block statement', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/simplifying-transformers/block-statement-simplify-transformer/BlockStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify block statement","suites":["BlockStatementSimplifyTransformer","Full `BlockStatement` simplify cases","With `ReturnStatement`","Variant #2: multiple statements"],"updatePoint":{"line":117,"column":51},"line":117,"code":"                it('should simplify block statement', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/simplifying-transformers/block-statement-simplify-transformer/BlockStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not simplify block statement","suites":["BlockStatementSimplifyTransformer","Partial `BlockStatement` simplify cases","No `ReturnStatement`","Variant #1: single statement"],"updatePoint":{"line":148,"column":55},"line":148,"code":"                it('should not simplify block statement', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/simplifying-transformers/block-statement-simplify-transformer/BlockStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify block statement","suites":["BlockStatementSimplifyTransformer","Partial `BlockStatement` simplify cases","No `ReturnStatement`","Variant #2: multiple statements"],"updatePoint":{"line":176,"column":51},"line":176,"code":"                it('should simplify block statement', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/simplifying-transformers/block-statement-simplify-transformer/BlockStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify block statement","suites":["BlockStatementSimplifyTransformer","Partial `BlockStatement` simplify cases","With `ReturnStatement`","Variant #1: multiple statements"],"updatePoint":{"line":206,"column":51},"line":206,"code":"                it('should simplify block statement', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/simplifying-transformers/block-statement-simplify-transformer/BlockStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify block statement","suites":["BlockStatementSimplifyTransformer","Cases","Variable declarations merge transformer integration","Variant #1: three statements"],"updatePoint":{"line":239,"column":51},"line":239,"code":"                it('should simplify block statement', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/simplifying-transformers/block-statement-simplify-transformer/BlockStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should merge expression statements","suites":["ExpressionStatementsMergeTransformer","Variant #1: simple"],"updatePoint":{"line":34,"column":46},"line":34,"code":"        it('should merge expression statements', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/simplifying-transformers/expression-statements-merge-transformer/ExpressionStatementsMergeTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should merge expression statements","suites":["ExpressionStatementsMergeTransformer","Variant #2: complex"],"updatePoint":{"line":68,"column":46},"line":68,"code":"        it('should merge expression statements', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/simplifying-transformers/expression-statements-merge-transformer/ExpressionStatementsMergeTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Full `IfStatement` simplify cases","Consequent only","No `ReturnStatement`","Variant #1: single statement"],"updatePoint":{"line":33,"column":52},"line":33,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Full `IfStatement` simplify cases","Consequent only","No `ReturnStatement`","Variant #2: multiple statements"],"updatePoint":{"line":58,"column":52},"line":58,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Full `IfStatement` simplify cases","Consequent only","With `ReturnStatement`","Variant #1: single statement"],"updatePoint":{"line":86,"column":52},"line":86,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Full `IfStatement` simplify cases","Consequent only","With `ReturnStatement`","Variant #2: multiple statements"],"updatePoint":{"line":112,"column":52},"line":112,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Full `IfStatement` simplify cases","Consequent only","With `ReturnStatement`","Variant #3: statements after return"],"updatePoint":{"line":139,"column":52},"line":139,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Full `IfStatement` simplify cases","Consequent and alternate","No `ReturnStatement`","Variant #1: single statement"],"updatePoint":{"line":170,"column":52},"line":170,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Full `IfStatement` simplify cases","Consequent and alternate","No `ReturnStatement`","Variant #2: multiple statements"],"updatePoint":{"line":197,"column":52},"line":197,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Full `IfStatement` simplify cases","Consequent and alternate","With consequent `ReturnStatement`","Variant #1: single statement"],"updatePoint":{"line":227,"column":52},"line":227,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Full `IfStatement` simplify cases","Consequent and alternate","With consequent `ReturnStatement`","Variant #2: multiple statements"],"updatePoint":{"line":255,"column":52},"line":255,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Full `IfStatement` simplify cases","Consequent and alternate","With consequent `ReturnStatement`","Variant #3: statements after return"],"updatePoint":{"line":282,"column":52},"line":282,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Full `IfStatement` simplify cases","Consequent and alternate","With alternate `ReturnStatement`","Variant #1: single statement"],"updatePoint":{"line":312,"column":52},"line":312,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Full `IfStatement` simplify cases","Consequent and alternate","With alternate `ReturnStatement`","Variant #2: multiple statements"],"updatePoint":{"line":340,"column":52},"line":340,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Full `IfStatement` simplify cases","Consequent and alternate","With alternate `ReturnStatement`","Variant #3: statements after return"],"updatePoint":{"line":368,"column":52},"line":368,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Full `IfStatement` simplify cases","Consequent and alternate","With consequent and alternate `ReturnStatement`","Variant #1: single statement"],"updatePoint":{"line":397,"column":52},"line":397,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Full `IfStatement` simplify cases","Consequent and alternate","With consequent and alternate `ReturnStatement`","Variant #2: multiple statements"],"updatePoint":{"line":424,"column":52},"line":424,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not simplify if statement","suites":["IfStatementSimplifyTransformer","Partial `IfStatement` simplify cases","Consequent only","No `ReturnStatement`","Variant #1: single statement"],"updatePoint":{"line":456,"column":56},"line":456,"code":"                    it('should not simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Partial `IfStatement` simplify cases","Consequent only","No `ReturnStatement`","Variant #2: multiple statements"],"updatePoint":{"line":484,"column":52},"line":484,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Partial `IfStatement` simplify cases","Consequent only","With `ReturnStatement`","Variant #1: multiple statements"],"updatePoint":{"line":514,"column":52},"line":514,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Partial `IfStatement` simplify cases","Consequent only","With `ReturnStatement`","Variant #2: statements after return"],"updatePoint":{"line":543,"column":52},"line":543,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not simplify if statement","suites":["IfStatementSimplifyTransformer","Partial `IfStatement` simplify cases","Consequent and alternate","No `ReturnStatement`","Variant #1: single statement"],"updatePoint":{"line":575,"column":56},"line":575,"code":"                    it('should not simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Partial `IfStatement` simplify cases","Consequent and alternate","No `ReturnStatement`","Variant #2: multiple statements"],"updatePoint":{"line":607,"column":52},"line":607,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Partial `IfStatement` simplify cases","Consequent and alternate","No `ReturnStatement`","Variant #3: mixed statements #1"],"updatePoint":{"line":637,"column":52},"line":637,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Partial `IfStatement` simplify cases","Consequent and alternate","No `ReturnStatement`","Variant #4: mixed statements #2"],"updatePoint":{"line":667,"column":52},"line":667,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Partial `IfStatement` simplify cases","Consequent and alternate","With consequent `ReturnStatement`","Variant #1: single statement"],"updatePoint":{"line":697,"column":52},"line":697,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Partial `IfStatement` simplify cases","Consequent and alternate","With consequent `ReturnStatement`","Variant #2: multiple statements"],"updatePoint":{"line":729,"column":52},"line":729,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Partial `IfStatement` simplify cases","Consequent and alternate","With consequent `ReturnStatement`","Variant #3: statements after return"],"updatePoint":{"line":761,"column":52},"line":761,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Partial `IfStatement` simplify cases","Consequent and alternate","With alternate `ReturnStatement`","Variant #1: single statement"],"updatePoint":{"line":791,"column":52},"line":791,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Partial `IfStatement` simplify cases","Consequent and alternate","With alternate `ReturnStatement`","Variant #2: multiple statements"],"updatePoint":{"line":823,"column":52},"line":823,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Partial `IfStatement` simplify cases","Consequent and alternate","With alternate `ReturnStatement`","Variant #3: statements after return"],"updatePoint":{"line":855,"column":52},"line":855,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Partial `IfStatement` simplify cases","Consequent and alternate","With consequent and alternate `ReturnStatement`","Variant #1: multiple statements"],"updatePoint":{"line":890,"column":52},"line":890,"code":"                    it('should simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should simplify if statement","suites":["IfStatementSimplifyTransformer","Cases","Variable declarations merge transformer integration","Variant #1: three statements"],"updatePoint":{"line":923,"column":48},"line":923,"code":"                it('should simplify if statement', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not simplify if statement","suites":["IfStatementSimplifyTransformer","Cases","Prohibited single statement","Variant #1: `IfStatement` as prohibited single statement","Variant #1: `IfStatement` with `var` variable inside`"],"updatePoint":{"line":955,"column":56},"line":955,"code":"                    it('should not simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not simplify if statement","suites":["IfStatementSimplifyTransformer","Cases","Prohibited single statement","Variant #1: `IfStatement` as prohibited single statement","Variant #2: `IfStatement` with `const` variable inside`"],"updatePoint":{"line":985,"column":56},"line":985,"code":"                    it('should not simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not simplify if statement","suites":["IfStatementSimplifyTransformer","Cases","Prohibited single statement","Variant #2: Nodes with single statement `body` property","Variant #1: Single line `ForStatement` as prohibited single statement"],"updatePoint":{"line":1019,"column":56},"line":1019,"code":"                    it('should not simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not simplify if statement","suites":["IfStatementSimplifyTransformer","Cases","Prohibited single statement","Variant #2: Nodes with single statement `body` property","Variant #2: Single line `ForOfStatement` as prohibited single statement"],"updatePoint":{"line":1047,"column":56},"line":1047,"code":"                    it('should not simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not simplify if statement","suites":["IfStatementSimplifyTransformer","Cases","Prohibited single statement","Variant #2: Nodes with single statement `body` property","Variant #3: Single line `ForInStatement` as prohibited single statement"],"updatePoint":{"line":1075,"column":56},"line":1075,"code":"                    it('should not simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not simplify if statement","suites":["IfStatementSimplifyTransformer","Cases","Prohibited single statement","Variant #2: Nodes with single statement `body` property","Variant #4: Single line `WhileStatement` as prohibited single statement"],"updatePoint":{"line":1103,"column":56},"line":1103,"code":"                    it('should not simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not simplify if statement","suites":["IfStatementSimplifyTransformer","Cases","Prohibited single statement","Variant #2: Nodes with single statement `body` property","Variant #5: Single line `DoWhileStatement` as prohibited single statement"],"updatePoint":{"line":1132,"column":56},"line":1132,"code":"                    it('should not simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not simplify if statement","suites":["IfStatementSimplifyTransformer","Cases","Prohibited single statement","Variant #2: Nodes with single statement `body` property","Variant #6: Single line `LabeledStatement` as prohibited single statement"],"updatePoint":{"line":1160,"column":56},"line":1160,"code":"                    it('should not simplify if statement', () => {\n                        assert.match(obfuscatedCode, regExp);\n                    });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not simplify if statement","suites":["IfStatementSimplifyTransformer","Cases","Prohibited single statement","Variant #3: `FunctionDeclaration` as prohibited single statement"],"updatePoint":{"line":1190,"column":52},"line":1190,"code":"                it('should not simplify if statement', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not simplify if statement","suites":["IfStatementSimplifyTransformer","Cases","Prohibited single statement","Variant #4: `let` `VariableDeclaration` as prohibited single statement"],"updatePoint":{"line":1217,"column":52},"line":1217,"code":"                it('should not simplify if statement', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not simplify if statement","suites":["IfStatementSimplifyTransformer","Cases","Prohibited single statement","Variant #5: `const` `VariableDeclaration` as prohibited single statement"],"updatePoint":{"line":1244,"column":52},"line":1244,"code":"                it('should not simplify if statement', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"functional-tests/node-transformers/simplifying-transformers/if-statement-simplify-transformer/IfStatementSimplifyTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep single declaration","suites":["VariableDeclarationsMergeTransformer","base behaviour","Variant #1: single variable declaration"],"updatePoint":{"line":33,"column":46},"line":33,"code":"            it('should keep single declaration', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/simplifying-transformers/variable-declarations-merge-transformer/VariableDeclarationsMergeTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should merge variable declarations","suites":["VariableDeclarationsMergeTransformer","base behaviour","Variant #2: multiple variable declarations"],"updatePoint":{"line":60,"column":50},"line":60,"code":"            it('should merge variable declarations', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/simplifying-transformers/variable-declarations-merge-transformer/VariableDeclarationsMergeTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should merge variable declarations","suites":["VariableDeclarationsMergeTransformer","base behaviour","Variant #3: multiple variable declarations with multiple declarators"],"updatePoint":{"line":87,"column":50},"line":87,"code":"            it('should merge variable declarations', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/simplifying-transformers/variable-declarations-merge-transformer/VariableDeclarationsMergeTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should merge variable declarations","suites":["VariableDeclarationsMergeTransformer","base behaviour","Variant #4: Splitted declarations with other statement"],"updatePoint":{"line":115,"column":50},"line":115,"code":"            it('should merge variable declarations', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/simplifying-transformers/variable-declarations-merge-transformer/VariableDeclarationsMergeTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should merge variable declarations","suites":["VariableDeclarationsMergeTransformer","base behaviour","Variant #5: multiple variable declarations without declarators"],"updatePoint":{"line":142,"column":50},"line":142,"code":"            it('should merge variable declarations', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/simplifying-transformers/variable-declarations-merge-transformer/VariableDeclarationsMergeTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should merge variable declarations","suites":["VariableDeclarationsMergeTransformer","base behaviour","Variant #6: declarations inside nested function expressions"],"updatePoint":{"line":174,"column":50},"line":174,"code":"            it('should merge variable declarations', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/simplifying-transformers/variable-declarations-merge-transformer/VariableDeclarationsMergeTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should merge variable declarations with object pattern","suites":["VariableDeclarationsMergeTransformer","object pattern as initializer"],"updatePoint":{"line":203,"column":66},"line":203,"code":"        it('should merge variable declarations with object pattern', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/simplifying-transformers/variable-declarations-merge-transformer/VariableDeclarationsMergeTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should keep unmerged variable declarations with different variable kinds","suites":["VariableDeclarationsMergeTransformer","variables kind"],"updatePoint":{"line":232,"column":84},"line":232,"code":"        it('should keep unmerged variable declarations with different variable kinds', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/simplifying-transformers/variable-declarations-merge-transformer/VariableDeclarationsMergeTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly append code helper into the obfuscated code","suites":["StringArrayRotateFunctionTransformer","Code helper append","`stringArray` option is set"],"updatePoint":{"line":41,"column":76},"line":41,"code":"            it('should correctly append code helper into the obfuscated code', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-rotate-function-transformer/StringArrayRotateFunctionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't append code helper into the obfuscated code","suites":["StringArrayRotateFunctionTransformer","Code helper append","`stringArray` option isn't set"],"updatePoint":{"line":63,"column":70},"line":63,"code":"            it('shouldn\\'t append code helper into the obfuscated code', () => {\n                assert.notMatch(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-rotate-function-transformer/StringArrayRotateFunctionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly append code helper into the obfuscated code","suites":["StringArrayRotateFunctionTransformer","Code helper append","`stringArrayThreshold` option is `0.00001`"],"updatePoint":{"line":85,"column":76},"line":85,"code":"            it('should correctly append code helper into the obfuscated code', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-rotate-function-transformer/StringArrayRotateFunctionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly append code helper into the obfuscated code","suites":["StringArrayRotateFunctionTransformer","Code helper append","`stringArrayThreshold` option is `0`"],"updatePoint":{"line":107,"column":76},"line":107,"code":"            it('should correctly append code helper into the obfuscated code', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-rotate-function-transformer/StringArrayRotateFunctionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't append code helper into the obfuscated code","suites":["StringArrayRotateFunctionTransformer","Code helper append","Input code has no string literals"],"updatePoint":{"line":129,"column":70},"line":129,"code":"            it('shouldn\\'t append code helper into the obfuscated code', () => {\n                assert.notMatch(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-rotate-function-transformer/StringArrayRotateFunctionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"It should correctly evaluate obfuscated code","suites":["StringArrayRotateFunctionTransformer","Code helper append","Code evaluation"],"updatePoint":{"line":206,"column":60},"line":206,"code":"            it('It should correctly evaluate obfuscated code', () => {\n                assert.equal(hasRuntimeErrors, false);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-rotate-function-transformer/StringArrayRotateFunctionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate code","suites":["StringArrayRotateFunctionTransformer","Code helper append","Prevent early successful comparison"],"updatePoint":{"line":253,"column":46},"line":253,"code":"            it('should correctly evaluate code', () => {\n                assert.equal(evaluationError, null);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-rotate-function-transformer/StringArrayRotateFunctionTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #1: root scope","Variant #1: option value is lower then count `literal` nodes in the scope"],"updatePoint":{"line":47,"column":51},"line":47,"code":"                it('should add scope calls wrappers', () => {\n                    assert.match(obfuscatedCode, stringArrayCallRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #1: root scope","Variant #2: option value is bigger then count `literal` nodes in the scope"],"updatePoint":{"line":78,"column":51},"line":78,"code":"                it('should add scope calls wrappers', () => {\n                    assert.match(obfuscatedCode, stringArrayCallRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #1: root scope","Variant #3: correct wrappers order"],"updatePoint":{"line":109,"column":51},"line":109,"code":"                it('should add scope calls wrappers', () => {\n                    assert.match(obfuscatedCode, stringArrayCallRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #1: root scope","Variant #4: `identifiersPrefix` option is set"],"updatePoint":{"line":141,"column":51},"line":141,"code":"                it('should add scope calls wrappers', () => {\n                    assert.match(obfuscatedCode, stringArrayCallRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #2: function scope","Variant #1: option value is lower then count `literal` nodes in the scope"],"updatePoint":{"line":175,"column":51},"line":175,"code":"                it('should add scope calls wrappers', () => {\n                    assert.match(obfuscatedCode, stringArrayCallRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #2: function scope","Variant #2: option value is bigger then count `literal` nodes in the scope"],"updatePoint":{"line":208,"column":51},"line":208,"code":"                it('should add scope calls wrappers', () => {\n                    assert.match(obfuscatedCode, stringArrayCallRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #2: function scope","Variant #3: correct wrappers order"],"updatePoint":{"line":241,"column":51},"line":241,"code":"                it('should add scope calls wrappers', () => {\n                    assert.match(obfuscatedCode, stringArrayCallRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #2: function scope","Variant #4: correct wrapper for the function default parameter"],"updatePoint":{"line":273,"column":51},"line":273,"code":"                it('should add scope calls wrappers', () => {\n                    assert.match(obfuscatedCode, stringArrayCallRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #2: function scope","Variant #5: `identifiersPrefix` option is set"],"updatePoint":{"line":307,"column":51},"line":307,"code":"                it('should add scope calls wrappers', () => {\n                    assert.match(obfuscatedCode, stringArrayCallRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not add scope calls wrappers to a prohibited scope","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #3: prohibited scopes","Variant #1: if statement scope"],"updatePoint":{"line":339,"column":77},"line":339,"code":"                it('should not add scope calls wrappers to a prohibited scope', () => {\n                    assert.match(obfuscatedCode, stringArrayCallRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should not add scope calls wrappers to a prohibited scope","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #3: prohibited scopes","Variant #2: arrow function scope without statements"],"updatePoint":{"line":367,"column":77},"line":367,"code":"                it('should not add scope calls wrappers to a prohibited scope', () => {\n                    assert.match(obfuscatedCode, stringArrayCallRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add scope calls wrappers with a correct variables kind","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #4: prevailing kind of variables"],"updatePoint":{"line":399,"column":77},"line":399,"code":"            it('should add scope calls wrappers with a correct variables kind', () => {\n                assert.match(obfuscatedCode, stringArrayCallRegExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #5: correct evaluation of the scope calls wrappers"],"updatePoint":{"line":424,"column":62},"line":424,"code":"            it('should correctly evaluate scope calls wrappers', () => {\n                assert.equal(evaluationResult, expectedEvaluationResult);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add correct scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #6: `stringArrayWrappersChainedCalls` option is enabled","Variant #1: correct chained calls","Variant #1: `Mangled` identifier names generator"],"updatePoint":{"line":473,"column":63},"line":473,"code":"                    it('should add correct scope calls wrappers', () => {\n                        assert.match(obfuscatedCode, stringArrayCallRegExp);\n                    });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate string array wrappers chained calls","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #6: `stringArrayWrappersChainedCalls` option is enabled","Variant #2: correct evaluation of the string array wrappers chained calls","Variant #1: base","Variant #1: `Hexadecimal` identifier names generator"],"updatePoint":{"line":515,"column":89},"line":515,"code":"                        it('should correctly evaluate string array wrappers chained calls', () => {\n                            assert.equal(isEvaluationSuccessful, true);\n                        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate string array wrappers chained calls","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #6: `stringArrayWrappersChainedCalls` option is enabled","Variant #2: correct evaluation of the string array wrappers chained calls","Variant #1: base","Variant #2: `Mangled` identifier names generator"],"updatePoint":{"line":554,"column":89},"line":554,"code":"                        it('should correctly evaluate string array wrappers chained calls', () => {\n                            assert.equal(isEvaluationSuccessful, true);\n                        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate string array wrappers chained calls","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #6: `stringArrayWrappersChainedCalls` option is enabled","Variant #2: correct evaluation of the string array wrappers chained calls","Variant #2: advanced","Variant #1: `Hexadecimal` identifier names generator"],"updatePoint":{"line":595,"column":89},"line":595,"code":"                        it('should correctly evaluate string array wrappers chained calls', () => {\n                            assert.equal(isEvaluationSuccessful, true);\n                        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate string array wrappers chained calls","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #6: `stringArrayWrappersChainedCalls` option is enabled","Variant #2: correct evaluation of the string array wrappers chained calls","Variant #2: advanced","Variant #2: `Mangled` identifier names generator"],"updatePoint":{"line":634,"column":89},"line":634,"code":"                        it('should correctly evaluate string array wrappers chained calls', () => {\n                            assert.equal(isEvaluationSuccessful, true);\n                        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should add correct scope calls wrapper 1","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #1: base","Variant #1: `hexadecimal-number` indexes type"],"updatePoint":{"line":700,"column":74},"line":700,"code":"                    it('Match #1: should add correct scope calls wrapper 1', () => {\n                        assert.match(obfuscatedCode, stringArrayScopeCallsWrapperRegExp1);\n                    });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should add correct scope calls wrapper 2","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #1: base","Variant #1: `hexadecimal-number` indexes type"],"updatePoint":{"line":704,"column":74},"line":704,"code":"                    it('Match #2: should add correct scope calls wrapper 2', () => {\n                        assert.match(obfuscatedCode, stringArrayScopeCallsWrapperRegExp2);\n                    });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should add correct scope calls wrappers calls","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #1: base","Variant #1: `hexadecimal-number` indexes type"],"updatePoint":{"line":708,"column":79},"line":708,"code":"                    it('Match #3: should add correct scope calls wrappers calls', () => {\n                        assert.match(obfuscatedCode, stringArrayCallsWrapperCallsRegExp);\n                    });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should evaluate code without errors","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #1: base","Variant #1: `hexadecimal-number` indexes type"],"updatePoint":{"line":712,"column":59},"line":712,"code":"                    it('should evaluate code without errors', () => {\n                        assert.isTrue(areSuccessEvaluations);\n                    });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should add correct scope calls wrapper 1","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #1: base","Variant #2: `hexadecimal-numeric-string` indexes type"],"updatePoint":{"line":770,"column":74},"line":770,"code":"                    it('Match #1: should add correct scope calls wrapper 1', () => {\n                        assert.match(obfuscatedCode, stringArrayScopeCallsWrapperRegExp1);\n                    });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should add correct scope calls wrapper 2","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #1: base","Variant #2: `hexadecimal-numeric-string` indexes type"],"updatePoint":{"line":774,"column":74},"line":774,"code":"                    it('Match #2: should add correct scope calls wrapper 2', () => {\n                        assert.match(obfuscatedCode, stringArrayScopeCallsWrapperRegExp2);\n                    });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should add correct scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #1: base","Variant #2: `hexadecimal-numeric-string` indexes type"],"updatePoint":{"line":778,"column":73},"line":778,"code":"                    it('Match #3: should add correct scope calls wrappers', () => {\n                        assert.match(obfuscatedCode, stringArrayCallsWrapperCallRegExp);\n                    });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should evaluate code without errors","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #1: base","Variant #2: `hexadecimal-numeric-string` indexes type"],"updatePoint":{"line":782,"column":59},"line":782,"code":"                    it('should evaluate code without errors', () => {\n                        assert.isTrue(areSuccessEvaluations);\n                    });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should add correct scope calls wrapper 1","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #2: correct chained calls"],"updatePoint":{"line":841,"column":70},"line":841,"code":"                it('Match #1: should add correct scope calls wrapper 1', () => {\n                    assert.match(obfuscatedCode, stringArrayScopeCallsWrapperRegExp1);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should add correct scope calls wrapper 2","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #2: correct chained calls"],"updatePoint":{"line":845,"column":70},"line":845,"code":"                it('Match #2: should add correct scope calls wrapper 2', () => {\n                    assert.match(obfuscatedCode, stringArrayScopeCallsWrapperRegExp2);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should add correct scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #2: correct chained calls"],"updatePoint":{"line":849,"column":69},"line":849,"code":"                it('Match #3: should add correct scope calls wrappers', () => {\n                    assert.match(obfuscatedCode, stringArrayCallsWrapperCallRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should evaluate code without errors","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #2: correct chained calls"],"updatePoint":{"line":853,"column":55},"line":853,"code":"                it('should evaluate code without errors', () => {\n                    assert.isTrue(areSuccessEvaluations);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should add correct scope calls wrapper","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #3: no wrappers on a root scope"],"updatePoint":{"line":900,"column":68},"line":900,"code":"                it('Match #1: should add correct scope calls wrapper', () => {\n                    assert.match(obfuscatedCode, stringArrayScopeCallsWrapperRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should add correct scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #3: no wrappers on a root scope"],"updatePoint":{"line":904,"column":69},"line":904,"code":"                it('Match #2: should add correct scope calls wrappers', () => {\n                    assert.match(obfuscatedCode, stringArrayCallsWrapperCallRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should evaluate code without errors","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #3: no wrappers on a root scope"],"updatePoint":{"line":908,"column":55},"line":908,"code":"                it('should evaluate code without errors', () => {\n                    assert.isTrue(areSuccessEvaluations);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate string array wrappers chained calls","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #4: correct evaluation of the string array wrappers chained calls","Variant #1: base","Variant #1: `Hexadecimal` identifier names generator"],"updatePoint":{"line":949,"column":89},"line":949,"code":"                        it('should correctly evaluate string array wrappers chained calls', () => {\n                            assert.equal(isEvaluationSuccessful, true);\n                        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate string array wrappers chained calls","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #4: correct evaluation of the string array wrappers chained calls","Variant #1: base","Variant #2: `Mangled` identifier names generator"],"updatePoint":{"line":988,"column":89},"line":988,"code":"                        it('should correctly evaluate string array wrappers chained calls', () => {\n                            assert.equal(isEvaluationSuccessful, true);\n                        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate string array wrappers chained calls","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #4: correct evaluation of the string array wrappers chained calls","Variant #2: advanced","Variant #1: `Hexadecimal` identifier names generator"],"updatePoint":{"line":1030,"column":89},"line":1030,"code":"                        it('should correctly evaluate string array wrappers chained calls', () => {\n                            assert.equal(isEvaluationSuccessful, true);\n                        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate string array wrappers chained calls","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #4: correct evaluation of the string array wrappers chained calls","Variant #2: advanced","Variant #2: `Mangled` identifier names generator"],"updatePoint":{"line":1070,"column":89},"line":1070,"code":"                        it('should correctly evaluate string array wrappers chained calls', () => {\n                            assert.equal(isEvaluationSuccessful, true);\n                        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should add correct scope calls wrapper 1","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #5: variable amount of the arguments","Variant #1: base"],"updatePoint":{"line":1140,"column":74},"line":1140,"code":"                    it('Match #1: should add correct scope calls wrapper 1', () => {\n                        assert.match(obfuscatedCode, stringArrayScopeCallsWrapperRegExp1);\n                    });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should add correct scope calls wrapper 2","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #5: variable amount of the arguments","Variant #1: base"],"updatePoint":{"line":1144,"column":74},"line":1144,"code":"                    it('Match #2: should add correct scope calls wrapper 2', () => {\n                        assert.match(obfuscatedCode, stringArrayScopeCallsWrapperRegExp2);\n                    });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should add correct scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #5: variable amount of the arguments","Variant #1: base"],"updatePoint":{"line":1148,"column":73},"line":1148,"code":"                    it('Match #3: should add correct scope calls wrappers', () => {\n                        assert.match(obfuscatedCode, stringArrayCallsWrapperCallRegExp);\n                    });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should evaluate code without errors","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #5: variable amount of the arguments","Variant #1: base"],"updatePoint":{"line":1152,"column":59},"line":1152,"code":"                    it('should evaluate code without errors', () => {\n                        assert.isTrue(areSuccessEvaluations);\n                    });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should add correct scope calls wrapper 1","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #5: variable amount of the arguments","Variant #2: `stringArrayEncoding` option is `rc4`"],"updatePoint":{"line":1222,"column":74},"line":1222,"code":"                    it('Match #1: should add correct scope calls wrapper 1', () => {\n                        assert.match(obfuscatedCode, stringArrayScopeCallsWrapperRegExp1);\n                    });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should add correct scope calls wrapper 2","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #5: variable amount of the arguments","Variant #2: `stringArrayEncoding` option is `rc4`"],"updatePoint":{"line":1226,"column":74},"line":1226,"code":"                    it('Match #2: should add correct scope calls wrapper 2', () => {\n                        assert.match(obfuscatedCode, stringArrayScopeCallsWrapperRegExp2);\n                    });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should add correct scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #5: variable amount of the arguments","Variant #2: `stringArrayEncoding` option is `rc4`"],"updatePoint":{"line":1230,"column":73},"line":1230,"code":"                    it('Match #3: should add correct scope calls wrappers', () => {\n                        assert.match(obfuscatedCode, stringArrayCallsWrapperCallRegExp);\n                    });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should evaluate code without errors","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #5: variable amount of the arguments","Variant #2: `stringArrayEncoding` option is `rc4`"],"updatePoint":{"line":1234,"column":59},"line":1234,"code":"                    it('should evaluate code without errors', () => {\n                        assert.isTrue(areSuccessEvaluations);\n                    });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should generate a different indexes for different string array scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #1: base","Variant #7: `stringArrayWrappersType` option has `Function` value","Variant #6: different indexes for calls wrappers"],"updatePoint":{"line":1284,"column":103},"line":1284,"code":"                it('Should generate a different indexes for different string array scope calls wrappers', () => {\n                    assert.closeTo(\n                        differentIndexesMatchesCount,\n                        differentIndexesMatchesSamplesCount,\n                        differentIndexesMatchesDelta\n                    );\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add scope calls wrappers for both `none` and `base64` string array wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #2: none and base64 encoding","Variant #1: root scope","Variant #1: `1` scope calls wrapper for each encoding type"],"updatePoint":{"line":1329,"column":102},"line":1329,"code":"                it('should add scope calls wrappers for both `none` and `base64` string array wrappers', () => {\n                    assert.match(obfuscatedCode, stringArrayWrappersRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add scope calls wrappers for both `none` and `base64` string array wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #2: none and base64 encoding","Variant #1: root scope","Variant #2: `2` scope calls wrappers for each encoding type"],"updatePoint":{"line":1366,"column":102},"line":1366,"code":"                it('should add scope calls wrappers for both `none` and `base64` string array wrappers', () => {\n                    assert.match(obfuscatedCode, stringArrayWrappersRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add scope calls wrappers for both `none` and `base64` string array wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #2: none and base64 encoding","Variant #2: function scope","Variant #1: `1` scope calls wrapper for each encoding type"],"updatePoint":{"line":1406,"column":102},"line":1406,"code":"                it('should add scope calls wrappers for both `none` and `base64` string array wrappers', () => {\n                    assert.match(obfuscatedCode, stringArrayWrappersRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add scope calls wrappers for both `none` and `base64` string array wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #2: none and base64 encoding","Variant #2: function scope","Variant #2: `2` scope calls wrappers for each encoding type"],"updatePoint":{"line":1445,"column":102},"line":1445,"code":"                it('should add scope calls wrappers for both `none` and `base64` string array wrappers', () => {\n                    assert.match(obfuscatedCode, stringArrayWrappersRegExp);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #3: none and rc4 encoding","Variant #1: correct evaluation of the scope calls wrappers"],"updatePoint":{"line":1477,"column":62},"line":1477,"code":"            it('should correctly evaluate scope calls wrappers', () => {\n                assert.equal(evaluationResult, expectedEvaluationResult);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate scope calls wrappers","suites":["StringArrayScopeCallsWrapperTransformer","Variant #4: base64 and rc4 encoding","Variant #1: correct evaluation of the scope calls wrappers"],"updatePoint":{"line":1508,"column":62},"line":1508,"code":"            it('should correctly evaluate scope calls wrappers', () => {\n                assert.equal(evaluationResult, expectedEvaluationResult);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-scope-calls-wrapper-transformer/StringArrayScopeCallsWrapperTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should replace literal node value with value from string array","suites":["StringArrayTransformer","Variant #1: default behaviour"],"updatePoint":{"line":39,"column":84},"line":39,"code":"        it('match #1: should replace literal node value with value from string array', () => {\n            assert.match(obfuscatedCode, stringArrayRegExp);\n        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should replace literal node value with value from string array","suites":["StringArrayTransformer","Variant #1: default behaviour"],"updatePoint":{"line":43,"column":84},"line":43,"code":"        it('match #2: should replace literal node value with value from string array', () => {\n            assert.match(obfuscatedCode, stringArrayCallRegExp);\n        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't replace literal node value with value from string array","suites":["StringArrayTransformer","Variant #2: `stringArray` option is disabled"],"updatePoint":{"line":64,"column":78},"line":64,"code":"        it('shouldn\\'t replace literal node value with value from string array', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform string array index with the passed index type","suites":["StringArrayTransformer","Variant #3: `stringArrayIndexesType` option","Variant #1: `hexadecimal-number` type"],"updatePoint":{"line":91,"column":88},"line":91,"code":"            it('match #1: should transform string array index with the passed index type', () => {\n                assert.match(obfuscatedCode, stringArrayCallRegExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform string array index with the passed index type","suites":["StringArrayTransformer","Variant #3: `stringArrayIndexesType` option","Variant #2: `hexadecimal-numeric-string` type"],"updatePoint":{"line":117,"column":88},"line":117,"code":"            it('match #1: should transform string array index with the passed index type', () => {\n                assert.match(obfuscatedCode, stringArrayCallRegExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform string array indexes with a `hexadecimal-number` type","suites":["StringArrayTransformer","Variant #3: `stringArrayIndexesType` option","Variant #3: multiple types"],"updatePoint":{"line":166,"column":86},"line":166,"code":"            it('should transform string array indexes with a `hexadecimal-number` type', () => {\n                assert.closeTo(hexadecimalNumberIndexTypeMatchesChance, expectedMatchesChance, expectedMatchesDelta);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should transform string array indexes with a `hexadecimal-numeric-string` type","suites":["StringArrayTransformer","Variant #3: `stringArrayIndexesType` option","Variant #3: multiple types"],"updatePoint":{"line":170,"column":94},"line":170,"code":"            it('should transform string array indexes with a `hexadecimal-numeric-string` type', () => {\n                assert.closeTo(hexadecimalNumericStringIndexTypeMatchesChance, expectedMatchesChance, expectedMatchesDelta);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should shift string array index in calls wrapper","suites":["StringArrayTransformer","Variant #4: `stringArrayIndexShift` option is enabled","Variant #1: simple"],"updatePoint":{"line":215,"column":64},"line":215,"code":"            it('should shift string array index in calls wrapper', () => {\n                assert.match(obfuscatedCode, stringArrayIndexShiftRegExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should create string array call with shifted index","suites":["StringArrayTransformer","Variant #4: `stringArrayIndexShift` option is enabled","Variant #1: simple"],"updatePoint":{"line":219,"column":76},"line":219,"code":"            it('Match #1: should create string array call with shifted index', () => {\n                assert.equal(stringArrayIndexShiftIndexValue, stringArrayCallIndexValue1);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should create string array call with shifted index","suites":["StringArrayTransformer","Variant #4: `stringArrayIndexShift` option is enabled","Variant #1: simple"],"updatePoint":{"line":223,"column":76},"line":223,"code":"            it('Match #2: should create string array call with shifted index', () => {\n                assert.equal(stringArrayIndexShiftIndexValue, stringArrayCallIndexValue2 - 1);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should create string array call with shifted index","suites":["StringArrayTransformer","Variant #4: `stringArrayIndexShift` option is enabled","Variant #1: simple"],"updatePoint":{"line":227,"column":76},"line":227,"code":"            it('Match #3: should create string array call with shifted index', () => {\n                assert.equal(stringArrayIndexShiftIndexValue, stringArrayCallIndexValue3 - 2);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate code","suites":["StringArrayTransformer","Variant #4: `stringArrayIndexShift` option is enabled","Variant #1: simple"],"updatePoint":{"line":231,"column":46},"line":231,"code":"            it('should correctly evaluate code', () => {\n                assert.equal(evaluationResult, expectedEvaluationResult);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should shift string array index in calls wrapper","suites":["StringArrayTransformer","Variant #4: `stringArrayIndexShift` option is enabled","Variant #2: `stringArrayRotate` option is enabled"],"updatePoint":{"line":259,"column":64},"line":259,"code":"            it('should shift string array index in calls wrapper', () => {\n                assert.match(obfuscatedCode, stringArrayIndexShiftRegExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate code","suites":["StringArrayTransformer","Variant #4: `stringArrayIndexShift` option is enabled","Variant #2: `stringArrayRotate` option is enabled"],"updatePoint":{"line":263,"column":46},"line":263,"code":"            it('should correctly evaluate code', () => {\n                assert.equal(evaluationResult, expectedEvaluationResult);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should shift string array index in calls wrapper","suites":["StringArrayTransformer","Variant #4: `stringArrayIndexShift` option is enabled","Variant #3: `stringArrayShuffle` option is enabled"],"updatePoint":{"line":286,"column":64},"line":286,"code":"            it('should shift string array index in calls wrapper', () => {\n                assert.match(obfuscatedCode, stringArrayIndexShiftRegExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate code","suites":["StringArrayTransformer","Variant #4: `stringArrayIndexShift` option is enabled","Variant #3: `stringArrayShuffle` option is enabled"],"updatePoint":{"line":290,"column":46},"line":290,"code":"            it('should correctly evaluate code', () => {\n                assert.equal(evaluationResult, expectedEvaluationResult);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should shift string array index in calls wrapper","suites":["StringArrayTransformer","Variant #4: `stringArrayIndexShift` option is enabled","Variant #4: `stringArrayWrappersCount` option is enabled and type is `function`"],"updatePoint":{"line":314,"column":64},"line":314,"code":"            it('should shift string array index in calls wrapper', () => {\n                assert.match(obfuscatedCode, stringArrayIndexShiftRegExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate code","suites":["StringArrayTransformer","Variant #4: `stringArrayIndexShift` option is enabled","Variant #4: `stringArrayWrappersCount` option is enabled and type is `function`"],"updatePoint":{"line":318,"column":46},"line":318,"code":"            it('should correctly evaluate code', () => {\n                assert.equal(evaluationResult, expectedEvaluationResult);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should shift string array index in calls wrapper","suites":["StringArrayTransformer","Variant #4: `stringArrayIndexShift` option is enabled","Variant #5: all string array options are enabled"],"updatePoint":{"line":348,"column":64},"line":348,"code":"            it('should shift string array index in calls wrapper', () => {\n                assert.match(obfuscatedCode, stringArrayIndexShiftRegExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly evaluate code","suites":["StringArrayTransformer","Variant #4: `stringArrayIndexShift` option is enabled","Variant #5: all string array options are enabled"],"updatePoint":{"line":352,"column":46},"line":352,"code":"            it('should correctly evaluate code', () => {\n                assert.equal(evaluationResult, expectedEvaluationResult);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should create only one item in string array for same literal node values","suites":["StringArrayTransformer","Variant #5: same literal node values"],"updatePoint":{"line":377,"column":94},"line":377,"code":"        it('match #1: should create only one item in string array for same literal node values', () => {\n            assert.match(obfuscatedCode, stringArrayRegExp);\n        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should create only one item in string array for same literal node values","suites":["StringArrayTransformer","Variant #5: same literal node values"],"updatePoint":{"line":381,"column":94},"line":381,"code":"        it('match #2: should create only one item in string array for same literal node values', () => {\n            assert.match(obfuscatedCode, stringArrayCallRegExp);\n        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't replace short literal node value with value from string array","suites":["StringArrayTransformer","Variant #6: short literal node value"],"updatePoint":{"line":404,"column":84},"line":404,"code":"        it('shouldn\\'t replace short literal node value with value from string array', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should replace literal node value with value from string array encoded using base64","suites":["StringArrayTransformer","Variant #7: base64 encoding"],"updatePoint":{"line":434,"column":105},"line":434,"code":"        it('match #1: should replace literal node value with value from string array encoded using base64', () => {\n            assert.match(obfuscatedCode, stringArrayRegExp);\n        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should replace literal node value with value from string array encoded using base64","suites":["StringArrayTransformer","Variant #7: base64 encoding"],"updatePoint":{"line":438,"column":105},"line":438,"code":"        it('match #2: should replace literal node value with value from string array encoded using base64', () => {\n            assert.match(obfuscatedCode, stringArrayCallRegExp);\n        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace literal node value with value from string array encoded using rc4","suites":["StringArrayTransformer","Variant #8: rc4 encoding","Variant #1: single string literal"],"updatePoint":{"line":463,"column":96},"line":463,"code":"            it('should replace literal node value with value from string array encoded using rc4', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should replace literal node value with value from string array encoded using rc4","suites":["StringArrayTransformer","Variant #8: rc4 encoding","Variant #2: multiple string literals"],"updatePoint":{"line":495,"column":106},"line":495,"code":"            it('Match #1: should replace literal node value with value from string array encoded using rc4', () => {\n                assert.match(obfuscatedCode, variableRegExp1);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should replace literal node value with value from string array encoded using rc4","suites":["StringArrayTransformer","Variant #8: rc4 encoding","Variant #2: multiple string literals"],"updatePoint":{"line":499,"column":106},"line":499,"code":"            it('Match #2: should replace literal node value with value from string array encoded using rc4', () => {\n                assert.match(obfuscatedCode, variableRegExp2);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should encode same values as two different encoded string array items","suites":["StringArrayTransformer","Variant #8: rc4 encoding","Variant #2: multiple string literals"],"updatePoint":{"line":503,"column":85},"line":503,"code":"            it('Should encode same values as two different encoded string array items', () => {\n                assert.notEqual(encodedLiteralValue1, encodedLiteralValue2);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add literal node value to the string array without encoding","suites":["StringArrayTransformer","Variant #9: none and base64 encoding","Variant #1: string array values"],"updatePoint":{"line":555,"column":82},"line":555,"code":"            it('should add literal node value to the string array without encoding', () => {\n                assert.closeTo(noneEncodingMatchesChance, expectedMatchesChance, expectedMatchesDelta);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add literal node value to the string array encoded using base64","suites":["StringArrayTransformer","Variant #9: none and base64 encoding","Variant #1: string array values"],"updatePoint":{"line":559,"column":86},"line":559,"code":"            it('should add literal node value to the string array encoded using base64', () => {\n                assert.closeTo(base64EncodingMatchesChance, expectedMatchesChance, expectedMatchesDelta);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace literal node value with value from string array without encoding","suites":["StringArrayTransformer","Variant #10: none and rc4 encoding","Variant #1: string array calls wrapper call"],"updatePoint":{"line":611,"column":95},"line":611,"code":"            it('should replace literal node value with value from string array without encoding', () => {\n                assert.closeTo(noneEncodingMatchesChance, expectedMatchesChance, expectedMatchesDelta);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace literal node value with value from string array encoded using rc4","suites":["StringArrayTransformer","Variant #10: none and rc4 encoding","Variant #1: string array calls wrapper call"],"updatePoint":{"line":615,"column":96},"line":615,"code":"            it('should replace literal node value with value from string array encoded using rc4', () => {\n                assert.closeTo(rc4EncodingMatchesChance, expectedMatchesChance, expectedMatchesDelta);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace literal node value with value from string array encoded using base64","suites":["StringArrayTransformer","Variant #11: base64 and rc4 encoding","Variant #1: single string literal"],"updatePoint":{"line":667,"column":99},"line":667,"code":"            it('should replace literal node value with value from string array encoded using base64', () => {\n                assert.closeTo(base64EncodingMatchesChance, expectedMatchesChance, expectedMatchesDelta);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should replace literal node value with value from string array encoded using rc4","suites":["StringArrayTransformer","Variant #11: base64 and rc4 encoding","Variant #1: single string literal"],"updatePoint":{"line":671,"column":96},"line":671,"code":"            it('should replace literal node value with value from string array encoded using rc4', () => {\n                assert.closeTo(rc4EncodingMatchesChance, expectedMatchesChance, expectedMatchesDelta);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: should replace literal node value with value from string array with `stringArrayThreshold` chance","suites":["StringArrayTransformer","Variant #12: `stringArrayThreshold` option value"],"updatePoint":{"line":711,"column":121},"line":711,"code":"        it('Variant #1: should replace literal node value with value from string array with `stringArrayThreshold` chance', () => {\n            assert.closeTo(stringArrayProbability, stringArrayThreshold, delta);\n        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #2: shouldn't replace literal node value with value from string array with `(1 - stringArrayThreshold)` chance","suites":["StringArrayTransformer","Variant #12: `stringArrayThreshold` option value"],"updatePoint":{"line":715,"column":131},"line":715,"code":"        it('Variant #2: shouldn\\'t replace literal node value with value from string array with `(1 - stringArrayThreshold)` chance', () => {\n            assert.closeTo(noStringArrayProbability, stringArrayThreshold, delta);\n        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should keep identifier with string array calls wrapper name untouched after obfuscation","suites":["StringArrayTransformer","Variant #13: string array calls wrapper name"],"updatePoint":{"line":739,"column":109},"line":739,"code":"        it('match #1: should keep identifier with string array calls wrapper name untouched after obfuscation', () => {\n            assert.match(obfuscatedCode, regExp);\n        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should ignore reserved strings","suites":["StringArrayTransformer","Variant #14: `reservedStrings` option is enabled","Variant #1: base `reservedStrings` values","Variant #1: single reserved string value"],"updatePoint":{"line":766,"column":60},"line":766,"code":"                it('match #1: should ignore reserved strings', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp1);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform non-reserved strings","suites":["StringArrayTransformer","Variant #14: `reservedStrings` option is enabled","Variant #1: base `reservedStrings` values","Variant #1: single reserved string value"],"updatePoint":{"line":770,"column":67},"line":770,"code":"                it('match #2: should transform non-reserved strings', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp2);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should ignore reserved strings","suites":["StringArrayTransformer","Variant #14: `reservedStrings` option is enabled","Variant #1: base `reservedStrings` values","Variant #2: two reserved string values"],"updatePoint":{"line":795,"column":60},"line":795,"code":"                it('match #1: should ignore reserved strings', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp1);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should ignore reserved strings","suites":["StringArrayTransformer","Variant #14: `reservedStrings` option is enabled","Variant #1: base `reservedStrings` values","Variant #2: two reserved string values"],"updatePoint":{"line":799,"column":60},"line":799,"code":"                it('match #2: should ignore reserved strings', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp2);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform non-reserved strings","suites":["StringArrayTransformer","Variant #14: `reservedStrings` option is enabled","Variant #2: RegExp `reservedStrings` values","Variant #1: single reserved string value"],"updatePoint":{"line":826,"column":67},"line":826,"code":"                it('match #1: should transform non-reserved strings', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp1);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should ignore reserved strings","suites":["StringArrayTransformer","Variant #14: `reservedStrings` option is enabled","Variant #2: RegExp `reservedStrings` values","Variant #1: single reserved string value"],"updatePoint":{"line":830,"column":60},"line":830,"code":"                it('match #2: should ignore reserved strings', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp2);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should ignore reserved strings","suites":["StringArrayTransformer","Variant #14: `reservedStrings` option is enabled","Variant #2: RegExp `reservedStrings` values","Variant #2: two reserved string values"],"updatePoint":{"line":855,"column":60},"line":855,"code":"                it('match #1: should ignore reserved strings', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp1);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should ignore reserved strings","suites":["StringArrayTransformer","Variant #14: `reservedStrings` option is enabled","Variant #2: RegExp `reservedStrings` values","Variant #2: two reserved string values"],"updatePoint":{"line":859,"column":60},"line":859,"code":"                it('match #2: should ignore reserved strings', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp2);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should not transform string","suites":["StringArrayTransformer","Variant #15: `forceTransformStrings` option is enabled","Variant #1: base `forceTransformStrings` values","Variant #1: single force transform string value"],"updatePoint":{"line":888,"column":57},"line":888,"code":"                it('match #1: should not transform string', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp1);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform force transform string","suites":["StringArrayTransformer","Variant #15: `forceTransformStrings` option is enabled","Variant #1: base `forceTransformStrings` values","Variant #1: single force transform string value"],"updatePoint":{"line":892,"column":69},"line":892,"code":"                it('match #2: should transform force transform string', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp2);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform force transform string","suites":["StringArrayTransformer","Variant #15: `forceTransformStrings` option is enabled","Variant #1: base `forceTransformStrings` values","Variant #2: two force transform string values"],"updatePoint":{"line":917,"column":69},"line":917,"code":"                it('match #1: should transform force transform string', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp1);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform force transform string","suites":["StringArrayTransformer","Variant #15: `forceTransformStrings` option is enabled","Variant #1: base `forceTransformStrings` values","Variant #2: two force transform string values"],"updatePoint":{"line":921,"column":69},"line":921,"code":"                it('match #2: should transform force transform string', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp2);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should not transform string","suites":["StringArrayTransformer","Variant #15: `forceTransformStrings` option is enabled","Variant #2: RegExp `forceTransformStrings` values","Variant #1: single force transform string value"],"updatePoint":{"line":948,"column":57},"line":948,"code":"                it('match #1: should not transform string', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp1);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform force transform string","suites":["StringArrayTransformer","Variant #15: `forceTransformStrings` option is enabled","Variant #2: RegExp `forceTransformStrings` values","Variant #1: single force transform string value"],"updatePoint":{"line":952,"column":69},"line":952,"code":"                it('match #2: should transform force transform string', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp2);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should transform force transform string","suites":["StringArrayTransformer","Variant #15: `forceTransformStrings` option is enabled","Variant #2: RegExp `forceTransformStrings` values","Variant #2: two force transform string values"],"updatePoint":{"line":977,"column":69},"line":977,"code":"                it('match #1: should transform force transform string', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp1);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform force transform string","suites":["StringArrayTransformer","Variant #15: `forceTransformStrings` option is enabled","Variant #2: RegExp `forceTransformStrings` values","Variant #2: two force transform string values"],"updatePoint":{"line":981,"column":69},"line":981,"code":"                it('match #2: should transform force transform string', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp2);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should not transform string","suites":["StringArrayTransformer","Variant #15: `forceTransformStrings` option is enabled","Variant #3: `stringArray` option is disabled","Variant #1: base case"],"updatePoint":{"line":1008,"column":57},"line":1008,"code":"                it('match #1: should not transform string', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp1);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should not transform string","suites":["StringArrayTransformer","Variant #15: `forceTransformStrings` option is enabled","Variant #3: `stringArray` option is disabled","Variant #1: base case"],"updatePoint":{"line":1012,"column":57},"line":1012,"code":"                it('match #2: should not transform string', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp2);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should not transform string","suites":["StringArrayTransformer","Variant #15: `forceTransformStrings` option is enabled","Variant #4: Priority over `reservedStrings` option","Variant #1: base case"],"updatePoint":{"line":1040,"column":57},"line":1040,"code":"                it('match #1: should not transform string', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp1);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should transform string","suites":["StringArrayTransformer","Variant #15: `forceTransformStrings` option is enabled","Variant #4: Priority over `reservedStrings` option","Variant #1: base case"],"updatePoint":{"line":1044,"column":53},"line":1044,"code":"                it('match #2: should transform string', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp2);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should not transform string","suites":["StringArrayTransformer","Variant #15: `forceTransformStrings` option is enabled","Variant #5: Priority on conditional comments","Variant #1: base case"],"updatePoint":{"line":1072,"column":57},"line":1072,"code":"                it('match #1: should not transform string', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp1);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should not transform string","suites":["StringArrayTransformer","Variant #15: `forceTransformStrings` option is enabled","Variant #5: Priority on conditional comments","Variant #1: base case"],"updatePoint":{"line":1076,"column":57},"line":1076,"code":"                it('match #2: should not transform string', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp2);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should transform string","suites":["StringArrayTransformer","Variant #15: `forceTransformStrings` option is enabled","Variant #5: Priority on conditional comments","Variant #1: base case"],"updatePoint":{"line":1080,"column":53},"line":1080,"code":"                it('match #3: should transform string', () => {\n                    assert.match(obfuscatedCode, stringLiteralRegExp3);\n                });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should not add object expression key literal to the string array","suites":["StringArrayTransformer","Variant #16: object expression key literal","Variant #1: base key literal"],"updatePoint":{"line":1107,"column":90},"line":1107,"code":"            it('match #1: should not add object expression key literal to the string array', () => {\n                assert.match(obfuscatedCode, stringArrayRegExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should keep object expression key literal","suites":["StringArrayTransformer","Variant #16: object expression key literal","Variant #1: base key literal"],"updatePoint":{"line":1111,"column":67},"line":1111,"code":"            it('match #2: should keep object expression key literal', () => {\n                assert.match(obfuscatedCode, objectExpressionRegExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should add object expression computed key literal to the string array","suites":["StringArrayTransformer","Variant #16: object expression key literal","Variant #2: computed key literal"],"updatePoint":{"line":1135,"column":95},"line":1135,"code":"            it('match #1: should add object expression computed key literal to the string array', () => {\n                assert.match(obfuscatedCode, stringArrayRegExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should replace object expression computed key literal on call to the string array","suites":["StringArrayTransformer","Variant #16: object expression key literal","Variant #2: computed key literal"],"updatePoint":{"line":1139,"column":107},"line":1139,"code":"            it('match #2: should replace object expression computed key literal on call to the string array', () => {\n                assert.match(obfuscatedCode, objectExpressionRegExp);\n            });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should not add `ImportDeclaration` source literal to the string array","suites":["StringArrayTransformer","Variant #17: import declaration source literal"],"updatePoint":{"line":1163,"column":81},"line":1163,"code":"        it('Should not add `ImportDeclaration` source literal to the string array', () => {\n            assert.match(obfuscatedCode, importDeclarationRegExp);\n        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should not add `ExportAllDeclaration` source literal to the string array","suites":["StringArrayTransformer","Variant #18: export all declaration source literal"],"updatePoint":{"line":1186,"column":84},"line":1186,"code":"        it('Should not add `ExportAllDeclaration` source literal to the string array', () => {\n            assert.match(obfuscatedCode, exportAllDeclarationRegExp);\n        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"Should not add `ExportNamedDeclaration` source literal to the string array","suites":["StringArrayTransformer","Variant #19: export named declaration source literal"],"updatePoint":{"line":1209,"column":86},"line":1209,"code":"        it('Should not add `ExportNamedDeclaration` source literal to the string array', () => {\n            assert.match(obfuscatedCode, exportNamedDeclarationRegExp);\n        });","file":"functional-tests/node-transformers/string-array-transformers/string-array-transformer/StringArrayTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should pass validation","suites":["`domainLockRedirectUrl` validation","IsDomainLockRedirectUrl","Variant #1: positive validation","Variant #1: string with url containing protocol, host and some path"],"updatePoint":{"line":23,"column":42},"line":23,"code":"                it('should pass validation', () => {\n                    assert.doesNotThrow(testFunc);\n                });","file":"functional-tests/options/domain-lock-destination/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should pass validation","suites":["`domainLockRedirectUrl` validation","IsDomainLockRedirectUrl","Variant #1: positive validation","Variant #2: string with url containing host and some path"],"updatePoint":{"line":41,"column":42},"line":41,"code":"                it('should pass validation', () => {\n                    assert.doesNotThrow(testFunc);\n                });","file":"functional-tests/options/domain-lock-destination/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should pass validation","suites":["`domainLockRedirectUrl` validation","IsDomainLockRedirectUrl","Variant #1: positive validation","Variant #3: string with url containing host and some path"],"updatePoint":{"line":59,"column":42},"line":59,"code":"                it('should pass validation', () => {\n                    assert.doesNotThrow(testFunc);\n                });","file":"functional-tests/options/domain-lock-destination/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should pass validation","suites":["`domainLockRedirectUrl` validation","IsDomainLockRedirectUrl","Variant #1: positive validation","Variant #4: `about:blank` string"],"updatePoint":{"line":77,"column":42},"line":77,"code":"                it('should pass validation', () => {\n                    assert.doesNotThrow(testFunc);\n                });","file":"functional-tests/options/domain-lock-destination/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should not pass validation","suites":["`domainLockRedirectUrl` validation","IsDomainLockRedirectUrl","Variant #2: negative validation","Variant #1: some non-url string"],"updatePoint":{"line":98,"column":46},"line":98,"code":"                it('should not pass validation', () => {\n                    assert.throws(testFunc, expectedError);\n                });","file":"functional-tests/options/domain-lock-destination/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should pass validation when obfuscation target is `browser`","suites":["`domainLock` validation","IsAllowedForObfuscationTarget","Variant #1: positive validation","Variant #1: obfuscation target: `browser`"],"updatePoint":{"line":26,"column":79},"line":26,"code":"                it('should pass validation when obfuscation target is `browser`', () => {\n                    assert.doesNotThrow(testFunc);\n                });","file":"functional-tests/options/domain-lock/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should pass validation when obfuscation target is `node` and value is default","suites":["`domainLock` validation","IsAllowedForObfuscationTarget","Variant #1: positive validation","Variant #2: obfuscation target: `node` and default value"],"updatePoint":{"line":45,"column":97},"line":45,"code":"                it('should pass validation when obfuscation target is `node` and value is default', () => {\n                    assert.doesNotThrow(testFunc);\n                });","file":"functional-tests/options/domain-lock/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should not pass validation when obfuscation target is `node` and value is not default","suites":["`domainLock` validation","IsAllowedForObfuscationTarget","Variant #2: negative validation"],"updatePoint":{"line":67,"column":101},"line":67,"code":"            it('should not pass validation when obfuscation target is `node` and value is not default', () => {\n                assert.throws(testFunc, expectedError);\n            });","file":"functional-tests/options/domain-lock/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should pass validation","suites":["`identifierNamesCache` validation","IsIdentifierNamesCache","Variant #1: positive validation","Variant #1: object with existing identifier names cached"],"updatePoint":{"line":30,"column":42},"line":30,"code":"                it('should pass validation', () => {\n                    assert.doesNotThrow(testFunc);\n                });","file":"functional-tests/options/identifier-names-cache/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should pass validation","suites":["`identifierNamesCache` validation","IsIdentifierNamesCache","Variant #1: positive validation","Variant #2: object with empty identifier names cache"],"updatePoint":{"line":53,"column":42},"line":53,"code":"                it('should pass validation', () => {\n                    assert.doesNotThrow(testFunc);\n                });","file":"functional-tests/options/identifier-names-cache/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should pass validation","suites":["`identifierNamesCache` validation","IsIdentifierNamesCache","Variant #1: positive validation","Variant #3: object with empty identifier names caches"],"updatePoint":{"line":74,"column":42},"line":74,"code":"                it('should pass validation', () => {\n                    assert.doesNotThrow(testFunc);\n                });","file":"functional-tests/options/identifier-names-cache/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should pass validation","suites":["`identifierNamesCache` validation","IsIdentifierNamesCache","Variant #1: positive validation","Variant #4: object with some empty identifier names cache"],"updatePoint":{"line":96,"column":42},"line":96,"code":"                it('should pass validation', () => {\n                    assert.doesNotThrow(testFunc);\n                });","file":"functional-tests/options/identifier-names-cache/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should pass validation","suites":["`identifierNamesCache` validation","IsIdentifierNamesCache","Variant #1: positive validation","Variant #5: empty object"],"updatePoint":{"line":114,"column":42},"line":114,"code":"                it('should pass validation', () => {\n                    assert.doesNotThrow(testFunc);\n                });","file":"functional-tests/options/identifier-names-cache/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should pass validation","suites":["`identifierNamesCache` validation","IsIdentifierNamesCache","Variant #1: positive validation","Variant #5: `null` value"],"updatePoint":{"line":132,"column":42},"line":132,"code":"                it('should pass validation', () => {\n                    assert.doesNotThrow(testFunc);\n                });","file":"functional-tests/options/identifier-names-cache/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should not pass validation","suites":["`identifierNamesCache` validation","IsIdentifierNamesCache","Variant #2: negative validation","Variant #1: string value"],"updatePoint":{"line":154,"column":46},"line":154,"code":"                it('should not pass validation', () => {\n                    assert.throws(testFunc, expectedError);\n                });","file":"functional-tests/options/identifier-names-cache/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should not pass validation","suites":["`identifierNamesCache` validation","IsIdentifierNamesCache","Variant #2: negative validation","Variant #2: cache with number values inside single cache"],"updatePoint":{"line":178,"column":46},"line":178,"code":"                it('should not pass validation', () => {\n                    assert.throws(testFunc, expectedError);\n                });","file":"functional-tests/options/identifier-names-cache/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should not pass validation","suites":["`identifierNamesCache` validation","IsIdentifierNamesCache","Variant #2: negative validation","Variant #3: cache with number values inside both caches"],"updatePoint":{"line":205,"column":46},"line":205,"code":"                it('should not pass validation', () => {\n                    assert.throws(testFunc, expectedError);\n                });","file":"functional-tests/options/identifier-names-cache/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should not pass validation","suites":["`identifierNamesCache` validation","IsIdentifierNamesCache","Variant #2: negative validation","Variant #4: cache with mixed values"],"updatePoint":{"line":231,"column":46},"line":231,"code":"                it('should not pass validation', () => {\n                    assert.throws(testFunc, expectedError);\n                });","file":"functional-tests/options/identifier-names-cache/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should not pass validation","suites":["`identifierNamesCache` validation","IsIdentifierNamesCache","Variant #2: negative validation","Variant #5: cache with nullable dictionary fields"],"updatePoint":{"line":252,"column":46},"line":252,"code":"                it('should not pass validation', () => {\n                    assert.throws(testFunc, expectedError);\n                });","file":"functional-tests/options/identifier-names-cache/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should pass validation","suites":["`inputFileName` validation","IsInputFileName","Variant #1: positive validation","Variant #1: empty string when `sourceMapSourcesMode: 'sources-content'"],"updatePoint":{"line":25,"column":42},"line":25,"code":"                it('should pass validation', () => {\n                    assert.doesNotThrow(testFunc);\n                });","file":"functional-tests/options/input-file-name/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should pass validation","suites":["`inputFileName` validation","IsInputFileName","Variant #1: positive validation","Variant #2: string with input file name when `sourceMapSourcesMode: 'sources'"],"updatePoint":{"line":44,"column":42},"line":44,"code":"                it('should pass validation', () => {\n                    assert.doesNotThrow(testFunc);\n                });","file":"functional-tests/options/input-file-name/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should not pass validation","suites":["`inputFileName` validation","IsInputFileName","Variant #2: negative validation","Variant #1: empty string when `sourceMapSourcesMode: 'sources'"],"updatePoint":{"line":66,"column":46},"line":66,"code":"                it('should not pass validation', () => {\n                    assert.throws(testFunc, expectedError);\n                });","file":"functional-tests/options/input-file-name/Validation.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct options preset","suites":["Options","Options preset","Preset selection","Default preset"],"updatePoint":{"line":51,"column":56},"line":51,"code":"                it('should return correct options preset', () => {\n                    assert.deepEqualExcluding<IOptions | TInputOptions>(options, expectedOptions, 'seed');\n                });","file":"functional-tests/options/Options.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct options preset","suites":["Options","Options preset","Preset selection","Low obfuscation preset"],"updatePoint":{"line":65,"column":56},"line":65,"code":"                it('should return correct options preset', () => {\n                    assert.deepEqualExcluding<IOptions | TInputOptions>(options, expectedOptions, 'seed');\n                });","file":"functional-tests/options/Options.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct options preset","suites":["Options","Options preset","Preset selection","Medium obfuscation preset"],"updatePoint":{"line":79,"column":56},"line":79,"code":"                it('should return correct options preset', () => {\n                    assert.deepEqualExcluding<IOptions | TInputOptions>(options, expectedOptions, 'seed');\n                });","file":"functional-tests/options/Options.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct options preset","suites":["Options","Options preset","Preset selection","High obfuscation preset"],"updatePoint":{"line":93,"column":56},"line":93,"code":"                it('should return correct options preset', () => {\n                    assert.deepEqualExcluding<IOptions | TInputOptions>(options, expectedOptions, 'seed');\n                });","file":"functional-tests/options/Options.spec.ts","skipped":false,"dir":"test"},{"name":"should return merge input options with options preset","suites":["Options","Options preset","Input options merge with preset"],"updatePoint":{"line":112,"column":69},"line":112,"code":"            it('should return merge input options with options preset', () => {\n                assert.deepEqualExcluding<IOptions | TInputOptions>(options, expectedOptions, 'seed');\n            });","file":"functional-tests/options/Options.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","controlFlowFlatteningThresholdRule"],"updatePoint":{"line":63,"column":47},"line":63,"code":"            it('should normalize options preset', () => {\n                assert.deepEqual(optionsPreset, expectedOptionsPreset);\n            });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","deadCodeInjectionRule"],"updatePoint":{"line":87,"column":47},"line":87,"code":"            it('should normalize options preset', () => {\n                assert.deepEqual(optionsPreset, expectedOptionsPreset);\n            });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","deadCodeInjectionRule","`stringArrayThreshold` option is empty"],"updatePoint":{"line":112,"column":51},"line":112,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","deadCodeInjectionRule","`stringArrayThreshold` option is not empty"],"updatePoint":{"line":136,"column":51},"line":136,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","deadCodeInjectionThresholdRule"],"updatePoint":{"line":157,"column":47},"line":157,"code":"            it('should normalize options preset', () => {\n                assert.deepEqual(optionsPreset, expectedOptionsPreset);\n            });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should not normalize options preset","suites":["OptionsNormalizer","normalize","domainLockRedirectUrlRule","Variant #1: `domainLock` option is set"],"updatePoint":{"line":182,"column":55},"line":182,"code":"                it('should not normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","domainLockRedirectUrlRule","Variant #2 `domainLock` option is not set"],"updatePoint":{"line":202,"column":51},"line":202,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","domainLockRule"],"updatePoint":{"line":227,"column":47},"line":227,"code":"            it('should normalize options preset', () => {\n                assert.deepEqual(optionsPreset, expectedOptionsPreset);\n            });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","inputFileNameRule","Variant #1: extension isn't set"],"updatePoint":{"line":246,"column":51},"line":246,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","inputFileNameRule","Variant #2: extension is set"],"updatePoint":{"line":264,"column":51},"line":264,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","inputFileNameRule","Variant #3: extension in set with `.map` postfix"],"updatePoint":{"line":282,"column":51},"line":282,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","inputFileNameRule","Variant #4: no file name"],"updatePoint":{"line":300,"column":51},"line":300,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","inputFileNameRule","Variant #5: relative path"],"updatePoint":{"line":318,"column":51},"line":318,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should not normalize options preset","suites":["OptionsNormalizer","normalize","identifierNamesCacheRule","Variant #1: all fields are exist with values"],"updatePoint":{"line":352,"column":55},"line":352,"code":"                it('should not normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should not normalize options preset","suites":["OptionsNormalizer","normalize","identifierNamesCacheRule","Variant #2: some fields are exist with values"],"updatePoint":{"line":380,"column":55},"line":380,"code":"                it('should not normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should not normalize options preset","suites":["OptionsNormalizer","normalize","identifierNamesCacheRule","Variant #3: all fields are exist with empty objects"],"updatePoint":{"line":404,"column":55},"line":404,"code":"                it('should not normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","identifierNamesCacheRule","Variant #4: some fields are missing"],"updatePoint":{"line":431,"column":51},"line":431,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","identifierNamesCacheRule","Variant #5: all fields are missing"],"updatePoint":{"line":452,"column":51},"line":452,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should not normalize options preset","suites":["OptionsNormalizer","normalize","seedRule","Variant #1: seed value is string"],"updatePoint":{"line":472,"column":55},"line":472,"code":"                it('should not normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","seedRule","Variant #2: seed value is number"],"updatePoint":{"line":490,"column":51},"line":490,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize seed value","suites":["OptionsNormalizer","normalize","seedRule","Variant #3: seed value is `0``"],"updatePoint":{"line":507,"column":47},"line":507,"code":"                it('should normalize seed value', () => {\n                    assert.isAtLeast(seedValue, 0);\n                    assert.isBelow(seedValue, 999_999_999);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","selfDefendingRule"],"updatePoint":{"line":529,"column":47},"line":529,"code":"            it('should normalize options preset', () => {\n                assert.deepEqual(optionsPreset, expectedOptionsPreset);\n            });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","sourceMapBaseUrlRule","Variant #1: only source map base url"],"updatePoint":{"line":548,"column":51},"line":548,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","sourceMapBaseUrlRule","Variant #2: source map base url with source map file name"],"updatePoint":{"line":568,"column":51},"line":568,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","sourceMapFileNameRule","Base filename without extension"],"updatePoint":{"line":590,"column":51},"line":590,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","sourceMapFileNameRule","Slashes in file name"],"updatePoint":{"line":610,"column":51},"line":610,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","sourceMapFileNameRule","`js` file extension in file name"],"updatePoint":{"line":630,"column":51},"line":630,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","sourceMapFileNameRule","Non `js` file extension in file name"],"updatePoint":{"line":650,"column":51},"line":650,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","sourceMapFileNameRule","File hash in file name"],"updatePoint":{"line":670,"column":51},"line":670,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","sourceMapFileNameRule","File hash and `js` file extension in file name #1"],"updatePoint":{"line":690,"column":51},"line":690,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","sourceMapFileNameRule","File hash and non `js` file extension in file name"],"updatePoint":{"line":710,"column":51},"line":710,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","splitStringsChunkLengthRule","`splitStringsChunkLengthRule` value is float number"],"updatePoint":{"line":732,"column":51},"line":732,"code":"                it('should normalize options preset', () => {\n                    assert.deepEqual(optionsPreset, expectedOptionsPreset);\n                });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","stringArrayRule"],"updatePoint":{"line":769,"column":47},"line":769,"code":"            it('should normalize options preset', () => {\n                assert.deepEqual(optionsPreset, expectedOptionsPreset);\n            });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","stringArrayCallsTransformThresholdRule"],"updatePoint":{"line":789,"column":47},"line":789,"code":"            it('should normalize options preset', () => {\n                assert.deepEqual(optionsPreset, expectedOptionsPreset);\n            });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","stringArrayEncodingRule"],"updatePoint":{"line":809,"column":47},"line":809,"code":"            it('should normalize options preset', () => {\n                assert.deepEqual(optionsPreset, expectedOptionsPreset);\n            });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"should normalize options preset","suites":["OptionsNormalizer","normalize","stringArrayWrappersChainedCallsRule"],"updatePoint":{"line":829,"column":47},"line":829,"code":"            it('should normalize options preset', () => {\n                assert.deepEqual(optionsPreset, expectedOptionsPreset);\n            });","file":"functional-tests/options/OptionsNormalizer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: should create single string array variant","suites":["StringArrayStorage","Rotate string array","Variant #1: single string array value","String array probability"],"updatePoint":{"line":56,"column":73},"line":56,"code":"                it('Variant #1: should create single string array variant', () => {\n                    assert.closeTo(stringArrayVariantProbability, expectedVariantProbability, delta);\n                });","file":"functional-tests/storages/string-array-transformers/string-array-storage/StringArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: should replace literal node with call to string array variant","suites":["StringArrayStorage","Rotate string array","Variant #1: single string array value","Literal node probability"],"updatePoint":{"line":62,"column":93},"line":62,"code":"                it('Variant #1: should replace literal node with call to string array variant', () => {\n                    assert.closeTo(literalNodeVariantProbability, expectedVariantProbability, delta);\n                });","file":"functional-tests/storages/string-array-transformers/string-array-storage/StringArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #: should create string array variant","suites":["StringArrayStorage","Rotate string array","Variant #2: Three string array values","String array probability"],"updatePoint":{"line":133,"column":85},"line":133,"code":"                    it(`Variant #${variantNumber}: should create string array variant`, () => {\n                        assert.closeTo(stringArrayVariantProbabilities[variantIndex], expectedStringArrayVariantProbability, delta);\n                    });","file":"functional-tests/storages/string-array-transformers/string-array-storage/StringArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #: should replace literal node with call to string array variant","suites":["StringArrayStorage","Rotate string array","Variant #2: Three string array values","Literal node probability"],"updatePoint":{"line":143,"column":112},"line":143,"code":"                    it(`Variant #${variantNumber}: should replace literal node with call to string array variant`, () => {\n                        assert.closeTo(literalNodeVariantProbabilities[variantIndex], expectedLiteralNodeVariantProbability, delta);\n                    });","file":"functional-tests/storages/string-array-transformers/string-array-storage/StringArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: should create string array variant","suites":["StringArrayStorage","Shuffle string array","Variant #1: single string array value","String array probability"],"updatePoint":{"line":196,"column":66},"line":196,"code":"                it('Variant #1: should create string array variant', () => {\n                    assert.closeTo(stringArrayVariant1Probability, expectedVariantProbability, delta);\n                });","file":"functional-tests/storages/string-array-transformers/string-array-storage/StringArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: should replace literal node with call to string array variant","suites":["StringArrayStorage","Shuffle string array","Variant #1: single string array value","Literal node probability"],"updatePoint":{"line":202,"column":93},"line":202,"code":"                it('Variant #1: should replace literal node with call to string array variant', () => {\n                    assert.closeTo(literalNodeVariant1Probability, expectedVariantProbability, delta);\n                });","file":"functional-tests/storages/string-array-transformers/string-array-storage/StringArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #: should create string array variant","suites":["StringArrayStorage","Shuffle string array","Variant #2: Three string array values"],"updatePoint":{"line":298,"column":81},"line":298,"code":"                it(`Variant #${variantNumber}: should create string array variant`, () => {\n                    assert.closeTo(stringArrayVariantProbabilities[variantIndex], expectedVariantProbability, delta);\n                });","file":"functional-tests/storages/string-array-transformers/string-array-storage/StringArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #: should replace literal node with call to string array variant","suites":["StringArrayStorage","Shuffle string array","Variant #2: Three string array values"],"updatePoint":{"line":302,"column":108},"line":302,"code":"                it(`Variant #${variantNumber}: should replace literal node with call to string array variant`, () => {\n                    assert.closeTo(literalNodeVariantProbabilities[variantIndex], expectedVariantProbability, delta);\n                });","file":"functional-tests/storages/string-array-transformers/string-array-storage/StringArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should keep heap usage without memory leaks","suites":["JavaScriptObfuscator memory","memory: heap usage"],"updatePoint":{"line":19,"column":55},"line":19,"code":"        it('should keep heap usage without memory leaks', () => {\n            const sourceCode: string = readFileAsString('./test/fixtures/sample.js');\n\n            const maxHeapUsed: number[] = [];\n            let prevHeapUsed: number | null = null;\n\n            for (let i: number = 0; i < iterationsCount; i++) {\n                JavaScriptObfuscator.obfuscate(\n                    sourceCode,\n                    {\n                        compact: true,\n                        controlFlowFlattening: true,\n                        controlFlowFlatteningThreshold: 0.75,\n                        deadCodeInjection: true,\n                        deadCodeInjectionThreshold: 0.4,\n                        debugProtection: false,\n                        debugProtectionInterval: 0,\n                        disableConsoleOutput: true,\n                        identifierNamesGenerator: 'mangled',\n                        log: false,\n                        renameGlobals: false,\n                        stringArrayRotate: true,\n                        selfDefending: true,\n                        stringArrayShuffle: true,\n                        splitStrings: true,\n                        splitStringsChunkLength: 2,\n                        stringArray: true,\n                        stringArrayEncoding: [StringArrayEncoding.Base64],\n                        stringArrayThreshold: 0.75,\n                        transformObjectKeys: true,\n                        unicodeEscapeSequence: false\n                    }\n                );\n\n                const heap = process.memoryUsage();\n                const heapUsed: number = heapValueToMB(heap.heapUsed);\n\n                const gcDiff: number = (prevHeapUsed ?? heapUsed) - heapUsed;\n\n                if (prevHeapUsed && gcDiff > gcDiffThreshold) {\n                    maxHeapUsed.push(prevHeapUsed);\n                }\n\n                prevHeapUsed = heapUsed;\n            }\n\n            const sortedMaxHeapUsed: number[] = [...maxHeapUsed].sort((a: number, b: number) => a - b);\n\n            const firstMaxHeapMBUsed: number = sortedMaxHeapUsed[0] ?? 0;\n            const lastMaxHeapMbUsed: number = sortedMaxHeapUsed[sortedMaxHeapUsed.length - 1] ?? 0;\n\n            const diff: number = lastMaxHeapMbUsed - firstMaxHeapMBUsed;\n\n            assert.closeTo(diff, 0, allowedHeapDiffThreshold);\n        });","file":"performance-tests/JavaScriptObfuscatorMemory.spec.ts","skipped":false,"dir":"test"},{"name":"shows performance time with multiple obfuscator calls","suites":["JavaScriptObfuscator performance","performance: multiple calls"],"updatePoint":{"line":13,"column":65},"line":13,"code":"        it('shows performance time with multiple obfuscator calls', () => {\n            for (let i: number = 0; i < iterationsCount; i++) {\n                JavaScriptObfuscator.obfuscate(readFileAsString('./test/fixtures/sample.js'));\n            }\n\n            assert.isOk(true);\n        });","file":"performance-tests/JavaScriptObfuscatorPerformance.spec.ts","skipped":false,"dir":"test"},{"name":"shows performance time with large code size","suites":["JavaScriptObfuscator performance","performance: large source code"],"updatePoint":{"line":23,"column":55},"line":23,"code":"        it('shows performance time with large code size', () => {\n            JavaScriptObfuscator.obfuscate(readFileAsString('./test/fixtures/sample.js').repeat(iterationsCount));\n\n            assert.isOk(true);\n        });","file":"performance-tests/JavaScriptObfuscatorPerformance.spec.ts","skipped":false,"dir":"test"},{"name":"should obfuscate code without any runtime errors after obfuscation: Variant #1 astring","suites":["JavaScriptObfuscator runtime eval","Astring. "],"updatePoint":{"line":95,"column":102},"line":95,"code":"            it('should obfuscate code without any runtime errors after obfuscation: Variant #1 astring', () => {\n                const code: string = readFileAsString(__dirname + '/fixtures/astring.js');\n\n                const obfuscatedCode: string = JavaScriptObfuscator.obfuscate(\n                    `\n                    ${getEnvironmentCode()}\n                    ${code}\n                    const code = generate({\n                        \"type\": \"Program\",\n                        \"body\": [\n                            {\n                                \"type\": \"FunctionDeclaration\",\n                                \"id\": {\n                                    \"type\": \"Identifier\",\n                                    \"name\": \"test\",\n                                    \"range\": [\n                                        9,\n                                        13\n                                    ]\n                                },\n                                \"params\": [],\n                                \"body\": {\n                                    \"type\": \"BlockStatement\",\n                                    \"body\": [\n                                        {\n                                            \"type\": \"ReturnStatement\",\n                                            \"argument\": {\n                                                \"type\": \"Literal\",\n                                                \"value\": \"foo\",\n                                                \"raw\": \"'foo'\",\n                                                \"range\": [\n                                                    30,\n                                                    35\n                                                ]\n                                            },\n                                            \"range\": [\n                                                23,\n                                                36\n                                            ]\n                                        }\n                                    ],\n                                    \"range\": [\n                                        17,\n                                        38\n                                    ]\n                                },\n                                \"generator\": false,\n                                \"expression\": false,\n                                \"async\": false,\n                                \"range\": [\n                                    0,\n                                    38\n                                ]\n                            }\n                        ],\n                        \"sourceType\": \"module\",\n                        \"range\": [\n                            0,\n                            38\n                        ],\n                        \"comments\": []\n                    });\n                    \n                    eval(\\`\\${code} test();\\`);\n                    `,\n                    {\n                        ...baseOptions,\n                        ...options,\n                        renamePropertiesMode: RenamePropertiesMode.Safe,\n                        reservedNames: ['generate']\n                    }\n                ).getObfuscatedCode();\n\n                let evaluationResult: string;\n\n                try {\n                    evaluationResult = eval(obfuscatedCode)\n                } catch (e) {\n                    throw new Error(`Evaluation error: ${e.message}. Code: ${obfuscatedCode}`);\n                }\n\n                assert.equal(evaluationResult, 'foo');\n            });","file":"runtime-tests/JavaScriptObfuscatorRuntime.spec.ts","skipped":false,"dir":"test"},{"name":"should obfuscate code without any runtime errors after obfuscation: Variant #2 sha256","suites":["JavaScriptObfuscator runtime eval","Sha256. "],"updatePoint":{"line":181,"column":101},"line":181,"code":"            it('should obfuscate code without any runtime errors after obfuscation: Variant #2 sha256', () => {\n                const code: string = readFileAsString(__dirname + '/fixtures/sha256.js');\n\n                const obfuscatedCode: string = JavaScriptObfuscator.obfuscate(\n                    `\n                    ${getEnvironmentCode()}\n                    ${code}\n                    sha256('test');\n                    `,\n                    {\n                        ...baseOptions,\n                        ...options,\n                        reservedNames: ['sha256']\n                    }\n                ).getObfuscatedCode();\n\n                assert.equal(\n                    eval(obfuscatedCode),\n                    '9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08'\n                );\n            });","file":"runtime-tests/JavaScriptObfuscatorRuntime.spec.ts","skipped":false,"dir":"test"},{"name":"should obfuscate code without any runtime errors after obfuscation: Variant #3 obfuscator","suites":["JavaScriptObfuscator runtime eval","Obfuscator. "],"updatePoint":{"line":243,"column":105},"line":243,"code":"            it('should obfuscate code without any runtime errors after obfuscation: Variant #3 obfuscator', () => {\n                assert.equal(\n                    evaluationResult,\n                    'var foo=0x1;'\n                );\n            });","file":"runtime-tests/JavaScriptObfuscatorRuntime.spec.ts","skipped":false,"dir":"test"},{"name":"should obfuscate code without any runtime errors after obfuscation: Variant #4 webpack bootstrap","suites":["JavaScriptObfuscator runtime eval","Webpack bootstrap code. . "],"updatePoint":{"line":304,"column":116},"line":304,"code":"                it('should obfuscate code without any runtime errors after obfuscation: Variant #4 webpack bootstrap', () => {\n                    assert.equal(evaluationResult, 'foo');\n                });","file":"runtime-tests/JavaScriptObfuscatorRuntime.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct limit index based on block scope body length","suites":["CallsGraphAnalyzer","getLimitIndex","Variant #1: length - 10000"],"updatePoint":{"line":17,"column":82},"line":17,"code":"            it('should return correct limit index based on block scope body length', () => {\n                assert.equal(limitIndex, expectedLimitIndex);\n            });","file":"unit-tests/analyzers/calls-graph-analyzer/CallsGraphAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct limit index based on block scope body length","suites":["CallsGraphAnalyzer","getLimitIndex","Variant #2: length - 1000"],"updatePoint":{"line":30,"column":82},"line":30,"code":"            it('should return correct limit index based on block scope body length', () => {\n                assert.equal(limitIndex, expectedLimitIndex);\n            });","file":"unit-tests/analyzers/calls-graph-analyzer/CallsGraphAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct limit index based on block scope body length","suites":["CallsGraphAnalyzer","getLimitIndex","Variant #3: length - 25"],"updatePoint":{"line":43,"column":82},"line":43,"code":"            it('should return correct limit index based on block scope body length', () => {\n                assert.equal(limitIndex, expectedLimitIndex);\n            });","file":"unit-tests/analyzers/calls-graph-analyzer/CallsGraphAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct limit index based on block scope body length","suites":["CallsGraphAnalyzer","getLimitIndex","Variant #4: length - 5"],"updatePoint":{"line":56,"column":82},"line":56,"code":"            it('should return correct limit index based on block scope body length', () => {\n                assert.equal(limitIndex, expectedLimitIndex);\n            });","file":"unit-tests/analyzers/calls-graph-analyzer/CallsGraphAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct number numerical expression data","suites":["NumberNumericalExpressionAnalyzer","analyze","Positive numbers","Variant #1: positive number"],"updatePoint":{"line":55,"column":74},"line":55,"code":"                it('should return correct number numerical expression data', () => {\n                    assert.equal(number, evaluatedResult);\n                });","file":"unit-tests/analyzers/number-numerical-expression-analyzer/NumberNumericalExpressionAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct number numerical expression data","suites":["NumberNumericalExpressionAnalyzer","analyze","Positive numbers","Variant #2: positive zero number"],"updatePoint":{"line":73,"column":74},"line":73,"code":"                it('should return correct number numerical expression data', () => {\n                    assert.equal(number, evaluatedResult);\n                });","file":"unit-tests/analyzers/number-numerical-expression-analyzer/NumberNumericalExpressionAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct number numerical expression data","suites":["NumberNumericalExpressionAnalyzer","analyze","Positive numbers","Variant #3: positive big number"],"updatePoint":{"line":91,"column":74},"line":91,"code":"                it('should return correct number numerical expression data', () => {\n                    assert.equal(number, evaluatedResult);\n                });","file":"unit-tests/analyzers/number-numerical-expression-analyzer/NumberNumericalExpressionAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct number numerical expression data","suites":["NumberNumericalExpressionAnalyzer","analyze","Positive numbers","Variant #4: positive unsafe big number"],"updatePoint":{"line":109,"column":74},"line":109,"code":"                it('should return correct number numerical expression data', () => {\n                    assert.equal(number, evaluatedResult);\n                });","file":"unit-tests/analyzers/number-numerical-expression-analyzer/NumberNumericalExpressionAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct number numerical expression data","suites":["NumberNumericalExpressionAnalyzer","analyze","Negative numbers","Variant #1: negative number"],"updatePoint":{"line":129,"column":74},"line":129,"code":"                it('should return correct number numerical expression data', () => {\n                    assert.equal(number, evaluatedResult);\n                });","file":"unit-tests/analyzers/number-numerical-expression-analyzer/NumberNumericalExpressionAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct number numerical expression data","suites":["NumberNumericalExpressionAnalyzer","analyze","Negative numbers","Variant #2: negative zero number"],"updatePoint":{"line":147,"column":74},"line":147,"code":"                it('should return correct number numerical expression data', () => {\n                    assert.equal(number, evaluatedResult);\n                });","file":"unit-tests/analyzers/number-numerical-expression-analyzer/NumberNumericalExpressionAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct number numerical expression data","suites":["NumberNumericalExpressionAnalyzer","analyze","Negative numbers","Variant #3: negative big number"],"updatePoint":{"line":165,"column":74},"line":165,"code":"                it('should return correct number numerical expression data', () => {\n                    assert.equal(number, evaluatedResult);\n                });","file":"unit-tests/analyzers/number-numerical-expression-analyzer/NumberNumericalExpressionAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct number numerical expression data","suites":["NumberNumericalExpressionAnalyzer","analyze","Negative numbers","Variant #4: negative unsafe number"],"updatePoint":{"line":183,"column":74},"line":183,"code":"                it('should return correct number numerical expression data', () => {\n                    assert.equal(number, evaluatedResult);\n                });","file":"unit-tests/analyzers/number-numerical-expression-analyzer/NumberNumericalExpressionAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should throw error","suites":["NumberNumericalExpressionAnalyzer","analyze","NaN"],"updatePoint":{"line":201,"column":34},"line":201,"code":"            it('should throw error', () => {\n                assert.throw(testFunc, 'Given value is NaN');\n            });","file":"unit-tests/analyzers/number-numerical-expression-analyzer/NumberNumericalExpressionAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct prevailing kind of variables","suites":["PrevailingKindOfVariablesAnalyzer","analyze","Prevailing `var` kind"],"updatePoint":{"line":66,"column":66},"line":66,"code":"            it('should return correct prevailing kind of variables', () => {\n                assert.equal(prevailingKindOfVariables, expectedPrevailingKind);\n            });","file":"unit-tests/analyzers/prevailing-kind-of-variables-analyzer/PrevailingKindOfVariablesAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct prevailing kind of variables","suites":["PrevailingKindOfVariablesAnalyzer","analyze","Prevailing `let` kind"],"updatePoint":{"line":109,"column":66},"line":109,"code":"            it('should return correct prevailing kind of variables', () => {\n                assert.equal(prevailingKindOfVariables, expectedPrevailingKind);\n            });","file":"unit-tests/analyzers/prevailing-kind-of-variables-analyzer/PrevailingKindOfVariablesAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct prevailing kind of variables","suites":["PrevailingKindOfVariablesAnalyzer","analyze","Prevailing `const` kind"],"updatePoint":{"line":152,"column":66},"line":152,"code":"            it('should return correct prevailing kind of variables', () => {\n                assert.equal(prevailingKindOfVariables, expectedPrevailingKind);\n            });","file":"unit-tests/analyzers/prevailing-kind-of-variables-analyzer/PrevailingKindOfVariablesAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct prevailing kind of variables","suites":["PrevailingKindOfVariablesAnalyzer","analyze","No variables"],"updatePoint":{"line":167,"column":66},"line":167,"code":"            it('should return correct prevailing kind of variables', () => {\n                assert.equal(prevailingKindOfVariables, expectedPrevailingKind);\n            });","file":"unit-tests/analyzers/prevailing-kind-of-variables-analyzer/PrevailingKindOfVariablesAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return scope data with variables","suites":["ScopeAnalyzer","analyze","Variant #1: base analyze of the scope for ProgramNode"],"updatePoint":{"line":52,"column":55},"line":52,"code":"            it('should return scope data with variables', () => {\n                assert.equal(scopeVariablesLength, expectedScopeVariablesLength);\n            });","file":"unit-tests/analyzers/scope-analyzer/ScopeAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should return scope data with correct variable name","suites":["ScopeAnalyzer","analyze","Variant #1: base analyze of the scope for ProgramNode"],"updatePoint":{"line":56,"column":67},"line":56,"code":"            it('should return scope data with correct variable name', () => {\n                assert.equal(scopeVariableName, expectedScopeVariablesName);\n            });","file":"unit-tests/analyzers/scope-analyzer/ScopeAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should throw error","suites":["ScopeAnalyzer","analyze","Variant #2: Acquire of the scope for VariableDeclarationNode"],"updatePoint":{"line":80,"column":34},"line":80,"code":"            it('should throw error', () => {\n                assert.throws(testFunc, expectedError);\n            });","file":"unit-tests/analyzers/scope-analyzer/ScopeAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should throw error","suites":["ScopeAnalyzer","analyze","Variant #3: acquire scope without analyzing"],"updatePoint":{"line":103,"column":34},"line":103,"code":"            it('should throw error', () => {\n                assert.throws(testFunc, expectedError);\n            });","file":"unit-tests/analyzers/scope-analyzer/ScopeAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should throw error","suites":["ScopeAnalyzer","analyze","Variant #4: analyzing error"],"updatePoint":{"line":128,"column":34},"line":128,"code":"            it('should throw error', () => {\n                assert.throws(testFunc, expectedError);\n            });","file":"unit-tests/analyzers/scope-analyzer/ScopeAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should does not throw error","suites":["ScopeAnalyzer","analyze","Variant #5: cannot read property `0` of undefined error"],"updatePoint":{"line":172,"column":43},"line":172,"code":"            it('should does not throw error', () => {\n                assert.doesNotThrow(testFunc, expectedError);\n            });","file":"unit-tests/analyzers/scope-analyzer/ScopeAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: should return correct string array storage item data for literal node #1","suites":["StringArrayStorageAnalyzer","analyze","Base analyze of the AST tree"],"updatePoint":{"line":74,"column":100},"line":74,"code":"            it('Variant #1: should return correct string array storage item data for literal node #1', () => {\n                assert.deepEqual(stringArrayStorageItemData1, expectedStringArrayStorageItemData1);\n            });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #2: should return correct string array storage item data for literal node #2","suites":["StringArrayStorageAnalyzer","analyze","Base analyze of the AST tree"],"updatePoint":{"line":78,"column":100},"line":78,"code":"            it('Variant #2: should return correct string array storage item data for literal node #2', () => {\n                assert.deepEqual(stringArrayStorageItemData2, expectedStringArrayStorageItemData2);\n            });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #3: should return correct string array storage item data for literal node #3","suites":["StringArrayStorageAnalyzer","analyze","Base analyze of the AST tree"],"updatePoint":{"line":82,"column":100},"line":82,"code":"            it('Variant #3: should return correct string array storage item data for literal node #3', () => {\n                assert.deepEqual(stringArrayStorageItemData3, expectedStringArrayStorageItemData3);\n            });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: should return correct string array storage item data for literal node #1","suites":["StringArrayStorageAnalyzer","analyze","Base analyze of the AST tree with string literal nodes with values shorter than allowed length"],"updatePoint":{"line":119,"column":100},"line":119,"code":"            it('Variant #1: should return correct string array storage item data for literal node #1', () => {\n                assert.deepEqual(stringArrayStorageItemData1, expectedStringArrayStorageItemData1);\n            });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #2: should return correct string array storage item data for literal node #2","suites":["StringArrayStorageAnalyzer","analyze","Base analyze of the AST tree with string literal nodes with values shorter than allowed length"],"updatePoint":{"line":123,"column":100},"line":123,"code":"            it('Variant #2: should return correct string array storage item data for literal node #2', () => {\n                assert.deepEqual(stringArrayStorageItemData2, expectedStringArrayStorageItemData2);\n            });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: should return correct string array storage item data for literal node #1","suites":["StringArrayStorageAnalyzer","analyze","Base analyze of the AST tree with number literal nodes"],"updatePoint":{"line":160,"column":100},"line":160,"code":"            it('Variant #1: should return correct string array storage item data for literal node #1', () => {\n                assert.deepEqual(stringArrayStorageItemData1, expectedStringArrayStorageItemData1);\n            });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #2: should return correct string array storage item data for literal node #2","suites":["StringArrayStorageAnalyzer","analyze","Base analyze of the AST tree with number literal nodes"],"updatePoint":{"line":164,"column":100},"line":164,"code":"            it('Variant #2: should return correct string array storage item data for literal node #2', () => {\n                assert.deepEqual(stringArrayStorageItemData2, expectedStringArrayStorageItemData2);\n            });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: should return correct string array storage item data for literal node #1","suites":["StringArrayStorageAnalyzer","analyze","Analyzes of the AST tree with prohibited string literal nodes"],"updatePoint":{"line":211,"column":100},"line":211,"code":"            it('Variant #1: should return correct string array storage item data for literal node #1', () => {\n                assert.deepEqual(stringArrayStorageItemData1, expectedStringArrayStorageItemData1);\n            });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #2: should return correct string array storage item data for literal node #2","suites":["StringArrayStorageAnalyzer","analyze","Analyzes of the AST tree with prohibited string literal nodes"],"updatePoint":{"line":215,"column":100},"line":215,"code":"            it('Variant #2: should return correct string array storage item data for literal node #2', () => {\n                assert.deepEqual(stringArrayStorageItemData2, expectedStringArrayStorageItemData2);\n            });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: should return correct string array storage item data for literal node #1","suites":["StringArrayStorageAnalyzer","analyze","Analyzes of the AST tree with ignored string literal nodes"],"updatePoint":{"line":253,"column":100},"line":253,"code":"            it('Variant #1: should return correct string array storage item data for literal node #1', () => {\n                assert.deepEqual(stringArrayStorageItemData1, expectedStringArrayStorageItemData1);\n            });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #2: should return correct string array storage item data for literal node #2","suites":["StringArrayStorageAnalyzer","analyze","Analyzes of the AST tree with ignored string literal nodes"],"updatePoint":{"line":257,"column":100},"line":257,"code":"            it('Variant #2: should return correct string array storage item data for literal node #2', () => {\n                assert.deepEqual(stringArrayStorageItemData2, expectedStringArrayStorageItemData2);\n            });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: should return correct string array storage item data for literal node #1","suites":["StringArrayStorageAnalyzer","analyze","Analyzes of the AST tree with force transform string literal nodes","Variant #1: Force obfuscate string when threshold is `0`"],"updatePoint":{"line":296,"column":104},"line":296,"code":"                it('Variant #1: should return correct string array storage item data for literal node #1', () => {\n                    assert.deepEqual(stringArrayStorageItemData1, expectedStringArrayStorageItemData1);\n                });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #2: should return correct string array storage item data for literal node #2","suites":["StringArrayStorageAnalyzer","analyze","Analyzes of the AST tree with force transform string literal nodes","Variant #1: Force obfuscate string when threshold is `0`"],"updatePoint":{"line":300,"column":104},"line":300,"code":"                it('Variant #2: should return correct string array storage item data for literal node #2', () => {\n                    assert.deepEqual(stringArrayStorageItemData2, expectedStringArrayStorageItemData2);\n                });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: should return correct string array storage item data for literal node #1","suites":["StringArrayStorageAnalyzer","analyze","Analyzes of the AST tree with force transform string literal nodes","Variant #2: Force obfuscate string when string value shorter than allowed length"],"updatePoint":{"line":338,"column":104},"line":338,"code":"                it('Variant #1: should return correct string array storage item data for literal node #1', () => {\n                    assert.deepEqual(stringArrayStorageItemData1, expectedStringArrayStorageItemData1);\n                });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #2: should return correct string array storage item data for literal node #2","suites":["StringArrayStorageAnalyzer","analyze","Analyzes of the AST tree with force transform string literal nodes","Variant #2: Force obfuscate string when string value shorter than allowed length"],"updatePoint":{"line":342,"column":104},"line":342,"code":"                it('Variant #2: should return correct string array storage item data for literal node #2', () => {\n                    assert.deepEqual(stringArrayStorageItemData2, expectedStringArrayStorageItemData2);\n                });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: should return correct string array storage item data for literal node #1","suites":["StringArrayStorageAnalyzer","analyze","Analyzes of the AST tree with disabled string array"],"updatePoint":{"line":381,"column":100},"line":381,"code":"            it('Variant #1: should return correct string array storage item data for literal node #1', () => {\n                assert.deepEqual(stringArrayStorageItemData1, expectedStringArrayStorageItemData1);\n            });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #2: should return correct string array storage item data for literal node #2","suites":["StringArrayStorageAnalyzer","analyze","Analyzes of the AST tree with disabled string array"],"updatePoint":{"line":385,"column":100},"line":385,"code":"            it('Variant #2: should return correct string array storage item data for literal node #2', () => {\n                assert.deepEqual(stringArrayStorageItemData2, expectedStringArrayStorageItemData2);\n            });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: should return empty string array storage item data for literal nodes","suites":["StringArrayStorageAnalyzer","analyze","Analyzes of the AST tree with string array threshold","Threshold value: 0"],"updatePoint":{"line":427,"column":100},"line":427,"code":"                it('Variant #1: should return empty string array storage item data for literal nodes', () => {\n                    assert.equal(isStringArrayStorageItemDataEmpty, true);\n                });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #1: should return correct string array storage item data for literal node #1","suites":["StringArrayStorageAnalyzer","analyze","Analyzes of the AST tree with string array threshold","Threshold value: 0.5"],"updatePoint":{"line":465,"column":104},"line":465,"code":"                it('Variant #1: should return correct string array storage item data for literal node #1', () => {\n                    assert.deepEqual(stringArrayStorageItemData1, expectedStringArrayStorageItemData1);\n                });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"Variant #2: should return correct string array storage item data for literal node #2","suites":["StringArrayStorageAnalyzer","analyze","Analyzes of the AST tree with string array threshold","Threshold value: 0.5"],"updatePoint":{"line":469,"column":104},"line":469,"code":"                it('Variant #2: should return correct string array storage item data for literal node #2', () => {\n                    assert.deepEqual(stringArrayStorageItemData2, expectedStringArrayStorageItemData2);\n                });","file":"unit-tests/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.spec.ts","skipped":false,"dir":"test"},{"name":"should sanitize value","suites":["ArraySanitizer","Variant #1: input value `foo`"],"updatePoint":{"line":16,"column":33},"line":16,"code":"        it('should sanitize value', () => {\n            assert.deepEqual(value, expectedValue);\n        });","file":"unit-tests/cli/sanitizers/ArraySanitizer.spec.ts","skipped":false,"dir":"test"},{"name":"should sanitize value","suites":["ArraySanitizer","Variant #2: input value `foo, bar`"],"updatePoint":{"line":31,"column":33},"line":31,"code":"        it('should sanitize value', () => {\n            assert.deepEqual(value, expectedValue);\n        });","file":"unit-tests/cli/sanitizers/ArraySanitizer.spec.ts","skipped":false,"dir":"test"},{"name":"should sanitize value","suites":["ArraySanitizer","Variant #3: input value `foo,`"],"updatePoint":{"line":43,"column":33},"line":43,"code":"        it('should sanitize value', () => {\n            assert.throw(testFunc, SyntaxError);\n        });","file":"unit-tests/cli/sanitizers/ArraySanitizer.spec.ts","skipped":false,"dir":"test"},{"name":"should sanitize value","suites":["BooleanSanitizer","Variant #1: input value `true`"],"updatePoint":{"line":17,"column":33},"line":17,"code":"        it('should sanitize value', () => {\n            assert.equal(value, expectedValue);\n        });","file":"unit-tests/cli/sanitizers/BooleanSanitizer.spec.ts","skipped":false,"dir":"test"},{"name":"should sanitize value","suites":["BooleanSanitizer","Variant #2: input value `1`"],"updatePoint":{"line":32,"column":33},"line":32,"code":"        it('should sanitize value', () => {\n            assert.equal(value, expectedValue);\n        });","file":"unit-tests/cli/sanitizers/BooleanSanitizer.spec.ts","skipped":false,"dir":"test"},{"name":"should sanitize value","suites":["BooleanSanitizer","Variant #3: input value `false`"],"updatePoint":{"line":47,"column":33},"line":47,"code":"        it('should sanitize value', () => {\n            assert.equal(value, expectedValue);\n        });","file":"unit-tests/cli/sanitizers/BooleanSanitizer.spec.ts","skipped":false,"dir":"test"},{"name":"should sanitize value","suites":["BooleanSanitizer","Variant #4: input value `foo`"],"updatePoint":{"line":62,"column":33},"line":62,"code":"        it('should sanitize value', () => {\n            assert.equal(value, expectedValue);\n        });","file":"unit-tests/cli/sanitizers/BooleanSanitizer.spec.ts","skipped":false,"dir":"test"},{"name":"should return object with user configuration","suites":["CLIUtils","getUserConfig","Variant #1: valid config file path","Variant #1: js file with config"],"updatePoint":{"line":29,"column":64},"line":29,"code":"                it('should return object with user configuration', () => {\n                    assert.deepEqual(result, expectedResult);\n                });","file":"unit-tests/cli/utils/CLIUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return object with user configuration","suites":["CLIUtils","getUserConfig","Variant #1: valid config file path","Variant #2: cjs file with config"],"updatePoint":{"line":51,"column":64},"line":51,"code":"                it('should return object with user configuration', () => {\n                    assert.deepEqual(result, expectedResult);\n                });","file":"unit-tests/cli/utils/CLIUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return object with user configuration","suites":["CLIUtils","getUserConfig","Variant #1: valid config file path","Variant #3: json file with config"],"updatePoint":{"line":72,"column":64},"line":72,"code":"                it('should return object with user configuration', () => {\n                    assert.deepEqual(result, expectedResult);\n                });","file":"unit-tests/cli/utils/CLIUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if `configFilePath` is not a valid path","suites":["CLIUtils","getUserConfig","Variant #2: invalid config file extension"],"updatePoint":{"line":89,"column":77},"line":89,"code":"            it('should throw an error if `configFilePath` is not a valid path', () => {\n                assert.throws(testFunc, /Given config path must be a valid/);\n            });","file":"unit-tests/cli/utils/CLIUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if `configFilePath` is not a valid path","suites":["CLIUtils","getUserConfig","Variant #3: invalid config file path"],"updatePoint":{"line":105,"column":77},"line":105,"code":"            it('should throw an error if `configFilePath` is not a valid path', () => {\n                assert.throws(testFunc, /Cannot open config file/);\n            });","file":"unit-tests/cli/utils/CLIUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return option available values as string","suites":["CLIUtils","stringifyOptionAvailableValues","Variant #1: should stringify option available values"],"updatePoint":{"line":121,"column":63},"line":121,"code":"            it('should return option available values as string', () => {\n                assert.deepEqual(result, expectedResult);\n            });","file":"unit-tests/cli/utils/CLIUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return valid identifier names cache","suites":["IdentifierNamesCacheFileUtils","readFile","Variant #1: input path is a file path","Variant #1: `identifierNamesCachePath` is a valid cache path","Variant #1: valid `json` as identifier names cache file content"],"updatePoint":{"line":44,"column":66},"line":44,"code":"                    it('should return valid identifier names cache', () => {\n                        assert.deepEqual(identifierNamesCache, expectedIdentifierNamesCache);\n                    });","file":"unit-tests/cli/utils/IdentifierNamesCacheFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error","suites":["IdentifierNamesCacheFileUtils","readFile","Variant #1: input path is a file path","Variant #1: `identifierNamesCachePath` is a valid cache path","Variant #2: invalid `json` as identifier names cache file content"],"updatePoint":{"line":65,"column":45},"line":65,"code":"                    it('should throw an error', () => {\n                        assert.throws(testFunc, expectedFileContentError);\n                    });","file":"unit-tests/cli/utils/IdentifierNamesCacheFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error","suites":["IdentifierNamesCacheFileUtils","readFile","Variant #1: input path is a file path","Variant #1: `identifierNamesCachePath` is a valid cache path","Variant #3: some string as identifier names cache file content"],"updatePoint":{"line":86,"column":45},"line":86,"code":"                    it('should throw an error', () => {\n                        assert.throws(testFunc, expectedFileContentError);\n                    });","file":"unit-tests/cli/utils/IdentifierNamesCacheFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if `identifierNamesCachePath` is not a valid path","suites":["IdentifierNamesCacheFileUtils","readFile","Variant #1: input path is a file path","Variant #2: `identifierNamesCachePath` is a valid path with invalid extension"],"updatePoint":{"line":107,"column":91},"line":107,"code":"                it('should throw an error if `identifierNamesCachePath` is not a valid path', () => {\n                    assert.throws(testFunc, expectedFilePathError);\n                });","file":"unit-tests/cli/utils/IdentifierNamesCacheFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if `identifierNamesCachePath` is not a valid path","suites":["IdentifierNamesCacheFileUtils","readFile","Variant #1: input path is a file path","Variant #3: `identifierNamesCachePath` is not a valid cache path"],"updatePoint":{"line":126,"column":91},"line":126,"code":"                it('should throw an error if `identifierNamesCachePath` is not a valid path', () => {\n                    assert.throws(testFunc, expectedFilePathError);\n                });","file":"unit-tests/cli/utils/IdentifierNamesCacheFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if `identifierNamesCachePath` is a directory path","suites":["IdentifierNamesCacheFileUtils","readFile","Variant #2: input path is a directory path","Variant #1: `inputPath` is a valid path"],"updatePoint":{"line":140,"column":91},"line":140,"code":"                it('should throw an error if `identifierNamesCachePath` is a directory path', () => {\n                    assert.throws(testFunc, expectedFilePathError);\n                });","file":"unit-tests/cli/utils/IdentifierNamesCacheFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly write updated identifier names to the cache file","suites":["IdentifierNamesCacheFileUtils","writeFile","Variant #1: Should write identifier names cache back to the file","Variant #1: identifier names cache file does not exist"],"updatePoint":{"line":168,"column":85},"line":168,"code":"                it('should correctly write updated identifier names to the cache file', () => {\n                    assert.deepEqual(updatedIdentifierNamesCache, expectedUpdatedIdentifierNamesCache);\n                });","file":"unit-tests/cli/utils/IdentifierNamesCacheFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly write updated identifier names to the cache file","suites":["IdentifierNamesCacheFileUtils","writeFile","Variant #1: Should write identifier names cache back to the file","Variant #2 identifier names cache file is exist"],"updatePoint":{"line":197,"column":85},"line":197,"code":"                it('should correctly write updated identifier names to the cache file', () => {\n                    assert.deepEqual(updatedIdentifierNamesCache, expectedUpdatedIdentifierNamesCache);\n                });","file":"unit-tests/cli/utils/IdentifierNamesCacheFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path that equals to passed output file path","suites":["obfuscatedCodeFileUtils","getOutputCodePath","Variant #1: raw input path is a file path, raw output path is a file path"],"updatePoint":{"line":39,"column":80},"line":39,"code":"            it('should return output path that equals to passed output file path', () => {\n                assert.equal(outputCodePath, expectedOutputCodePath);\n            });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path that equals to passed output directory with file name from actual file path","suites":["obfuscatedCodeFileUtils","getOutputCodePath","Variant #2: raw input path is a file path, raw output path is a directory path"],"updatePoint":{"line":62,"column":117},"line":62,"code":"            it('should return output path that equals to passed output directory with file name from actual file path', () => {\n                assert.equal(outputCodePath, expectedOutputCodePath);\n            });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if output path is a file path","suites":["obfuscatedCodeFileUtils","getOutputCodePath","Variant #3: raw input path is a directory path, raw output path is a file path"],"updatePoint":{"line":84,"column":67},"line":84,"code":"            it('should throw an error if output path is a file path', () => {\n                assert.throws(testFunc, Error);\n            });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path that contains raw output path and actual file input path","suites":["obfuscatedCodeFileUtils","getOutputCodePath","Variant #4: raw input path is a directory path, raw output path is a directory path","Variant #1: base directory name"],"updatePoint":{"line":112,"column":102},"line":112,"code":"                it('should return output path that contains raw output path and actual file input path', () => {\n                    assert.equal(outputCodePath, expectedOutputCodePath);\n                });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path that contains raw output path and actual file input path","suites":["obfuscatedCodeFileUtils","getOutputCodePath","Variant #4: raw input path is a directory path, raw output path is a directory path","Variant #2: base directory name with leading dot in output path"],"updatePoint":{"line":139,"column":102},"line":139,"code":"                it('should return output path that contains raw output path and actual file input path', () => {\n                    assert.equal(outputCodePath, expectedOutputCodePath);\n                });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path that contains raw output path and actual file input path","suites":["obfuscatedCodeFileUtils","getOutputCodePath","Variant #4: raw input path is a directory path, raw output path is a directory path","Variant #3: base nested directory name"],"updatePoint":{"line":167,"column":102},"line":167,"code":"                it('should return output path that contains raw output path and actual file input path', () => {\n                    assert.equal(outputCodePath, expectedOutputCodePath);\n                });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path that contains raw output path and actual file input path","suites":["obfuscatedCodeFileUtils","getOutputCodePath","Variant #4: raw input path is a directory path, raw output path is a directory path","Variant #4: directory name with dot"],"updatePoint":{"line":196,"column":102},"line":196,"code":"                it('should return output path that contains raw output path and actual file input path', () => {\n                    assert.equal(outputCodePath, expectedOutputCodePath);\n                });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path that contains raw output path and actual file input path","suites":["obfuscatedCodeFileUtils","getOutputCodePath","Variant #4: raw input path is a directory path, raw output path is a directory path","Variant #5: input directory name with dot only"],"updatePoint":{"line":223,"column":102},"line":223,"code":"                it('should return output path that contains raw output path and actual file input path', () => {\n                    assert.equal(outputCodePath, expectedOutputCodePath);\n                });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path that contains raw output path and actual file input path","suites":["obfuscatedCodeFileUtils","getOutputCodePath","Variant #4: raw input path is a directory path, raw output path is a directory path","Variant #6: input directory name with dot and slash only"],"updatePoint":{"line":250,"column":102},"line":250,"code":"                it('should return output path that contains raw output path and actual file input path', () => {\n                    assert.equal(outputCodePath, expectedOutputCodePath);\n                });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path that contains raw output path and actual file input path","suites":["obfuscatedCodeFileUtils","getOutputCodePath","Variant #5: Win32 environment","Variant #1: raw input absolute path is a directory path, raw output absolute path is a directory path","Variant #1: base directory name"],"updatePoint":{"line":292,"column":106},"line":292,"code":"                    it('should return output path that contains raw output path and actual file input path', () => {\n                        assert.equal(outputCodePath, expectedOutputCodePath);\n                    });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path for source map","suites":["obfuscatedCodeFileUtils","getOutputSourceMapPath","Variant #1: output code path is a file path","Variant #1: file path with directory","Variant #1: source map file name is not set","Variant #1: base output code path"],"updatePoint":{"line":330,"column":68},"line":330,"code":"                        it('should return output path for source map', () => {\n                            assert.equal(outputSourceMapPath, expectedOutputSourceMapPath);\n                        });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path for source map","suites":["obfuscatedCodeFileUtils","getOutputSourceMapPath","Variant #1: output code path is a file path","Variant #1: file path with directory","Variant #1: source map file name is not set","Variant #2: output code path with dot"],"updatePoint":{"line":353,"column":68},"line":353,"code":"                        it('should return output path for source map', () => {\n                            assert.equal(outputSourceMapPath, expectedOutputSourceMapPath);\n                        });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path for source map","suites":["obfuscatedCodeFileUtils","getOutputSourceMapPath","Variant #1: output code path is a file path","Variant #1: file path with directory","Variant #2: source map file name is set","Variant #1: source map file name without extension is set"],"updatePoint":{"line":379,"column":68},"line":379,"code":"                        it('should return output path for source map', () => {\n                            assert.equal(outputSourceMapPath, expectedOutputSourceMapPath);\n                        });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path for source map","suites":["obfuscatedCodeFileUtils","getOutputSourceMapPath","Variant #1: output code path is a file path","Variant #1: file path with directory","Variant #2: source map file name is set","Variant #2: source map file name with wrong extension is set"],"updatePoint":{"line":403,"column":68},"line":403,"code":"                        it('should return output path for source map', () => {\n                            assert.equal(outputSourceMapPath, expectedOutputSourceMapPath);\n                        });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path for source map","suites":["obfuscatedCodeFileUtils","getOutputSourceMapPath","Variant #1: output code path is a file path","Variant #1: file path with directory","Variant #2: source map file name is set","Variant #3: source map file name with valid extension is set"],"updatePoint":{"line":427,"column":68},"line":427,"code":"                        it('should return output path for source map', () => {\n                            assert.equal(outputSourceMapPath, expectedOutputSourceMapPath);\n                        });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path for source map","suites":["obfuscatedCodeFileUtils","getOutputSourceMapPath","Variant #1: output code path is a file path","Variant #1: file path with directory","Variant #2: source map file name is set","Variant #4: source map file name contains directories"],"updatePoint":{"line":451,"column":68},"line":451,"code":"                        it('should return output path for source map', () => {\n                            assert.equal(outputSourceMapPath, expectedOutputSourceMapPath);\n                        });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path for source map","suites":["obfuscatedCodeFileUtils","getOutputSourceMapPath","Variant #1: output code path is a file path","Variant #1: file path with directory","Variant #2: source map file name is set","Variant #5: output code path with dot"],"updatePoint":{"line":475,"column":68},"line":475,"code":"                        it('should return output path for source map', () => {\n                            assert.equal(outputSourceMapPath, expectedOutputSourceMapPath);\n                        });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path for source map","suites":["obfuscatedCodeFileUtils","getOutputSourceMapPath","Variant #1: output code path is a file path","Variant #2: file path without directory","Variant #1: source map file name is not set","Variant #1: base output code path"],"updatePoint":{"line":502,"column":68},"line":502,"code":"                        it('should return output path for source map', () => {\n                            assert.equal(outputSourceMapPath, expectedOutputSourceMapPath);\n                        });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path for source map","suites":["obfuscatedCodeFileUtils","getOutputSourceMapPath","Variant #1: output code path is a file path","Variant #2: file path without directory","Variant #2: source map file name is set","Variant #1: base output code path"],"updatePoint":{"line":531,"column":68},"line":531,"code":"                        it('should return output path for source map', () => {\n                            assert.equal(outputSourceMapPath, expectedOutputSourceMapPath);\n                        });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path for source map","suites":["obfuscatedCodeFileUtils","getOutputSourceMapPath","Variant #1: output code path is a file path","Variant #10: Win32 environment","Variant #1: source map file name is a file name without extension"],"updatePoint":{"line":558,"column":64},"line":558,"code":"                    it('should return output path for source map', () => {\n                        assert.equal(outputSourceMapPath, expectedOutputSourceMapPath);\n                    });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path for source map","suites":["obfuscatedCodeFileUtils","getOutputSourceMapPath","Variant #1: output code path is a file path","Variant #10: Win32 environment","Variant #2: source map file name is a file name with an extension"],"updatePoint":{"line":582,"column":64},"line":582,"code":"                    it('should return output path for source map', () => {\n                        assert.equal(outputSourceMapPath, expectedOutputSourceMapPath);\n                    });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path for source map","suites":["obfuscatedCodeFileUtils","getOutputSourceMapPath","Variant #1: output code path is a file path","Variant #10: Win32 environment","Variant #3: output path and win32 path in source map file name"],"updatePoint":{"line":606,"column":64},"line":606,"code":"                    it('should return output path for source map', () => {\n                        assert.equal(outputSourceMapPath, expectedOutputSourceMapPath);\n                    });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if output code path is a directory path and source map file name is not set","suites":["obfuscatedCodeFileUtils","getOutputSourceMapPath","Variant #2: output code path is a directory path","Variant #1: source map file name is not set"],"updatePoint":{"line":631,"column":117},"line":631,"code":"                it('should throw an error if output code path is a directory path and source map file name is not set', () => {\n                    assert.throws(testFunc, Error);\n                });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path for source map","suites":["obfuscatedCodeFileUtils","getOutputSourceMapPath","Variant #2: output code path is a directory path","Variant #2: source map file name without extension is set"],"updatePoint":{"line":655,"column":60},"line":655,"code":"                it('should return output path for source map', () => {\n                    assert.equal(outputSourceMapPath, expectedOutputSourceMapPath);\n                });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path for source map","suites":["obfuscatedCodeFileUtils","getOutputSourceMapPath","Variant #2: output code path is a directory path","Variant #2: source map file name with extension is set"],"updatePoint":{"line":679,"column":60},"line":679,"code":"                it('should return output path for source map', () => {\n                    assert.equal(outputSourceMapPath, expectedOutputSourceMapPath);\n                });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return output path for source map","suites":["obfuscatedCodeFileUtils","getOutputSourceMapPath","Variant #2: output code path is a directory path","Variant #3: Win32 environment"],"updatePoint":{"line":703,"column":60},"line":703,"code":"                it('should return output path for source map', () => {\n                    assert.equal(outputSourceMapPath, expectedOutputSourceMapPath);\n                });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if output code path is empty","suites":["obfuscatedCodeFileUtils","getOutputSourceMapPath","Variant #3: empty paths"],"updatePoint":{"line":725,"column":66},"line":725,"code":"            it('should throw an error if output code path is empty', () => {\n                assert.throws(testFunc, Error);\n            });","file":"unit-tests/cli/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return valid files data","suites":["SourceCodeFileUtils","readSourceCode","Variant #1: input path is a file path","Variant #1: `inputPath` is a valid path"],"updatePoint":{"line":38,"column":50},"line":38,"code":"                it('should return valid files data', () => {\n                    assert.deepEqual(filesData, expectedFilesData);\n                });","file":"unit-tests/cli/utils/SourceCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if `inputPath` is not a valid path","suites":["SourceCodeFileUtils","readSourceCode","Variant #1: input path is a file path","Variant #2: `inputPath` is not a valid path"],"updatePoint":{"line":57,"column":76},"line":57,"code":"                it('should throw an error if `inputPath` is not a valid path', () => {\n                    assert.throws(testFunc, expectedError);\n                });","file":"unit-tests/cli/utils/SourceCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if `inputPath` has invalid extension","suites":["SourceCodeFileUtils","readSourceCode","Variant #1: input path is a file path","Variant #3: `inputPath` has invalid extension"],"updatePoint":{"line":73,"column":78},"line":73,"code":"                it('should throw an error if `inputPath` has invalid extension', () => {\n                    assert.throws(testFunc, expectedError);\n                });","file":"unit-tests/cli/utils/SourceCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return valid files data","suites":["SourceCodeFileUtils","readSourceCode","Variant #1: input path is a file path","Variant #4: `exclude` option","Variant #1: `inputPath` isn't excluded path"],"updatePoint":{"line":103,"column":54},"line":103,"code":"                    it('should return valid files data', () => {\n                        assert.deepEqual(filesData, expectedFilesData);\n                    });","file":"unit-tests/cli/utils/SourceCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if `inputPath` is the excluded file path","suites":["SourceCodeFileUtils","readSourceCode","Variant #1: input path is a file path","Variant #4: `exclude` option","Variant #2: `inputPath` is excluded path","Variant #1: exclude by `glob` pattern"],"updatePoint":{"line":129,"column":90},"line":129,"code":"                        it('should throw an error if `inputPath` is the excluded file path', () => {\n                            assert.throws(testFunc, expectedError);\n                        });","file":"unit-tests/cli/utils/SourceCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if `inputPath` is the excluded file path","suites":["SourceCodeFileUtils","readSourceCode","Variant #1: input path is a file path","Variant #4: `exclude` option","Variant #2: `inputPath` is excluded path","Variant #2: exclude by file name"],"updatePoint":{"line":154,"column":90},"line":154,"code":"                        it('should throw an error if `inputPath` is the excluded file path', () => {\n                            assert.throws(testFunc, expectedError);\n                        });","file":"unit-tests/cli/utils/SourceCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if `inputPath` is the excluded file path","suites":["SourceCodeFileUtils","readSourceCode","Variant #1: input path is a file path","Variant #4: `exclude` option","Variant #2: `inputPath` is excluded path","Variant #3: exclude by file path"],"updatePoint":{"line":179,"column":90},"line":179,"code":"                        it('should throw an error if `inputPath` is the excluded file path', () => {\n                            assert.throws(testFunc, expectedError);\n                        });","file":"unit-tests/cli/utils/SourceCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return files data","suites":["SourceCodeFileUtils","readSourceCode","Variant #2: input path is a directory path","Variant #1: `inputPath` is a valid path"],"updatePoint":{"line":223,"column":44},"line":223,"code":"                it('should return files data', () => {\n                    assert.deepEqual(result, expectedResult);\n                });","file":"unit-tests/cli/utils/SourceCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if `inputPath` is not a valid path","suites":["SourceCodeFileUtils","readSourceCode","Variant #2: input path is a directory path","Variant #2: `inputPath` is not a valid path"],"updatePoint":{"line":244,"column":76},"line":244,"code":"                it('should throw an error if `inputPath` is not a valid path', () => {\n                    assert.throws(testFunc, expectedError);\n                });","file":"unit-tests/cli/utils/SourceCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return files data","suites":["SourceCodeFileUtils","readSourceCode","Variant #2: input path is a directory path","Variant #3: `inputPath` is a directory with sub-directories"],"updatePoint":{"line":294,"column":44},"line":294,"code":"                it('should return files data', () => {\n                    assert.deepEqual(result, expectedResult);\n                });","file":"unit-tests/cli/utils/SourceCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return files data","suites":["SourceCodeFileUtils","readSourceCode","Variant #2: input path is a directory path","Variant #4: `exclude` option","Variant #1: `inputPath` isn't excluded path"],"updatePoint":{"line":345,"column":48},"line":345,"code":"                    it('should return files data', () => {\n                        assert.deepEqual(result, expectedResult);\n                    });","file":"unit-tests/cli/utils/SourceCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return files data","suites":["SourceCodeFileUtils","readSourceCode","Variant #2: input path is a directory path","Variant #4: `exclude` option","Variant #2: `inputPath` is excluded path","Variant #1: exclude by `glob` pattern"],"updatePoint":{"line":397,"column":52},"line":397,"code":"                        it('should return files data', () => {\n                            assert.deepEqual(result, expectedResult);\n                        });","file":"unit-tests/cli/utils/SourceCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return files data","suites":["SourceCodeFileUtils","readSourceCode","Variant #2: input path is a directory path","Variant #4: `exclude` option","Variant #2: `inputPath` is excluded path","Variant #2: exclude by file name"],"updatePoint":{"line":448,"column":52},"line":448,"code":"                        it('should return files data', () => {\n                            assert.deepEqual(result, expectedResult);\n                        });","file":"unit-tests/cli/utils/SourceCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return files data","suites":["SourceCodeFileUtils","readSourceCode","Variant #2: input path is a directory path","Variant #4: `exclude` option","Variant #2: `inputPath` is excluded path","Variant #3: exclude by file path"],"updatePoint":{"line":499,"column":52},"line":499,"code":"                        it('should return files data', () => {\n                            assert.deepEqual(result, expectedResult);\n                        });","file":"unit-tests/cli/utils/SourceCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return files data","suites":["SourceCodeFileUtils","readSourceCode","Variant #2: input path is a directory path","Variant #4: `exclude` option","Variant #2: `inputPath` is excluded path","Variant #4: exclude whole directory"],"updatePoint":{"line":536,"column":52},"line":536,"code":"                        it('should return files data', () => {\n                            assert.throws(testFunc, expectedError);\n                        });","file":"unit-tests/cli/utils/SourceCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return files data","suites":["SourceCodeFileUtils","readSourceCode","Variant #2: input path is a directory path","Variant #5: `inputPath` is a valid path with dot"],"updatePoint":{"line":570,"column":44},"line":570,"code":"                it('should return files data', () => {\n                    assert.deepEqual(result, expectedResult);\n                });","file":"unit-tests/cli/utils/SourceCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't throws an errors if property was initialized","suites":["@initializable","Variant #1: property was initialized"],"updatePoint":{"line":27,"column":67},"line":27,"code":"        it('shouldn\\'t throws an errors if property was initialized', () => {\n            assert.doesNotThrow(testFunc, Error);\n        });","file":"unit-tests/decorators/initializable/Initializable.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't throw an error if `initialize` method was called first","suites":["@initializable","Variant #2: `initialize` method should be called first","Variant #1: `initialize` method was called first"],"updatePoint":{"line":52,"column":81},"line":52,"code":"            it('shouldn\\'t throw an error if `initialize` method was called first', () => {\n                assert.doesNotThrow(testFunc, /Class should be initialized/);\n            });","file":"unit-tests/decorators/initializable/Initializable.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't throw an error if other method was called inside `initialize` method","suites":["@initializable","Variant #2: `initialize` method should be called first","Variant #2: other method was called inside `initialize` method with initialization of the property"],"updatePoint":{"line":77,"column":95},"line":77,"code":"            it('shouldn\\'t throw an error if other method was called inside `initialize` method', () => {\n                assert.doesNotThrow(testFunc, /Class should be initialized/);\n            });","file":"unit-tests/decorators/initializable/Initializable.spec.ts","skipped":false,"dir":"test"},{"name":"should throws an error if other method was called inside `initialize` method without initialization of the property","suites":["@initializable","Variant #2: `initialize` method should be called first","Variant #3: other method was called inside `initialize` method without initialization of the property"],"updatePoint":{"line":101,"column":131},"line":101,"code":"            it('should throws an error if other method was called inside `initialize` method without initialization of the property', () => {\n                assert.throws(testFunc, /Property `property` is not initialized/);\n            });","file":"unit-tests/decorators/initializable/Initializable.spec.ts","skipped":false,"dir":"test"},{"name":"should throws an error if `initialize` method wasn't called first","suites":["@initializable","Variant #2: `initialize` method should be called first","Variant #4: `initialize` method wasn't called first"],"updatePoint":{"line":125,"column":82},"line":125,"code":"            it('should throws an error if `initialize` method wasn\\'t called first', () => {\n                assert.throws(testFunc, /Class should be initialized/);\n            });","file":"unit-tests/decorators/initializable/Initializable.spec.ts","skipped":false,"dir":"test"},{"name":"should throws an error if `initialize` method wasn't called first","suites":["@initializable","Variant #2: `initialize` method should be called first","Variant #5: `initialize` method wasn't called"],"updatePoint":{"line":148,"column":82},"line":148,"code":"            it('should throws an error if `initialize` method wasn\\'t called first', () => {\n                assert.throws(testFunc, /Class should be initialized/);\n            });","file":"unit-tests/decorators/initializable/Initializable.spec.ts","skipped":false,"dir":"test"},{"name":"should throws an error if property didn't initialized","suites":["@initializable","Variant #3: property didn't initialized"],"updatePoint":{"line":171,"column":66},"line":171,"code":"        it('should throws an error if property didn\\'t initialized', () => {\n            assert.throws(testFunc, /Property `property` is not initialized/);\n        });","file":"unit-tests/decorators/initializable/Initializable.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should return first identifier name","suites":["DictionaryIdentifierNamesGenerator","generateNext","Base behaviour","Variant #1: first dictionary iteration"],"updatePoint":{"line":39,"column":65},"line":39,"code":"                it('Match #1: should return first identifier name', () => {\n                    assert.match(dictionaryIdentifierName, expectedDictionaryIdentifierNameRegExp);\n                });","file":"unit-tests/generators/identifier-names-generators/DictionarylIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should return second identifier name","suites":["DictionaryIdentifierNamesGenerator","generateNext","Base behaviour","Variant #1: first dictionary iteration"],"updatePoint":{"line":43,"column":66},"line":43,"code":"                it('Match #2: should return second identifier name', () => {\n                    assert.match(dictionaryIdentifierName, expectedDictionaryIdentifierNameRegExp);\n                });","file":"unit-tests/generators/identifier-names-generators/DictionarylIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should return third identifier name","suites":["DictionaryIdentifierNamesGenerator","generateNext","Base behaviour","Variant #2: second dictionary iteration"],"updatePoint":{"line":55,"column":65},"line":55,"code":"                it('Match #1: should return third identifier name', () => {\n                    assert.match(dictionaryIdentifierName, expectedDictionaryIdentifierNameRegExp);\n                });","file":"unit-tests/generators/identifier-names-generators/DictionarylIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should return fourth identifier name","suites":["DictionaryIdentifierNamesGenerator","generateNext","Base behaviour","Variant #2: second dictionary iteration"],"updatePoint":{"line":59,"column":66},"line":59,"code":"                it('Match #2: should return fourth identifier name', () => {\n                    assert.match(dictionaryIdentifierName, expectedDictionaryIdentifierNameRegExp);\n                });","file":"unit-tests/generators/identifier-names-generators/DictionarylIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should return first identifier name","suites":["DictionaryIdentifierNamesGenerator","generateNext","Empty string as dictionary value","Variant #1: Should ignore empty strings from dictionary"],"updatePoint":{"line":85,"column":65},"line":85,"code":"                it('Match #1: should return first identifier name', () => {\n                    assert.match(dictionaryIdentifierName, expectedDictionaryIdentifierNameRegExp);\n                });","file":"unit-tests/generators/identifier-names-generators/DictionarylIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should return second identifier name","suites":["DictionaryIdentifierNamesGenerator","generateNext","Empty string as dictionary value","Variant #1: Should ignore empty strings from dictionary"],"updatePoint":{"line":89,"column":66},"line":89,"code":"                it('Match #2: should return second identifier name', () => {\n                    assert.match(dictionaryIdentifierName, expectedDictionaryIdentifierNameRegExp);\n                });","file":"unit-tests/generators/identifier-names-generators/DictionarylIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should return first identifier name","suites":["DictionaryIdentifierNamesGenerator","generateNext","Multi-character string as dictionary value","Variant #1: Should generate identifier names based on all variants of word from dictionary"],"updatePoint":{"line":118,"column":65},"line":118,"code":"                it('Match #1: should return first identifier name', () => {\n                    assert.equal(dictionaryIdentifierName, expectedFirstIterationIdentifierName);\n                });","file":"unit-tests/generators/identifier-names-generators/DictionarylIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should return second identifier name","suites":["DictionaryIdentifierNamesGenerator","generateNext","Multi-character string as dictionary value","Variant #1: Should generate identifier names based on all variants of word from dictionary"],"updatePoint":{"line":122,"column":66},"line":122,"code":"                it('Match #2: should return second identifier name', () => {\n                    assert.equal(dictionaryIdentifierName, expectedSecondIterationIdentifierName);\n                });","file":"unit-tests/generators/identifier-names-generators/DictionarylIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #3: should return third identifier name","suites":["DictionaryIdentifierNamesGenerator","generateNext","Multi-character string as dictionary value","Variant #1: Should generate identifier names based on all variants of word from dictionary"],"updatePoint":{"line":126,"column":65},"line":126,"code":"                it('Match #3: should return third identifier name', () => {\n                    assert.equal(dictionaryIdentifierName, expectedThirdIterationIdentifierName);\n                });","file":"unit-tests/generators/identifier-names-generators/DictionarylIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #4: should return fourth identifier name","suites":["DictionaryIdentifierNamesGenerator","generateNext","Multi-character string as dictionary value","Variant #1: Should generate identifier names based on all variants of word from dictionary"],"updatePoint":{"line":130,"column":66},"line":130,"code":"                it('Match #4: should return fourth identifier name', () => {\n                    assert.equal(dictionaryIdentifierName, expectedFourthIterationIdentifierName);\n                });","file":"unit-tests/generators/identifier-names-generators/DictionarylIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should return first identifier name","suites":["DictionaryIdentifierNamesGenerator","generateNext","Errors","Variant #1: No more identifier variants for generation"],"updatePoint":{"line":160,"column":65},"line":160,"code":"                it('Match #1: should return first identifier name', () => {\n                    dictionaryIdentifierName = testFunc();\n                    assert.match(dictionaryIdentifierName, expectedDictionaryIdentifierNameRegExp);\n                });","file":"unit-tests/generators/identifier-names-generators/DictionarylIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should return second identifier name","suites":["DictionaryIdentifierNamesGenerator","generateNext","Errors","Variant #1: No more identifier variants for generation"],"updatePoint":{"line":165,"column":66},"line":165,"code":"                it('Match #2: should return second identifier name', () => {\n                    dictionaryIdentifierName = testFunc();\n                    assert.match(dictionaryIdentifierName, expectedDictionaryIdentifierNameRegExp);\n                });","file":"unit-tests/generators/identifier-names-generators/DictionarylIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Should throw an error when all identifier variants are used","suites":["DictionaryIdentifierNamesGenerator","generateNext","Errors","Variant #1: No more identifier variants for generation"],"updatePoint":{"line":170,"column":79},"line":170,"code":"                it('Should throw an error when all identifier variants are used', () => {\n                    assert.throws(testFunc, Error);\n                });","file":"unit-tests/generators/identifier-names-generators/DictionarylIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Should throw an error when identifiers dictionary is empty","suites":["DictionaryIdentifierNamesGenerator","generateNext","Errors","Variant #2: Empty identifiers dictionary"],"updatePoint":{"line":190,"column":78},"line":190,"code":"                it('Should throw an error when identifiers dictionary is empty', () => {\n                    assert.throws(testFunc, Error);\n                });","file":"unit-tests/generators/identifier-names-generators/DictionarylIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #1: should return first identifier name","suites":["DictionaryIdentifierNamesGenerator","generateForGlobalScope","Variant #1: Should generate identifier names with prefix"],"updatePoint":{"line":218,"column":61},"line":218,"code":"            it('Match #1: should return first identifier name', () => {\n                assert.match(dictionaryIdentifierName, expectedDictionaryIdentifierNameRegExp);\n            });","file":"unit-tests/generators/identifier-names-generators/DictionarylIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"Match #2: should return second identifier name","suites":["DictionaryIdentifierNamesGenerator","generateForGlobalScope","Variant #1: Should generate identifier names with prefix"],"updatePoint":{"line":222,"column":62},"line":222,"code":"            it('Match #2: should return second identifier name', () => {\n                assert.match(dictionaryIdentifierName, expectedDictionaryIdentifierNameRegExp);\n            });","file":"unit-tests/generators/identifier-names-generators/DictionarylIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return different dictionary names for different labels","suites":["DictionaryIdentifierNamesGenerator","generateForLabel"],"updatePoint":{"line":258,"column":73},"line":258,"code":"        it('should return different dictionary names for different labels', () => {\n            assert.notDeepEqual(dictionaryNames1, dictionaryNames2);\n        });","file":"unit-tests/generators/identifier-names-generators/DictionarylIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return hexadecimal name","suites":["HexadecimalIdentifierNamesGenerator","generateNext","Base"],"updatePoint":{"line":34,"column":46},"line":34,"code":"            it('should return hexadecimal name', () => {\n                assert.match(hexadecimalIdentifierName, regExp);\n            })","file":"unit-tests/generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return hexadecimal name","suites":["HexadecimalIdentifierNamesGenerator","generateNext","Custom length"],"updatePoint":{"line":57,"column":46},"line":57,"code":"            it('should return hexadecimal name', () => {\n                assert.match(hexadecimalIdentifierName, regExp);\n            })","file":"unit-tests/generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return hexadecimal name with prefix","suites":["HexadecimalIdentifierNamesGenerator","generateForGlobalScope"],"updatePoint":{"line":83,"column":54},"line":83,"code":"        it('should return hexadecimal name with prefix', () => {\n            assert.match(hexadecimalIdentifierName, regExp);\n        })","file":"unit-tests/generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return valid hexadecimal name 1","suites":["HexadecimalIdentifierNamesGenerator","generateForLabel"],"updatePoint":{"line":117,"column":50},"line":117,"code":"        it('should return valid hexadecimal name 1', () => {\n            assert.match(hexadecimalIdentifierName1, regExp);\n        })","file":"unit-tests/generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return valid hexadecimal name 2","suites":["HexadecimalIdentifierNamesGenerator","generateForLabel"],"updatePoint":{"line":121,"column":50},"line":121,"code":"        it('should return valid hexadecimal name 2', () => {\n            assert.match(hexadecimalIdentifierName2, regExp);\n        })","file":"unit-tests/generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should generate different hexadecimal names for different labels","suites":["HexadecimalIdentifierNamesGenerator","generateForLabel"],"updatePoint":{"line":125,"column":76},"line":125,"code":"        it('should generate different hexadecimal names for different labels', () => {\n            assert.notEqual(hexadecimalIdentifierName1, hexadecimalIdentifierName2);\n        })","file":"unit-tests/generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return mangled name","suites":["MangledIdentifierNamesGenerator","generateNext","Variant #1: initial mangled name"],"updatePoint":{"line":37,"column":42},"line":37,"code":"            it('should return mangled name', () => {\n                assert.equal(mangledIdentifierName, expectedMangledIdentifierName);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return mangled name","suites":["MangledIdentifierNamesGenerator","generateNext","Variant #2: second mangled name"],"updatePoint":{"line":52,"column":42},"line":52,"code":"            it('should return mangled name', () => {\n                assert.equal(mangledIdentifierName, expectedMangledIdentifierName);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return mangled name","suites":["MangledIdentifierNamesGenerator","generateNext","Variant #3: last mangled name with single character"],"updatePoint":{"line":67,"column":42},"line":67,"code":"            it('should return mangled name', () => {\n                assert.equal(mangledIdentifierName, expectedMangledIdentifierName);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return mangled name","suites":["MangledIdentifierNamesGenerator","generateNext","Variant #4: correct increase of mangled name length"],"updatePoint":{"line":82,"column":42},"line":82,"code":"            it('should return mangled name', () => {\n                assert.equal(mangledIdentifierName, expectedMangledIdentifierName);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return mangled name","suites":["MangledIdentifierNamesGenerator","generateNext","Variant #5: correct increase of mangled name length #2"],"updatePoint":{"line":97,"column":42},"line":97,"code":"            it('should return mangled name', () => {\n                assert.equal(mangledIdentifierName, expectedMangledIdentifierName);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return mangled name","suites":["MangledIdentifierNamesGenerator","generateNext","Variant #6: reserved names"],"updatePoint":{"line":123,"column":42},"line":123,"code":"            it('should return mangled name', () => {\n                assert.equal(mangledIdentifierName1, expectedMangledIdentifierName1);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't return reserved mangled name","suites":["MangledIdentifierNamesGenerator","generateNext","Variant #6: reserved names"],"updatePoint":{"line":127,"column":55},"line":127,"code":"            it('shouldn\\'t return reserved mangled name', () => {\n                assert.equal(mangledIdentifierName2, expectedMangledIdentifierName2);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return mangled name with prefix","suites":["MangledIdentifierNamesGenerator","generateForGlobalScope","Variant #1: initial mangled name"],"updatePoint":{"line":156,"column":54},"line":156,"code":"            it('should return mangled name with prefix', () => {\n                assert.equal(mangledIdentifierName, expectedMangledIdentifierName);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return mangled name with prefix","suites":["MangledIdentifierNamesGenerator","generateForGlobalScope","Variant #2: second mangled name"],"updatePoint":{"line":168,"column":54},"line":168,"code":"            it('should return mangled name with prefix', () => {\n                assert.equal(mangledIdentifierName, expectedMangledIdentifierName);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return valid mangled names for label 1","suites":["MangledIdentifierNamesGenerator","generateForLabel"],"updatePoint":{"line":205,"column":57},"line":205,"code":"        it('should return valid mangled names for label 1', () => {\n            assert.deepEqual(mangledNames1, expectedMangledNames1);\n        })","file":"unit-tests/generators/identifier-names-generators/MangledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return valid mangled names for label 2","suites":["MangledIdentifierNamesGenerator","generateForLabel"],"updatePoint":{"line":209,"column":57},"line":209,"code":"        it('should return valid mangled names for label 2', () => {\n            assert.deepEqual(mangledNames2, expectedMangledNames2);\n        })","file":"unit-tests/generators/identifier-names-generators/MangledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly compare mangled names","suites":["MangledIdentifierNamesGenerator","isIncrementedMangledName"],"updatePoint":{"line":248,"column":50},"line":248,"code":"        it('should correctly compare mangled names', () => {\n            assert.isTrue(isSuccessComparison);\n        });","file":"unit-tests/generators/identifier-names-generators/MangledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should generate first identifier","suites":["MangledIdentifierNamesGenerator","isValidIdentifierName","Variant #1: reserved name as simple string"],"updatePoint":{"line":276,"column":48},"line":276,"code":"            it('should generate first identifier', () => {\n                assert.equal(firstMangledIdentifierName, expectedFirstIdentifier);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should generate second identifier","suites":["MangledIdentifierNamesGenerator","isValidIdentifierName","Variant #1: reserved name as simple string"],"updatePoint":{"line":280,"column":49},"line":280,"code":"            it('should generate second identifier', () => {\n                assert.equal(secondMangledIdentifierName, expectedSecondIdentifier);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should generate first identifier","suites":["MangledIdentifierNamesGenerator","isValidIdentifierName","Variant #2: reserved name as string regexp"],"updatePoint":{"line":307,"column":48},"line":307,"code":"            it('should generate first identifier', () => {\n                assert.equal(firstMangledIdentifierName, expectedFirstIdentifier);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should generate second identifier","suites":["MangledIdentifierNamesGenerator","isValidIdentifierName","Variant #2: reserved name as string regexp"],"updatePoint":{"line":311,"column":49},"line":311,"code":"            it('should generate second identifier', () => {\n                assert.equal(secondMangledIdentifierName, expectedSecondIdentifier);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should generate first identifier","suites":["MangledIdentifierNamesGenerator","isValidIdentifierName","Variant #3: reserved dom property name"],"updatePoint":{"line":336,"column":48},"line":336,"code":"            it('should generate first identifier', () => {\n                assert.isFalse(isValidName1);\n                assert.isFalse(isValidName2);\n                assert.isTrue(isValidName3);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return mangled name","suites":["MangledShuffledIdentifierNamesGenerator","generateNext","Variant #1: initial mangled name"],"updatePoint":{"line":37,"column":42},"line":37,"code":"            it('should return mangled name', () => {\n                assert.match(mangledIdentifierName, expectedMangledIdentifierNameRegExp);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledShuffledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return mangled name","suites":["MangledShuffledIdentifierNamesGenerator","generateNext","Variant #2: second mangled name"],"updatePoint":{"line":52,"column":42},"line":52,"code":"            it('should return mangled name', () => {\n                assert.match(mangledIdentifierName, expectedMangledIdentifierNameRegExp);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledShuffledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return mangled name","suites":["MangledShuffledIdentifierNamesGenerator","generateNext","Variant #3: correct increase of mangled name length"],"updatePoint":{"line":67,"column":42},"line":67,"code":"            it('should return mangled name', () => {\n                assert.match(mangledIdentifierName, expectedMangledIdentifierNameRegExp);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledShuffledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return mangled name","suites":["MangledShuffledIdentifierNamesGenerator","generateNext","Variant #4: correct increase of mangled name length #2"],"updatePoint":{"line":82,"column":42},"line":82,"code":"            it('should return mangled name', () => {\n                assert.match(mangledIdentifierName, expectedMangledIdentifierNameRegExp);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledShuffledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return mangled name with prefix","suites":["MangledShuffledIdentifierNamesGenerator","generateForGlobalScope","Variant #1: initial mangled name"],"updatePoint":{"line":111,"column":54},"line":111,"code":"            it('should return mangled name with prefix', () => {\n                assert.match(mangledIdentifierName, expectedMangledIdentifierNameRegExp);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledShuffledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return the same mangled names set for different labels","suites":["MangledShuffledIdentifierNamesGenerator","generateForLabel"],"updatePoint":{"line":146,"column":73},"line":146,"code":"        it('should return the same mangled names set for different labels', () => {\n            assert.deepEqual(mangledNames1, mangledNames2);\n        })","file":"unit-tests/generators/identifier-names-generators/MangledShuffledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should correctly compare mangled names","suites":["MangledShuffledIdentifierNamesGenerator","isIncrementedMangledName"],"updatePoint":{"line":185,"column":50},"line":185,"code":"        it('should correctly compare mangled names', () => {\n            assert.isTrue(isSuccessComparison);\n        });","file":"unit-tests/generators/identifier-names-generators/MangledShuffledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should generate first identifier","suites":["MangledShuffledIdentifierNamesGenerator","isValidIdentifierName","Variant #1: reserved dom property name"],"updatePoint":{"line":211,"column":48},"line":211,"code":"            it('should generate first identifier', () => {\n                assert.isFalse(isValidName1);\n                assert.isFalse(isValidName2);\n                assert.isTrue(isValidName3);\n            });","file":"unit-tests/generators/identifier-names-generators/MangledShuffledlIdentifierNamesGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should output code preview when AST parser throws a parse error","suites":["ASTParserFacade","parse","\\`Unexpected token\\` error code preview","Variant #1: 5 lines of code"],"updatePoint":{"line":24,"column":83},"line":24,"code":"                it('should output code preview when AST parser throws a parse error', () => {\n                    assert.throws(testFunc, /ERROR at line 3: Unexpected token \\(3:28\\)\\n.*\\.\\.\\.var baz = 3;,\\.\\.\\./);\n                });","file":"unit-tests/javascript-obfuscator/ASTParserFacade.spec.ts","skipped":false,"dir":"test"},{"name":"should output code preview when AST parser throws a parse error","suites":["ASTParserFacade","parse","\\`Unexpected token\\` error code preview","Variant #2: 15 lines of code"],"updatePoint":{"line":53,"column":83},"line":53,"code":"                it('should output code preview when AST parser throws a parse error', () => {\n                    assert.throws(testFunc, /ERROR at line 13: Unexpected token \\(13:28\\)\\n.*\\.\\.\\.var baz = 3;,\\.\\.\\./);\n                });","file":"unit-tests/javascript-obfuscator/ASTParserFacade.spec.ts","skipped":false,"dir":"test"},{"name":"should output code preview when AST parser throws a parse error","suites":["ASTParserFacade","parse","\\`Unexpected token\\` error code preview","Variant #3: code with functions"],"updatePoint":{"line":76,"column":83},"line":76,"code":"                it('should output code preview when AST parser throws a parse error', () => {\n                    assert.throws(testFunc, /ERROR at line 4: Unexpected token \\(4:28\\)\\n.*\\.\\.\\.functin baz \\(\\) {\\.\\.\\./);\n                });","file":"unit-tests/javascript-obfuscator/ASTParserFacade.spec.ts","skipped":false,"dir":"test"},{"name":"should link obfuscated code with source map","suites":["JavaScriptObfuscator","obfuscate","source map","Variant #1: default behaviour"],"updatePoint":{"line":49,"column":63},"line":49,"code":"                it('should link obfuscated code with source map', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"unit-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return valid source map with `mappings` property","suites":["JavaScriptObfuscator","obfuscate","source map","Variant #1: default behaviour"],"updatePoint":{"line":53,"column":75},"line":53,"code":"                it('should return valid source map with `mappings` property', () => {\n                    assert.isOk(sourceMapObject.mappings);\n                });","file":"unit-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should properly add base url to source map import inside obfuscated code","suites":["JavaScriptObfuscator","obfuscate","source map","Variant #2: `sourceMapBaseUrl` is set"],"updatePoint":{"line":88,"column":92},"line":88,"code":"                it('should properly add base url to source map import inside obfuscated code', () => {\n                    assert.match(obfuscatedCode, regExp);\n                });","file":"unit-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should return valid source map with `mappings` property","suites":["JavaScriptObfuscator","obfuscate","source map","Variant #2: `sourceMapBaseUrl` is set"],"updatePoint":{"line":92,"column":75},"line":92,"code":"                it('should return valid source map with `mappings` property', () => {\n                    assert.isOk(sourceMapObject.mappings);\n                });","file":"unit-tests/javascript-obfuscator/JavaScriptObfuscator.spec.ts","skipped":false,"dir":"test"},{"name":"should call `console.log`","suites":["Logger","log"],"updatePoint":{"line":36,"column":37},"line":36,"code":"        it('should call `console.log`', () => {\n            assert.equal(consoleLogCallResult, expectedConsoleLogCallResult);\n        });","file":"unit-tests/logger/Logger.spec.ts","skipped":false,"dir":"test"},{"name":"should log message to the console","suites":["Logger","log"],"updatePoint":{"line":40,"column":45},"line":40,"code":"        it('should log message to the console', () => {\n            assert.include(loggingMessageResult, loggingMessage);\n        });","file":"unit-tests/logger/Logger.spec.ts","skipped":false,"dir":"test"},{"name":"should call `console.log`","suites":["Logger","info","`log` option is enabled"],"updatePoint":{"line":74,"column":41},"line":74,"code":"            it('should call `console.log`', () => {\n                assert.equal(consoleLogCallResult, expectedConsoleLogCallResult);\n            });","file":"unit-tests/logger/Logger.spec.ts","skipped":false,"dir":"test"},{"name":"should log `info` message to the console","suites":["Logger","info","`log` option is enabled"],"updatePoint":{"line":78,"column":56},"line":78,"code":"            it('should log `info` message to the console', () => {\n                assert.include(loggingMessageResult, loggingMessage);\n            });","file":"unit-tests/logger/Logger.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't call `console.log`","suites":["Logger","info","`log` option is disabled"],"updatePoint":{"line":109,"column":45},"line":109,"code":"            it('shouldn\\'t call `console.log`', () => {\n                assert.equal(consoleLogCallResult, expectedConsoleLogCallResult);\n            });","file":"unit-tests/logger/Logger.spec.ts","skipped":false,"dir":"test"},{"name":"should call `console.log`","suites":["Logger","success","`log` option is enabled"],"updatePoint":{"line":145,"column":41},"line":145,"code":"            it('should call `console.log`', () => {\n                assert.equal(consoleLogCallResult, expectedConsoleLogCallResult);\n            });","file":"unit-tests/logger/Logger.spec.ts","skipped":false,"dir":"test"},{"name":"should log `success` message to the console","suites":["Logger","success","`log` option is enabled"],"updatePoint":{"line":149,"column":59},"line":149,"code":"            it('should log `success` message to the console', () => {\n                assert.include(loggingMessageResult, loggingMessage);\n            });","file":"unit-tests/logger/Logger.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't call `console.log`","suites":["Logger","success","`log` option is disabled"],"updatePoint":{"line":180,"column":45},"line":180,"code":"            it('shouldn\\'t call `console.log`', () => {\n                assert.equal(consoleLogCallResult, expectedConsoleLogCallResult);\n            });","file":"unit-tests/logger/Logger.spec.ts","skipped":false,"dir":"test"},{"name":"should call `console.log`","suites":["Logger","warn","`log` option is enabled"],"updatePoint":{"line":216,"column":41},"line":216,"code":"            it('should call `console.log`', () => {\n                assert.equal(consoleLogCallResult, expectedConsoleLogCallResult);\n            });","file":"unit-tests/logger/Logger.spec.ts","skipped":false,"dir":"test"},{"name":"should log `warn` message to the console","suites":["Logger","warn","`log` option is enabled"],"updatePoint":{"line":220,"column":56},"line":220,"code":"            it('should log `warn` message to the console', () => {\n                assert.include(loggingMessageResult, loggingMessage);\n            });","file":"unit-tests/logger/Logger.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't call `console.log`","suites":["Logger","warn","`log` option is disabled"],"updatePoint":{"line":251,"column":45},"line":251,"code":"            it('shouldn\\'t call `console.log`', () => {\n                assert.equal(consoleLogCallResult, expectedConsoleLogCallResult);\n            });","file":"unit-tests/logger/Logger.spec.ts","skipped":false,"dir":"test"},{"name":"should add `ignoredNode` property with `false` value to given node","suites":["ObfuscatingGuardsTransformer","transformNode","Variant #1: transform node"],"updatePoint":{"line":60,"column":82},"line":60,"code":"            it('should add `ignoredNode` property with `false` value to given node', () => {\n                assert.deepEqual(result, expectedResult);\n            });","file":"unit-tests/node-transformers/preparing-transformers/ObfuscatingGuardsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add `ignoredNode` property with `true` value to given node","suites":["ObfuscatingGuardsTransformer","transformNode","Variant #2: ignored node"],"updatePoint":{"line":89,"column":81},"line":89,"code":"            it('should add `ignoredNode` property with `true` value to given node', () => {\n                assert.deepEqual(result, expectedResult);\n            });","file":"unit-tests/node-transformers/preparing-transformers/ObfuscatingGuardsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add `forceTransformNode` property with `true` value to given node","suites":["ObfuscatingGuardsTransformer","transformNode","Variant #3: force transform node"],"updatePoint":{"line":114,"column":88},"line":114,"code":"            it('should add `forceTransformNode` property with `true` value to given node', () => {\n                assert.deepEqual(result, expectedResult);\n            });","file":"unit-tests/node-transformers/preparing-transformers/ObfuscatingGuardsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should add correct metadata to given node","suites":["ObfuscatingGuardsTransformer","transformNode","Variant #4: ignored node and force transform node"],"updatePoint":{"line":139,"column":57},"line":139,"code":"            it('should add correct metadata to given node', () => {\n                assert.deepEqual(result, expectedResult);\n            });","file":"unit-tests/node-transformers/preparing-transformers/ObfuscatingGuardsTransformer.spec.ts","skipped":false,"dir":"test"},{"name":"should append given node to a `BlockStatement` node body","suites":["NodeAppender","append"],"updatePoint":{"line":60,"column":68},"line":60,"code":"        it('should append given node to a `BlockStatement` node body', () => {\n            assert.deepEqual(astTree, expectedAstTree);\n        });","file":"unit-tests/node/node-appender/NodeAppender.spec.ts","skipped":false,"dir":"test"},{"name":"should append node into first and deepest function call in nested function calls","suites":["NodeAppender","appendToOptimalBlockScope","Variant #1: nested function calls"],"updatePoint":{"line":93,"column":96},"line":93,"code":"            it('should append node into first and deepest function call in nested function calls', () => {\n                assert.deepEqual(astTree, expectedAstTree);\n            });","file":"unit-tests/node/node-appender/NodeAppender.spec.ts","skipped":false,"dir":"test"},{"name":"should append node into first and deepest function call in nested function calls","suites":["NodeAppender","appendToOptimalBlockScope","Variant #2: nested function calls"],"updatePoint":{"line":108,"column":96},"line":108,"code":"            it('should append node into first and deepest function call in nested function calls', () => {\n                assert.deepEqual(astTree, expectedAstTree);\n            });","file":"unit-tests/node/node-appender/NodeAppender.spec.ts","skipped":false,"dir":"test"},{"name":"should append node into deepest function call by specified index in nested function calls","suites":["NodeAppender","appendToOptimalBlockScope","append by specific index","Variant #1: append by specific index in nested function calls"],"updatePoint":{"line":129,"column":109},"line":129,"code":"                it('should append node into deepest function call by specified index in nested function calls', () => {\n                    assert.deepEqual(astTree, expectedAstTree);\n                });","file":"unit-tests/node/node-appender/NodeAppender.spec.ts","skipped":false,"dir":"test"},{"name":"should append node into deepest function call by specified index in nested function calls","suites":["NodeAppender","appendToOptimalBlockScope","append by specific index","Variant #2: append by specific index in nested function calls"],"updatePoint":{"line":143,"column":109},"line":143,"code":"                it('should append node into deepest function call by specified index in nested function calls', () => {\n                    assert.deepEqual(astTree, expectedAstTree);\n                });","file":"unit-tests/node/node-appender/NodeAppender.spec.ts","skipped":false,"dir":"test"},{"name":"should append node into deepest function call by specified index in nested function calls","suites":["NodeAppender","appendToOptimalBlockScope","append by specific index","Variant #3: append by specific index in nested function calls"],"updatePoint":{"line":163,"column":109},"line":163,"code":"                it('should append node into deepest function call by specified index in nested function calls', () => {\n                    assert.deepEqual(astTree, expectedAstTree);\n                });","file":"unit-tests/node/node-appender/NodeAppender.spec.ts","skipped":false,"dir":"test"},{"name":"should insert given node in `BlockStatement` node body before target statement","suites":["NodeAppender","insertBefore"],"updatePoint":{"line":188,"column":90},"line":188,"code":"        it('should insert given node in `BlockStatement` node body before target statement', () => {\n            assert.deepEqual(astTree, expectedAstTree);\n        });","file":"unit-tests/node/node-appender/NodeAppender.spec.ts","skipped":false,"dir":"test"},{"name":"should insert given node in `BlockStatement` node body after target statement","suites":["NodeAppender","insertAfter"],"updatePoint":{"line":211,"column":89},"line":211,"code":"        it('should insert given node in `BlockStatement` node body after target statement', () => {\n            assert.deepEqual(astTree, expectedAstTree);\n        });","file":"unit-tests/node/node-appender/NodeAppender.spec.ts","skipped":false,"dir":"test"},{"name":"should insert given node in `BlockStatement` node body at index","suites":["NodeAppender","insertAtIndex"],"updatePoint":{"line":232,"column":75},"line":232,"code":"        it('should insert given node in `BlockStatement` node body at index', () => {\n            assert.deepEqual(astTree, expectedAstTree);\n        });","file":"unit-tests/node/node-appender/NodeAppender.spec.ts","skipped":false,"dir":"test"},{"name":"should prepend given node to a `BlockStatement` node body","suites":["NodeAppender","prepend"],"updatePoint":{"line":253,"column":69},"line":253,"code":"        it('should prepend given node to a `BlockStatement` node body', () => {\n            assert.deepEqual(astTree, expectedAstTree);\n        });","file":"unit-tests/node/node-appender/NodeAppender.spec.ts","skipped":false,"dir":"test"},{"name":"should remove given node from a `BlockStatement` node body","suites":["NodeAppender","remove","Variant #1: valid index"],"updatePoint":{"line":273,"column":74},"line":273,"code":"            it('should remove given node from a `BlockStatement` node body', () => {\n                assert.deepEqual(astTree, expectedAstTree);\n            });","file":"unit-tests/node/node-appender/NodeAppender.spec.ts","skipped":false,"dir":"test"},{"name":"should keep `BlockStatement` as is","suites":["NodeAppender","remove","Variant #2: invalid index"],"updatePoint":{"line":292,"column":50},"line":292,"code":"            it('should keep `BlockStatement` as is', () => {\n                assert.deepEqual(astTree, expectedAstTree);\n            });","file":"unit-tests/node/node-appender/NodeAppender.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `IfStatement` node has single statement `consequent`","suites":["NodeGuards","isIfStatementNodeWithSingleStatementBody","truthful checks","Variant #1: single statement `consequent`"],"updatePoint":{"line":27,"column":88},"line":27,"code":"                it('should check if `IfStatement` node has single statement `consequent`', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `IfStatement` node has single statement `alternate`","suites":["NodeGuards","isIfStatementNodeWithSingleStatementBody","truthful checks","Variant #2: single statement `alternate`"],"updatePoint":{"line":52,"column":87},"line":52,"code":"                it('should check if `IfStatement` node has single statement `alternate`', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `IfStatement` node has single statement `consequent` and `alternate`","suites":["NodeGuards","isIfStatementNodeWithSingleStatementBody","truthful checks","Variant #3: single statement `consequent` and `alternate`"],"updatePoint":{"line":75,"column":104},"line":75,"code":"                it('should check if `IfStatement` node has single statement `consequent` and `alternate`', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should return `false` for other node","suites":["NodeGuards","isIfStatementNodeWithSingleStatementBody","false checks","Variant #1: other node"],"updatePoint":{"line":92,"column":56},"line":92,"code":"                it('should return `false` for other node', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `IfStatement` node has multiple statements `consequent` and `alternate`","suites":["NodeGuards","isIfStatementNodeWithSingleStatementBody","false checks","Variant #2: multiple statements `consequent` and `alternate`"],"updatePoint":{"line":119,"column":107},"line":119,"code":"                it('should check if `IfStatement` node has multiple statements `consequent` and `alternate`', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if node has statements","suites":["NodeGuards","isNodeWithLexicalScopeStatements","truthful checks","Variant #1: block statement of function declaration"],"updatePoint":{"line":144,"column":55},"line":144,"code":"                it('should check if node has statements', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if node has statements","suites":["NodeGuards","isNodeWithLexicalScopeStatements","truthful checks","Variant #2: block statement of function expression"],"updatePoint":{"line":164,"column":55},"line":164,"code":"                it('should check if node has statements', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if node has statements","suites":["NodeGuards","isNodeWithLexicalScopeStatements","false checks","Variant #1: switch-case node"],"updatePoint":{"line":202,"column":55},"line":202,"code":"                it('should check if node has statements', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if node has statements","suites":["NodeGuards","isNodeWithLexicalScopeStatements","false checks","Variant #2: literal node"],"updatePoint":{"line":230,"column":55},"line":230,"code":"                it('should check if node has statements', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if node has statements","suites":["NodeGuards","isNodeWithLexicalScopeStatements","false checks","Variant #3: block statement of if statement"],"updatePoint":{"line":250,"column":55},"line":250,"code":"                it('should check if node has statements', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `IfStatement` node has single statement `consequent`","suites":["NodeGuards","isNodeWithSingleStatementBody","truthful checks","Variant #1: `IfStatement` node","Variant #1: single statement `consequent`"],"updatePoint":{"line":275,"column":92},"line":275,"code":"                    it('should check if `IfStatement` node has single statement `consequent`', () => {\n                        assert.equal(result, expectedResult);\n                    });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `IfStatement` node has single statement `alternate`","suites":["NodeGuards","isNodeWithSingleStatementBody","truthful checks","Variant #1: `IfStatement` node","Variant #2: single statement `alternate`"],"updatePoint":{"line":300,"column":91},"line":300,"code":"                    it('should check if `IfStatement` node has single statement `alternate`', () => {\n                        assert.equal(result, expectedResult);\n                    });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `IfStatement` node has single statement `consequent` and `alternate`","suites":["NodeGuards","isNodeWithSingleStatementBody","truthful checks","Variant #1: `IfStatement` node","Variant #3: single statement `consequent` and `alternate`"],"updatePoint":{"line":323,"column":108},"line":323,"code":"                    it('should check if `IfStatement` node has single statement `consequent` and `alternate`', () => {\n                        assert.equal(result, expectedResult);\n                    });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `ForStatement` node has single statement `body`","suites":["NodeGuards","isNodeWithSingleStatementBody","truthful checks","Variant #2: `ForStatement` node"],"updatePoint":{"line":358,"column":83},"line":358,"code":"                it('should check if `ForStatement` node has single statement `body`', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `ForInStatement` node has single statement `body`","suites":["NodeGuards","isNodeWithSingleStatementBody","truthful checks","Variant #3: `ForInStatement` node"],"updatePoint":{"line":386,"column":85},"line":386,"code":"                it('should check if `ForInStatement` node has single statement `body`', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `ForOfStatement` node has single statement `body`","suites":["NodeGuards","isNodeWithSingleStatementBody","truthful checks","Variant #4: `ForOfStatement` node"],"updatePoint":{"line":415,"column":85},"line":415,"code":"                it('should check if `ForOfStatement` node has single statement `body`', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `WhileStatement` node has single statement `body`","suites":["NodeGuards","isNodeWithSingleStatementBody","truthful checks","Variant #5: `WhileStatement` node"],"updatePoint":{"line":435,"column":85},"line":435,"code":"                it('should check if `WhileStatement` node has single statement `body`', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `DoWhileStatement` node has single statement `body`","suites":["NodeGuards","isNodeWithSingleStatementBody","truthful checks","Variant #6: `DoWhileStatement` node"],"updatePoint":{"line":455,"column":87},"line":455,"code":"                it('should check if `DoWhileStatement` node has single statement `body`', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `LabeledStatement` node has single statement `body`","suites":["NodeGuards","isNodeWithSingleStatementBody","truthful checks","Variant #7: `LabeledStatement` node"],"updatePoint":{"line":475,"column":87},"line":475,"code":"                it('should check if `LabeledStatement` node has single statement `body`', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `IfStatement` node has multiple statements `consequent` and `alternate`","suites":["NodeGuards","isNodeWithSingleStatementBody","false checks","Variant #1: `IfStatement` node","Variant #1: multiple statements `consequent` and `alternate`"],"updatePoint":{"line":505,"column":111},"line":505,"code":"                    it('should check if `IfStatement` node has multiple statements `consequent` and `alternate`', () => {\n                        assert.equal(result, expectedResult);\n                    });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `ForStatement` node has multiple statements `body`","suites":["NodeGuards","isNodeWithSingleStatementBody","false checks","Variant #2: `ForStatement` node"],"updatePoint":{"line":542,"column":86},"line":542,"code":"                it('should check if `ForStatement` node has multiple statements `body`', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `ForInStatement` node has multiple statements `body`","suites":["NodeGuards","isNodeWithSingleStatementBody","false checks","Variant #3: `ForInStatement` node"],"updatePoint":{"line":572,"column":88},"line":572,"code":"                it('should check if `ForInStatement` node has multiple statements `body`', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `ForOfStatement` node has multiple statements `body`","suites":["NodeGuards","isNodeWithSingleStatementBody","false checks","Variant #4: `ForOfStatement` node"],"updatePoint":{"line":603,"column":88},"line":603,"code":"                it('should check if `ForOfStatement` node has multiple statements `body`', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `WhileStatement` node has multiple statements `body`","suites":["NodeGuards","isNodeWithSingleStatementBody","false checks","Variant #5: `WhileStatement` node"],"updatePoint":{"line":625,"column":88},"line":625,"code":"                it('should check if `WhileStatement` node has multiple statements `body`', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `DoWhileStatement` node has multiple statements `body`","suites":["NodeGuards","isNodeWithSingleStatementBody","false checks","Variant #6: `DoWhileStatement` node"],"updatePoint":{"line":647,"column":90},"line":647,"code":"                it('should check if `DoWhileStatement` node has multiple statements `body`', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if `LabeledStatement` node has multiple statements `body`","suites":["NodeGuards","isNodeWithSingleStatementBody","false checks","Variant #7: `LabeledStatement` node"],"updatePoint":{"line":669,"column":90},"line":669,"code":"                it('should check if `LabeledStatement` node has multiple statements `body`', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if node has statements","suites":["NodeGuards","isNodeWithStatements","truthful checks","Variant #1: program node"],"updatePoint":{"line":688,"column":55},"line":688,"code":"                it('should check if node has statements', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if node has statements","suites":["NodeGuards","isNodeWithStatements","truthful checks","Variant #2: block statement node"],"updatePoint":{"line":703,"column":55},"line":703,"code":"                it('should check if node has statements', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if node has statements","suites":["NodeGuards","isNodeWithStatements","truthful checks","Variant #3: static block node"],"updatePoint":{"line":719,"column":55},"line":719,"code":"                it('should check if node has statements', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if node has statements","suites":["NodeGuards","isNodeWithStatements","truthful checks","Variant #4: switch case node"],"updatePoint":{"line":737,"column":55},"line":737,"code":"                it('should check if node has statements', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if node has statements","suites":["NodeGuards","isNodeWithStatements","false checks","Variant #1: literal node"],"updatePoint":{"line":754,"column":55},"line":754,"code":"                it('should check if node has statements', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if node has statements","suites":["NodeGuards","isNodeWithStatements","false checks","Variant #2: identifier node"],"updatePoint":{"line":769,"column":55},"line":769,"code":"                it('should check if node has statements', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if node has statements","suites":["NodeGuards","isNodeWithStatements","false checks","Variant #3: if-statement node"],"updatePoint":{"line":787,"column":55},"line":787,"code":"                it('should check if node has statements', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should check if node has statements","suites":["NodeGuards","isNodeWithStatements","false checks","Variant #4: switch-statement node"],"updatePoint":{"line":805,"column":55},"line":805,"code":"                it('should check if node has statements', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/node/node-guards/NodeGuards.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `program` node child node","suites":["NodeLexicalScopeUtils","getParentScope"],"updatePoint":{"line":67,"column":74},"line":67,"code":"        it('should return lexical scope node for `program` node child node', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScope(programNode), programNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `functionDeclaration` node child node","suites":["NodeLexicalScopeUtils","getParentScope"],"updatePoint":{"line":71,"column":86},"line":71,"code":"        it('should return lexical scope node for `functionDeclaration` node child node', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScope(functionDeclarationNode), functionDeclarationNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `functionDeclaration blockStatement` node child node","suites":["NodeLexicalScopeUtils","getParentScope"],"updatePoint":{"line":75,"column":101},"line":75,"code":"        it('should return lexical scope node for `functionDeclaration blockStatement` node child node', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScope(functionDeclarationBlockStatementNode), functionDeclarationNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `expressionStatement` node #1 child node","suites":["NodeLexicalScopeUtils","getParentScope"],"updatePoint":{"line":79,"column":89},"line":79,"code":"        it('should return lexical scope node for `expressionStatement` node #1 child node', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScope(expressionStatementNode1), functionDeclarationNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `ifStatement` node child node","suites":["NodeLexicalScopeUtils","getParentScope"],"updatePoint":{"line":83,"column":78},"line":83,"code":"        it('should return lexical scope node for `ifStatement` node child node', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScope(ifStatementNode1), functionDeclarationNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `ifStatement blockStatement` node #1 child node","suites":["NodeLexicalScopeUtils","getParentScope"],"updatePoint":{"line":87,"column":96},"line":87,"code":"        it('should return lexical scope node for `ifStatement blockStatement` node #1 child node', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScope(ifStatementBlockStatementNode1), functionDeclarationNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `ifStatement blockStatement` node #2 child node","suites":["NodeLexicalScopeUtils","getParentScope"],"updatePoint":{"line":91,"column":96},"line":91,"code":"        it('should return lexical scope node for `ifStatement blockStatement` node #2 child node', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScope(ifStatementBlockStatementNode2), functionDeclarationNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `expressionStatement` node #3 child node","suites":["NodeLexicalScopeUtils","getParentScope"],"updatePoint":{"line":95,"column":89},"line":95,"code":"        it('should return lexical scope node for `expressionStatement` node #3 child node', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScope(expressionStatementNode3), functionDeclarationNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw a `ReferenceError` if node has no `parentNode` property","suites":["NodeLexicalScopeUtils","getParentScope"],"updatePoint":{"line":99,"column":80},"line":99,"code":"        it('should throw a `ReferenceError` if node has no `parentNode` property', () => {\n            assert.throws(() => NodeLexicalScopeUtils.getLexicalScope(expressionStatementNode2), ReferenceError);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `program` node child node","suites":["NodeLexicalScopeUtils","getParentScopes"],"updatePoint":{"line":162,"column":74},"line":162,"code":"        it('should return lexical scope node for `program` node child node', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScopes(programNode)[0], programNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `functionDeclaration` node child node #1","suites":["NodeLexicalScopeUtils","getParentScopes"],"updatePoint":{"line":166,"column":89},"line":166,"code":"        it('should return lexical scope node for `functionDeclaration` node child node #1', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScopes(functionDeclarationNode)[0], functionDeclarationNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `functionDeclaration` node child node #2","suites":["NodeLexicalScopeUtils","getParentScopes"],"updatePoint":{"line":170,"column":89},"line":170,"code":"        it('should return lexical scope node for `functionDeclaration` node child node #2', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScopes(functionDeclarationNode)[1], programNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `functionDeclaration blockStatement` node child node #1","suites":["NodeLexicalScopeUtils","getParentScopes"],"updatePoint":{"line":174,"column":104},"line":174,"code":"        it('should return lexical scope node for `functionDeclaration blockStatement` node child node #1', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScopes(functionDeclarationBlockStatementNode)[0], functionDeclarationNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `expressionStatement` node #1 child node #1","suites":["NodeLexicalScopeUtils","getParentScopes"],"updatePoint":{"line":178,"column":92},"line":178,"code":"        it('should return lexical scope node for `expressionStatement` node #1 child node #1', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScopes(expressionStatementNode1)[0], functionDeclarationNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `expressionStatement` node #1 child node #2","suites":["NodeLexicalScopeUtils","getParentScopes"],"updatePoint":{"line":182,"column":92},"line":182,"code":"        it('should return lexical scope node for `expressionStatement` node #1 child node #2', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScopes(expressionStatementNode1)[1], programNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `ifStatement` node child node #1","suites":["NodeLexicalScopeUtils","getParentScopes"],"updatePoint":{"line":186,"column":81},"line":186,"code":"        it('should return lexical scope node for `ifStatement` node child node #1', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScopes(ifStatementNode1)[0], functionDeclarationNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `ifStatement` node child node #2","suites":["NodeLexicalScopeUtils","getParentScopes"],"updatePoint":{"line":190,"column":81},"line":190,"code":"        it('should return lexical scope node for `ifStatement` node child node #2', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScopes(ifStatementNode1)[1], programNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `ifStatement blockStatement` node #1 child node #1","suites":["NodeLexicalScopeUtils","getParentScopes"],"updatePoint":{"line":194,"column":99},"line":194,"code":"        it('should return lexical scope node for `ifStatement blockStatement` node #1 child node #1', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScopes(ifStatementBlockStatementNode1)[0], functionDeclarationNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `ifStatement blockStatement` node #1 child node #2","suites":["NodeLexicalScopeUtils","getParentScopes"],"updatePoint":{"line":198,"column":99},"line":198,"code":"        it('should return lexical scope node for `ifStatement blockStatement` node #1 child node #2', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScopes(ifStatementBlockStatementNode1)[1], programNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `ifStatement blockStatement` node #2 child node #1","suites":["NodeLexicalScopeUtils","getParentScopes"],"updatePoint":{"line":202,"column":99},"line":202,"code":"        it('should return lexical scope node for `ifStatement blockStatement` node #2 child node #1', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScopes(ifStatementBlockStatementNode2)[0], functionDeclarationNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `ifStatement blockStatement` node #1 child node #2","suites":["NodeLexicalScopeUtils","getParentScopes"],"updatePoint":{"line":206,"column":99},"line":206,"code":"        it('should return lexical scope node for `ifStatement blockStatement` node #1 child node #2', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScopes(ifStatementBlockStatementNode2)[1], programNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `expressionStatement` node #3 child node #1","suites":["NodeLexicalScopeUtils","getParentScopes"],"updatePoint":{"line":210,"column":92},"line":210,"code":"        it('should return lexical scope node for `expressionStatement` node #3 child node #1', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScopes(expressionStatementNode3)[0], functionDeclarationNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return lexical scope node for `expressionStatement` node #3 child node #2","suites":["NodeLexicalScopeUtils","getParentScopes"],"updatePoint":{"line":214,"column":92},"line":214,"code":"        it('should return lexical scope node for `expressionStatement` node #3 child node #2', () => {\n            assert.deepEqual(NodeLexicalScopeUtils.getLexicalScopes(expressionStatementNode3)[1], programNode);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw a `ReferenceError` if node has no `parentNode` property","suites":["NodeLexicalScopeUtils","getParentScopes"],"updatePoint":{"line":218,"column":80},"line":218,"code":"        it('should throw a `ReferenceError` if node has no `parentNode` property', () => {\n            assert.throws(() => NodeLexicalScopeUtils.getLexicalScopes(expressionStatementNode2)[0], ReferenceError);\n        });","file":"unit-tests/node/node-lexical-scope-utils/NodeLexicalScopeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return `true` for string literal node","suites":["NodeLiteralUtils","isStringLiteralNode","Variant #1: string literal node"],"updatePoint":{"line":19,"column":60},"line":19,"code":"            it('should return `true` for string literal node', () => {\n                assert.isTrue(result);\n            });","file":"unit-tests/node/node-literal-utils/NodeLiteralUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return `false` for number literal node","suites":["NodeLiteralUtils","isStringLiteralNode","Variant #2: number literal node"],"updatePoint":{"line":33,"column":61},"line":33,"code":"            it('should return `false` for number literal node', () => {\n                assert.isFalse(result);\n            });","file":"unit-tests/node/node-literal-utils/NodeLiteralUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return `false` for boolean literal node","suites":["NodeLiteralUtils","isStringLiteralNode","Variant #3: boolean literal node"],"updatePoint":{"line":47,"column":62},"line":47,"code":"            it('should return `false` for boolean literal node', () => {\n                assert.isFalse(result);\n            });","file":"unit-tests/node/node-literal-utils/NodeLiteralUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return false for base string literal node","suites":["NodeLiteralUtils","isProhibitedLiteralNode","String literal node","Variant #1: base string literal node"],"updatePoint":{"line":68,"column":68},"line":68,"code":"                it('should return false for base string literal node', () => {\n                    assert.equal(NodeLiteralUtils.isProhibitedLiteralNode(literalNode, statementNode), false);\n                });","file":"unit-tests/node/node-literal-utils/NodeLiteralUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return false for property key literal node","suites":["NodeLiteralUtils","isProhibitedLiteralNode","String literal node","Variant #2: property literal node","Variant #1: property key literal node"],"updatePoint":{"line":88,"column":73},"line":88,"code":"                    it('should return false for property key literal node', () => {\n                        assert.equal(NodeLiteralUtils.isProhibitedLiteralNode(literalNode, propertyNode), true);\n                    });","file":"unit-tests/node/node-literal-utils/NodeLiteralUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return false for computed property key literal node","suites":["NodeLiteralUtils","isProhibitedLiteralNode","String literal node","Variant #2: property literal node","Variant #2: computed property key literal node"],"updatePoint":{"line":108,"column":82},"line":108,"code":"                    it('should return false for computed property key literal node', () => {\n                        assert.equal(NodeLiteralUtils.isProhibitedLiteralNode(literalNode, propertyNode), false);\n                    });","file":"unit-tests/node/node-literal-utils/NodeLiteralUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return false for property value literal node","suites":["NodeLiteralUtils","isProhibitedLiteralNode","String literal node","Variant #2: property literal node","Variant #3: property value literal node"],"updatePoint":{"line":127,"column":75},"line":127,"code":"                    it('should return false for property value literal node', () => {\n                        assert.equal(NodeLiteralUtils.isProhibitedLiteralNode(literalNode, propertyNode), false);\n                    });","file":"unit-tests/node/node-literal-utils/NodeLiteralUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return false for import declaration literal node","suites":["NodeLiteralUtils","isProhibitedLiteralNode","String literal node","Variant #3: import declaration node","Variant #1: base import declaration literal node"],"updatePoint":{"line":148,"column":79},"line":148,"code":"                    it('should return false for import declaration literal node', () => {\n                        assert.equal(NodeLiteralUtils.isProhibitedLiteralNode(literalNode, importDeclarationNode), true);\n                    });","file":"unit-tests/node/node-literal-utils/NodeLiteralUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return false for export named declaration literal node","suites":["NodeLiteralUtils","isProhibitedLiteralNode","String literal node","Variant #4: export named declaration node","Variant #1: base export named declaration literal node"],"updatePoint":{"line":169,"column":85},"line":169,"code":"                    it('should return false for export named declaration literal node', () => {\n                        assert.equal(NodeLiteralUtils.isProhibitedLiteralNode(literalNode, exportNamedDeclarationNode), true);\n                    });","file":"unit-tests/node/node-literal-utils/NodeLiteralUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return false for export all declaration literal node","suites":["NodeLiteralUtils","isProhibitedLiteralNode","String literal node","Variant #5: export all declaration node","Variant #1: base export all declaration literal node"],"updatePoint":{"line":190,"column":83},"line":190,"code":"                    it('should return false for export all declaration literal node', () => {\n                        assert.equal(NodeLiteralUtils.isProhibitedLiteralNode(literalNode, exportAllDeclarationNode), true);\n                    });","file":"unit-tests/node/node-literal-utils/NodeLiteralUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return false for base number literal node","suites":["NodeLiteralUtils","isProhibitedLiteralNode","Number literal node","Variant #1: base number literal node"],"updatePoint":{"line":216,"column":68},"line":216,"code":"                it('should return false for base number literal node', () => {\n                    assert.equal(NodeLiteralUtils.isProhibitedLiteralNode(literalNode, statementNode), false);\n                });","file":"unit-tests/node/node-literal-utils/NodeLiteralUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should set metadata to the node","suites":["NodeMetadata","set"],"updatePoint":{"line":27,"column":43},"line":27,"code":"        it('should set metadata to the node', () => {\n            assert.deepPropertyVal(node, 'metadata', expectedMetadata);\n        });","file":"unit-tests/node/node-metadata/NodeMetadata.spec.ts","skipped":false,"dir":"test"},{"name":"should get metadata value of the node","suites":["NodeMetadata","get"],"updatePoint":{"line":48,"column":49},"line":48,"code":"        it('should get metadata value of the node', () => {\n            assert.equal(value, expectedValue);\n        });","file":"unit-tests/node/node-metadata/NodeMetadata.spec.ts","skipped":false,"dir":"test"},{"name":"should return metadata value","suites":["NodeMetadata","isEvalHostNode"],"updatePoint":{"line":66,"column":40},"line":66,"code":"        it('should return metadata value', () => {\n            assert.equal(value, expectedValue);\n        });","file":"unit-tests/node/node-metadata/NodeMetadata.spec.ts","skipped":false,"dir":"test"},{"name":"should return metadata value","suites":["NodeMetadata","isForceTransformNode"],"updatePoint":{"line":84,"column":40},"line":84,"code":"        it('should return metadata value', () => {\n            assert.equal(value, expectedValue);\n        });","file":"unit-tests/node/node-metadata/NodeMetadata.spec.ts","skipped":false,"dir":"test"},{"name":"should return metadata value","suites":["NodeMetadata","isIgnoredNode"],"updatePoint":{"line":102,"column":40},"line":102,"code":"        it('should return metadata value', () => {\n            assert.equal(value, expectedValue);\n        });","file":"unit-tests/node/node-metadata/NodeMetadata.spec.ts","skipped":false,"dir":"test"},{"name":"should return metadata value","suites":["NodeMetadata","propertyKeyToRenameNode"],"updatePoint":{"line":120,"column":40},"line":120,"code":"        it('should return metadata value', () => {\n            assert.equal(value, expectedValue);\n        });","file":"unit-tests/node/node-metadata/NodeMetadata.spec.ts","skipped":false,"dir":"test"},{"name":"should return metadata value","suites":["NodeMetadata","isStringArrayCallLiteralNode"],"updatePoint":{"line":138,"column":40},"line":138,"code":"        it('should return metadata value', () => {\n            assert.equal(value, expectedValue);\n        });","file":"unit-tests/node/node-metadata/NodeMetadata.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements for `program` node child node","suites":["NodeStatementUtils","getParentNodeWithStatements"],"updatePoint":{"line":68,"column":83},"line":68,"code":"        it('should return parent node with statements for `program` node child node', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodeWithStatements(programNode), programNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `functionDeclaration` node child node","suites":["NodeStatementUtils","getParentNodeWithStatements"],"updatePoint":{"line":72,"column":100},"line":72,"code":"        it('should return parent node with statements node for `functionDeclaration` node child node', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodeWithStatements(functionDeclarationNode), programNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `functionDeclaration blockStatement` node child node","suites":["NodeStatementUtils","getParentNodeWithStatements"],"updatePoint":{"line":76,"column":115},"line":76,"code":"        it('should return parent node with statements node for `functionDeclaration blockStatement` node child node', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodeWithStatements(functionDeclarationBlockStatementNode), programNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `expressionStatement` node #1 child node","suites":["NodeStatementUtils","getParentNodeWithStatements"],"updatePoint":{"line":80,"column":103},"line":80,"code":"        it('should return parent node with statements node for `expressionStatement` node #1 child node', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodeWithStatements(expressionStatementNode1), functionDeclarationBlockStatementNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `ifStatement` node child node","suites":["NodeStatementUtils","getParentNodeWithStatements"],"updatePoint":{"line":84,"column":92},"line":84,"code":"        it('should return parent node with statements node for `ifStatement` node child node', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodeWithStatements(ifStatementNode1), functionDeclarationBlockStatementNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `ifStatement blockStatement` node #1 child node","suites":["NodeStatementUtils","getParentNodeWithStatements"],"updatePoint":{"line":88,"column":110},"line":88,"code":"        it('should return parent node with statements node for `ifStatement blockStatement` node #1 child node', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodeWithStatements(ifStatementBlockStatementNode1), functionDeclarationBlockStatementNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `ifStatement blockStatement` node #2 child node","suites":["NodeStatementUtils","getParentNodeWithStatements"],"updatePoint":{"line":92,"column":110},"line":92,"code":"        it('should return parent node with statements node for `ifStatement blockStatement` node #2 child node', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodeWithStatements(ifStatementBlockStatementNode2), functionDeclarationBlockStatementNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `expressionStatement` node #3 child node","suites":["NodeStatementUtils","getParentNodeWithStatements"],"updatePoint":{"line":96,"column":103},"line":96,"code":"        it('should return parent node with statements node for `expressionStatement` node #3 child node', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodeWithStatements(expressionStatementNode3), functionDeclarationBlockStatementNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw a `ReferenceError` if node has no `parentNode` property","suites":["NodeStatementUtils","getParentNodeWithStatements"],"updatePoint":{"line":100,"column":80},"line":100,"code":"        it('should throw a `ReferenceError` if node has no `parentNode` property', () => {\n            assert.throws(() => NodeStatementUtils.getParentNodeWithStatements(expressionStatementNode2), ReferenceError);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `program` node child node","suites":["NodeStatementUtils","getParentNodesWithStatements"],"updatePoint":{"line":163,"column":88},"line":163,"code":"        it('should return parent node with statements node for `program` node child node', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodesWithStatements(programNode)[0], programNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `functionDeclaration` node child node #1","suites":["NodeStatementUtils","getParentNodesWithStatements"],"updatePoint":{"line":167,"column":103},"line":167,"code":"        it('should return parent node with statements node for `functionDeclaration` node child node #1', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodesWithStatements(functionDeclarationNode)[0], programNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `functionDeclaration blockStatement` node child node #1","suites":["NodeStatementUtils","getParentNodesWithStatements"],"updatePoint":{"line":171,"column":118},"line":171,"code":"        it('should return parent node with statements node for `functionDeclaration blockStatement` node child node #1', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodesWithStatements(functionDeclarationBlockStatementNode)[0], programNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `expressionStatement` node #1 child node #1","suites":["NodeStatementUtils","getParentNodesWithStatements"],"updatePoint":{"line":175,"column":106},"line":175,"code":"        it('should return parent node with statements node for `expressionStatement` node #1 child node #1', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodesWithStatements(expressionStatementNode1)[0], functionDeclarationBlockStatementNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `expressionStatement` node #1 child node #2","suites":["NodeStatementUtils","getParentNodesWithStatements"],"updatePoint":{"line":179,"column":106},"line":179,"code":"        it('should return parent node with statements node for `expressionStatement` node #1 child node #2', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodesWithStatements(expressionStatementNode1)[1], programNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `ifStatement` node child node #1","suites":["NodeStatementUtils","getParentNodesWithStatements"],"updatePoint":{"line":183,"column":95},"line":183,"code":"        it('should return parent node with statements node for `ifStatement` node child node #1', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodesWithStatements(ifStatementNode1)[0], functionDeclarationBlockStatementNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `ifStatement` node child node #2","suites":["NodeStatementUtils","getParentNodesWithStatements"],"updatePoint":{"line":187,"column":95},"line":187,"code":"        it('should return parent node with statements node for `ifStatement` node child node #2', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodesWithStatements(ifStatementNode1)[1], programNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `ifStatement blockStatement` node #1 child node #1","suites":["NodeStatementUtils","getParentNodesWithStatements"],"updatePoint":{"line":191,"column":113},"line":191,"code":"        it('should return parent node with statements node for `ifStatement blockStatement` node #1 child node #1', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodesWithStatements(ifStatementBlockStatementNode1)[0], functionDeclarationBlockStatementNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `ifStatement blockStatement` node #1 child node #2","suites":["NodeStatementUtils","getParentNodesWithStatements"],"updatePoint":{"line":195,"column":113},"line":195,"code":"        it('should return parent node with statements node for `ifStatement blockStatement` node #1 child node #2', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodesWithStatements(ifStatementBlockStatementNode1)[1], programNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `ifStatement blockStatement` node #2 child node #1","suites":["NodeStatementUtils","getParentNodesWithStatements"],"updatePoint":{"line":199,"column":113},"line":199,"code":"        it('should return parent node with statements node for `ifStatement blockStatement` node #2 child node #1', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodesWithStatements(ifStatementBlockStatementNode2)[0], functionDeclarationBlockStatementNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `ifStatement blockStatement` node #1 child node #2","suites":["NodeStatementUtils","getParentNodesWithStatements"],"updatePoint":{"line":203,"column":113},"line":203,"code":"        it('should return parent node with statements node for `ifStatement blockStatement` node #1 child node #2', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodesWithStatements(ifStatementBlockStatementNode2)[1], programNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `expressionStatement` node #3 child node #1","suites":["NodeStatementUtils","getParentNodesWithStatements"],"updatePoint":{"line":207,"column":106},"line":207,"code":"        it('should return parent node with statements node for `expressionStatement` node #3 child node #1', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodesWithStatements(expressionStatementNode3)[0], functionDeclarationBlockStatementNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return parent node with statements node for `expressionStatement` node #3 child node #2","suites":["NodeStatementUtils","getParentNodesWithStatements"],"updatePoint":{"line":211,"column":106},"line":211,"code":"        it('should return parent node with statements node for `expressionStatement` node #3 child node #2', () => {\n            assert.deepEqual(NodeStatementUtils.getParentNodesWithStatements(expressionStatementNode3)[1], programNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw a `ReferenceError` if node has no `parentNode` property","suites":["NodeStatementUtils","getParentNodesWithStatements"],"updatePoint":{"line":215,"column":80},"line":215,"code":"        it('should throw a `ReferenceError` if node has no `parentNode` property', () => {\n            assert.throws(() => NodeStatementUtils.getParentNodesWithStatements(expressionStatementNode2)[0], ReferenceError);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return next sibling statement node","suites":["NodeStatementUtils","getNextSiblingStatement","Variant #1: block statement node as scope node"],"updatePoint":{"line":248,"column":57},"line":248,"code":"            it('should return next sibling statement node', () => {\n                assert.deepEqual(NodeStatementUtils.getNextSiblingStatement(statementNode1), statementNode2);\n            });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return next sibling statement node","suites":["NodeStatementUtils","getNextSiblingStatement","Variant #1: block statement node as scope node"],"updatePoint":{"line":252,"column":57},"line":252,"code":"            it('should return next sibling statement node', () => {\n                assert.deepEqual(NodeStatementUtils.getNextSiblingStatement(statementNode2), statementNode3);\n            });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return `null` if given statement node is last node in the scope","suites":["NodeStatementUtils","getNextSiblingStatement","Variant #1: block statement node as scope node"],"updatePoint":{"line":256,"column":86},"line":256,"code":"            it('should return `null` if given statement node is last node in the scope', () => {\n                assert.deepEqual(NodeStatementUtils.getNextSiblingStatement(statementNode3), null);\n            });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return next sibling statement node","suites":["NodeStatementUtils","getNextSiblingStatement","Variant #2: switch case node as scope node"],"updatePoint":{"line":291,"column":57},"line":291,"code":"            it('should return next sibling statement node', () => {\n                assert.deepEqual(NodeStatementUtils.getNextSiblingStatement(statementNode1), statementNode2);\n            });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return next sibling statement node","suites":["NodeStatementUtils","getNextSiblingStatement","Variant #2: switch case node as scope node"],"updatePoint":{"line":295,"column":57},"line":295,"code":"            it('should return next sibling statement node', () => {\n                assert.deepEqual(NodeStatementUtils.getNextSiblingStatement(statementNode2), statementNode3);\n            });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return `null` if given statement node is last node in the scope","suites":["NodeStatementUtils","getNextSiblingStatement","Variant #2: switch case node as scope node"],"updatePoint":{"line":299,"column":86},"line":299,"code":"            it('should return `null` if given statement node is last node in the scope', () => {\n                assert.deepEqual(NodeStatementUtils.getNextSiblingStatement(statementNode3), null);\n            });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return next sibling statement node","suites":["NodeStatementUtils","getPreviousSiblingStatement","Variant #1: block statement node as scope node"],"updatePoint":{"line":333,"column":57},"line":333,"code":"            it('should return next sibling statement node', () => {\n                assert.deepEqual(NodeStatementUtils.getPreviousSiblingStatement(statementNode1), null);\n            });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return next sibling statement node","suites":["NodeStatementUtils","getPreviousSiblingStatement","Variant #1: block statement node as scope node"],"updatePoint":{"line":337,"column":57},"line":337,"code":"            it('should return next sibling statement node', () => {\n                assert.deepEqual(NodeStatementUtils.getPreviousSiblingStatement(statementNode2), statementNode1);\n            });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return `null` if given statement node is last node in the scope","suites":["NodeStatementUtils","getPreviousSiblingStatement","Variant #1: block statement node as scope node"],"updatePoint":{"line":341,"column":86},"line":341,"code":"            it('should return `null` if given statement node is last node in the scope', () => {\n                assert.deepEqual(NodeStatementUtils.getPreviousSiblingStatement(statementNode3), statementNode2);\n            });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return next sibling statement node","suites":["NodeStatementUtils","getPreviousSiblingStatement","Variant #2: switch case node as scope node"],"updatePoint":{"line":376,"column":57},"line":376,"code":"            it('should return next sibling statement node', () => {\n                assert.deepEqual(NodeStatementUtils.getPreviousSiblingStatement(statementNode1), null);\n            });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return next sibling statement node","suites":["NodeStatementUtils","getPreviousSiblingStatement","Variant #2: switch case node as scope node"],"updatePoint":{"line":380,"column":57},"line":380,"code":"            it('should return next sibling statement node', () => {\n                assert.deepEqual(NodeStatementUtils.getPreviousSiblingStatement(statementNode2), statementNode1);\n            });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return `null` if given statement node is last node in the scope","suites":["NodeStatementUtils","getPreviousSiblingStatement","Variant #2: switch case node as scope node"],"updatePoint":{"line":384,"column":86},"line":384,"code":"            it('should return `null` if given statement node is last node in the scope', () => {\n                assert.deepEqual(NodeStatementUtils.getPreviousSiblingStatement(statementNode3), statementNode2);\n            });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return root statement in scope for `program` node child","suites":["NodeStatementUtils","getRootStatementOfNode"],"updatePoint":{"line":452,"column":74},"line":452,"code":"        it('should return root statement in scope for `program` node child', () => {\n            assert.throws(() => NodeStatementUtils.getRootStatementOfNode(programNode), Error);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return root statement in scope for `functionDeclaration` node #1","suites":["NodeStatementUtils","getRootStatementOfNode"],"updatePoint":{"line":456,"column":83},"line":456,"code":"        it('should return root statement in scope for `functionDeclaration` node #1', () => {\n            assert.deepEqual(NodeStatementUtils.getRootStatementOfNode(functionDeclarationNode), functionDeclarationNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return root statement in scope for `functionDeclaration blockStatement` node #1","suites":["NodeStatementUtils","getRootStatementOfNode"],"updatePoint":{"line":460,"column":98},"line":460,"code":"        it('should return root statement in scope for `functionDeclaration blockStatement` node #1', () => {\n            assert.deepEqual(NodeStatementUtils.getRootStatementOfNode(functionDeclarationBlockStatementNode), functionDeclarationNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return root statement in scope for `identifier` node #1","suites":["NodeStatementUtils","getRootStatementOfNode"],"updatePoint":{"line":464,"column":74},"line":464,"code":"        it('should return root statement in scope for `identifier` node #1', () => {\n            assert.deepEqual(NodeStatementUtils.getRootStatementOfNode(identifierNode1), variableDeclarationNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return root statement in scope for `identifier` node #2","suites":["NodeStatementUtils","getRootStatementOfNode"],"updatePoint":{"line":468,"column":74},"line":468,"code":"        it('should return root statement in scope for `identifier` node #2', () => {\n            assert.deepEqual(NodeStatementUtils.getRootStatementOfNode(identifierNode2), variableDeclarationNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return root statement in scope for `identifier` node #4","suites":["NodeStatementUtils","getRootStatementOfNode"],"updatePoint":{"line":472,"column":74},"line":472,"code":"        it('should return root statement in scope for `identifier` node #4', () => {\n            assert.deepEqual(NodeStatementUtils.getRootStatementOfNode(identifierNode4), expressionStatement);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return root statement in scope for `identifier` node #5","suites":["NodeStatementUtils","getRootStatementOfNode"],"updatePoint":{"line":476,"column":74},"line":476,"code":"        it('should return root statement in scope for `identifier` node #5', () => {\n            assert.deepEqual(NodeStatementUtils.getRootStatementOfNode(identifierNode5), expressionStatement);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw a `ReferenceError` if node has no `parentNode` property","suites":["NodeStatementUtils","getRootStatementOfNode"],"updatePoint":{"line":480,"column":80},"line":480,"code":"        it('should throw a `ReferenceError` if node has no `parentNode` property', () => {\n            assert.throws(() => NodeStatementUtils.getRootStatementOfNode(identifierNode3), ReferenceError);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return scope node for `program` node child","suites":["NodeStatementUtils","getScopeOfNode"],"updatePoint":{"line":573,"column":61},"line":573,"code":"        it('should return scope node for `program` node child', () => {\n            assert.deepEqual(NodeStatementUtils.getScopeOfNode(programNode), programNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return scope node for `functionDeclaration` node child node #1","suites":["NodeStatementUtils","getScopeOfNode"],"updatePoint":{"line":577,"column":81},"line":577,"code":"        it('should return scope node for `functionDeclaration` node child node #1', () => {\n            assert.deepEqual(NodeStatementUtils.getScopeOfNode(functionDeclarationNode), programNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return scope node for `functionDeclaration blockStatement` node child node #1","suites":["NodeStatementUtils","getScopeOfNode"],"updatePoint":{"line":581,"column":96},"line":581,"code":"        it('should return scope node for `functionDeclaration blockStatement` node child node #1', () => {\n            assert.deepEqual(NodeStatementUtils.getScopeOfNode(functionDeclarationBlockStatementNode), programNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return scope node for `expressionStatement` node #1 child node","suites":["NodeStatementUtils","getScopeOfNode"],"updatePoint":{"line":585,"column":81},"line":585,"code":"        it('should return scope node for `expressionStatement` node #1 child node', () => {\n            assert.deepEqual(NodeStatementUtils.getScopeOfNode(expressionStatementNode1), functionDeclarationBlockStatementNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return scope node for `ifStatement` node #1 child node","suites":["NodeStatementUtils","getScopeOfNode"],"updatePoint":{"line":589,"column":73},"line":589,"code":"        it('should return scope node for `ifStatement` node #1 child node', () => {\n            assert.deepEqual(NodeStatementUtils.getScopeOfNode(ifStatementNode1), functionDeclarationBlockStatementNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return scope node for `switchStatement` node child node","suites":["NodeStatementUtils","getScopeOfNode"],"updatePoint":{"line":593,"column":74},"line":593,"code":"        it('should return scope node for `switchStatement` node child node', () => {\n            assert.deepEqual(NodeStatementUtils.getScopeOfNode(switchStatementNode), functionDeclarationBlockStatementNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return scope node for `switchCase` node child node","suites":["NodeStatementUtils","getScopeOfNode"],"updatePoint":{"line":597,"column":69},"line":597,"code":"        it('should return scope node for `switchCase` node child node', () => {\n            assert.deepEqual(NodeStatementUtils.getScopeOfNode(switchCaseNode), functionDeclarationBlockStatementNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return scope node for `ifStatement` node #2 child node","suites":["NodeStatementUtils","getScopeOfNode"],"updatePoint":{"line":601,"column":73},"line":601,"code":"        it('should return scope node for `ifStatement` node #2 child node', () => {\n            assert.deepEqual(NodeStatementUtils.getScopeOfNode(ifStatementNode2), switchCaseNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return scope node for `ifStatement blockStatement` node #2 child node","suites":["NodeStatementUtils","getScopeOfNode"],"updatePoint":{"line":605,"column":88},"line":605,"code":"        it('should return scope node for `ifStatement blockStatement` node #2 child node', () => {\n            assert.deepEqual(NodeStatementUtils.getScopeOfNode(ifStatementBlockStatementNode2), switchCaseNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return scope node for `ifStatement blockStatement` node #1 child node","suites":["NodeStatementUtils","getScopeOfNode"],"updatePoint":{"line":609,"column":88},"line":609,"code":"        it('should return scope node for `ifStatement blockStatement` node #1 child node', () => {\n            assert.deepEqual(NodeStatementUtils.getScopeOfNode(ifStatementBlockStatementNode1), functionDeclarationBlockStatementNode);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return scope node for `ifStatement blockStatement` node #3 child node","suites":["NodeStatementUtils","getScopeOfNode"],"updatePoint":{"line":613,"column":88},"line":613,"code":"        it('should return scope node for `ifStatement blockStatement` node #3 child node', () => {\n            assert.deepEqual(NodeStatementUtils.getScopeOfNode(ifStatementBlockStatementNode3), ifStatementBlockStatementNode1);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return scope node for `expressionStatement` node #3 child node","suites":["NodeStatementUtils","getScopeOfNode"],"updatePoint":{"line":617,"column":81},"line":617,"code":"        it('should return scope node for `expressionStatement` node #3 child node', () => {\n            assert.deepEqual(NodeStatementUtils.getScopeOfNode(expressionStatementNode3), ifStatementBlockStatementNode3);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw a `ReferenceError` if node has no `parentNode` property","suites":["NodeStatementUtils","getScopeOfNode"],"updatePoint":{"line":621,"column":80},"line":621,"code":"        it('should throw a `ReferenceError` if node has no `parentNode` property', () => {\n            assert.throws(() => NodeStatementUtils.getScopeOfNode(expressionStatementNode2), ReferenceError);\n        });","file":"unit-tests/node/node-statement-utils/NodeStatementUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should add `x-verbatim-property` to `Literal` node","suites":["NodeUtils","addXVerbatimPropertyTo"],"updatePoint":{"line":26,"column":62},"line":26,"code":"        it('should add `x-verbatim-property` to `Literal` node', () => {\n            assert.deepEqual(literalNode, expectedLiteralNode);\n        });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should clone given AST-tree","suites":["NodeUtils","clone","Variant #1: simple AST-tree"],"updatePoint":{"line":77,"column":43},"line":77,"code":"            it('should clone given AST-tree', () => {\n                assert.deepEqual(programNode, expectedProgramNode);\n            });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should clone given AST-tree","suites":["NodeUtils","clone","Variant #2: array expression with `null` element"],"updatePoint":{"line":121,"column":43},"line":121,"code":"            it('should clone given AST-tree', () => {\n                assert.deepEqual(programNode, expectedProgramNode);\n            });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should convert code to `ESTree.Node[]` structure array","suites":["NodeUtils","convertCodeToStructure"],"updatePoint":{"line":156,"column":66},"line":156,"code":"        it('should convert code to `ESTree.Node[]` structure array', () => {\n            assert.deepEqual(structure, expectedStructure);\n        });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should convert `ESTree.Node[]` structure to source code","suites":["NodeUtils","convertStructureToCode"],"updatePoint":{"line":179,"column":67},"line":179,"code":"        it('should convert `ESTree.Node[]` structure to source code', () => {\n            assert.deepEqual(NodeUtils.convertStructureToCode(structure), expectedCode);\n        });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return unary expression argument node","suites":["NodeUtils","getUnaryExpressionArgumentNode"],"updatePoint":{"line":207,"column":56},"line":207,"code":"        it('should return unary expression argument node', () => {\n            assert.deepEqual(unaryExpressionArgumentNode, expectedNode);\n        });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should parentize `program` node with `ProgramNode` as root node","suites":["NodeUtils","parentizeAst","Variant #1: parentize AST-tree with `ProgramNode` as root node"],"updatePoint":{"line":243,"column":79},"line":243,"code":"            it('should parentize `program` node with `ProgramNode` as root node', () => {\n                assert.deepEqual(programNode.parentNode, programNode);\n            });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should parentize `ifStatement` node with `ProgramNode` as root node","suites":["NodeUtils","parentizeAst","Variant #1: parentize AST-tree with `ProgramNode` as root node"],"updatePoint":{"line":247,"column":83},"line":247,"code":"            it('should parentize `ifStatement` node with `ProgramNode` as root node', () => {\n                assert.deepEqual(ifStatementNode.parentNode, programNode);\n            });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should parentize `ifStatement blockStatement` node with `ProgramNode` as root node","suites":["NodeUtils","parentizeAst","Variant #1: parentize AST-tree with `ProgramNode` as root node"],"updatePoint":{"line":251,"column":98},"line":251,"code":"            it('should parentize `ifStatement blockStatement` node with `ProgramNode` as root node', () => {\n                assert.deepEqual(ifStatementBlockStatementNode.parentNode, ifStatementNode);\n            });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should parentize `expressionStatement` node #1 with `ProgramNode` as root node","suites":["NodeUtils","parentizeAst","Variant #1: parentize AST-tree with `ProgramNode` as root node"],"updatePoint":{"line":255,"column":94},"line":255,"code":"            it('should parentize `expressionStatement` node #1 with `ProgramNode` as root node', () => {\n                assert.deepEqual(expressionStatementNode1.parentNode, ifStatementBlockStatementNode);\n            });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should parentize `expressionStatement` node #2 with `ProgramNode` as root node","suites":["NodeUtils","parentizeAst","Variant #1: parentize AST-tree with `ProgramNode` as root node"],"updatePoint":{"line":259,"column":94},"line":259,"code":"            it('should parentize `expressionStatement` node #2 with `ProgramNode` as root node', () => {\n                assert.deepEqual(expressionStatementNode2.parentNode, ifStatementBlockStatementNode);\n            });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should parentize `ifStatement` node","suites":["NodeUtils","parentizeAst","Variant #2: parentize AST-tree"],"updatePoint":{"line":269,"column":51},"line":269,"code":"            it('should parentize `ifStatement` node', () => {\n                assert.deepEqual(ifStatementNode.parentNode, ifStatementNode);\n            });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should parentize `ifStatement blockStatement` node","suites":["NodeUtils","parentizeAst","Variant #2: parentize AST-tree"],"updatePoint":{"line":273,"column":66},"line":273,"code":"            it('should parentize `ifStatement blockStatement` node', () => {\n                assert.deepEqual(ifStatementBlockStatementNode.parentNode, ifStatementNode);\n            });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should parentize `expressionStatement` node #1","suites":["NodeUtils","parentizeAst","Variant #2: parentize AST-tree"],"updatePoint":{"line":277,"column":62},"line":277,"code":"            it('should parentize `expressionStatement` node #1', () => {\n                assert.deepEqual(expressionStatementNode1.parentNode, ifStatementBlockStatementNode);\n            });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should parentize `expressionStatement` node #2","suites":["NodeUtils","parentizeAst","Variant #2: parentize AST-tree"],"updatePoint":{"line":281,"column":62},"line":281,"code":"            it('should parentize `expressionStatement` node #2', () => {\n                assert.deepEqual(expressionStatementNode2.parentNode, ifStatementBlockStatementNode);\n            });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should parentize `ifStatement` node","suites":["NodeUtils","parentizeAst","Variant #3: parentize AST-tree and keep root node parent node"],"updatePoint":{"line":296,"column":51},"line":296,"code":"            it('should parentize `ifStatement` node', () => {\n                assert.deepEqual(ifStatementNode.parentNode, programNode);\n            });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should parentize `ifStatement blockStatement` node","suites":["NodeUtils","parentizeAst","Variant #3: parentize AST-tree and keep root node parent node"],"updatePoint":{"line":300,"column":66},"line":300,"code":"            it('should parentize `ifStatement blockStatement` node', () => {\n                assert.deepEqual(ifStatementBlockStatementNode.parentNode, ifStatementNode);\n            });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should parentize given node","suites":["NodeUtils","parentizeNode","Variant #1: node with parent node"],"updatePoint":{"line":325,"column":43},"line":325,"code":"            it('should parentize given node', () => {\n                assert.deepEqual(result, expectedResult);\n            });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should parentize given node","suites":["NodeUtils","parentizeNode","Variant #2: node without parent node"],"updatePoint":{"line":342,"column":43},"line":342,"code":"            it('should parentize given node', () => {\n                assert.deepEqual(result, expectedResult);\n            });","file":"unit-tests/node/node-utils/NodeUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should convert number numerical expression data to expression node","suites":["NumericalExpressionDataToNodeConverter","convertIntegerNumberData","Variant #1: base"],"updatePoint":{"line":54,"column":82},"line":54,"code":"            it('should convert number numerical expression data to expression node', () => {\n                assert.deepEqual(expressionNode, expectedExpressionNode);\n            });","file":"unit-tests/node/numerical-expression-data-to-node-converter/NumericalExpressionDataToNodeConverter.spec.ts","skipped":false,"dir":"test"},{"name":"should convert number numerical expression data to expression node","suites":["NumericalExpressionDataToNodeConverter","convertFloatNumberData","Variant #1: base"],"updatePoint":{"line":107,"column":82},"line":107,"code":"            it('should convert number numerical expression data to expression node', () => {\n                assert.deepEqual(expressionNode, expectedExpressionNode);\n            });","file":"unit-tests/node/numerical-expression-data-to-node-converter/NumericalExpressionDataToNodeConverter.spec.ts","skipped":false,"dir":"test"},{"name":"Should return options for passed options preset name","suites":["Options","getOptionsByPreset","Variant #1: base behaviour"],"updatePoint":{"line":25,"column":68},"line":25,"code":"            it('Should return options for passed options preset name', () => {\n                assert.deepEqual(options, HIGH_OBFUSCATION_PRESET);\n            });","file":"unit-tests/options/Options.spec.ts","skipped":false,"dir":"test"},{"name":"Should throws an error when unknown option preset is passed","suites":["Options","getOptionsByPreset","Variant #2: unknown options preset name"],"updatePoint":{"line":39,"column":75},"line":39,"code":"            it('Should throws an error when unknown option preset is passed', () => {\n                assert.throws(testFunc, 'Options for preset name `foobar` are not found');\n            });","file":"unit-tests/options/Options.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should return valid validation errors","suites":["ValidationErrorsFormatter","format","Variant #1: one constraint group with one constraint"],"updatePoint":{"line":28,"column":63},"line":28,"code":"            it('match #1: should return valid validation errors', () => {\n                assert.match(validationError, constraintGroupRegExp);\n            });","file":"unit-tests/options/ValidationErrorsFormatter.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should return valid validation errors","suites":["ValidationErrorsFormatter","format","Variant #1: one constraint group with one constraint"],"updatePoint":{"line":32,"column":63},"line":32,"code":"            it('match #2: should return valid validation errors', () => {\n                assert.match(validationError, constraintRegExp);\n            });","file":"unit-tests/options/ValidationErrorsFormatter.spec.ts","skipped":false,"dir":"test"},{"name":"match #1: should return valid validation errors","suites":["ValidationErrorsFormatter","format","Variant #2: one constraint group with two constraint"],"updatePoint":{"line":58,"column":63},"line":58,"code":"            it('match #1: should return valid validation errors', () => {\n                assert.match(validationError, constraintGroupRegExp);\n            });","file":"unit-tests/options/ValidationErrorsFormatter.spec.ts","skipped":false,"dir":"test"},{"name":"match #2: should return valid validation errors","suites":["ValidationErrorsFormatter","format","Variant #2: one constraint group with two constraint"],"updatePoint":{"line":62,"column":63},"line":62,"code":"            it('match #2: should return valid validation errors', () => {\n                assert.match(validationError, constraintRegExp1);\n            });","file":"unit-tests/options/ValidationErrorsFormatter.spec.ts","skipped":false,"dir":"test"},{"name":"match #3: should return valid validation errors","suites":["ValidationErrorsFormatter","format","Variant #2: one constraint group with two constraint"],"updatePoint":{"line":66,"column":63},"line":66,"code":"            it('match #3: should return valid validation errors', () => {\n                assert.match(validationError, constraintRegExp2);\n            });","file":"unit-tests/options/ValidationErrorsFormatter.spec.ts","skipped":false,"dir":"test"},{"name":"Should return valid validation error","suites":["ValidationErrorsFormatter","format","Variant #3: one constraint group without constraints"],"updatePoint":{"line":86,"column":52},"line":86,"code":"            it('Should return valid validation error', () => {\n                assert.match(validationError, constraintGroupRegExp);\n            });","file":"unit-tests/options/ValidationErrorsFormatter.spec.ts","skipped":false,"dir":"test"},{"name":"should return valid validation errors","suites":["ValidationErrorsFormatter","format","Variant #4: two constraint groups"],"updatePoint":{"line":123,"column":53},"line":123,"code":"            it('should return valid validation errors', () => {\n                assert.match(validationError, regExp);\n            });","file":"unit-tests/options/ValidationErrorsFormatter.spec.ts","skipped":false,"dir":"test"},{"name":"should return obfuscation result if `.toString()` was called on `ObfuscationResult` object","suites":["ObfuscatedCode","constructor"],"updatePoint":{"line":101,"column":102},"line":101,"code":"        it('should return obfuscation result if `.toString()` was called on `ObfuscationResult` object', () => {\n            assert.equal(obfuscationResult.toString(), expectedObfuscatedCode);\n        });","file":"unit-tests/source-code/ObfuscationResult.spec.ts","skipped":false,"dir":"test"},{"name":"should return untouched obfuscated code","suites":["ObfuscatedCode","getObfuscatedCode","source map doest't exist"],"updatePoint":{"line":120,"column":55},"line":120,"code":"            it('should return untouched obfuscated code', () => {\n                assert.equal(obfuscatedCode, expectedObfuscatedCode);\n            });","file":"unit-tests/source-code/ObfuscationResult.spec.ts","skipped":false,"dir":"test"},{"name":"should add source map to obfuscated code as base64 encoded string","suites":["ObfuscatedCode","getObfuscatedCode","source map is set, source map mode is `inline`"],"updatePoint":{"line":138,"column":81},"line":138,"code":"            it('should add source map to obfuscated code as base64 encoded string', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"unit-tests/source-code/ObfuscationResult.spec.ts","skipped":false,"dir":"test"},{"name":"should add source map import to obfuscated code","suites":["ObfuscatedCode","getObfuscatedCode","source map mode is `separate`"],"updatePoint":{"line":156,"column":63},"line":156,"code":"            it('should add source map import to obfuscated code', () => {\n                assert.match(obfuscatedCode, regExp);\n            });","file":"unit-tests/source-code/ObfuscationResult.spec.ts","skipped":false,"dir":"test"},{"name":"should not touch obfuscated code","suites":["ObfuscatedCode","getObfuscatedCode","source map mode is `separate`, `sourceMapUrl` is not set"],"updatePoint":{"line":172,"column":48},"line":172,"code":"            it('should not touch obfuscated code', () => {\n                assert.equal(obfuscatedCode, expectedObfuscatedCode);\n            });","file":"unit-tests/source-code/ObfuscationResult.spec.ts","skipped":false,"dir":"test"},{"name":"should return options object","suites":["ObfuscatedCode","getOptions"],"updatePoint":{"line":195,"column":40},"line":195,"code":"        it('should return options object', () => {\n            assert.deepEqual(options, expectedOptions);\n        });","file":"unit-tests/source-code/ObfuscationResult.spec.ts","skipped":false,"dir":"test"},{"name":"should return source code","suites":["SourceCode","getSourceCode","should return source code"],"updatePoint":{"line":18,"column":41},"line":18,"code":"            it('should return source code', () => {\n                assert.equal(sourceCode, expectedSourceCode);\n            });","file":"unit-tests/source-code/SourceCode.spec.ts","skipped":false,"dir":"test"},{"name":"should return source map","suites":["SourceCode","getSourceMap","should return source map"],"updatePoint":{"line":34,"column":40},"line":34,"code":"            it('should return source map', () => {\n                assert.equal(sourceMap, expectedSourceMap);\n            });","file":"unit-tests/source-code/SourceCode.spec.ts","skipped":false,"dir":"test"},{"name":"should throws an error when storage isn't initialized","suites":["ArrayStorage","initialize"],"updatePoint":{"line":56,"column":66},"line":56,"code":"        it('should throws an error when storage isn\\'t initialized', () => {\n            assert.throws(testFunc, expectedError);\n        });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return storage","suites":["ArrayStorage","getStorage"],"updatePoint":{"line":72,"column":33},"line":72,"code":"        it('should return storage', () => {\n            assert.instanceOf(arrayStorage, expectedInstanceOf);\n        });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return storage id","suites":["ArrayStorage","getStorageId"],"updatePoint":{"line":89,"column":36},"line":89,"code":"        it('should return storage id', () => {\n            assert.match(storageId, storageIdRegExp);\n        });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return value from storage by key","suites":["ArrayStorage","get","Variant #1: value exist"],"updatePoint":{"line":107,"column":55},"line":107,"code":"            it('should return value from storage by key', () => {\n                assert.equal(value, expectedValue);\n            });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return undefined if value does not exist in the storage","suites":["ArrayStorage","get","Variant #2: value isn't exist"],"updatePoint":{"line":123,"column":78},"line":123,"code":"            it('should return undefined if value does not exist in the storage', () => {\n                assert.equal(value, expectedValue);\n            });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return value from storage by key","suites":["ArrayStorage","getOrThrow","Variant #1: value exist"],"updatePoint":{"line":142,"column":55},"line":142,"code":"            it('should return value from storage by key', () => {\n                assert.equal(value, expectedValue);\n            });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error","suites":["ArrayStorage","getOrThrow","Variant #2: value isn't exist"],"updatePoint":{"line":158,"column":37},"line":158,"code":"            it('should throw an error', () => {\n                assert.throws(testFunc, expectedError);\n            });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return length of storage","suites":["ArrayStorage","getLength"],"updatePoint":{"line":176,"column":43},"line":176,"code":"        it('should return length of storage', () => {\n            assert.equal(storageLength, expectedStorageLength);\n        });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return key of string value","suites":["ArrayStorage","getKeyOf","Variant #1"],"updatePoint":{"line":192,"column":49},"line":192,"code":"            it('should return key of string value', () => {\n                assert.equal(key, storageKey);\n            });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return key of object if objects in `set` and `get` are two same objects","suites":["ArrayStorage","getKeyOf","Variant #2"],"updatePoint":{"line":209,"column":94},"line":209,"code":"            it('should return key of object if objects in `set` and `get` are two same objects', () => {\n                assert.equal(key, storageKey);\n            });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return `null` if objects in `set` and `get` are two different objects","suites":["ArrayStorage","getKeyOf","Variant #3"],"updatePoint":{"line":227,"column":92},"line":227,"code":"            it('should return `null` if objects in `set` and `get` are two different objects', () => {\n                assert.equal(key, expectedKey);\n            });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should set value to the storage","suites":["ArrayStorage","set"],"updatePoint":{"line":243,"column":43},"line":243,"code":"        it('should set value to the storage', () => {\n            assert.equal(value, storageValue);\n        });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should delete value from the storage by index","suites":["ArrayStorage","delete","Variant #1: value exist"],"updatePoint":{"line":272,"column":61},"line":272,"code":"            it('should delete value from the storage by index', () => {\n                assert.deepEqual(updatedStorage, expectedUpdatedStorage);\n            });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should update storage length","suites":["ArrayStorage","delete","Variant #1: value exist"],"updatePoint":{"line":276,"column":44},"line":276,"code":"            it('should update storage length', () => {\n                assert.deepEqual(updatedStorageLength, expectedUpdatedStorageLength);\n            });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return deleted value","suites":["ArrayStorage","delete","Variant #1: value exist"],"updatePoint":{"line":280,"column":43},"line":280,"code":"            it('should return deleted value', () => {\n                assert.equal(deletedValue, expectedDeletedValue);\n            });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should keep storage the same","suites":["ArrayStorage","delete","Variant #2: value isn't exist"],"updatePoint":{"line":309,"column":44},"line":309,"code":"            it('should keep storage the same', () => {\n                assert.deepEqual(updatedStorage, expectedUpdatedStorage);\n            });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should keep storage length","suites":["ArrayStorage","delete","Variant #2: value isn't exist"],"updatePoint":{"line":313,"column":42},"line":313,"code":"            it('should keep storage length', () => {\n                assert.deepEqual(updatedStorageLength, expectedUpdatedStorageLength);\n            });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return undefined","suites":["ArrayStorage","delete","Variant #2: value isn't exist"],"updatePoint":{"line":317,"column":39},"line":317,"code":"            it('should return undefined', () => {\n                assert.equal(deletedValue, expectedDeletedValue);\n            });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should merge two storages","suites":["ArrayStorage","mergeWith","Base merge"],"updatePoint":{"line":344,"column":41},"line":344,"code":"            it('should merge two storages', () => {\n                assert.deepEqual(array, expectedArray);\n            });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should update storage id","suites":["ArrayStorage","mergeWith","Merge with storage id"],"updatePoint":{"line":373,"column":40},"line":373,"code":"            it('should update storage id', () => {\n                assert.deepEqual(storageId, expectedStorageId);\n            });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should merge two storages","suites":["ArrayStorage","mergeWith","Merge with storage id"],"updatePoint":{"line":377,"column":41},"line":377,"code":"            it('should merge two storages', () => {\n                assert.deepEqual(array, expectedArray);\n            });","file":"unit-tests/storages/ArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should initialize storage with `identifierNamesStorage` option object","suites":["GlobalIdentifierNamesCacheStorage","initialize","Variant #1: `identifierNamesCache` option values is object"],"updatePoint":{"line":66,"column":85},"line":66,"code":"            it('should initialize storage with `identifierNamesStorage` option object', () => {\n                assert.deepEqual(dictionary, expectedDictionary);\n            });","file":"unit-tests/storages/identifier-names-cache/GlobalIdentifierNamesCacheStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should initialize storage with `identifierNamesStorage` option object","suites":["GlobalIdentifierNamesCacheStorage","initialize","Variant #2: `identifierNamesCache` option values is empty object"],"updatePoint":{"line":87,"column":85},"line":87,"code":"            it('should initialize storage with `identifierNamesStorage` option object', () => {\n                assert.deepEqual(dictionary, expectedDictionary);\n            });","file":"unit-tests/storages/identifier-names-cache/GlobalIdentifierNamesCacheStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should initialize storage with `identifierNamesStorage` option object","suites":["GlobalIdentifierNamesCacheStorage","initialize","Variant #3: `identifierNamesCache` option values is `null`"],"updatePoint":{"line":105,"column":85},"line":105,"code":"            it('should initialize storage with `identifierNamesStorage` option object', () => {\n                assert.deepEqual(dictionary, expectedDictionary);\n            });","file":"unit-tests/storages/identifier-names-cache/GlobalIdentifierNamesCacheStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should initialize storage with `identifierNamesStorage` option object","suites":["PropertyIdentifierNamesCacheStorage","initialize","Variant #1: `identifierNamesCache` option values is object"],"updatePoint":{"line":66,"column":85},"line":66,"code":"            it('should initialize storage with `identifierNamesStorage` option object', () => {\n                assert.deepEqual(dictionary, expectedDictionary);\n            });","file":"unit-tests/storages/identifier-names-cache/PropertyIdentifierNamesCacheStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should initialize storage with `identifierNamesStorage` option object","suites":["PropertyIdentifierNamesCacheStorage","initialize","Variant #2: `identifierNamesCache` option values is empty object"],"updatePoint":{"line":87,"column":85},"line":87,"code":"            it('should initialize storage with `identifierNamesStorage` option object', () => {\n                assert.deepEqual(dictionary, expectedDictionary);\n            });","file":"unit-tests/storages/identifier-names-cache/PropertyIdentifierNamesCacheStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should initialize storage with `identifierNamesStorage` option object","suites":["PropertyIdentifierNamesCacheStorage","initialize","Variant #3: `identifierNamesCache` option values is `null`"],"updatePoint":{"line":105,"column":85},"line":105,"code":"            it('should initialize storage with `identifierNamesStorage` option object', () => {\n                assert.deepEqual(dictionary, expectedDictionary);\n            });","file":"unit-tests/storages/identifier-names-cache/PropertyIdentifierNamesCacheStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should throws an error when storage isn't initialized","suites":["MapStorage","initialize"],"updatePoint":{"line":57,"column":66},"line":57,"code":"        it('should throws an error when storage isn\\'t initialized', () => {\n            assert.throws(testFunc, expectedError);\n        });","file":"unit-tests/storages/MapStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return storage","suites":["MapStorage","getStorage"],"updatePoint":{"line":73,"column":33},"line":73,"code":"        it('should return storage', () => {\n            assert.instanceOf(mapStorage, expectedInstanceOf);\n        });","file":"unit-tests/storages/MapStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return value from storage by key","suites":["MapStorage","get","Variant #1: value exist"],"updatePoint":{"line":91,"column":55},"line":91,"code":"            it('should return value from storage by key', () => {\n                assert.equal(value, expectedValue);\n            });","file":"unit-tests/storages/MapStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return undefined","suites":["MapStorage","get","Variant #2: value isn't exist"],"updatePoint":{"line":107,"column":39},"line":107,"code":"            it('should return undefined', () => {\n                assert.equal(value, expectedValue);\n            });","file":"unit-tests/storages/MapStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return value from storage by key","suites":["MapStorage","getOrThrow","Variant #1: value exist"],"updatePoint":{"line":126,"column":55},"line":126,"code":"            it('should return value from storage by key', () => {\n                assert.equal(value, expectedValue);\n            });","file":"unit-tests/storages/MapStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error","suites":["MapStorage","getOrThrow","Variant #2: value isn't exist"],"updatePoint":{"line":142,"column":37},"line":142,"code":"            it('should throw an error', () => {\n                assert.throws(testFunc, expectedError);\n            });","file":"unit-tests/storages/MapStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return length of storage","suites":["MapStorage","getLength"],"updatePoint":{"line":160,"column":43},"line":160,"code":"        it('should return length of storage', () => {\n            assert.equal(storageLength, expectedStorageLength);\n        });","file":"unit-tests/storages/MapStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return key of string value","suites":["MapStorage","getKeyOf","Variant #1"],"updatePoint":{"line":176,"column":49},"line":176,"code":"            it('should return key of string value', () => {\n                assert.equal(key, storageKey);\n            });","file":"unit-tests/storages/MapStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return key of object if objects in `set` and `get` are two same objects","suites":["MapStorage","getKeyOf","Variant #2"],"updatePoint":{"line":193,"column":94},"line":193,"code":"            it('should return key of object if objects in `set` and `get` are two same objects', () => {\n                assert.equal(key, storageKey);\n            });","file":"unit-tests/storages/MapStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return `null` if objects in `set` and `get` are two different objects","suites":["MapStorage","getKeyOf","Variant #3"],"updatePoint":{"line":211,"column":92},"line":211,"code":"            it('should return `null` if objects in `set` and `get` are two different objects', () => {\n                assert.equal(key, expectedKey);\n            });","file":"unit-tests/storages/MapStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return storage as dictionary","suites":["MapStorage","getStorageAsDictionary"],"updatePoint":{"line":231,"column":47},"line":231,"code":"        it('should return storage as dictionary', () => {\n            assert.deepEqual(storageAsDictionary, expectedDictionary);\n        });","file":"unit-tests/storages/MapStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return `true` if item is presenting in storage","suites":["MapStorage","has","Variant #1: item is presenting in storage"],"updatePoint":{"line":249,"column":69},"line":249,"code":"            it('should return `true` if item is presenting in storage', () => {\n                assert.equal(itemExistence, expectedItemExistence);\n            });","file":"unit-tests/storages/MapStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return `false` if item isn't presenting in storage","suites":["MapStorage","has","Variant #2: item isn't presenting in storage"],"updatePoint":{"line":265,"column":74},"line":265,"code":"            it('should return `false` if item isn\\'t presenting in storage', () => {\n                assert.equal(itemExistence, expectedItemExistence);\n            });","file":"unit-tests/storages/MapStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should set value to the storage","suites":["MapStorage","set"],"updatePoint":{"line":281,"column":43},"line":281,"code":"        it('should set value to the storage', () => {\n            assert.equal(value, storageValue);\n        });","file":"unit-tests/storages/MapStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should merge two storages","suites":["MapStorage","mergeWith"],"updatePoint":{"line":309,"column":37},"line":309,"code":"        it('should merge two storages', () => {\n            assert.deepEqual(array, expectedArray);\n        });","file":"unit-tests/storages/MapStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should build a key for the storage","suites":["LiteralNodesCacheStorage","buildKey"],"updatePoint":{"line":59,"column":46},"line":59,"code":"        it('should build a key for the storage', () => {\n            assert.equal(cacheKey, expectedCacheKey);\n        });","file":"unit-tests/storages/string-array-transformers/literal-nodes-cache/LiteralNodesCacheStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should check if can use cached value","suites":["LiteralNodesCacheStorage","shouldUseCachedValue","Encoding is not `rc4` and `stringArrayWrappersCount` option is disabled"],"updatePoint":{"line":92,"column":52},"line":92,"code":"            it('should check if can use cached value', () => {\n                assert.equal(result, expectedResult);\n            });","file":"unit-tests/storages/string-array-transformers/literal-nodes-cache/LiteralNodesCacheStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should check if can use cached value","suites":["LiteralNodesCacheStorage","shouldUseCachedValue","Encoding is `rc4` and `stringArrayWrappersCount` option is disabled"],"updatePoint":{"line":121,"column":52},"line":121,"code":"            it('should check if can use cached value', () => {\n                assert.equal(result, expectedResult);\n            });","file":"unit-tests/storages/string-array-transformers/literal-nodes-cache/LiteralNodesCacheStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should check if can use cached value","suites":["LiteralNodesCacheStorage","shouldUseCachedValue","Encoding is not `rc4` and `stringArrayWrappersCount` option is enabled"],"updatePoint":{"line":152,"column":52},"line":152,"code":"            it('should check if can use cached value', () => {\n                assert.equal(result, expectedResult);\n            });","file":"unit-tests/storages/string-array-transformers/literal-nodes-cache/LiteralNodesCacheStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should not make a collision between different source values with different keys","suites":["StringArrayStorage","rc4 encoded value collision fix"],"updatePoint":{"line":74,"column":91},"line":74,"code":"        it('should not make a collision between different source values with different keys', () => {\n            assert.equal(isCollisionHappened, false);\n        });","file":"unit-tests/storages/string-array-transformers/string-array/StringArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should not make a cache key collision between different encoded input strings","suites":["StringArrayStorage","Cache key collision when rc4 and base64 encoded values for different input strings are the same"],"updatePoint":{"line":112,"column":89},"line":112,"code":"        it('should not make a cache key collision between different encoded input strings', () => {\n            assert.equal(isCollisionHappened, false);\n        });","file":"unit-tests/storages/string-array-transformers/string-array/StringArrayStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return a last element from the stack","suites":["VisitedLexicalScopeNodesStackStorage","getLastElement"],"updatePoint":{"line":65,"column":55},"line":65,"code":"        it('should return a last element from the stack', () => {\n            assert.equal(lastElement, expectedLastElement);\n        });","file":"unit-tests/storages/string-array-transformers/visited-lexical-scope-nodes-stack/VisitedLexicalScopeNodesStackStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return a penultimate element from the stack","suites":["VisitedLexicalScopeNodesStackStorage","getPenultimateElement","Variant #1: three array elements"],"updatePoint":{"line":99,"column":66},"line":99,"code":"            it('should return a penultimate element from the stack', () => {\n                assert.equal(penultimateElement, expectedSecondElement);\n            });","file":"unit-tests/storages/string-array-transformers/visited-lexical-scope-nodes-stack/VisitedLexicalScopeNodesStackStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return a penultimate element from the stack","suites":["VisitedLexicalScopeNodesStackStorage","getPenultimateElement","Variant #2: one array element"],"updatePoint":{"line":121,"column":66},"line":121,"code":"            it('should return a penultimate element from the stack', () => {\n                assert.equal(penultimateElement, expectedPenultimateElement);\n            });","file":"unit-tests/storages/string-array-transformers/visited-lexical-scope-nodes-stack/VisitedLexicalScopeNodesStackStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return a penultimate element from the stack","suites":["VisitedLexicalScopeNodesStackStorage","getPenultimateElement","Variant #3: empty array"],"updatePoint":{"line":137,"column":66},"line":137,"code":"            it('should return a penultimate element from the stack', () => {\n                assert.equal(penultimateElement, expectedPenultimateElement);\n            });","file":"unit-tests/storages/string-array-transformers/visited-lexical-scope-nodes-stack/VisitedLexicalScopeNodesStackStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should push a new element into the storage","suites":["VisitedLexicalScopeNodesStackStorage","push"],"updatePoint":{"line":169,"column":54},"line":169,"code":"        it('should push a new element into the storage', () => {\n            assert.deepEqual(storage, expectedStorage);\n        });","file":"unit-tests/storages/string-array-transformers/visited-lexical-scope-nodes-stack/VisitedLexicalScopeNodesStackStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should pop a last element from the storage","suites":["VisitedLexicalScopeNodesStackStorage","pop","Variant #1: few elements"],"updatePoint":{"line":204,"column":58},"line":204,"code":"            it('should pop a last element from the storage', () => {\n                assert.deepEqual(storage, expectedStorage);\n            });","file":"unit-tests/storages/string-array-transformers/visited-lexical-scope-nodes-stack/VisitedLexicalScopeNodesStackStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return a popped element from the storage","suites":["VisitedLexicalScopeNodesStackStorage","pop","Variant #1: few elements"],"updatePoint":{"line":208,"column":63},"line":208,"code":"            it('should return a popped element from the storage', () => {\n                assert.equal(poppedElement, expectedPoppedElement);\n            });","file":"unit-tests/storages/string-array-transformers/visited-lexical-scope-nodes-stack/VisitedLexicalScopeNodesStackStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should pop a last element from the storage","suites":["VisitedLexicalScopeNodesStackStorage","pop","Variant #2: single element"],"updatePoint":{"line":234,"column":58},"line":234,"code":"            it('should pop a last element from the storage', () => {\n                assert.deepEqual(storage, expectedStorage);\n            });","file":"unit-tests/storages/string-array-transformers/visited-lexical-scope-nodes-stack/VisitedLexicalScopeNodesStackStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return a popped element from the storage","suites":["VisitedLexicalScopeNodesStackStorage","pop","Variant #2: single element"],"updatePoint":{"line":238,"column":63},"line":238,"code":"            it('should return a popped element from the storage', () => {\n                assert.equal(poppedElement, expectedPoppedElement);\n            });","file":"unit-tests/storages/string-array-transformers/visited-lexical-scope-nodes-stack/VisitedLexicalScopeNodesStackStorage.spec.ts","skipped":false,"dir":"test"},{"name":"should return array with range of numbers","suites":["ArrayUtils","createWithRange","range length more than 0"],"updatePoint":{"line":33,"column":57},"line":33,"code":"            it('should return array with range of numbers', () => {\n                assert.deepEqual(array, expectedArray);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return empty array","suites":["ArrayUtils","createWithRange","range length is 0"],"updatePoint":{"line":48,"column":41},"line":48,"code":"            it('should return empty array', () => {\n                assert.deepEqual(array, expectedArray);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return empty array","suites":["ArrayUtils","createWithRange","range length less than 0"],"updatePoint":{"line":63,"column":41},"line":63,"code":"            it('should return empty array', () => {\n                assert.deepEqual(array, expectedArray);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return array with range of strings","suites":["ArrayUtils","fillWithRange","range length more than 0"],"updatePoint":{"line":88,"column":57},"line":88,"code":"            it('should return array with range of strings', () => {\n                assert.deepEqual(array, expectedArray);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return empty array","suites":["ArrayUtils","fillWithRange","range length is 0"],"updatePoint":{"line":103,"column":41},"line":103,"code":"            it('should return empty array', () => {\n                assert.deepEqual(array, expectedArray);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return empty array","suites":["ArrayUtils","fillWithRange","range length less than 0"],"updatePoint":{"line":118,"column":41},"line":118,"code":"            it('should return empty array', () => {\n                assert.deepEqual(array, expectedArray);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return null if array is empty","suites":["ArrayUtils","findMostOccurringElement","empty array"],"updatePoint":{"line":135,"column":52},"line":135,"code":"            it('should return null if array is empty', () => {\n                assert.equal(mostOccurringElement, expectedMostOccurringElement);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return most occurring element","suites":["ArrayUtils","findMostOccurringElement","one elements is most occurring"],"updatePoint":{"line":150,"column":52},"line":150,"code":"            it('should return most occurring element', () => {\n                assert.equal(mostOccurringElement, expectedMostOccurringElement);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return first most occurring element","suites":["ArrayUtils","findMostOccurringElement","few elements are most occurring"],"updatePoint":{"line":165,"column":58},"line":165,"code":"            it('should return first most occurring element', () => {\n                assert.equal(mostOccurringElement, expectedMostOccurringElement);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return undefined if array is empty","suites":["ArrayUtils","getLastElement","empty array"],"updatePoint":{"line":182,"column":57},"line":182,"code":"            it('should return undefined if array is empty', () => {\n                assert.equal(lastElement, expectedLastElement);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return first element for array with length: `1`","suites":["ArrayUtils","getLastElement","array length: `1`"],"updatePoint":{"line":197,"column":70},"line":197,"code":"            it('should return first element for array with length: `1`', () => {\n                assert.equal(lastElement, expectedLastElement);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return last element for array with length: `3`","suites":["ArrayUtils","getLastElement","array length: `3`"],"updatePoint":{"line":212,"column":69},"line":212,"code":"            it('should return last element for array with length: `3`', () => {\n                assert.equal(lastElement, expectedLastElement);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return undefined if array is empty","suites":["ArrayUtils","getLastElementByIndex","empty array"],"updatePoint":{"line":229,"column":57},"line":229,"code":"            it('should return undefined if array is empty', () => {\n                assert.equal(lastElement, expectedLastElement);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return undefined","suites":["ArrayUtils","getLastElementByIndex","array length: `1` and index is out of array boundary"],"updatePoint":{"line":244,"column":39},"line":244,"code":"            it('should return undefined', () => {\n                assert.equal(lastElement, expectedLastElement);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return element with a correct index","suites":["ArrayUtils","getLastElementByIndex","array length: `3` and index is `0`"],"updatePoint":{"line":259,"column":58},"line":259,"code":"            it('should return element with a correct index', () => {\n                assert.equal(lastElement, expectedLastElement);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return element with a correct index","suites":["ArrayUtils","getLastElementByIndex","array length: `3` and index is `1`"],"updatePoint":{"line":274,"column":58},"line":274,"code":"            it('should return element with a correct index', () => {\n                assert.equal(lastElement, expectedLastElement);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should rotate (shift) array by a given value","suites":["ArrayUtils","rotate","value is not 0"],"updatePoint":{"line":296,"column":60},"line":296,"code":"            it('should rotate (shift) array by a given value', () => {\n                assert.deepEqual(rotatedArray, expectedArray);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"shouldn't rotate array","suites":["ArrayUtils","rotate","value equals or less 0"],"updatePoint":{"line":309,"column":39},"line":309,"code":"            it('shouldn\\'t rotate array', () => {\n                assert.deepEqual(rotatedArray, expectedArray);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw exception if array is empty","suites":["ArrayUtils","rotate","empty array"],"updatePoint":{"line":325,"column":56},"line":325,"code":"            it('should throw exception if array is empty', () => {\n                assert.throws(testFunc, expectedError);\n            });","file":"unit-tests/utils/ArrayUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should create a base-64 encoded string from a given string","suites":["CryptUtils","btoa","Variant #1: basic"],"updatePoint":{"line":36,"column":73},"line":36,"code":"           it('should create a base-64 encoded string from a given string', () => {\n               assert.equal(encodedString, expectedEncodedString);\n           });","file":"unit-tests/utils/CryptUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should create encoded string that can be successfully decoded","suites":["CryptUtils","btoa","Variant #1: basic"],"updatePoint":{"line":40,"column":76},"line":40,"code":"           it('should create encoded string that can be successfully decoded', () => {\n               assert.equal(decodedString, expectedDecodedString);\n           });","file":"unit-tests/utils/CryptUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should create a base-64 encoded string from a given string with padding characters","suites":["CryptUtils","btoa","Variant #2: padding characters"],"updatePoint":{"line":57,"column":98},"line":57,"code":"            it('should create a base-64 encoded string from a given string with padding characters', () => {\n                assert.equal(encodedString, expectedEncodedString);\n            });","file":"unit-tests/utils/CryptUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should create encoded string that can be successfully decoded","suites":["CryptUtils","btoa","Variant #2: padding characters"],"updatePoint":{"line":61,"column":77},"line":61,"code":"            it('should create encoded string that can be successfully decoded', () => {\n                assert.equal(decodedString, expectedDecodedString);\n            });","file":"unit-tests/utils/CryptUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should create a base-64 encoded string from a given string","suites":["CryptUtils","btoa","Variant #3: cyrillic string"],"updatePoint":{"line":78,"column":74},"line":78,"code":"            it('should create a base-64 encoded string from a given string', () => {\n                assert.equal(encodedString, expectedEncodedString);\n            });","file":"unit-tests/utils/CryptUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should create encoded string with a cyrillic characters that can be successfully decoded","suites":["CryptUtils","btoa","Variant #3: cyrillic string"],"updatePoint":{"line":82,"column":104},"line":82,"code":"            it('should create encoded string with a cyrillic characters that can be successfully decoded', () => {\n                assert.equal(decodedString, expectedDecodedString);\n            });","file":"unit-tests/utils/CryptUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should create hidden string with length equal or bigger than given length","suites":["CryptUtils","hideString","hidden string length check"],"updatePoint":{"line":108,"column":89},"line":108,"code":"            it('should create hidden string with length equal or bigger than given length', () => {\n                assert.isTrue(hiddenStringActualLength > originalStringActualLength);\n            });","file":"unit-tests/utils/CryptUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return a hidden string with the original string within","suites":["CryptUtils","hideString","hidden string content"],"updatePoint":{"line":122,"column":77},"line":122,"code":"            it('should return a hidden string with the original string within', () => {\n                assert.equal(hiddenStringWithoutDiff, originalString);\n            });","file":"unit-tests/utils/CryptUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should encode string using the rc4 algorithm","suites":["CryptUtils","rc4"],"updatePoint":{"line":140,"column":56},"line":140,"code":"        it('should encode string using the rc4 algorithm', () => {\n            assert.notEqual(encodedString, string);\n        });","file":"unit-tests/utils/CryptUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should encode and successfully decode string using the rc4 algorithm","suites":["CryptUtils","rc4"],"updatePoint":{"line":144,"column":80},"line":144,"code":"        it('should encode and successfully decode string using the rc4 algorithm', () => {\n            assert.equal(decodedString, string);\n        });","file":"unit-tests/utils/CryptUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should create a base-64 encoded string with swapped alphabet from a given string","suites":["CryptUtilsStringArray","btoa","Variant #1: basic"],"updatePoint":{"line":35,"column":96},"line":35,"code":"            it('should create a base-64 encoded string with swapped alphabet from a given string', () => {\n                assert.equal(string, expectedString);\n            });","file":"unit-tests/utils/CryptUtilsStringArray.spec.ts","skipped":false,"dir":"test"},{"name":"should create a base-64 encoded string from a given string without padding characters","suites":["CryptUtilsStringArray","btoa","Variant #2: no padding characters"],"updatePoint":{"line":49,"column":101},"line":49,"code":"            it('should create a base-64 encoded string from a given string without padding characters', () => {\n                assert.equal(string, expectedString);\n            });","file":"unit-tests/utils/CryptUtilsStringArray.spec.ts","skipped":false,"dir":"test"},{"name":"should encode string using the rc4 algorithm","suites":["CryptUtilsStringArray","rc4"],"updatePoint":{"line":67,"column":56},"line":67,"code":"        it('should encode string using the rc4 algorithm', () => {\n            assert.notEqual(encodedString, string);\n        });","file":"unit-tests/utils/CryptUtilsStringArray.spec.ts","skipped":false,"dir":"test"},{"name":"should encode and successfully decode string using the rc4 algorithm","suites":["CryptUtilsStringArray","rc4"],"updatePoint":{"line":71,"column":80},"line":71,"code":"        it('should encode and successfully decode string using the rc4 algorithm', () => {\n            assert.equal(decodedString, string);\n        });","file":"unit-tests/utils/CryptUtilsStringArray.spec.ts","skipped":false,"dir":"test"},{"name":"should return a string where all characters are encoded","suites":["EscapeSequenceEncoder","encode","Variant #1: default"],"updatePoint":{"line":34,"column":71},"line":34,"code":"            it('should return a string where all characters are encoded', () => {\n                assert.equal(actualString, expectedString);\n            });","file":"unit-tests/utils/EscapeSequenceEncoder.spec.ts","skipped":false,"dir":"test"},{"name":"should return a string where all `escape sequences` are encoded","suites":["EscapeSequenceEncoder","encode","Variant #2: escape `escape sequences`"],"updatePoint":{"line":49,"column":79},"line":49,"code":"            it('should return a string where all `escape sequences` are encoded', () => {\n                assert.equal(actualString, expectedString);\n            });","file":"unit-tests/utils/EscapeSequenceEncoder.spec.ts","skipped":false,"dir":"test"},{"name":"should return a string where all non-ascii characters are encoded","suites":["EscapeSequenceEncoder","encode","Variant #3: non-ascii character`"],"updatePoint":{"line":64,"column":81},"line":64,"code":"            it('should return a string where all non-ascii characters are encoded', () => {\n                assert.equal(actualString, expectedString);\n            });","file":"unit-tests/utils/EscapeSequenceEncoder.spec.ts","skipped":false,"dir":"test"},{"name":"should return a string where all unicode control characters are encoded","suites":["EscapeSequenceEncoder","encode","Variant #4: unicode control character`"],"updatePoint":{"line":79,"column":87},"line":79,"code":"            it('should return a string where all unicode control characters are encoded', () => {\n                assert.equal(actualString, expectedString);\n            });","file":"unit-tests/utils/EscapeSequenceEncoder.spec.ts","skipped":false,"dir":"test"},{"name":"should topologically linear sort items","suites":["EscapeSequenceEncoder","encode","Base sort","Variant #1: Base linear sort"],"updatePoint":{"line":51,"column":58},"line":51,"code":"                it('should topologically linear sort items', () => {\n                    assert.deepEqual(sortedItems, expectedSortedItems);\n                });","file":"unit-tests/utils/LevelledTopologicalSorter.spec.ts","skipped":false,"dir":"test"},{"name":"should topologically linear sort items","suites":["EscapeSequenceEncoder","encode","Base sort","Variant #2: Base sort with grouping"],"updatePoint":{"line":69,"column":58},"line":69,"code":"                it('should topologically linear sort items', () => {\n                    assert.deepEqual(sortedItems, expectedSortedItems);\n                });","file":"unit-tests/utils/LevelledTopologicalSorter.spec.ts","skipped":false,"dir":"test"},{"name":"should topologically linear sort items","suites":["EscapeSequenceEncoder","encode","Sort without relations","Variant #1: Should sort items without relations"],"updatePoint":{"line":101,"column":58},"line":101,"code":"                it('should topologically linear sort items', () => {\n                    assert.deepEqual(sortedItems, expectedSortedItems);\n                });","file":"unit-tests/utils/LevelledTopologicalSorter.spec.ts","skipped":false,"dir":"test"},{"name":"should topologically linear sort items","suites":["EscapeSequenceEncoder","encode","Sort without relations","Variant #2: Should sort items without relations with grouping"],"updatePoint":{"line":117,"column":58},"line":117,"code":"                it('should topologically linear sort items', () => {\n                    assert.deepEqual(sortedItems, expectedSortedItems);\n                });","file":"unit-tests/utils/LevelledTopologicalSorter.spec.ts","skipped":false,"dir":"test"},{"name":"should topologically linear sort items","suites":["EscapeSequenceEncoder","encode","Circular relations"],"updatePoint":{"line":133,"column":54},"line":133,"code":"            it('should topologically linear sort items', () => {\n                assert.throws(testFunc, Error);\n            });","file":"unit-tests/utils/LevelledTopologicalSorter.spec.ts","skipped":false,"dir":"test"},{"name":"should create a string with hexadecimal value from a given decimal number","suites":["NumberUtils","toHex","Variant #1: number `0`"],"updatePoint":{"line":19,"column":89},"line":19,"code":"            it('should create a string with hexadecimal value from a given decimal number', () => {\n                assert.equal(hexString, expectedHexString);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should create a string with hexadecimal value from a given decimal number","suites":["NumberUtils","toHex","Variant #2: number `10`"],"updatePoint":{"line":34,"column":89},"line":34,"code":"            it('should create a string with hexadecimal value from a given decimal number', () => {\n                assert.equal(hexString, expectedHexString);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should create a string with hexadecimal value from a given decimal number","suites":["NumberUtils","toHex","Variant #3: number `17`"],"updatePoint":{"line":49,"column":89},"line":49,"code":"            it('should create a string with hexadecimal value from a given decimal number', () => {\n                assert.equal(hexString, expectedHexString);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should create a string with hexadecimal value from a given decimal number","suites":["NumberUtils","toHex","Variant #4: number `536870912`"],"updatePoint":{"line":64,"column":89},"line":64,"code":"            it('should create a string with hexadecimal value from a given decimal number', () => {\n                assert.equal(hexString, expectedHexString);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should create a string with hexadecimal value from a given bigint number","suites":["NumberUtils","toHex","Variant #5: bigint number `10n`"],"updatePoint":{"line":80,"column":88},"line":80,"code":"            it('should create a string with hexadecimal value from a given bigint number', () => {\n                assert.equal(hexString, expectedHexString);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should extract integer and decimal parts","suites":["NumberUtils","extractIntegerAndDecimalParts","Variant #1: number `0`"],"updatePoint":{"line":97,"column":56},"line":97,"code":"            it('should extract integer and decimal parts', () => {\n                assert.deepEqual(parts, expectedParts);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should extract integer and decimal parts","suites":["NumberUtils","extractIntegerAndDecimalParts","Variant #2: number `10`"],"updatePoint":{"line":112,"column":56},"line":112,"code":"            it('should extract integer and decimal parts', () => {\n                assert.deepEqual(parts, expectedParts);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should extract integer and decimal parts","suites":["NumberUtils","extractIntegerAndDecimalParts","Variant #3: number `-17`"],"updatePoint":{"line":127,"column":56},"line":127,"code":"            it('should extract integer and decimal parts', () => {\n                assert.deepEqual(parts, expectedParts);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should extract integer and decimal parts","suites":["NumberUtils","extractIntegerAndDecimalParts","Variant #4: number `0.0000000001`"],"updatePoint":{"line":142,"column":56},"line":142,"code":"            it('should extract integer and decimal parts', () => {\n                assert.deepEqual(parts, expectedParts);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return an initial number after sum of extracted parts","suites":["NumberUtils","extractIntegerAndDecimalParts","Variant #4: number `0.0000000001`"],"updatePoint":{"line":146,"column":76},"line":146,"code":"            it('should return an initial number after sum of extracted parts', () => {\n                assert.equal(number, parts[0] + parts[1]!);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should extract integer and decimal parts (with inaccuracy of float numbers)","suites":["NumberUtils","extractIntegerAndDecimalParts","Variant #5: number `10.0002`"],"updatePoint":{"line":161,"column":91},"line":161,"code":"            it('should extract integer and decimal parts (with inaccuracy of float numbers)', () => {\n                assert.deepEqual(parts, expectedParts);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return an initial number after sum of extracted parts","suites":["NumberUtils","extractIntegerAndDecimalParts","Variant #5: number `10.0002`"],"updatePoint":{"line":165,"column":76},"line":165,"code":"            it('should return an initial number after sum of extracted parts', () => {\n                assert.equal(number, parts[0] + parts[1]!);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should extract integer and decimal parts","suites":["NumberUtils","extractIntegerAndDecimalParts","Variant #6: number `1e-13`"],"updatePoint":{"line":180,"column":56},"line":180,"code":"            it('should extract integer and decimal parts', () => {\n                assert.deepEqual(parts, expectedParts);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return an initial number after sum of extracted parts","suites":["NumberUtils","extractIntegerAndDecimalParts","Variant #6: number `1e-13`"],"updatePoint":{"line":184,"column":76},"line":184,"code":"            it('should return an initial number after sum of extracted parts', () => {\n                assert.equal(number, parts[0] + parts[1]!);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should extract integer and decimal parts","suites":["NumberUtils","extractIntegerAndDecimalParts","Variant #7: number `-1e-100`"],"updatePoint":{"line":199,"column":56},"line":199,"code":"            it('should extract integer and decimal parts', () => {\n                assert.deepEqual(parts, expectedParts);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return an initial number after sum of extracted parts","suites":["NumberUtils","extractIntegerAndDecimalParts","Variant #7: number `-1e-100`"],"updatePoint":{"line":203,"column":76},"line":203,"code":"            it('should return an initial number after sum of extracted parts', () => {\n                assert.equal(number, parts[0] + parts[1]!);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return true","suites":["NumberUtils","isCeil","given number is a ceil"],"updatePoint":{"line":220,"column":34},"line":220,"code":"            it('should return true', () => {\n                assert.equal(result, expectedResult);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return false","suites":["NumberUtils","isCeil","given number is a float"],"updatePoint":{"line":235,"column":35},"line":235,"code":"            it('should return false', () => {\n                assert.equal(result, expectedResult);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return true","suites":["NumberUtils","isCeil","bigint number"],"updatePoint":{"line":251,"column":34},"line":251,"code":"            it('should return true', () => {\n                assert.equal(result, expectedResult);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return true","suites":["NumberUtils","isPositive","Variant #1: positive integer"],"updatePoint":{"line":268,"column":34},"line":268,"code":"            it('should return true', () => {\n                assert.equal(result, expectedResult);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return true","suites":["NumberUtils","isPositive","Variant #2: positive zero"],"updatePoint":{"line":283,"column":34},"line":283,"code":"            it('should return true', () => {\n                assert.equal(result, expectedResult);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return false","suites":["NumberUtils","isPositive","Variant #3: negative integer"],"updatePoint":{"line":298,"column":35},"line":298,"code":"            it('should return false', () => {\n                assert.equal(result, expectedResult);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return false","suites":["NumberUtils","isPositive","Variant #4: negative zero"],"updatePoint":{"line":313,"column":35},"line":313,"code":"            it('should return false', () => {\n                assert.equal(result, expectedResult);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error","suites":["NumberUtils","isPositive","Variant #5: NaN"],"updatePoint":{"line":327,"column":37},"line":327,"code":"            it('should throw an error', () => {\n                assert.throw(testFunc, 'Given value is NaN');\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return false","suites":["NumberUtils","isUnsafeNumber","Positive number","Variant #1: positive small safe integer"],"updatePoint":{"line":345,"column":39},"line":345,"code":"                it('should return false', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return false","suites":["NumberUtils","isUnsafeNumber","Positive number","Variant #2: positive big safe integer"],"updatePoint":{"line":360,"column":39},"line":360,"code":"                it('should return false', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return true","suites":["NumberUtils","isUnsafeNumber","Positive number","Variant #3: positive unsafe integer"],"updatePoint":{"line":375,"column":38},"line":375,"code":"                it('should return true', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return false","suites":["NumberUtils","isUnsafeNumber","Negative number","Variant #1: negative small safe integer"],"updatePoint":{"line":392,"column":39},"line":392,"code":"                it('should return false', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return false","suites":["NumberUtils","isUnsafeNumber","Negative number","Variant #2: negative big safe integer"],"updatePoint":{"line":407,"column":39},"line":407,"code":"                it('should return false', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return true","suites":["NumberUtils","isUnsafeNumber","Negative number","Variant #3: negative unsafe integer"],"updatePoint":{"line":422,"column":38},"line":422,"code":"                it('should return true', () => {\n                    assert.equal(result, expectedResult);\n                });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error","suites":["NumberUtils","isUnsafeNumber","NaN"],"updatePoint":{"line":437,"column":37},"line":437,"code":"            it('should throw an error', () => {\n                assert.throw(testFunc, 'Given value is NaN');\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return factors of a number","suites":["NumberUtils","getFactors","Positive numbers","Variant #1: positive number `1`"],"updatePoint":{"line":458,"column":53},"line":458,"code":"                it('should return factors of a number', () => {\n                    assert.deepEqual(factors, expectedFactors);\n                });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return factors of a number","suites":["NumberUtils","getFactors","Positive numbers","Variant #2: positive number `2`"],"updatePoint":{"line":478,"column":53},"line":478,"code":"                it('should return factors of a number', () => {\n                    assert.deepEqual(factors, expectedFactors);\n                });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return factors of a number","suites":["NumberUtils","getFactors","Positive numbers","Variant #3: positive number `100`"],"updatePoint":{"line":512,"column":53},"line":512,"code":"                it('should return factors of a number', () => {\n                    assert.deepEqual(factors, expectedFactors);\n                });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return factors of a number","suites":["NumberUtils","getFactors","Positive numbers","Variant #4: positive number `9007199254740991`"],"updatePoint":{"line":544,"column":53},"line":544,"code":"                it('should return factors of a number', () => {\n                    assert.deepEqual(factors, expectedFactors);\n                });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return factors of a number","suites":["NumberUtils","getFactors","Negative numbers","Variant #1: negative number `-1`"],"updatePoint":{"line":564,"column":53},"line":564,"code":"                it('should return factors of a number', () => {\n                    assert.deepEqual(factors, expectedFactors);\n                });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return factors of a number","suites":["NumberUtils","getFactors","Negative numbers","Variant #2: negative number `-2`"],"updatePoint":{"line":584,"column":53},"line":584,"code":"                it('should return factors of a number', () => {\n                    assert.deepEqual(factors, expectedFactors);\n                });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return factors of a number","suites":["NumberUtils","getFactors","Negative numbers","Variant #3: negative number `-100`"],"updatePoint":{"line":618,"column":53},"line":618,"code":"                it('should return factors of a number', () => {\n                    assert.deepEqual(factors, expectedFactors);\n                });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return factors of a number","suites":["NumberUtils","getFactors","Negative numbers","Variant #4: negative number `-9007199254740991`"],"updatePoint":{"line":650,"column":53},"line":650,"code":"                it('should return factors of a number', () => {\n                    assert.deepEqual(factors, expectedFactors);\n                });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should throw an error","suites":["NumberUtils","getFactors","zero number"],"updatePoint":{"line":665,"column":37},"line":665,"code":"            it('should throw an error', () => {\n                assert.throw(testFunc, Error);\n            });","file":"unit-tests/utils/NumberUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should handle input path ending (or not ending) with forward slash","suites":["ObfuscatedCodeFileUtils"],"updatePoint":{"line":13,"column":72},"line":13,"code":"  it('should handle input path ending (or not ending) with forward slash', () => {\n    const result = util.getOutputCodePath('src/cli/app.js');\n    expect(result).equals('src/cli/dist/app.js');\n  });","file":"unit-tests/utils/ObfuscatedCodeFileUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return a random integer in allowed values range","suites":["RandomGenerator","getRandomIntegerExcluding","Variant #1: avoid excluded values"],"updatePoint":{"line":44,"column":70},"line":44,"code":"            it('should return a random integer in allowed values range', () => {\n                assert.isTrue(isRandomIntegerInAllowedValuesRange);\n            });","file":"unit-tests/utils/RandomGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should generate min values","suites":["RandomGenerator","getRandomIntegerExcluding","Variant #2: values boundaries"],"updatePoint":{"line":83,"column":42},"line":83,"code":"            it('should generate min values', () => {\n                assert.closeTo(minValueChance, expectedValueChance, delta);\n            });","file":"unit-tests/utils/RandomGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should generate max values","suites":["RandomGenerator","getRandomIntegerExcluding","Variant #2: values boundaries"],"updatePoint":{"line":87,"column":42},"line":87,"code":"            it('should generate max values', () => {\n                assert.closeTo(maxValueChance, expectedValueChance, delta);\n            });","file":"unit-tests/utils/RandomGenerator.spec.ts","skipped":false,"dir":"test"},{"name":"should return undefined if set is empty","suites":["SetUtils","getLastElement","empty set"],"updatePoint":{"line":33,"column":55},"line":33,"code":"            it('should return undefined if set is empty', () => {\n                assert.equal(lastElement, expectedLastElement);\n            });","file":"unit-tests/utils/SetUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return first element for set with length: `1`","suites":["SetUtils","getLastElement","set length: `1`"],"updatePoint":{"line":48,"column":68},"line":48,"code":"            it('should return first element for set with length: `1`', () => {\n                assert.equal(lastElement, expectedLastElement);\n            });","file":"unit-tests/utils/SetUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return last element for set with length: `3`","suites":["SetUtils","getLastElement","set length: `3`"],"updatePoint":{"line":63,"column":67},"line":63,"code":"            it('should return last element for set with length: `3`', () => {\n                assert.equal(lastElement, expectedLastElement);\n            });","file":"unit-tests/utils/SetUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should return last element for changed set with length: `2`","suites":["SetUtils","getLastElement","changed set with length: `2`"],"updatePoint":{"line":82,"column":75},"line":82,"code":"            it('should return last element for changed set with length: `2`', () => {\n                assert.equal(lastElement, expectedLastElement);\n            });","file":"unit-tests/utils/SetUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should escape js string","suites":["StringUtils","escapeJsString","Variant #1: single quotes"],"updatePoint":{"line":18,"column":39},"line":18,"code":"            it('should escape js string', () => {\n                assert.equal(escapedJsString, expectedEscapedJsString);\n            });","file":"unit-tests/utils/StringUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should escape js string","suites":["StringUtils","escapeJsString","Variant #2: double quotes"],"updatePoint":{"line":32,"column":39},"line":32,"code":"            it('should escape js string', () => {\n                assert.equal(escapedJsString, expectedEscapedJsString);\n            });","file":"unit-tests/utils/StringUtils.spec.ts","skipped":false,"dir":"test"},{"name":"should extract domain from the given URL","suites":["Utils","extractDomainFrom","Variant #1: simple url"],"updatePoint":{"line":17,"column":56},"line":17,"code":"            it('should extract domain from the given URL', () => {\n                assert.equal(domain, expectedDomain);\n            });","file":"unit-tests/utils/Utils.spec.ts","skipped":false,"dir":"test"},{"name":"should extract domain from the given URL","suites":["Utils","extractDomainFrom","Variant #2: url with `www` part"],"updatePoint":{"line":32,"column":56},"line":32,"code":"            it('should extract domain from the given URL', () => {\n                assert.equal(domain, expectedDomain);\n            });","file":"unit-tests/utils/Utils.spec.ts","skipped":false,"dir":"test"},{"name":"should extract domain from the given URL","suites":["Utils","extractDomainFrom","Variant #3: url with `https` protocol and port"],"updatePoint":{"line":47,"column":56},"line":47,"code":"            it('should extract domain from the given URL', () => {\n                assert.equal(domain, expectedDomain);\n            });","file":"unit-tests/utils/Utils.spec.ts","skipped":false,"dir":"test"},{"name":"should extract domain from the given URL","suites":["Utils","extractDomainFrom","Variant #4: protocol-wide url and route"],"updatePoint":{"line":62,"column":56},"line":62,"code":"            it('should extract domain from the given URL', () => {\n                assert.equal(domain, expectedDomain);\n            });","file":"unit-tests/utils/Utils.spec.ts","skipped":false,"dir":"test"},{"name":"should extract domain from the given URL","suites":["Utils","extractDomainFrom","Variant #5: protocol-wide url, `localhost` and port"],"updatePoint":{"line":77,"column":56},"line":77,"code":"            it('should extract domain from the given URL', () => {\n                assert.equal(domain, expectedDomain);\n            });","file":"unit-tests/utils/Utils.spec.ts","skipped":false,"dir":"test"},{"name":"should build version message","suites":["Utils","buildVersionMessage","Variant #1: version and build timestamp are set"],"updatePoint":{"line":93,"column":44},"line":93,"code":"            it('should build version message', () => {\n                assert.equal(versionMessage, expectedVersionMessage);\n            });","file":"unit-tests/utils/Utils.spec.ts","skipped":false,"dir":"test"},{"name":"should build version message","suites":["Utils","buildVersionMessage","Variant #2: version is not set set"],"updatePoint":{"line":107,"column":44},"line":107,"code":"            it('should build version message', () => {\n                assert.equal(versionMessage, expectedVersionMessage);\n            });","file":"unit-tests/utils/Utils.spec.ts","skipped":false,"dir":"test"},{"name":"should build version message","suites":["Utils","buildVersionMessage","Variant #3: build timestamp is not set set"],"updatePoint":{"line":121,"column":44},"line":121,"code":"            it('should build version message', () => {\n                assert.equal(versionMessage, expectedVersionMessage);\n            });","file":"unit-tests/utils/Utils.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct identifiers prefix","suites":["Utils","getIdentifiersPrefixForMultipleSources","Variant #1: should get identifiers prefix for identifiers prefix from options"],"updatePoint":{"line":140,"column":56},"line":140,"code":"            it('should return correct identifiers prefix', () => {\n                assert.equal(identifiersPrefix, expectedIdentifiersPrefix);\n            });","file":"unit-tests/utils/Utils.spec.ts","skipped":false,"dir":"test"},{"name":"should return correct identifiers prefix","suites":["Utils","getIdentifiersPrefixForMultipleSources","Variant #2: should get identifiers prefix for base identifiers prefix for multiple sources"],"updatePoint":{"line":157,"column":56},"line":157,"code":"            it('should return correct identifiers prefix', () => {\n                assert.equal(identifiersPrefix, expectedIdentifiersPrefix);\n            });","file":"unit-tests/utils/Utils.spec.ts","skipped":false,"dir":"test"}]}