{"repo":"vuejs/vuex","url":"https://github.com/vuejs/vuex","branch":"dev","configs":[{"package":"vuex","lang":"js","dir":"test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"cart app","suites":["e2e/cart"],"updatePoint":{"line":10,"column":16,"index":192},"line":10,"code":"  test('cart app', async () => {\n    await page().goto('http://localhost:8080/shopping-cart/');\n    await sleep(120); // api simulation\n\n    expect(await count('li')).toBe(3);\n    expect(await count('.cart button[disabled]')).toBe(1);\n    expect(await text('li:nth-child(1)')).toContain('iPad 4 Mini');\n    expect(await text('.cart')).toContain('Please add some products to cart');\n    expect(await text('.cart')).toContain('Total: $0.00');\n    await click('li:nth-child(1) button');\n    expect(await text('.cart')).toContain('iPad 4 Mini - $500.01 x 1');\n    expect(await text('.cart')).toContain('Total: $500.01');\n    await click('li:nth-child(1) button');\n    expect(await text('.cart')).toContain('iPad 4 Mini - $500.01 x 2');\n    expect(await text('.cart')).toContain('Total: $1,000.02');\n    expect(await count('li:nth-child(1) button[disabled]')).toBe(1);\n    await click('li:nth-child(2) button');\n    expect(await text('.cart')).toContain('H&M T-Shirt White - $10.99 x 1');\n    expect(await text('.cart')).toContain('Total: $1,011.01');\n    await click('.cart button');\n    await sleep(200);\n    expect(await text('.cart')).toContain('Please add some products to cart');\n    expect(await text('.cart')).toContain('Total: $0.00');\n    expect(await text('.cart')).toContain('Checkout successful');\n    expect(await count('.cart button[disabled]')).toBe(1);\n  }, E2E_TIMEOUT);","file":"e2e/cart.spec.js","skipped":false,"dir":"test"},{"name":"chat app","suites":["e2e/chat"],"updatePoint":{"line":11,"column":16,"index":208},"line":11,"code":"  test('chat app', async () => {\n    await page().goto('http://localhost:8080/chat/');\n    expect(await text('.thread-count')).toContain('Unread threads: 2');\n    expect(await count('.thread-list-item')).toBe(3);\n    expect(await text('.thread-list-item.active')).toContain('Functional Heads');\n    expect(await text('.message-thread-heading')).toContain('Functional Heads');\n    expect(await count('.message-list-item')).toBe(2);\n    expect(await text('.message-list-item:nth-child(1) .message-author-name')).toContain('Bill');\n    expect(await text('.message-list-item:nth-child(1) .message-text')).toContain('Hey Brian');\n    await enterValue('.message-composer', 'hi');\n    await sleep(50); // fake api\n\n    expect(await count('.message-list-item')).toBe(3);\n    expect(await text('.message-list-item:nth-child(3)')).toContain('hi');\n    await click('.thread-list-item:nth-child(2)');\n    expect(await text('.thread-list-item.active')).toContain('Dave and Bill');\n    expect(await text('.message-thread-heading')).toContain('Dave and Bill');\n    expect(await count('.message-list-item')).toBe(2);\n    expect(await text('.message-list-item:nth-child(1) .message-author-name')).toContain('Bill');\n    expect(await text('.message-list-item:nth-child(1) .message-text')).toContain('Hey Dave');\n    await enterValue('.message-composer', 'hi');\n    await sleep(50); // fake api\n\n    expect(await count('.message-list-item')).toBe(3);\n    expect(await text('.message-list-item:nth-child(3)')).toContain('hi');\n  }, E2E_TIMEOUT);","file":"e2e/chat.spec.js","skipped":false,"dir":"test"},{"name":"counter app","suites":["e2e/counter"],"updatePoint":{"line":9,"column":19,"index":187},"line":9,"code":"  test('counter app', async () => {\n    await page().goto('http://localhost:8080/counter/');\n    expect(await text('#app')).toContain('Clicked: 0 times');\n    await click('button:nth-child(1)');\n    expect(await text('#app')).toContain('Clicked: 1 times');\n    await click('button:nth-child(2)');\n    expect(await text('#app')).toContain('Clicked: 0 times');\n    await click('button:nth-child(3)');\n    expect(await text('#app')).toContain('Clicked: 0 times');\n    await click('button:nth-child(1)');\n    expect(await text('#app')).toContain('Clicked: 1 times');\n    await click('button:nth-child(3)');\n    expect(await text('#app')).toContain('Clicked: 2 times');\n    await click('button:nth-child(4)');\n    expect(await text('#app')).toContain('Clicked: 2 times');\n    await sleep(1000);\n    expect(await text('#app')).toContain('Clicked: 3 times');\n  }, E2E_TIMEOUT);","file":"e2e/counter.spec.js","skipped":false,"dir":"test"},{"name":"todomvc app","suites":["e2e/todomvc"],"updatePoint":{"line":19,"column":19,"index":325},"line":19,"code":"  test('todomvc app', async () => {\n    await page().goto('http://localhost:8080/todomvc/');\n    expect(await isVisible('.main')).toBe(false);\n    expect(await isVisible('.footer')).toBe(false);\n    expect(await count('.filters .selected')).toBe(1);\n    await enterValue('.new-todo', 'test');\n    expect(await count('.todo')).toBe(1);\n    expect(await isVisible('.todo .edit')).toBe(false);\n    expect(await text('.todo label')).toContain('test');\n    expect(await text('.todo-count strong')).toContain('1');\n    expect(await isChecked('.todo .toggle')).toBe(false);\n    expect(await isVisible('.main')).toBe(true);\n    expect(await isVisible('.footer')).toBe(true);\n    expect(await isVisible('.clear-completed')).toBe(false);\n    expect(await value('.new-todo')).toBe('');\n    await enterValue('.new-todo', 'test2');\n    expect(await count('.todo')).toBe(2);\n    expect(await text('.todo:nth-child(2) label')).toContain('test2');\n    expect(await text('.todo-count strong')).toContain('2'); // toggle\n\n    await click('.todo .toggle');\n    expect(await count('.todo.completed')).toBe(1);\n    expect(await hasClass('.todo:nth-child(1)', 'completed')).toBe(true);\n    expect(await text('.todo-count strong')).toContain('1');\n    expect(await isVisible('.clear-completed')).toBe(true);\n    await enterValue('.new-todo', 'test3');\n    expect(await count('.todo')).toBe(3);\n    expect(await text('.todo:nth-child(3) label')).toContain('test3');\n    expect(await text('.todo-count strong')).toContain('2');\n    await enterValue('.new-todo', 'test4');\n    await enterValue('.new-todo', 'test5');\n    expect(await count('.todo')).toBe(5);\n    expect(await text('.todo-count strong')).toContain('4'); // toggle more\n\n    await click('.todo:nth-child(4) .toggle');\n    await click('.todo:nth-child(5) .toggle');\n    expect(await count('.todo.completed')).toBe(3);\n    expect(await text('.todo-count strong')).toContain('2'); // remove\n\n    await hover('.todo:nth-child(1)');\n    await click('.todo:nth-child(1) .destroy');\n    expect(await count('.todo')).toBe(4);\n    expect(await count('.todo.completed')).toBe(2);\n    expect(await text('.todo-count strong')).toContain('2');\n    await hover('.todo:nth-child(2)');\n    await click('.todo:nth-child(2) .destroy');\n    expect(await count('.todo')).toBe(3);\n    expect(await count('.todo.completed')).toBe(2);\n    expect(await text('.todo-count strong')).toContain('1'); // remove all\n\n    await click('.clear-completed');\n    expect(await count('.todo')).toBe(1);\n    expect(await text('.todo label')).toContain('test2');\n    expect(await count('.todo.completed')).toBe(0);\n    expect(await text('.todo-count strong')).toBe('1');\n    expect(await isVisible('.clear-completed')).toBe(false); // prepare to test filters\n\n    await enterValue('.new-todo', 'test');\n    await enterValue('.new-todo', 'test');\n    await click('.todo:nth-child(2) .toggle');\n    await click('.todo:nth-child(3) .toggle'); // active filter\n\n    await click('.filters li:nth-child(2) a');\n    expect(await count('.todo')).toBe(1);\n    expect(await count('.todo.completed')).toBe(0); // add item with filter active\n\n    await enterValue('.new-todo', 'test');\n    expect(await count('.todo', 2)).toBe(2); // complted filter\n\n    await click('.filters li:nth-child(3) a');\n    expect(await count('.todo')).toBe(2);\n    expect(await count('.todo.completed')).toBe(2); // toggling with filter active\n\n    await click('.todo .toggle');\n    expect(await count('.todo')).toBe(1);\n    await click('.filters li:nth-child(2) a');\n    expect(await count('.todo')).toBe(3);\n    await click('.todo .toggle');\n    expect(await count('.todo')).toBe(2); // editing triggered by blur\n\n    await click('.filters li:nth-child(1) a');\n    await click('.todo:nth-child(1) label', {\n      clickCount: 2\n    });\n    expect(await count('.todo.editing')).toBe(1);\n    expect(await isFocused('.todo:nth-child(1) .edit')).toBe(true);\n    await clearValue('.todo:nth-child(1) .edit');\n    await setValue('.todo:nth-child(1) .edit', 'edited!');\n    await click('.todo-count'); // blur\n\n    expect(await count('.todo.editing')).toBe(0);\n    expect(await text('.todo:nth-child(1) label')).toBe('edited!'); // editing triggered by enter\n\n    await click('.todo label', {\n      clickCount: 2\n    });\n    await clearValue('.todo:nth-child(1) .edit');\n    await enterValue('.todo:nth-child(1) .edit', 'edited again!');\n    expect(await count('.todo.editing')).toBe(0);\n    expect(await text('.todo:nth-child(1) label')).toBe('edited again!'); // cancel\n\n    await click('.todo label', {\n      clickCount: 2\n    });\n    await clearValue('.todo:nth-child(1) .edit');\n    await setValue('.todo:nth-child(1) .edit', 'edited!');\n    await keyUp('Escape');\n    expect(await count('.todo.editing')).toBe(0);\n    expect(await text('.todo:nth-child(1) label')).toBe('edited again!'); // empty value should remove\n\n    await click('.todo label', {\n      clickCount: 2\n    });\n    await clearValue('.todo:nth-child(1) .edit');\n    await enterValue('.todo:nth-child(1) .edit', ' ');\n    expect(await count('.todo')).toBe(3); // toggle all\n\n    await click('label[for=\"toggle-all\"]');\n    expect(await count('.todo.completed')).toBe(3);\n    await click('label[for=\"toggle-all\"]');\n    expect(await count('.todo:not(.completed)')).toBe(3);\n  }, E2E_TIMEOUT);","file":"e2e/todomvc.spec.js","skipped":false,"dir":"test"},{"name":"mapState (array)","suites":["Helpers"],"updatePoint":{"line":4,"column":22,"index":187},"line":4,"code":"  it('mapState (array)', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      }\n    });\n    const vm = new Vue({\n      store,\n      computed: mapState(['a'])\n    });\n    expect(vm.a).toBe(1);\n    store.state.a++;\n    expect(vm.a).toBe(2);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapState (object)","suites":["Helpers"],"updatePoint":{"line":18,"column":23,"index":457},"line":18,"code":"  it('mapState (object)', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      getters: {\n        b: () => 2\n      }\n    });\n    const vm = new Vue({\n      store,\n      computed: mapState({\n        a: (state, getters) => {\n          return state.a + getters.b;\n        }\n      })\n    });\n    expect(vm.a).toBe(3);\n    store.state.a++;\n    expect(vm.a).toBe(4);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapState (with namespace)","suites":["Helpers"],"updatePoint":{"line":39,"column":31,"index":865},"line":39,"code":"  it('mapState (with namespace)', () => {\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            a: 1\n          },\n          getters: {\n            b: state => state.a + 1\n          }\n        }\n      }\n    });\n    const vm = new Vue({\n      store,\n      computed: mapState('foo', {\n        a: (state, getters) => {\n          return state.a + getters.b;\n        }\n      })\n    });\n    expect(vm.a).toBe(3);\n    store.state.foo.a++;\n    expect(vm.a).toBe(5);\n    store.replaceState({\n      foo: {\n        a: 3\n      }\n    });\n    expect(vm.a).toBe(7);\n  }); // #708","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapState (with namespace and a nested module)","suites":["Helpers"],"updatePoint":{"line":72,"column":51,"index":1521},"line":72,"code":"  it('mapState (with namespace and a nested module)', () => {\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            a: 1\n          },\n          modules: {\n            bar: {\n              state: {\n                b: 2\n              }\n            }\n          }\n        }\n      }\n    });\n    const vm = new Vue({\n      store,\n      computed: mapState('foo', {\n        value: state => state\n      })\n    });\n    expect(vm.value.a).toBe(1);\n    expect(vm.value.bar.b).toBe(2);\n    expect(vm.value.b).toBeUndefined();\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapState (with undefined states)","suites":["Helpers"],"updatePoint":{"line":100,"column":38,"index":2099},"line":100,"code":"  it('mapState (with undefined states)', () => {\n    jest.spyOn(console, 'error').mockImplementation();\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            a: 1\n          }\n        }\n      }\n    });\n    const vm = new Vue({\n      store,\n      computed: mapState('foo')\n    });\n    expect(vm.a).toBeUndefined();\n    expect(console.error).toHaveBeenCalledWith('[vuex] mapState: mapper parameter must be either an Array or an Object');\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapMutations (array)","suites":["Helpers"],"updatePoint":{"line":119,"column":26,"index":2600},"line":119,"code":"  it('mapMutations (array)', () => {\n    const store = new Vuex.Store({\n      state: {\n        count: 0\n      },\n      mutations: {\n        inc: state => state.count++,\n        dec: state => state.count--\n      }\n    });\n    const vm = new Vue({\n      store,\n      methods: mapMutations(['inc', 'dec'])\n    });\n    vm.inc();\n    expect(store.state.count).toBe(1);\n    vm.dec();\n    expect(store.state.count).toBe(0);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapMutations (object)","suites":["Helpers"],"updatePoint":{"line":138,"column":27,"index":3024},"line":138,"code":"  it('mapMutations (object)', () => {\n    const store = new Vuex.Store({\n      state: {\n        count: 0\n      },\n      mutations: {\n        inc: state => state.count++,\n        dec: state => state.count--\n      }\n    });\n    const vm = new Vue({\n      store,\n      methods: mapMutations({\n        plus: 'inc',\n        minus: 'dec'\n      })\n    });\n    vm.plus();\n    expect(store.state.count).toBe(1);\n    vm.minus();\n    expect(store.state.count).toBe(0);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapMutations (function)","suites":["Helpers"],"updatePoint":{"line":160,"column":29,"index":3490},"line":160,"code":"  it('mapMutations (function)', () => {\n    const store = new Vuex.Store({\n      state: {\n        count: 0\n      },\n      mutations: {\n        inc(state, amount) {\n          state.count += amount;\n        }\n\n      }\n    });\n    const vm = new Vue({\n      store,\n      methods: mapMutations({\n        plus(commit, amount) {\n          commit('inc', amount + 1);\n        }\n\n      })\n    });\n    vm.plus(42);\n    expect(store.state.count).toBe(43);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapMutations (with namespace)","suites":["Helpers"],"updatePoint":{"line":184,"column":35,"index":3947},"line":184,"code":"  it('mapMutations (with namespace)', () => {\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            count: 0\n          },\n          mutations: {\n            inc: state => state.count++,\n            dec: state => state.count--\n          }\n        }\n      }\n    });\n    const vm = new Vue({\n      store,\n      methods: mapMutations('foo', {\n        plus: 'inc',\n        minus: 'dec'\n      })\n    });\n    vm.plus();\n    expect(store.state.foo.count).toBe(1);\n    vm.minus();\n    expect(store.state.foo.count).toBe(0);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapMutations (function with namepsace)","suites":["Helpers"],"updatePoint":{"line":211,"column":44,"index":4549},"line":211,"code":"  it('mapMutations (function with namepsace)', () => {\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            count: 0\n          },\n          mutations: {\n            inc(state, amount) {\n              state.count += amount;\n            }\n\n          }\n        }\n      }\n    });\n    const vm = new Vue({\n      store,\n      methods: mapMutations('foo', {\n        plus(commit, amount) {\n          commit('inc', amount + 1);\n        }\n\n      })\n    });\n    vm.plus(42);\n    expect(store.state.foo.count).toBe(43);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapMutations (with undefined mutations)","suites":["Helpers"],"updatePoint":{"line":240,"column":45,"index":5137},"line":240,"code":"  it('mapMutations (with undefined mutations)', () => {\n    jest.spyOn(console, 'error').mockImplementation();\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            count: 0\n          },\n          mutations: {\n            inc: state => state.count++,\n            dec: state => state.count--\n          }\n        }\n      }\n    });\n    const vm = new Vue({\n      store,\n      methods: mapMutations('foo')\n    });\n    expect(vm.inc).toBeUndefined();\n    expect(vm.dec).toBeUndefined();\n    expect(console.error).toHaveBeenCalledWith('[vuex] mapMutations: mapper parameter must be either an Array or an Object');\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapGetters (array)","suites":["Helpers"],"updatePoint":{"line":264,"column":24,"index":5802},"line":264,"code":"  it('mapGetters (array)', () => {\n    const store = new Vuex.Store({\n      state: {\n        count: 0\n      },\n      mutations: {\n        inc: state => state.count++,\n        dec: state => state.count--\n      },\n      getters: {\n        hasAny: ({\n          count\n        }) => count > 0,\n        negative: ({\n          count\n        }) => count < 0\n      }\n    });\n    const vm = new Vue({\n      store,\n      computed: mapGetters(['hasAny', 'negative'])\n    });\n    expect(vm.hasAny).toBe(false);\n    expect(vm.negative).toBe(false);\n    store.commit('inc');\n    expect(vm.hasAny).toBe(true);\n    expect(vm.negative).toBe(false);\n    store.commit('dec');\n    store.commit('dec');\n    expect(vm.hasAny).toBe(false);\n    expect(vm.negative).toBe(true);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapGetters (object)","suites":["Helpers"],"updatePoint":{"line":296,"column":25,"index":6561},"line":296,"code":"  it('mapGetters (object)', () => {\n    const store = new Vuex.Store({\n      state: {\n        count: 0\n      },\n      mutations: {\n        inc: state => state.count++,\n        dec: state => state.count--\n      },\n      getters: {\n        hasAny: ({\n          count\n        }) => count > 0,\n        negative: ({\n          count\n        }) => count < 0\n      }\n    });\n    const vm = new Vue({\n      store,\n      computed: mapGetters({\n        a: 'hasAny',\n        b: 'negative'\n      })\n    });\n    expect(vm.a).toBe(false);\n    expect(vm.b).toBe(false);\n    store.commit('inc');\n    expect(vm.a).toBe(true);\n    expect(vm.b).toBe(false);\n    store.commit('dec');\n    store.commit('dec');\n    expect(vm.a).toBe(false);\n    expect(vm.b).toBe(true);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapGetters (with namespace)","suites":["Helpers"],"updatePoint":{"line":331,"column":33,"index":7322},"line":331,"code":"  it('mapGetters (with namespace)', () => {\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            count: 0\n          },\n          mutations: {\n            inc: state => state.count++,\n            dec: state => state.count--\n          },\n          getters: {\n            hasAny: ({\n              count\n            }) => count > 0,\n            negative: ({\n              count\n            }) => count < 0\n          }\n        }\n      }\n    });\n    const vm = new Vue({\n      store,\n      computed: mapGetters('foo', {\n        a: 'hasAny',\n        b: 'negative'\n      })\n    });\n    expect(vm.a).toBe(false);\n    expect(vm.b).toBe(false);\n    store.commit('foo/inc');\n    expect(vm.a).toBe(true);\n    expect(vm.b).toBe(false);\n    store.commit('foo/dec');\n    store.commit('foo/dec');\n    expect(vm.a).toBe(false);\n    expect(vm.b).toBe(true);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapGetters (with namespace and nested module)","suites":["Helpers"],"updatePoint":{"line":371,"column":51,"index":8258},"line":371,"code":"  it('mapGetters (with namespace and nested module)', () => {\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          modules: {\n            bar: {\n              namespaced: true,\n              state: {\n                count: 0\n              },\n              mutations: {\n                inc: state => state.count++,\n                dec: state => state.count--\n              },\n              getters: {\n                hasAny: ({\n                  count\n                }) => count > 0,\n                negative: ({\n                  count\n                }) => count < 0\n              }\n            },\n            cat: {\n              state: {\n                count: 9\n              },\n              getters: {\n                count: ({\n                  count\n                }) => count\n              }\n            }\n          }\n        }\n      }\n    });\n    const vm = new Vue({\n      store,\n      computed: { ...mapGetters('foo/bar', ['hasAny', 'negative']),\n        ...mapGetters('foo', ['count'])\n      }\n    });\n    expect(vm.hasAny).toBe(false);\n    expect(vm.negative).toBe(false);\n    store.commit('foo/bar/inc');\n    expect(vm.hasAny).toBe(true);\n    expect(vm.negative).toBe(false);\n    store.commit('foo/bar/dec');\n    store.commit('foo/bar/dec');\n    expect(vm.hasAny).toBe(false);\n    expect(vm.negative).toBe(true);\n    expect(vm.count).toBe(9);\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapGetters (with undefined getters)","suites":["Helpers"],"updatePoint":{"line":426,"column":41,"index":9666},"line":426,"code":"  it('mapGetters (with undefined getters)', () => {\n    jest.spyOn(console, 'error').mockImplementation();\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            count: 0\n          },\n          mutations: {\n            inc: state => state.count++,\n            dec: state => state.count--\n          },\n          getters: {\n            hasAny: ({\n              count\n            }) => count > 0,\n            negative: ({\n              count\n            }) => count < 0\n          }\n        }\n      }\n    });\n    const vm = new Vue({\n      store,\n      computed: mapGetters('foo')\n    });\n    expect(vm.a).toBeUndefined();\n    expect(vm.b).toBeUndefined();\n    expect(console.error).toHaveBeenCalledWith('[vuex] mapGetters: mapper parameter must be either an Array or an Object');\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapActions (array)","suites":["Helpers"],"updatePoint":{"line":458,"column":24,"index":10503},"line":458,"code":"  it('mapActions (array)', () => {\n    const a = jest.fn();\n    const b = jest.fn();\n    const store = new Vuex.Store({\n      actions: {\n        a,\n        b\n      }\n    });\n    const vm = new Vue({\n      store,\n      methods: mapActions(['a', 'b'])\n    });\n    vm.a();\n    expect(a).toHaveBeenCalled();\n    expect(b).not.toHaveBeenCalled();\n    vm.b();\n    expect(b).toHaveBeenCalled();\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapActions (object)","suites":["Helpers"],"updatePoint":{"line":477,"column":25,"index":10898},"line":477,"code":"  it('mapActions (object)', () => {\n    const a = jest.fn();\n    const b = jest.fn();\n    const store = new Vuex.Store({\n      actions: {\n        a,\n        b\n      }\n    });\n    const vm = new Vue({\n      store,\n      methods: mapActions({\n        foo: 'a',\n        bar: 'b'\n      })\n    });\n    vm.foo();\n    expect(a).toHaveBeenCalled();\n    expect(b).not.toHaveBeenCalled();\n    vm.bar();\n    expect(b).toHaveBeenCalled();\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapActions (function)","suites":["Helpers"],"updatePoint":{"line":499,"column":27,"index":11333},"line":499,"code":"  it('mapActions (function)', () => {\n    const a = jest.fn();\n    const store = new Vuex.Store({\n      actions: {\n        a\n      }\n    });\n    const vm = new Vue({\n      store,\n      methods: mapActions({\n        foo(dispatch, arg) {\n          dispatch('a', arg + 'bar');\n        }\n\n      })\n    });\n    vm.foo('foo');\n    expect(a.mock.calls[0][1]).toBe('foobar');\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapActions (with namespace)","suites":["Helpers"],"updatePoint":{"line":518,"column":33,"index":11713},"line":518,"code":"  it('mapActions (with namespace)', () => {\n    const a = jest.fn();\n    const b = jest.fn();\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          actions: {\n            a,\n            b\n          }\n        }\n      }\n    });\n    const vm = new Vue({\n      store,\n      methods: mapActions('foo/', {\n        foo: 'a',\n        bar: 'b'\n      })\n    });\n    vm.foo();\n    expect(a).toHaveBeenCalled();\n    expect(b).not.toHaveBeenCalled();\n    vm.bar();\n    expect(b).toHaveBeenCalled();\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapActions (function with namespace)","suites":["Helpers"],"updatePoint":{"line":545,"column":42,"index":12265},"line":545,"code":"  it('mapActions (function with namespace)', () => {\n    const a = jest.fn();\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          actions: {\n            a\n          }\n        }\n      }\n    });\n    const vm = new Vue({\n      store,\n      methods: mapActions('foo/', {\n        foo(dispatch, arg) {\n          dispatch('a', arg + 'bar');\n        }\n\n      })\n    });\n    vm.foo('foo');\n    expect(a.mock.calls[0][1]).toBe('foobar');\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mapActions (with undefined actions)","suites":["Helpers"],"updatePoint":{"line":569,"column":41,"index":12751},"line":569,"code":"  it('mapActions (with undefined actions)', () => {\n    jest.spyOn(console, 'error').mockImplementation();\n    const a = jest.fn();\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          actions: {\n            a\n          }\n        }\n      }\n    });\n    const vm = new Vue({\n      store,\n      methods: mapActions('foo/')\n    });\n    expect(vm.a).toBeUndefined();\n    expect(a).not.toHaveBeenCalled();\n    expect(console.error).toHaveBeenCalledWith('[vuex] mapActions: mapper parameter must be either an Array or an Object');\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"createNamespacedHelpers","suites":["Helpers"],"updatePoint":{"line":590,"column":29,"index":13321},"line":590,"code":"  it('createNamespacedHelpers', () => {\n    const actionA = jest.fn();\n    const actionB = jest.fn();\n    const store = new Vuex.Store({\n      modules: {\n        foo: {\n          namespaced: true,\n          state: {\n            count: 0\n          },\n          getters: {\n            isEven: state => state.count % 2 === 0\n          },\n          mutations: {\n            inc: state => state.count++,\n            dec: state => state.count--\n          },\n          actions: {\n            actionA,\n            actionB\n          }\n        }\n      }\n    });\n    const {\n      mapState,\n      mapGetters,\n      mapMutations,\n      mapActions\n    } = createNamespacedHelpers('foo/');\n    const vm = new Vue({\n      store,\n      computed: { ...mapState(['count']),\n        ...mapGetters(['isEven'])\n      },\n      methods: { ...mapMutations(['inc', 'dec']),\n        ...mapActions(['actionA', 'actionB'])\n      }\n    });\n    expect(vm.count).toBe(0);\n    expect(vm.isEven).toBe(true);\n    store.state.foo.count++;\n    expect(vm.count).toBe(1);\n    expect(vm.isEven).toBe(false);\n    vm.inc();\n    expect(store.state.foo.count).toBe(2);\n    expect(store.getters['foo/isEven']).toBe(true);\n    vm.dec();\n    expect(store.state.foo.count).toBe(1);\n    expect(store.getters['foo/isEven']).toBe(false);\n    vm.actionA();\n    expect(actionA).toHaveBeenCalled();\n    expect(actionB).not.toHaveBeenCalled();\n    vm.actionB();\n    expect(actionB).toHaveBeenCalled();\n  });","file":"unit/helpers.spec.js","skipped":false,"dir":"test"},{"name":"mutations","suites":["Hot Reload"],"updatePoint":{"line":6,"column":15,"index":175},"line":6,"code":"  it('mutations', function () {\n    const mutations = {\n      [TEST](state, n) {\n        state.a += n;\n      }\n\n    };\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations,\n      modules: {\n        nested: {\n          state: {\n            a: 2\n          },\n          mutations,\n          modules: {\n            one: {\n              state: {\n                a: 3\n              },\n              mutations\n            },\n            nested: {\n              modules: {\n                two: {\n                  state: {\n                    a: 4\n                  },\n                  mutations\n                },\n                three: {\n                  state: {\n                    a: 5\n                  },\n                  mutations\n                }\n              }\n            }\n          }\n        },\n        four: {\n          state: {\n            a: 6\n          },\n          mutations\n        }\n      }\n    });\n    store.commit(TEST, 1);\n    expect(store.state.a).toBe(2);\n    expect(store.state.nested.a).toBe(3);\n    expect(store.state.nested.one.a).toBe(4);\n    expect(store.state.nested.nested.two.a).toBe(5);\n    expect(store.state.nested.nested.three.a).toBe(6);\n    expect(store.state.four.a).toBe(7); // hot reload only root mutations\n\n    store.hotUpdate({\n      mutations: {\n        [TEST](state, n) {\n          state.a = n;\n        }\n\n      }\n    });\n    store.commit(TEST, 1);\n    expect(store.state.a).toBe(1); // only root mutation updated\n\n    expect(store.state.nested.a).toBe(4);\n    expect(store.state.nested.one.a).toBe(5);\n    expect(store.state.nested.nested.two.a).toBe(6);\n    expect(store.state.nested.nested.three.a).toBe(7);\n    expect(store.state.four.a).toBe(8); // hot reload modules\n\n    store.hotUpdate({\n      modules: {\n        nested: {\n          state: {\n            a: 234\n          },\n          mutations,\n          modules: {\n            one: {\n              state: {\n                a: 345\n              },\n              mutations\n            },\n            nested: {\n              modules: {\n                two: {\n                  state: {\n                    a: 456\n                  },\n                  mutations\n                },\n                three: {\n                  state: {\n                    a: 567\n                  },\n                  mutations\n                }\n              }\n            }\n          }\n        },\n        four: {\n          state: {\n            a: 678\n          },\n          mutations\n        }\n      }\n    });\n    store.commit(TEST, 2);\n    expect(store.state.a).toBe(2);\n    expect(store.state.nested.a).toBe(6); // should not reload initial state\n\n    expect(store.state.nested.one.a).toBe(7); // should not reload initial state\n\n    expect(store.state.nested.nested.two.a).toBe(8); // should not reload initial state\n\n    expect(store.state.nested.nested.three.a).toBe(9); // should not reload initial state\n\n    expect(store.state.four.a).toBe(10); // should not reload initial state\n    // hot reload all\n\n    store.hotUpdate({\n      mutations: {\n        [TEST](state, n) {\n          state.a -= n;\n        }\n\n      },\n      modules: {\n        nested: {\n          state: {\n            a: 234\n          },\n          mutations: {\n            [TEST](state, n) {\n              state.a += n;\n            }\n\n          },\n          modules: {\n            one: {\n              state: {\n                a: 345\n              },\n              mutations: {\n                [TEST](state, n) {\n                  state.a += n;\n                }\n\n              }\n            },\n            nested: {\n              modules: {\n                two: {\n                  state: {\n                    a: 456\n                  },\n                  mutations: {\n                    [TEST](state, n) {\n                      state.a += n;\n                    }\n\n                  }\n                },\n                three: {\n                  state: {\n                    a: 567\n                  },\n                  mutations: {\n                    [TEST](state, n) {\n                      state.a -= n;\n                    }\n\n                  }\n                }\n              }\n            }\n          }\n        },\n        four: {\n          state: {\n            a: 678\n          },\n          mutations: {\n            [TEST](state, n) {\n              state.a -= n;\n            }\n\n          }\n        }\n      }\n    });\n    store.commit(TEST, 3);\n    expect(store.state.a).toBe(-1);\n    expect(store.state.nested.a).toBe(9);\n    expect(store.state.nested.one.a).toBe(10);\n    expect(store.state.nested.nested.two.a).toBe(11);\n    expect(store.state.nested.nested.three.a).toBe(6);\n    expect(store.state.four.a).toBe(7);\n  });","file":"unit/hot-reload.spec.js","skipped":false,"dir":"test"},{"name":"actions","suites":["Hot Reload"],"updatePoint":{"line":214,"column":13,"index":4900},"line":214,"code":"  it('actions', () => {\n    const store = new Vuex.Store({\n      state: {\n        list: []\n      },\n      mutations: {\n        [TEST](state, n) {\n          state.list.push(n);\n        }\n\n      },\n      actions: {\n        [TEST]({\n          commit\n        }) {\n          commit(TEST, 1);\n        }\n\n      },\n      modules: {\n        a: {\n          actions: {\n            [TEST]({\n              commit\n            }) {\n              commit(TEST, 2);\n            }\n\n          }\n        }\n      }\n    });\n    store.dispatch(TEST);\n    expect(store.state.list.join()).toBe('1,2'); // update root\n\n    store.hotUpdate({\n      actions: {\n        [TEST]({\n          commit\n        }) {\n          commit(TEST, 3);\n        }\n\n      }\n    });\n    store.dispatch(TEST);\n    expect(store.state.list.join()).toBe('1,2,3,2'); // update modules\n\n    store.hotUpdate({\n      actions: {\n        [TEST]({\n          commit\n        }) {\n          commit(TEST, 4);\n        }\n\n      },\n      modules: {\n        a: {\n          actions: {\n            [TEST]({\n              commit\n            }) {\n              commit(TEST, 5);\n            }\n\n          }\n        }\n      }\n    });\n    store.dispatch(TEST);\n    expect(store.state.list.join()).toBe('1,2,3,2,4,5');\n  });","file":"unit/hot-reload.spec.js","skipped":false,"dir":"test"},{"name":"getters","suites":["Hot Reload"],"updatePoint":{"line":287,"column":13,"index":6146},"line":287,"code":"  it('getters', done => {\n    const store = new Vuex.Store({\n      state: {\n        count: 0\n      },\n      mutations: {\n        inc: state => state.count++\n      },\n      getters: {\n        count: state => state.count\n      },\n      actions: {\n        check({\n          getters\n        }, value) {\n          expect(getters.count).toBe(value);\n        }\n\n      }\n    });\n    const spy = jest.fn();\n    const vm = new Vue({\n      computed: {\n        a: () => store.getters.count\n      },\n      watch: {\n        a: spy\n      }\n    });\n    expect(vm.a).toBe(0);\n    store.dispatch('check', 0);\n    store.commit('inc');\n    expect(vm.a).toBe(1);\n    store.dispatch('check', 1); // update getters\n\n    store.hotUpdate({\n      getters: {\n        count: state => state.count * 10\n      }\n    });\n    expect(vm.a).toBe(10);\n    store.dispatch('check', 10);\n\n    if (isSSR) {\n      done();\n    } else {\n      Vue.nextTick(() => {\n        expect(spy).toHaveBeenCalled();\n        done();\n      });\n    }\n  });","file":"unit/hot-reload.spec.js","skipped":false,"dir":"test"},{"name":"provide warning if a new module is given","suites":["Hot Reload"],"updatePoint":{"line":339,"column":46,"index":7178},"line":339,"code":"  it('provide warning if a new module is given', () => {\n    const store = new Vuex.Store({});\n    jest.spyOn(console, 'warn').mockImplementation();\n    store.hotUpdate({\n      modules: {\n        test: {\n          state: {\n            count: 0\n          }\n        }\n      }\n    });\n    expect(console.warn).toHaveBeenCalledWith('[vuex] trying to add a new module \\'test\\' on hot reloading, ' + 'manual reload is needed');\n  });","file":"unit/hot-reload.spec.js","skipped":false,"dir":"test"},{"name":"update namespace","suites":["Hot Reload"],"updatePoint":{"line":353,"column":22,"index":7582},"line":353,"code":"  it('update namespace', () => {\n    // prevent to print notification of unknown action/mutation\n    jest.spyOn(console, 'error').mockImplementation();\n    const actionSpy = jest.fn();\n    const mutationSpy = jest.fn();\n    const store = new Vuex.Store({\n      modules: {\n        a: {\n          namespaced: true,\n          state: {\n            value: 1\n          },\n          getters: {\n            foo: state => state.value\n          },\n          actions: {\n            foo: actionSpy\n          },\n          mutations: {\n            foo: mutationSpy\n          }\n        }\n      }\n    });\n    expect(store.state.a.value).toBe(1);\n    expect(store.getters['a/foo']).toBe(1);\n    store.dispatch('a/foo');\n    expect(actionSpy).toHaveBeenCalledTimes(1);\n    store.commit('a/foo');\n    expect(actionSpy).toHaveBeenCalledTimes(1);\n    store.hotUpdate({\n      modules: {\n        a: {\n          namespaced: false\n        }\n      }\n    });\n    expect(store.state.a.value).toBe(1);\n    expect(store.getters['a/foo']).toBe(undefined); // removed\n\n    expect(store.getters['foo']).toBe(1); // renamed\n    // should not be called\n\n    store.dispatch('a/foo');\n    expect(actionSpy).toHaveBeenCalledTimes(1); // should be called\n\n    store.dispatch('foo');\n    expect(actionSpy).toHaveBeenCalledTimes(2); // should not be called\n\n    store.commit('a/foo');\n    expect(mutationSpy).toHaveBeenCalledTimes(1); // should be called\n\n    store.commit('foo');\n    expect(mutationSpy).toHaveBeenCalledTimes(2);\n  });","file":"unit/hot-reload.spec.js","skipped":false,"dir":"test"},{"name":"get","suites":["ModuleCollection"],"updatePoint":{"line":3,"column":9,"index":106},"line":3,"code":"  it('get', () => {\n    const collection = new ModuleCollection({\n      state: {\n        value: 1\n      },\n      modules: {\n        a: {\n          state: {\n            value: 2\n          }\n        },\n        b: {\n          state: {\n            value: 3\n          },\n          modules: {\n            c: {\n              state: {\n                value: 4\n              }\n            }\n          }\n        }\n      }\n    });\n    expect(collection.get([]).state.value).toBe(1);\n    expect(collection.get(['a']).state.value).toBe(2);\n    expect(collection.get(['b']).state.value).toBe(3);\n    expect(collection.get(['b', 'c']).state.value).toBe(4);\n  });","file":"unit/module/module-collection.spec.js","skipped":false,"dir":"test"},{"name":"getNamespace","suites":["ModuleCollection"],"updatePoint":{"line":33,"column":18,"index":763},"line":33,"code":"  it('getNamespace', () => {\n    const module = (namespaced, children) => {\n      return {\n        namespaced,\n        modules: children\n      };\n    };\n\n    const collection = new ModuleCollection({\n      namespace: 'ignore/',\n      // root module namespace should be ignored\n      modules: {\n        a: module(true, {\n          b: module(false, {\n            c: module(true)\n          }),\n          d: module(true)\n        })\n      }\n    });\n\n    const check = (path, expected) => {\n      const type = 'test';\n      const namespace = collection.getNamespace(path);\n      expect(namespace + type).toBe(expected);\n    };\n\n    check(['a'], 'a/test');\n    check(['a', 'b'], 'a/test');\n    check(['a', 'b', 'c'], 'a/c/test');\n    check(['a', 'd'], 'a/d/test');\n  });","file":"unit/module/module-collection.spec.js","skipped":false,"dir":"test"},{"name":"register","suites":["ModuleCollection"],"updatePoint":{"line":65,"column":14,"index":1523},"line":65,"code":"  it('register', () => {\n    const collection = new ModuleCollection({});\n    collection.register(['a'], {\n      state: {\n        value: 1\n      }\n    });\n    collection.register(['b'], {\n      state: {\n        value: 2\n      }\n    });\n    collection.register(['a', 'b'], {\n      state: {\n        value: 3\n      }\n    });\n    expect(collection.get(['a']).state.value).toBe(1);\n    expect(collection.get(['b']).state.value).toBe(2);\n    expect(collection.get(['a', 'b']).state.value).toBe(3);\n  });","file":"unit/module/module-collection.spec.js","skipped":false,"dir":"test"},{"name":"unregister","suites":["ModuleCollection"],"updatePoint":{"line":86,"column":16,"index":2023},"line":86,"code":"  it('unregister', () => {\n    const collection = new ModuleCollection({});\n    collection.register(['a'], {\n      state: {\n        value: true\n      }\n    });\n    expect(collection.get(['a']).state.value).toBe(true);\n    collection.unregister(['a']);\n    expect(collection.get(['a'])).toBe(undefined);\n  });","file":"unit/module/module-collection.spec.js","skipped":false,"dir":"test"},{"name":"isRegistered","suites":["ModuleCollection"],"updatePoint":{"line":97,"column":18,"index":2334},"line":97,"code":"  it('isRegistered', () => {\n    const collection = new ModuleCollection({});\n    collection.register(['a'], {\n      state: {\n        value: true\n      }\n    });\n    collection.register(['a', 'b'], {\n      state: {\n        value: false\n      }\n    });\n    expect(collection.isRegistered(['a'])).toBe(true);\n    expect(collection.isRegistered(['a', 'b'])).toBe(true);\n    expect(collection.isRegistered(['c'])).toBe(false);\n    expect(collection.isRegistered(['c', 'd'])).toBe(false);\n  });","file":"unit/module/module-collection.spec.js","skipped":false,"dir":"test"},{"name":"does not unregister initial modules","suites":["ModuleCollection"],"updatePoint":{"line":114,"column":41,"index":2847},"line":114,"code":"  it('does not unregister initial modules', () => {\n    const collection = new ModuleCollection({\n      modules: {\n        a: {\n          state: {\n            value: true\n          }\n        }\n      }\n    });\n    collection.unregister(['a']);\n    expect(collection.get(['a']).state.value).toBe(true);\n  });","file":"unit/module/module-collection.spec.js","skipped":false,"dir":"test"},{"name":"warns when unregistering non existing module","suites":["ModuleCollection"],"updatePoint":{"line":127,"column":50,"index":3163},"line":127,"code":"  it('warns when unregistering non existing module', () => {\n    const spy = jest.spyOn(console, 'warn').mockImplementation();\n    const collection = new ModuleCollection({});\n    collection.unregister(['a']);\n    expect(spy).toHaveBeenCalled();\n  });","file":"unit/module/module-collection.spec.js","skipped":false,"dir":"test"},{"name":"get state","suites":["Module"],"updatePoint":{"line":3,"column":15,"index":81},"line":3,"code":"  it('get state', () => {\n    const module = new Module({\n      state: {\n        value: true\n      }\n    });\n    expect(module.state).toEqual({\n      value: true\n    });\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"get state: should return object if state option is empty","suites":["Module"],"updatePoint":{"line":13,"column":62,"index":304},"line":13,"code":"  it('get state: should return object if state option is empty', () => {\n    const module = new Module({});\n    expect(module.state).toEqual({});\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"get namespacer: no namespace option","suites":["Module"],"updatePoint":{"line":17,"column":41,"index":435},"line":17,"code":"  it('get namespacer: no namespace option', () => {\n    const module = new Module({});\n    expect(module.namespaced).toBe(false);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"get namespacer: namespace option is true","suites":["Module"],"updatePoint":{"line":21,"column":46,"index":576},"line":21,"code":"  it('get namespacer: namespace option is true', () => {\n    let module = new Module({\n      namespaced: true\n    });\n    expect(module.namespaced).toBe(true);\n    module = new Module({\n      namespaced: 100\n    });\n    expect(module.namespaced).toBe(true);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"add child method","suites":["Module"],"updatePoint":{"line":31,"column":22,"index":816},"line":31,"code":"  it('add child method', () => {\n    const module = new Module({});\n    module.addChild('v1', new Module({}));\n    module.addChild('v2', new Module({}));\n    expect(Object.keys(module._children)).toEqual(['v1', 'v2']);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"remove child method","suites":["Module"],"updatePoint":{"line":37,"column":25,"index":1044},"line":37,"code":"  it('remove child method', () => {\n    const module = new Module({});\n    module.addChild('v1', new Module({}));\n    module.addChild('v2', new Module({}));\n    expect(Object.keys(module._children)).toEqual(['v1', 'v2']);\n    module.removeChild('v2');\n    module.removeChild('abc');\n    expect(Object.keys(module._children)).toEqual(['v1']);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"get child method","suites":["Module"],"updatePoint":{"line":46,"column":22,"index":1389},"line":46,"code":"  it('get child method', () => {\n    const module = new Module({});\n    const subModule1 = new Module({\n      state: {\n        name: 'v1'\n      }\n    });\n    const subModule2 = new Module({\n      state: {\n        name: 'v2'\n      }\n    });\n    module.addChild('v1', subModule1);\n    module.addChild('v2', subModule2);\n    expect(module.getChild('v2')).toEqual(subModule2);\n    expect(module.getChild('v1')).toEqual(subModule1);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"update method","suites":["Module"],"updatePoint":{"line":63,"column":19,"index":1820},"line":63,"code":"  it('update method', () => {\n    const originObject = {\n      state: {\n        name: 'vuex',\n        version: '2.x.x'\n      },\n      namespaced: true,\n      actions: {\n        a1: () => {},\n        a2: () => {}\n      },\n      mutations: {\n        m1: () => {},\n        m2: () => {}\n      },\n      getters: {\n        g1: () => {},\n        g2: () => {}\n      }\n    };\n    const newObject = {\n      actions: {\n        a3: () => {},\n        a4: () => {}\n      },\n      mutations: {\n        m3: () => {},\n        m2: () => {}\n      },\n      getters: {\n        g1: () => {}\n      },\n      namespaced: false,\n      state: {\n        name: 'vuex',\n        version: '3.x.x'\n      }\n    };\n    const module = new Module(originObject);\n    expect(module._rawModule).toEqual(originObject);\n    module.update(newObject);\n    expect(module._rawModule.actions).toEqual(newObject.actions);\n    expect(module._rawModule.mutations).toEqual(newObject.mutations);\n    expect(module._rawModule.getters).toEqual(newObject.getters);\n    expect(module._rawModule.namespaced).toEqual(newObject.namespaced);\n    expect(module._rawModule.state).toEqual(originObject.state);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"forEachChild method","suites":["Module"],"updatePoint":{"line":110,"column":25,"index":2979},"line":110,"code":"  it('forEachChild method', () => {\n    const module = new Module({});\n    const module1 = new Module({});\n    const module2 = new Module({});\n    module.addChild('v1', module1);\n    module.addChild('v2', module2);\n    const collections = [];\n    module.forEachChild(item => {\n      collections.push(item);\n    });\n    expect(collections.length).toEqual(2);\n    expect(collections).toEqual([module2, module1]);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"forEachAction method","suites":["Module"],"updatePoint":{"line":123,"column":26,"index":3397},"line":123,"code":"  it('forEachAction method', () => {\n    const action1 = () => {};\n\n    const action2 = () => {};\n\n    const module = new Module({\n      actions: {\n        action1,\n        action2\n      }\n    });\n    const collections = [];\n    module.forEachAction(item => {\n      collections.push(item);\n    });\n    expect(collections.length).toEqual(2);\n    expect(collections).toEqual([action1, action2]);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"forEachGetter method","suites":["Module"],"updatePoint":{"line":141,"column":26,"index":3797},"line":141,"code":"  it('forEachGetter method', () => {\n    const getter1 = () => {};\n\n    const getter2 = () => {};\n\n    const module = new Module({\n      getters: {\n        getter1,\n        getter2\n      }\n    });\n    const collections = [];\n    module.forEachGetter(item => {\n      collections.push(item);\n    });\n    expect(collections.length).toEqual(2);\n    expect(collections).toEqual([getter1, getter2]);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"forEachMutation method","suites":["Module"],"updatePoint":{"line":159,"column":28,"index":4199},"line":159,"code":"  it('forEachMutation method', () => {\n    const mutation1 = () => {};\n\n    const mutation2 = () => {};\n\n    const module = new Module({\n      mutations: {\n        mutation1,\n        mutation2\n      }\n    });\n    const collections = [];\n    module.forEachMutation(item => {\n      collections.push(item);\n    });\n    expect(collections.length).toEqual(2);\n    expect(collections).toEqual([mutation1, mutation2]);\n  });","file":"unit/module/module.spec.js","skipped":false,"dir":"test"},{"name":"dynamic module registration","suites":["Modules","module registration"],"updatePoint":{"line":6,"column":35,"index":186},"line":6,"code":"    it('dynamic module registration', () => {\n      const store = new Vuex.Store({\n        strict: true,\n        modules: {\n          foo: {\n            state: {\n              bar: 1\n            },\n            mutations: {\n              inc: state => state.bar++\n            },\n            actions: {\n              incFoo: ({\n                commit\n              }) => commit('inc')\n            },\n            getters: {\n              bar: state => state.bar\n            }\n          }\n        }\n      });\n      expect(() => {\n        store.registerModule('hi', {\n          state: {\n            a: 1\n          },\n          mutations: {\n            inc: state => state.a++\n          },\n          actions: {\n            inc: ({\n              commit\n            }) => commit('inc')\n          },\n          getters: {\n            a: state => state.a\n          }\n        });\n      }).not.toThrow();\n      expect(store._mutations.inc.length).toBe(2);\n      expect(store.state.hi.a).toBe(1);\n      expect(store.getters.a).toBe(1); // assert initial modules work as expected after dynamic registration\n\n      expect(store.state.foo.bar).toBe(1);\n      expect(store.getters.bar).toBe(1); // test dispatching actions defined in dynamic module\n\n      store.dispatch('inc');\n      expect(store.state.hi.a).toBe(2);\n      expect(store.getters.a).toBe(2);\n      expect(store.state.foo.bar).toBe(2);\n      expect(store.getters.bar).toBe(2); // unregister\n\n      store.unregisterModule('hi');\n      expect(store.state.hi).toBeUndefined();\n      expect(store.getters.a).toBeUndefined();\n      expect(store._mutations.inc.length).toBe(1);\n      expect(store._actions.inc).toBeUndefined(); // assert initial modules still work as expected after unregister\n\n      store.dispatch('incFoo');\n      expect(store.state.foo.bar).toBe(3);\n      expect(store.getters.bar).toBe(3);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"dynamic module registration with namespace inheritance","suites":["Modules","module registration"],"updatePoint":{"line":69,"column":62,"index":2073},"line":69,"code":"    it('dynamic module registration with namespace inheritance', () => {\n      const store = new Vuex.Store({\n        modules: {\n          a: {\n            namespaced: true\n          }\n        }\n      });\n      const actionSpy = jest.fn();\n      const mutationSpy = jest.fn();\n      store.registerModule(['a', 'b'], {\n        state: {\n          value: 1\n        },\n        getters: {\n          foo: state => state.value\n        },\n        actions: {\n          foo: actionSpy\n        },\n        mutations: {\n          foo: mutationSpy\n        }\n      });\n      expect(store.state.a.b.value).toBe(1);\n      expect(store.getters['a/foo']).toBe(1);\n      store.dispatch('a/foo');\n      expect(actionSpy).toHaveBeenCalled();\n      store.commit('a/foo');\n      expect(mutationSpy).toHaveBeenCalled();\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"dynamic module existance test","suites":["Modules","module registration"],"updatePoint":{"line":100,"column":37,"index":2851},"line":100,"code":"    it('dynamic module existance test', () => {\n      const store = new Vuex.Store({});\n      store.registerModule('bonjour', {});\n      expect(store.hasModule('bonjour')).toBe(true);\n      store.unregisterModule('bonjour');\n      expect(store.hasModule('bonjour')).toBe(false);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"dynamic module existance test with nested modules","suites":["Modules","module registration"],"updatePoint":{"line":107,"column":57,"index":3158},"line":107,"code":"    it('dynamic module existance test with nested modules', () => {\n      const store = new Vuex.Store({});\n      store.registerModule('a', {});\n      store.registerModule(['a', 'b'], {});\n      expect(store.hasModule(['a'])).toBe(true);\n      expect(store.hasModule(['a', 'b'])).toBe(true);\n      expect(store.hasModule(['c'])).toBe(false);\n      expect(store.hasModule(['c', 'd'])).toBe(false);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"dynamic module registration preserving hydration","suites":["Modules","module registration"],"updatePoint":{"line":116,"column":56,"index":3562},"line":116,"code":"    it('dynamic module registration preserving hydration', () => {\n      const store = new Vuex.Store({});\n      store.replaceState({\n        a: {\n          foo: 'state'\n        }\n      });\n      const actionSpy = jest.fn();\n      const mutationSpy = jest.fn();\n      store.registerModule('a', {\n        namespaced: true,\n        getters: {\n          foo: state => state.foo\n        },\n        actions: {\n          foo: actionSpy\n        },\n        mutations: {\n          foo: mutationSpy\n        }\n      }, {\n        preserveState: true\n      });\n      expect(store.state.a.foo).toBe('state');\n      expect(store.getters['a/foo']).toBe('state');\n      store.dispatch('a/foo');\n      expect(actionSpy).toHaveBeenCalled();\n      store.commit('a/foo');\n      expect(mutationSpy).toHaveBeenCalled();\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"should not fire an unrelated watcher","suites":["Modules","module registration"],"updatePoint":{"line":148,"column":42,"index":4368},"line":148,"code":"  it('should not fire an unrelated watcher', done => {\n    const spy = jest.fn();\n    const store = new Vuex.Store({\n      modules: {\n        a: {\n          state: {\n            value: 1\n          }\n        },\n        b: {}\n      }\n    });\n    store.watch(state => state.a, spy);\n    store.registerModule(['b', 'c'], {\n      state: {\n        value: 2\n      }\n    });\n    Vue.nextTick(() => {\n      expect(spy).not.toHaveBeenCalled();\n      done();\n    });\n  });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"state as function (multiple module in same store)","suites":["Modules","modules usage"],"updatePoint":{"line":172,"column":57,"index":4881},"line":172,"code":"    it('state as function (multiple module in same store)', () => {\n      const module = {\n        state() {\n          return {\n            a: 0\n          };\n        },\n\n        mutations: {\n          [TEST](state, n) {\n            state.a += n;\n          }\n\n        }\n      };\n      const store = new Vuex.Store({\n        modules: {\n          one: module,\n          two: module\n        }\n      });\n      expect(store.state.one.a).toBe(0);\n      expect(store.state.two.a).toBe(0);\n      store.commit(TEST, 1);\n      expect(store.state.one.a).toBe(1);\n      expect(store.state.two.a).toBe(1);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"state as function (same module in multiple stores)","suites":["Modules","modules usage"],"updatePoint":{"line":199,"column":58,"index":5482},"line":199,"code":"    it('state as function (same module in multiple stores)', () => {\n      const module = {\n        state() {\n          return {\n            a: 0\n          };\n        },\n\n        mutations: {\n          [TEST](state, n) {\n            state.a += n;\n          }\n\n        }\n      };\n      const storeA = new Vuex.Store({\n        modules: {\n          foo: module\n        }\n      });\n      const storeB = new Vuex.Store({\n        modules: {\n          bar: module\n        }\n      });\n      expect(storeA.state.foo.a).toBe(0);\n      expect(storeB.state.bar.a).toBe(0);\n      storeA.commit(TEST, 1);\n      expect(storeA.state.foo.a).toBe(1);\n      expect(storeB.state.bar.a).toBe(0);\n      storeB.commit(TEST, 2);\n      expect(storeA.state.foo.a).toBe(1);\n      expect(storeB.state.bar.a).toBe(2);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: mutation","suites":["Modules","modules usage"],"updatePoint":{"line":233,"column":24,"index":6245},"line":233,"code":"    it('module: mutation', function () {\n      const mutations = {\n        [TEST](state, n) {\n          state.a += n;\n        }\n\n      };\n      const store = new Vuex.Store({\n        state: {\n          a: 1\n        },\n        mutations,\n        modules: {\n          nested: {\n            state: {\n              a: 2\n            },\n            mutations,\n            modules: {\n              one: {\n                state: {\n                  a: 3\n                },\n                mutations\n              },\n              nested: {\n                modules: {\n                  two: {\n                    state: {\n                      a: 4\n                    },\n                    mutations\n                  },\n                  three: {\n                    state: {\n                      a: 5\n                    },\n                    mutations\n                  }\n                }\n              }\n            }\n          },\n          four: {\n            state: {\n              a: 6\n            },\n            mutations\n          }\n        }\n      });\n      store.commit(TEST, 1);\n      expect(store.state.a).toBe(2);\n      expect(store.state.nested.a).toBe(3);\n      expect(store.state.nested.one.a).toBe(4);\n      expect(store.state.nested.nested.two.a).toBe(5);\n      expect(store.state.nested.nested.three.a).toBe(6);\n      expect(store.state.four.a).toBe(7);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: action","suites":["Modules","modules usage"],"updatePoint":{"line":292,"column":22,"index":7621},"line":292,"code":"    it('module: action', function () {\n      let calls = 0;\n\n      const makeAction = n => {\n        return {\n          [TEST]({\n            state,\n            rootState\n          }) {\n            calls++;\n            expect(state.a).toBe(n);\n            expect(rootState).toBe(store.state);\n          }\n\n        };\n      };\n\n      const store = new Vuex.Store({\n        state: {\n          a: 1\n        },\n        actions: makeAction(1),\n        modules: {\n          nested: {\n            state: {\n              a: 2\n            },\n            actions: makeAction(2),\n            modules: {\n              one: {\n                state: {\n                  a: 3\n                },\n                actions: makeAction(3)\n              },\n              nested: {\n                modules: {\n                  two: {\n                    state: {\n                      a: 4\n                    },\n                    actions: makeAction(4)\n                  },\n                  three: {\n                    state: {\n                      a: 5\n                    },\n                    actions: makeAction(5)\n                  }\n                }\n              }\n            }\n          },\n          four: {\n            state: {\n              a: 6\n            },\n            actions: makeAction(6)\n          }\n        }\n      });\n      store.dispatch(TEST);\n      expect(calls).toBe(6);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: getters","suites":["Modules","modules usage"],"updatePoint":{"line":356,"column":23,"index":9011},"line":356,"code":"    it('module: getters', function () {\n      const makeGetter = n => ({\n        [`getter${n}`]: (state, getters, rootState) => {\n          expect(getters.constant).toBe(0);\n          expect(rootState).toBe(store.state);\n          return state.a;\n        }\n      });\n\n      const store = new Vuex.Store({\n        state: {\n          a: 1\n        },\n        getters: {\n          constant: () => 0,\n          ...makeGetter(1)\n        },\n        modules: {\n          nested: {\n            state: {\n              a: 2\n            },\n            getters: makeGetter(2),\n            modules: {\n              one: {\n                state: {\n                  a: 3\n                },\n                getters: makeGetter(3)\n              },\n              nested: {\n                modules: {\n                  two: {\n                    state: {\n                      a: 4\n                    },\n                    getters: makeGetter(4)\n                  },\n                  three: {\n                    state: {\n                      a: 5\n                    },\n                    getters: makeGetter(5)\n                  }\n                }\n              }\n            }\n          },\n          four: {\n            state: {\n              a: 6\n            },\n            getters: makeGetter(6)\n          }\n        }\n      });\n      [1, 2, 3, 4, 5, 6].forEach(n => {\n        expect(store.getters[`getter${n}`]).toBe(n);\n      });\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: namespace","suites":["Modules","modules usage"],"updatePoint":{"line":416,"column":25,"index":10444},"line":416,"code":"    it('module: namespace', () => {\n      const actionSpy = jest.fn();\n      const mutationSpy = jest.fn();\n      const store = new Vuex.Store({\n        modules: {\n          a: {\n            namespaced: true,\n            state: {\n              a: 1\n            },\n            getters: {\n              b: () => 2\n            },\n            actions: {\n              [TEST]: actionSpy\n            },\n            mutations: {\n              [TEST]: mutationSpy\n            }\n          }\n        }\n      });\n      expect(store.state.a.a).toBe(1);\n      expect(store.getters['a/b']).toBe(2);\n      store.dispatch('a/' + TEST);\n      expect(actionSpy).toHaveBeenCalled();\n      store.commit('a/' + TEST);\n      expect(mutationSpy).toHaveBeenCalled();\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: nested namespace","suites":["Modules","modules usage"],"updatePoint":{"line":445,"column":32,"index":11202},"line":445,"code":"    it('module: nested namespace', () => {\n      // mock module generator\n      const actionSpys = [];\n      const mutationSpys = [];\n\n      const createModule = (name, namespaced, children) => {\n        const actionSpy = jest.fn();\n        const mutationSpy = jest.fn();\n        actionSpys.push(actionSpy);\n        mutationSpys.push(mutationSpy);\n        return {\n          namespaced,\n          state: {\n            [name]: true\n          },\n          getters: {\n            [name]: state => state[name]\n          },\n          actions: {\n            [name]: actionSpy\n          },\n          mutations: {\n            [name]: mutationSpy\n          },\n          modules: children\n        };\n      }; // mock module\n\n\n      const modules = {\n        a: createModule('a', true, {\n          // a/a\n          b: createModule('b', false, {\n            // a/b - does not add namespace\n            c: createModule('c', true) // a/c/c\n\n          }),\n          d: createModule('d', true) // a/d/d\n\n        })\n      };\n      const store = new Vuex.Store({\n        modules\n      });\n      const expectedTypes = ['a/a', 'a/b', 'a/c/c', 'a/d/d']; // getters\n\n      expectedTypes.forEach(type => {\n        expect(store.getters[type]).toBe(true);\n      }); // actions\n\n      expectedTypes.forEach(type => {\n        store.dispatch(type);\n      });\n      actionSpys.forEach(spy => {\n        expect(spy).toHaveBeenCalledTimes(1);\n      }); // mutations\n\n      expectedTypes.forEach(type => {\n        store.commit(type);\n      });\n      mutationSpys.forEach(spy => {\n        expect(spy).toHaveBeenCalledTimes(1);\n      });\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: getters are namespaced in namespaced module","suites":["Modules","modules usage"],"updatePoint":{"line":509,"column":59,"index":12840},"line":509,"code":"    it('module: getters are namespaced in namespaced module', () => {\n      const store = new Vuex.Store({\n        state: {\n          value: 'root'\n        },\n        getters: {\n          foo: state => state.value\n        },\n        modules: {\n          a: {\n            namespaced: true,\n            state: {\n              value: 'module'\n            },\n            getters: {\n              foo: state => state.value,\n              bar: (state, getters) => getters.foo,\n              baz: (state, getters, rootState, rootGetters) => rootGetters.foo\n            }\n          }\n        }\n      });\n      expect(store.getters['a/foo']).toBe('module');\n      expect(store.getters['a/bar']).toBe('module');\n      expect(store.getters['a/baz']).toBe('root');\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: action context is namespaced in namespaced module","suites":["Modules","modules usage"],"updatePoint":{"line":535,"column":65,"index":13607},"line":535,"code":"    it('module: action context is namespaced in namespaced module', done => {\n      const rootActionSpy = jest.fn();\n      const rootMutationSpy = jest.fn();\n      const moduleActionSpy = jest.fn();\n      const moduleMutationSpy = jest.fn();\n      const store = new Vuex.Store({\n        state: {\n          value: 'root'\n        },\n        getters: {\n          foo: state => state.value\n        },\n        actions: {\n          foo: rootActionSpy\n        },\n        mutations: {\n          foo: rootMutationSpy\n        },\n        modules: {\n          a: {\n            namespaced: true,\n            state: {\n              value: 'module'\n            },\n            getters: {\n              foo: state => state.value\n            },\n            actions: {\n              foo: moduleActionSpy,\n\n              test({\n                dispatch,\n                commit,\n                getters,\n                rootGetters\n              }) {\n                expect(getters.foo).toBe('module');\n                expect(rootGetters.foo).toBe('root');\n                dispatch('foo');\n                expect(moduleActionSpy).toHaveBeenCalledTimes(1);\n                dispatch('foo', null, {\n                  root: true\n                });\n                expect(rootActionSpy).toHaveBeenCalledTimes(1);\n                commit('foo');\n                expect(moduleMutationSpy).toHaveBeenCalledTimes(1);\n                commit('foo', null, {\n                  root: true\n                });\n                expect(rootMutationSpy).toHaveBeenCalledTimes(1);\n                done();\n              }\n\n            },\n            mutations: {\n              foo: moduleMutationSpy\n            }\n          }\n        }\n      });\n      store.dispatch('a/test');\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: use other module that has same namespace","suites":["Modules","modules usage"],"updatePoint":{"line":597,"column":56,"index":15342},"line":597,"code":"    it('module: use other module that has same namespace', done => {\n      const actionSpy = jest.fn();\n      const mutationSpy = jest.fn();\n      const store = new Vuex.Store({\n        modules: {\n          parent: {\n            namespaced: true,\n            modules: {\n              a: {\n                state: {\n                  value: 'a'\n                },\n                getters: {\n                  foo: state => state.value\n                },\n                actions: {\n                  foo: actionSpy\n                },\n                mutations: {\n                  foo: mutationSpy\n                }\n              },\n              b: {\n                state: {\n                  value: 'b'\n                },\n                getters: {\n                  bar: (state, getters) => getters.foo\n                },\n                actions: {\n                  test({\n                    dispatch,\n                    commit,\n                    getters\n                  }) {\n                    expect(getters.foo).toBe('a');\n                    expect(getters.bar).toBe('a');\n                    dispatch('foo');\n                    expect(actionSpy).toHaveBeenCalled();\n                    commit('foo');\n                    expect(mutationSpy).toHaveBeenCalled();\n                    done();\n                  }\n\n                }\n              }\n            }\n          }\n        }\n      });\n      store.dispatch('parent/test');\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"module: warn when module overrides state","suites":["Modules","modules usage"],"updatePoint":{"line":649,"column":48,"index":16784},"line":649,"code":"    it('module: warn when module overrides state', () => {\n      jest.spyOn(console, 'warn').mockImplementation();\n      const store = new Vuex.Store({\n        modules: {\n          foo: {\n            state() {\n              return {\n                value: 1\n              };\n            },\n\n            modules: {\n              value: {\n                state: () => 2\n              }\n            }\n          }\n        }\n      });\n      expect(store.state.foo.value).toBe(2);\n      expect(console.warn).toHaveBeenCalledWith(`[vuex] state field \"value\" was overridden by a module with the same name at \"foo.value\"`);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"dispatching multiple actions in different modules","suites":["Modules","modules usage"],"updatePoint":{"line":671,"column":57,"index":17416},"line":671,"code":"    it('dispatching multiple actions in different modules', done => {\n      const store = new Vuex.Store({\n        modules: {\n          a: {\n            actions: {\n              [TEST]() {\n                return 1;\n              }\n\n            }\n          },\n          b: {\n            actions: {\n              [TEST]() {\n                return new Promise(r => r(2));\n              }\n\n            }\n          }\n        }\n      });\n      store.dispatch(TEST).then(res => {\n        expect(res[0]).toBe(1);\n        expect(res[1]).toBe(2);\n        done();\n      });\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"root actions dispatched in namespaced modules","suites":["Modules","modules usage"],"updatePoint":{"line":698,"column":53,"index":17983},"line":698,"code":"    it('root actions dispatched in namespaced modules', done => {\n      const store = new Vuex.Store({\n        modules: {\n          a: {\n            namespaced: true,\n            actions: {\n              [TEST]: {\n                root: true,\n\n                handler() {\n                  return 1;\n                }\n\n              }\n            }\n          },\n          b: {\n            namespaced: true,\n            actions: {\n              [TEST]: {\n                root: true,\n\n                handler() {\n                  return new Promise(r => r(2));\n                }\n\n              }\n            }\n          },\n          c: {\n            namespaced: true,\n            actions: {\n              [TEST]: {\n                handler() {\n                  // Should not be called\n                  return 3;\n                }\n\n              }\n            }\n          },\n          d: {\n            namespaced: true,\n            actions: {\n              [TEST]() {\n                // Should not be called\n                return 4;\n              }\n\n            }\n          }\n        }\n      });\n      store.dispatch(TEST).then(res => {\n        expect(res.length).toBe(2);\n        expect(res[0]).toBe(1);\n        expect(res[1]).toBe(2);\n        done();\n      });\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"plugins","suites":["Modules","modules usage"],"updatePoint":{"line":758,"column":15,"index":19215},"line":758,"code":"    it('plugins', function () {\n      let initState;\n      const actionSpy = jest.fn();\n      const mutations = [];\n      const subscribeActionSpy = jest.fn();\n      const store = new Vuex.Store({\n        state: {\n          a: 1\n        },\n        mutations: {\n          [TEST](state, n) {\n            state.a += n;\n          }\n\n        },\n        actions: {\n          [TEST]: actionSpy\n        },\n        plugins: [store => {\n          initState = store.state;\n          store.subscribe((mut, state) => {\n            expect(state).toBe(state);\n            mutations.push(mut);\n          });\n          store.subscribeAction(subscribeActionSpy);\n        }]\n      });\n      expect(initState).toBe(store.state);\n      store.commit(TEST, 2);\n      store.dispatch(TEST, 2);\n      expect(mutations.length).toBe(1);\n      expect(mutations[0].type).toBe(TEST);\n      expect(mutations[0].payload).toBe(2);\n      expect(actionSpy).toHaveBeenCalled();\n      expect(subscribeActionSpy).toHaveBeenCalledWith({\n        type: TEST,\n        payload: 2\n      }, store.state);\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"action before/after subscribers","suites":["Modules","modules usage"],"updatePoint":{"line":797,"column":39,"index":20306},"line":797,"code":"    it('action before/after subscribers', done => {\n      const beforeSpy = jest.fn();\n      const afterSpy = jest.fn();\n      const store = new Vuex.Store({\n        actions: {\n          [TEST]: () => Promise.resolve()\n        },\n        plugins: [store => {\n          store.subscribeAction({\n            before: beforeSpy,\n            after: afterSpy\n          });\n        }]\n      });\n      store.dispatch(TEST, 2);\n      expect(beforeSpy).toHaveBeenCalledWith({\n        type: TEST,\n        payload: 2\n      }, store.state);\n      expect(afterSpy).not.toHaveBeenCalled();\n      Vue.nextTick(() => {\n        expect(afterSpy).toHaveBeenCalledWith({\n          type: TEST,\n          payload: 2\n        }, store.state);\n        done();\n      });\n    });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"action error subscribers","suites":["Modules","modules usage"],"updatePoint":{"line":826,"column":30,"index":21054},"line":826,"code":"  it('action error subscribers', done => {\n    const beforeSpy = jest.fn();\n    const afterSpy = jest.fn();\n    const errorSpy = jest.fn();\n    const error = new Error();\n    const store = new Vuex.Store({\n      actions: {\n        [TEST]: () => Promise.reject(error)\n      },\n      plugins: [store => {\n        store.subscribeAction({\n          before: beforeSpy,\n          after: afterSpy,\n          error: errorSpy\n        });\n      }]\n    });\n    store.dispatch(TEST, 2).catch(() => {\n      expect(beforeSpy).toHaveBeenCalledWith({\n        type: TEST,\n        payload: 2\n      }, store.state);\n      expect(afterSpy).not.toHaveBeenCalled();\n      Vue.nextTick(() => {\n        expect(afterSpy).not.toHaveBeenCalledWith({\n          type: TEST,\n          payload: 2\n        }, store.state);\n        expect(errorSpy).toHaveBeenCalledWith({\n          type: TEST,\n          payload: 2\n        }, store.state, error);\n        done();\n      });\n    });\n  });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"asserts a mutation should be a function","suites":["Modules","modules usage"],"updatePoint":{"line":862,"column":45,"index":22023},"line":862,"code":"  it('asserts a mutation should be a function', () => {\n    expect(() => {\n      new Vuex.Store({\n        mutations: {\n          test: null\n        }\n      });\n    }).toThrowError(/mutations should be function but \"mutations\\.test\" is null/);\n    expect(() => {\n      new Vuex.Store({\n        modules: {\n          foo: {\n            modules: {\n              bar: {\n                mutations: {\n                  test: 123\n                }\n              }\n            }\n          }\n        }\n      });\n    }).toThrowError(/mutations should be function but \"mutations\\.test\" in module \"foo\\.bar\" is 123/);\n  });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"asserts an action should be a function","suites":["Modules","modules usage"],"updatePoint":{"line":886,"column":44,"index":22633},"line":886,"code":"  it('asserts an action should be a function', () => {\n    expect(() => {\n      new Vuex.Store({\n        actions: {\n          test: 'test'\n        }\n      });\n    }).toThrowError(/actions should be function or object with \"handler\" function but \"actions\\.test\" is \"test\"/);\n    expect(() => {\n      new Vuex.Store({\n        modules: {\n          foo: {\n            modules: {\n              bar: {\n                actions: {\n                  test: 'error'\n                }\n              }\n            }\n          }\n        }\n      });\n    }).toThrowError(/actions should be function or object with \"handler\" function but \"actions\\.test\" in module \"foo\\.bar\" is \"error\"/);\n  });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"asserts a getter should be a function","suites":["Modules","modules usage"],"updatePoint":{"line":910,"column":43,"index":23310},"line":910,"code":"  it('asserts a getter should be a function', () => {\n    expect(() => {\n      new Vuex.Store({\n        getters: {\n          test: undefined\n        }\n      });\n    }).toThrowError(/getters should be function but \"getters\\.test\" is undefined/);\n    expect(() => {\n      new Vuex.Store({\n        modules: {\n          foo: {\n            modules: {\n              bar: {\n                getters: {\n                  test: true\n                }\n              }\n            }\n          }\n        }\n      });\n    }).toThrowError(/getters should be function but \"getters\\.test\" in module \"foo\\.bar\" is true/);\n  });","file":"unit/modules.spec.js","skipped":false,"dir":"test"},{"name":"committing mutations","suites":["Store"],"updatePoint":{"line":6,"column":26,"index":173},"line":6,"code":"  it('committing mutations', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations: {\n        [TEST](state, n) {\n          state.a += n;\n        }\n\n      }\n    });\n    store.commit(TEST, 2);\n    expect(store.state.a).toBe(3);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"committing with object style","suites":["Store"],"updatePoint":{"line":21,"column":34,"index":455},"line":21,"code":"  it('committing with object style', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations: {\n        [TEST](state, payload) {\n          state.a += payload.amount;\n        }\n\n      }\n    });\n    store.commit({\n      type: TEST,\n      amount: 2\n    });\n    expect(store.state.a).toBe(3);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"asserts committed type","suites":["Store"],"updatePoint":{"line":39,"column":28,"index":784},"line":39,"code":"  it('asserts committed type', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations: {\n        // Maybe registered with undefined type accidentally\n        // if the user has typo in a constant type\n        undefined(state, n) {\n          state.a += n;\n        }\n\n      }\n    });\n    expect(() => {\n      store.commit(undefined, 2);\n    }).toThrowError(/expects string as the type, but found undefined/);\n    expect(store.state.a).toBe(1);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"dispatching actions, sync","suites":["Store"],"updatePoint":{"line":58,"column":31,"index":1276},"line":58,"code":"  it('dispatching actions, sync', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations: {\n        [TEST](state, n) {\n          state.a += n;\n        }\n\n      },\n      actions: {\n        [TEST]({\n          commit\n        }, n) {\n          commit(TEST, n);\n        }\n\n      }\n    });\n    store.dispatch(TEST, 2);\n    expect(store.state.a).toBe(3);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"dispatching with object style","suites":["Store"],"updatePoint":{"line":81,"column":35,"index":1675},"line":81,"code":"  it('dispatching with object style', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations: {\n        [TEST](state, n) {\n          state.a += n;\n        }\n\n      },\n      actions: {\n        [TEST]({\n          commit\n        }, payload) {\n          commit(TEST, payload.amount);\n        }\n\n      }\n    });\n    store.dispatch({\n      type: TEST,\n      amount: 2\n    });\n    expect(store.state.a).toBe(3);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"dispatching actions, with returned Promise","suites":["Store"],"updatePoint":{"line":107,"column":48,"index":2140},"line":107,"code":"  it('dispatching actions, with returned Promise', done => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations: {\n        [TEST](state, n) {\n          state.a += n;\n        }\n\n      },\n      actions: {\n        [TEST]({\n          commit\n        }, n) {\n          return new Promise(resolve => {\n            setTimeout(() => {\n              commit(TEST, n);\n              resolve();\n            }, 0);\n          });\n        }\n\n      }\n    });\n    expect(store.state.a).toBe(1);\n    store.dispatch(TEST, 2).then(() => {\n      expect(store.state.a).toBe(3);\n      done();\n    });\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"composing actions with async/await","suites":["Store"],"updatePoint":{"line":138,"column":40,"index":2752},"line":138,"code":"  it('composing actions with async/await', done => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations: {\n        [TEST](state, n) {\n          state.a += n;\n        }\n\n      },\n      actions: {\n        [TEST]({\n          commit\n        }, n) {\n          return new Promise(resolve => {\n            setTimeout(() => {\n              commit(TEST, n);\n              resolve();\n            }, 0);\n          });\n        },\n\n        two: async ({\n          commit,\n          dispatch\n        }, n) => {\n          await dispatch(TEST, 1);\n          expect(store.state.a).toBe(2);\n          commit(TEST, n);\n        }\n      }\n    });\n    expect(store.state.a).toBe(1);\n    store.dispatch('two', 3).then(() => {\n      expect(store.state.a).toBe(5);\n      done();\n    });\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"detecting action Promise errors","suites":["Store"],"updatePoint":{"line":177,"column":37,"index":3554},"line":177,"code":"  it('detecting action Promise errors', done => {\n    const store = new Vuex.Store({\n      actions: {\n        [TEST]() {\n          return new Promise((resolve, reject) => {\n            reject('no');\n          });\n        }\n\n      }\n    });\n    const spy = jest.fn();\n    store._devtoolHook = {\n      emit: spy\n    };\n    const thenSpy = jest.fn();\n    store.dispatch(TEST).then(thenSpy).catch(err => {\n      expect(thenSpy).not.toHaveBeenCalled();\n      expect(err).toBe('no');\n      expect(spy).toHaveBeenCalledWith('vuex:error', 'no');\n      done();\n    });\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"asserts dispatched type","suites":["Store"],"updatePoint":{"line":200,"column":29,"index":4112},"line":200,"code":"  it('asserts dispatched type', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 1\n      },\n      mutations: {\n        [TEST](state, n) {\n          state.a += n;\n        }\n\n      },\n      actions: {\n        // Maybe registered with undefined type accidentally\n        // if the user has typo in a constant type\n        undefined({\n          commit\n        }, n) {\n          commit(TEST, n);\n        }\n\n      }\n    });\n    expect(() => {\n      store.dispatch(undefined, 2);\n    }).toThrowError(/expects string as the type, but found undefined/);\n    expect(store.state.a).toBe(1);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"getters","suites":["Store"],"updatePoint":{"line":227,"column":13,"index":4702},"line":227,"code":"  it('getters', () => {\n    const store = new Vuex.Store({\n      state: {\n        a: 0\n      },\n      getters: {\n        state: state => state.a > 0 ? 'hasAny' : 'none'\n      },\n      mutations: {\n        [TEST](state, n) {\n          state.a += n;\n        }\n\n      },\n      actions: {\n        check({\n          getters\n        }, value) {\n          // check for exposing getters into actions\n          expect(getters.state).toBe(value);\n        }\n\n      }\n    });\n    expect(store.getters.state).toBe('none');\n    store.dispatch('check', 'none');\n    store.commit(TEST, 1);\n    expect(store.getters.state).toBe('hasAny');\n    store.dispatch('check', 'hasAny');\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"store injection","suites":["Store"],"updatePoint":{"line":257,"column":21,"index":5377},"line":257,"code":"  it('store injection', () => {\n    const store = new Vuex.Store();\n    const vm = new Vue({\n      store\n    });\n    const child = new Vue({\n      parent: vm\n    });\n    expect(child.$store).toBe(store);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"should warn silent option depreciation","suites":["Store"],"updatePoint":{"line":267,"column":44,"index":5610},"line":267,"code":"  it('should warn silent option depreciation', () => {\n    jest.spyOn(console, 'warn').mockImplementation();\n    const store = new Vuex.Store({\n      mutations: {\n        [TEST]() {}\n\n      }\n    });\n    store.commit(TEST, {}, {\n      silent: true\n    });\n    expect(console.warn).toHaveBeenCalledWith(`[vuex] mutation type: ${TEST}. Silent option has been removed. ` + 'Use the filter functionality in the vue-devtools');\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"asserts the call with the new operator","suites":["Store"],"updatePoint":{"line":280,"column":44,"index":6039},"line":280,"code":"  it('asserts the call with the new operator', () => {\n    expect(() => {\n      Vuex.Store({});\n    }).toThrowError(/Cannot call a class as a function/);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"should accept state as function","suites":["Store"],"updatePoint":{"line":285,"column":37,"index":6192},"line":285,"code":"  it('should accept state as function', () => {\n    const store = new Vuex.Store({\n      state: () => ({\n        a: 1\n      }),\n      mutations: {\n        [TEST](state, n) {\n          state.a += n;\n        }\n\n      }\n    });\n    expect(store.state.a).toBe(1);\n    store.commit(TEST, 2);\n    expect(store.state.a).toBe(3);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"should not call root state function twice","suites":["Store"],"updatePoint":{"line":301,"column":47,"index":6530},"line":301,"code":"  it('should not call root state function twice', () => {\n    const spy = jest.fn().mockReturnValue(1);\n    new Vuex.Store({\n      state: spy\n    });\n    expect(spy).toHaveBeenCalledTimes(1);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"subscribe: should handle subscriptions / unsubscriptions","suites":["Store"],"updatePoint":{"line":308,"column":62,"index":6743},"line":308,"code":"  it('subscribe: should handle subscriptions / unsubscriptions', () => {\n    const subscribeSpy = jest.fn();\n    const secondSubscribeSpy = jest.fn();\n    const testPayload = 2;\n    const store = new Vuex.Store({\n      state: {},\n      mutations: {\n        [TEST]: () => {}\n      }\n    });\n    const unsubscribe = store.subscribe(subscribeSpy);\n    store.subscribe(secondSubscribeSpy);\n    store.commit(TEST, testPayload);\n    unsubscribe();\n    store.commit(TEST, testPayload);\n    expect(subscribeSpy).toHaveBeenCalledWith({\n      type: TEST,\n      payload: testPayload\n    }, store.state);\n    expect(secondSubscribeSpy).toHaveBeenCalled();\n    expect(subscribeSpy).toHaveBeenCalledTimes(1);\n    expect(secondSubscribeSpy).toHaveBeenCalledTimes(2);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"subscribe: should handle subscriptions with synchronous unsubscriptions","suites":["Store"],"updatePoint":{"line":331,"column":77,"index":7516},"line":331,"code":"  it('subscribe: should handle subscriptions with synchronous unsubscriptions', () => {\n    const subscribeSpy = jest.fn();\n    const testPayload = 2;\n    const store = new Vuex.Store({\n      state: {},\n      mutations: {\n        [TEST]: () => {}\n      }\n    });\n    const unsubscribe = store.subscribe(() => unsubscribe());\n    store.subscribe(subscribeSpy);\n    store.commit(TEST, testPayload);\n    expect(subscribeSpy).toHaveBeenCalledWith({\n      type: TEST,\n      payload: testPayload\n    }, store.state);\n    expect(subscribeSpy).toHaveBeenCalledTimes(1);\n  });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"subscribeAction: should handle subscriptions with synchronous unsubscriptions","suites":["Store"],"updatePoint":{"line":349,"column":83,"index":8090},"line":349,"code":"  it('subscribeAction: should handle subscriptions with synchronous unsubscriptions', () => {\n    const subscribeSpy = jest.fn();\n    const testPayload = 2;\n    const store = new Vuex.Store({\n      state: {},\n      actions: {\n        [TEST]: () => {}\n      }\n    });\n    const unsubscribe = store.subscribeAction(() => unsubscribe());\n    store.subscribeAction(subscribeSpy);\n    store.dispatch(TEST, testPayload);\n    expect(subscribeSpy).toHaveBeenCalledWith({\n      type: TEST,\n      payload: testPayload\n    }, store.state);\n    expect(subscribeSpy).toHaveBeenCalledTimes(1);\n  }); // store.watch should only be asserted in non-SSR environment","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"strict mode: warn mutations outside of handlers","suites":["Store"],"updatePoint":{"line":369,"column":55,"index":8727},"line":369,"code":"    it('strict mode: warn mutations outside of handlers', () => {\n      const spy = jest.spyOn(console, 'error').mockImplementation();\n      const store = new Vuex.Store({\n        state: {\n          a: 1\n        },\n        strict: true\n      });\n      Vue.config.silent = true;\n      store.state.a++;\n      expect(spy).toHaveBeenCalled();\n      Vue.config.silent = false;\n    });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"watch: with resetting vm","suites":["Store"],"updatePoint":{"line":382,"column":32,"index":9084},"line":382,"code":"    it('watch: with resetting vm', done => {\n      const store = new Vuex.Store({\n        state: {\n          count: 0\n        },\n        mutations: {\n          [TEST]: state => state.count++\n        }\n      });\n      const spy = jest.fn();\n      store.watch(state => state.count, spy); // reset store vm\n\n      store.registerModule('test', {});\n      Vue.nextTick(() => {\n        store.commit(TEST);\n        expect(store.state.count).toBe(1);\n        Vue.nextTick(() => {\n          expect(spy).toHaveBeenCalled();\n          done();\n        });\n      });\n    });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"watch: getter function has access to store's getters object","suites":["Store"],"updatePoint":{"line":404,"column":68,"index":9682},"line":404,"code":"    it('watch: getter function has access to store\\'s getters object', done => {\n      const store = new Vuex.Store({\n        state: {\n          count: 0\n        },\n        mutations: {\n          [TEST]: state => state.count++\n        },\n        getters: {\n          getCount: state => state.count\n        }\n      });\n\n      const getter = function getter(state, getters) {\n        return state.count;\n      };\n\n      const spy = jest.spyOn({\n        getter\n      }, 'getter');\n      const spyCb = jest.fn();\n      store.watch(spy, spyCb);\n      Vue.nextTick(() => {\n        store.commit(TEST);\n        expect(store.state.count).toBe(1);\n        Vue.nextTick(() => {\n          expect(spy).toHaveBeenCalledWith(store.state, store.getters);\n          done();\n        });\n      });\n    });","file":"unit/store.spec.js","skipped":false,"dir":"test"},{"name":"find: returns item when it was found","suites":["util"],"updatePoint":{"line":3,"column":42,"index":152},"line":3,"code":"  it('find: returns item when it was found', () => {\n    const list = [33, 22, 112, 222, 43];\n    expect(find(list, function (a) {\n      return a % 2 === 0;\n    })).toEqual(22);\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"},{"name":"find: returns undefined when item was not found","suites":["util"],"updatePoint":{"line":9,"column":53,"index":347},"line":9,"code":"  it('find: returns undefined when item was not found', () => {\n    const list = [1, 2, 3];\n    expect(find(list, function (a) {\n      return a === 9000;\n    })).toEqual(undefined);\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"},{"name":"deepCopy: normal structure","suites":["util"],"updatePoint":{"line":15,"column":32,"index":514},"line":15,"code":"  it('deepCopy: normal structure', () => {\n    const original = {\n      a: 1,\n      b: 'string',\n      c: true,\n      d: null,\n      e: undefined\n    };\n    const copy = deepCopy(original);\n    expect(copy).toEqual(original);\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"},{"name":"deepCopy: nested structure","suites":["util"],"updatePoint":{"line":26,"column":32,"index":746},"line":26,"code":"  it('deepCopy: nested structure', () => {\n    const original = {\n      a: {\n        b: 1,\n        c: [2, 3, {\n          d: 4\n        }]\n      }\n    };\n    const copy = deepCopy(original);\n    expect(copy).toEqual(original);\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"},{"name":"deepCopy: circular structure","suites":["util"],"updatePoint":{"line":38,"column":34,"index":979},"line":38,"code":"  it('deepCopy: circular structure', () => {\n    const original = {\n      a: 1\n    };\n    original.circular = original;\n    const copy = deepCopy(original);\n    expect(copy).toEqual(original);\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"},{"name":"forEachValue","suites":["util"],"updatePoint":{"line":46,"column":18,"index":1162},"line":46,"code":"  it('forEachValue', () => {\n    let number = 1;\n\n    function plus(value, key) {\n      number += value;\n    }\n\n    const origin = {\n      a: 1,\n      b: 3\n    };\n    forEachValue(origin, plus);\n    expect(number).toEqual(5);\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"},{"name":"isObject","suites":["util"],"updatePoint":{"line":60,"column":14,"index":1390},"line":60,"code":"  it('isObject', () => {\n    expect(isObject(1)).toBe(false);\n    expect(isObject('String')).toBe(false);\n    expect(isObject(undefined)).toBe(false);\n    expect(isObject({})).toBe(true);\n    expect(isObject(null)).toBe(false);\n    expect(isObject([])).toBe(true);\n    expect(isObject(new Function())).toBe(false);\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"},{"name":"isPromise","suites":["util"],"updatePoint":{"line":69,"column":15,"index":1712},"line":69,"code":"  it('isPromise', () => {\n    const promise = new Promise(() => {}, () => {});\n    expect(isPromise(1)).toBe(false);\n    expect(isPromise(promise)).toBe(true);\n    expect(isPromise(new Function())).toBe(false);\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"},{"name":"assert","suites":["util"],"updatePoint":{"line":75,"column":12,"index":1926},"line":75,"code":"  it('assert', () => {\n    expect(assert.bind(null, false, 'Hello')).toThrowError('[vuex] Hello');\n  });","file":"unit/util.spec.js","skipped":false,"dir":"test"}]}