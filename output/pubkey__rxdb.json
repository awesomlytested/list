{"repo":"pubkey/rxdb","url":"https://github.com/pubkey/rxdb","branch":"master","configs":[{"package":"angular","lang":"ts","dir":"examples/angular/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"rxdb-example-electron-remote","lang":"js","dir":"examples/electron-remote/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"rxdb-example-electron","lang":"js","dir":"examples/electron/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"graphql","lang":"js","dir":"examples/graphql/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"rxdb-example-react","lang":"js","dir":"examples/react/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"svelte-app","lang":"js","dir":"examples/svelte/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"vue2","lang":"js","dir":"examples/vue/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"rxdb","lang":"ts","dir":"test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"wait for first request until the server has bootet","suites":["ssr.test.ts"],"updatePoint":{"line":18,"column":58},"line":18,"code":"    it('wait for first request until the server has bootet', async () => {\n        await waitUntil(\n            async () => {\n                try {\n                    await getHtml(baseUrl);\n                    return true;\n                } catch (err) {\n                    console.log('-- waiting for server to start');\n                    return false;\n                }\n            },\n            undefined,\n            1000\n        );\n    });","file":"ssr.test.ts","skipped":false,"dir":"examples/angular/test"},{"name":"should get some html","suites":["ssr.test.ts"],"updatePoint":{"line":34,"column":28},"line":34,"code":"    it('should get some html', async () => {\n        console.log('run first request');\n        const html = await getHtml(baseUrl);\n        console.log('run first request DONE');\n        assert.ok(html);\n    });","file":"ssr.test.ts","skipped":false,"dir":"examples/angular/test"},{"name":"should contain data from the rxdb instance","suites":["ssr.test.ts"],"updatePoint":{"line":40,"column":50},"line":40,"code":"    it('should contain data from the rxdb instance', async function () {\n        /**\n         * If the timeout of 5 seconds is not enough,\n         * there is likely something wrong with RxDB.\n         * For example an open setTimeout prevents ssr from knowing the page is loaded\n         */\n        this.timeout(1000 * 5);\n        const html = await getHtml(baseUrl);\n        assert.ok(html.includes('Gandalf'));\n    });","file":"ssr.test.ts","skipped":false,"dir":"examples/angular/test"},{"name":"reach couchdb server","suites":["couchdb-db-integration.test.js"],"updatePoint":{"line":31,"column":28},"line":31,"code":"    it('reach couchdb server', async function () {\n        /**\n         * After the couchdb container is started,\n         * it can take some time until the replication endpoint is reachable\n         */\n        this.timeout(1000 * 60);\n\n        await waitUntil(async () => {\n            try {\n                const gotJson = await request(COUCHDB_URL);\n                // ensure json is parseable\n                JSON.parse(gotJson);\n                return true;\n            } catch (err) {\n                console.error('could not reach couchdb server at ' + COUCHDB_URL);\n                return false;\n            }\n        }, 1000 * 60, 1000);\n    });","file":"couch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"sync to couchdb","suites":["couchdb-db-integration.test.js"],"updatePoint":{"line":51,"column":23},"line":51,"code":"    it('sync to couchdb', async () => {\n        const col = await humansCollection.create(0);\n\n        const couchName = COUCHDB_URL + randomCouchString(12);\n        const replicationState = await col.syncCouchDB({\n            remote: couchName,\n            waitForLeadership: false,\n            direction: {\n                pull: true,\n                push: true\n            }\n        });\n        replicationState.docs$.subscribe(docData => console.dir(docData));\n\n        // add 3 docs\n        await Promise.all(\n            new Array(3)\n                .fill(0)\n                .map(() => col.insert(schemaObjects.human()))\n        );\n        const docs1 = await col.find().exec();\n        assert.strictEqual(docs1.length, 3);\n\n\n        // create a new collection\n        const col2 = await humansCollection.create(0);\n        await col2.syncCouchDB({\n            remote: couchName,\n            waitForLeadership: false,\n            direction: {\n                pull: true,\n                push: true\n            }\n        });\n\n        await waitUntil(async () => {\n            const docs = await col2.find().exec();\n            return docs.length === 3;\n        });\n\n        col.database.destroy();\n        col2.database.destroy();\n    });","file":"couch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"should not have enabled dev-mode which would affect the performance","suites":["performance.test.ts"],"updatePoint":{"line":18,"column":75},"line":18,"code":"    it('should not have enabled dev-mode which would affect the performance', () => {\n        assert.strictEqual(\n            overwritable.isDevMode(),\n            false\n        );\n    });","file":"performance.test.ts","skipped":false,"dir":"test"},{"name":"run the performance test","suites":["performance.test.ts"],"updatePoint":{"line":24,"column":32},"line":24,"code":"    it('run the performance test', async function () {\n        this.timeout(120 * 1000);\n        const runs = config.isFastMode() ? 1 : 12;\n\n        const perfStorage = config.storage.getPerformanceStorage();\n\n        const totalTimes: { [k: string]: number[] } = {};\n\n        const collectionsAmount = 4;\n        const docsAmount = 600;\n\n        let runsDone = 0;\n        while (runsDone < runs) {\n            /**\n             * Wait a bit to ensure nothing else is running\n             * that would influence the performance.\n             */\n            await wait(200);\n\n            runsDone++;\n\n            let time = performance.now();\n            const updateTime = (flag?: string) => {\n                if (!flag) {\n                    time = performance.now();\n                    return;\n                }\n                const diff = performance.now() - time;\n                if (!totalTimes[flag]) {\n                    totalTimes[flag] = [diff];\n                } else {\n                    totalTimes[flag].push(diff);\n                }\n                time = performance.now();\n            }\n\n            updateTime();\n\n            // create database\n            const db = await createRxDatabase({\n                name: 'test-db-performance-' + randomCouchString(10),\n                eventReduce: true,\n                /**\n                 * A RxStorage implementation (like LokiJS)\n                 * might need a full leader election cycle to be useable.\n                 * So we disable multiInstance here because it would make no sense\n                 * to measure the leader election time instead of the database\n                 * creation time.\n                 */\n                multiInstance: false,\n                storage: perfStorage.storage\n            });\n\n            // create collections\n            const collectionData: any = {};\n            let firstCollectionName: string = '';\n            new Array(collectionsAmount)\n                .fill(0)\n                .forEach((_v, idx) => {\n                    const name = randomCouchString(10) + '_' + idx;\n                    if (!firstCollectionName) {\n                        firstCollectionName = name;\n                    }\n                    collectionData[name] = {\n                        schema: schemas.averageSchema(),\n                        statics: {}\n                    };\n                });\n            const collections = await db.addCollections(collectionData);\n            const collection = collections[firstCollectionName];\n\n\n            /**\n             * Many storages have a lazy initialization.\n             * So it makes no sense to measure the time of database/collection creation.\n             * Insert we do a single insert an measure the time to the first insert.\n             */\n            await collection.insert(schemaObjects.averageSchema());\n            updateTime('time-to-first-insert');\n\n            // insert documents\n            const docIds: string[] = [];\n            const docsData = new Array(docsAmount)\n                .fill(0)\n                .map(() => {\n                    const data = schemaObjects.averageSchema();\n                    docIds.push(data.id);\n                    return data;\n                });\n\n            updateTime();\n            await collection.bulkInsert(docsData);\n            updateTime('insert-documents');\n\n            /**\n             * Find by id,\n             * here we run the query agains the storage because\n             * if we would do collection.findByIds(), it would\n             * just return the documents from the cache.\n             * \n             */\n            const idsResult = await collection.storageInstance.findDocumentsById(docIds, false);\n            updateTime('find-by-ids');\n            assert.strictEqual(Object.keys(idsResult).length, docsAmount);\n\n            // find by query\n            updateTime();\n            const query = collection.find({\n                selector: {\n                    var1: {\n                        $gt: ''\n                    }\n                },\n                sort: [{ var1: 'asc' }]\n            });\n            const queryResult = await query.exec();\n            updateTime('find-by-query');\n            assert.strictEqual(queryResult.length, docsAmount + 1);\n\n            await db.remove();\n        }\n\n\n        const timeToLog: any = {\n            description: perfStorage.description,\n            platform: config.platform.name\n        };\n        Object.entries(totalTimes).forEach(([key, times]) => {\n            timeToLog[key] = averageOfTimeValues(times, 50);\n        });\n\n        console.log('Performance test for ' + perfStorage.description);\n        console.log(JSON.stringify(timeToLog, null, 4));\n        // process.exit();\n    });","file":"performance.test.ts","skipped":false,"dir":"test"},{"name":"should sucess on basic test","suites":["typings.test.js"],"updatePoint":{"line":87,"column":39},"line":87,"code":"        it('should sucess on basic test', async () => {\n            await transpileCode('console.log(\"Hello, world!\")');\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should fail on broken code","suites":["typings.test.js"],"updatePoint":{"line":90,"column":38},"line":90,"code":"        it('should fail on broken code', async () => {\n            const brokenCode = `\n                let x: string = 'foo';\n                x = 1337;\n            `;\n            let thrown = false;\n            try {\n                const code = await transpileCode(brokenCode);\n                console.dir(code);\n            } catch (err) {\n                thrown = true;\n            }\n            assert.ok(thrown);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"import * with strict:true","suites":["typings.test.js"],"updatePoint":{"line":106,"column":37},"line":106,"code":"        it('import * with strict:true', async () => {\n            const code = `\n                import { addPouchPlugin } from '${pouchdbPluginPath}';\n                import * as PouchMemAdapter from 'pouchdb-adapter-memory';\n                addPouchPlugin(PouchMemAdapter);\n            `;\n            await transpileCode(code);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should create the database and use its methods","suites":["typings.test.js","positive"],"updatePoint":{"line":117,"column":62},"line":117,"code":"            it('should create the database and use its methods', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const databaseCreator: RxDatabaseCreator = {\n                            name: 'mydb',\n                            storage: getRxStoragePouch('memory'),\n                            multiInstance: false,\n                            ignoreDuplicate: false\n                        };\n                        const myDb: RxDatabase = await createRxDatabase(databaseCreator);\n                        await myDb.destroy();\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"allow to type-define the collections","suites":["typings.test.js","positive"],"updatePoint":{"line":132,"column":52},"line":132,"code":"            it('allow to type-define the collections', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const db: RxDatabase<{\n                            foobar: RxCollection\n                        }> = {} as RxDatabase<{\n                            foobar: RxCollection\n                        }>;\n                        const col: RxCollection = db.foobar;\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"a collection-untyped database should allow all collection-getters","suites":["typings.test.js","positive"],"updatePoint":{"line":145,"column":81},"line":145,"code":"            it('a collection-untyped database should allow all collection-getters', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const db: RxDatabase = {} as RxDatabase;\n                        const col: RxCollection = db.foobar;\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"an collection-TYPED database should allow to access methods","suites":["typings.test.js","positive"],"updatePoint":{"line":154,"column":75},"line":154,"code":"            it('an collection-TYPED database should allow to access methods', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const db: RxDatabase = {} as RxDatabase;\n                        const col: RxCollection = db.foobar;\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"an allow to use a custom extends type","suites":["typings.test.js","positive"],"updatePoint":{"line":163,"column":53},"line":163,"code":"            it('an allow to use a custom extends type', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        type RxHeroesDatabase = RxDatabase<{\n                            hero: RxCollection;\n                        }>;\n                        const db: RxHeroesDatabase = await createRxDatabase<{\n                            hero: RxCollection;\n                        }>({\n                            name: 'heroes',\n                            storage: getRxStoragePouch('memory')\n                        });\n                        const col: RxCollection = db.hero;\n                        await db.destroy();\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should not allow additional parameters","suites":["typings.test.js","negative"],"updatePoint":{"line":183,"column":54},"line":183,"code":"            it('should not allow additional parameters', async () => {\n                const brokenCode = codeBase + `\n                    const databaseCreator: RxDatabaseCreator = {\n                        name: 'mydb',\n                        storage: getRxStoragePouch('memory'),\n                        multiInstance: false,\n                        ignoreDuplicate: false,\n                        foo: 'bar'\n                    };\n                `;\n                let thrown = false;\n                try {\n                    await transpileCode(brokenCode);\n                } catch (err) {\n                    thrown = true;\n                }\n                assert.ok(thrown);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"an collection-TYPED database should only allow known collection-getters","suites":["typings.test.js","negative"],"updatePoint":{"line":201,"column":87},"line":201,"code":"            it('an collection-TYPED database should only allow known collection-getters', async () => {\n                const brokenCode = codeBase + `\n                    (async() => {\n                        const db: RxDatabase<{\n                            foobar: RxCollection\n                        }> = {} as RxDatabase;\n                        const col: RxCollection = db.foobar;\n                        const col2: RxCollection = db.foobar2;\n                        db.destroy();\n                    })();\n                `;\n                let thrown = false;\n                try {\n                    await transpileCode(brokenCode);\n                } catch (err) {\n                    thrown = true;\n                }\n                assert.ok(thrown);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should work with DocType = any","suites":["typings.test.js","positive"],"updatePoint":{"line":226,"column":46},"line":226,"code":"            it('should work with DocType = any', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const schema: RxJsonSchema<any> = ${JSON.stringify(schemas.humanMinimal)};\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should allow creating generic schema based on a model","suites":["typings.test.js","positive"],"updatePoint":{"line":234,"column":69},"line":234,"code":"            it('should allow creating generic schema based on a model', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const databaseCreator: RxDatabaseCreator = {\n                            name: 'mydb',\n                            storage: getRxStoragePouch('memory'),\n                            multiInstance: false,\n                            ignoreDuplicate: false\n                        };\n                        const myDb: RxDatabase = await createRxDatabase(databaseCreator);\n                        const minimalHuman: RxJsonSchema<DefaultDocType> = ${JSON.stringify(schemas.humanMinimal)};\n                        const myCollections = await myDb.addCollections({\n                            humans: {\n                                schema: minimalHuman,\n                            }\n                        });\n                        await myDb.destroy();\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should not allow wrong properties when passing a model","suites":["typings.test.js","negative"],"updatePoint":{"line":257,"column":70},"line":257,"code":"            it('should not allow wrong properties when passing a model', async () => {\n                const brokenCode = codeBase + `\n                    (async() => {\n                        const databaseCreator: RxDatabaseCreator = {\n                            name: 'mydb',\n                            storage: getRxStoragePouch('memory'),\n                            multiInstance: false,\n                            ignoreDuplicate: false\n                        };\n                        const myDb: RxDatabase = await createRxDatabase(databaseCreator);\n\n                        const minimalHuman: RxJsonSchema<DefaultDocType> = ${JSON.stringify(schemas.humanMinimalBroken)};\n                        const myCollections = await myDb.addCollections({\n                            humans: {\n                                schema: minimalHuman,\n                            }\n                        });\n\n                        await myDb.destroy();\n                    })();\n                `;\n                let thrown = false;\n                try {\n                    await transpileCode(brokenCode);\n                } catch (err) {\n                    thrown = true;\n                }\n                assert.ok(thrown);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"collection-creation","suites":["typings.test.js","positive"],"updatePoint":{"line":292,"column":35},"line":292,"code":"            it('collection-creation', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const myDb: RxDatabase = await createRxDatabase({\n                            name: 'mydb',\n                            storage: getRxStoragePouch('memory'),\n                            multiInstance: false,\n                            ignoreDuplicate: false\n                        });\n                        const mySchema: RxJsonSchema<any> = ${JSON.stringify(schemas.human)};\n                        const cols = await myDb.addCollections({\n                            humans: {\n                                schema: mySchema,\n                                autoMigrate: false,\n                            }\n                        });\n                        const myCollections: RxCollection<any> = cols.humans;\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"typed collection should know its static orm methods","suites":["typings.test.js","positive"],"updatePoint":{"line":313,"column":67},"line":313,"code":"            it('typed collection should know its static orm methods', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const myDb: RxDatabase = await createRxDatabase({\n                            name: 'mydb',\n                            storage: getRxStoragePouch('memory'),\n                            multiInstance: false,\n                            ignoreDuplicate: false\n                        });\n                        const mySchema: RxJsonSchema<any> = ${JSON.stringify(schemas.human)};\n\n                        type staticMethods = {\n                            countAllDocuments: () => Promise<number>;\n                        }\n                        const myCollections = await myDb.addCollections({\n                            humans: {\n                                schema: mySchema,\n                                autoMigrate: false,\n                                statics: {\n                                    countAllDocuments: () => Promise.resolve(1)\n                                }\n                            }\n                        });\n                        const myCollection: RxCollection<any, any, staticMethods> = myCollections.humans as any;\n\n                        await myCollection.countAllDocuments();\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"use options","suites":["typings.test.js","positive"],"updatePoint":{"line":343,"column":27},"line":343,"code":"            it('use options', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const myDb: RxDatabase = await createRxDatabase({\n                            name: 'mydb',\n                            storage: getRxStoragePouch('memory'),\n                            multiInstance: false,\n                            ignoreDuplicate: false,\n                            options: {\n                                foo1: 'bar1'\n                            }\n                        });\n                        const mySchema: RxJsonSchema<any> = ${JSON.stringify(schemas.human)};\n                        const myCollections = await myDb.addCollections({\n                            humans: {\n                                schema: mySchema,\n                                autoMigrate: false,\n                                options: {\n                                    foo2: 'bar2'\n                                }\n                            }\n                        });\n                        const x: string = myDb.options.foo1;\n                        const y: string = myCollections.humans.options.foo2;\n                        myDb.destroy();\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"use underlaying pouchdb","suites":["typings.test.js","positive"],"updatePoint":{"line":372,"column":39},"line":372,"code":"            it('use underlaying pouchdb', async () => {\n                const code = codeBase + `\n                    (async() => {\n                        const myDb: RxDatabase = await createRxDatabase({\n                            name: 'mydb',\n                            storage: getRxStoragePouch('memory'),\n                            multiInstance: false,\n                            ignoreDuplicate: false,\n                            options: {\n                                foo1: 'bar1'\n                            }\n                        });\n                        const mySchema: RxJsonSchema<any> = ${JSON.stringify(schemas.human)};\n                        type docType = {\n                                foo: string\n                        };\n                        const cols = await myDb.addCollections({\n                            humans: {\n                                schema: mySchema,\n                                autoMigrate: false,\n                                options: {\n                                    foo2: 'bar2'\n                                }\n                            }\n                        });\n                        const myCollection: RxCollection<docType> = cols.humans;\n                        const result = await myCollection.storageInstance.internals.pouch.put({\n                            _id: 'foobar',\n                            foo: 'bar'\n                        });\n                        const docs = await myCollection.storageInstance.internals.pouch.allDocs();\n                    })();\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should not allow wrong collection-settings","suites":["typings.test.js","negative"],"updatePoint":{"line":409,"column":58},"line":409,"code":"            it('should not allow wrong collection-settings', async () => {\n                const brokenCode = codeBase + `\n                    (async() => {\n                        const myDb: RxDatabase = await createRxDatabase({\n                            name: 'mydb',\n                            storage: getRxStoragePouch('memory'),\n                            multiInstance: false,\n                            ignoreDuplicate: false\n                        });\n                        const mySchema: RxJsonSchema<any> = ${JSON.stringify(schemas.human)};\n                        await myDb.addCollections({\n                            humans: {\n                                schema: {}, // wrong schema format\n                                autoMigrate: false,\n                            }\n                        });\n                    })();\n                `;\n                let thrown = false;\n                try {\n                    await transpileCode(brokenCode);\n                } catch (err) {\n                    thrown = true;\n                }\n                assert.ok(thrown);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":".insert$ .update$ .remove$","suites":["typings.test.js","negative"],"updatePoint":{"line":438,"column":38},"line":438,"code":"        it('.insert$ .update$ .remove$', async () => {\n            const code = codeBase + `\n                (async() => {\n                    const myDb: RxDatabase = await createRxDatabase({\n                        name: 'mydb',\n                        storage: getRxStoragePouch('memory'),\n                        multiInstance: false,\n                        ignoreDuplicate: false\n                    });\n                    type docType = {\n                        firstName: string,\n                        lastName: string\n                    }\n                    const mySchema: RxJsonSchema<any> = ${JSON.stringify(schemas.human)};\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: mySchema,\n                            autoMigrate: false,\n                        }\n                    });\n\n                    const names: string[] = [];\n                    const revs: string[] = [];\n                    const sub1 = myCollections.humans.insert$.subscribe(cE => {\n                        names.push(cE.documentData.firstName);\n                        revs.push(cE.documentData._rev);\n                    });\n                })();\n            `;\n            await transpileCode(code);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should know the fields of the document","suites":["typings.test.js","negative"],"updatePoint":{"line":471,"column":50},"line":471,"code":"        it('should know the fields of the document', async () => {\n            const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n\n                    type DocType = {\n                        age: number,\n                        firstName: string,\n                        lastName: string,\n                        passportId: string\n                    };\n\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {},\n                            autoMigrate: false,\n                        }\n                    });\n\n                    const result = await myCollections.humans.findOne().exec();\n                    if(result === null) throw new Error('got no document');\n                    const oneDoc: RxDocument<DocType> = result;\n                    const id: string = oneDoc.passportId;\n                    const prim: string = oneDoc.primary;\n\n                    const otherResult = await myCollections.humans.findOne().exec();\n                    if(otherResult === null) throw new Error('got no other document');\n                    const otherDoc: RxDocument<DocType> = otherResult;\n                    const id2 = otherDoc.passportId;\n                });\n            `;\n            await transpileCode(code);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":".putAttachment()","suites":["typings.test.js","negative"],"updatePoint":{"line":504,"column":28},"line":504,"code":"        it('.putAttachment()', async () => {\n            const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n\n                    type DocType = {\n                        age: number,\n                        firstName: string,\n                        lastName: string,\n                        passportId: string\n                    };\n\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {},\n                            autoMigrate: false,\n                        }\n                    });\n\n                    const result = await myCollections.humans.findOne().exec(true);\n                    const oneDoc: RxDocument<DocType> = result;\n                    const attachment: RxAttachment<DocType> = await oneDoc.putAttachment({\n                        id: 'cat.txt',\n                        data: blobBufferUtil.createBlobBuffer('foo bar', 'text/plain'),\n                        type: 'text/plain'\n                    });\n                });\n            `;\n            await transpileCode(code);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":".toJSON() should have _rev","suites":["typings.test.js","negative"],"updatePoint":{"line":534,"column":38},"line":534,"code":"        it('.toJSON() should have _rev', async () => {\n            const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n\n                    type DocType = {\n                        age: number,\n                        firstName: string,\n                        lastName: string,\n                        passportId: string\n                    };\n\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {},\n                            autoMigrate: false,\n                        }\n                    });\n\n                    const result = await myCollections.humans.findOne().exec(true);\n                    const rev: string = result.toJSON(true)._rev;\n                });\n            `;\n            await transpileCode(code);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":".toJSON(false) should not have _rev","suites":["typings.test.js","negative"],"updatePoint":{"line":559,"column":47},"line":559,"code":"        it('.toJSON(false) should not have _rev', async () => {\n            const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n\n                    type DocType = {\n                        age: number,\n                        firstName: string,\n                        lastName: string,\n                        passportId: string\n                    };\n\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {},\n                            autoMigrate: false,\n                        }\n                    });\n                    const collection: RxCollection<{}> = myCollections.humans;\n\n                    const result = await collection.findOne().exec(true);\n                    const rev: string = result.toJSON(false)._rev;\n                });\n            `;\n            await AsyncTestUtil.assertThrows(\n                () => transpileCode(code),\n                Error,\n                '_rev'\n            );\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":".atomicUpdate()","suites":["typings.test.js","negative"],"updatePoint":{"line":589,"column":27},"line":589,"code":"        it('.atomicUpdate()', async () => {\n            const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n                    type DocType = {\n                        age: number,\n                        firstName: string,\n                        lastName: string,\n                        passportId: string\n                    };\n\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {},\n                            autoMigrate: false,\n                        }\n                    });\n                    const collection: RxCollection<DocType> = myCollections.humans;\n                    const doc = await collection.findOne().exec(true);\n                    await doc.atomicUpdate(docData => {\n                        const newData = {\n                            age: 23,\n                            firstName: 'bar',\n                            lastName: 'steve',\n                            passportId: 'lolol'\n                        };\n                        return newData;\n                    });\n                });\n            `;\n            await transpileCode(code);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should allow to type input data","suites":["typings.test.js","negative"],"updatePoint":{"line":623,"column":43},"line":623,"code":"        it('should allow to type input data', async () => {\n            const code = codeBase + `\n            (async() => {\n                const myDb: RxDatabase = {} as any;\n                const typedLocalDoc = await myDb.getLocal<{foo: string;}>('foobar');\n                const typedLocalDocInsert = await myDb.insertLocal<{foo: string;}>('foobar', { bar: 'foo' });\n\n                if (!typedLocalDoc) {\n                    throw new Error('local doc missing');\n                }\n\n                const x: string = typedLocalDoc.data.foo;\n                const x2: string = typedLocalDocInsert.data.foo;\n            });\n            `;\n            await AsyncTestUtil.assertThrows(\n                () => transpileCode(code),\n                Error\n            );\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should allow to type the return data","suites":["typings.test.js","negative"],"updatePoint":{"line":643,"column":48},"line":643,"code":"        it('should allow to type the return data', async () => {\n            const code = codeBase + `\n            (async() => {\n                const myDb: RxDatabase = {} as any;\n                const typedLocalDoc = await myDb.getLocal<{foo: string;}>('foobar');\n                const typedLocalDocUpsert = await myDb.upsertLocal<{foo: string;}>('foobar', { foo: 'bar' });\n\n                if (!typedLocalDoc) {\n                    throw new Error('local doc missing');\n                }\n\n                const x: string = typedLocalDoc.get('data').foo;\n                const x2: string = typedLocalDocUpsert.get('data').foo;\n            });\n            `;\n            await transpileCode(code);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should allow to access different property","suites":["typings.test.js","negative"],"updatePoint":{"line":660,"column":53},"line":660,"code":"        it('should allow to access different property', async () => {\n            const code = codeBase + `\n            (async() => {\n                const myDb: RxDatabase = {} as any;\n                const typedLocalDoc = await myDb.getLocal<{foo: string;}>('foobar');\n                const x: string = typedLocalDoc.data.bar;\n            });\n            `;\n            await AsyncTestUtil.assertThrows(\n                () => transpileCode(code),\n                Error\n            );\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should correctly recognize orm-methods","suites":["typings.test.js","orm"],"updatePoint":{"line":676,"column":54},"line":676,"code":"            it('should correctly recognize orm-methods', async () => {\n                const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {},\n                            methods: {\n                                foobar(){\n                                    return 'foobar';\n                                }\n                            }\n                        }\n                    });\n                    const myCollection: RxCollection<DefaultDocType, DefaultOrmMethods, {}> = myCollections.humans;\n\n                    // via insert\n                    const doc = await myCollection.insert({\n                        passportId: 'asdf',\n                        age: 10\n                    });\n                    const x: string = doc.foobar();\n\n                    // via query findOne()\n                    const doc2 = await myCollection.findOne('asdf').exec(true);\n                    const x2: string = doc.foobar();\n                });\n                `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should know the types","suites":["typings.test.js","hooks"],"updatePoint":{"line":709,"column":37},"line":709,"code":"            it('should know the types', async () => {\n                const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {}\n                        }\n                    });\n                    const myCollection: RxCollection<DefaultDocType, DefaultOrmMethods> = myCollections.humans;\n                    let myNumber: number;\n                    let myString: string;\n                    myCollection.postInsert((data, doc) => {\n                            myNumber = doc.age;\n                            myNumber = data.age;\n                            myString = doc.foobar();\n                            return Promise.resolve();\n                    }, true);\n                });\n            `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should know the where-fields","suites":["typings.test.js","query"],"updatePoint":{"line":733,"column":44},"line":733,"code":"            it('should know the where-fields', async () => {\n                const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n\n                    type DocType = {\n                        age: number,\n                        firstName: string,\n                        lastName: string,\n                        passportId: string,\n                        nestedObject: {\n                            foo: string,\n                            bar: number\n                        }\n                    };\n\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {},\n                            autoMigrate: false,\n                        }\n                    });\n                    const myCollection: RxCollection<DocType> = myCollections.humans;\n\n                    const query = myCollection.findOne().where('nestedObject.foo').eq('foobar');\n                });\n            `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should know the parameters of the error","suites":["typings.test.js","rx-error"],"updatePoint":{"line":764,"column":55},"line":764,"code":"            it('should know the parameters of the error', async () => {\n                const code = codeBase + `\n                (async() => {\n                    const myDb: any = {};\n                    const myCollections = await myDb.addCollections({\n                        humans: {\n                            schema: {},\n                            autoMigrate: false,\n                        }\n                    });\n\n                    try{\n                        await myCollections.humans.insert({ age: 4});\n                    } catch(err) {\n                        if ((err as any).rxdb) {\n                            (err as RxError).parameters.errors;\n                        } else {\n                            // handle regular Error class\n                        }\n                    }\n                });\n            `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should be a valid RxPlugin","suites":["typings.test.js","addRxPlugin"],"updatePoint":{"line":790,"column":42},"line":790,"code":"            it('should be a valid RxPlugin', async () => {\n                const code = codeBase + `\n                (async() => {\n                    const myPlugin: RxPlugin = {\n                        name: 'my-plugin',\n                        rxdb: true,\n                        prototypes: {\n                            RxDocument: () => {}\n                        }\n                    }\n                    addRxPlugin(myPlugin);\n                });\n            `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should be able to import and add a plugin","suites":["typings.test.js","addRxPlugin"],"updatePoint":{"line":805,"column":57},"line":805,"code":"            it('should be able to import and add a plugin', async () => {\n                const code = codeBase + `\n                import { RxDBReplicationGraphQLPlugin } from '${config.rootPath}plugins/replication-graphql';\n                addRxPlugin(RxDBReplicationGraphQLPlugin);\n            `;\n                await transpileCode(code);\n            });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"via gitter at 2018 Mai 22 19:20","suites":["typings.test.js","addRxPlugin"],"updatePoint":{"line":815,"column":43},"line":815,"code":"        it('via gitter at 2018 Mai 22 19:20', async () => {\n            const code = codeBase + `\n                (async() => {\n                    const db: RxDatabase = {} as RxDatabase;\n                    const heroSchema = {\n                        version: 0,\n                        type: 'object',\n                        primaryKey: 'id',\n                        properties: {\n                            id: {\n                                type: 'string'\n                            }\n                        },\n                        required: ['color']\n                    }\n                    const colCreator: RxCollectionCreator = {\n                        schema: heroSchema\n                    };\n                })();\n            `;\n            await transpileCode(code);\n        });","file":"typings.test.ts","skipped":false,"dir":"test"},{"name":"should be true on memory","suites":["outcome"],"updatePoint":{"line":23,"column":36},"line":23,"code":"        it('should be true on memory', async () => {\n            const ok2 = await checkAdapter('memory');\n            assert.ok(ok2);\n        });","file":"unit/adapter-check.test.ts","skipped":false,"dir":"test"},{"name":"should be false on invalid string","suites":["outcome"],"updatePoint":{"line":27,"column":45},"line":27,"code":"        it('should be false on invalid string', async () => {\n            const ok = await checkAdapter('foobar');\n            assert.strictEqual(ok, false);\n        });","file":"unit/adapter-check.test.ts","skipped":false,"dir":"test"},{"name":"should be true on memdown (leveldb-adapter)","suites":["outcome"],"updatePoint":{"line":31,"column":55},"line":31,"code":"        it('should be true on memdown (leveldb-adapter)', async () => {\n            const ok = await checkAdapter(memdown);\n            assert.ok(ok);\n        });","file":"unit/adapter-check.test.ts","skipped":false,"dir":"test"},{"name":"localstorage should be true on browser","suites":["outcome"],"updatePoint":{"line":35,"column":50},"line":35,"code":"        it('localstorage should be true on browser', async () => {\n            const should = config.platform.isNode() ? false : true;\n            const ok = await checkAdapter('idb');\n            assert.strictEqual(should, ok);\n        });","file":"unit/adapter-check.test.ts","skipped":false,"dir":"test"},{"name":"#715 Cleanup checkAdapter test databases after use","suites":["ISSUES"],"updatePoint":{"line":42,"column":62},"line":42,"code":"        it('#715 Cleanup checkAdapter test databases after use', async () => {\n            const ok = await checkAdapter(memdown);\n            assert.ok(ok);\n\n            // ensure the test-document is removed\n            const pouch = new (PouchDB as any)(\n                POUCHDB_LOCATION,\n                adapterObject(memdown) as any,\n                {\n                    auto_compaction: false, // no compaction because this only stores local documents\n                    revs_limit: 1\n                }\n            );\n\n            const found = await pouch.find({\n                selector: {}\n            });\n\n            assert.strictEqual(found.docs.length, 0);\n        });","file":"unit/adapter-check.test.ts","skipped":false,"dir":"test"},{"name":"should insert one attachment","suites":[".putAttachment()"],"updatePoint":{"line":72,"column":40},"line":72,"code":"        it('should insert one attachment', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            const attachment = await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow', 'text/plain'),\n                type: 'text/plain'\n            });\n            assert.ok(attachment);\n            assert.strictEqual(attachment.id, 'cat.txt');\n            assert.strictEqual(attachment.type, 'text/plain');\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should insert two attachments","suites":[".putAttachment()"],"updatePoint":{"line":85,"column":41},"line":85,"code":"        it('should insert two attachments', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow', 'text/plain'),\n                type: 'text/plain'\n            });\n            await doc.putAttachment({\n                id: 'cat2.txt',\n                data: blobBufferUtil.createBlobBuffer('meowmeow', 'text/plain'),\n                type: 'text/plain'\n            });\n\n            const catAttachment = doc.getAttachment('cat.txt');\n            const stringCat = await ensureNotFalsy(catAttachment).getStringData();\n            assert.strictEqual(stringCat, 'meow');\n\n            const cat2Attachment = doc.getAttachment('cat2.txt');\n            const stringCat2 = await ensureNotFalsy(cat2Attachment).getStringData();\n            assert.strictEqual(stringCat2, 'meowmeow');\n\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should insert 4 attachments in parallel","suites":[".putAttachment()"],"updatePoint":{"line":109,"column":51},"line":109,"code":"        it('should insert 4 attachments in parallel', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            const attachments = await Promise.all(\n                new Array(4)\n                    .fill(0)\n                    .map(() => doc.putAttachment({\n                        id: AsyncTestUtil.randomString(5) + '.txt',\n                        data: blobBufferUtil.createBlobBuffer('meow I am a kitty with a knife ' + AsyncTestUtil.randomString(5), 'text/plain'),\n                        type: 'text/plain'\n                    }))\n            );\n            assert.strictEqual(attachments.length, 4);\n            assert.ok(attachments[1].id);\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should insert an attachment with a big content","suites":[".putAttachment()"],"updatePoint":{"line":125,"column":58},"line":125,"code":"        it('should insert an attachment with a big content', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'cat2.txt',\n                data: blobBufferUtil.createBlobBuffer([\n                    AsyncTestUtil.randomString(100),\n                    AsyncTestUtil.randomString(100),\n                    AsyncTestUtil.randomString(100)\n                ].join(' '), 'text/plain'), // use space here\n                type: 'text/plain'\n            });\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should not update the document if skipIfSame=true and same data","suites":[".putAttachment()"],"updatePoint":{"line":139,"column":75},"line":139,"code":"        it('should not update the document if skipIfSame=true and same data', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            const data = blobBufferUtil.createBlobBuffer(AsyncTestUtil.randomString(100), 'text/plain');\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data,\n                type: 'text/plain'\n            }, true);\n            const revBefore = doc.revision;\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data,\n                type: 'text/plain'\n            }, true);\n            await wait(50);\n            assert.strictEqual(\n                revBefore,\n                doc.revision\n            );\n\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should update the document if skipIfSame=true and different data","suites":[".putAttachment()"],"updatePoint":{"line":162,"column":76},"line":162,"code":"        it('should update the document if skipIfSame=true and different data', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer(AsyncTestUtil.randomString(100), 'text/plain'),\n                type: 'text/plain'\n            }, true);\n            const revBefore = doc.revision;\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer(AsyncTestUtil.randomString(100), 'text/plain'),\n                type: 'text/plain'\n            }, false);\n            await wait(50);\n            assert.notStrictEqual(\n                revBefore,\n                doc.revision\n            );\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should get the attachment","suites":[".getAttachment()"],"updatePoint":{"line":185,"column":37},"line":185,"code":"        it('should get the attachment', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow I am a kitty with a knife', 'text/plain'),\n                type: 'text/plain'\n            });\n            const attachment: any = doc.getAttachment('cat.txt');\n            assert.ok(attachment);\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should find the attachment after another doc-update","suites":[".getAttachment()"],"updatePoint":{"line":197,"column":63},"line":197,"code":"        it('should find the attachment after another doc-update', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow I am a kitty with a knife', 'text/plain'),\n                type: 'text/plain'\n            });\n\n            await doc.atomicPatch({\n                age: 7\n            });\n\n            const attachment: any = doc.getAttachment('cat.txt');\n            assert.ok(attachment);\n            assert.strictEqual(attachment.type, 'text/plain');\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should find the attachment after database is re-created","suites":[".getAttachment()"],"updatePoint":{"line":215,"column":67},"line":215,"code":"        it('should find the attachment after database is re-created', async () => {\n            if (!config.storage.hasPersistence) {\n                return;\n            }\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                multiInstance: false,\n                ignoreDuplicate: true\n            });\n            const schemaJson = AsyncTestUtil.clone(schemas.human);\n            schemaJson.attachments = {};\n            const collections = await db.addCollections({\n                humans: {\n                    schema: schemaJson\n                }\n            });\n            await collections.humans.insert(schemaObjects.human());\n            const doc = await collections.humans.findOne().exec(true);\n            const docAge = doc.age;\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow I am a kitty with a knife', 'text/plain'),\n                type: 'text/plain'\n            });\n            await db.destroy();\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                multiInstance: false,\n                ignoreDuplicate: true\n            });\n            const cols2 = await db2.addCollections({\n                humans: {\n                    schema: schemaJson\n                }\n            });\n            const c2 = cols2.humans;\n            const doc2 = await c2.findOne().exec();\n            assert.strictEqual(docAge, doc2.age);\n            const attachment = doc2.getAttachment('cat.txt');\n            assert.ok(attachment);\n            assert.strictEqual(attachment.type, 'text/plain');\n            c2.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should remove all attachments when a document gets deleted","suites":[".getAttachment()"],"updatePoint":{"line":261,"column":70},"line":261,"code":"        it('should remove all attachments when a document gets deleted', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            const attachmentId = 'cat.txt';\n            await doc.putAttachment({\n                id: attachmentId,\n                data: blobBufferUtil.createBlobBuffer('meow I am a kitty with a knife', 'text/plain'),\n                type: 'text/plain'\n            });\n            await c.storageInstance.getAttachmentData(doc.primary, attachmentId);\n\n            await doc.remove();\n            let hasThrown = false;\n            try {\n                await c.storageInstance.getAttachmentData(doc.primary, attachmentId);\n            } catch (err) {\n                hasThrown = true;\n            }\n            assert.ok(hasThrown);\n\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should get the data","suites":["RxAttachment.getData()"],"updatePoint":{"line":285,"column":31},"line":285,"code":"        it('should get the data', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            const dat = AsyncTestUtil.randomString(100) + ' ' + AsyncTestUtil.randomString(100);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer(dat, 'text/plain'),\n                type: 'text/plain'\n            });\n            const attachment: any = doc.getAttachment('cat.txt');\n            const data = await attachment.getData();\n            const dataString = await blobBufferUtil.toString(data);\n            assert.strictEqual(dataString, dat);\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should get the data as string","suites":["RxAttachment.getStringData()"],"updatePoint":{"line":302,"column":41},"line":302,"code":"        it('should get the data as string', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            const dat = AsyncTestUtil.randomString(100) + ' ' + AsyncTestUtil.randomString(100);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer(dat, 'text/plain'),\n                type: 'text/plain'\n            });\n            const attachment: any = doc.getAttachment('cat.txt');\n            const data = await attachment.getStringData();\n            assert.strictEqual(data, dat);\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should remove the attachment","suites":["RxAttachment.remove()"],"updatePoint":{"line":318,"column":40},"line":318,"code":"        it('should remove the attachment', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow I am a kitty with a knife', 'text/plain'),\n                type: 'text/plain'\n            });\n            const attachment: any = doc.getAttachment('cat.txt');\n            assert.ok(attachment);\n\n            await attachment.remove();\n\n            // ensure it does not exist\n            const shouldBeNull = doc.getAttachment('cat.txt');\n            assert.strictEqual(null, shouldBeNull);\n\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should find all attachments","suites":[".allAttachments()"],"updatePoint":{"line":339,"column":39},"line":339,"code":"        it('should find all attachments', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            await Promise.all(\n                new Array(10)\n                    .fill(0)\n                    .map(() => doc.putAttachment({\n                        id: AsyncTestUtil.randomString(5) + '.txt',\n                        data: blobBufferUtil.createBlobBuffer('meow I am a kitty with a knife ' + AsyncTestUtil.randomString(500), 'text/plain'),\n                        type: 'text/plain'\n                    }))\n            );\n            const attachments = doc.allAttachments();\n            assert.strictEqual(attachments.length, 10);\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should lazy-load the data for the attachment","suites":[".allAttachments()"],"updatePoint":{"line":355,"column":56},"line":355,"code":"        it('should lazy-load the data for the attachment', async () => {\n            const c = await humansCollection.createAttachments(1);\n            const doc = await c.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'janosch.txt',\n                data: blobBufferUtil.createBlobBuffer('foo bar', 'text/plain'),\n                type: 'text/plain'\n            });\n            const attachments = doc.allAttachments();\n            const attachment = attachments[0];\n\n            const data = await attachment.getData();\n            const dataString = await blobBufferUtil.toString(data);\n            assert.deepStrictEqual(dataString, 'foo bar');\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should throw when attachments not defined in the schema","suites":["schema"],"updatePoint":{"line":373,"column":67},"line":373,"code":"        it('should throw when attachments not defined in the schema', async () => {\n            const c = await humansCollection.create(1);\n            const doc: any = await c.findOne().exec();\n            await AsyncTestUtil.assertThrows(\n                () => doc.putAttachment({\n                    id: AsyncTestUtil.randomString(5) + '.txt',\n                    data: blobBufferUtil.createBlobBuffer('meow I am a kitty with a knife ', 'text/plain'),\n                    type: 'text/plain'\n                }),\n                'RxError',\n                'schema'\n            );\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should store the data encrypted","suites":["encryption"],"updatePoint":{"line":389,"column":43},"line":389,"code":"        it('should store the data encrypted', async () => {\n            const c = await createEncryptedAttachmentsCollection(1);\n            const doc = await c.findOne().exec(true);\n            const attachment = await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('foo bar aaa', 'text/plain'),\n                type: 'text/plain'\n            });\n\n\n            // the data stored in the storage must be encrypted\n            if (config.storage.name === 'pouchdb') {\n                const encryptedData = await doc.collection.storageInstance.internals.pouch.getAttachment(doc.primary, 'cat.txt');\n                const dataString = await blobBufferUtil.toString(encryptedData);\n                assert.notStrictEqual(dataString, 'foo bar aaa');\n            }\n\n            // getting the data again must be decrypted\n            const data = await attachment.getStringData();\n            assert.strictEqual(data, 'foo bar aaa');\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should emit on subscription","suites":[".allAttachments$"],"updatePoint":{"line":413,"column":39},"line":413,"code":"        it('should emit on subscription', async () => {\n            const c = await createEncryptedAttachmentsCollection(1);\n            const doc = await c.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('foo bar', 'text/plain'),\n                type: 'text/plain'\n            });\n\n            const emited: any[] = [];\n            const sub = doc.allAttachments$\n                .subscribe((attachments: any[]) => emited.push(attachments));\n            await AsyncTestUtil.waitUntil(() => emited.length === 1);\n\n            assert.strictEqual(emited[0].length, 1);\n            assert.ok(emited[0][0].doc);\n\n            sub.unsubscribe();\n            c.database.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should emit on other instance","suites":["multiInstance"],"updatePoint":{"line":438,"column":41},"line":438,"code":"        it('should emit on other instance', async () => {\n            const name = randomCouchString(10);\n            type Collections = { humans: RxCollection<HumanDocumentType, {}, {}> };\n            type Document = RxDocument<HumanDocumentType>;\n            const db = await createRxDatabase<Collections>({\n                name,\n                storage: config.storage.getStorage(),\n                multiInstance: true,\n                ignoreDuplicate: true\n            });\n            const schemaJson: RxJsonSchema<HumanDocumentType> = AsyncTestUtil.clone(schemas.human);\n            schemaJson.attachments = {};\n\n\n            const c = await db.addCollections<Collections>({\n                humans: {\n                    schema: schemaJson\n                }\n            });\n\n            const db2 = await createRxDatabase<Collections>({\n                name,\n                storage: config.storage.getStorage(),\n                multiInstance: true,\n                ignoreDuplicate: true\n            });\n            const c2 = await db2.addCollections<Collections>({\n                humans: {\n                    schema: schemaJson\n                }\n            });\n\n            await c.humans.insert(schemaObjects.human());\n            const doc: Document = await c.humans.findOne().exec(true);\n            const doc2: Document = await c2.humans.findOne().exec(true);\n            assert.strictEqual(doc.age, doc2.age);\n\n            const doc2Streamed: any[] = [];\n            const sub = doc2.allAttachments$\n                .subscribe(atc => {\n                    doc2Streamed.push(atc);\n                });\n\n            const putAttachment = await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow I am a kitty', 'text/plain'),\n                type: 'text/plain'\n            });\n\n            await AsyncTestUtil.waitUntil(() => {\n                return doc2Streamed.length === 2;\n            }, 10 * 1000, 100);\n            const attachment = doc2Streamed[1][0];\n            const data = await attachment.getStringData();\n            assert.strictEqual(data, 'meow I am a kitty');\n\n            // remove again\n            await putAttachment.remove();\n\n            await AsyncTestUtil.waitUntil(\n                () => doc2Streamed.length === 3\n            );\n\n            assert.strictEqual(doc2Streamed[2].length, 0);\n            sub.unsubscribe();\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should keep the attachments during migration","suites":["migration"],"updatePoint":{"line":511,"column":56},"line":511,"code":"        it('should keep the attachments during migration', async () => {\n            const dbName = randomCouchString(10);\n            type DocData = {\n                id: string;\n            };\n            const schema0: RxJsonSchema<DocData> = {\n                version: 0,\n                type: 'object',\n                primaryKey: 'id',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    }\n                },\n                attachments: {},\n                required: ['id']\n            };\n            const schema1: RxJsonSchema<DocData> = clone(schema0);\n            schema1.version = 1;\n\n            const db = await createRxDatabase({\n                name: dbName,\n                storage: config.storage.getStorage(),\n            });\n            const col = await db.addCollections({\n                heroes: {\n                    schema: schema0\n                }\n            });\n            const doc: RxDocument<DocData> = await col.heroes.insert({\n                id: 'alice'\n            });\n            await doc.putAttachment({\n                id: 'foobar',\n                data: blobBufferUtil.createBlobBuffer('barfoo', 'text/plain'),\n                type: 'text/plain'\n            });\n            await db.destroy();\n\n            const db2 = await createRxDatabase({\n                name: dbName,\n                storage: config.storage.getStorage(),\n            });\n\n            const migrationStrategies: MigrationStrategies = {\n                1: (oldDoc: WithAttachmentsData<DocData>) => {\n                    const attachmentData = oldDoc._attachments;\n                    assert.ok(attachmentData);\n                    return oldDoc;\n                }\n            };\n\n            const col2 = await db2.addCollections({\n                heroes: {\n                    schema: schema1,\n                    migrationStrategies\n                }\n            });\n\n            const doc2: RxDocument<DocData> = await col2.heroes.findOne().exec();\n\n            assert.strictEqual(doc2.allAttachments().length, 1);\n            const firstAttachment = doc2.allAttachments()[0];\n            const data = await firstAttachment.getStringData();\n            assert.strictEqual(data, 'barfoo');\n\n            db2.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should delete the attachment during migration","suites":["migration"],"updatePoint":{"line":580,"column":57},"line":580,"code":"        it('should delete the attachment during migration', async () => {\n            const dbName = randomCouchString(10);\n            type DocData = {\n                id: string;\n            };\n            const schema0: RxJsonSchema<DocData> = {\n                version: 0,\n                primaryKey: 'id',\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    }\n                },\n                attachments: {},\n                required: ['id']\n            };\n            const schema1: RxJsonSchema<DocData> = clone(schema0);\n            schema1.version = 1;\n\n            const db = await createRxDatabase({\n                name: dbName,\n                storage: config.storage.getStorage(),\n            });\n            const col = await db.addCollections({\n                heroes: {\n                    schema: schema0\n                }\n            });\n            const doc: RxDocument<DocData> = await col.heroes.insert({\n                id: 'alice'\n            });\n            await doc.putAttachment({\n                id: 'foobar',\n                data: blobBufferUtil.createBlobBuffer('barfoo', 'text/plain'),\n                type: 'text/plain'\n            });\n            await db.destroy();\n\n            const db2 = await createRxDatabase({\n                name: dbName,\n                storage: config.storage.getStorage(),\n            });\n            const migrationStrategies: MigrationStrategies = {\n                1: (oldDoc: WithAttachmentsData<DocData>) => {\n                    oldDoc._attachments = {};\n                    return oldDoc;\n                }\n            };\n            const col2 = await db2.addCollections({\n                heroes: {\n                    schema: schema1,\n                    migrationStrategies\n                }\n            });\n            const doc2: RxDocument<DocData> = await col2.heroes.findOne().exec();\n            assert.strictEqual(doc2.allAttachments().length, 0);\n\n            db2.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should be able to change the attachment data during migration","suites":["migration"],"updatePoint":{"line":641,"column":73},"line":641,"code":"        it('should be able to change the attachment data during migration', async () => {\n            const dbName = randomCouchString(10);\n            type DocData = {\n                id: string;\n            };\n            const schema0: RxJsonSchema<DocData> = {\n                version: 0,\n                primaryKey: 'id',\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    }\n                },\n                attachments: {},\n                required: ['id']\n            };\n            const schema1: RxJsonSchema<DocData> = clone(schema0);\n            schema1.version = 1;\n\n            const db = await createRxDatabase({\n                name: dbName,\n                storage: config.storage.getStorage(),\n            });\n            const col = await db.addCollections({\n                heroes: {\n                    schema: schema0\n                }\n            });\n            const doc: RxDocument<DocData> = await col.heroes.insert({\n                id: 'alice'\n            });\n            await doc.putAttachment({\n                id: 'foobar',\n                data: blobBufferUtil.createBlobBuffer('barfoo1', 'text/plain'),\n                type: 'text/plain'\n            });\n            await db.destroy();\n\n            const db2 = await createRxDatabase({\n                name: dbName,\n                storage: config.storage.getStorage(),\n            });\n            const migrationStrategies: MigrationStrategies = {\n                1: async (oldDoc: RxDocumentWriteData<DocData>) => {\n                    if (!oldDoc._attachments) {\n                        throw new Error('oldDoc._attachments missing');\n                    }\n                    const myAttachment = oldDoc._attachments.foobar;\n                    const blobBuffer = await blobBufferUtil.createBlobBuffer(\n                        'barfoo2',\n                        myAttachment.type\n                    );\n                    (myAttachment as any).data = await blobBufferUtil.toBase64String(blobBuffer);\n\n                    oldDoc._attachments = {\n                        foobar: myAttachment\n                    };\n                    return oldDoc;\n                }\n            };\n            const col2 = await db2.addCollections({\n                heroes: {\n                    schema: schema1,\n                    migrationStrategies\n                }\n            });\n\n            const doc2: RxDocument<DocData> = await col2.heroes.findOne().exec();\n            assert.strictEqual(doc2.allAttachments().length, 1);\n            const firstAttachment = doc2.allAttachments()[0];\n            const data = await firstAttachment.getStringData();\n            assert.strictEqual(data, 'barfoo2');\n\n\n            db2.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should be able to call the defined function","suites":["orm"],"updatePoint":{"line":721,"column":55},"line":721,"code":"        it('should be able to call the defined function', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage(),\n                multiInstance: false,\n                ignoreDuplicate: true\n            });\n            const schemaJson = AsyncTestUtil.clone(schemas.human);\n            schemaJson.attachments = {};\n            const c = await db.addCollections({\n                humans: {\n                    schema: schemaJson,\n                    attachments: {\n                        foobar() {\n                            return 'foobar ' + this.type;\n                        }\n                    }\n                }\n            });\n            await c.humans.insert(schemaObjects.human());\n            const doc = await c.humans.findOne().exec();\n            const attachment = await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow I am a kitty', 'text/plain'),\n                type: 'text/plain'\n            });\n\n            assert.strictEqual(attachment.foobar(), 'foobar text/plain');\n            db.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"#455 attachments not working","suites":["issues"],"updatePoint":{"line":753,"column":40},"line":753,"code":"        it('#455 attachments not working', async () => {\n            const myschema = {\n                version: 0,\n                primaryKey: 'name',\n                type: 'object',\n                properties: {\n                    name: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                },\n                attachments: {\n                    encrypted: false,\n                },\n            };\n            const myDB = await createRxDatabase({\n                name: 'mylocaldb' + randomCouchString(10),\n                storage: config.storage.getStorage(),\n                multiInstance: true\n            });\n            const myCollections = await myDB.addCollections({\n                mycollection: {\n                    schema: myschema\n                }\n            });\n            const myCollection = myCollections.mycollection;\n            await myCollection.insert({\n                name: 'mydoc'\n            });\n            const doc = await myCollection.findOne('mydoc').exec();\n            await doc.putAttachment({\n                id: 'sampledata',\n                data: blobBufferUtil.createBlobBuffer('foo bar', 'text/plain'),\n                type: 'application/octet-stream'\n            });\n\n            const doc2 = await myCollection.findOne('mydoc').exec();\n            const attachment2 = doc2.getAttachment('sampledata');\n            const data = await attachment2.getStringData();\n            assert.strictEqual(data, 'foo bar');\n            await myDB.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"calling allAttachments() fails when document has none","suites":["issues"],"updatePoint":{"line":795,"column":65},"line":795,"code":"        it('calling allAttachments() fails when document has none', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                multiInstance: false,\n                ignoreDuplicate: true\n            });\n            const schemaJson = AsyncTestUtil.clone(schemas.human);\n            schemaJson.attachments = {};\n            const c = await db.addCollections({\n                humans: {\n                    schema: schemaJson\n                }\n            });\n            await c.humans.insert(schemaObjects.human());\n            const doc = await c.humans.findOne().exec();\n\n            const attachments = await doc.allAttachments();\n            assert.strictEqual(attachments.length, 0);\n\n            db.destroy();\n        });","file":"unit/attachments.test.ts","skipped":false,"dir":"test"},{"name":"should backup a single document","suites":["backup.test.ts",".backupSingleDocument()"],"updatePoint":{"line":45,"column":43},"line":45,"code":"        it('should backup a single document', async () => {\n            if (!config.storage.hasAttachments) {\n                return;\n            }\n            const collection = await createAttachments(1);\n            const firstDoc = await collection.findOne().exec(true);\n            await firstDoc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('lol', 'text/plain'),\n                type: 'text/plain'\n            });\n\n            const directory = getBackupDir();\n\n            await backupSingleDocument(\n                firstDoc as any,\n                {\n                    directory,\n                    attachments: true,\n                    live: false\n                }\n            );\n\n            assert.ok(fs.existsSync(path.join(directory, firstDoc.primary)));\n            assert.ok(fs.existsSync(path.join(directory, firstDoc.primary, 'attachments', 'cat.txt')));\n            assert.ok(\n                require(\n                    path.join(directory, firstDoc.primary, 'document.json')\n                )\n            );\n\n            collection.database.destroy();\n        });","file":"unit/backup.test.ts","skipped":false,"dir":"test"},{"name":"should backup all docs with attachments","suites":["backup.test.ts","RxDatabase.backup() live=false"],"updatePoint":{"line":80,"column":51},"line":80,"code":"        it('should backup all docs with attachments', async () => {\n            if (!config.storage.hasAttachments) {\n                return;\n            }\n            const collection = await createAttachments(1);\n            const firstDoc = await collection.findOne().exec(true);\n            await firstDoc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('lol', 'text/plain'),\n                type: 'text/plain'\n            });\n            const directory = getBackupDir();\n            const options = {\n                live: false,\n                directory,\n                attachments: true\n            };\n\n            const backupState = collection.database.backup(options);\n            await backupState.awaitInitialBackup();\n\n            assert.ok(fs.existsSync(path.join(directory, firstDoc.primary)));\n            assert.ok(fs.existsSync(path.join(directory, firstDoc.primary, 'attachments', 'cat.txt')));\n            assert.ok(\n                require(\n                    path.join(directory, firstDoc.primary, 'document.json')\n                )\n            );\n\n            const meta: BackupMetaFileContent = await getMeta(options);\n            assert.ok(meta.collectionStates.human.checkpoint);\n\n            collection.database.destroy();\n        });","file":"unit/backup.test.ts","skipped":false,"dir":"test"},{"name":"should emit write events","suites":["backup.test.ts","RxDatabase.backup() live=false"],"updatePoint":{"line":114,"column":36},"line":114,"code":"        it('should emit write events', async () => {\n            if (!config.storage.hasAttachments) {\n                return;\n            }\n            const collection = await createAttachments(1);\n            const directory = getBackupDir();\n            const options = {\n                live: false,\n                directory,\n                attachments: true\n            };\n            const emitted: RxBackupWriteEvent[] = [];\n            const backupState: RxBackupState = collection.database.backup(options);\n            const sub = backupState.writeEvents$.subscribe(ev => emitted.push(ev));\n            await backupState.awaitInitialBackup();\n\n            await waitUntil(() => emitted.length > 0);\n            assert.strictEqual(emitted[0].deleted, false);\n\n            collection.database.destroy();\n            sub.unsubscribe();\n        });","file":"unit/backup.test.ts","skipped":false,"dir":"test"},{"name":"should backup ongoing writes","suites":["backup.test.ts","RxDatabase.backup() live=true"],"updatePoint":{"line":138,"column":40},"line":138,"code":"        it('should backup ongoing writes', async () => {\n            if (!config.storage.hasAttachments) {\n                return;\n            }\n            const collection = await createAttachments(1);\n            const firstDoc = await collection.findOne().exec(true);\n            await firstDoc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('lol', 'text/plain'),\n                type: 'text/plain'\n            });\n            const directory = getBackupDir();\n            const backupState = collection.database.backup({\n                live: true,\n                directory,\n                attachments: true\n            });\n            await backupState.awaitInitialBackup();\n\n            const doc2 = await collection.insert(schemaObjects.human());\n\n            await waitUntil(() => {\n                return fs.existsSync(path.join(directory, doc2.primary));\n            });\n            await waitUntil(() => {\n                return fs.existsSync(\n                    path.join(directory, doc2.primary, 'document.json')\n                );\n            });\n\n            await collection.database.destroy();\n            // backupState should be stopped\n            assert.strictEqual(backupState.isStopped, true);\n        });","file":"unit/backup.test.ts","skipped":false,"dir":"test"},{"name":"should fail because it reproduces the bug","suites":["bug-report.test.js"],"updatePoint":{"line":21,"column":49},"line":21,"code":"    it('should fail because it reproduces the bug', async () => {\n\n        /**\n         * If your test should only run in nodejs or only run in the browser,\n         * you should comment in the return operator and addapt the if statement.\n         */\n        if (\n            !config.platform.isNode() // runs only in node\n            // config.platform.isNode() // runs only in the browser\n        ) {\n            // return;\n        }\n\n        if (!config.storage.hasMultiInstance) {\n            return;\n        }\n\n        // create a schema\n        const mySchema = {\n            version: 0,\n            primaryKey: 'passportId',\n            type: 'object',\n            properties: {\n                passportId: {\n                    type: 'string',\n                    maxLength: 100\n                },\n                firstName: {\n                    type: 'string'\n                },\n                lastName: {\n                    type: 'string'\n                },\n                age: {\n                    type: 'integer',\n                    minimum: 0,\n                    maximum: 150\n                }\n            }\n        };\n\n        // generate a random database-name\n        const name = randomCouchString(10);\n\n        // create a database\n        const db = await createRxDatabase({\n            name,\n            /**\n             * By calling config.storage.getStorage(),\n             * we can ensure that all variations of RxStorage are tested in the CI.\n             */\n            storage: config.storage.getStorage(),\n            eventReduce: true,\n            ignoreDuplicate: true\n        });\n        // create a collection\n        const collections = await db.addCollections({\n            mycollection: {\n                schema: mySchema\n            }\n        });\n\n        // insert a document\n        await collections.mycollection.insert({\n            passportId: 'foobar',\n            firstName: 'Bob',\n            lastName: 'Kelso',\n            age: 56\n        });\n\n        /**\n         * to simulate the event-propagation over multiple browser-tabs,\n         * we create the same database again\n         */\n        const dbInOtherTab = await createRxDatabase({\n            name,\n            storage: config.storage.getStorage(),\n            eventReduce: true,\n            ignoreDuplicate: true\n        });\n        // create a collection\n        const collectionInOtherTab = await dbInOtherTab.addCollections({\n            mycollection: {\n                schema: mySchema\n            }\n        });\n\n        // find the document in the other tab\n        const myDocument = await collectionInOtherTab.mycollection\n            .findOne()\n            .where('firstName')\n            .eq('Bob')\n            .exec();\n\n        /*\n         * assert things,\n         * here your tests should fail to show that there is a bug\n         */\n        assert.strictEqual(myDocument.age, 56);\n\n        // you can also wait for events\n        const emitted = [];\n        const sub = collectionInOtherTab.mycollection\n            .findOne().$\n            .subscribe(doc => emitted.push(doc));\n        await AsyncTestUtil.waitUntil(() => emitted.length === 1);\n\n        // clean up afterwards\n        sub.unsubscribe();\n        db.destroy();\n        dbInOtherTab.destroy();\n    });","file":"unit/bug-report.test.ts","skipped":false,"dir":"test"},{"name":"should still get the correct results on exec","suites":["uncached RxQuery"],"updatePoint":{"line":26,"column":56},"line":26,"code":"        it('should still get the correct results on exec', async () => {\n            const col = await humansCollection.create(0);\n            const uncachedQuery = col.find();\n            await uncachedQuery.exec();\n            clearQueryCache(col);\n\n            await col.insert(schemaObjects.human());\n            const res = await uncachedQuery.exec();\n            assert.strictEqual(res.length, 1);\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"should still emit on new results","suites":["uncached RxQuery"],"updatePoint":{"line":37,"column":44},"line":37,"code":"        it('should still emit on new results', async () => {\n            const col = await humansCollection.create(0);\n            const uncachedQuery = col.find();\n            await uncachedQuery.exec();\n\n            const emitted: any[][] = [];\n            const sub = uncachedQuery.$.subscribe((x: any) => emitted.push(x));\n            clearQueryCache(col);\n\n            await AsyncTestUtil.waitUntil(() => emitted.length === 1);\n            await col.insert(schemaObjects.human());\n            await AsyncTestUtil.waitUntil(() => emitted.length === 2);\n            sub.unsubscribe();\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"should have the correct amount","suites":[".countRxQuerySubscribers()"],"updatePoint":{"line":54,"column":42},"line":54,"code":"        it('should have the correct amount', async () => {\n            const col = await humansCollection.create(0);\n            const subs: Subscription[] = [];\n\n            const noSub = col.find({\n                selector: {\n                    foo: 'bar1'\n                }\n            });\n            const oneSub = col.find({\n                selector: {\n                    foo: 'bar2'\n                }\n            });\n            subs.push(oneSub.$.subscribe());\n            const twoSub = col.find({\n                selector: {\n                    foo: 'bar3'\n                }\n            });\n            subs.push(twoSub.$.subscribe());\n            subs.push(twoSub.$.subscribe());\n\n            const stillOneSub = col.find({\n                selector: {\n                    foo: 'bar4'\n                }\n            });\n            subs.push(stillOneSub.$.subscribe());\n            const removeAgain = stillOneSub.$.subscribe();\n            removeAgain.unsubscribe();\n\n            const noMoreSub = col.find({\n                selector: {\n                    foo: 'bar5'\n                }\n            });\n            const removeMe = noMoreSub.$.subscribe();\n            removeMe.unsubscribe();\n\n\n            assert.strictEqual(countRxQuerySubscribers(noSub), 0);\n            assert.strictEqual(countRxQuerySubscribers(oneSub), 1);\n            assert.strictEqual(countRxQuerySubscribers(twoSub), 2);\n            assert.strictEqual(countRxQuerySubscribers(stillOneSub), 1);\n            assert.strictEqual(countRxQuerySubscribers(noMoreSub), 0);\n\n            subs.forEach(sub => sub.unsubscribe());\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"BUG wrong count when used with switch map","suites":[".countRxQuerySubscribers()"],"updatePoint":{"line":104,"column":53},"line":104,"code":"        it('BUG wrong count when used with switch map', async () => {\n            const col = await humansCollection.create(0);\n            const root$ = new BehaviorSubject(1);\n            let query: RxQuery | null = null;\n            const nested = root$.pipe(\n                mergeMap((id: number) => {\n                    return Promise.resolve(id);\n                }),\n                switchMap(() => {\n                    query = col.findOne('foobar');\n                    return query.$;\n                }),\n                /**\n                 * This shareReplay made\n                 * having countRxQuerySubscribers() return more then 0\n                 * we have to set refCount: true so it will unsubscribe from the root\n                 * when has no longer any subscribing children.\n                 * @link https://cartant.medium.com/rxjs-whats-changed-with-sharereplay-65c098843e95\n                 */\n                shareReplay({\n                    bufferSize: 1,\n                    refCount: true\n                })\n            );\n            let emitted = 0;\n            const sub = nested.subscribe(() => emitted++);\n            await waitUntil(() => !!query && emitted === 1);\n\n            if (!query) {\n                throw new Error('query undefined');\n            }\n\n            sub.unsubscribe();\n            assert.strictEqual(countRxQuerySubscribers(query), 0);\n\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"should not crash","suites":[".defaultCacheReplacementPolicyMonad()"],"updatePoint":{"line":143,"column":28},"line":143,"code":"        it('should not crash', async () => {\n            const col = await humansCollection.create(0);\n            // exec one query\n            await col.find().exec();\n            // have one unexecuted\n            col.find({\n                selector: {\n                    foo: 'bar'\n                }\n            });\n            // have one with subscription\n            const sub = col.find({\n                selector: {\n                    foo: 'bar2'\n                }\n            }).$.subscribe();\n\n            defaultCacheReplacementPolicyMonad(0, 0)(col, col._queryCache);\n\n            sub.unsubscribe();\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"should not remove queries that have subscribers","suites":[".defaultCacheReplacementPolicyMonad()"],"updatePoint":{"line":165,"column":59},"line":165,"code":"        it('should not remove queries that have subscribers', async () => {\n            const amount = 4;\n            const col = await humansCollection.create(0);\n            const subs: Subscription[] = new Array(amount).fill(0).map((_v, i) => {\n                return col.find({\n                    selector: {\n                        foo: 'bar' + i\n                    }\n                }).$.subscribe();\n            });\n\n            defaultCacheReplacementPolicyMonad(0, 0)(col, col._queryCache);\n\n            const cachedQueries = Array.from(col._queryCache._map.values());\n            assert.strictEqual(cachedQueries.length, amount);\n\n\n            subs.forEach(sub => sub.unsubscribe());\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"should remove the unexecuted ones after unExecutedLifetime","suites":[".defaultCacheReplacementPolicyMonad()"],"updatePoint":{"line":185,"column":70},"line":185,"code":"        it('should remove the unexecuted ones after unExecutedLifetime', async () => {\n            const amount = 4;\n            const col = await humansCollection.create(0);\n\n            new Array(amount).fill(0).map((_v, i) => {\n                return col.find({\n                    selector: {\n                        foo: 'bar' + i\n                    }\n                });\n            });\n\n            await wait(10);\n            defaultCacheReplacementPolicyMonad(0, 0)(col, col._queryCache);\n            const cachedQueries = Array.from(col._queryCache._map.values());\n            assert.strictEqual(cachedQueries.length, 0);\n\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"should remove the oldest ones","suites":[".defaultCacheReplacementPolicyMonad()"],"updatePoint":{"line":204,"column":41},"line":204,"code":"        it('should remove the oldest ones', async () => {\n            const col = await humansCollection.create(0);\n            const amount = 10;\n            await Promise.all(\n                new Array(amount).fill(0)\n                    .map(async (_v, i) => {\n                        const q = col.find({\n                            selector: {\n                                passportId: 'old-bar' + i\n                            }\n                        });\n                        await q.exec();\n                        return q;\n                    })\n            );\n            await wait(10);\n            const newerQueries = await Promise.all(\n                new Array(amount).fill(0).map(async (_v, i) => {\n                    const q = col.find({\n                        selector: {\n                            passportId: 'new-bar' + i\n                        }\n                    });\n                    await q.exec();\n                    return q;\n                })\n            );\n\n            defaultCacheReplacementPolicyMonad(amount, 0)(col, col._queryCache);\n            const cachedQueries = Array.from(col._queryCache._map.values());\n            assert.deepStrictEqual(cachedQueries, newerQueries);\n            assert.strictEqual(cachedQueries.length, amount);\n\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"should run exactly once","suites":[".triggerCacheReplacement()"],"updatePoint":{"line":241,"column":35},"line":241,"code":"        it('should run exactly once', async () => {\n            const col = await humansCollection.create(0);\n\n            let runs = 0;\n            const policy = defaultCacheReplacementPolicyMonad(0, 0);\n            function trackingPolicy(\n                collection: RxCollection,\n                queryCache: QueryCache\n            ) {\n                runs = runs + 1;\n                policy(collection, queryCache);\n            }\n            col.cacheReplacementPolicy = trackingPolicy;\n\n            new Array(5).fill(0).forEach(() => {\n                triggerCacheReplacement(col);\n            });\n\n            await waitUntil(() => {\n                if (runs > 1) {\n                    throw new Error('too many runs ' + runs);\n                }\n                if (runs === 1) {\n                    return true;\n                } else {\n                    return false;\n                }\n            });\n            assert.strictEqual(runs, 1);\n\n            // run again when first was done\n            triggerCacheReplacement(col);\n            await waitUntil(() => {\n                if (runs > 2) {\n                    throw new Error('too many runs ' + runs);\n                }\n                if (runs === 2) {\n                    return true;\n                } else {\n                    return false;\n                }\n            });\n            assert.strictEqual(runs, 2);\n\n            col.database.destroy();\n        });","file":"unit/cache-replacement-policy.test.ts","skipped":false,"dir":"test"},{"name":"should contains some events","suites":["basic"],"updatePoint":{"line":10,"column":39},"line":10,"code":"        it('should contains some events', async () => {\n            const col = await humansCollection.create(10);\n            assert.strictEqual(col._changeEventBuffer.buffer.length, 10);\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"should delete older events when buffer get over limit","suites":["basic"],"updatePoint":{"line":15,"column":65},"line":15,"code":"        it('should delete older events when buffer get over limit', async () => {\n            const col = await humansCollection.create(0);\n            col._changeEventBuffer.limit = 10;\n            await Promise.all(\n                new Array(11).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n            assert.strictEqual(col._changeEventBuffer.buffer.length, 10);\n\n            await Promise.all(\n                new Array(11).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n            assert.strictEqual(col._changeEventBuffer.buffer.length, 10);\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"check if correct events get removed","suites":["basic"],"updatePoint":{"line":30,"column":47},"line":30,"code":"        it('check if correct events get removed', async () => {\n            const col = await humansCollection.create(0);\n            col._changeEventBuffer.limit = 10;\n\n            await Promise.all(\n                new Array(11).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n\n            const last = schemaObjects.human();\n            await col.insert(last);\n            const lastBufferEvent = col._changeEventBuffer.buffer[col._changeEventBuffer.buffer.length - 1];\n            assert.strictEqual(last.passportId, lastBufferEvent.documentData.passportId);\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"return null if pointer is no more in buffer (too low)","suites":[".getArrayIndexByPointer()"],"updatePoint":{"line":47,"column":65},"line":47,"code":"        it('return null if pointer is no more in buffer (too low)', async () => {\n            const col = await humansCollection.create(0);\n            col._changeEventBuffer.limit = 10;\n            await Promise.all(\n                new Array(11).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n\n            const pointer = col._changeEventBuffer.getArrayIndexByPointer(0);\n            assert.strictEqual(pointer, null);\n\n            await Promise.all(\n                new Array(11).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n\n            const pointer2 = col._changeEventBuffer.getArrayIndexByPointer(10);\n            assert.strictEqual(pointer2, null);\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"return the right pointer","suites":[".getArrayIndexByPointer()"],"updatePoint":{"line":66,"column":36},"line":66,"code":"        it('return the right pointer', async () => {\n            const col = await humansCollection.create(0);\n            let got;\n            col._changeEventBuffer.limit = 10;\n\n            await Promise.all(\n                new Array(10).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n\n            const pointer = col._changeEventBuffer.getArrayIndexByPointer(0);\n            assert.strictEqual(pointer, null);\n\n            await Promise.all(\n                new Array(10).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n\n            got = col._changeEventBuffer.getArrayIndexByPointer(15);\n            assert.strictEqual(got, 4);\n\n            await Promise.all(\n                new Array(10).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n            got = col._changeEventBuffer.getArrayIndexByPointer(25);\n            assert.strictEqual(got, 4);\n\n            got = col._changeEventBuffer.getArrayIndexByPointer(21);\n            assert.strictEqual(got, 0);\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"return the correct pointer","suites":[".getArrayIndexByPointer()"],"updatePoint":{"line":96,"column":38},"line":96,"code":"        it('return the correct pointer', async () => {\n            const col = await humansCollection.create(10);\n            col._changeEventBuffer.limit = 10;\n\n            const lastDoc = schemaObjects.human();\n            await col.insert(lastDoc);\n\n            const gotIndex: any = col._changeEventBuffer.getArrayIndexByPointer(col._changeEventBuffer.counter);\n            assert.strictEqual(col._changeEventBuffer.buffer[gotIndex].documentData.firstName, lastDoc.firstName);\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"should run from correctly","suites":[".runFrom()"],"updatePoint":{"line":110,"column":37},"line":110,"code":"        it('should run from correctly', async () => {\n            const col = await humansCollection.create(0);\n            col._changeEventBuffer.limit = 10;\n\n            await Promise.all(\n                new Array(10).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n\n            const evs: any[] = [];\n            col._changeEventBuffer.runFrom(1, function (cE: any) {\n                evs.push(cE);\n            });\n            assert.strictEqual(evs.length, 10);\n            evs.forEach(cE => assert.ok(cE.documentId));\n\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"should throw if pointer to low","suites":[".runFrom()"],"updatePoint":{"line":128,"column":42},"line":128,"code":"        it('should throw if pointer to low', async () => {\n            const col = await humansCollection.create(0);\n            col._changeEventBuffer.limit = 10;\n\n            await Promise.all(\n                new Array(30).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n\n            const evs = [];\n            assert.throws(() => col._changeEventBuffer.runFrom(5, function (cE: any) {\n                evs.push(cE);\n            }), Error);\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"should getFrom correctly","suites":[".getFrom()"],"updatePoint":{"line":145,"column":36},"line":145,"code":"        it('should getFrom correctly', async () => {\n            const col = await humansCollection.create(0);\n            col._changeEventBuffer.limit = 10;\n\n            await Promise.all(\n                new Array(10).fill(0).map(() => col.insert(schemaObjects.human()))\n            );\n\n            const evs: any[] = col._changeEventBuffer.getFrom(1) as any;\n            assert.strictEqual(evs.length, 10);\n            evs.forEach((cE: any) => assert.ok(cE.documentId));\n\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"should run correct on remove","suites":[".getFrom()"],"updatePoint":{"line":160,"column":40},"line":160,"code":"        it('should run correct on remove', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find();\n            await q.exec();\n            await col.insert(schemaObjects.human());\n            await q.exec();\n\n            // remove the doc\n            const doc: any = await col.findOne().exec();\n            await doc.remove();\n            await AsyncTestUtil.waitUntil(() => col._changeEventBuffer.counter === 2);\n\n            const evs: any[] = col._changeEventBuffer.getFrom(q._latestChangeEvent + 1) as any;\n            assert.strictEqual(evs.length, 1);\n            assert.strictEqual(evs[0].operation, 'DELETE');\n\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"should only have the last changeEvent for the doc","suites":[".reduceByLastOfDoc()"],"updatePoint":{"line":180,"column":61},"line":180,"code":"        it('should only have the last changeEvent for the doc', async () => {\n            return; // TODO see reduceByLastOfDoc() implementation\n            const col = await humansCollection.create(5);\n            const q = col.find();\n            await q.exec();\n            const oneDoc: any = await col.findOne().exec();\n            let newVal = 0;\n            while (newVal < 5) {\n                newVal++;\n                await oneDoc.atomicPatch({age: newVal});\n            }\n\n            const allEvents: any[] = q.collection._changeEventBuffer.getFrom(1) as any;\n            const reduced = q.collection._changeEventBuffer.reduceByLastOfDoc(allEvents);\n\n            assert.strictEqual(reduced.length, 5);\n            const lastEvent: any = reduced.find(cE => cE.documentId === oneDoc.primary);\n            assert.strictEqual(lastEvent.documentData.age, 5);\n            col.database.destroy();\n        });","file":"unit/change-event-buffer.test.ts","skipped":false,"dir":"test"},{"name":"should clean up the deleted documents","suites":[],"updatePoint":{"line":28,"column":45},"line":28,"code":"    it('should clean up the deleted documents', async () => {\n        const db = await createRxDatabase({\n            name: randomCouchString(10),\n            storage: config.storage.getStorage(),\n            cleanupPolicy: {\n                awaitReplicationsInSync: false,\n                minimumCollectionAge: 0,\n                minimumDeletedTime: 0,\n                runEach: 10,\n                waitForLeadership: false\n            }\n        });\n        const cols = await db.addCollections({\n            humans: {\n                schema: schemas.human\n            }\n        });\n        const collection: RxCollection<HumanDocumentType> = cols.humans;\n        const notDeleted = await collection.insert(schemaObjects.human());\n        const doc = await collection.insert(schemaObjects.human());\n        await doc.remove();\n\n        await waitUntil(async () => {\n            const deletedDocInStorage = await collection.storageInstance.findDocumentsById(\n                [\n                    doc.primary,\n                    notDeleted.primary\n                ],\n                true\n            );\n            assert.ok(deletedDocInStorage[notDeleted.primary]);\n            const deletedDocStillInStorage = !!deletedDocInStorage[doc.primary];\n            return !deletedDocStillInStorage;\n        });\n\n        db.destroy();\n    });","file":"unit/cleanup.test.ts","skipped":false,"dir":"test"},{"name":"should pause the cleanup when a replication is not in sync","suites":[],"updatePoint":{"line":65,"column":66},"line":65,"code":"    it('should pause the cleanup when a replication is not in sync', async () => {\n        const db = await createRxDatabase({\n            name: randomCouchString(10),\n            storage: config.storage.getStorage(),\n            cleanupPolicy: {\n                awaitReplicationsInSync: true,\n                minimumCollectionAge: 0,\n                minimumDeletedTime: 0,\n                runEach: 10,\n                waitForLeadership: false\n            }\n        });\n        const cols = await db.addCollections({\n            humans: {\n                schema: schemas.human\n            }\n        });\n\n        const collection: RxCollection<HumanDocumentType> = cols.humans;\n        replicateRxCollection({\n            collection,\n            replicationIdentifier: 'my-rep',\n            deletedField: '_deleted',\n            pull: {\n                async handler() {\n                    await wait(50);\n                    throw new Error('never sucess');\n                }\n            },\n            live: true\n        });\n\n        const doc = await collection.insert(schemaObjects.human());\n        await doc.remove();\n        await wait(config.isFastMode() ? 200 : 500);\n\n        /**\n         * The deleted document still be there\n         * because the errored replication\n         * blocks the cleanup\n         */\n        const deletedDocInStorage = await collection.storageInstance.findDocumentsById(\n            [doc.primary],\n            true\n        );\n        assert.ok(deletedDocInStorage[doc.primary]);\n\n        db.destroy();\n    });","file":"unit/cleanup.test.ts","skipped":false,"dir":"test"},{"name":"should resolve the emitted conflict of conflictResultionTasks()","suites":["RxStorageInterface"],"updatePoint":{"line":21,"column":75},"line":21,"code":"        it('should resolve the emitted conflict of conflictResultionTasks()', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStorageMemory(),\n            });\n            const cols = await db.addCollections({\n                humans: {\n                    schema: schemas.human\n                }\n            });\n            const collection: RxCollection<HumanDocumentType> = cols.humans;\n            const doc = await collection.insert(schemaObjects.human());\n            const docData = doc.toJSON(true);\n            const storageInstance: RxStorageInstanceMemory<HumanDocumentType> = collection.storageInstance as any;\n            const oldResolveConflictResultionTask = storageInstance.resolveConflictResultionTask.bind(storageInstance);\n            const resolvedTasks = new Set<string>();\n            storageInstance.resolveConflictResultionTask = function (taskSolution) {\n                resolvedTasks.add(taskSolution.id);\n                return oldResolveConflictResultionTask(taskSolution);\n            }\n\n            const taskId = randomCouchString();\n            storageInstance.internals.conflictResultionTasks$.next({\n                id: taskId,\n                context: '',\n                input: {\n                    newDocumentState: docData,\n                    realMasterState: docData,\n                    assumedMasterState: docData\n                }\n            });\n            await waitUntil(() => resolvedTasks.has(taskId));\n\n            db.destroy();\n        });","file":"unit/conflict-handling.test.ts","skipped":false,"dir":"test"},{"name":"create a multiInstance database","suites":["create database"],"updatePoint":{"line":36,"column":43},"line":36,"code":"        it('create a multiInstance database', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage(),\n                multiInstance: true\n            });\n            assert.ok(isRxDatabase(db));\n            db.destroy();\n        });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"create a 2 multiInstance databases","suites":["create database"],"updatePoint":{"line":45,"column":46},"line":45,"code":"        it('create a 2 multiInstance databases', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: getRxStoragePouch('memory'),\n                multiInstance: true,\n                ignoreDuplicate: true\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: getRxStoragePouch('memory'),\n                multiInstance: true,\n                ignoreDuplicate: true\n            });\n            assert.ok(isRxDatabase(db));\n            assert.ok(isRxDatabase(db2));\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"get event on db2 when db1 fires","suites":["RxDatabase.$","positive"],"updatePoint":{"line":67,"column":47},"line":67,"code":"            it('get event on db2 when db1 fires', async () => {\n                const name = randomCouchString(10);\n                const c1 = await humansCollection.createMultiInstance(name);\n                const c2 = await humansCollection.createMultiInstance(name);\n                const db1: RxDatabase = c1.database;\n                const db2: RxDatabase = c2.database;\n\n                let received = 0;\n                db2.$.subscribe(cEvent => {\n                    received++;\n                    assert.ok(cEvent.operation);\n                });\n                await c1.insert(schemaObjects.human());\n                await AsyncTestUtil.waitUntil(() => {\n                    return received > 0;\n                });\n\n                db1.destroy();\n                db2.destroy();\n            });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"should not get the same events twice","suites":["RxDatabase.$","negative"],"updatePoint":{"line":89,"column":52},"line":89,"code":"            it('should not get the same events twice', async () => {\n\n                const name = randomCouchString(10);\n                const c1 = await humansCollection.createMultiInstance(name);\n                const c2 = await humansCollection.createMultiInstance(name);\n                const db1: RxDatabase = c1.database;\n                const db2: RxDatabase = c2.database;\n\n                const emitted: any[] = [];\n                db2.$.subscribe(cEvent => {\n                    emitted.push(cEvent);\n                    assert.ok(cEvent.operation);\n                });\n                await c1.insert(schemaObjects.human());\n                await wait(100);\n\n                await AsyncTestUtil.waitUntil(() => {\n                    if (emitted.length > 1) {\n                        throw new Error('got too many events ' + emitted.length);\n                    }\n                    return emitted.length === 1;\n                });\n\n                db1.destroy();\n                db2.destroy();\n            });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"get event on db2 when db1 fires","suites":["Collection.$"],"updatePoint":{"line":118,"column":43},"line":118,"code":"        it('get event on db2 when db1 fires', async () => {\n            const name = randomCouchString(10);\n            const c1 = await humansCollection.createMultiInstance(name);\n            const c2 = await humansCollection.createMultiInstance(name);\n            let received = 0;\n            c2.$.subscribe(cEvent => {\n                received++;\n                assert.ok(cEvent.operation);\n            });\n            await c1.insert(schemaObjects.human());\n\n            await AsyncTestUtil.waitUntil(() => {\n                return received > 0;\n            });\n\n            c1.database.destroy();\n            c2.database.destroy();\n        });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"get no changes via pouchdb on different dbs","suites":["Collection.$"],"updatePoint":{"line":136,"column":55},"line":136,"code":"        it('get no changes via pouchdb on different dbs', async () => {\n            if (config.storage.name !== 'pouchdb') {\n                return;\n            }\n            const c1 = await humansCollection.create(0);\n            const c2 = await humansCollection.create(0);\n            let got;\n            c2.storageInstance.internals.pouch.changes({\n                since: 'now',\n                live: true,\n                include_docs: true\n            }).on('change', function (change: any) {\n                if (!change.id.startsWith('_'))\n                    got = change;\n            });\n            await c1.insert(schemaObjects.human());\n\n            await promiseWait(50);\n            assert.strictEqual(got, undefined);\n            c1.database.destroy();\n            c2.database.destroy();\n        });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"get event on doc2 when doc1 is changed","suites":["Document.$"],"updatePoint":{"line":161,"column":50},"line":161,"code":"        it('get event on doc2 when doc1 is changed', async () => {\n            const name = randomCouchString(10);\n            const c1 = await humansCollection.createMultiInstance(name);\n            const c2 = await humansCollection.createMultiInstance(name);\n            await c1.insert(schemaObjects.human());\n\n            const doc1 = await c1.findOne().exec(true);\n\n            let doc2: RxDocument<HumanDocumentType> | null = null as any;\n            await waitUntil(async () => {\n                doc2 = await c2.findOne().exec();\n                return !!doc2;\n            });\n\n            let received = 0;\n            ensureNotFalsy(doc2).$.subscribe(() => {\n                received = received + 1;\n            });\n\n            let firstNameAfter: any;\n            ensureNotFalsy(doc2).get$('firstName').subscribe((newValue: any) => {\n                firstNameAfter = newValue;\n            });\n\n            await doc1.atomicPatch({ firstName: 'foobar' });\n\n            await promiseWait(10);\n            await AsyncTestUtil.waitUntil(() => firstNameAfter === 'foobar');\n\n            assert.strictEqual(firstNameAfter, 'foobar');\n            c1.database.destroy();\n            c2.database.destroy();\n        });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"should work with encrypted fields","suites":["Document.$"],"updatePoint":{"line":194,"column":45},"line":194,"code":"        it('should work with encrypted fields', async () => {\n            const name = randomCouchString(10);\n            const password = randomCouchString(10);\n            const db1 = await createRxDatabase({\n                name,\n                storage: wrappedKeyEncryptionStorage({\n                    storage: config.storage.getStorage(),\n                }),\n                password,\n                multiInstance: true,\n                ignoreDuplicate: true\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: wrappedKeyEncryptionStorage({\n                    storage: config.storage.getStorage(),\n                }),\n                password,\n                multiInstance: true,\n                ignoreDuplicate: true\n            });\n            const c1 = await db1.addCollections({\n                human: {\n                    schema: schemas.encryptedHuman\n                }\n            });\n            const c2 = await db2.addCollections({\n                human: {\n                    schema: schemas.encryptedHuman\n                }\n            });\n            await c1.human.insert(schemaObjects.encryptedHuman());\n\n            const doc1 = await c1.human.findOne().exec(true);\n\n            let doc2: typeof doc1 | null = null;\n            await waitUntil(async () => {\n                doc2 = await c2.human.findOne().exec(true);\n                return !!doc2;\n            });\n\n            let receivedCollection = 0;\n            c2.human.$.subscribe(() => {\n                receivedCollection = receivedCollection + 1;\n            });\n\n            let received = 0;\n            doc2.$.subscribe(() => {\n                received = received + 1;\n            });\n\n            let secretAfter: any;\n            doc2.get$('secret').subscribe((newValue: any) => {\n                secretAfter = newValue;\n            });\n\n            await doc1.atomicPatch({ secret: 'foobar' });\n\n            await AsyncTestUtil.waitUntil(() => secretAfter === 'foobar');\n            assert.strictEqual(secretAfter, 'foobar');\n\n            db1.destroy();\n            db2.destroy();\n        });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"should work with nested encrypted fields","suites":["Document.$"],"updatePoint":{"line":258,"column":52},"line":258,"code":"        it('should work with nested encrypted fields', async () => {\n            const name = randomCouchString(10);\n            const password = randomCouchString(10);\n            const db1 = await createRxDatabase({\n                name,\n                storage: wrappedKeyEncryptionStorage({\n                    storage: config.storage.getStorage(),\n                }),\n                password,\n                multiInstance: true,\n                ignoreDuplicate: true\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: wrappedKeyEncryptionStorage({\n                    storage: config.storage.getStorage(),\n                }),\n                password,\n                multiInstance: true,\n                ignoreDuplicate: true\n            });\n            const c1 = await db1.addCollections({\n                human: {\n                    schema: schemas.encryptedObjectHuman\n                }\n            });\n            const c2 = await db2.addCollections({\n                human: {\n                    schema: schemas.encryptedObjectHuman\n                }\n            });\n            await c1.human.insert(schemaObjects.encryptedObjectHuman());\n\n            const doc1 = await c1.human.findOne().exec(true);\n            let doc2: typeof doc1 | null = null;\n            await waitUntil(async () => {\n                doc2 = await c2.human.findOne().exec(true);\n                return !!doc2;\n            });\n\n            let receivedCollection = 0;\n            c2.human.$.subscribe(() => {\n                receivedCollection = receivedCollection + 1;\n            });\n\n            let received = 0;\n            doc2.$.subscribe(() => {\n                received = received + 1;\n            });\n\n            let secretAfter: any;\n            doc2.get$('secret').subscribe((newValue: any) => {\n                secretAfter = newValue;\n            });\n\n            await doc1.atomicPatch({\n                secret: {\n                    name: 'foo',\n                    subname: 'bar'\n                }\n            });\n\n            await AsyncTestUtil.waitUntil(() => secretAfter.name === 'foo');\n            assert.deepStrictEqual(secretAfter, {\n                name: 'foo',\n                subname: 'bar'\n            });\n\n            db1.destroy();\n            db2.destroy();\n        });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"should recieve events on the other side","suites":["AutoPull","positive"],"updatePoint":{"line":332,"column":55},"line":332,"code":"            it('should recieve events on the other side', async () => {\n                const name = randomCouchString(10);\n                const c1 = await humansCollection.createMultiInstance(name);\n                const c2 = await humansCollection.createMultiInstance(name);\n\n                const emitted = [];\n                c2.$.subscribe(ev => emitted.push(ev));\n\n                await c1.insert(schemaObjects.human());\n\n                await waitUntil(() => emitted.length >= 1);\n\n                c1.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"should recieve 2 events","suites":["AutoPull","positive"],"updatePoint":{"line":347,"column":39},"line":347,"code":"            it('should recieve 2 events', async () => {\n                const name = randomCouchString(10);\n                const c1 = await humansCollection.createMultiInstance(name);\n                const c2 = await humansCollection.createMultiInstance(name);\n\n                let received = 0;\n                c2.$.subscribe(cEvent => {\n                    received++;\n                    assert.ok(cEvent.operation);\n                });\n\n                await c1.insert(schemaObjects.human());\n                await c1.insert(schemaObjects.human());\n\n                await AsyncTestUtil.waitUntil(() => received === 2);\n                assert.strictEqual(received, 2);\n                c1.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/cross-instance.test.ts","skipped":false,"dir":"test"},{"name":"should calculate the correct length","suites":[".getStringLengthOfIndexNumber()"],"updatePoint":{"line":78,"column":47},"line":78,"code":"        it('should calculate the correct length', () => {\n            const parsed = getStringLengthOfIndexNumber({\n                type: 'number',\n                minimum: 0.1,\n                maximum: 110.5,\n                multipleOf: 0.01\n            });\n            assert.strictEqual(parsed.decimals, 2);\n            assert.strictEqual(parsed.nonDecimals, 3);\n        });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"should get a correct string","suites":[".getIndexableStringMonad()","index-type: string"],"updatePoint":{"line":91,"column":43},"line":91,"code":"            it('should get a correct string', () => {\n                const index = ['id'];\n                const docs = [\n                    getIndexTestDoc({ id: 'bb' }),\n                    getIndexTestDoc({ id: 'aa' })\n                ];\n                const sorted = docs.sort((a, b) => {\n                    const strA = getIndexableStringMonad(\n                        schema,\n                        index\n                    )(a);\n                    const strB = getIndexableStringMonad(\n                        schema,\n                        index\n                    )(b);\n                    assert.strictEqual(strA.length, schema.properties.id.maxLength);\n                    assert.strictEqual(strB.length, schema.properties.id.maxLength);\n                    return strA < strB ? -1 : 1;\n                });\n                assert.strictEqual(sorted[0].id, 'aa');\n            });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"should get a correct string","suites":[".getIndexableStringMonad()","index-type: boolean"],"updatePoint":{"line":114,"column":43},"line":114,"code":"            it('should get a correct string', () => {\n                const index = ['bool'];\n                const docs = [\n                    getIndexTestDoc({ bool: true }),\n                    getIndexTestDoc({ bool: false })\n                ];\n                const sorted = docs.sort((a, b) => {\n                    const strA = getIndexableStringMonad(\n                        schema,\n                        index\n                    )(a);\n                    const strB = getIndexableStringMonad(\n                        schema,\n                        index\n                    )(b);\n                    assert.strictEqual(strA.length, 1);\n                    assert.strictEqual(strB.length, 1);\n                    return strA < strB ? -1 : 1;\n                });\n                assert.strictEqual(sorted[0].bool, false);\n            });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"should get a valid string","suites":[".getIndexableStringMonad()","index-type: number"],"updatePoint":{"line":137,"column":41},"line":137,"code":"            it('should get a valid string', () => {\n                const index = ['num'];\n                const docData = getIndexTestDoc({ num: 24.02 });\n                const indexString = getIndexableStringMonad(\n                    schema,\n                    index\n                )(docData);\n                const parsed = getStringLengthOfIndexNumber(schema.properties.num);\n                assert.strictEqual(indexString.length, parsed.decimals + parsed.nonDecimals);\n            });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"should get the correct sort order","suites":[".getIndexableStringMonad()","index-type: number"],"updatePoint":{"line":147,"column":49},"line":147,"code":"            it('should get the correct sort order', () => {\n                const index = ['num'];\n                const docs = [\n                    getIndexTestDoc({ num: 11 }),\n                    getIndexTestDoc({ num: 10.02 })\n                ];\n                const sorted = docs.sort((a, b) => {\n                    const strA = getIndexableStringMonad(\n                        schema,\n                        index\n                    )(a);\n                    const strB = getIndexableStringMonad(\n                        schema,\n                        index\n                    )(b);\n                    assert.strictEqual(strA.length, strB.length);\n                    return strA < strB ? -1 : 1;\n                });\n                assert.strictEqual(sorted[0].num, 10.02);\n            });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"should work correctly on big numbers","suites":[".getIndexableStringMonad()","index-type: number"],"updatePoint":{"line":167,"column":52},"line":167,"code":"            it('should work correctly on big numbers', () => {\n                type DocType = {\n                    id: string;\n                    bigNum: number;\n                };\n                const schema: RxJsonSchema<RxDocumentData<DocType>> = fillWithDefaultSettings({\n                    primaryKey: 'id',\n                    version: 0,\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 10\n                        },\n                        bigNum: {\n                            type: 'number',\n                            minimum: 0,\n                            maximum: 1000000000000000,\n                            multipleOf: 0.01\n                        }\n                    },\n                    additionalProperties: false,\n                    required: [\n                        'bigNum'\n                    ]\n                });\n                const index = [\n                    'bigNum',\n                    'id'\n                ];\n                const doc: RxDocumentData<DocType> = {\n                    id: 'foobar',\n                    bigNum: 1661946016806.01,\n                    _attachments: {},\n                    _deleted: false,\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n                const indexString = getIndexableStringMonad(\n                    schema,\n                    index\n                )(doc);\n                const mustBeStart = '000166194601680601';\n                if (!indexString.startsWith(mustBeStart)) {\n                    throw new Error(\n                        'indexString does not startWith ' + mustBeStart +\n                        '  indexString: ' + indexString\n                    );\n                }\n            });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"indexing a optional field must work","suites":[".getIndexableStringMonad()","special cases"],"updatePoint":{"line":221,"column":51},"line":221,"code":"            it('indexing a optional field must work', () => {\n                const schema: RxJsonSchema<RxDocumentData<{ id: string; optional?: string; }>> = fillWithDefaultSettings({\n                    primaryKey: 'id',\n                    version: 0,\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        optional: {\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    },\n                    required: [\n                        'id'\n                    ],\n                    indexes: [\n                        ['id'],\n                        ['optional']\n                    ]\n                });\n                const doc = {\n                    id: 'foo'\n                };\n                const strA: string = getIndexableStringMonad<{ id: string; optional?: string; }>(\n                    schema,\n                    ['optional']\n                )(doc as any);\n                assert.ok(strA);\n                strA.split('').forEach(char => assert.strictEqual(char, ' '));\n            });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"should find the correct docs when comparing with the index","suites":[".getStartIndexStringFromLowerBound()"],"updatePoint":{"line":257,"column":70},"line":257,"code":"        it('should find the correct docs when comparing with the index', () => {\n            const docs = new Array(100).fill(0).map(() => getIndexTestDoc());\n            const index = ['bool', 'num'];\n\n            const lowerBoundString = getStartIndexStringFromLowerBound(\n                schema,\n                index,\n                [\n                    true,\n                    30\n                ]\n            );\n\n            const matchingDocs = docs.filter(doc => {\n                const isIndexStr = getIndexableStringMonad(\n                    schema,\n                    index\n                )(doc);\n                return isIndexStr >= lowerBoundString;\n            });\n\n            matchingDocs.forEach(doc => {\n                assert.ok(doc.bool);\n                assert.ok(doc.num >= 30);\n            });\n        });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"should match the correct docs","suites":[".getStartIndexStringFromUpperBound()"],"updatePoint":{"line":285,"column":41},"line":285,"code":"        it('should match the correct docs', () => {\n            const docs = new Array(100).fill(0).map(() => getIndexTestDoc());\n            const index = ['bool', 'num'];\n\n            const upperBoundString = getStartIndexStringFromUpperBound(\n                schema,\n                index,\n                [\n                    false,\n                    30\n                ]\n            );\n            const matchingDocs = docs.filter(doc => {\n                const isIndexStr = getIndexableStringMonad(\n                    schema,\n                    index\n                )(doc);\n                return isIndexStr <= upperBoundString;\n            });\n\n            matchingDocs.forEach(doc => {\n                assert.strictEqual(doc.bool, false);\n                assert.ok(doc.num <= 30);\n            });\n        });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"should match the correct docs if bound is undefined","suites":[".getStartIndexStringFromUpperBound()"],"updatePoint":{"line":310,"column":63},"line":310,"code":"        it('should match the correct docs if bound is undefined', () => {\n            const docs = new Array(100).fill(0).map(() => getIndexTestDoc());\n            const index = ['id'];\n\n            const upperBoundString = getStartIndexStringFromUpperBound(\n                schema,\n                index,\n                [\n                    undefined\n                ]\n            );\n\n            const matchingDocs = docs.filter(doc => {\n                const isIndexStr = getIndexableStringMonad(\n                    schema,\n                    index\n                )(doc);\n                return isIndexStr <= upperBoundString;\n            });\n\n            /**\n             * Because the bound was 'undefined',\n             * all docs must match.\n             */\n            assert.strictEqual(\n                docs.length,\n                matchingDocs.length\n            );\n        });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"should find the correct string for the _deleted+_meta.lwt index","suites":[".getStartIndexStringFromUpperBound()"],"updatePoint":{"line":343,"column":75},"line":343,"code":"        it('should find the correct string for the _deleted+_meta.lwt index', () => {\n            const useSchema = clone(schema);\n            const index = ['_deleted', '_meta.lwt'];\n            useSchema.indexes.push(index);\n\n            const lowerBoundString = getStartIndexStringFromLowerBound(\n                useSchema,\n                index,\n                [\n                    true,\n                    1\n                ]\n            );\n\n            const doc = getIndexTestDoc();\n            doc._deleted = true;\n            doc._meta.lwt = now();\n            const docIndexString = getIndexableStringMonad(\n                useSchema,\n                index\n            )(doc);\n            assert.ok(lowerBoundString < docIndexString);\n            const upperBoundString = getStartIndexStringFromUpperBound(\n                useSchema,\n                index,\n                [\n                    true,\n                    now() + 1000 * 10\n                ]\n            );\n            assert.ok(upperBoundString.startsWith('1'));\n            assert.ok(docIndexString < upperBoundString);\n            const upperBoundString2 = getStartIndexStringFromUpperBound(\n                useSchema,\n                index,\n                [\n                    true,\n                    now() + 1000 * 100\n                ]\n            );\n            assert.ok(upperBoundString2 > upperBoundString);\n        });","file":"unit/custom-index.test.ts","skipped":false,"dir":"test"},{"name":"ok to create with strategies","suites":[".create() with migrationStrategies","positive"],"updatePoint":{"line":68,"column":44},"line":68,"code":"            it('ok to create with strategies', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                });\n                await db.addCollections({\n                    foobar: {\n                        schema: schemas.simpleHumanV3,\n                        autoMigrate: false,\n                        migrationStrategies: {\n                            1: () => { },\n                            2: () => { },\n                            3: () => { }\n                        }\n                    }\n                });\n                db.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"create same collection with different schema-versions","suites":[".create() with migrationStrategies","positive"],"updatePoint":{"line":86,"column":69},"line":86,"code":"            it('create same collection with different schema-versions', async () => {\n                const colName = 'human';\n                const name = randomCouchString(10);\n                const db = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n                await db.addCollections({\n                    [colName]: {\n                        schema: schemas.human,\n                        autoMigrate: false\n                    }\n                });\n\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n                await db2.addCollections({\n                    [colName]: {\n                        schema: schemas.simpleHumanV3,\n                        autoMigrate: false,\n                        migrationStrategies: {\n                            1: () => { },\n                            2: () => { },\n                            3: () => { }\n                        }\n                    }\n                });\n                db.destroy();\n                db2.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should throw when array","suites":[".create() with migrationStrategies","negative"],"updatePoint":{"line":122,"column":39},"line":122,"code":"            it('should throw when array', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        foobar: {\n                            schema: schemas.human,\n                            autoMigrate: false,\n                            migrationStrategies: [] as any\n                        }\n                    }),\n                    'RxTypeError'\n                );\n                db.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should throw when property no number","suites":[".create() with migrationStrategies","negative"],"updatePoint":{"line":139,"column":52},"line":139,"code":"            it('should throw when property no number', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        foobar: {\n                            schema: schemas.human,\n                            autoMigrate: false,\n                            migrationStrategies: {\n                                foo: function () { }\n                            }\n                        }\n                    } as any),\n                    'RxError'\n                );\n                db.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should throw when property no non-float-number","suites":[".create() with migrationStrategies","negative"],"updatePoint":{"line":158,"column":62},"line":158,"code":"            it('should throw when property no non-float-number', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        foobar: {\n                            schema: schemas.human,\n                            autoMigrate: false,\n                            migrationStrategies: {\n                                '1.1': function () { }\n                            }\n                        }\n                    }),\n                    'RxError'\n                );\n                db.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should throw when property-value no function","suites":[".create() with migrationStrategies","negative"],"updatePoint":{"line":177,"column":60},"line":177,"code":"            it('should throw when property-value no function', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        foobar: {\n                            schema: schemas.human,\n                            autoMigrate: false,\n                            migrationStrategies: {\n                                1: 'foobar'\n                            }\n                        }\n                    } as any),\n                    'RxError'\n                );\n                db.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"throw when strategy missing","suites":[".create() with migrationStrategies","negative"],"updatePoint":{"line":196,"column":43},"line":196,"code":"            it('throw when strategy missing', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        foobar: {\n                            schema: schemas.simpleHumanV3,\n                            autoMigrate: false,\n                            migrationStrategies: {\n                                1: () => { },\n                                3: () => { }\n                            }\n                        }\n                    }),\n                    'RxError'\n                );\n                db.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should NOT get an older version","suites":["DataMigrator.js","_getOldCollections()"],"updatePoint":{"line":220,"column":47},"line":220,"code":"            it('should NOT get an older version', async () => {\n                const colName = 'human';\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                });\n                const cols = await db.addCollections({\n                    [colName]: {\n                        schema: schemas.simpleHumanV3,\n                        autoMigrate: false,\n                        migrationStrategies: {\n                            1: () => { },\n                            2: () => { },\n                            3: () => { }\n                        }\n                    }\n                });\n                const col = cols[colName];\n                const old = await _getOldCollections(col.getDataMigrator());\n                assert.deepStrictEqual(old, []);\n                db.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should get an older version","suites":["DataMigrator.js","_getOldCollections()"],"updatePoint":{"line":242,"column":43},"line":242,"code":"            it('should get an older version', async () => {\n                const name = randomCouchString(10);\n                const colName = 'human';\n                const db = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n                await db.addCollections({\n                    [colName]: {\n                        schema: schemas.simpleHuman,\n                        autoMigrate: false\n                    }\n                });\n\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n                const cols2 = await db2.addCollections({\n                    [colName]: {\n                        schema: schemas.simpleHumanV3,\n                        autoMigrate: false,\n                        migrationStrategies: {\n                            1: () => { },\n                            2: () => { },\n                            3: () => { }\n                        }\n                    }\n                });\n                const col2 = cols2[colName];\n                const oldCollections = await _getOldCollections(col2.getDataMigrator());\n                assert.ok(Array.isArray(oldCollections));\n                assert.strictEqual(oldCollections.length, 1);\n\n                // ensure it is an OldCollection\n                assert.ok(oldCollections[0].newestCollection);\n\n                oldCollections.forEach(c => c.storageInstance.close().catch(() => { }));\n                db.destroy();\n                db2.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"create","suites":["DataMigrator.js","OldCollection","create"],"updatePoint":{"line":288,"column":26},"line":288,"code":"                it('create', async () => {\n                    const col = await humansCollection.createMigrationCollection();\n\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const oldCol: any = lastOfArray(oldCollections);\n\n                    assert.strictEqual(oldCol.schema.constructor.name, 'RxSchema');\n                    assert.strictEqual(oldCol.version, 0);\n                    oldCollections.forEach(c => c.storageInstance.close().catch(() => { }));\n                    col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"get a valid migrated document","suites":["DataMigrator.js","OldCollection",".migrateDocumentData()"],"updatePoint":{"line":301,"column":49},"line":301,"code":"                it('get a valid migrated document', async () => {\n                    const col = await humansCollection.createMigrationCollection(1, {\n                        3: (doc: any) => {\n                            doc.age = parseInt(doc.age, 10);\n                            return doc;\n                        }\n                    });\n\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const oldCol: any = lastOfArray(oldCollections);\n\n                    const oldDocs = await getBatchOfOldCollection(oldCol, 10);\n                    const newDoc = await migrateDocumentData(oldCol, oldDocs[0]);\n                    assert.deepStrictEqual(newDoc.age, parseInt(oldDocs[0].age, 10));\n                    oldCollections.forEach(c => c.storageInstance.close().catch(() => { }));\n                    col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"get a valid migrated document from async strategy","suites":["DataMigrator.js","OldCollection",".migrateDocumentData()"],"updatePoint":{"line":318,"column":69},"line":318,"code":"                it('get a valid migrated document from async strategy', async () => {\n                    const col = await humansCollection.createMigrationCollection(1, {\n                        3: async (doc: any) => {\n                            await promiseWait(10);\n                            doc.age = parseInt(doc.age, 10);\n                            return doc;\n                        }\n                    });\n\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const oldCol: any = lastOfArray(oldCollections);\n\n                    const oldDocs = await getBatchOfOldCollection(oldCol, 10);\n                    const newDoc = await migrateDocumentData(oldCol, oldDocs[0]);\n                    assert.deepStrictEqual(newDoc.age, parseInt(oldDocs[0].age, 10));\n                    oldCollections.forEach(c => c.storageInstance.close().catch(() => { }));\n                    col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should delete the pouchdb with all its content","suites":["DataMigrator.js","OldCollection",".remove()"],"updatePoint":{"line":338,"column":66},"line":338,"code":"                it('should delete the pouchdb with all its content', async () => {\n                    if (!config.storage.name.includes('pouchdb')) {\n                        return;\n                    }\n                    const dbName = randomCouchString(10);\n                    const col = await humansCollection.createMigrationCollection(10, {}, dbName);\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const old = lastOfArray(oldCollections);\n                    if (!old) {\n                        throw new Error('this should never happen');\n                    }\n\n                    function pouchCountAllUndeleted(\n                        pouchdb: PouchDBInstance\n                    ): Promise<number> {\n                        return pouchdb\n                            .allDocs({\n                                include_docs: false,\n                                attachments: false\n                            })\n                            .then(docs => (docs.rows as any[])\n                                .filter(row => !row.id.startsWith('_design/'))\n                                .length\n                            );\n                    }\n\n                    const undeletedResult = await old.storageInstance.query(\n                        col.database.storage.statics.prepareQuery(\n                            col.schema.jsonSchema,\n                            normalizeMangoQuery(col.schema.jsonSchema, {})\n                        )\n                    );\n                    const undeleted = undeletedResult.documents;\n                    const amount = undeleted.length;\n                    assert.strictEqual(amount, 10);\n\n                    const pouchLocation = old.storageInstance.internals.pouch.name;\n                    const checkPouch = new PouchDB(pouchLocation, {\n                        adapter: 'memory'\n                    });\n                    const amountPlain = await pouchCountAllUndeleted(checkPouch as any);\n                    assert.strictEqual(amountPlain, 10);\n\n                    // check that internal doc exists\n                    let docId = 'collection|' + _collectionNamePrimary(col.name, old.schema.jsonSchema);\n                    let iDoc = await old.database.internalStore.internals.pouch.get(docId);\n                    assert.strictEqual(typeof iDoc.data.schemaHash, 'string');\n\n\n                    await deleteOldCollection(old);\n\n                    // check that all docs deleted\n                    const checkPouch2 = new PouchDB(pouchLocation, {\n                        adapter: 'memory'\n                    });\n                    const amountPlain2 = await pouchCountAllUndeleted(checkPouch2 as any);\n                    assert.strictEqual(amountPlain2, 0);\n\n                    // check that internal doc deleted\n                    let has = true;\n                    docId = 'collection|' + _collectionNamePrimary(col.name, old.schema.jsonSchema);\n                    try {\n                        iDoc = await old.database.internalStore.internals.pouch.get(docId);\n                    } catch (e) {\n                        has = false;\n                    }\n                    assert.strictEqual(has, false);\n                    oldCollections.forEach(c => c.storageInstance.close().catch(() => { }));\n                    col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should not crash when doc already at new collection","suites":["DataMigrator.js","OldCollection","._migrateDocuments()"],"updatePoint":{"line":418,"column":71},"line":418,"code":"                it('should not crash when doc already at new collection', async () => {\n                    const col = await humansCollection.createMigrationCollection(10, {\n                        3: (doc: any) => {\n                            doc.age = parseInt(doc.age, 10);\n                            return doc;\n                        }\n                    });\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const oldCol = lastOfArray(oldCollections);\n\n                    // simluate prerun of migrate()\n                    const oldDocs = await getBatchOfOldCollection(oldCol as any, 10);\n                    const tryDoc = oldDocs.shift();\n                    const actions = await _migrateDocuments(oldCol as any, [tryDoc]);\n                    assert.strictEqual(actions[0].type, 'success');\n\n                    // this should no crash because existing doc will be overwritten\n                    await _migrateDocuments(oldCol as any, [tryDoc]);\n\n                    await Promise.all(\n                        oldCollections.map(c => c.storageInstance.close().catch(() => { }))\n                    );\n                    await col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should resolve finished when no docs","suites":["DataMigrator.js","OldCollection",".migrate()"],"updatePoint":{"line":444,"column":56},"line":444,"code":"                it('should resolve finished when no docs', async () => {\n                    const col = await humansCollection.createMigrationCollection(0);\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const oldCol = lastOfArray(oldCollections);\n\n                    await migratePromise(oldCol as any);\n                    await Promise.all(\n                        oldCollections.map(c => c.storageInstance.close().catch(() => { }))\n                    );\n                    await col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should resolve finished when some docs are in the collection","suites":["DataMigrator.js","OldCollection",".migrate()"],"updatePoint":{"line":455,"column":80},"line":455,"code":"                it('should resolve finished when some docs are in the collection', async () => {\n                    if (!config.storage.name.includes('pouchdb')) {\n                        return;\n                    }\n                    const col = await humansCollection.createMigrationCollection(10, {\n                        3: (doc: any) => {\n                            doc.age = parseInt(doc.age, 10);\n                            return doc;\n                        }\n                    });\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const oldCol = lastOfArray(oldCollections);\n\n                    const docsPrev = await col.storageInstance.internals.pouch.allDocs({\n                        include_docs: false,\n                        attachments: false\n                    });\n                    const preFiltered = docsPrev.rows.filter((doc: any) => !doc.id.startsWith('_design'));\n                    assert.strictEqual(preFiltered.length, 0);\n\n                    await migratePromise(oldCol as any);\n\n                    // check if in new collection\n                    const docs = await col.find().exec();\n                    assert.strictEqual(docs.length, 10);\n                    await Promise.all(\n                        oldCollections.map(c => c.storageInstance.close().catch(() => { }))\n                    );\n                    await col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should emit status for every handled document","suites":["DataMigrator.js","OldCollection",".migrate()"],"updatePoint":{"line":485,"column":65},"line":485,"code":"                it('should emit status for every handled document', async () => {\n                    const col = await humansCollection.createMigrationCollection(10, {\n                        3: async (doc: any) => {\n                            await promiseWait(10);\n                            doc.age = parseInt(doc.age, 10);\n                            return doc;\n                        }\n                    });\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const oldCol = lastOfArray(oldCollections);\n\n                    const pw8 = AsyncTestUtil.waitResolveable(1000);\n\n                    // batchSize is doc.length / 2 to make sure it takes a bit\n                    const state$ = migrateOldCollection(oldCol as any, 5);\n                    const states = [];\n                    state$.subscribe((state: any) => {\n                        assert.strictEqual(state.type, 'success');\n                        assert.ok(state.doc.passportId);\n                        states.push(state);\n                    }, () => {\n                        throw new Error('this test should not call error');\n                    }, () => pw8.resolve());\n\n                    await pw8.promise;\n                    assert.strictEqual(states.length, 10);\n                    await Promise.all(\n                        oldCollections.map(c => c.storageInstance.close().catch(() => { }))\n                    );\n                    await col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should emit \"deleted\" when migration-strategy returns null","suites":["DataMigrator.js","OldCollection",".migrate()"],"updatePoint":{"line":517,"column":78},"line":517,"code":"                it('should emit \"deleted\" when migration-strategy returns null', async () => {\n                    const col = await humansCollection.createMigrationCollection(10, {\n                        3: () => {\n                            return null;\n                        }\n                    });\n                    const olds = await _getOldCollections(col.getDataMigrator());\n                    const oldCol = olds.pop();\n\n                    // batchSize is doc.length / 2 to make sure it takes a bit\n                    const state$ = migrateOldCollection(oldCol as any, 5);\n                    const states = [];\n                    state$.subscribe((state: any) => {\n                        assert.strictEqual(state.type, 'deleted');\n                        states.push(state);\n                    });\n\n                    await AsyncTestUtil.waitUntil(() => states.length === 10);\n                    col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should throw when document cannot be migrated","suites":["DataMigrator.js","OldCollection",".migrate()"],"updatePoint":{"line":537,"column":65},"line":537,"code":"                it('should throw when document cannot be migrated', async () => {\n                    const col = await humansCollection.createMigrationCollection(10, {\n                        3: () => {\n                            throw new Error('foobar');\n                        }\n                    });\n                    const oldCollections = await _getOldCollections(col.getDataMigrator());\n                    const oldCol = lastOfArray(oldCollections);\n                    await AsyncTestUtil.assertThrows(\n                        () => migratePromise(oldCol as any),\n                        Error\n                    );\n                    await Promise.all(\n                        oldCollections.map(c => c.storageInstance.close().catch(() => { }))\n                    );\n                    await col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should not crash when nothing to migrate","suites":["DataMigrator.js",".migrate()","positive"],"updatePoint":{"line":559,"column":60},"line":559,"code":"                it('should not crash when nothing to migrate', async () => {\n                    const col = await humansCollection.createMigrationCollection(0, {});\n                    const pw8 = AsyncTestUtil.waitResolveable(5000); // higher than test-timeout\n                    const states: any[] = [];\n                    const state$ = col.migrate();\n                    state$['subscribe'](s => {\n                        states.push(s);\n                    }, null, pw8.resolve as any);\n\n                    await pw8.promise;\n                    assert.strictEqual(states[0].done, false);\n                    assert.strictEqual(states[0].percent, 0);\n                    assert.strictEqual(states[0].total, 0);\n\n                    assert.strictEqual(states[1].done, true);\n                    assert.strictEqual(states[1].percent, 100);\n                    assert.strictEqual(states[1].total, 0);\n                    await col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should not crash when migrating data","suites":["DataMigrator.js",".migrate()","positive"],"updatePoint":{"line":579,"column":56},"line":579,"code":"                it('should not crash when migrating data', async () => {\n                    const col = await humansCollection.createMigrationCollection(5, {\n                        3: (doc: any) => {\n                            doc.age = parseInt(doc.age, 10);\n                            return doc;\n                        }\n                    });\n                    const pw8 = AsyncTestUtil.waitResolveable(5000); // higher than test-timeout\n                    const states: any[] = [];\n                    const state$ = col.migrate();\n                    state$['subscribe'](s => {\n                        states.push(s);\n                    }, null, pw8.resolve as any);\n\n                    await pw8.promise;\n\n                    assert.strictEqual(states.length, 7);\n\n                    assert.strictEqual(states[0].done, false);\n                    assert.strictEqual(states[0].percent, 0);\n                    assert.strictEqual(states[0].total, 5);\n\n                    const midState = states[4];\n                    assert.strictEqual(midState.done, false);\n                    assert.strictEqual(midState.percent, 80);\n                    assert.strictEqual(midState.handled, 4);\n                    assert.strictEqual(midState.success, 4);\n\n                    const lastState = states.pop();\n                    assert.strictEqual(lastState.done, true);\n                    assert.strictEqual(lastState.percent, 100);\n                    assert.strictEqual(lastState.total, 5);\n                    assert.strictEqual(lastState.success, 5);\n                    await col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should .error when strategy fails","suites":["DataMigrator.js",".migrate()","negative"],"updatePoint":{"line":616,"column":53},"line":616,"code":"                it('should .error when strategy fails', async () => {\n                    const col = await humansCollection.createMigrationCollection(5, {\n                        3: () => {\n                            throw new Error('foobar');\n                        }\n                    });\n                    const pw8 = AsyncTestUtil.waitResolveable(5000); // higher than test-timeout\n                    const state$ = col.migrate();\n                    state$.subscribe(undefined, pw8.resolve as any, undefined);\n\n                    await pw8.promise;\n                    await col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should resolve when nothing to migrate","suites":["DataMigrator.js",".migratePromise()","positive"],"updatePoint":{"line":633,"column":58},"line":633,"code":"                it('should resolve when nothing to migrate', async () => {\n                    const col = await humansCollection.createMigrationCollection(0, {});\n                    await col.migratePromise();\n                    await col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should resolve when migrating data","suites":["DataMigrator.js",".migratePromise()","positive"],"updatePoint":{"line":639,"column":54},"line":639,"code":"                it('should resolve when migrating data', async () => {\n                    const col = await humansCollection.createMigrationCollection(5, {\n                        3: (doc: any) => {\n                            doc.age = parseInt(doc.age, 10);\n                            return doc;\n                        }\n                    });\n                    await col.migratePromise();\n                    await col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should reject when migration fails","suites":["DataMigrator.js",".migratePromise()","negative"],"updatePoint":{"line":651,"column":54},"line":651,"code":"                it('should reject when migration fails', async () => {\n                    const col = await humansCollection.createMigrationCollection(5, {\n                        3: () => {\n                            throw new Error('foobar');\n                        }\n                    });\n                    let failed = false;\n                    await col.migratePromise().catch(() => failed = true);\n                    assert.ok(failed);\n                    await col.database.destroy();\n                });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should auto-run on creation","suites":["integration into collection","run"],"updatePoint":{"line":667,"column":43},"line":667,"code":"            it('should auto-run on creation', async () => {\n                const col = await humansCollection.createMigrationCollection(\n                    10,\n                    {\n                        3: (doc: any) => {\n                            doc.age = parseInt(doc.age, 10);\n                            return doc;\n                        }\n                    },\n                    randomCouchString(10),\n                    true\n                );\n                const docs = await col.find().exec();\n                assert.strictEqual(docs.length, 10);\n                assert.strictEqual(typeof (docs.pop() as any).age, 'number');\n                await col.database.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should be able to change the primary key during migration","suites":["integration into collection","run"],"updatePoint":{"line":684,"column":73},"line":684,"code":"            it('should be able to change the primary key during migration', async () => {\n                const dbName = randomCouchString(10);\n                const schema0 = {\n                    version: 0,\n                    primaryKey: 'id',\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    },\n                    required: ['id']\n                };\n                const schema1 = {\n                    version: 1,\n                    primaryKey: 'id',\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        name: {\n                            type: 'string'\n                        }\n                    },\n                    required: ['id', 'name']\n                };\n                const db = await createRxDatabase({\n                    name: dbName,\n                    storage: config.storage.getStorage(),\n                });\n                const cols = await db.addCollections({\n                    heroes: {\n                        schema: schema0\n                    }\n                });\n                const col = cols.heroes;\n                await col.insert({\n                    id: 'niven'\n                });\n                await db.destroy();\n\n                const db2 = await createRxDatabase({\n                    name: dbName,\n                    storage: config.storage.getStorage(),\n                });\n                const cols2 = await db2.addCollections({\n                    heroes: {\n                        schema: schema1,\n                        migrationStrategies: {\n                            1: (oldDoc: any) => {\n                                oldDoc.name = (oldDoc.id as string).toUpperCase();\n                                return oldDoc;\n                            }\n                        }\n                    }\n                });\n                const col2 = cols2.heroes;\n\n                const doc = await col2.findOne().exec();\n\n                assert.ok(doc);\n                assert.strictEqual(doc.id, 'niven');\n                assert.strictEqual(doc.name, 'NIVEN');\n                db2.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should auto-run on creation (async)","suites":["integration into collection","run"],"updatePoint":{"line":753,"column":51},"line":753,"code":"            it('should auto-run on creation (async)', async () => {\n                const col = await humansCollection.createMigrationCollection(\n                    10, {\n                    3: (doc: any) => {\n                        promiseWait(10);\n                        doc.age = parseInt(doc.age, 10);\n                        return doc;\n                    }\n                },\n                    randomCouchString(10),\n                    true\n                );\n                const docs = await col.find().exec();\n                assert.strictEqual(docs.length, 10);\n                assert.strictEqual(typeof (docs.pop() as any).age, 'number');\n                col.database.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should increase revision height when the strategy changed the documents data","suites":["integration into collection","run"],"updatePoint":{"line":770,"column":92},"line":770,"code":"            it('should increase revision height when the strategy changed the documents data', async () => {\n                const dbName = randomCouchString(10);\n\n                const nonChangedKey = 'not-changed-data';\n                const changedKey = 'changed-data';\n\n                const db = await createRxDatabase({\n                    name: dbName,\n                    storage: config.storage.getStorage(),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.humanFinal\n                    }\n                });\n\n\n                const col = cols.humans;\n                await col.bulkInsert([\n                    {\n                        passportId: changedKey,\n                        firstName: 'foo',\n                        lastName: 'bar',\n                        age: 20\n                    }\n                ]);\n\n                /**\n                 * To ensure that we really keep that revision, we\n                 * hackly insert this document via the RxStorageInstance.\n                 */\n                const originalStorageInstance: RxStorageInstance<HumanDocumentType, any, any> = (col.storageInstance as any).originalStorageInstance;\n                await originalStorageInstance.bulkWrite([{\n                    document: {\n                        passportId: nonChangedKey,\n                        firstName: 'foo',\n                        lastName: 'bar',\n                        age: 21,\n                        _meta: {\n                            lwt: now()\n                        },\n                        _rev: EXAMPLE_REVISION_1,\n                        _attachments: {},\n                        _deleted: false\n                    }\n                }], 'test-data-migration');\n\n                await db.destroy();\n\n                const db2 = await createRxDatabase({\n                    name: dbName,\n                    storage: config.storage.getStorage(),\n                });\n                const schema2 = clone(schemas.humanFinal);\n                schema2.version = 1;\n\n                const cols2 = await db2.addCollections({\n                    humans: {\n                        schema: schema2,\n                        migrationStrategies: {\n                            1: function (docData: HumanDocumentType) {\n                                if (docData.passportId === changedKey) {\n                                    docData.age = 100;\n                                }\n                                return docData;\n                            }\n                        }\n                    }\n                });\n                const col2 = cols2.humans;\n\n                /**\n                 * If document data was not changed by migration, it should have kept the same revision\n                 */\n                const revAfterMigration = (await col2.findOne(nonChangedKey).exec(true)).toJSON(true)._rev;\n                assert.strictEqual(EXAMPLE_REVISION_1, revAfterMigration);\n\n                /**\n                 * If document was changed, we should have an increased revision height\n                 * to ensure that replicated instances use our new data.\n                 */\n                const revChangedAfterMigration = (await col2.findOne(changedKey).exec(true)).toJSON(true)._rev;\n                const afterHeight = getHeightOfRevision(revChangedAfterMigration);\n                assert.strictEqual(afterHeight, 2);\n\n                db2.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"return true if schema-version is 0","suites":["integration into collection",".migrationNeeded()"],"updatePoint":{"line":859,"column":50},"line":859,"code":"            it('return true if schema-version is 0', async () => {\n                const col = await humansCollection.create();\n                const needed = await col.migrationNeeded();\n                assert.strictEqual(needed, false);\n                col.database.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"return false if nothing to migrate","suites":["integration into collection",".migrationNeeded()"],"updatePoint":{"line":865,"column":50},"line":865,"code":"            it('return false if nothing to migrate', async () => {\n                const col = await humansCollection.createMigrationCollection(5, {\n                    3: (doc: any) => {\n                        doc.age = parseInt(doc.age, 10);\n                        return doc;\n                    }\n                });\n                await col.migratePromise();\n                const needed = await col.migrationNeeded();\n                assert.strictEqual(needed, false);\n                col.database.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"return true if something to migrate","suites":["integration into collection",".migrationNeeded()"],"updatePoint":{"line":877,"column":51},"line":877,"code":"            it('return true if something to migrate', async () => {\n                const col = await humansCollection.createMigrationCollection(5, {\n                    3: (doc: any) => {\n                        doc.age = parseInt(doc.age, 10);\n                        return doc;\n                    }\n                });\n                const needed = await col.migrationNeeded();\n                assert.strictEqual(needed, true);\n                col.database.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should emit the ongoing migration state","suites":["RxDatabase.migrationStates()"],"updatePoint":{"line":891,"column":51},"line":891,"code":"        it('should emit the ongoing migration state', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage(),\n            });\n            const migrationStrategies = {\n                1: () => { },\n                2: () => { },\n                3: () => { }\n            };\n\n            const emitted: any[] = [];\n            db.migrationStates().subscribe(x => emitted.push(x));\n\n            await db.addCollections({\n                foobar: {\n                    schema: schemas.simpleHumanV3,\n                    autoMigrate: false,\n                    migrationStrategies\n                },\n                foobar2: {\n                    schema: schemas.simpleHumanV3,\n                    autoMigrate: false,\n                    migrationStrategies\n                }\n            });\n\n            await Promise.all([\n                db.foobar.migrate().toPromise(),\n                db.foobar2.migrate().toPromise()\n            ]);\n\n            assert.ok(emitted.length >= 2);\n\n            const endStates = emitted.map(list => list.map((i: any) => i.state)).pop();\n            if (!endStates) {\n                throw new Error('endStates missing');\n            }\n            assert.strictEqual(endStates.length, 2);\n            endStates.forEach((s: any) => {\n                assert.strictEqual(s.done, true);\n            });\n\n            db.destroy();\n        });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should add the _meta field if it is missing","suites":["major versions","12.0.0"],"updatePoint":{"line":945,"column":59},"line":945,"code":"            it('should add the _meta field if it is missing', async () => {\n                const dbName = randomCouchString(10);\n                const docId = 'foobar';\n                const db = await createRxDatabase({\n                    name: dbName,\n                    storage: config.storage.getStorage(),\n                });\n                await db.addCollections<{\n                    foobar: RxCollection<SimpleHumanV3DocumentType>\n                }>({\n                    foobar: {\n                        schema: schemas.simpleHuman\n                    }\n                });\n                const collection: RxCollection<SimpleHumanV3DocumentType> = db.foobar;\n\n                // insert a document without the _meta field\n                const insertDocData = Object.assign(\n                    simpleHumanV3(docId),\n                    {\n                        _deleted: false,\n                        _attachments: {},\n                        // DO NOT ADD THE META FIELD HERE\n                        // _meta: {\n                        //     lwt: 3\n                        // }\n                    } as any\n                );\n                insertDocData._rev = createRevision(defaultHashFunction, insertDocData);\n                await collection.storageInstance.bulkWrite([{\n                    document: insertDocData\n                }], 'data-migration-test');\n                await db.destroy();\n\n                const db2 = await createRxDatabase({\n                    name: dbName,\n                    storage: config.storage.getStorage(),\n                });\n                const schemaV2 = clone(schemas.simpleHuman);\n                schemaV2.version = 1;\n                await db2.addCollections<{\n                    foobar: RxCollection<SimpleHumanV3DocumentType>\n                }>({\n                    foobar: {\n                        schema: schemaV2,\n                        migrationStrategies: {\n                            1: (oldDoc: SimpleHumanV3DocumentType) => {\n                                (oldDoc as any).age = '99';\n                                return oldDoc;\n                            }\n                        }\n                    }\n                });\n                const collection2: RxCollection<SimpleHumanV3DocumentType> = db2.foobar;\n\n                const doc = await collection2.findOne(docId).exec(true);\n                const docData = doc.toJSON(true);\n\n                assert.ok(docData._meta);\n                assert.ok(docData._meta.lwt);\n\n                db2.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"reproduce and fix","suites":["issues","#212 migration runs into infinity-loop"],"updatePoint":{"line":1012,"column":33},"line":1012,"code":"            it('reproduce and fix', async () => {\n                const dbName = randomCouchString(10);\n                const schema0 = {\n                    title: 'hero schema',\n                    description: 'describes a simple hero',\n                    version: 0,\n                    primaryKey: 'name',\n                    type: 'object',\n                    properties: {\n                        name: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        color: {\n                            type: 'string'\n                        }\n                    },\n                    required: ['color']\n                };\n                const schema1 = {\n                    title: 'hero schema',\n                    description: 'describes a simple hero',\n                    version: 1,\n                    primaryKey: 'name',\n                    type: 'object',\n                    properties: {\n                        name: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        color: {\n                            type: 'string'\n                        },\n                        level: {\n                            type: 'string'\n                        }\n                    },\n                    required: ['color']\n                };\n                const db = await createRxDatabase({\n                    name: dbName,\n                    storage: config.storage.getStorage(),\n                });\n                const cols = await db.addCollections({\n                    heroes: {\n                        schema: schema0\n                    }\n                });\n                const col = cols.heroes;\n                await col.insert({\n                    name: 'Niven',\n                    color: 'black'\n                });\n                await db.destroy();\n\n                const db2 = await createRxDatabase({\n                    name: dbName,\n                    storage: config.storage.getStorage(),\n                });\n                const cols2 = await db2.addCollections({\n                    heroes: {\n                        schema: schema1,\n                        migrationStrategies: {\n                            1: (oldDoc: any) => {\n                                oldDoc.level = 'ss';\n                                return oldDoc;\n                            }\n                        }\n                    }\n                });\n                const col2 = cols2.heroes;\n\n                const docs = await col2.find().exec();\n                assert.strictEqual(docs.length, 1);\n                assert.strictEqual(docs[0].level, 'ss');\n                assert.strictEqual(docs[0].name, 'Niven');\n                assert.strictEqual(docs[0].color, 'black');\n                db2.destroy();\n            });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"#3460 migrate attachments","suites":["issues","#212 migration runs into infinity-loop"],"updatePoint":{"line":1092,"column":37},"line":1092,"code":"        it('#3460 migrate attachments', async () => {\n            const attachmentData = AsyncTestUtil.randomString(20);\n            const dataBlobBuffer = blobBufferUtil.createBlobBuffer(\n                attachmentData,\n                'text/plain'\n            );\n\n            const dataStringBase64 = await blobBufferUtil.toBase64String(dataBlobBuffer);\n            const attachmentHash = await hashAttachmentData(dataStringBase64);\n\n            const col = await humansCollection.createMigrationCollection(10, {\n                3: (doc: any) => {\n                    doc.age = parseInt(doc.age, 10);\n                    return doc;\n                }\n            }, randomCouchString(10), false, {\n                id: 'foo',\n                data: dataBlobBuffer,\n                type: 'text/plain'\n            });\n            const olds = await _getOldCollections(col.getDataMigrator());\n            const oldCol = lastOfArray(olds);\n\n            const oldDocs = await getBatchOfOldCollection(oldCol as any, 10);\n            const tryDoc = oldDocs.shift();\n            const actions = await _migrateDocuments(oldCol as any, [tryDoc]);\n            assert.strictEqual(actions[0].type, 'success');\n\n            const docs = await col.find().exec();\n            const attachment = docs[0].getAttachment('foo');\n            assert.ok(attachment);\n            assert.strictEqual(attachment.type, 'text/plain');\n            assert.strictEqual(attachment.digest, 'md5-' + attachmentHash);\n            assert.strictEqual(attachment.length, attachmentData.length);\n\n            olds.forEach(oldCol => oldCol.storageInstance.close().catch(() => { }));\n            col.database.destroy();\n        });","file":"unit/data-migration.test.ts","skipped":false,"dir":"test"},{"name":"should convert unsupported IndexedDB key","suites":[".fromStorageToDexie()"],"updatePoint":{"line":14,"column":52},"line":14,"code":"        it('should convert unsupported IndexedDB key', () => {\n            const result = fromStorageToDexie(\n                {\n                    '|key': 'value',\n                    '|objectArray': [{ ['|id']: '1' }],\n                    '|nestedObject': {\n                        key: 'value2',\n                        '|objectArray': [{ '|id': '2' }],\n                        stringArray: ['415', '51'],\n                        '|numberArray': [1, 2, 3],\n                        '|falsyValue': null\n                    }\n                }\n            );\n            assert.deepStrictEqual(result, {\n                '__key': 'value',\n                '__objectArray': [{ ['__id']: '1' }],\n                '__nestedObject': {\n                    key: 'value2',\n                    '__objectArray': [{ '__id': '2' }],\n                    stringArray: ['415', '51'],\n                    '__numberArray': [1, 2, 3],\n                    '__falsyValue': null\n                }\n            });\n        });","file":"unit/dexie-helper.test.ts","skipped":false,"dir":"test"},{"name":"should revert escaped unsupported IndexedDB key","suites":[".fromDexieToStorage()"],"updatePoint":{"line":42,"column":59},"line":42,"code":"        it('should revert escaped unsupported IndexedDB key', () => {\n            const result = fromDexieToStorage({\n                '__key': 'value',\n                '__objectArray': [{ ['__id']: '1' }],\n                '__nestedObject': {\n                    key: 'value2',\n                    '__objectArray': [{ '__id': '2' }],\n                    stringArray: ['415', '51'],\n                    '__numberArray': [1, 2, 3],\n                    '__falsyValue': null\n                }\n            }\n            );\n            assert.deepStrictEqual(result,\n                {\n                    '|key': 'value',\n                    '|objectArray': [{ ['|id']: '1' }],\n                    '|nestedObject': {\n                        key: 'value2',\n                        '|objectArray': [{ '|id': '2' }],\n                        stringArray: ['415', '51'],\n                        '|numberArray': [1, 2, 3],\n                        '|falsyValue': null\n                    }\n                });\n        });","file":"unit/dexie-helper.test.ts","skipped":false,"dir":"test"},{"name":"string","suites":["basics",".encryptString()"],"updatePoint":{"line":60,"column":22},"line":60,"code":"            it('string', () => {\n                const value = 'foobar';\n                const encrypted = encryptString(value, 'mypw');\n                assert.strictEqual(typeof encrypted, 'string');\n                assert.ok(!encrypted.includes(value));\n                assert.ok(encrypted.length > value.length);\n            });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"string","suites":["basics",".decryptString()"],"updatePoint":{"line":69,"column":22},"line":69,"code":"            it('string', () => {\n                const value = 'foobar';\n                const encrypted = encryptString(value, 'mypw');\n                const decrypted = decryptString(encrypted, 'mypw');\n                assert.deepStrictEqual(decrypted, value);\n            });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"should encrypt and decrypt an extremly long string","suites":["basics",".decryptString()"],"updatePoint":{"line":75,"column":66},"line":75,"code":"            it('should encrypt and decrypt an extremly long string', () => {\n                const value = randomCouchString(5000);\n                const pwd = 'pwd';\n                const encrypted = encryptString(value, pwd);\n                const decrypted = decryptString(encrypted, pwd);\n                assert.notStrictEqual(value, encrypted);\n                assert.ok(encrypted.length > value.length);\n                assert.strictEqual(typeof encrypted, 'string');\n                assert.strictEqual(value, decrypted);\n            });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"should encrypt and decrypt an extremly long password","suites":["basics",".decryptString()"],"updatePoint":{"line":85,"column":68},"line":85,"code":"            it('should encrypt and decrypt an extremly long password', () => {\n                const value = 'foobar';\n                const pwd = randomCouchString(5000);\n                const encrypted = encryptString(value, pwd);\n                const decrypted = decryptString(encrypted, pwd);\n                assert.notStrictEqual(value, encrypted);\n                assert.ok(encrypted.length > value.length);\n                assert.strictEqual(typeof encrypted, 'string');\n                assert.strictEqual(value, decrypted);\n            });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"should crash with invalid password (no string)","suites":["RxDatabase creation"],"updatePoint":{"line":98,"column":58},"line":98,"code":"        it('should crash with invalid password (no string)', async () => {\n            await AsyncTestUtil.assertThrows(\n                () => createRxDatabase({\n                    name: randomCouchString(10),\n                    storage,\n                    password: {}\n                }),\n                'RxTypeError',\n                'EN1'\n            );\n        });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"should crash with invalid password (too short)","suites":["RxDatabase creation"],"updatePoint":{"line":109,"column":58},"line":109,"code":"        it('should crash with invalid password (too short)', async () => {\n            await AsyncTestUtil.assertThrows(\n                () => createRxDatabase({\n                    name: randomCouchString(10),\n                    storage,\n                    password: randomCouchString(4)\n                }),\n                'RxError',\n                'EN2'\n            );\n        });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"BUG: should have stored the password hash when creating the database","suites":["RxDatabase creation"],"updatePoint":{"line":120,"column":80},"line":120,"code":"        it('BUG: should have stored the password hash when creating the database', async () => {\n            const name = randomCouchString(10);\n            const password = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage,\n                password,\n                ignoreDuplicate: true\n            });\n            await db.storageTokenDocument;\n            const doc = await getSingleDocument<InternalStoreStorageTokenDocType>(\n                db.internalStore,\n                STORAGE_TOKEN_DOCUMENT_ID\n            );\n            if (!doc) {\n                throw new Error('error in test this should never happen ' + doc);\n            }\n            assert.strictEqual(typeof doc.data.passwordHash, 'string');\n            const db2 = await createRxDatabase({\n                name,\n                storage,\n                password,\n                ignoreDuplicate: true\n            });\n            await ensureNoStartupErrors(db2);\n            const doc2 = await getSingleDocument<InternalStoreStorageTokenDocType>(\n                db.internalStore,\n                STORAGE_TOKEN_DOCUMENT_ID\n            );\n            assert.ok(doc2);\n            assert.strictEqual(typeof doc2.data.passwordHash, 'string');\n\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"prevent 2 instances with different passwords on same adapter","suites":["RxDatabase creation"],"updatePoint":{"line":155,"column":72},"line":155,"code":"        it('prevent 2 instances with different passwords on same adapter', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage,\n                password: randomCouchString(10),\n                ignoreDuplicate: true\n            });\n            await db.storageToken;\n            const db2 = await createRxDatabase({\n                name,\n                storage,\n                password: randomCouchString(10),\n                ignoreDuplicate: true\n            });\n\n            /**\n             * Because the database creation does some\n             * tasks lazy, we have to run addCollections\n             * so that ensureNoStartupErrors(rxDatabase) can throw\n             * its stored errors.\n             */\n            await AsyncTestUtil.assertThrows(\n                () => db2.addCollections({\n                    humanenc: {\n                        schema: schemas.encryptedHuman\n                    }\n                }),\n                'RxError',\n                'DB1'\n            );\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"create encrypted collection","suites":["RxCollection creation"],"updatePoint":{"line":191,"column":39},"line":191,"code":"        it('create encrypted collection', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage,\n                password: randomCouchString(12)\n            });\n            const collections = await db.addCollections({\n                humanenc: {\n                    schema: schemas.encryptedHuman\n                }\n            });\n            const collection = collections.humanenc;\n            assert.ok(isRxCollection(collection));\n            db.destroy();\n        });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"should insert one encrypted value (string)","suites":["RxCollection.insert()"],"updatePoint":{"line":208,"column":54},"line":208,"code":"        it('should insert one encrypted value (string)', async () => {\n            const c = await createEncryptedCollection(0);\n            const agent = schemaObjects.encryptedHuman();\n            await c.insert(agent);\n            const doc = await c.findOne().exec(true);\n            const secret = doc.get('secret');\n            assert.strictEqual(agent.secret, secret);\n            c.database.destroy();\n        });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"should insert one encrypted value (object)","suites":["RxCollection.insert()"],"updatePoint":{"line":217,"column":54},"line":217,"code":"        it('should insert one encrypted value (object)', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage,\n                password: randomCouchString(10)\n            });\n            const c = await db.addCollections({\n                enchuman: {\n                    schema: schemas.encryptedObjectHuman\n                }\n            });\n            const agent = schemaObjects.encryptedObjectHuman();\n            await c.enchuman.insert(agent);\n            const doc = await c.enchuman.findOne().exec();\n            const secret = doc.get('secret');\n            assert.strictEqual(agent.secret.name, secret.name);\n            assert.strictEqual(agent.secret.subname, secret.subname);\n            db.destroy();\n        });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"should save one encrypted value (string)","suites":["RxDocument.save()"],"updatePoint":{"line":238,"column":52},"line":238,"code":"        it('should save one encrypted value (string)', async () => {\n            const c = await createEncryptedCollection(0);\n            const agent = schemaObjects.encryptedHuman();\n            await c.insert(agent);\n            const doc = await c.findOne().exec(true);\n            const secret = doc.get('secret');\n            assert.strictEqual(agent.secret, secret);\n            const newSecret = randomCouchString(10);\n\n            await doc.atomicPatch({ secret: newSecret });\n            const docNew = await c.findOne().exec(true);\n            assert.strictEqual(newSecret, docNew.get('secret'));\n            c.database.destroy();\n        });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"should save one encrypted value (object)","suites":["RxDocument.save()"],"updatePoint":{"line":252,"column":52},"line":252,"code":"        it('should save one encrypted value (object)', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage,\n                password: randomCouchString(10)\n            });\n            const c = await db.addCollections({\n                enchuman: {\n                    schema: schemas.encryptedObjectHuman\n                }\n            });\n            const agent = schemaObjects.encryptedObjectHuman();\n            await c.enchuman.insert(agent);\n            const newSecret = {\n                name: randomCouchString(10),\n                subname: randomCouchString(10)\n            };\n            const doc = await c.enchuman.findOne().exec(true);\n            const secret = doc.get('secret');\n\n            assert.strictEqual(agent.secret.name, secret.name);\n            assert.strictEqual(agent.secret.subname, secret.subname);\n\n            await doc.atomicPatch({ secret: newSecret });\n            const docNew = await c.enchuman.findOne().exec(true);\n\n            assert.strictEqual(newSecret.name, docNew.get('secret.name'));\n            assert.strictEqual(newSecret.subname, docNew.get('secret.subname'));\n            db.destroy();\n        });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"#837 Recover from wrong database password","suites":["ISSUES"],"updatePoint":{"line":284,"column":53},"line":284,"code":"        it('#837 Recover from wrong database password', async () => {\n            if (!config.storage.hasPersistence) {\n                return;\n            }\n\n            const name = randomCouchString(10) + '837';\n            const password = randomCouchString(10);\n\n            // 1. create and destroy encrypted db\n            const db1 = await createRxDatabase({\n                name,\n                storage,\n                password\n            });\n            await db1.destroy();\n\n            // 2. reopen with wrong password\n\n            const db2 = await createRxDatabase({\n                name,\n                storage,\n                password: 'foobarfoobar'\n            });\n\n            await AsyncTestUtil.assertThrows(\n                () => ensureNoStartupErrors(db2),\n                'RxError',\n                'different password'\n            );\n            await db2.destroy();\n\n            // 3. reopen with correct password\n            const db3 = await createRxDatabase({\n                name,\n                storage,\n                password\n            });\n            assert.ok(db3);\n            await db3.destroy();\n        });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"#917 Unexpected end of JSON input","suites":["ISSUES"],"updatePoint":{"line":324,"column":45},"line":324,"code":"        it('#917 Unexpected end of JSON input', async () => {\n            const schema: RxJsonSchema<{ name: string; color: string; happy: boolean; }> = {\n                title: 'hero schema',\n                description: 'describes a simple hero',\n                version: 0,\n                primaryKey: 'name',\n                type: 'object',\n                properties: {\n                    name: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    color: {\n                        type: 'string'\n                    },\n                    happy: {\n                        type: 'boolean'\n                    }\n                },\n                required: ['color'],\n                encrypted: [\n                    'color',\n                    'happy'\n                ]\n            };\n            const dbName = randomCouchString(10);\n\n            const db = await createRxDatabase({\n                name: dbName,\n                storage,\n                password: 'myLongAndStupidPassword'\n            });\n\n            const collections = await db.addCollections({\n                heroes: {\n                    schema\n                }\n            });\n            const collection = collections.heroes;\n\n            // insert a document\n            const record = await collection.findOne().exec();\n            if (!record) {\n                await collection.upsert({\n                    name: 'big-billy',\n                    color: 'arugula',\n                });\n            }\n\n            // will throw exception\n            await collection.findOne().exec();\n\n            db.destroy();\n        });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"schema example 1","suites":["ISSUES","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":379,"column":32},"line":379,"code":"            it('schema example 1', async () => {\n                const schema: RxJsonSchema<{ user_id: string; user_pwd: string; last_login: number; status: string; }> = {\n                    keyCompression: false,\n                    version: 0,\n                    primaryKey: 'user_id',\n                    type: 'object',\n                    properties: {\n                        user_id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        user_pwd: {\n                            type: 'string',\n                        },\n                        last_login: {\n                            type: 'number'\n                        },\n                        status: {\n                            type: 'string'\n                        }\n                    },\n                    required: ['user_pwd', 'last_login', 'status'],\n                    encrypted: [\n                        'user_pwd'\n                    ]\n                };\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage,\n                    password: randomCouchString(20)\n                });\n                const colName = randomCouchString(10);\n                const collections = await db.addCollections({\n                    [colName]: {\n                        schema\n                    }\n                });\n                const collection = collections[colName];\n\n                const query = collection\n                    .findOne()\n                    .where('status')\n                    .eq('foobar');\n\n                const resultDoc = await query.exec();\n                assert.strictEqual(resultDoc, null);\n\n                const queryAll = collection\n                    .find()\n                    .where('status')\n                    .eq('foobar');\n\n                const resultsAll = await queryAll.exec();\n                assert.strictEqual(resultsAll.length, 0);\n                db.destroy();\n            });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"schema example 2","suites":["ISSUES","#157 Cannot sort on field(s) \"XXX\" when using the default index"],"updatePoint":{"line":435,"column":32},"line":435,"code":"            it('schema example 2', async () => {\n                const schema: RxJsonSchema<{ id: string; value: number; }> = {\n                    keyCompression: false,\n                    version: 0,\n                    primaryKey: 'id',\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        value: {\n                            type: 'number',\n                            minimum: 0,\n                            maximum: 1000000,\n                            multipleOf: 1\n                        }\n                    },\n                    indexes: ['value']\n                };\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage,\n                    password: randomCouchString(20)\n                });\n\n                const colName = randomCouchString(10);\n                const collections = await db.addCollections({\n                    [colName]: {\n                        schema\n                    }\n                });\n                const collection = collections[colName];\n\n                const queryAll = collection\n                    .find()\n                    .sort({\n                        value: 'desc'\n                    });\n\n                const resultsAll = await queryAll.exec();\n                assert.strictEqual(resultsAll.length, 0);\n                db.destroy();\n            });","file":"unit/encryption.test.ts","skipped":false,"dir":"test"},{"name":"should have the same results on given data","suites":["event-reduce.test.js"],"updatePoint":{"line":79,"column":50},"line":79,"code":"    it('should have the same results on given data', async () => {\n        const queries: MangoQuery<any>[] = [\n            { selector: { age: { '$gt': 20 } }, sort: [{ passportId: 'asc' }] }\n        ];\n        const writeData = [\n            {\n                passportId: 's90j6hhznefj',\n                firstName: 'Freeman',\n                lastName: 'Rogahn',\n                age: 25\n            },\n            {\n                passportId: '6eu7byz49iq9',\n                firstName: 'Eugenia',\n                lastName: 'Dare',\n                age: 16\n            }\n        ];\n\n        const colNoEventReduce = await createCollection(false);\n        const colWithEventReduce = await createCollection(true);\n\n        await testQueryResultForEqualness(\n            colNoEventReduce,\n            colWithEventReduce,\n            queries\n        );\n\n        await Promise.all(\n            writeData\n                .map(async (docData) => {\n                    await colNoEventReduce.insert(docData);\n                    await colWithEventReduce.insert(docData);\n                })\n        );\n\n        await testQueryResultForEqualness(\n            colNoEventReduce,\n            colWithEventReduce,\n            queries\n        );\n\n        // update one so it must now be in query results\n        await Promise.all(\n            [\n                colNoEventReduce,\n                colWithEventReduce\n            ].map(async (col) => {\n                const docToUpdate = await col\n                    .findOne('6eu7byz49iq9')\n                    .exec(true);\n                await docToUpdate.atomicPatch({ age: 50 });\n            })\n        );\n\n        await testQueryResultForEqualness(\n            colNoEventReduce,\n            colWithEventReduce,\n            queries\n        );\n\n        colNoEventReduce.database.destroy();\n        colWithEventReduce.database.destroy();\n    });","file":"unit/event-reduce.test.ts","skipped":false,"dir":"test"},{"name":"should work with the key-compression plugin","suites":["event-reduce.test.js"],"updatePoint":{"line":144,"column":51},"line":144,"code":"    it('should work with the key-compression plugin', async () => {\n        const storage = wrappedKeyCompressionStorage({\n            storage: config.storage.getStorage()\n        });\n\n\n        const queries: MangoQuery<any>[] = [\n            { selector: { age: { '$gt': 10 } }, sort: [{ passportId: 'asc' }] },\n            { selector: { firstName: { $eq: 'Freeman' } }, sort: [{ passportId: 'asc' }] },\n            {\n                selector: {},\n                sort: [{ firstName: 'asc' }]\n            }\n        ];\n\n\n        const colNoEventReduce = await createCollection(false, storage, true);\n        const colWithEventReduce = await createCollection(true, storage, true);\n\n        await testQueryResultForEqualness(\n            colNoEventReduce,\n            colWithEventReduce,\n            queries\n        );\n\n        const writeData = [\n            {\n                passportId: 's90j6hhznefj-bbbbb',\n                firstName: 'bbbbb',\n                lastName: 'Rogahn',\n                age: 25\n            },\n            {\n                passportId: '6eu7byz49iq9-aaaa',\n                firstName: 'aaaaa',\n                lastName: 'Dare',\n                age: 16\n            }\n        ];\n        await Promise.all(\n            writeData\n                .map(async (docData) => {\n                    await colNoEventReduce.insert(docData);\n                    await colWithEventReduce.insert(docData);\n                })\n        );\n        await testQueryResultForEqualness(\n            colNoEventReduce,\n            colWithEventReduce,\n            queries\n        );\n\n\n        const insertForSortTest = {\n            passportId: 'for-sort-00000',\n            firstName: '00000',\n            lastName: 'Rogahn2',\n            age: 26\n        };\n        await colNoEventReduce.insert(insertForSortTest);\n        await colWithEventReduce.insert(insertForSortTest);\n        await testQueryResultForEqualness(\n            colNoEventReduce,\n            colWithEventReduce,\n            queries\n        );\n\n        colNoEventReduce.database.destroy();\n        colWithEventReduce.database.destroy();\n    });","file":"unit/event-reduce.test.ts","skipped":false,"dir":"test"},{"name":"random data: should have the same results as without event-reduce","suites":["event-reduce.test.js"],"updatePoint":{"line":221,"column":77},"line":221,"code":"        it('random data: should have the same results as without event-reduce', async () => {\n            const colNoEventReduce = await createCollection(false);\n            const colWithEventReduce = await createCollection(true);\n\n            const queries: MangoQuery[] = [\n                {\n                    selector: {},\n                    sort: [{\n                        passportId: 'asc'\n                    }]\n                },\n                {\n                    selector: {\n                        age: {\n                            $gt: 20\n                        }\n                    },\n                    // TODO it should also work without the sorting\n                    // because RxDB should add predicatble sort if primary not used in sorting\n                    sort: [{\n                        passportId: 'asc'\n                    }]\n                }\n\n            ];\n\n            await testQueryResultForEqualness(\n                colNoEventReduce,\n                colWithEventReduce,\n                queries\n            );\n\n            // add some\n            await Promise.all(\n                new Array(3)\n                    .fill(0)\n                    .map(async () => {\n                        const doc = schemaObjects.human();\n                        await colNoEventReduce.insert(doc);\n                        await colWithEventReduce.insert(doc);\n                    })\n            );\n\n            await testQueryResultForEqualness(\n                colNoEventReduce,\n                colWithEventReduce,\n                queries\n            );\n\n            // update one\n            await Promise.all(\n                [\n                    colNoEventReduce,\n                    colWithEventReduce\n                ].map(async (col) => {\n                    const docToUpdate = await col\n                        .findOne()\n                        .sort('lastName')\n                        .exec(true);\n                    await docToUpdate.atomicPatch({ age: 50 });\n                })\n            );\n\n            await testQueryResultForEqualness(\n                colNoEventReduce,\n                colWithEventReduce,\n                queries\n            );\n\n            // remove one\n            await Promise.all(\n                [\n                    colNoEventReduce,\n                    colWithEventReduce\n                ].map(async (col) => {\n                    const doc = await col\n                        .findOne()\n                        .sort('age')\n                        .exec(true);\n                    await doc.remove();\n                })\n            );\n\n            await testQueryResultForEqualness(\n                colNoEventReduce,\n                colWithEventReduce,\n                queries\n            );\n\n            // remove another one\n            await Promise.all(\n                [\n                    colNoEventReduce,\n                    colWithEventReduce\n                ].map(async (col) => {\n                    const doc = await col\n                        .findOne()\n                        .sort('age')\n                        .exec(true);\n                    await doc.remove();\n                })\n            );\n\n            await testQueryResultForEqualness(\n                colNoEventReduce,\n                colWithEventReduce,\n                queries\n            );\n\n            // clean up\n            colNoEventReduce.database.destroy();\n            colWithEventReduce.database.destroy();\n        });","file":"unit/event-reduce.test.ts","skipped":false,"dir":"test"},{"name":"should set a hook","suites":["get/set"],"updatePoint":{"line":22,"column":29},"line":22,"code":"        it('should set a hook', async () => {\n            const c = await humansCollection.create(0);\n            c.preSave(function () { }, false);\n            c.database.destroy();\n        });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should get a hook","suites":["get/set"],"updatePoint":{"line":27,"column":29},"line":27,"code":"        it('should get a hook', async () => {\n            const c = await humansCollection.create(0);\n            c.preSave(function () { }, false);\n            const hooks = c.getHooks('pre', 'save');\n            assert.ok(Array.isArray(hooks.series));\n            assert.strictEqual(hooks.series.length, 1);\n            c.database.destroy();\n        });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should get a parallel hook","suites":["get/set"],"updatePoint":{"line":35,"column":38},"line":35,"code":"        it('should get a parallel hook', async () => {\n            const c = await humansCollection.create(0);\n            c.preSave(function () { }, true);\n            const hooks = c.getHooks('pre', 'save');\n            assert.ok(Array.isArray(hooks.parallel));\n            assert.strictEqual(hooks.parallel.length, 1);\n            c.database.destroy();\n        });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"series","suites":["insert","pre","positive"],"updatePoint":{"line":47,"column":26},"line":47,"code":"                it('series', async () => {\n                    const c = await humansCollection.create(0);\n                    const human = schemaObjects.human();\n                    let count = 0;\n                    c.preInsert((data, instance) => {\n                        assert.strictEqual(typeof instance, 'undefined');\n                        count++;\n                    }, false);\n                    await c.insert(human);\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"parallel","suites":["insert","pre","positive"],"updatePoint":{"line":59,"column":28},"line":59,"code":"                it('parallel', async () => {\n                    const c = await humansCollection.create(0);\n                    const human = schemaObjects.human();\n                    let count = 0;\n                    c.preInsert(function (doc, instance) {\n                        assert.strictEqual(typeof instance, 'undefined');\n                        count++;\n                    }, false);\n                    let countp = 0;\n                    c.preInsert(function (doc, instance) {\n                        assert.strictEqual(typeof instance, 'undefined');\n                        countp++;\n                    }, true);\n                    await c.insert(human);\n                    assert.strictEqual(count, 1);\n                    assert.strictEqual(countp, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should save a modified document","suites":["insert","pre","positive"],"updatePoint":{"line":77,"column":51},"line":77,"code":"                it('should save a modified document', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n\n                    c.preInsert(function (d, instance) {\n                        assert.strictEqual(typeof instance, 'undefined');\n                        d.lastName = 'foobar';\n                    }, false);\n\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    assert.strictEqual(doc.get('lastName'), 'foobar');\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"async: should save a modified document","suites":["insert","pre","positive"],"updatePoint":{"line":91,"column":58},"line":91,"code":"                it('async: should save a modified document', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n\n                    c.preInsert(async function (d, instance) {\n                        assert.strictEqual(typeof instance, 'undefined');\n                        await promiseWait(10);\n                        d.lastName = 'foobar';\n                    }, false);\n\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    assert.strictEqual(doc.get('lastName'), 'foobar');\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should not insert if hook throws","suites":["insert","pre","positive"],"updatePoint":{"line":106,"column":52},"line":106,"code":"                it('should not insert if hook throws', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    c.preInsert(() => {\n                        throw new Error('foobar');\n                    }, false);\n\n                    let failC = 0;\n                    try {\n                        await c.insert(human);\n                    } catch (e) {\n                        failC++;\n                    }\n                    assert.strictEqual(failC, 1);\n                    const doc = await c.findOne(human.passportId).exec();\n                    assert.strictEqual(doc, null);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should have the collection bound to the this-scope","suites":["insert","pre","positive"],"updatePoint":{"line":124,"column":70},"line":124,"code":"                it('should have the collection bound to the this-scope', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    (c as any).foo = 'bar';\n                    let hasRun = false;\n                    c.preInsert(function (this: any) {\n                        hasRun = true;\n                        assert.strictEqual(this.foo, 'bar');\n                    }, false);\n\n                    await c.insert(schemaObjects.simpleHuman());\n\n                    assert.ok(hasRun);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"series","suites":["insert","post","positive"],"updatePoint":{"line":142,"column":26},"line":142,"code":"                it('series', async () => {\n                    const c = await humansCollection.create(0);\n                    const human = schemaObjects.human();\n                    let count = 0;\n                    c.postInsert(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, false);\n                    await c.insert(human);\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"parallel","suites":["insert","post","positive"],"updatePoint":{"line":154,"column":28},"line":154,"code":"                it('parallel', async () => {\n                    const c = await humansCollection.create(0);\n                    const human = schemaObjects.human();\n                    let count = 0;\n                    c.postInsert(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        assert.ok(data.age);\n                        count++;\n                    }, true);\n                    await c.insert(human);\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should call post insert hook after bulkInsert","suites":["insert","post","positive"],"updatePoint":{"line":167,"column":65},"line":167,"code":"                it('should call post insert hook after bulkInsert', async () => {\n                    const c = await humansCollection.create(0);\n                    const human = schemaObjects.human();\n                    let count = 0;\n                    c.postInsert((data, instance) => {\n                        assert.ok(data.age);\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, false);\n                    await c.bulkInsert([human]);\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"series","suites":["save","pre","positive"],"updatePoint":{"line":186,"column":26},"line":186,"code":"                it('series', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    let count = 0;\n                    c.preSave(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, false);\n                    await doc.atomicPatch({ firstName: 'foobar' });\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"parallel","suites":["save","pre","positive"],"updatePoint":{"line":200,"column":28},"line":200,"code":"                it('parallel', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    let count = 0;\n                    c.preSave(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, true);\n                    await doc.atomicPatch({ firstName: 'foobar' });\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should save a modified document","suites":["save","pre","positive"],"updatePoint":{"line":214,"column":51},"line":214,"code":"                it('should save a modified document', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n\n                    let hasRun = false;\n                    c.preSave(function () {\n                        hasRun = true;\n                    }, false);\n\n                    await doc.atomicPatch({ firstName: 'foobar' });\n                    assert.ok(hasRun);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"async: should save a modified document","suites":["save","pre","positive"],"updatePoint":{"line":229,"column":58},"line":229,"code":"                it('async: should save a modified document', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n\n                    let hasRun = false;\n                    c.preSave(async function () {\n                        await promiseWait(10);\n                        hasRun = true;\n                    }, false);\n                    await doc.atomicPatch({ firstName: 'foobar' });\n                    assert.ok(hasRun);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should not save if hook throws","suites":["save","pre","positive"],"updatePoint":{"line":244,"column":50},"line":244,"code":"                it('should not save if hook throws', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    human.firstName = 'test';\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n\n                    c.preSave(function () {\n                        throw new Error('fail');\n                    }, false);\n\n                    let failC = 0;\n                    try {\n                        await doc.atomicPatch({ firstName: 'foobar' });\n                    } catch (e) {\n                        failC++;\n                    }\n                    assert.strictEqual(failC, 1);\n                    const syncValue = await (doc as any).firstName$.pipe(first()).toPromise();\n                    assert.strictEqual(syncValue, 'test');\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"series","suites":["save","post","positive"],"updatePoint":{"line":270,"column":26},"line":270,"code":"                it('series', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    let count = 0;\n                    c.postSave(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, false);\n                    await doc.atomicPatch({ firstName: 'foobar' });\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"parallel","suites":["save","post","positive"],"updatePoint":{"line":284,"column":28},"line":284,"code":"                it('parallel', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    let count = 0;\n                    c.postSave(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, true);\n                    await doc.atomicPatch({ firstName: 'foobar' });\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"series","suites":["remove","pre","positive"],"updatePoint":{"line":305,"column":26},"line":305,"code":"                it('series', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    let count = 0;\n                    c.preRemove(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, false);\n                    await doc.remove();\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"parallel","suites":["remove","pre","positive"],"updatePoint":{"line":319,"column":28},"line":319,"code":"                it('parallel', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    let count = 0;\n                    c.preRemove(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, true);\n                    await doc.remove();\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should not remove if hook throws","suites":["remove","pre","positive"],"updatePoint":{"line":333,"column":52},"line":333,"code":"                it('should not remove if hook throws', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n\n                    c.preRemove(function () {\n                        throw new Error('fail');\n                    }, false);\n\n                    let failC = 0;\n                    try {\n                        await doc.remove();\n                    } catch (e) {\n                        failC++;\n                    }\n                    assert.strictEqual(failC, 1);\n                    const doc2 = await c.findOne(human.passportId).exec(true);\n                    assert.strictEqual(doc2.get('passportId'), human.passportId);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should call pre remove hook before bulkRemove","suites":["remove","pre","positive"],"updatePoint":{"line":354,"column":65},"line":354,"code":"                it('should call pre remove hook before bulkRemove', async () => {\n                    const c = await humansCollection.create(5);\n                    const docList = await c.find().exec();\n                    const primaryList = docList.map(doc => doc.primary);\n\n                    let count = 0;\n                    c.preRemove((data, instance) => {\n                        assert.ok(isRxDocument(instance));\n                        assert.ok(data.age);\n                        count++;\n                    }, true);\n\n                    await c.bulkRemove(primaryList);\n                    assert.strictEqual(count, 5);\n\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should keep the field value that was added by the hook","suites":["remove","pre","positive"],"updatePoint":{"line":371,"column":74},"line":371,"code":"                it('should keep the field value that was added by the hook', async () => {\n                    const c = await humansCollection.create(5);\n                    const firstDoc = await c.findOne().exec(true);\n\n                    const emitted: RxChangeEvent<any>[] = [];\n                    c.$.subscribe(event => emitted.push(event));\n\n                    c.preRemove((data) => {\n                        data.lastName = 'by-hook';\n                        return data;\n                    }, true);\n                    await firstDoc.remove();\n\n                    // check in storage\n                    const docInStorage = await c.storageInstance.findDocumentsById([firstDoc.primary], true);\n                    assert.strictEqual(docInStorage[firstDoc.primary].lastName, 'by-hook');\n\n                    // check the emitted event\n                    const ev = emitted[0];\n                    assert.strictEqual(ev.documentData.lastName, 'by-hook');\n\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"series","suites":["remove","post","positive"],"updatePoint":{"line":399,"column":26},"line":399,"code":"                it('series', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    let count = 0;\n                    c.postRemove(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, false);\n                    await doc.remove();\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"parallel","suites":["remove","post","positive"],"updatePoint":{"line":413,"column":28},"line":413,"code":"                it('parallel', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const human = schemaObjects.simpleHuman();\n                    await c.insert(human);\n                    const doc = await c.findOne(human.passportId).exec(true);\n                    let count = 0;\n                    c.postRemove(function (data, instance) {\n                        assert.ok(isRxDocument(instance));\n                        count++;\n                    }, true);\n                    await doc.remove();\n                    assert.strictEqual(count, 1);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should have the collection bound to the this-scope","suites":["remove","post","positive"],"updatePoint":{"line":427,"column":70},"line":427,"code":"                it('should have the collection bound to the this-scope', async () => {\n                    const c = await humansCollection.createPrimary(1);\n                    (c as any).foo2 = 'bar2';\n                    let hasRun = false;\n\n                    c.postRemove(function (this: any) {\n                        hasRun = true;\n                        assert.strictEqual(this.foo2, 'bar2');\n                    }, true);\n\n                    const doc = await c.findOne().exec(true);\n                    await doc.remove();\n\n                    assert.ok(hasRun);\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should call post remove hook after bulkRemove","suites":["remove","post","positive"],"updatePoint":{"line":443,"column":65},"line":443,"code":"                it('should call post remove hook after bulkRemove', async () => {\n                    const c = await humansCollection.create(5);\n                    const docList = await c.find().exec();\n                    const primaryList = docList.map(doc => doc.primary);\n\n                    let count = 0;\n                    c.postRemove((data, instance) => {\n                        assert.ok(isRxDocument(instance));\n                        assert.ok(data.age);\n                        count++;\n                    }, true);\n                    await c.bulkRemove(primaryList);\n                    assert.strictEqual(count, 5);\n\n                    c.database.destroy();\n                });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should define a getter","suites":["postCreate","positive"],"updatePoint":{"line":465,"column":38},"line":465,"code":"            it('should define a getter', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    multiInstance: true\n                });\n                const collections = await db.addCollections({\n                    myhumans: {\n                        schema: schemas.primaryHuman\n                    }\n                });\n                const collection = collections.myhumans;\n                collection.postCreate(function (_data, instance) {\n                    assert.ok(isRxDocument(instance));\n                    Object.defineProperty(instance, 'myField', {\n                        get: () => 'foobar',\n                    });\n                });\n\n                const human = schemaObjects.simpleHuman();\n                await collection.insert(human);\n                const doc = await collection.findOne().exec();\n                assert.strictEqual('foobar', doc.myField);\n\n                db.destroy();\n            });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should throw when adding an async-hook","suites":["postCreate","negative"],"updatePoint":{"line":493,"column":54},"line":493,"code":"            it('should throw when adding an async-hook', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    multiInstance: true\n                });\n                const collections = await db.addCollections({\n                    myhumans: {\n                        schema: schemas.primaryHuman\n                    }\n                });\n                const collection = collections.myhumans;\n\n                const hookFun = function (doc: any) {\n                    Object.defineProperty(doc, 'myField', {\n                        get: () => 'foobar',\n                    });\n                };\n\n                assert.throws(() => (collection as any).postCreate(hookFun, true));\n                db.destroy();\n            });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"ISSUE #158 : Throwing error in async preInsert does not prevent insert","suites":["issues"],"updatePoint":{"line":518,"column":82},"line":518,"code":"        it('ISSUE #158 : Throwing error in async preInsert does not prevent insert', async () => {\n            const c = await humansCollection.create(0);\n            c.preInsert(async function () {\n                await promiseWait(1);\n                throw new Error('This throw should prevent the insert');\n            }, false);\n            let hasThrown = false;\n            try {\n                await c.insert(schemaObjects.human());\n            } catch (e) {\n                hasThrown = true;\n            }\n            assert.ok(hasThrown);\n            await promiseWait(10);\n            const allDocs = await c.find().exec();\n            assert.strictEqual(allDocs.length, 0);\n            c.database.destroy();\n        });","file":"unit/hooks.test.ts","skipped":false,"dir":"test"},{"name":"should be able to call queue on database","suites":["integration"],"updatePoint":{"line":9,"column":52},"line":9,"code":"        it('should be able to call queue on database', async () => {\n            const c = await humansCollection.create(0);\n            await c.database.requestIdlePromise();\n            c.database.destroy();\n        });","file":"unit/idle-queue.test.ts","skipped":false,"dir":"test"},{"name":"inserts should always be faster than idle-call","suites":["integration"],"updatePoint":{"line":14,"column":58},"line":14,"code":"        it('inserts should always be faster than idle-call', async () => {\n            const c = await humansCollection.create(0);\n            const data = new Array(10).fill(0).map(() => schemaObjects.human());\n            const order: any[] = [];\n\n            Promise.all(data.map(\n                doc => c.insert(doc)\n            )).then(() => order.push(0));\n            c.database.requestIdlePromise().then(() => order.push(1));\n\n            await AsyncTestUtil.waitUntil(() => order.length === 2);\n            assert.deepStrictEqual(order, [0, 1]);\n\n            c.database.destroy();\n        });","file":"unit/idle-queue.test.ts","skipped":false,"dir":"test"},{"name":"export the collection","suites":["Collection",".exportJSON()"],"updatePoint":{"line":27,"column":37},"line":27,"code":"            it('export the collection', async () => {\n                const col = await humansCollection.create(5);\n                const json = await col.exportJSON();\n                assert.strictEqual(json.name, 'human');\n                assert.strictEqual(typeof json.schemaHash, 'string');\n                assert.strictEqual(json.docs.length, 5);\n                json.docs.map(doc => assert.strictEqual(typeof doc, 'object'));\n                col.database.destroy();\n            });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"export encrypted as decrypted","suites":["Collection",".exportJSON()"],"updatePoint":{"line":36,"column":45},"line":36,"code":"            it('export encrypted as decrypted', async () => {\n                const db = await createRxDatabase<{ enchuman: RxCollection<schemaObjects.EncryptedObjectHumanDocumentType> }>({\n                    name: randomCouchString(10),\n                    storage: wrappedKeyEncryptionStorage({\n                        storage: config.storage.getStorage()\n                    }),\n                    password: randomCouchString(10)\n                });\n                const cols = await db.addCollections({\n                    enchuman: {\n                        schema: schemas.encryptedObjectHuman\n                    }\n                });\n                const col = cols.enchuman;\n\n                const fns = [];\n                for (let i = 0; i < 10; i++)\n                    fns.push(col.insert(schemaObjects.encryptedObjectHuman()));\n                await Promise.all(fns);\n\n                const json = await col.exportJSON();\n                assert.strictEqual(json.docs.length, 10);\n                json.docs.map(doc => {\n                    assert.strictEqual(typeof doc.secret, 'object');\n                    assert.strictEqual(typeof doc.secret.name, 'string');\n                    assert.strictEqual(typeof doc.secret.subname, 'string');\n                });\n                db.destroy();\n            });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"import json","suites":["Collection",".importJSON()","positive"],"updatePoint":{"line":68,"column":31},"line":68,"code":"                it('import json', async () => {\n                    const col = await humansCollection.createMultiInstance(\n                        randomCouchString(10),\n                        5\n                    );\n                    const json = await col.exportJSON();\n                    const emptyCol = await humansCollection.createMultiInstance(\n                        randomCouchString(10),\n                        0\n                    );\n                    const noDocs = await emptyCol.find().exec();\n                    assert.strictEqual(noDocs.length, 0);\n\n                    await emptyCol.importJSON(json);\n                    const docs = await emptyCol.find().exec();\n                    assert.strictEqual(docs.length, 5);\n\n                    col.database.destroy();\n                    emptyCol.database.destroy();\n                });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"should not import if schema is different","suites":["Collection",".importJSON()","negative"],"updatePoint":{"line":90,"column":60},"line":90,"code":"                it('should not import if schema is different', async () => {\n                    const col = await humansCollection.createMultiInstance('pref1', 5);\n                    const json = await col.exportJSON();\n                    const differentSchemaCol = await humansCollection.createNested();\n                    await AsyncTestUtil.assertThrows(\n                        // Explicitly typed as any because TS will catch this error\n                        () => differentSchemaCol.importJSON(json as any),\n                        'RxError'\n                    );\n                    col.database.destroy();\n                    differentSchemaCol.database.destroy();\n                });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"should export a valid dump","suites":["Database",".exportJSON()"],"updatePoint":{"line":107,"column":42},"line":107,"code":"            it('should export a valid dump', async () => {\n                const col = await humansCollection.createMultiInstance(randomCouchString(10), 5);\n                const json = await col.database.exportJSON();\n\n                assert.strictEqual(typeof json.name, 'string');\n                assert.strictEqual(typeof json.instanceToken, 'string');\n                assert.strictEqual(typeof json.collections, 'object');\n                assert.strictEqual(json.collections.length, 1);\n\n                const colDump = json.collections[0];\n                assert.strictEqual(colDump.name, 'human');\n                assert.strictEqual(typeof colDump.schemaHash, 'string');\n                assert.strictEqual(colDump.docs.length, 5);\n                colDump.docs.map((doc: any) => assert.strictEqual(typeof doc, 'object'));\n                col.database.destroy();\n            });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"export encrypted as decrypted","suites":["Database",".exportJSON()"],"updatePoint":{"line":123,"column":45},"line":123,"code":"            it('export encrypted as decrypted', async () => {\n                const db = await createRxDatabase<{ enchuman: RxCollection<schemaObjects.EncryptedObjectHumanDocumentType> }>({\n                    name: randomCouchString(10),\n                    storage: wrappedKeyEncryptionStorage({\n                        storage: config.storage.getStorage()\n                    }),\n                    password: randomCouchString(10)\n                });\n                const cols = await db.addCollections({\n                    enchuman: {\n                        schema: schemas.encryptedObjectHuman\n                    }\n                });\n                const col = cols.enchuman;\n                await Promise.all(\n                    new Array(10).fill(0)\n                        .map(() => col.insert(schemaObjects.encryptedObjectHuman()))\n                );\n                const json = await db.exportJSON();\n\n                json.collections[0].docs\n                    .forEach(docData => {\n                        assert.strictEqual(typeof docData.secret, 'object');\n                        assert.strictEqual(typeof docData.secret.name, 'string');\n                        assert.strictEqual(typeof docData.secret.subname, 'string');\n                    });\n                db.destroy();\n            });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"export with multiple collections","suites":["Database",".exportJSON()"],"updatePoint":{"line":151,"column":48},"line":151,"code":"            it('export with multiple collections', async () => {\n                const db = await createRxDatabase<{ enchuman: RxCollection<schemaObjects.EncryptedObjectHumanDocumentType> }>({\n                    name: randomCouchString(10),\n                    storage: wrappedKeyEncryptionStorage({\n                        storage: config.storage.getStorage()\n                    }),\n                    password: randomCouchString(10)\n                });\n                const cols = await db.addCollections({\n                    enchuman: {\n                        schema: schemas.encryptedObjectHuman\n                    }\n                });\n                const col = cols.enchuman;\n                const cols2 = await db.addCollections({\n                    enchuman2: {\n                        schema: schemas.encryptedObjectHuman\n                    }\n                });\n                const col2 = cols2.enchuman2;\n\n                const fns = [];\n                for (let i = 0; i < 10; i++) {\n                    fns.push(col.insert(schemaObjects.encryptedObjectHuman()));\n                    fns.push(col2.insert(schemaObjects.encryptedObjectHuman()));\n                }\n                await Promise.all(fns);\n\n                const json = await col.database.exportJSON();\n                assert.strictEqual(json.collections.length, 2);\n                json.collections\n                    .forEach((c: any) => assert.strictEqual(c.docs.length, 10));\n                db.destroy();\n            });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"export 1 of 2 collections","suites":["Database",".exportJSON()"],"updatePoint":{"line":185,"column":41},"line":185,"code":"            it('export 1 of 2 collections', async () => {\n                const db = await createRxDatabase<{ enchuman: RxCollection<schemaObjects.EncryptedObjectHumanDocumentType> }>({\n                    name: randomCouchString(10),\n                    storage: wrappedKeyEncryptionStorage({\n                        storage: config.storage.getStorage()\n                    }),\n                    password: randomCouchString(10)\n                });\n                const cols = await db.addCollections({\n                    enchuman: {\n                        schema: schemas.encryptedObjectHuman\n                    },\n                    enchuman2: {\n                        schema: schemas.encryptedObjectHuman\n                    }\n                });\n                const col = cols.enchuman;\n                const col2 = cols.enchuman2;\n\n                const fns = [];\n                for (let i = 0; i < 10; i++) {\n                    fns.push(col.insert(schemaObjects.encryptedObjectHuman()));\n                    fns.push(col2.insert(schemaObjects.encryptedObjectHuman()));\n                }\n                await Promise.all(fns);\n\n                const json = await col.database.exportJSON(['enchuman']);\n                assert.strictEqual(json.collections.length, 1);\n                json.collections\n                    .forEach((c: any) => assert.strictEqual(c.docs.length, 10));\n                db.destroy();\n            });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"import dump","suites":["Database",".importJSON()","positive"],"updatePoint":{"line":220,"column":31},"line":220,"code":"                it('import dump', async () => {\n                    const col = await humansCollection.create(5);\n                    const db = col.database;\n                    const json = await db.exportJSON();\n\n                    const col2 = await humansCollection.create(0);\n                    const db2 = col2.database;\n                    await db2.importJSON(json);\n\n                    const docs = await col2.find().exec();\n                    assert.strictEqual(docs.length, 5);\n                    db.destroy();\n                    db2.destroy();\n                });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"should not import if schema is different","suites":["Database",".importJSON()","negative"],"updatePoint":{"line":236,"column":60},"line":236,"code":"                it('should not import if schema is different', async () => {\n\n                    const db = await createRxDatabase<{ human: RxCollection<HumanDocumentType> }>({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                        password: null,\n                        multiInstance: true\n                    });\n                    const cols = await db.addCollections({\n                        human: {\n                            schema: schemas.human\n                        }\n                    });\n                    const col = cols.human;\n\n                    const db2 = await createRxDatabase<{ human: RxCollection<schemaObjects.NestedHumanDocumentType> }>({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                        password: null,\n                        multiInstance: true\n                    });\n                    const cols2 = await db2.addCollections({\n                        human: {\n                            schema: schemas.nestedHuman\n                        }\n                    });\n                    const col2 = cols2.human;\n\n                    const fns = [];\n                    for (let i = 0; i < 5; i++) {\n                        fns.push(col.insert(schemaObjects.human()));\n                    }\n                    await Promise.all(fns);\n\n                    const json = await db.exportJSON();\n                    await AsyncTestUtil.assertThrows(\n                        // Explicitly typed as any because TS will catch this error\n                        () => db2.importJSON(json as any),\n                        'RxError'\n                    );\n\n                    const docs = await col2.find().exec();\n                    assert.strictEqual(docs.length, 0);\n\n                    db.destroy();\n                    db2.destroy();\n                });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"#319 collections must be created before importDump","suites":["issues"],"updatePoint":{"line":287,"column":62},"line":287,"code":"        it('#319 collections must be created before importDump', async () => {\n            const docSchema = {\n                name: 'demo',\n                version: 0,\n                primaryKey: 'firstName',\n                type: 'object',\n                properties: {\n                    firstName: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    time: {\n                        type: 'string'\n                    }\n                }\n            };\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage(),\n            });\n            const db2 = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage(),\n            });\n            const cols = await db.addCollections({\n                demo: {\n                    schema: docSchema\n                }\n            });\n            const col = cols.demo;\n            await col.insert({\n                firstName: 'nnnn'\n            });\n            const json = await db.exportJSON();\n\n            // should throw when the collection does not exist\n            await AsyncTestUtil.assertThrows(\n                () => db2.importJSON(json),\n                'RxError',\n                'create the collections'\n            );\n\n            // should work when the collection exists\n            const cols2 = await db2.addCollections({\n                demo: {\n                    schema: docSchema\n                }\n            });\n            const col2 = cols2.demo;\n            await db2.importJSON(json);\n            const docs = await col2.find().exec();\n            assert.strictEqual(docs.length, 1);\n\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"#1396 import/export should work with attachments","suites":["issues"],"updatePoint":{"line":343,"column":60},"line":343,"code":"        it('#1396 import/export should work with attachments', async () => {\n            if (!config.storage.hasAttachments) {\n                return;\n            }\n            const sourceCol = await humansCollection.createAttachments(1);\n            const doc = await sourceCol.findOne().exec(true);\n            await doc.putAttachment({\n                id: 'cat.txt',\n                data: blobBufferUtil.createBlobBuffer('meow', 'text/plain'),\n                type: 'text/plain'\n            });\n            const json = await sourceCol.exportJSON();\n\n            const destCol = await humansCollection.createAttachments(0);\n\n            const noDocs = await destCol.find().exec();\n            assert.strictEqual(noDocs.length, 0);\n\n            // this line triggers an error\n            await destCol.importJSON(json);\n\n            const docs = await destCol.find().exec();\n            assert.strictEqual(docs.length, 1);\n\n            const importedDoc = await destCol.findOne().exec();\n            assert.ok(importedDoc);\n\n            sourceCol.database.destroy();\n            destCol.database.destroy();\n        });","file":"unit/import-export.test.ts","skipped":false,"dir":"test"},{"name":"clear BroadcastChannel tmp folder","suites":["init.test.js"],"updatePoint":{"line":70,"column":41},"line":70,"code":"    it('clear BroadcastChannel tmp folder', async () => {\n        await clearNodeFolder();\n    });","file":"unit/init.test.ts","skipped":false,"dir":"test"},{"name":"positive","suites":[],"updatePoint":{"line":14,"column":16},"line":14,"code":"    it('positive', async () => {\n        const c = await humansCollection.create(1);\n        const query = c.findOne();\n        const doc = await query.exec();\n        assert.ok(isRxDatabase(c.database));\n        assert.ok(isRxCollection(c));\n        assert.ok(isRxQuery(query));\n        assert.ok(isRxDocument(doc));\n        assert.ok(isRxSchema(c.schema));\n\n        c.database.destroy();\n    });","file":"unit/instance-of-check.test.ts","skipped":false,"dir":"test"},{"name":"negative","suites":[],"updatePoint":{"line":26,"column":16},"line":26,"code":"    it('negative', () => {\n        const anyObj = {};\n        assert.strictEqual(false, isRxDatabase(anyObj));\n        assert.strictEqual(false, isRxCollection(anyObj));\n        assert.strictEqual(false, isRxQuery(anyObj));\n        assert.strictEqual(false, isRxDocument(anyObj));\n        assert.strictEqual(false, isRxSchema(anyObj));\n    });","file":"unit/instance-of-check.test.ts","skipped":false,"dir":"test"},{"name":"transform basic search keys","suites":[".getPreparedQuery()"],"updatePoint":{"line":49,"column":39},"line":49,"code":"        it('transform basic search keys', async () => {\n            const c = await getCollection();\n            const query: any = c.find()\n                .where('firstName').eq('myFirstName')\n                .getPreparedQuery();\n            const jsonString = JSON.stringify(query);\n            assert.ok(!jsonString.includes('firstName'));\n            assert.ok(jsonString.includes('myFirstName'));\n            c.database.destroy();\n        });","file":"unit/key-compression.test.ts","skipped":false,"dir":"test"},{"name":"additional attribute","suites":[".getPreparedQuery()"],"updatePoint":{"line":59,"column":32},"line":59,"code":"        it('additional attribute', async () => {\n            if (config.storage.name !== 'pouchdb') {\n                return;\n            }\n            const c = await getCollection();\n            const query: any = c.find()\n                .where('age').eq(5)\n                .getPreparedQuery();\n\n            assert.deepStrictEqual(query.selector.age, { $eq: 5 });\n            c.database.destroy();\n        });","file":"unit/key-compression.test.ts","skipped":false,"dir":"test"},{"name":"should have saved a compressed document","suites":["integration into pouchDB"],"updatePoint":{"line":73,"column":51},"line":73,"code":"        it('should have saved a compressed document', async () => {\n            if (config.storage.name !== 'pouchdb') {\n                return;\n            }\n\n            const c = await getCollection();\n            const docData = schemaObjects.simpleHuman();\n            await c.insert(docData);\n\n            const pouchDoc = await c.internalStorageInstance.internals.pouch.get(docData.passportId);\n            const doc = pouchDocumentDataToRxDocumentData<SimpleHumanDocumentType>(c.schema.primaryPath as any, pouchDoc);\n            Object.keys(doc)\n                .filter(key => !key.startsWith('_'))\n                .filter(key => key !== c.schema.primaryPath)\n                .forEach(key => {\n                    assert.ok(key.length <= 3);\n                    assert.strictEqual(typeof (doc as any)[key], 'string');\n                });\n            assert.strictEqual((doc as any)[c.schema.primaryPath], docData.passportId);\n            assert.strictEqual((doc as any)['|a'], docData.firstName);\n            c.database.destroy();\n        });","file":"unit/key-compression.test.ts","skipped":false,"dir":"test"},{"name":"should properly run the compressed query","suites":["query"],"updatePoint":{"line":97,"column":52},"line":97,"code":"        it('should properly run the compressed query', async () => {\n            const col = await getCollection();\n            assert.ok(col.schema.jsonSchema.keyCompression);\n\n            // add one matching and one non-matching doc\n            await col.bulkInsert([\n                {\n                    firstName: 'aaa',\n                    lastName: 'aaa',\n                    passportId: 'aaa',\n                    age: 0\n                },\n                {\n                    firstName: 'bbb',\n                    lastName: 'bbb',\n                    passportId: 'bbb',\n                    age: 0\n                }\n            ]);\n            const query = col.find({\n                selector: {\n                    firstName: {\n                        $ne: 'aaa'\n                    }\n                }\n            });\n            const docs = await query.exec();\n            const doc = docs[0];\n            if (!doc) {\n                throw new Error('doc missing');\n            }\n\n            assert.strictEqual(doc.passportId, 'bbb');\n\n            col.database.destroy();\n        });","file":"unit/key-compression.test.ts","skipped":false,"dir":"test"},{"name":"#50 compress string array properly","suites":["issues"],"updatePoint":{"line":135,"column":46},"line":135,"code":"        it('#50 compress string array properly', async () => {\n            const mySchema: RxJsonSchema<{ likes: any[], id: string }> = {\n                title: 'hero schema',\n                version: 0,\n                description: 'describes a simple hero',\n                primaryKey: 'id',\n                required: [\n                    'id'\n                ],\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    likes: {\n                        type: 'array',\n                        items: {\n                            type: 'string'\n                        }\n                    }\n                }\n            };\n\n            const db = await createRxDatabase({\n                name: 'heroesdb',\n                storage: config.storage.getStorage()\n            });\n            const collections = await db.addCollections({\n                mycollection: {\n                    schema: mySchema\n                }\n            });\n            const collection = collections.mycollection;\n            const docData = {\n                id: randomCouchString(12),\n                likes: ['abc', '8']\n            };\n            await collection.insert(docData);\n            const doc = await collection.findOne().exec();\n            assert.ok(isRxDocument(doc));\n            assert.deepStrictEqual(doc.likes, docData.likes);\n            db.destroy();\n        });","file":"unit/key-compression.test.ts","skipped":false,"dir":"test"},{"name":"error on nested null","suites":["issues"],"updatePoint":{"line":179,"column":32},"line":179,"code":"        it('error on nested null', async () => {\n            const mySchema = {\n                title: 'hero schema',\n                version: 0,\n                description: 'describes a simple hero',\n                primaryKey: 'key',\n                required: ['key'],\n                type: 'object',\n                properties: {\n                    key: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    nested: {\n                        type: 'object'\n                    }\n                }\n            };\n\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage()\n            });\n            const collections = await db.addCollections({\n                mycollection: {\n                    schema: mySchema\n                }\n            });\n            const collection = collections.mycollection;\n\n            const docData = {\n                key: 'foobar',\n                nested: {\n                    lastProvider: null,\n                    providers: 0,\n                    sync: false,\n                    other: {}\n                }\n            };\n            await collection.insert(docData);\n\n            db.destroy();\n        });","file":"unit/key-compression.test.ts","skipped":false,"dir":"test"},{"name":"query over compressed index","suites":["issues"],"updatePoint":{"line":227,"column":39},"line":227,"code":"        it('query over compressed index', async () => {\n            type RxMessageDocumentType = {\n                id: string;\n                text: string;\n                createdAt: number;\n                read: boolean;\n                sender: string;\n                reciever: string;\n            };\n            const schema: RxJsonSchema<RxMessageDocumentType> = {\n                title: 'messages schema',\n                description: 'describes a message',\n                version: 0,\n                keyCompression: true,\n                primaryKey: 'id',\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 40\n                    },\n                    text: {\n                        type: 'string'\n                    },\n                    createdAt: {\n                        type: 'number',\n                        minimum: 0,\n                        maximum: 100000000000000,\n                        multipleOf: 1\n                    },\n                    read: {\n                        description: 'true if was read by the reciever',\n                        type: 'boolean'\n                    },\n                    sender: {\n                        type: 'string',\n                        ref: 'users',\n                        maxLength: 40\n                    },\n                    reciever: {\n                        type: 'string',\n                        ref: 'users',\n                        maxLength: 40\n                    }\n                },\n                indexes: [\n                    'createdAt'\n                ],\n                required: [\n                    'text',\n                    'createdAt',\n                    'read',\n                    'sender',\n                    'reciever'\n                ]\n            };\n\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: wrappedKeyCompressionStorage({\n                    storage: config.storage.getStorage()\n                })\n            });\n\n            const collections = await db.addCollections({\n                messages: {\n                    schema\n                }\n            });\n            const collection: RxCollection<RxMessageDocumentType> = collections.messages;\n            await collection.insert({\n                id: 'xxx',\n                text: 'foobar',\n                createdAt: 100,\n                read: false,\n                sender: 'a',\n                reciever: 'b'\n            });\n            const query = collection.findOne({\n                selector: {\n                    $or: [\n                        {\n                            sender: 'a',\n                            reciever: 'b'\n                        },\n                        {\n                            sender: 'b',\n                            reciever: 'a'\n                        }\n                    ]\n                },\n                sort: [\n                    { createdAt: 'asc' },\n                    { id: 'asc' }\n                ]\n            });\n\n\n            const result = await query.exec(true);\n            assert.strictEqual(result.id, 'xxx');\n            db.destroy();\n        });","file":"unit/key-compression.test.ts","skipped":false,"dir":"test"},{"name":"ensure every db is cleaned up","suites":[],"updatePoint":{"line":19,"column":37},"line":19,"code":"    it('ensure every db is cleaned up', () => {\n        assert.strictEqual(dbCount(), 0);\n    });","file":"unit/last.test.ts","skipped":false,"dir":"test"},{"name":"ensure every PouchDB storage instance is cleaned up","suites":[],"updatePoint":{"line":22,"column":59},"line":22,"code":"    it('ensure every PouchDB storage instance is cleaned up', async () => {\n        try {\n            // for performance, we do not await db closing, so it might take some time\n            // until everything is closed.\n            await waitUntil(() => {\n                return OPEN_POUCHDB_STORAGE_INSTANCES.size === 0;\n            }, 5 * 1000);\n        } catch (err) {\n            console.dir(OPEN_POUCHDB_STORAGE_INSTANCES);\n            throw new Error('no all PouchDB storage instances have been closed (open: ' + OPEN_POUCHDB_STORAGE_INSTANCES.size + ')');\n        }\n    });","file":"unit/last.test.ts","skipped":false,"dir":"test"},{"name":"ensure every PouchDB database is removed","suites":[],"updatePoint":{"line":34,"column":48},"line":34,"code":"    it('ensure every PouchDB database is removed', async () => {\n        try {\n            // for performance, we do not await db closing, so it might take some time\n            // until everything is closed.\n            await waitUntil(() => {\n                return OPEN_POUCH_INSTANCES.size === 0;\n            }, 5 * 1000);\n        } catch (err) {\n            console.dir(OPEN_POUCH_INSTANCES);\n            throw new Error('no all pouch instances have been closed');\n        }\n    });","file":"unit/last.test.ts","skipped":false,"dir":"test"},{"name":"ensure all BroadcastChannels are closed","suites":[],"updatePoint":{"line":46,"column":47},"line":46,"code":"    it('ensure all BroadcastChannels are closed', async () => {\n        try {\n            await waitUntil(() => {\n                return BROADCAST_CHANNEL_BY_TOKEN.size === 0;\n            }, 5 * 1000);\n        } catch (err) {\n            const openChannelKeys = Array.from(BROADCAST_CHANNEL_BY_TOKEN.keys());\n            console.log('open broadcast channel tokens:');\n            console.log(openChannelKeys.join(', '));\n            throw new Error('not all broadcast channels have been closed (' + openChannelKeys.length + ')');\n        }\n    });","file":"unit/last.test.ts","skipped":false,"dir":"test"},{"name":"ensure all websockets have been closed","suites":[],"updatePoint":{"line":58,"column":46},"line":58,"code":"    it('ensure all websockets have been closed', async () => {\n        try {\n            await waitUntil(() => {\n                return GRAPHQL_WEBSOCKET_BY_URL.size === 0;\n            }, 5 * 1000);\n        } catch (err) {\n            const openSocketUrls = Array.from(GRAPHQL_WEBSOCKET_BY_URL.keys());\n            console.log('open graphql websockets:');\n            console.log(openSocketUrls.join(', '));\n            throw new Error('not all graphql websockets have been closed (' + openSocketUrls.length + ')');\n        }\n    });","file":"unit/last.test.ts","skipped":false,"dir":"test"},{"name":"other instance applies on death of leader","suites":["leader-election.test.js"],"updatePoint":{"line":26,"column":53},"line":26,"code":"        it('other instance applies on death of leader', async () => {\n            const name = randomCouchString(10);\n            const c = await humansCollection.createMultiInstance(name);\n            const leaderElector = c.database.leaderElector();\n\n            await c.database.waitForLeadership();\n            await leaderElector.die();\n\n            const c2 = await humansCollection.createMultiInstance(name);\n            await c2.database.waitForLeadership();\n\n            c.database.destroy();\n            c2.database.destroy();\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"a single instance should always elect itself as leader","suites":["leader-election.test.js","election"],"updatePoint":{"line":43,"column":66},"line":43,"code":"        it('a single instance should always elect itself as leader', async () => {\n            const c1 = await humansCollection.createMultiInstance(randomCouchString(10));\n            const db1 = c1.database;\n            await db1.waitForLeadership();\n            c1.database.destroy();\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"should not elect as leader if other instance is leader","suites":["leader-election.test.js","election"],"updatePoint":{"line":49,"column":66},"line":49,"code":"        it('should not elect as leader if other instance is leader', async () => {\n            const name = randomCouchString(10);\n            const c1 = await humansCollection.createMultiInstance(name);\n            const c2 = await humansCollection.createMultiInstance(name);\n            const db1 = c1.database;\n            const db2 = c2.database;\n\n            await db1.waitForLeadership();\n            await AsyncTestUtil.wait(150);\n            assert.strictEqual(db2.isLeader(), false);\n\n            c1.database.destroy();\n            c2.database.destroy();\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"when 2 instances apply at the same time, one should win","suites":["leader-election.test.js","election"],"updatePoint":{"line":63,"column":67},"line":63,"code":"        it('when 2 instances apply at the same time, one should win', async () => {\n            if (!config.platform.isNode()) return;\n\n            // run often\n            let tries = 0;\n            while (tries < 3) {\n                tries++;\n                const name = randomCouchString(10);\n                const c1 = await humansCollection.createMultiInstance(name);\n                const c2 = await humansCollection.createMultiInstance(name);\n                const le1 = c1.database.leaderElector();\n                const le2 = c2.database.leaderElector();\n\n                c1.database.waitForLeadership();\n                c2.database.waitForLeadership();\n\n                await AsyncTestUtil.waitUntil(() => {\n                    const leaders = [\n                        le1.isLeader,\n                        le2.isLeader\n                    ].filter(x => x);\n                    return leaders.length === 1;\n                });\n                await AsyncTestUtil.wait(50);\n\n                assert.notStrictEqual(le1.isLeader, le2.isLeader);\n\n                await c1.database.destroy();\n                await c2.database.destroy();\n            }\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"when many instances apply, one should win","suites":["leader-election.test.js","election"],"updatePoint":{"line":94,"column":53},"line":94,"code":"        it('when many instances apply, one should win', async () => {\n            const name = randomCouchString(10);\n            const dbs: any[] = [];\n            while (dbs.length < 10) {\n                const c = await humansCollection.createMultiInstance(name);\n                dbs.push(c.database);\n            }\n            dbs.forEach(db => db.waitForLeadership());\n\n            await AsyncTestUtil.waitUntil(() => {\n                const count = dbs\n                    .map(db => db.leaderElector().isLeader)\n                    .filter(is => is === true)\n                    .length;\n                return count === 1;\n            });\n            await AsyncTestUtil.wait(100);\n\n            const leaderCount = dbs\n                .map(db => db.leaderElector().isLeader)\n                .filter(is => is === true)\n                .length;\n            assert.strictEqual(leaderCount, 1);\n            await Promise.all(dbs.map(db => db.destroy()));\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"when the leader dies, a new one should be elected","suites":["leader-election.test.js","election"],"updatePoint":{"line":119,"column":61},"line":119,"code":"        it('when the leader dies, a new one should be elected', async function () {\n            this.timeout(5 * 1000);\n            const name = randomCouchString(10);\n            const dbs: any[] = [];\n            while (dbs.length < 6) {\n                const c = await humansCollection.createMultiInstance(name);\n                dbs.push(c.database);\n            }\n            dbs.forEach(db => db.waitForLeadership());\n\n            await AsyncTestUtil.waitUntil(() => {\n                const count = dbs\n                    .filter(db => db.leaderElector().isLeader === true)\n                    .length;\n                return count === 1;\n            });\n            await AsyncTestUtil.wait(100);\n            const leaderCount = dbs\n                .filter(db => db.leaderElector().isLeader === true)\n                .length;\n            assert.strictEqual(leaderCount, 1);\n\n            // let leader die\n            const leader = dbs\n                .filter(db => db.leaderElector().isLeader === true)[0];\n            const leaderToken = leader.token;\n            await leader.destroy();\n            const nonDeadDbs = dbs.filter(db => db !== leader);\n\n            await AsyncTestUtil.waitUntil(() => {\n                const count = nonDeadDbs\n                    .filter(db => db.leaderElector().isLeader === true)\n                    .length;\n                return count === 1;\n            });\n            const leaderCount2 = nonDeadDbs\n                .filter(db => db.leaderElector().isLeader === true)\n                .length;\n            assert.strictEqual(leaderCount2, 1);\n\n            const leader2 = nonDeadDbs\n                .filter(db => db.token !== leaderToken)\n                .filter(db => db.leaderElector().isLeader === true)[0];\n            const leaderToken2 = leader2.token;\n\n            assert.notStrictEqual(leaderToken, leaderToken2);\n            await Promise.all(nonDeadDbs.map(db => db.destroy()));\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"non-multiInstance should always be leader","suites":["leader-election.test.js","election"],"updatePoint":{"line":169,"column":53},"line":169,"code":"        it('non-multiInstance should always be leader', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n                multiInstance: false\n            });\n            // setTimeout(() => db.destroy(), dbLifetime);\n            await db.addCollections({\n                human: {\n                    schema: schemas.human\n                }\n            });\n            assert.strictEqual(db.isLeader(), true);\n            await db.destroy();\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"non-multiInstance: waitForLeadership should instant","suites":["leader-election.test.js","election"],"updatePoint":{"line":184,"column":63},"line":184,"code":"        it('non-multiInstance: waitForLeadership should instant', async () => {\n            const c = await humansCollection.create(0);\n            const db = c.database;\n            await db.waitForLeadership();\n            await db.destroy();\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"waitForLeadership: run once when instance becomes leader","suites":["leader-election.test.js","election"],"updatePoint":{"line":191,"column":68},"line":191,"code":"        it('waitForLeadership: run once when instance becomes leader', async () => {\n            const name = randomCouchString(10);\n            const cols = await Promise.all(\n                new Array(5)\n                    .fill(0)\n                    .map(() => humansCollection.createMultiInstance(name))\n            );\n            const dbs = cols.map(col => col.database);\n\n            let count = 0;\n            dbs.forEach(db => db.waitForLeadership().then(() => count++));\n            await AsyncTestUtil.waitUntil(() => count === 1);\n\n            // let leader die\n            await dbs\n                .filter(db => db.isLeader())[0]\n                .leaderElector().die();\n\n            await AsyncTestUtil.waitUntil(() => count === 2);\n            await Promise.all(dbs.map(db => db.destroy()));\n        });","file":"unit/leader-election.test.ts","skipped":false,"dir":"test"},{"name":"should create a local document","suites":[".insertLocal()","positive"],"updatePoint":{"line":44,"column":46},"line":44,"code":"            it('should create a local document', async () => {\n                const c = await humansCollection.create(0);\n                const doc = await c.insertLocal('foobar', {\n                    foo: 'bar'\n                });\n                assert.ok(doc);\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should not find the doc because its local","suites":[".insertLocal()","positive"],"updatePoint":{"line":52,"column":57},"line":52,"code":"            it('should not find the doc because its local', async () => {\n                const c = await humansCollection.create(0);\n                await c.insertLocal('foobar', {\n                    foo: 'bar'\n                });\n                const doc2 = await c.findOne().exec();\n                assert.strictEqual(doc2, null);\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should throw if already exists","suites":[".insertLocal()","negative"],"updatePoint":{"line":63,"column":46},"line":63,"code":"            it('should throw if already exists', async () => {\n                const c = await humansCollection.create(0);\n                const doc = await c.insertLocal('foobar', {\n                    foo: 'bar'\n                });\n                assert.ok(doc);\n                let thrown = false;\n                try {\n                    await c.insertLocal('foobar', {\n                        foo: 'bar2'\n                    });\n                } catch (err) {\n                    thrown = true;\n                }\n                assert.ok(thrown);\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should find the document","suites":[".getLocal()","positive"],"updatePoint":{"line":84,"column":40},"line":84,"code":"            it('should find the document', async () => {\n                const c = await humansCollection.create(0);\n                await c.insertLocal('foobar', {\n                    foo: 'bar'\n                });\n                const doc = await c.getLocal('foobar');\n                assert.ok(doc);\n                assert.strictEqual(doc.get('foo'), 'bar');\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should find the document twice (doc-cache)","suites":[".getLocal()","positive"],"updatePoint":{"line":94,"column":58},"line":94,"code":"            it('should find the document twice (doc-cache)', async () => {\n                const c = await humansCollection.create(0);\n                await c.insertLocal('foobar', {\n                    foo: 'bar'\n                });\n                const doc = await c.getLocal('foobar');\n                const doc2 = await c.getLocal('foobar');\n                assert.ok(doc);\n                assert.ok(doc === doc2);\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should not find non-existing","suites":[".getLocal()","negative"],"updatePoint":{"line":107,"column":44},"line":107,"code":"            it('should not find non-existing', async () => {\n                const c = await humansCollection.create(0);\n                const doc = await c.getLocal('foobar');\n                assert.strictEqual(doc, null);\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should modify the data","suites":["atomic mutation functions",".atomicPatch()"],"updatePoint":{"line":121,"column":38},"line":121,"code":"            it('should modify the data', async () => {\n                const c = await humansCollection.create(0);\n                const doc = await c.upsertLocal<LocalDocType>(\n                    'foobar',\n                    {\n                        foo: 'bar'\n                    }\n                );\n\n                await doc.atomicPatch({\n                    added: 'foo'\n                });\n\n                assert.strictEqual(doc.get('foo'), 'bar');\n                assert.strictEqual(doc.get('added'), 'foo');\n\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should modify the data","suites":["atomic mutation functions",".atomicUpdate()"],"updatePoint":{"line":141,"column":38},"line":141,"code":"            it('should modify the data', async () => {\n                const c = await humansCollection.create(0);\n                const doc: RxLocalDocument<RxCollection<any>, LocalDocType> = await c.upsertLocal<LocalDocType>('foobar', {\n                    foo: 'bar'\n                });\n\n                await doc.atomicUpdate(data => {\n                    data.added = 'foo';\n                    return data;\n                });\n\n                assert.strictEqual(doc.get('foo'), 'bar');\n                assert.strictEqual(doc.get('added'), 'foo');\n\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should emit null when not exists","suites":[".getLocal$()"],"updatePoint":{"line":161,"column":44},"line":161,"code":"        it('should emit null when not exists', async () => {\n            const c = await humansCollection.create(0);\n            const cData = await c.getLocal$(id).pipe(first()).toPromise();\n            const dbData = await c.database.getLocal$(id).pipe(first()).toPromise();\n\n            assert.strictEqual(cData, null);\n            assert.strictEqual(dbData, null);\n\n            c.database.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should emit the document when exists","suites":[".getLocal$()"],"updatePoint":{"line":171,"column":48},"line":171,"code":"        it('should emit the document when exists', async () => {\n            const c = await humansCollection.create(0);\n\n            await c.insertLocal(id, {\n                foo: 'bar'\n            });\n            await c.database.insertLocal(id, {\n                foo: 'bar'\n            });\n\n            const cDoc = await c.getLocal$(id).pipe(first()).toPromise();\n            const dbDoc = await c.database.getLocal$(id).pipe(first()).toPromise();\n\n            assert.strictEqual(ensureNotFalsy(cDoc).get('foo'), 'bar');\n            assert.strictEqual(ensureNotFalsy(dbDoc).get('foo'), 'bar');\n\n            c.database.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"collection: should emit again when state changed","suites":[".getLocal$()"],"updatePoint":{"line":189,"column":60},"line":189,"code":"        it('collection: should emit again when state changed', async () => {\n            const c = await humansCollection.create(0);\n            const cEmits: any[] = [];\n            const sub = c.getLocal$(id).subscribe((x: any) => {\n                cEmits.push(x ? x.toJSON() : null);\n            });\n\n            await waitUntil(() => cEmits.length === 1);\n            assert.strictEqual(cEmits[0], null);\n\n            // insert\n            await c.insertLocal(id, { foo: 'bar' });\n            await waitUntil(() => cEmits.length === 2);\n\n            assert.strictEqual(cEmits[1].data.foo, 'bar');\n\n            // update\n            await c.upsertLocal(id, { foo: 'bar2' });\n            await waitUntil(() => cEmits.length === 3);\n            assert.strictEqual(cEmits[2].data.foo, 'bar2');\n\n            sub.unsubscribe();\n            c.database.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"database: should emit again when state changed","suites":[".getLocal$()"],"updatePoint":{"line":213,"column":58},"line":213,"code":"        it('database: should emit again when state changed', async () => {\n            const c = await humansCollection.create(0);\n            const db = c.database;\n\n            const cEmits: any[] = [];\n            const sub = db.getLocal$(id).subscribe((x) => {\n                cEmits.push(x ? x.toJSON() : null);\n            });\n\n            await waitUntil(() => cEmits.length === 1);\n            assert.strictEqual(cEmits[0], null);\n\n            // insert\n            await db.insertLocal(id, { foo: 'bar' });\n            await waitUntil(() => cEmits.length === 2);\n            assert.strictEqual(cEmits[1].data.foo, 'bar');\n\n            // update\n            await db.upsertLocal(id, { foo: 'bar2' });\n            await waitUntil(() => cEmits.length === 3);\n            assert.strictEqual(cEmits[2].data.foo, 'bar2');\n\n            sub.unsubscribe();\n            c.database.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should insert when not exists","suites":[".upsertLocal()","positive"],"updatePoint":{"line":241,"column":45},"line":241,"code":"            it('should insert when not exists', async () => {\n                const c = await humansCollection.create(0);\n                const doc: RxLocalDocument<any, { foo: string; }> = await c.upsertLocal<{ foo: string; }>('foobar', {\n                    foo: 'bar'\n                });\n                assert.ok(doc);\n                assert.strictEqual(doc.get('foo'), 'bar');\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should update when exists","suites":[".upsertLocal()","positive"],"updatePoint":{"line":250,"column":41},"line":250,"code":"            it('should update when exists', async () => {\n                const c = await humansCollection.create(0);\n                const doc = await c.upsertLocal('foobar', {\n                    foo: 'bar'\n                });\n                const doc2 = await c.upsertLocal('foobar', {\n                    foo: 'bar2'\n                });\n\n                assert.ok(doc === doc2);\n                assert.strictEqual(doc.get('foo'), 'bar2');\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should invoke subscription once","suites":[".upsertLocal()","positive"],"updatePoint":{"line":266,"column":47},"line":266,"code":"            it('should invoke subscription once', async () => {\n                const c = await humansCollection.create(0);\n                const emitted: any[] = [];\n                const doc = await c.upsertLocal('foobar', {\n                    foo: 'barOne',\n                });\n                await wait(50);\n                const docSub = doc.$.subscribe(x => {\n                    emitted.push(x);\n                });\n                await c.upsertLocal('foobar', {\n                    foo: 'barTwo',\n                });\n\n                assert.strictEqual(emitted.length, 2);\n                // first 'barOne' is emitted because.$ is a BehaviorSubject\n                assert.strictEqual(emitted[0].data.foo, 'barOne');\n                // second after the change, barTwo is emitted\n                assert.strictEqual(emitted[1].data.foo, 'barTwo');\n\n                docSub.unsubscribe();\n                c.database.destroy();\n            });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should remove the document","suites":[".remove()"],"updatePoint":{"line":293,"column":38},"line":293,"code":"        it('should remove the document', async () => {\n            const c = await humansCollection.create(0);\n            const doc = await c.upsertLocal('foobar', {\n                foo: 'bar'\n            });\n            await doc.remove();\n            const doc2 = await c.getLocal('foobar');\n            assert.strictEqual(doc2, null);\n            c.database.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should be able to use local documents directly on the database","suites":["with database"],"updatePoint":{"line":305,"column":74},"line":305,"code":"        it('should be able to use local documents directly on the database', async () => {\n            const c = await humansCollection.create(0);\n            const db = c.database;\n\n            const doc1 = await db.insertLocal('foobar', {\n                foo: 'bar'\n            });\n            const doc2 = await db.getLocal('foobar');\n            assert.strictEqual(doc1, doc2);\n            db.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should stream events over multi-instance","suites":["multi-instance"],"updatePoint":{"line":321,"column":52},"line":321,"code":"        it('should stream events over multi-instance', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                localDocuments: true\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                ignoreDuplicate: true,\n                localDocuments: true\n            });\n\n            const doc1 = await db.insertLocal('foobar', {\n                foo: 'bar'\n            });\n            let doc2: RxLocalDocument<any, any> | null;\n            await waitUntil(async () => {\n                doc2 = await db2.getLocal('foobar');\n                return !!doc2;\n            });\n\n            await doc1.atomicPatch({ foo: 'bar2' });\n            await AsyncTestUtil.waitUntil(() => {\n                return ensureNotFalsy(doc2).get('foo') === 'bar2';\n            }, 1000, 50);\n\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should emit deleted","suites":["multi-instance"],"updatePoint":{"line":352,"column":31},"line":352,"code":"        it('should emit deleted', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                localDocuments: true\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                ignoreDuplicate: true,\n                localDocuments: true\n            });\n\n            const doc1 = await db.insertLocal('foobar', {\n                foo: 'bar'\n            });\n\n            let doc2: RxLocalDocument<any, any> | null = undefined as any;\n            await waitUntil(async () => {\n                doc2 = await db2.getLocal('foobar');\n                return !!doc2;\n            });\n\n            doc1.remove();\n\n            await ensureNotFalsy(doc2).deleted$\n                .pipe(\n                    filter(d => d === true),\n                    first()\n                )\n                .toPromise();\n\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should emit changes (database)","suites":["multi-instance"],"updatePoint":{"line":388,"column":42},"line":388,"code":"        it('should emit changes (database)', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                localDocuments: true\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                ignoreDuplicate: true,\n                localDocuments: true\n            });\n\n            const doc1 = await db.insertLocal('foobar', {\n                foo: 'bar'\n            });\n\n            await doc1.atomicPatch({ foo: 'bar2' });\n\n            await waitUntil(async () => {\n                const doc2 = await db2.getLocal<TestDocType>('foobar');\n                return doc2 && doc2.toJSON().data.foo === 'bar2';\n            });\n\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should emit changes (collection)","suites":["multi-instance"],"updatePoint":{"line":416,"column":44},"line":416,"code":"        it('should emit changes (collection)', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                ignoreDuplicate: true\n            });\n            const c1 = await db.addCollections({\n                humans: {\n                    schema: schemas.primaryHuman,\n                    localDocuments: true\n                }\n            });\n\n            const c2 = await db2.addCollections({\n                humans: {\n                    schema: schemas.primaryHuman,\n                    localDocuments: true\n                }\n            });\n\n            // insert on instance #1\n            const doc1 = await c1.humans.insertLocal('foobar', {\n                foo: 'bar'\n            });\n\n            const emitted: any[] = [];\n            const sub = c1.humans.getLocal$('foobar').subscribe((x: any) => {\n                emitted.push(x ? x.toJSON(true) : null);\n            });\n            await waitUntil(() => emitted.length === 1);\n\n\n            // update on instance #2\n            const doc2 = await c2.humans.getLocal<TestDocType>('foobar');\n            await doc1.atomicPatch({ foo: 'bar2' });\n\n            await waitUntil(() => doc2 && doc2.toJSON().data.foo === 'bar2');\n            await waitUntil(() => {\n                return emitted.length >= 2;\n            });\n\n            sub.unsubscribe();\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"BUG insertLocal not send to other instance","suites":["multi-instance"],"updatePoint":{"line":466,"column":54},"line":466,"code":"        it('BUG insertLocal not send to other instance', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                localDocuments: true\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                ignoreDuplicate: true,\n                localDocuments: true\n            });\n\n            const emitted: any[] = [];\n            const sub = db2.getLocal$<TestDocType>('foobar').subscribe(x => {\n                emitted.push(x);\n            });\n\n            /**\n             * Before inserting, we must await that the empty result set\n             * was emitted. Otherwise we might miss the initial emit\n             * because creating the db2 can take a long time\n             * on some storages. So not awaiting here would make the test\n             * timing dependend.\n             */\n            await waitUntil(() => emitted.length === 1);\n\n            await db.insertLocal<TestDocType>('foobar', {\n                foo: 'bar'\n            });\n\n            await waitUntil(() => {\n                return emitted.length === 2;\n            }, 2000, 50);\n            assert.ok(emitted.pop());\n\n            const doc = await db2.getLocal<TestDocType>('foobar');\n            assert.strictEqual(doc && doc.toJSON().data.foo, 'bar');\n\n            sub.unsubscribe();\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"should not conflict with non-local-doc that has same id","suites":["multi-instance"],"updatePoint":{"line":510,"column":67},"line":510,"code":"        it('should not conflict with non-local-doc that has same id', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                localDocuments: true\n            });\n            const c1 = await db.addCollections({\n                humans: {\n                    schema: schemas.primaryHuman,\n                    localDocuments: true\n                }\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                ignoreDuplicate: true,\n                localDocuments: true\n            });\n            const c2 = await db2.addCollections({\n                humans: {\n                    schema: schemas.primaryHuman,\n                    localDocuments: true\n                }\n            });\n            const docData = schemaObjects.human();\n            docData.passportId = 'foobar';\n            docData.age = 40;\n            const doc = await c1.humans.insert(docData);\n            const localDoc = await c1.humans.insertLocal('foobar', {\n                foo: 'bar',\n                age: 10\n            });\n\n            let doc2: RxLocalDocument<any, any> | null = undefined as any;\n            await waitUntil(async () => {\n                doc2 = await c2.humans.findOne().exec();\n                return !!doc2;\n            });\n\n\n\n            let localDoc2: RxLocalDocument<any, any> | null = undefined as any;\n            await waitUntil(async () => {\n                localDoc2 = await c2.humans.getLocal('foobar');\n                return !!localDoc2;\n            });\n            await doc.atomicPatch({ age: 50 });\n\n            await AsyncTestUtil.waitUntil(() => (doc2 as any).age === 50);\n            await AsyncTestUtil.wait(20);\n            assert.strictEqual(ensureNotFalsy(localDoc2).get('age'), 10);\n            await localDoc.atomicPatch({ age: 66, foo: 'bar' });\n\n            await AsyncTestUtil.waitUntil(() => ensureNotFalsy(localDoc2).get('age') === 66);\n            await AsyncTestUtil.wait(20);\n            assert.strictEqual(ensureNotFalsy(doc2).get('age'), 50);\n\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"#661 LocalDocument Observer field error","suites":["issues"],"updatePoint":{"line":573,"column":51},"line":573,"code":"        it('#661 LocalDocument Observer field error', async () => {\n            const myCollection = await humansCollection.create(0);\n            await myCollection.upsertLocal(\n                'foobar', {\n                foo: 'bar'\n            }\n            );\n\n            const emitted: any[] = [];\n            const localDoc = await myCollection.getLocal('foobar');\n            ensureNotFalsy(localDoc).get$('foo').subscribe((val: any) => emitted.push(val));\n\n            await AsyncTestUtil.waitUntil(() => emitted.length === 1);\n            assert.strictEqual(emitted[0], 'bar');\n\n            myCollection.database.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"#663 Document conflicts with LocalDocument in the same Collection","suites":["issues"],"updatePoint":{"line":590,"column":77},"line":590,"code":"        it('#663 Document conflicts with LocalDocument in the same Collection', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n            });\n\n            type DocData = { id: string; boudariesGrp: { bndrPlnId: string; bndrPlnNm: string; }[] };\n            const boundaryMgmtSchema: RxJsonSchema<DocData> = {\n                version: 0,\n                type: 'object',\n                primaryKey: 'id',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    boudariesGrp: {\n                        type: 'array',\n                        uniqueItems: false,\n                        items: {\n                            type: 'object',\n                            properties: {\n                                bndrPlnId: {\n                                    type: 'string',\n                                },\n                                bndrPlnNm: {\n                                    type: 'string',\n                                }\n                            }\n                        },\n                        default: [],\n                    },\n                }\n            };\n            const boundaryMgmtCols = await db.addCollections({\n                human: {\n                    schema: boundaryMgmtSchema,\n                    localDocuments: true\n                }\n            });\n            const boundaryMgmtCol = boundaryMgmtCols.human;\n\n            const groups = {\n                bndrPlnId: 'mygroup',\n                bndrPlnNm: 'other'\n            };\n\n            // insert non-local\n            await boundaryMgmtCol.insert({\n                id: randomCouchString(12),\n                boudariesGrp: [groups]\n            });\n\n            await boundaryMgmtCol.insertLocal('metadata', {\n                userData: {},\n                selectedBndrPlnId: 'foobar1',\n                actionRev: 0,\n                bndrId: 'foobar2',\n                direction: 'foobar3',\n            });\n\n            // save localgrpId\n            const grpId = 'foobar';\n            const metadata = await boundaryMgmtCol.getLocal('metadata');\n\n            await ensureNotFalsy(metadata).atomicUpdate(docData => {\n                docData.selectedBndrPlnId = grpId;\n                return docData;\n            });\n\n            const data = await boundaryMgmtCol.findOne().exec(true);\n            const json = data.toJSON();\n\n            assert.deepStrictEqual(json.boudariesGrp[0], groups);\n\n            db.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"local documents not persistent on db restart","suites":["issues"],"updatePoint":{"line":668,"column":56},"line":668,"code":"        it('local documents not persistent on db restart', async () => {\n            addPouchPlugin(require('pouchdb-adapter-leveldb'));\n            if (!config.platform.isNode()) {\n                return;\n            }\n            const dbName: string = config.rootPath + 'test_tmp/' + randomCouchString(10);\n\n            const localDocId = 'foobar';\n            const localDocData = {\n                foo: 'bar'\n            };\n\n            const db = await createRxDatabase({\n                name: dbName,\n                storage: getRxStoragePouch(leveldown),\n                multiInstance: false,\n                localDocuments: true\n            });\n            const cols = await db.addCollections({\n                humans: {\n                    schema: schemas.human,\n                    localDocuments: true\n                }\n            });\n\n            await db.insertLocal(localDocId, localDocData);\n            await cols.humans.insertLocal(localDocId, localDocData);\n\n            await db.destroy();\n\n            const db2 = await createRxDatabase({\n                name: dbName,\n                storage: getRxStoragePouch(leveldown),\n                multiInstance: false,\n                localDocuments: true\n            });\n            const col2 = await db2.addCollections({\n                humans: {\n                    schema: schemas.human,\n                    localDocuments: true\n                }\n            });\n\n            const docDb = await db2.getLocal(localDocId);\n            const docCol = await col2.humans.getLocal(localDocId);\n\n            assert.ok(docDb);\n            assert.ok(docCol);\n\n            assert.strictEqual(docDb.get('foo'), 'bar');\n            assert.strictEqual(docCol.get('foo'), 'bar');\n\n            await db2.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"doing many upsertLocal() can cause a 404 document not found","suites":["issues"],"updatePoint":{"line":722,"column":71},"line":722,"code":"        it('doing many upsertLocal() can cause a 404 document not found', async () => {\n            if (!config.platform.isNode()) {\n                return;\n            }\n            const dbName: string = config.rootPath + 'test_tmp/' + randomCouchString(10);\n            const db = await createRxDatabase({\n                name: dbName,\n                storage: getRxStoragePouch('leveldb'),\n                multiInstance: false,\n                localDocuments: true\n            });\n\n            const key = 'foobar';\n            let doc = await db.getLocal(key);\n            doc = await db.insertLocal(key, {\n                foo: 'bar'\n            });\n            assert.ok(doc);\n\n            let t = 0;\n            while (t < 50) {\n                await db.upsertLocal(key, {\n                    foo: randomString(10)\n                });\n                t++;\n            }\n\n            db.destroy();\n        });","file":"unit/local-documents.test.ts","skipped":false,"dir":"test"},{"name":"create a collection with static-methods","suites":["statics","create","positive"],"updatePoint":{"line":25,"column":59},"line":25,"code":"                it('create a collection with static-methods', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    await db.addCollections({\n                        humans: {\n                            schema: schemas.human,\n                            statics: {\n                                foobar: function () {\n                                    return 'test';\n                                }\n                            }\n                        }\n                    });\n                    db.destroy();\n                });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"crash when name not allowed (startsWith(_))","suites":["statics","create","negative"],"updatePoint":{"line":44,"column":63},"line":44,"code":"                it('crash when name not allowed (startsWith(_))', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    await AsyncTestUtil.assertThrows(\n                        () => db.addCollections({\n                            humans: {\n                                schema: schemas.human,\n                                statics: {\n                                    _foobar: function () {\n                                        return 'test';\n                                    }\n                                }\n                            }\n                        }),\n                        'RxTypeError',\n                        'cannot start'\n                    );\n                    db.destroy();\n                });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"crash when name not allowed (name reserved)","suites":["statics","create","negative"],"updatePoint":{"line":65,"column":63},"line":65,"code":"                it('crash when name not allowed (name reserved)', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const reserved = [\n                        'synced',\n                        'migrate',\n                        'insert',\n                        'preInsert'\n                    ];\n                    let t = 0;\n                    while (t < reserved.length) {\n                        const statics: any = {};\n                        statics[reserved[t]] = function () { };\n                        await AsyncTestUtil.assertThrows(\n                            () => db.addCollections({\n                                humans: {\n                                    schema: schemas.human,\n                                    statics\n                                }\n                            }),\n                            'RxError',\n                            reserved[t]\n                        );\n                        t++;\n                    }\n                    db.destroy();\n                });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"should be able to run the method","suites":["statics","run"],"updatePoint":{"line":97,"column":48},"line":97,"code":"            it('should be able to run the method', async () => {\n                const db = await createRxDatabase<{\n                    humans: RxCollection<HumanDocumentType, {}, { foobar(): string; }>\n                }>({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: schemas.human,\n                        statics: {\n                            foobar: function () {\n                                return 'test';\n                            }\n                        }\n                    }\n                });\n                const res = (collections.humans as any).foobar();\n                assert.strictEqual(res, 'test');\n                db.destroy();\n            });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"should have the right this-context","suites":["statics","run"],"updatePoint":{"line":118,"column":50},"line":118,"code":"            it('should have the right this-context', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: schemas.human,\n                        statics: {\n                            foobar: function () {\n                                return this.name;\n                            }\n                        }\n                    }\n                });\n                const collection = collections.humans;\n                const res = (collection as any).foobar();\n                assert.strictEqual(res, 'humans');\n                db.destroy();\n            });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"should be able to use this.insert()","suites":["statics","run"],"updatePoint":{"line":138,"column":51},"line":138,"code":"            it('should be able to use this.insert()', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: schemas.human,\n                        statics: {\n                            foobar: function (obj: any) {\n                                return this.insert(obj);\n                            }\n                        }\n                    }\n                });\n                const collection = collections.humans;\n                const res = (collection as any).foobar(schemaObjects.human());\n                assert.strictEqual(res.constructor.name, 'Promise');\n                await res;\n                db.destroy();\n            });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"create a collection with instance-methods","suites":["instance-methods","create","positive"],"updatePoint":{"line":164,"column":61},"line":164,"code":"                it('create a collection with instance-methods', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    await db.addCollections({\n                        humans: {\n                            schema: schemas.human,\n                            methods: {\n                                foobar: function () {\n                                    return 'test';\n                                }\n                            }\n                        }\n                    });\n                    db.destroy();\n                });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"this-scope should be bound to document","suites":["instance-methods","create","positive"],"updatePoint":{"line":181,"column":58},"line":181,"code":"                it('this-scope should be bound to document', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const cols = await db.addCollections({\n                        humans: {\n                            schema: schemas.human,\n                            methods: {\n                                myMethod: function () {\n                                    return 'test:' + this.firstName;\n                                }\n                            }\n                        }\n                    });\n                    const col = cols.humans;\n\n                    // add one to ensure it does not overwrite\n                    await col.insert(schemaObjects.human());\n\n                    const docData = schemaObjects.human();\n                    docData.firstName = 'foobar';\n                    const doc = await col.insert(docData);\n\n                    // add another one to ensure it does not overwrite\n                    await col.insert(schemaObjects.human());\n\n                    const val = doc.myMethod();\n                    assert.strictEqual(val, 'test:foobar');\n\n                    db.destroy();\n                });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"crash when name not allowed (startsWith(_))","suites":["instance-methods","create","negative"],"updatePoint":{"line":215,"column":63},"line":215,"code":"                it('crash when name not allowed (startsWith(_))', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    await AsyncTestUtil.assertThrows(\n                        () => db.addCollections({\n                            humans: {\n                                schema: schemas.human,\n                                methods: {\n                                    _foobar: function () {\n                                        return 'test';\n                                    }\n                                }\n                            }\n                        }),\n                        'RxTypeError'\n                    );\n                    db.destroy();\n                });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"crash when name not allowed (name reserved)","suites":["instance-methods","create","negative"],"updatePoint":{"line":235,"column":63},"line":235,"code":"                it('crash when name not allowed (name reserved)', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const reserved = [\n                        'primaryPath',\n                        'get',\n                        'toJSON',\n                    ];\n                    let t = 0;\n                    while (t < reserved.length) {\n                        const methods: any = {};\n                        methods[reserved[t]] = function () { };\n                        await AsyncTestUtil.assertThrows(\n                            () => db.addCollections({\n                                humans: {\n                                    schema: schemas.human,\n                                    methods\n                                }\n                            }),\n                            'RxError',\n                            reserved[t]\n                        );\n                        t++;\n                    }\n                    db.destroy();\n                });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"crash when name not allowed (name is top-level field in schema)","suites":["instance-methods","create","negative"],"updatePoint":{"line":263,"column":83},"line":263,"code":"                it('crash when name not allowed (name is top-level field in schema)', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const reserved = [\n                        'passportId',\n                        'firstName',\n                        'lastName',\n                        'age',\n                    ];\n                    let t = 0;\n                    while (t < reserved.length) {\n                        const methods: any = {};\n                        methods[reserved[t]] = function () { };\n                        await AsyncTestUtil.assertThrows(\n                            () => db.addCollections({\n                                humans: {\n                                    schema: schemas.human,\n                                    methods\n                                }\n                            }),\n                            'RxError',\n                            reserved[t]\n                        );\n                        t++;\n                    }\n                    db.destroy();\n                });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"should be able to run the method","suites":["instance-methods","run"],"updatePoint":{"line":296,"column":48},"line":296,"code":"            it('should be able to run the method', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: schemas.human,\n                        methods: {\n                            foobar: function () {\n                                return 'test';\n                            }\n                        }\n                    }\n                });\n                const collection = collections.humans;\n                await collection.insert(schemaObjects.human());\n                const doc = await collection.findOne().exec();\n                const res = doc.foobar();\n                assert.strictEqual(res, 'test');\n                db.destroy();\n            });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"should have the right this-context","suites":["instance-methods","run"],"updatePoint":{"line":318,"column":50},"line":318,"code":"            it('should have the right this-context', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: schemas.human,\n                        methods: {\n                            foobar: function () {\n                                return this.passportId;\n                            }\n                        }\n                    }\n                });\n                const collection = collections.humans;\n                const obj = schemaObjects.human();\n                await collection.insert(obj);\n                const doc = await collection.findOne().exec();\n                const res = doc.foobar();\n                assert.strictEqual(res, obj.passportId);\n                db.destroy();\n            });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"should not be confused with many collections","suites":["instance-methods","run"],"updatePoint":{"line":341,"column":60},"line":341,"code":"            it('should not be confused with many collections', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: schemas.human,\n                        methods: {\n                            foobar: () => '1'\n                        }\n                    },\n                    humans2: {\n                        schema: schemas.human,\n                        methods: {\n                            foobar: () => '2'\n                        }\n                    }\n                });\n                const collection = collections.humans;\n                const collection2 = collections.humans2;\n\n                const docData = schemaObjects.human();\n                const doc1 = await collection.insert(docData);\n                const doc2 = await collection2.insert(docData);\n\n                assert.strictEqual('1', doc1.foobar());\n                assert.strictEqual('2', doc2.foobar());\n\n                db.destroy();\n            });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"#791 Document methods are not bind() to the document","suites":["ISSUES"],"updatePoint":{"line":375,"column":64},"line":375,"code":"        it('#791 Document methods are not bind() to the document', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(),\n                storage: getRxStoragePouch('memory'),\n                multiInstance: false\n            });\n\n            const schema: RxJsonSchema<{ name: string; nested: { foo: string }; }> = {\n                version: 0,\n                type: 'object',\n                primaryKey: 'name',\n                properties: {\n                    name: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    nested: {\n                        type: 'object',\n                        properties: {\n                            foo: {\n                                type: 'string'\n                            }\n                        }\n                    }\n                }\n            };\n\n            const collections = await db.addCollections({\n                person: {\n                    schema: schema,\n                    methods: {\n                        hello: function () {\n                            return this.name;\n                        }\n                    }\n                }\n            });\n\n            const doc = await collections.person.insert({\n                name: 'hi',\n                nested: {\n                    foo: 'bar'\n                }\n            });\n\n            // orm-method\n            const hello = doc.hello;\n            assert.strictEqual(hello(), 'hi');\n\n            // prototype-method\n            const get = doc.get;\n            assert.strictEqual(get('name'), 'hi');\n\n            // nested\n            const nestedObj = doc.nested;\n            assert.strictEqual(nestedObj.foo, 'bar');\n\n            // nested getter-method\n            const obs = nestedObj.foo$;\n            const emitted: any[] = [];\n            const sub = obs.subscribe((v: any) => emitted.push(v));\n            await AsyncTestUtil.waitUntil(() => emitted.length === 1);\n            assert.strictEqual(emitted[0], 'bar');\n            sub.unsubscribe();\n\n            db.destroy();\n        });","file":"unit/orm.test.ts","skipped":false,"dir":"test"},{"name":"should not crash when a new plugin is added","suites":[".addRxPlugin()","positive"],"updatePoint":{"line":31,"column":59},"line":31,"code":"            it('should not crash when a new plugin is added', () => {\n                addRxPlugin({\n                    rxdb: true,\n                    name: randomCouchString(12)\n                });\n            });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"should crash when dev-mode is added multiple times","suites":[".addRxPlugin()","positive"],"updatePoint":{"line":43,"column":66},"line":43,"code":"            it('should crash when dev-mode is added multiple times', async () => {\n                await assertThrows(\n                    () => addRxPlugin(RxDBDevModePlugin),\n                    'RxError',\n                    'DEV1'\n                );\n            });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"should not crash when pouch plugin is added","suites":[".addPouchPlugin()"],"updatePoint":{"line":53,"column":55},"line":53,"code":"        it('should not crash when pouch plugin is added', () => {\n            addPouchPlugin(require('pouchdb-adapter-memory'));\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"should crash when rxdb plugin is added via addPouchPlugin","suites":[".addPouchPlugin()"],"updatePoint":{"line":56,"column":69},"line":56,"code":"        it('should crash when rxdb plugin is added via addPouchPlugin', async () => {\n            await assertThrows(\n                () => addPouchPlugin(RxDBDevModePlugin),\n                'RxTypeError',\n                'PL2'\n            );\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"core.node.ts: should run without errors","suites":["core.node.ts"],"updatePoint":{"line":65,"column":51},"line":65,"code":"        it('core.node.ts: should run without errors', async function () {\n            this.timeout(10000);\n            if (!config.platform.isNode())\n                return;\n\n            const spawn = REQUIRE_FUN('child-process-promise').spawn;\n            const stdout: any[] = [];\n            const stderr: any[] = [];\n            const promise = spawn('mocha', [config.rootPath + 'test_tmp/unit/core.node.js']);\n            const childProcess = promise.childProcess;\n            childProcess.stdout.on('data', (data: any) => {\n                // comment in to debug\n                //               console.log(':: ' + data.toString());\n                stdout.push(data.toString());\n            });\n            childProcess.stderr.on('data', (data: any) => stderr.push(data.toString()));\n            try {\n                await promise;\n            } catch (err) {\n                console.error('errrrr');\n                console.dir(stdout);\n                throw new Error(`could not run Core.node.js.\n                    # Error: ${err}\n                    # Output: ${stdout}\n                    # ErrOut: ${stderr}\n                    `);\n            }\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"full.node.ts should run without errors","suites":["full.node.ts"],"updatePoint":{"line":95,"column":50},"line":95,"code":"        it('full.node.ts should run without errors', async () => {\n            if (!config.platform.isNode())\n                return;\n\n            const spawn = REQUIRE_FUN('child-process-promise').spawn;\n            const stdout: any[] = [];\n            const stderr: any[] = [];\n            const promise = spawn('mocha', [config.rootPath + 'test_tmp/unit/full.node.js']);\n            const childProcess = promise.childProcess;\n            childProcess.stdout.on('data', (data: any) => stdout.push(data.toString()));\n            childProcess.stderr.on('data', (data: any) => stderr.push(data.toString()));\n            try {\n                await promise;\n            } catch (err) {\n                console.error('errrrr');\n                console.dir(stdout);\n                throw new Error(`could not run full.node.js.\n                    # Error: ${err}\n                    # Output: ${stdout}\n                    # ErrOut: ${stderr}\n                    `);\n            }\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"createRxDatabase","suites":["hooks"],"updatePoint":{"line":120,"column":28},"line":120,"code":"        it('createRxDatabase', async () => {\n            const createRxDatabase = (args: any) => {\n                args.database.foo = 'bar_createRxDatabase';\n            };\n            const plugin: RxPlugin = {\n                rxdb: true,\n                name: randomCouchString(12),\n                hooks: {\n                    createRxDatabase: {\n                        after: createRxDatabase\n                    }\n                }\n            };\n            addRxPlugin(plugin);\n            const col = await humansCollection.create();\n            assert.strictEqual(col.database.foo, 'bar_createRxDatabase');\n            col.database.destroy();\n\n            _clearHook('createRxDatabase', createRxDatabase);\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"createRxCollection","suites":["hooks"],"updatePoint":{"line":140,"column":30},"line":140,"code":"        it('createRxCollection', async () => {\n            const createRxCollection = (args: any) => {\n                args.collection.foo = 'bar_createRxCollection';\n            };\n            const plugin: RxPlugin = {\n                rxdb: true,\n                name: randomCouchString(12),\n                hooks: {\n                    createRxCollection: {\n                        after: createRxCollection\n                    }\n                }\n            };\n            addRxPlugin(plugin);\n            const col = await humansCollection.create();\n            assert.strictEqual((col as any).foo, 'bar_createRxCollection');\n            col.database.destroy();\n            _clearHook('createRxCollection', createRxCollection);\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"createRxSchema","suites":["hooks"],"updatePoint":{"line":159,"column":26},"line":159,"code":"        it('createRxSchema', async () => {\n            const createRxSchema = (c: any) => {\n                c.foo = 'bar_createRxSchema';\n            };\n            const plugin: RxPlugin = {\n                rxdb: true,\n                name: randomCouchString(12),\n                hooks: {\n                    createRxSchema: {\n                        after: createRxSchema\n                    }\n                }\n            };\n            addRxPlugin(plugin);\n            const col: any = await humansCollection.create();\n            assert.strictEqual(col.schema['foo'], 'bar_createRxSchema');\n            col.database.destroy();\n            _clearHook('createRxSchema', createRxSchema);\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"createRxDocument","suites":["hooks"],"updatePoint":{"line":178,"column":28},"line":178,"code":"        it('createRxDocument', async () => {\n            const createRxDocument = (c: any) => {\n                c.foo = 'bar_createRxDocument';\n            };\n            const plugin: RxPlugin = {\n                rxdb: true,\n                name: randomCouchString(12),\n                hooks: {\n                    createRxDocument: {\n                        after: createRxDocument\n                    }\n                }\n            };\n            addRxPlugin(plugin);\n            const col = await humansCollection.create(5);\n            const doc: any = await col.findOne().exec();\n            assert.strictEqual(doc.foo, 'bar_createRxDocument');\n            col.database.destroy();\n            _clearHook('createRxDocument', createRxDocument);\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"postCreateRxDocument","suites":["hooks"],"updatePoint":{"line":198,"column":32},"line":198,"code":"        it('postCreateRxDocument', async () => {\n            const postCreateRxDocument = (c: any) => {\n                c.fooPostCreate = 'bar_postCreateRxDocument';\n            };\n            const plugin: RxPlugin = {\n                rxdb: true,\n                name: randomCouchString(12),\n                hooks: {\n                    postCreateRxDocument: {\n                        after: postCreateRxDocument\n                    }\n                }\n            };\n            addRxPlugin(plugin);\n            const col = await humansCollection.create(5);\n            const doc: any = await col.findOne().exec();\n            assert.strictEqual(doc.fooPostCreate, 'bar_postCreateRxDocument');\n            await col.database.destroy();\n            _clearHook('postCreateRxDocument', postCreateRxDocument);\n        });","file":"unit/plugin.test.ts","skipped":false,"dir":"test"},{"name":"should allow to create a schema with a relation","suites":["createRxSchema","positive"],"updatePoint":{"line":23,"column":63},"line":23,"code":"            it('should allow to create a schema with a relation', () => {\n                const schema = createRxSchema({\n                    version: 0,\n                    primaryKey: 'bestFriend',\n                    type: 'object',\n                    properties: {\n                        bestFriend: {\n                            ref: 'human',\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    }\n                });\n                assert.strictEqual(schema.constructor.name, 'RxSchema');\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"should allow primary as relation key","suites":["createRxSchema","positive"],"updatePoint":{"line":43,"column":52},"line":43,"code":"            it('should allow primary as relation key', () => {\n                const schema = createRxSchema({\n                    version: 0,\n                    primaryKey: 'bestFriend',\n                    type: 'object',\n                    properties: {\n                        bestFriend: {\n                            ref: 'human',\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    }\n                });\n                assert.strictEqual(schema.constructor.name, 'RxSchema');\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"should allow to create a schema with a relation in nested","suites":["createRxSchema","positive"],"updatePoint":{"line":58,"column":73},"line":58,"code":"            it('should allow to create a schema with a relation in nested', () => {\n                const schema = createRxSchema<any>({\n                    version: 0,\n                    primaryKey: 'id',\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        foo: {\n                            type: 'object',\n                            properties: {\n                                bestFriend: {\n                                    ref: 'human',\n                                    type: 'string'\n                                }\n                            }\n                        }\n                    }\n                });\n                assert.strictEqual(schema.constructor.name, 'RxSchema');\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"should allow to create relation of array","suites":["createRxSchema","positive"],"updatePoint":{"line":81,"column":56},"line":81,"code":"            it('should allow to create relation of array', () => {\n                const schema = createRxSchema<any>({\n                    version: 0,\n                    primaryKey: 'id',\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        friends: {\n                            type: 'array',\n                            items: {\n                                ref: 'human',\n                                type: 'string'\n                            }\n                        }\n                    }\n                });\n                assert.strictEqual(schema.constructor.name, 'RxSchema');\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"should allow to create relation with nullable string","suites":["createRxSchema","positive"],"updatePoint":{"line":102,"column":68},"line":102,"code":"            it('should allow to create relation with nullable string', () => {\n                const schema = createRxSchema<any>({\n                    version: 0,\n                    primaryKey: 'id',\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        friends: {\n                            type: 'array',\n                            items: {\n                                ref: 'human',\n                                type: ['string', 'null']\n                            }\n                        }\n                    }\n                });\n                assert.strictEqual(schema.constructor.name, 'RxSchema');\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"throw if ref-type is no string","suites":["createRxSchema","negative"],"updatePoint":{"line":125,"column":46},"line":125,"code":"            it('throw if ref-type is no string', () => {\n                assert.throws(\n                    () => createRxSchema<any>({\n                        version: 0,\n                        primaryKey: 'id',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            bestFriend: {\n                                ref: 'human'\n                            }\n                        }\n                    }),\n                    Error\n                );\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"throw if ref-type is no string (array)","suites":["createRxSchema","negative"],"updatePoint":{"line":144,"column":54},"line":144,"code":"            it('throw if ref-type is no string (array)', () => {\n                assert.throws(\n                    () => createRxSchema<any>({\n                        version: 0,\n                        primaryKey: 'id',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            friends: {\n                                type: 'array',\n                                items: {\n                                    ref: 'human'\n                                }\n                            }\n                        }\n                    }),\n                    Error\n                );\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"populate top-level-field","suites":["RxDocument().populate()","positive"],"updatePoint":{"line":170,"column":40},"line":170,"code":"            it('populate top-level-field', async () => {\n                const col = await humansCollection.createRelated();\n                const doc = await col.findOne().exec(true);\n                const friend = await doc.populate('bestFriend');\n                assert.ok(isRxDocument(friend));\n                assert.strictEqual(friend.name, doc.bestFriend);\n                col.database.destroy();\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"populate nested field","suites":["RxDocument().populate()","positive"],"updatePoint":{"line":178,"column":37},"line":178,"code":"            it('populate nested field', async () => {\n                const col = await humansCollection.createRelatedNested();\n                const doc = await col.findOne().exec(true);\n                const friend = await doc.populate('foo.bestFriend');\n                assert.ok(isRxDocument(friend));\n                assert.strictEqual(friend.name, doc.foo.bestFriend);\n                col.database.destroy();\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"populate string-array","suites":["RxDocument().populate()","positive"],"updatePoint":{"line":186,"column":37},"line":186,"code":"            it('populate string-array', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const cols = await db.addCollections({\n                    human: {\n                        schema: {\n                            version: 0,\n                            primaryKey: 'name',\n                            type: 'object',\n                            properties: {\n                                name: {\n                                    type: 'string',\n                                    maxLength: 100\n                                },\n                                friends: {\n                                    type: 'array',\n                                    ref: 'human',\n                                    items: {\n                                        type: 'string'\n                                    }\n                                }\n                            }\n                        }\n                    }\n                });\n                const col = cols.human;\n                const friends = new Array(5)\n                    .fill(0)\n                    .map(() => {\n                        return {\n                            name: faker.name.firstName() + randomCouchString(5),\n                            friends: []\n                        };\n                    });\n                await Promise.all(friends.map(friend => col.insert(friend)));\n                const oneGuy = {\n                    name: 'Piotr',\n                    friends: friends.map(friend => friend.name)\n                };\n                await col.insert(oneGuy);\n                const doc = await col.findOne(oneGuy.name).exec();\n                const friendDocs = await doc.friends_;\n                friendDocs.forEach((friend: any) => {\n                    assert.ok(isRxDocument(friend));\n                });\n                db.destroy();\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"populate with primary as ref","suites":["RxDocument().populate()","positive"],"updatePoint":{"line":235,"column":44},"line":235,"code":"            it('populate with primary as ref', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const schema: RxJsonSchema<{ name: string; }> = {\n                    version: 0,\n                    primaryKey: 'name',\n                    type: 'object',\n                    properties: {\n                        name: {\n                            type: 'string',\n                            maxLength: 100,\n                            ref: 'human2'\n                        }\n                    }\n                };\n                const cols = await db.addCollections({\n                    human: {\n                        schema\n                    },\n                    human2: {\n                        schema\n                    }\n                });\n                const col = cols.human;\n                const col2 = cols.human2;\n\n                const doc = await col.insert({\n                    name: 'foobar'\n                });\n                await col2.insert({\n                    name: 'foobar'\n                });\n                const doc2 = await doc.populate(doc.primaryPath);\n                assert.ok(doc2.collection === col2);\n\n                db.destroy();\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"populate top-level-field","suites":["RxDocument populate via pseudo-proxy","positive"],"updatePoint":{"line":278,"column":40},"line":278,"code":"            it('populate top-level-field', async () => {\n                const col = await humansCollection.createRelated();\n                const doc = await col.findOne().exec(true);\n                const friend = await (doc as any).bestFriend_;\n                assert.ok(isRxDocument(friend));\n                assert.strictEqual(friend.name, doc.bestFriend);\n                col.database.destroy();\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"populate nested field","suites":["RxDocument populate via pseudo-proxy","positive"],"updatePoint":{"line":286,"column":37},"line":286,"code":"            it('populate nested field', async () => {\n                const col = await humansCollection.createRelatedNested();\n                const doc = await col.findOne().exec(true);\n                const friend = await (doc as any).foo.bestFriend_;\n                assert.ok(isRxDocument(friend));\n                assert.strictEqual(friend.name, doc.foo.bestFriend);\n                col.database.destroy();\n            });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"#222 population not working when multiInstance: false","suites":["issues"],"updatePoint":{"line":297,"column":65},"line":297,"code":"        it('#222 population not working when multiInstance: false', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n                multiInstance: false // this must be false here\n            });\n            const cols = await db.addCollections({\n                doca: {\n                    schema: {\n                        type: 'object',\n                        primaryKey: 'name',\n                        version: 0,\n                        properties: {\n                            name: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            refB: {\n                                ref: 'docb', // refers to collection human\n                                type: 'string' // ref-values must always be string (primary of foreign RxDocument)\n                            }\n                        }\n                    }\n                },\n                docb: {\n                    schema: {\n                        version: 0,\n                        primaryKey: 'name',\n                        type: 'object',\n                        properties: {\n                            name: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            somevalue: {\n                                type: 'string'\n                            }\n                        }\n                    }\n                }\n            });\n            const colA = cols.doca;\n            const colB = cols.docb;\n\n            await colB.insert({\n                name: 'docB-01',\n                somevalue: 'foobar'\n            });\n            await colA.insert({\n                name: 'docA-01',\n                refB: 'docB-01'\n            });\n\n            const docA = await colA.findOne().where('name').eq('docA-01').exec();\n            const docB = await docA.populate('refB');\n\n            assert.ok(isRxDocument(docB));\n            assert.strictEqual(docB.somevalue, 'foobar');\n\n            db.destroy();\n        });","file":"unit/population.test.ts","skipped":false,"dir":"test"},{"name":"should export the pouchDB-module","suites":["init"],"updatePoint":{"line":37,"column":44},"line":37,"code":"        it('should export the pouchDB-module', () => {\n            addPouchPlugin(PouchReplicationPlugin);\n            assert.strictEqual(typeof PouchDB, 'function');\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"must be able to insert->update->delete via replication","suites":["assumptions"],"updatePoint":{"line":43,"column":66},"line":43,"code":"        it('must be able to insert->update->delete via replication', async () => {\n            addPouchPlugin(require('pouchdb-adapter-memory'));\n            addPouchPlugin(PouchDBFind);\n\n            const pouch1: PouchDBInstance = new PouchDB('foobar1' + randomCouchString(10), {\n                adapter: 'memory'\n            });\n            const pouch2: PouchDBInstance = new PouchDB('foobar2' + randomCouchString(10), {\n                adapter: 'memory'\n            });\n            const syncHandler = pouch1.sync(pouch2, {\n                live: true\n            });\n\n            const docData: any = {\n                _id: 'syncMe',\n                value: 1\n            };\n            async function getDocsFromPouch2() {\n                const allDocs = await pouch2.find({\n                    selector: {}\n                });\n                return allDocs.docs;\n            }\n\n            // insert\n            const insertResult = await pouch1.put(clone(docData));\n            docData._rev = insertResult.rev;\n\n            await AsyncTestUtil.waitUntil(async () => {\n                const allDocs = await getDocsFromPouch2();\n                return allDocs.length === 1;\n            });\n\n            // update\n            docData.value = 2;\n            const updateResult = await pouch1.put(clone(docData));\n            docData._rev = updateResult.rev;\n\n            await AsyncTestUtil.waitUntil(async () => {\n                const allDocs = await getDocsFromPouch2();\n                return allDocs.length === 1 && (allDocs[0] as any).value === 2;\n            });\n\n            // delete\n            docData._deleted = true;\n            const deleteResult = await pouch1.put(clone(docData));\n            assert.ok(deleteResult);\n            await AsyncTestUtil.waitUntil(async () => {\n                const allDocs = await getDocsFromPouch2();\n                return allDocs.length === 0;\n            });\n\n            // undelete via insert\n            const undeleteResult = await pouch1.put({\n                _id: 'syncMe',\n                value: 5\n            });\n            assert.ok(undeleteResult);\n            await AsyncTestUtil.waitUntil(async () => {\n                const allDocs = await getDocsFromPouch2();\n                return allDocs.length === 1 && (allDocs[0] as any).value === 5;\n            });\n\n            await syncHandler.cancel();\n            await promiseWait(100);\n            await pouch1.close();\n            await pouch2.close();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"must be able to insert->update->delete via new_edits:false","suites":["assumptions"],"updatePoint":{"line":112,"column":70},"line":112,"code":"        it('must be able to insert->update->delete via new_edits:false', async () => {\n            const pouch: PouchDBInstance = new PouchDB('foobar' + randomCouchString(10), {\n                adapter: 'memory'\n            });\n            const docId = 'foobar';\n\n            // insert\n            await pouch.bulkDocs({\n                docs: [{\n                    _id: docId,\n                    value: 1,\n                    _rev: '1-51b2fae5721cc4d3cf7392f19e6cc118'\n                }]\n            }, {\n                new_edits: false\n            });\n\n            // update\n            let getDocs = await pouch.bulkGet({\n                docs: [{ id: docId }],\n                revs: true,\n                latest: true\n            });\n            let useRevs = (getDocs as any).results[0].docs[0].ok._revisions;\n            useRevs.start = useRevs.start + 1;\n            useRevs.ids.unshift('a723631364fbfa906c5ffa8203ac9725');\n\n            await pouch.bulkDocs({\n                docs: [{\n                    _id: docId,\n                    value: 2,\n                    _rev: '2-a723631364fbfa906c5ffa8203ac9725',\n                    _revisions: useRevs\n                }]\n            }, {\n                new_edits: false\n            });\n\n            // delete\n            getDocs = await pouch.bulkGet({\n                docs: [{ id: docId }],\n                revs: true,\n                latest: true\n            });\n            useRevs = (getDocs as any).results[0].docs[0].ok._revisions;\n            useRevs.start = useRevs.start + 1;\n            useRevs.ids.unshift('13af8c9a835820969a8a273b18783a70');\n\n            await pouch.bulkDocs({\n                docs: [{\n                    _id: docId,\n                    value: 2,\n                    _deleted: true,\n                    _rev: '3-13af8c9a835820969a8a273b18783a70',\n                    _revisions: useRevs\n                }]\n            }, {\n                new_edits: false\n            });\n\n            let allDocs = await pouch.find({\n                selector: {}\n            });\n            assert.strictEqual(allDocs.docs.length, 0);\n\n            // undelete via insert\n            getDocs = await pouch.bulkGet({\n                docs: [{ id: docId }],\n                revs: true,\n                latest: true\n            });\n\n            const getDocs2 = await pouch.bulkGet({\n                docs: [{ id: docId, rev: '3-13af8c9a835820969a8a273b18783a70' }],\n                revs: true,\n                latest: true\n            });\n\n            useRevs = (getDocs2 as any).results[0].docs[0].ok._revisions;\n            useRevs.start = 1;\n            useRevs.ids.unshift('14af8c9a835820969a8a273b18783a70');\n            await pouch.bulkDocs({\n                docs: [{\n                    _id: docId,\n                    value: 5,\n                    _deleted: false,\n                    _rev: '1-14af8c9a835820969a8a273b18783a70',\n                    _revisions: useRevs\n                }]\n            }, {\n                new_edits: false\n            });\n\n\n            // must be found via query\n            allDocs = await pouch.find({\n                selector: {\n                    _id: docId\n                },\n                limit: 1\n            });\n            assert.strictEqual(allDocs.docs.length, 1);\n            assert.strictEqual((allDocs.docs[0] as any).value, 5);\n\n            // same via .get\n            const getDoc = await pouch.get(docId);\n            assert.strictEqual(getDoc.value, 5);\n\n            pouch.close();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"should not allow leveldown-adapters without the plugin","suites":["memdown"],"updatePoint":{"line":224,"column":66},"line":224,"code":"        it('should not allow leveldown-adapters without the plugin', async () => {\n            await AsyncTestUtil.assertThrows(\n                () => createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch(memdown)\n                }),\n                'RxError',\n                'leveldb-plugin'\n            );\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"should work after adding the leveldb-plugin","suites":["memdown"],"updatePoint":{"line":234,"column":55},"line":234,"code":"        it('should work after adding the leveldb-plugin', async () => {\n            if (!config.platform.isNode()) {\n                return;\n            }\n            PouchDB.plugin(leveldb);\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch(memdown)\n            });\n            assert.ok(isRxDatabase(db));\n            db.destroy();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"should work when adapter was added","suites":["pouchdb-adapter-memory"],"updatePoint":{"line":248,"column":46},"line":248,"code":"        it('should work when adapter was added', async () => {\n            addPouchPlugin(require('pouchdb-adapter-memory'));\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory')\n            });\n            assert.ok(isRxDatabase(db));\n            db.destroy();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"should crash because nodejs has no localstorage","suites":["localstorage"],"updatePoint":{"line":259,"column":59},"line":259,"code":"        it('should crash because nodejs has no localstorage', async () => {\n            if (!config.platform.isNode()) return;\n            PouchDB.plugin(require('pouchdb-adapter-localstorage'));\n            await AsyncTestUtil.assertThrows(\n                () => createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('localstorage')\n                }),\n                'RxError',\n                'Adapter'\n            );\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"should fail when no adapter was added","suites":["websql","negative"],"updatePoint":{"line":274,"column":53},"line":274,"code":"            it('should fail when no adapter was added', async () => {\n                await AsyncTestUtil.assertThrows(\n                    () => createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('websql')\n                    }),\n                    'RxError',\n                    'Adapter'\n                );\n            });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"should work after adding the adapter","suites":["websql","positive"],"updatePoint":{"line":286,"column":52},"line":286,"code":"            it('should work after adding the adapter', async () => {\n                // test websql on chrome only\n                if (config.platform.name !== 'chrome') return;\n\n                addPouchPlugin(require('pouchdb-adapter-websql'));\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('websql')\n                });\n                assert.ok(isRxDatabase(db));\n                await promiseWait(10);\n                db.destroy();\n            });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"_local documents should not be cached by pouchdb","suites":["BUGS: pouchdb"],"updatePoint":{"line":302,"column":60},"line":302,"code":"        it('_local documents should not be cached by pouchdb', async () => {\n            const name = randomCouchString(10);\n            const _id = '_local/foobar';\n            function createPouch(): PouchDBInstance {\n                const pouch = new PouchDB(\n                    name, {\n                    adapter: 'memory',\n                    auto_compaction: true,\n                    revs_limit: 1\n                }\n                ) as any;\n                return pouch;\n            }\n            const pouch1 = createPouch();\n            const pouch2 = createPouch();\n            await AsyncTestUtil.assertThrows(\n                () => pouch2.get(_id),\n                'PouchError'\n            );\n            // insert\n            await pouch1.put({\n                _id,\n                value: 'foo'\n            });\n            const doc2 = await pouch2.get(_id);\n            assert.strictEqual(doc2.value, 'foo');\n\n            pouch1.destroy();\n            pouch2.destroy();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"pouchdb.find() should not return design-docs","suites":["BUGS: pouchdb"],"updatePoint":{"line":335,"column":56},"line":335,"code":"        it('pouchdb.find() should not return design-docs', async () => {\n            const pouch = new PouchDB(\n                randomCouchString(10), {\n                adapter: 'memory',\n                auto_compaction: true,\n                revs_limit: 1\n            }\n            );\n\n            await pouch.createIndex({\n                index: {\n                    fields: ['foo']\n                }\n            });\n\n            // add one doc\n            await pouch.put({\n                _id: 'asdf',\n                foo: 'bar'\n            });\n\n            // get docs\n            const docs = await pouch.find({\n                selector: {\n                    foo: {\n                        $ne: null\n                    }\n                }\n            });\n\n            assert.strictEqual(docs.docs.length, 1);\n\n            pouch.destroy();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"removing via bulkDocs does not work","suites":["BUGS: pouchdb"],"updatePoint":{"line":369,"column":47},"line":369,"code":"        it('removing via bulkDocs does not work', async () => {\n            const pouch: PouchDBInstance = new PouchDB(\n                randomCouchString(10), {\n                adapter: 'memory',\n                auto_compaction: true,\n                revs_limit: 1\n            }\n            ) as any;\n\n            // add one doc\n            await pouch.put({\n                _id: 'foobar',\n                foo: 'bar'\n            });\n\n            // overwrite via bulkDocs\n            const bulkOptions = {\n                new_edits: false\n            };\n            await pouch.bulkDocs({\n                docs: [{\n                    _id: 'foobar',\n                    foo: 'bar',\n                    _rev: '2-6c5d4399ffe848f395069eab42630eee'\n                }]\n            }, bulkOptions);\n\n            // find again\n            const foundAfter = await pouch.find({\n                selector: {}\n            });\n            assert.ok(foundAfter.docs[0]._rev.startsWith('2-')); // ok\n\n            // delete via bulkDocs\n            const x = await pouch.put({\n                _id: 'foobar',\n                foo: 'bar',\n                _rev: '3-13af8c9a835820969a8a273b18783a70',\n                _deleted: true\n            }, bulkOptions);\n            assert.strictEqual((x as any).length, 0);\n\n            /**\n             * If this test ever throws, it means we can remove the hacky workarround in\n             * src/plugins/in-memory.js\n             * Where we add the emitFlag to 'doNotEmitSet'\n             */\n            await AsyncTestUtil.assertThrows(\n                async () => {\n                    const foundAfter2 = await pouch.find({\n                        selector: {}\n                    });\n                    assert.ok(foundAfter2.docs[0]._rev.startsWith('3-'));\n                },\n                'AssertionError'\n            );\n\n            pouch.destroy();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"putting with _deleted does not work","suites":["BUGS: pouchdb"],"updatePoint":{"line":428,"column":47},"line":428,"code":"        it('putting with _deleted does not work', async () => {\n            const pouch: PouchDBInstance = new PouchDB(\n                randomCouchString(10), {\n                adapter: 'memory',\n                auto_compaction: true,\n                revs_limit: 1\n            }\n            ) as any;\n            const bulkOptions = {\n                new_edits: false\n            };\n\n            // subscribe to changes 2 times\n            pouch.changes({\n                since: 'now',\n                live: true,\n                include_docs: true\n            });\n            pouch.changes({\n                since: 'now',\n                live: true,\n                include_docs: true\n            });\n\n            // insert doc via bulkDocs\n            const docs = [{\n                '|c': '0waqyh2xjwtu',\n                '|a': 'foo123',\n                '|b': 'King',\n                age: 1,\n                _id: 'myid',\n                _rev: '1-62080c42d471e3d2625e49dcca3b8e3e'\n            }];\n            await pouch.bulkDocs({\n                docs\n            }, bulkOptions);\n\n            let foundAfter = await pouch.find<{ firstName: string, _deleted: boolean }>({\n                selector: {}\n            });\n            assert.strictEqual(foundAfter.docs.length, 1);\n\n\n            // update via bulkDocs\n            const updateMe = foundAfter.docs[0];\n            updateMe.firstName = 'foobar';\n            await pouch.bulkDocs({\n                docs: [updateMe]\n            }, bulkOptions);\n\n            // remove\n            foundAfter = await pouch.find({\n                selector: {}\n            });\n            const removeMe = foundAfter.docs[0];\n            removeMe._deleted = true;\n            await pouch.get('myid').catch(() => null);\n            await pouch.put(removeMe);\n\n            await AsyncTestUtil.wait(100);\n\n            foundAfter = await pouch.find({\n                selector: {}\n            });\n            assert.strictEqual(foundAfter.docs.length, 0);\n\n\n            pouch.destroy();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"put->delete-put will find the previous document","suites":["BUGS: pouchdb"],"updatePoint":{"line":497,"column":59},"line":497,"code":"        it('put->delete-put will find the previous document', async () => {\n            const pouch: PouchDBInstance = new PouchDB(\n                randomCouchString(10),\n                {\n                    adapter: 'memory'\n                }\n            ) as any;\n            const BULK_DOC_OPTIONS = {\n                new_edits: false\n            };\n\n            const docData: any = schemaObjects.human();\n            docData['_id'] = 'foobar1';\n            const ret = await pouch.put(docData);\n\n            await AsyncTestUtil.wait(100);\n\n            const docData2: any = clone(docData);\n            docData2._rev = ret.rev;\n            docData2._deleted = true;\n\n            await pouch.bulkDocs({\n                docs: [docData2]\n            }, BULK_DOC_OPTIONS);\n\n            await AsyncTestUtil.wait(100);\n\n            /**\n             * If this test ever throws, it means we can remove the hacky workarround in\n             * src/plugins/in-memory.js\n             * Where we add the emitFlag to 'doNotEmitSet'\n             */\n            await AsyncTestUtil.assertThrows(\n                async () => {\n                    const foundAfter2 = await pouch.find({\n                        selector: {}\n                    });\n                    assert.strictEqual(foundAfter2.docs.length, 0);\n                },\n                'AssertionError'\n            );\n\n            pouch.destroy();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"should handle writes before reads (first insert then find)","suites":["BUGS: pouchdb"],"updatePoint":{"line":541,"column":70},"line":541,"code":"        it('should handle writes before reads (first insert then find)', async () => {\n            const amount = 20;\n            const pouches: PouchDBInstance[] = [];\n            const results: any[] = [];\n\n            let t = 0;\n            while (t < amount) {\n                t++;\n                const pouch: PouchDBInstance = new PouchDB(\n                    randomCouchString(10), {\n                    adapter: 'memory'\n                }) as any;\n                pouches.push(pouch);\n\n                // do not await\n                pouch.put({\n                    _id: 'foobar',\n                    passportId: 'z3i7q29g4yr1',\n                    firstName: 'Edison',\n                    lastName: 'Keebler',\n                    age: 24\n                });\n                const res = await pouch.find({\n                    selector: {}\n                });\n                results.push(res);\n            }\n\n            results.forEach(res => {\n                assert.strictEqual(res.docs.length, 1);\n            });\n\n            pouches.forEach(pouch => pouch.destroy());\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"should handle writes before reads (first find then insert)","suites":["BUGS: pouchdb"],"updatePoint":{"line":575,"column":70},"line":575,"code":"        it('should handle writes before reads (first find then insert)', async () => {\n            const amount = 20;\n            const promises: Promise<any>[] = [];\n            const pouches: PouchDBInstance[] = [];\n\n            while (promises.length < amount) {\n                const pouch: PouchDBInstance = new PouchDB(\n                    randomCouchString(10), {\n                    adapter: 'memory'\n                }) as any;\n                pouches.push(pouch);\n\n                promises.push(pouch.find({\n                    selector: {}\n                }));\n                await pouch.put({\n                    _id: 'foobar',\n                    passportId: 'z3i7q29g4yr1',\n                    firstName: 'Edison',\n                    lastName: 'Keebler',\n                    age: 24\n                });\n            }\n\n            const results = await Promise.all(promises);\n\n            results.forEach(res => {\n                assert.strictEqual(res.docs.length, 1);\n            });\n            pouches.forEach(pouch => pouch.destroy());\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"re-saving an attachment fails in browsers","suites":["BUGS: pouchdb"],"updatePoint":{"line":606,"column":53},"line":606,"code":"        it('re-saving an attachment fails in browsers', async () => {\n            const pouch1: PouchDBInstance = new PouchDB(\n                randomCouchString(10),\n                {\n                    adapter: 'memory'\n                }\n            );\n\n            const text = 'lorem ipsum dolor';\n            const mimeType = 'text/plain';\n            const blobBuffer = blobBufferUtil.createBlobBuffer(text, {\n                type: mimeType\n            } as any);\n\n            // insert a document with attachment\n            const docId = 'foobar';\n            const attachmentId = 'myattachment';\n            const putRes = await pouch1.put({ _id: docId });\n            const attachmentDataAsBase64 = await blobBufferUtil.toBase64String(blobBuffer);\n            await pouch1.putAttachment(\n                docId,\n                attachmentId,\n                putRes.rev,\n                attachmentDataAsBase64,\n                mimeType\n            );\n\n\n            const rawAttachmentData = await pouch1.getAttachment(docId, attachmentId);\n\n            const pouch2: PouchDBInstance = new PouchDB(\n                randomCouchString(10),\n                {\n                    adapter: 'memory'\n                }\n            );\n            await pouch2.bulkDocs([\n                {\n                    _attachments: {\n                        [attachmentId]: {\n                            content_type: 'text/plain',\n                            data: rawAttachmentData\n                        }\n                    },\n                    _rev: '2-7a51240884063593468f396a29db001f',\n                    _id: 'foobar2',\n                }\n            ], {\n                new_edits: false\n            });\n\n            pouch1.destroy();\n            pouch2.destroy();\n        });","file":"unit/pouch-db-integration.test.ts","skipped":false,"dir":"test"},{"name":"use in schema","suites":["Schema",".create()","positive"],"updatePoint":{"line":28,"column":33},"line":28,"code":"                it('use in schema', () => {\n                    const schema = createRxSchema(schemas.primaryHuman);\n                    assert.strictEqual(typeof schema.primaryPath, 'string');\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"throw if primary is also index","suites":["Schema",".create()","negative"],"updatePoint":{"line":34,"column":50},"line":34,"code":"                it('throw if primary is also index', () => {\n                    const schemaObj = clone(schemas.primaryHuman);\n                    schemaObj.indexes = [\n                        'passportId'\n                    ];\n                    assert.throws(() => createRxSchema(schemaObj), Error);\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"throw if primary is also unique","suites":["Schema",".create()","negative"],"updatePoint":{"line":41,"column":51},"line":41,"code":"                it('throw if primary is also unique', () => {\n                    const schemaObj: any = clone(schemas.primaryHuman);\n                    schemaObj.properties.passportId['unique'] = true;\n                    assert.throws(() => createRxSchema(schemaObj), Error);\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"throw if primary is no string","suites":["Schema",".create()","negative"],"updatePoint":{"line":46,"column":49},"line":46,"code":"                it('throw if primary is no string', () => {\n                    const schemaObj = clone(schemas.primaryHuman);\n                    schemaObj.properties.passportId.type = 'integer';\n                    assert.throws(() => createRxSchema(schemaObj), Error);\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"throw if primary is encrypted","suites":["Schema",".create()","negative"],"updatePoint":{"line":51,"column":49},"line":51,"code":"                it('throw if primary is encrypted', () => {\n                    const schemaObj = clone(schemas.primaryHuman);\n                    (schemaObj.properties.passportId as any).encrypted = true;\n                    assert.throws(() => createRxSchema(schemaObj), Error);\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"should insert a human","suites":["Collection",".insert()","positive"],"updatePoint":{"line":62,"column":41},"line":62,"code":"                it('should insert a human', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const obj = schemaObjects.simpleHuman();\n                    await c.insert(obj);\n                    const docInStorage = await c.storageInstance.findDocumentsById([obj.passportId], false);\n                    const first = getFromObjectOrThrow(docInStorage, obj.passportId);\n                    assert.strictEqual(obj.passportId, first.passportId);\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"throw on duplicate primary","suites":["Collection",".insert()","negative"],"updatePoint":{"line":73,"column":46},"line":73,"code":"                it('throw on duplicate primary', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const obj = schemaObjects.simpleHuman();\n                    await c.insert(obj);\n                    const obj2 = schemaObjects.simpleHuman();\n                    obj2.passportId = obj.passportId;\n                    await AsyncTestUtil.assertThrows(\n                        () => c.insert(obj2),\n                        'RxError',\n                        'conflict'\n                    );\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"find the inserted doc","suites":["Collection",".find()","positive"],"updatePoint":{"line":90,"column":41},"line":90,"code":"                it('find the inserted doc', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const obj = schemaObjects.simpleHuman();\n                    await c.insert(obj);\n                    const docs = await c.find().exec();\n                    assert.strictEqual(docs.length, 1);\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"find by primary","suites":["Collection",".find()","positive"],"updatePoint":{"line":98,"column":35},"line":98,"code":"                it('find by primary', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const obj = schemaObjects.simpleHuman();\n                    await c.insert(obj);\n                    const docs = await c.find({\n                        selector: {\n                            passportId: obj.passportId\n                        }\n                    }).exec();\n                    assert.strictEqual(docs.length, 1);\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"sort by primary","suites":["Collection",".find()","positive"],"updatePoint":{"line":110,"column":35},"line":110,"code":"                it('sort by primary', async () => {\n                    const c = await humansCollection.createPrimary(5);\n                    const docsASC = await c.find().sort({\n                        passportId: 'asc'\n                    }).exec();\n                    const docsDESC = await c.find().sort({\n                        passportId: 'desc'\n                    }).exec();\n                    assert.strictEqual(docsASC.length, 5);\n                    assert.strictEqual(docsDESC.length, 5);\n                    assert.strictEqual(\n                        docsASC[0].firstName,\n                        (docsDESC.pop() as any).firstName\n                    );\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"find the doc","suites":["Collection",".findOne()","positive"],"updatePoint":{"line":131,"column":32},"line":131,"code":"                it('find the doc', async () => {\n                    const c = await humansCollection.createPrimary(6);\n                    const obj = schemaObjects.simpleHuman();\n                    await c.insert(obj);\n                    const doc = await c.findOne(obj.passportId).exec(true);\n                    assert.strictEqual(doc.primary, obj.passportId);\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"find nothing","suites":["Collection",".findOne()","positive"],"updatePoint":{"line":139,"column":32},"line":139,"code":"                it('find nothing', async () => {\n                    const c = await humansCollection.createPrimary(10);\n                    const doc = await c.findOne('foobar').exec();\n                    assert.strictEqual(doc, null);\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"find with more selectors","suites":["Collection",".findOne()","positive"],"updatePoint":{"line":145,"column":44},"line":145,"code":"                it('find with more selectors', async () => {\n                    const c = await humansCollection.createPrimary(6);\n                    const obj = schemaObjects.simpleHuman();\n                    obj.firstName = randomCouchString(10);\n                    await c.insert(obj);\n                    const doc = await c.findOne({\n                        selector: {\n                            firstName: obj.firstName\n                        }\n                    }).exec(true);\n                    assert.strictEqual(doc.primary, obj.passportId);\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"BUG: findOne().where(myPrimary)","suites":["Collection",".findOne()","positive"],"updatePoint":{"line":158,"column":51},"line":158,"code":"                it('BUG: findOne().where(myPrimary)', async () => {\n                    const c = await humansCollection.createPrimary(1);\n                    const doc = await c.findOne().exec(true);\n                    const passportId = doc.passportId;\n                    assert.ok(passportId.length > 4);\n                    const doc2 = await c.findOne().where('passportId').eq(passportId).exec(true);\n                    assert.ok(isRxDocument(doc2));\n                    assert.strictEqual(doc.passportId, doc2.passportId);\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"get the primary value","suites":["Document",".get()","positive"],"updatePoint":{"line":175,"column":41},"line":175,"code":"                it('get the primary value', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const obj = schemaObjects.simpleHuman();\n                    await c.insert(obj);\n                    const doc = await c.findOne().exec(true);\n                    assert.strictEqual(obj.passportId, doc.get('passportId'));\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"save an edited doc with a primary","suites":["Document",".save()","positive"],"updatePoint":{"line":188,"column":53},"line":188,"code":"                it('save an edited doc with a primary', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const obj = schemaObjects.simpleHuman();\n                    await c.insert(obj);\n                    const doc = await c.findOne().exec(true);\n                    await doc.atomicPatch({ firstName: 'foobar' });\n                    const doc2 = await c.findOne().exec(true);\n\n                    assert.strictEqual(doc2.get('firstName'), 'foobar');\n                    assert.strictEqual(doc.get('passportId'), doc2.get('passportId'));\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"subscribe to one field","suites":["Document",".subscribe()","positive"],"updatePoint":{"line":205,"column":42},"line":205,"code":"                it('subscribe to one field', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const obj = schemaObjects.simpleHuman();\n                    await c.insert(obj);\n                    const doc = await c.findOne().exec(true);\n                    let value;\n                    const sub = doc.get$('firstName').subscribe((newVal: any) => value = newVal);\n                    await doc.atomicPatch({ firstName: 'foobar' });\n                    await promiseWait(10);\n                    assert.strictEqual(value, 'foobar');\n                    sub.unsubscribe();\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"subscribe to query","suites":["Document",".subscribe()","positive"],"updatePoint":{"line":218,"column":38},"line":218,"code":"                it('subscribe to query', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    let docs: any[];\n                    const sub = c.find().$.subscribe(newDocs => {\n                        docs = newDocs;\n                    });\n                    await AsyncTestUtil.waitUntil(() => !!docs);\n                    await c.insert(schemaObjects.simpleHuman());\n                    await AsyncTestUtil.waitUntil(() => {\n                        if (docs) {\n                            if (docs.length === 1) {\n                                return true;\n                            }\n                            if (docs.length > 1) {\n                                throw new Error('too many documents');\n                            }\n                        }\n                        return false;\n                    });\n                    sub.unsubscribe();\n                    c.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"get event on db2 when db1 fires","suites":["Document",".subscribe()","positive"],"updatePoint":{"line":240,"column":51},"line":240,"code":"                it('get event on db2 when db1 fires', async () => {\n                    if (!config.storage.hasMultiInstance) {\n                        return;\n                    }\n                    const name = randomCouchString(10);\n                    const c1 = await humansCollection.createPrimary(0, name);\n                    const c2 = await humansCollection.createPrimary(0, name);\n                    let docs: any[] = [];\n                    c2.find().$.subscribe(newDocs => {\n                        docs = newDocs;\n                    });\n                    await promiseWait(50);\n                    await c1.insert(schemaObjects.simpleHuman());\n                    await promiseWait(1000);\n                    await AsyncTestUtil.waitUntil(() => {\n                        if (docs.length > 1) {\n                            throw new Error('got too much documents');\n                        }\n                        return docs.length === 1\n                    });\n\n                    c1.database.destroy();\n                    c2.database.destroy();\n                });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"should not throw when creating a collection with composite primary","suites":["Composite Primary"],"updatePoint":{"line":281,"column":78},"line":281,"code":"        it('should not throw when creating a collection with composite primary', async () => {\n            const col = await getCompositePrimaryCollection();\n            assert.ok(col);\n            col.database.destroy();\n        });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"insert/update/delete a document","suites":["Composite Primary"],"updatePoint":{"line":286,"column":43},"line":286,"code":"        it('insert/update/delete a document', async () => {\n            const col = await getCompositePrimaryCollection();\n            assert.ok(col);\n\n            // insert\n            const doc = await col.insert(humanWithCompositePrimary());\n\n            // update\n            await doc.atomicPatch({ lastName: 'alice' });\n\n            // remove\n            await doc.remove();\n\n\n            col.database.destroy();\n        });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":".atomicUpsert()","suites":["Composite Primary"],"updatePoint":{"line":302,"column":27},"line":302,"code":"        it('.atomicUpsert()', async () => {\n            const col = await getCompositePrimaryCollection();\n            assert.ok(col);\n\n            const data = humanWithCompositePrimary();\n\n            await col.atomicUpsert(data);\n            await col.atomicUpsert(data);\n\n            col.database.destroy();\n        });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":".upsert()","suites":["Composite Primary"],"updatePoint":{"line":313,"column":21},"line":313,"code":"        it('.upsert()', async () => {\n            const col = await getCompositePrimaryCollection();\n            assert.ok(col);\n\n            const data = humanWithCompositePrimary();\n\n            await col.upsert(data);\n            await col.upsert(data);\n\n            col.database.destroy();\n        });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"should throw when a primary related field is changed","suites":["Composite Primary"],"updatePoint":{"line":324,"column":64},"line":324,"code":"        it('should throw when a primary related field is changed', async () => {\n            const col = await getCompositePrimaryCollection();\n            const doc = await col.insert(humanWithCompositePrimary());\n\n            await AsyncTestUtil.assertThrows(\n                () => doc.atomicPatch({ firstName: 'foobar' }),\n                'RxError',\n                'final fields'\n            );\n\n            col.database.destroy();\n        });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"find via composite primary","suites":["Composite Primary"],"updatePoint":{"line":336,"column":38},"line":336,"code":"        it('find via composite primary', async () => {\n            const col = await getCompositePrimaryCollection();\n            assert.ok(col);\n\n            // insert\n            const insertData = humanWithCompositePrimary();\n            const doc = await col.insert(insertData);\n\n            // find\n            const id = col.schema.getPrimaryOfDocumentData({\n                firstName: insertData.firstName,\n                info: {\n                    age: insertData.info.age\n                }\n            });\n\n            const found = await col.findOne(id).exec(true);\n            assert.ok(found === doc);\n\n            col.database.destroy();\n        });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"#3546 Compound primary key migration throws \"Value of primary key(s) cannot be changed\"","suites":["issues"],"updatePoint":{"line":359,"column":99},"line":359,"code":"        it('#3546 Compound primary key migration throws \"Value of primary key(s) cannot be changed\"', async () => {\n            // create a schema\n            const getSchema = (version: number) => {\n                const ret: RxJsonSchema<any> = {\n                    version,\n                    primaryKey: {\n                        key: 'id',\n                        fields: ['b_firstName', 'a_lastName'],\n                        separator: '|',\n                    },\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 200\n                        },\n                        passportId: {\n                            type: 'string',\n                        },\n                        b_firstName: {\n                            type: 'string',\n                        },\n                        a_lastName: {\n                            type: 'string',\n                        },\n                        age: {\n                            type: 'integer',\n                            minimum: 0,\n                            maximum: 150,\n                        }\n                    }\n                };\n                return ret;\n            };\n\n            // generate a random database-name\n            const name = randomCouchString(10);\n\n            // create a database\n            const db = await createRxDatabase({\n                name,\n                storage: getRxStoragePouch('memory'),\n                eventReduce: true,\n                ignoreDuplicate: true,\n            });\n            const collections = await db.addCollections({\n                mycollection: {\n                    schema: getSchema(0),\n                },\n            });\n\n            await collections.mycollection.insert({\n                passportId: 'foobar',\n                b_firstName: 'Bob',\n                a_lastName: 'Kelso',\n                age: 56,\n            });\n\n\n            const dbInOtherTab = await createRxDatabase({\n                name,\n                storage: getRxStoragePouch('memory'),\n                eventReduce: true,\n                ignoreDuplicate: true,\n            });\n\n            const collectionInOtherTab = await dbInOtherTab.addCollections({\n                mycollection: {\n                    schema: getSchema(1),\n                    migrationStrategies: {\n                        1: (oldDoc) => oldDoc,\n                    },\n                },\n            });\n\n            // find document after migration\n            await collectionInOtherTab.mycollection\n                .findOne()\n                .where('b_firstName')\n                .eq('Bob')\n                .exec(true);\n\n            await Promise.all([\n                db.destroy(),\n                dbInOtherTab.destroy()\n            ]);\n        });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"#3562 _id must be allowed as primaryKey","suites":["issues"],"updatePoint":{"line":446,"column":51},"line":446,"code":"        it('#3562 _id must be allowed as primaryKey', async () => {\n            const mySchema: RxJsonSchema<any> = {\n                version: 0,\n                primaryKey: '_id',\n                type: 'object',\n                properties: {\n                    _id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    firstName: {\n                        type: 'string'\n                    }\n                }\n            };\n\n            // generate a random database-name\n            const name = randomCouchString(10);\n\n            // create a database\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                eventReduce: true,\n                ignoreDuplicate: true\n            });\n            await db.addCollections({\n                mycollection: {\n                    schema: mySchema\n                }\n            });\n            const collection = db.mycollection;\n            await collection.insert({\n                _id: 'foobar',\n                firstName: 'Alice'\n            });\n            db.destroy();\n        });","file":"unit/primary.test.ts","skipped":false,"dir":"test"},{"name":"should make a basic roundtrip","suites":["NoSqlQueryBuilder"],"updatePoint":{"line":19,"column":41},"line":19,"code":"        it('should make a basic roundtrip', () => {\n            const startQuery: MangoQuery = {\n                selector: {\n                    age: {\n                        $gt: 4\n                    },\n                    name: {\n                        $ne: 'alice'\n                    }\n                },\n                sort: [{ name: 'asc' }, { lastname: 'desc' }],\n                skip: 3,\n                limit: 2\n            };\n\n            // check initial json\n            const builder: NoSqlQueryBuilder = createQueryBuilder(startQuery);\n            const initialJson = builder.toJSON();\n            assert.deepStrictEqual(startQuery, initialJson.query);\n\n            // check builded json\n            const builder2 = createQueryBuilder();\n            builder2\n                .where('age').gt(4)\n                .where('name').ne('alice')\n                .skip(startQuery.skip as number)\n                .limit(startQuery.limit as number)\n                .sort({ name: 'asc', lastname: 'desc' });\n            const buildedJson = builder2.toJSON();\n            assert.deepStrictEqual(startQuery, buildedJson.query);\n        });","file":"unit/query-builder.test.ts","skipped":false,"dir":"test"},{"name":"should work with only the selector","suites":["NoSqlQueryBuilder"],"updatePoint":{"line":50,"column":46},"line":50,"code":"        it('should work with only the selector', () => {\n            const startQuery: MangoQuery = {\n                selector: {\n                    age: {\n                        $gt: 5\n                    },\n                    name: {\n                        $ne: 'alice'\n                    }\n                }\n            };\n            // check initial json\n            const builder: NoSqlQueryBuilder = createQueryBuilder(startQuery);\n            const initialJson = builder.toJSON();\n            assert.deepStrictEqual(startQuery, initialJson.query);\n\n            // check builded json\n            const builder2 = createQueryBuilder();\n            builder2\n                .where('age').gt(5)\n                .where('name').ne('alice');\n            const buildedJson = builder2.toJSON();\n            assert.deepStrictEqual(startQuery, buildedJson.query);\n        });","file":"unit/query-builder.test.ts","skipped":false,"dir":"test"},{"name":"should have path","suites":["NoSqlQueryBuilder"],"updatePoint":{"line":74,"column":28},"line":74,"code":"        it('should have path', () => {\n            const path = 'foobar';\n            const builder2 = createQueryBuilder();\n            builder2\n                .where('age').gt(6)\n                .where('name').ne('alice')\n                .where(path);\n            const buildedJson = builder2.toJSON();\n            assert.strictEqual(buildedJson.path, path);\n        });","file":"unit/query-builder.test.ts","skipped":false,"dir":"test"},{"name":"should work with big equal number","suites":["NoSqlQueryBuilder"],"updatePoint":{"line":84,"column":45},"line":84,"code":"        it('should work with big equal number', () => {\n            const startQuery: MangoQuery = {\n                selector: {\n                    age: {\n                        $gt: -9999999999999999999999999999\n                    }\n                },\n                sort: [{ age: 'asc' }]\n            };\n            // check initial json\n            const builder: NoSqlQueryBuilder = createQueryBuilder(startQuery);\n            const initialJson = builder.toJSON();\n            assert.deepStrictEqual(startQuery, initialJson.query);\n\n            // check builded json\n            const builder2 = createQueryBuilder();\n            builder2\n                .where('age')\n                .gt(-9999999999999999999999999999)\n                .sort('age');\n            const buildedJson = builder2.toJSON();\n            assert.deepStrictEqual(startQuery, buildedJson.query);\n        });","file":"unit/query-builder.test.ts","skipped":false,"dir":"test"},{"name":"should find correct if the $gt value is lower then the minimum or higher then the maximum","suites":["$gt"],"updatePoint":{"line":65,"column":101},"line":65,"code":"        it('should find correct if the $gt value is lower then the minimum or higher then the maximum', async () => {\n            const collection = await getTestCollection();\n\n            await collection.insert({\n                id: 'A',\n                alwaysX: 'X',\n                age: 100\n            });\n            await collection.insert({\n                id: 'B',\n                alwaysX: 'X',\n                age: 150\n            });\n            await collection.insert({\n                id: 'C',\n                alwaysX: 'X',\n                age: 200\n            });\n\n            const lowerThenMin = await collection.find({\n                selector: {\n                    age: {\n                        $gt: 1\n                    }\n                }\n            }).exec();\n            assert.strictEqual(\n                lowerThenMin.length,\n                3\n            );\n\n            const higherThenMax = await collection.find({\n                selector: {\n                    age: {\n                        $gt: 300\n                    }\n                }\n            }).exec();\n            assert.strictEqual(\n                higherThenMax.length,\n                0\n            );\n            collection.database.destroy();\n        });","file":"unit/query-correctness.test.ts","skipped":false,"dir":"test"},{"name":"should find correct if the $lt value is lower then the minimum or higher then the maximum","suites":["$lt"],"updatePoint":{"line":111,"column":101},"line":111,"code":"        it('should find correct if the $lt value is lower then the minimum or higher then the maximum', async () => {\n            const collection = await getTestCollection();\n\n            await collection.insert({\n                id: 'A',\n                alwaysX: 'X',\n                age: 100\n            });\n            await collection.insert({\n                id: 'B',\n                alwaysX: 'X',\n                age: 150\n            });\n            await collection.insert({\n                id: 'C',\n                alwaysX: 'X',\n                age: 200\n            });\n\n            const lowerThenMin = await collection.find({\n                selector: {\n                    age: {\n                        $lt: 1\n                    }\n                }\n            }).exec();\n            assert.strictEqual(\n                lowerThenMin.length,\n                0\n            );\n\n            const higherThenMax = await collection.find({\n                selector: {\n                    age: {\n                        $lt: 300\n                    }\n                }\n            }).exec();\n            assert.strictEqual(\n                higherThenMax.length,\n                3\n            );\n            collection.database.destroy();\n        });","file":"unit/query-correctness.test.ts","skipped":false,"dir":"test"},{"name":"should use the index fields as default sort, if index is provided","suites":[".normalizeMangoQuery()","fill up the sort"],"updatePoint":{"line":35,"column":81},"line":35,"code":"            it('should use the index fields as default sort, if index is provided', () => {\n                const schema = getHumanSchemaWithIndexes([['age', 'firstName']]);\n                const query = normalizeMangoQuery<HumanDocumentType>(\n                    schema,\n                    {\n                        index: ['age', 'firstName']\n                    }\n                );\n                assert.deepStrictEqual(\n                    query.sort,\n                    [\n                        { age: 'asc' },\n                        { firstName: 'asc' },\n                        { passportId: 'asc' }\n                    ]\n                );\n            });","file":"unit/query-planner.test.ts","skipped":false,"dir":"test"},{"name":"should use the logical operators if no index is provided","suites":[".normalizeMangoQuery()","fill up the sort"],"updatePoint":{"line":52,"column":72},"line":52,"code":"            it('should use the logical operators if no index is provided', () => {\n                const schema = getHumanSchemaWithIndexes([\n                    ['age', 'firstName'],\n                    ['lastName', 'firstName']\n                ]);\n                const query = normalizeMangoQuery<HumanDocumentType>(\n                    schema,\n                    {\n                        selector: {\n                            age: {\n                                $gt: 20\n                            },\n                            firstName: {\n                                $gt: ''\n                            }\n                        }\n                    }\n                );\n                assert.deepStrictEqual(\n                    query.sort,\n                    [\n                        { age: 'asc' },\n                        { firstName: 'asc' },\n                        { passportId: 'asc' }\n                    ]\n                );\n            });","file":"unit/query-planner.test.ts","skipped":false,"dir":"test"},{"name":"should pick the default index when no indexes specified in the schema","suites":[".getQueryPlan()"],"updatePoint":{"line":82,"column":81},"line":82,"code":"        it('should pick the default index when no indexes specified in the schema', () => {\n            const schema = getHumanSchemaWithIndexes([]);\n            const query = normalizeMangoQuery<HumanDocumentType>(\n                schema,\n                {}\n            );\n            const queryPlan = getQueryPlan(\n                schema,\n                query\n            );\n            assert.deepStrictEqual(queryPlan.index, ['passportId']);\n        });","file":"unit/query-planner.test.ts","skipped":false,"dir":"test"},{"name":"should respect the given index","suites":[".getQueryPlan()"],"updatePoint":{"line":94,"column":42},"line":94,"code":"        it('should respect the given index', () => {\n            const customSetIndex = ['firstName'];\n            const schema = getHumanSchemaWithIndexes([customSetIndex]);\n            const query = normalizeMangoQuery<HumanDocumentType>(\n                schema,\n                {\n                    index: customSetIndex\n                }\n            );\n            const queryPlan = getQueryPlan(\n                schema,\n                query\n            );\n            assert.deepStrictEqual(queryPlan.index, ['firstName', 'passportId']);\n        });","file":"unit/query-planner.test.ts","skipped":false,"dir":"test"},{"name":"should have the correct start- and end keys","suites":[".getQueryPlan()"],"updatePoint":{"line":109,"column":55},"line":109,"code":"        it('should have the correct start- and end keys', () => {\n            const schema = getHumanSchemaWithIndexes([['age']]);\n            const query = normalizeMangoQuery<HumanDocumentType>(\n                schema,\n                {\n                    selector: {\n                        age: {\n                            $gte: 20\n                        }\n                    }\n                }\n            );\n            const queryPlan = getQueryPlan(\n                schema,\n                query\n            );\n            assert.deepStrictEqual(queryPlan.index, ['age', 'passportId']);\n            assert.strictEqual(queryPlan.startKeys[0], 20);\n            assert.strictEqual(queryPlan.endKeys[0], INDEX_MAX);\n            assert.ok(queryPlan.inclusiveStart);\n        });","file":"unit/query-planner.test.ts","skipped":false,"dir":"test"},{"name":"should use the best plan for an equals comparison","suites":[".getQueryPlan()"],"updatePoint":{"line":130,"column":61},"line":130,"code":"        it('should use the best plan for an equals comparison', () => {\n            const schema = getHumanSchemaWithIndexes([]);\n            const query = normalizeMangoQuery<HumanDocumentType>(\n                schema,\n                {\n                    selector: {\n                        passportId: 'asdf'\n                    }\n                }\n            );\n            const queryPlan = getQueryPlan(\n                schema,\n                query\n            );\n            assert.deepStrictEqual(queryPlan.index, ['passportId']);\n            assert.deepStrictEqual(queryPlan.startKeys[0], 'asdf');\n            assert.deepStrictEqual(queryPlan.endKeys[0], 'asdf');\n        });","file":"unit/query-planner.test.ts","skipped":false,"dir":"test"},{"name":"should prefer the default index over one that has no fields of the query","suites":["always prefer the better index"],"updatePoint":{"line":151,"column":84},"line":151,"code":"        it('should prefer the default index over one that has no fields of the query', () => {\n            const schema = getHumanSchemaWithIndexes([['firstName']]);\n            const query = normalizeMangoQuery<HumanDocumentType>(\n                schema,\n                {\n                    selector: {\n                        age: {\n                            $eq: 10\n                        }\n                    }\n                }\n            );\n            const queryPlan = getQueryPlan(\n                schema,\n                query\n            );\n            assert.deepStrictEqual(queryPlan.index, ['passportId']);\n        });","file":"unit/query-planner.test.ts","skipped":false,"dir":"test"},{"name":"should prefer the index that reduces the read-count by having a non-minimal startKey","suites":["always prefer the better index"],"updatePoint":{"line":169,"column":96},"line":169,"code":"        it('should prefer the index that reduces the read-count by having a non-minimal startKey', () => {\n            const schema = getHumanSchemaWithIndexes([\n                ['firstName', 'age'],\n                ['age', 'firstName']\n            ]);\n            const query = normalizeMangoQuery<HumanDocumentType>(\n                schema,\n                {\n                    selector: {\n                        age: {\n                            $eq: 10\n                        }\n                    }\n                }\n            );\n            const queryPlan = getQueryPlan(\n                schema,\n                query\n            );\n            assert.deepStrictEqual(queryPlan.index, ['age', 'firstName', 'passportId']);\n        });","file":"unit/query-planner.test.ts","skipped":false,"dir":"test"},{"name":"should prefer the index that matches the sort order, if no selector given","suites":["always prefer the better index"],"updatePoint":{"line":190,"column":85},"line":190,"code":"        it('should prefer the index that matches the sort order, if no selector given', () => {\n            const schema = getHumanSchemaWithIndexes([\n                ['firstName', 'age'],\n                ['age', 'firstName']\n            ]);\n            const query = normalizeMangoQuery<HumanDocumentType>(\n                schema,\n                {\n                    sort: [\n                        { age: 'asc' },\n                        { firstName: 'asc' }\n                    ]\n                }\n            );\n            const queryPlan = getQueryPlan(\n                schema,\n                query\n            );\n            assert.deepStrictEqual(queryPlan.index, ['age', 'firstName', 'passportId']);\n        });","file":"unit/query-planner.test.ts","skipped":false,"dir":"test"},{"name":"should prefer the index that matches the sort order, if selector for both fiels is used","suites":["always prefer the better index"],"updatePoint":{"line":210,"column":99},"line":210,"code":"        it('should prefer the index that matches the sort order, if selector for both fiels is used', () => {\n            const schema = getHumanSchemaWithIndexes([\n                ['firstName', 'age'],\n                ['age', 'firstName']\n            ]);\n            const query = normalizeMangoQuery<HumanDocumentType>(\n                schema,\n                {\n                    selector: {\n                        age: {\n                            $gt: 20\n                        },\n                        firstName: {\n                            $gt: 'aaa'\n                        }\n                    },\n                    sort: [\n                        { age: 'asc' },\n                        { firstName: 'asc' }\n                    ]\n                }\n            );\n            const queryPlan = getQueryPlan(\n                schema,\n                query\n            );\n            assert.deepStrictEqual(queryPlan.index, ['age', 'firstName', 'passportId']);\n        });","file":"unit/query-planner.test.ts","skipped":false,"dir":"test"},{"name":"should prefer indexing over the $eq operator over the $gt operator","suites":["always prefer the better index"],"updatePoint":{"line":238,"column":78},"line":238,"code":"        it('should prefer indexing over the $eq operator over the $gt operator', () => {\n            const schema = getHumanSchemaWithIndexes([\n                ['firstName', 'age'],\n                ['age', 'firstName']\n            ]);\n            const query = normalizeMangoQuery<HumanDocumentType>(\n                schema,\n                {\n                    selector: {\n                        age: {\n                            $gt: 20\n                        },\n                        firstName: {\n                            $eq: 'aaa'\n                        }\n                    },\n                    sort: [\n                        { age: 'asc' },\n                        { firstName: 'asc' }\n                    ]\n                }\n            );\n            const queryPlan = getQueryPlan(\n                schema,\n                query\n            );\n            assert.deepStrictEqual(queryPlan.index, ['firstName', 'age', 'passportId']);\n        });","file":"unit/query-planner.test.ts","skipped":false,"dir":"test"},{"name":"should have set sortFieldsSameAsIndexFields: false when order is desc","suites":["always prefer the better index"],"updatePoint":{"line":266,"column":81},"line":266,"code":"        it('should have set sortFieldsSameAsIndexFields: false when order is desc', () => {\n            const schema = getHumanSchemaWithIndexes([\n                ['firstName', 'age'],\n                ['age', 'firstName']\n            ]);\n            const query = normalizeMangoQuery<HumanDocumentType>(\n                schema,\n                {\n                    selector: {},\n                    sort: [\n                        { age: 'desc' },\n                        { firstName: 'asc' }\n                    ]\n                }\n            );\n            const queryPlan = getQueryPlan(\n                schema,\n                query\n            );\n\n            /**\n             * Because on a 'desc'-sorting no index can be used,\n             * it should use the default index.\n             */\n            assert.deepStrictEqual(queryPlan.index, ['passportId']);\n            assert.strictEqual(queryPlan.sortFieldsSameAsIndexFields, false);\n        });","file":"unit/query-planner.test.ts","skipped":false,"dir":"test"},{"name":"should get a valid event on insert","suites":[".insert()","positive"],"updatePoint":{"line":28,"column":50},"line":28,"code":"            it('should get a valid event on insert', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const colName = 'foobar';\n                const cols = await db.addCollections({\n                    [colName]: {\n                        schema: schemas.human\n                    }\n                });\n                const c = cols[colName];\n\n                c.insert(schemaObjects.human());\n                const changeEvent: RxChangeEvent<HumanDocumentType> = await c.$.pipe(first()).toPromise() as any;\n                assert.strictEqual(changeEvent.collectionName, colName);\n                assert.strictEqual(typeof changeEvent.documentId, 'string');\n                assert.ok(changeEvent.documentData);\n                db.destroy();\n            });","file":"unit/reactive-collection.test.ts","skipped":false,"dir":"test"},{"name":"should fire on bulk insert","suites":[".bulkInsert()","positive"],"updatePoint":{"line":52,"column":42},"line":52,"code":"            it('should fire on bulk insert', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const collections = await db.addCollections({\n                    human: {\n                        schema: schemas.primaryHuman\n                    }\n                });\n                const collection = collections.human;\n\n                const emittedCollection: RxChangeEvent<HumanDocumentType>[] = [];\n                const colSub = collection.insert$.subscribe((ce) => {\n                    emittedCollection.push(ce);\n                });\n\n                const docs = new Array(1).fill(0).map(() => schemaObjects.human());\n\n                await collection.bulkInsert(docs);\n\n                const changeEvent = emittedCollection[0];\n                assert.strictEqual(changeEvent.operation, 'INSERT');\n                assert.strictEqual(changeEvent.collectionName, 'human');\n                assert.strictEqual(changeEvent.documentId, docs[0].passportId);\n                assert.ok(changeEvent.documentData);\n\n                colSub.unsubscribe();\n                db.destroy();\n            });","file":"unit/reactive-collection.test.ts","skipped":false,"dir":"test"},{"name":"should fire on bulk remove","suites":[".bulkRemove()","positive"],"updatePoint":{"line":86,"column":42},"line":86,"code":"            it('should fire on bulk remove', async () => {\n                const c = await humansCollection.create(10);\n                const emittedCollection: RxChangeEvent<HumanDocumentType>[] = [];\n                const colSub = c.remove$.subscribe((ce) => {\n                    emittedCollection.push(ce);\n                });\n\n                const docList = await c.find().exec();\n                const primaryList = docList.map(doc => doc.primary);\n\n                await c.bulkRemove(primaryList);\n                const changeEvent = emittedCollection[0];\n\n                assert.strictEqual(changeEvent.operation, 'DELETE');\n                assert.strictEqual(changeEvent.collectionName, 'human');\n                assert.strictEqual(changeEvent.documentId, docList[0].primary);\n                assert.ok(changeEvent.documentData);\n                assert.ok(changeEvent.previousDocumentData);\n\n                colSub.unsubscribe();\n                c.database.destroy();\n            });","file":"unit/reactive-collection.test.ts","skipped":false,"dir":"test"},{"name":"should fire on remove","suites":[".remove()","positive"],"updatePoint":{"line":112,"column":37},"line":112,"code":"            it('should fire on remove', async () => {\n                const c = await humansCollection.create(0);\n                const q = c.find();\n                const ar: any[] = [];\n                const sub = q.$\n                    .subscribe(docs => {\n                        ar.push(docs);\n                    });\n\n                // nothing is fired until no results\n                assert.strictEqual(ar.length, 0);\n\n                // empty array since no documents\n                await AsyncTestUtil.waitUntil(() => ar.length === 1);\n\n                assert.deepStrictEqual(ar[0], []);\n\n                await c.insert(schemaObjects.human());\n                await AsyncTestUtil.waitUntil(() => ar.length === 2);\n\n                const doc: any = await c.findOne().exec();\n                await doc.remove();\n                await AsyncTestUtil.waitUntil(() => ar.length === 3);\n                sub.unsubscribe();\n\n                c.database.destroy();\n            });","file":"unit/reactive-collection.test.ts","skipped":false,"dir":"test"},{"name":"should only emit inserts","suites":[".insert$"],"updatePoint":{"line":142,"column":36},"line":142,"code":"        it('should only emit inserts', async () => {\n            const c = await humansCollection.create(0);\n\n            const emitted: RxChangeEvent<HumanDocumentType>[] = [];\n            c.insert$.subscribe(cE => emitted.push(cE as any));\n\n            await c.insert(schemaObjects.human());\n            const doc = await c.insert(schemaObjects.human());\n            await c.insert(schemaObjects.human());\n            await doc.remove();\n\n            await c.insert(schemaObjects.human());\n\n            await AsyncTestUtil.waitUntil(() => {\n                return emitted.length === 4;\n            });\n            emitted.forEach(cE => assert.strictEqual(cE.operation, 'INSERT'));\n            c.database.destroy();\n        });","file":"unit/reactive-collection.test.ts","skipped":false,"dir":"test"},{"name":"should only emit updates","suites":[".update$"],"updatePoint":{"line":163,"column":36},"line":163,"code":"        it('should only emit updates', async () => {\n            const c = await humansCollection.create(0);\n\n            const emitted: RxChangeEvent<HumanDocumentType>[] = [];\n            c.update$.subscribe(cE => emitted.push(cE as any));\n\n            const doc1 = await c.insert(schemaObjects.human());\n            const doc2 = await c.insert(schemaObjects.human());\n            const doc3 = await c.insert(schemaObjects.human());\n            await c.insert(schemaObjects.human());\n            await doc3.remove();\n\n            await doc1.atomicPatch({ firstName: 'foobar1' });\n            await doc2.atomicPatch({ firstName: 'foobar2' });\n\n            await AsyncTestUtil.waitUntil(() => emitted.length === 2);\n            emitted.forEach(cE => assert.strictEqual(cE.operation, 'UPDATE'));\n            c.database.destroy();\n        });","file":"unit/reactive-collection.test.ts","skipped":false,"dir":"test"},{"name":"should only emit removes","suites":[".remove$"],"updatePoint":{"line":184,"column":36},"line":184,"code":"        it('should only emit removes', async () => {\n            const c = await humansCollection.create(0);\n\n            const emitted: RxChangeEvent<HumanDocumentType>[] = [];\n            c.remove$.subscribe(cE => emitted.push(cE as any));\n            await c.insert(schemaObjects.human());\n            const doc1 = await c.insert(schemaObjects.human());\n            const doc2 = await c.insert(schemaObjects.human());\n            await doc1.remove();\n            await c.insert(schemaObjects.human());\n            await doc2.remove();\n\n\n            await AsyncTestUtil.waitUntil(() => emitted.length === 2);\n            emitted.forEach(cE => assert.strictEqual(cE.operation, 'DELETE'));\n            c.database.destroy();\n        });","file":"unit/reactive-collection.test.ts","skipped":false,"dir":"test"},{"name":"should fire on save","suites":[".save()","positive"],"updatePoint":{"line":34,"column":35},"line":34,"code":"            it('should fire on save', async () => {\n                const c = await humansCollection.create(1);\n                const doc = await c.findOne().exec(true);\n\n                const oldName = doc.firstName;\n                const newName = randomCouchString(8);\n\n                const emittedCollection: RxChangeEvent<HumanDocumentType>[] = [];\n                const colSub = c.$.subscribe(cE => {\n                    emittedCollection.push(cE);\n                });\n\n                await doc.atomicPatch({ firstName: newName });\n                await AsyncTestUtil.waitUntil(() => {\n                    const count = emittedCollection.length;\n                    if (count > 1) {\n                        throw new Error('too many events');\n                    } else {\n                        return emittedCollection.length === 1;\n                    }\n                });\n                const docDataAfter = await doc.$.pipe(first()).toPromise();\n                const changeEvent: any = emittedCollection[0];\n                assert.strictEqual(changeEvent.documentData.firstName, newName);\n                assert.strictEqual(changeEvent.previousDocumentData.firstName, oldName);\n\n\n                assert.strictEqual(docDataAfter.passportId, doc.primary);\n                assert.strictEqual(docDataAfter.passportId, doc.primary);\n                colSub.unsubscribe();\n                c.database.destroy();\n            });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"should observe a single field","suites":[".save()","positive"],"updatePoint":{"line":66,"column":45},"line":66,"code":"            it('should observe a single field', async () => {\n                const c = await humansCollection.create();\n                const doc: any = await c.findOne().exec();\n                const valueObj = {\n                    v: doc.get('firstName')\n                };\n                doc.get$('firstName').subscribe((newVal: any) => {\n                    valueObj.v = newVal;\n                });\n                const setName = randomCouchString(10);\n                await doc.atomicPatch({ firstName: setName });\n                await promiseWait(5);\n                assert.strictEqual(valueObj.v, setName);\n                c.database.destroy();\n            });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"should observe a nested field","suites":[".save()","positive"],"updatePoint":{"line":81,"column":45},"line":81,"code":"            it('should observe a nested field', async () => {\n                const c = await humansCollection.createNested();\n                const doc = await c.findOne().exec(true);\n                const valueObj = {\n                    v: doc.get('mainSkill.name')\n                };\n                doc.get$('mainSkill.name').subscribe((newVal: any) => {\n                    valueObj.v = newVal;\n                });\n                const setName = randomCouchString(10);\n                await doc.atomicPatch({\n                    mainSkill: {\n                        name: setName,\n                        level: 10\n                    }\n                });\n                promiseWait(5);\n                assert.strictEqual(valueObj.v, setName);\n                c.database.destroy();\n            });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"get equal values when subscribing again later","suites":[".save()","positive"],"updatePoint":{"line":101,"column":61},"line":101,"code":"            it('get equal values when subscribing again later', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec();\n                let v1;\n                const sub = doc.get$('firstName').subscribe((newVal: any) => v1 = newVal);\n                await promiseWait(5);\n\n                await doc.atomicPatch({ firstName: 'foobar' });\n\n                let v2;\n                doc.get$('firstName').subscribe((newVal: any) => v2 = newVal);\n\n                assert.strictEqual(v1, v2);\n                assert.strictEqual(v1, 'foobar');\n                sub.unsubscribe();\n                c.database.destroy();\n            });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"cannot observe non-existend field","suites":[".save()","negative"],"updatePoint":{"line":120,"column":49},"line":120,"code":"            it('cannot observe non-existend field', async () => {\n                const c = await humansCollection.create();\n                const doc: any = await c.findOne().exec();\n                await AsyncTestUtil.assertThrows(\n                    () => doc.get$('foobar').subscribe((newVal: any) => newVal),\n                    'RxError',\n                    'observe'\n                );\n                c.database.destroy();\n            });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"deleted$ is true, on delete","suites":[".deleted$","positive"],"updatePoint":{"line":134,"column":43},"line":134,"code":"            it('deleted$ is true, on delete', async () => {\n                const c = await humansCollection.create();\n                const doc: any = await c.findOne().exec();\n                let deleted = null;\n                doc.deleted$.subscribe((v: any) => deleted = v);\n                promiseWait(5);\n                assert.deepStrictEqual(deleted, false);\n                await doc.remove();\n                promiseWait(5);\n                assert.deepStrictEqual(deleted, true);\n                c.database.destroy();\n            });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"primary cannot be observed","suites":[".get$()","negative"],"updatePoint":{"line":154,"column":42},"line":154,"code":"            it('primary cannot be observed', async () => {\n                const c = await humansCollection.createPrimary();\n                const doc = await c.findOne().exec(true);\n                await AsyncTestUtil.assertThrows(\n                    () => doc.get$('passportId'),\n                    'RxError',\n                    'primary path'\n                );\n                c.database.destroy();\n            });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"final fields cannot be observed","suites":[".get$()","negative"],"updatePoint":{"line":164,"column":47},"line":164,"code":"            it('final fields cannot be observed', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.humanFinal\n                    }\n                });\n                const col = cols.humans;\n                const docData = schemaObjects.human();\n                await col.insert(docData);\n                const doc = await col.findOne().exec();\n                await AsyncTestUtil.assertThrows(\n                    () => doc.get$('age'),\n                    'RxError',\n                    'final fields'\n                );\n                db.destroy();\n            });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"#3434 event data must not be mutateable","suites":["issues"],"updatePoint":{"line":188,"column":51},"line":188,"code":"        it('#3434 event data must not be mutateable', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n                eventReduce: true,\n                ignoreDuplicate: true\n            });\n            const collections = await db.addCollections({\n                mycollection: {\n                    schema: schemas.humanDefault\n                }\n            });\n            await collections.mycollection.insert({\n                passportId: 'foobar',\n                firstName: 'Bob',\n                lastName: 'Kelso',\n                age: 56\n            });\n\n            const person: RxDocument<HumanDocumentType> = await db.mycollection.findOne().exec();\n\n\n            let hasThrown = false;\n            person.$.subscribe(data => {\n                try {\n                    // mutating the document data is not allowed and should throw\n                    delete data['_rev'];\n                } catch (err) {\n                    hasThrown = true;\n                }\n            });\n\n            await person.atomicUpdate(state => {\n                state.age = 50;\n                return state\n            });\n\n            assert.strictEqual(person.age, 50);\n            assert.ok(hasThrown);\n\n            db.destroy();\n        });","file":"unit/reactive-document.test.ts","skipped":false,"dir":"test"},{"name":"get results of array when .subscribe() and filled array later","suites":[],"updatePoint":{"line":32,"column":73},"line":32,"code":"        it('get results of array when .subscribe() and filled array later', async () => {\n            const c = await humansCollection.create(1);\n            const query = c.find();\n            let lastValue: any = null;\n            let count = 0;\n            query.$.subscribe(newResults => {\n                count++;\n                lastValue = newResults;\n            });\n            await AsyncTestUtil.waitUntil(() => count === 1);\n            assert.ok(lastValue);\n            assert.strictEqual(lastValue.length, 1);\n            assert.strictEqual(count, 1);\n            c.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"get the updated docs on Collection.insert()","suites":[],"updatePoint":{"line":47,"column":55},"line":47,"code":"        it('get the updated docs on Collection.insert()', async () => {\n            const c = await humansCollection.create(1);\n            const query = c.find();\n            let lastValue: any[] = [];\n            const emitted: any[] = [];\n            query.$.subscribe(newResults => {\n                lastValue = newResults;\n                emitted.push(newResults);\n            });\n            await waitUntil(() => emitted.length === 1);\n            assert.strictEqual(lastValue.length, 1);\n\n            const addHuman = schemaObjects.human();\n            const newPromiseWait = AsyncTestUtil.waitResolveable(500);\n            await c.insert(addHuman);\n            await newPromiseWait.promise;\n            assert.strictEqual(lastValue.length, 2);\n\n            let isHere = false;\n            lastValue.map(doc => {\n                if (doc.get('passportId') === addHuman.passportId)\n                    isHere = true;\n            });\n            assert.ok(isHere);\n            c.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"get the value twice when subscribing 2 times","suites":[],"updatePoint":{"line":73,"column":56},"line":73,"code":"        it('get the value twice when subscribing 2 times', async () => {\n            const c = await humansCollection.create(1);\n            const query = c.find();\n            let lastValue: any[] = [];\n            query.$.subscribe(newResults => {\n                lastValue = newResults;\n            });\n            let lastValue2: any[] = [];\n            query.$.subscribe(newResults => {\n                lastValue2 = newResults;\n            });\n            await promiseWait(100);\n\n            await AsyncTestUtil.waitUntil(() => lastValue2 && lastValue2.length === 1);\n            assert.deepStrictEqual(lastValue, lastValue2);\n            c.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"get the base-value when subscribing again later","suites":[],"updatePoint":{"line":90,"column":59},"line":90,"code":"        it('get the base-value when subscribing again later', async () => {\n            const c = await humansCollection.create(1);\n            const query = c.find();\n            let lastValue: any[] = [];\n            query.$.subscribe(newResults => {\n                lastValue = newResults;\n            });\n            await AsyncTestUtil.waitUntil(() => lastValue.length > 0);\n            let lastValue2: any[] = [];\n            query.$.subscribe(newResults => {\n                lastValue2 = newResults;\n            });\n            await AsyncTestUtil.waitUntil(() => lastValue2.length > 0);\n            await promiseWait(10);\n            assert.strictEqual(lastValue2.length, 1);\n            assert.deepStrictEqual(lastValue, lastValue2);\n            c.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"get new values on RxDocument.save","suites":[],"updatePoint":{"line":108,"column":45},"line":108,"code":"        it('get new values on RxDocument.save', async () => {\n            const c = await humansCollection.create(1);\n            const doc: any = await c.findOne().exec(true);\n\n            let values: any;\n            const emitted: any[] = [];\n            const querySub = c.find({\n                selector: {\n                    firstName: doc.get('firstName')\n                }\n            }).$.subscribe(newV => {\n                values = newV;\n                if (newV) {\n                    emitted.push(newV);\n                }\n            });\n            await waitUntil(() => emitted.length === 1);\n            assert.strictEqual(values.length, 1);\n\n            // change doc so query does not match\n            const newPromiseWait = AsyncTestUtil.waitResolveable(500);\n            await doc.atomicPatch({ firstName: 'foobar' });\n            await newPromiseWait.promise;\n            assert.strictEqual(values.length, 0);\n            querySub.unsubscribe();\n            c.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"subscribing many times should not result in many database-requests","suites":[],"updatePoint":{"line":135,"column":78},"line":135,"code":"        it('subscribing many times should not result in many database-requests', async () => {\n            const c = await humansCollection.create(1);\n            const query = c.find({\n                selector: {\n                    passportId: {\n                        $ne: 'foobar'\n                    }\n                }\n            });\n            await query.exec();\n            const countBefore = query._execOverDatabaseCount;\n            await Promise.all(\n                new Array(10).fill(0).map(() => {\n                    return query.$.pipe(first()).toPromise();\n                })\n            );\n            const countAfter = query._execOverDatabaseCount;\n\n            assert.strictEqual(countBefore, countAfter);\n\n            c.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"changing many documents in one write should not lead to many query result emits","suites":[],"updatePoint":{"line":157,"column":91},"line":157,"code":"        it('changing many documents in one write should not lead to many query result emits', async () => {\n            const c = await humansCollection.create(0);\n\n            const emitted: RxDocument<HumanDocumentType>[][] = [];\n            const sub = c.find().$.subscribe(results => emitted.push(results));\n            await waitUntil(() => emitted.length > 0);\n\n            await c.bulkInsert(\n                new Array(10).fill(0).map(() => schemaObjects.human())\n            );\n            await wait(config.isFastMode() ? 50 : 100);\n            assert.ok(\n                emitted.length <= 3,\n                JSON.stringify(emitted.map(result => result.map(doc => doc.toJSON())), null, 4)\n            );\n\n            sub.unsubscribe();\n            c.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"get no change when nothing happens","suites":["negative"],"updatePoint":{"line":178,"column":46},"line":178,"code":"        it('get no change when nothing happens', async () => {\n            const c = await humansCollection.create(1);\n            const query = c.find();\n            let received = 0;\n            const querySub = query.$.subscribe(() => {\n                received++;\n            });\n            await AsyncTestUtil.waitUntil(() => received === 1);\n            querySub.unsubscribe();\n            c.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"ISSUE: should have the document in DocCache when getting it from observe","suites":["ISSUES"],"updatePoint":{"line":252,"column":84},"line":252,"code":"        it('ISSUE: should have the document in DocCache when getting it from observe', async () => {\n            if (!config.storage.hasMultiInstance) {\n                return;\n            }\n            const name = randomCouchString(10);\n            const c = await humansCollection.createPrimary(1, name);\n            const c2 = await humansCollection.createPrimary(0, name);\n            const doc = await c.findOne().exec(true);\n            const docId = doc.primary;\n\n            assert.deepStrictEqual(c2._docCache.get(docId), undefined);\n\n            const results = [];\n            const sub = c2.find().$.subscribe(docs => results.push(docs));\n            await AsyncTestUtil.waitUntil(() => results.length >= 1);\n\n            assert.strictEqual((c2._docCache.get(docId) as any).primary, docId);\n\n            sub.unsubscribe();\n            c.database.destroy();\n            c2.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"#136 : findOne(string).$ streams all documents (_id as primary)","suites":["ISSUES"],"updatePoint":{"line":274,"column":75},"line":274,"code":"        it('#136 : findOne(string).$ streams all documents (_id as primary)', async () => {\n            const subs = [];\n            const col = await humansCollection.create(3);\n            const docData = schemaObjects.human();\n            const doc: any = await col.insert(docData);\n            const _id = doc._id;\n            const streamed: any[] = [];\n            subs.push(\n                col.findOne(_id).$\n                    .pipe(\n                        filter(d => d !== null)\n                    )\n                    .subscribe(d => {\n                        streamed.push(d);\n                    })\n            );\n            await AsyncTestUtil.waitUntil(() => streamed.length === 1);\n            assert.ok(isRxDocument(streamed[0]));\n            assert.strictEqual(streamed[0]._id, _id);\n\n            const streamed2: any[] = [];\n            subs.push(\n                col.findOne().where('_id').eq(_id).$\n                    .pipe(\n                        filter(d => d !== null)\n                    )\n                    .subscribe(d => {\n                        streamed2.push(d);\n                    })\n            );\n            await AsyncTestUtil.waitUntil(() => streamed2.length === 1);\n            assert.strictEqual(streamed2.length, 1);\n            assert.ok(isRxDocument(streamed2[0]));\n            assert.strictEqual(streamed2[0]._id, _id);\n\n            subs.forEach(sub => sub.unsubscribe());\n            col.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"#138 : findOne().$ returns every doc if no id given","suites":["ISSUES"],"updatePoint":{"line":312,"column":63},"line":312,"code":"        it('#138 : findOne().$ returns every doc if no id given', async () => {\n            const col = await humansCollection.create(3);\n            const streamed: any[] = [];\n            const sub = col.findOne().$\n                .pipe(\n                    filter(doc => doc !== null)\n                )\n                .subscribe(doc => {\n                    streamed.push(doc);\n                });\n            await AsyncTestUtil.waitUntil(() => streamed.length === 1);\n            assert.strictEqual(streamed.length, 1);\n            assert.ok(isRxDocument(streamed[0]));\n            sub.unsubscribe();\n            col.database.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"ISSUE emitted-order working when doing many atomicUpserts","suites":["ISSUES"],"updatePoint":{"line":328,"column":69},"line":328,"code":"        it('ISSUE emitted-order working when doing many atomicUpserts', async () => {\n            const crawlStateSchema = {\n                version: 0,\n                type: 'object',\n                primaryKey: 'key',\n                properties: {\n                    key: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    state: {\n                        type: 'object'\n                    }\n                },\n                required: ['state']\n            };\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: getRxStoragePouch('memory'),\n                ignoreDuplicate: true\n            });\n            await db.addCollections({\n                crawlstate: {\n                    schema: crawlStateSchema\n                }\n            });\n            const db2 = await createRxDatabase({\n                name,\n                storage: getRxStoragePouch('memory'),\n                ignoreDuplicate: true\n            });\n            await db2.addCollections({\n                crawlstate: {\n                    schema: crawlStateSchema\n                }\n            });\n\n            const emitted: any[] = [];\n            const sub = db.crawlstate\n                .findOne('registry').$\n                .pipe(\n                    filter(doc => doc !== null),\n                    map(doc => (doc as RxDocument).toJSON())\n                ).subscribe(data => emitted.push(data));\n\n            const emittedOwn = [];\n            const sub2 = db2.crawlstate\n                .findOne('registry').$\n                .pipe(\n                    filter(doc => doc !== null),\n                    map(doc => (doc as RxDocument).toJSON())\n                ).subscribe(data => emittedOwn.push(data));\n\n            const baseData = {\n                lastProvider: null,\n                providers: 0,\n                sync: false,\n                other: {}\n            };\n            let count = 0;\n            const getData = () => {\n                const d2 = clone(baseData);\n                d2.providers = count;\n                count++;\n                return d2;\n            };\n\n            await Promise.all(\n                new Array(5)\n                    .fill(0)\n                    .map(() => ({\n                        key: 'registry',\n                        state: getData()\n                    }))\n                    .map(data => {\n                        return db2.crawlstate.atomicUpsert(data);\n                    })\n            );\n\n            await AsyncTestUtil.waitUntil(() => emitted.length > 0);\n            await AsyncTestUtil.waitUntil(() => {\n                const lastEmitted = emitted[emitted.length - 1];\n                return lastEmitted.state.providers === 4;\n            }, 0, 300);\n\n            await Promise.all(\n                new Array(5)\n                    .fill(0)\n                    .map(() => ({\n                        key: 'registry',\n                        state: getData()\n                    }))\n                    .map(data => db2.crawlstate.atomicUpsert(data))\n            );\n\n            await AsyncTestUtil.waitUntil(() => {\n                if (!emitted.length) return false;\n                const lastEmitted = emitted[emitted.length - 1];\n                return lastEmitted.state.providers === 9;\n            });\n\n            // TODO this fails for unknown reasons on slow devices\n            // await AsyncTestUtil.waitUntil(() => emittedOwn.length === 10);\n\n            const last = emitted[emitted.length - 1];\n            assert.strictEqual(last.state.providers, 9);\n\n            // on own collection, all events should have propagated\n            // TODO this fails for unkonwn reason on slow device\n            // assert.strictEqual(emittedOwn.length, 10);\n\n            sub.unsubscribe();\n            sub2.unsubscribe();\n            db.destroy();\n            db2.destroy();\n        });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"#749 RxQuery subscription returns null as first result when ran immediately after another subscription or exec()","suites":["ISSUES"],"updatePoint":{"line":446,"column":125},"line":445,"code":"        it(\n            '#749 RxQuery subscription returns null as first result when ran immediately after another subscription or exec()',\n            async () => {\n                const name = randomCouchString(10);\n                const db = await createRxDatabase({\n                    name,\n                    storage: getRxStoragePouch('memory'),\n                    ignoreDuplicate: true\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: schemas.human\n                    }\n                });\n                const collection = collections.humans;\n\n                await collection.insert(schemaObjects.human());\n\n                const results: any[] = [];\n\n                const subs1 = collection.find().$.subscribe(x => {\n                    results.push(x);\n                    subs1.unsubscribe();\n                });\n\n                const subs2 = collection.find().$.subscribe(x => {\n                    results.push(x);\n                    subs2.unsubscribe();\n                });\n\n                // Let's try with a different query\n                collection\n                    .find()\n                    .sort('passportId')\n                    .exec()\n                    .then((x) => {\n                        results.push(x);\n                    });\n\n                const subs3 = collection\n                    .find()\n                    .sort('passportId')\n                    .$.subscribe(x => {\n                        results.push(x);\n                        subs3.unsubscribe();\n                    });\n\n                await AsyncTestUtil.waitUntil(() => results.length === 4);\n                results.forEach(res => {\n                    assert.strictEqual(res.length, 1);\n                });\n\n                db.destroy();\n            });","file":"unit/reactive-query.test.ts","skipped":false,"dir":"test"},{"name":"spawn and reach a server","suites":["replication-couchdb.test.js","spawn-server.js"],"updatePoint":{"line":63,"column":36},"line":63,"code":"        it('spawn and reach a server', async () => {\n            const server = await SpawnServer.spawn();\n            let path = server.url.split('/');\n            path.pop();\n            path.pop();\n            path = path.join('/');\n            const res = await request(path);\n            const json = JSON.parse(res);\n            assert.strictEqual(typeof json.uuid, 'string');\n            server.close();\n        });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"spawn again","suites":["replication-couchdb.test.js","spawn-server.js"],"updatePoint":{"line":74,"column":23},"line":74,"code":"        it('spawn again', async () => {\n            const server = await SpawnServer.spawn();\n            let path = server.url.split('/');\n            path.pop();\n            path.pop();\n            path = path.join('/');\n            const res = await request(path);\n            const json = JSON.parse(res);\n            assert.strictEqual(typeof json.uuid, 'string');\n            server.close();\n        });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"sync two collections over server","suites":["replication-couchdb.test.js","positive"],"updatePoint":{"line":88,"column":48},"line":88,"code":"            it('sync two collections over server', async function () {\n                const server = await SpawnServer.spawn();\n                const c = await humansCollection.create(0);\n                const c2 = await humansCollection.create(0);\n\n                const pw8 = AsyncTestUtil.waitResolveable(1000);\n                c.storageInstance.internals.pouch.sync(server.url, {\n                    live: true\n                }).on('error', function (err: Error) {\n                    console.error('error:');\n                    console.log(JSON.stringify(err));\n                    throw err;\n                });\n                c2.storageInstance.internals.pouch.sync(server.url, {\n                    live: true\n                });\n                let count = 0;\n                c2.storageInstance.internals.pouch.changes({\n                    since: 'now',\n                    live: true,\n                    include_docs: true\n                }).on('change', () => {\n                    count++;\n                    if (count === 2) pw8.resolve();\n                });\n\n                const obj = schemaObjects.human();\n                const doc = await c.insert(obj);\n                await pw8.promise;\n\n                await AsyncTestUtil.waitUntil(async () => {\n                    const ds = await c2.find().exec();\n                    return ds.length === 1;\n                });\n                const docs = await c2.find().exec();\n                assert.strictEqual(docs.length, 1);\n\n                assert.strictEqual(docs[0].get('firstName'), obj.firstName);\n\n\n                /**\n                 * Also try a delete\n                 */\n                await doc.remove();\n\n\n                await wait(1000);\n                const ds = await c2.find({\n                    selector: {\n                        age: {\n                            $gt: 0\n                        }\n                    }\n                }).exec();\n                assert.strictEqual(ds.length, 0);\n\n\n                c.database.destroy();\n                c2.database.destroy();\n                server.close();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"Observable.fromEvent should fire on sync-change","suites":["replication-couchdb.test.js","positive"],"updatePoint":{"line":149,"column":63},"line":149,"code":"            it('Observable.fromEvent should fire on sync-change', async () => {\n                const server = await SpawnServer.spawn();\n                const c = await humansCollection.create(0, undefined, false);\n                const c2 = await humansCollection.create(0, undefined, false);\n                c.storageInstance.internals.pouch.sync(server.url, {\n                    live: true\n                });\n                c2.storageInstance.internals.pouch.sync(server.url, {\n                    live: true\n                });\n\n                const e1 = [];\n                const pouch$ =\n                    fromEvent(\n                        c.storageInstance.internals.pouch.changes({\n                            since: 'now',\n                            live: true,\n                            include_docs: true\n                        }), 'change')\n                        .pipe(\n                            map((ar: any) => ar[0]),\n                            filter(e => !e.id.startsWith('_'))\n                        ).subscribe(e => e1.push(e));\n                const e2 = [];\n                const pouch2$ =\n                    fromEvent(c2.storageInstance.internals.pouch.changes({\n                        since: 'now',\n                        live: true,\n                        include_docs: true\n                    }), 'change').pipe(\n                        map((ar: any) => ar[0]),\n                        filter(e => !e.id.startsWith('_'))\n                    ).subscribe(e => e2.push(e));\n\n                const obj = schemaObjects.human();\n                await c.insert(obj);\n\n                await AsyncTestUtil.waitUntil(() => e1.length === 1);\n                await AsyncTestUtil.waitUntil(() => e2.length === 1);\n                assert.strictEqual(e1.length, e2.length);\n\n                pouch$.unsubscribe();\n                pouch2$.unsubscribe();\n                c.database.destroy();\n                c2.database.destroy();\n                server.close();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"push-only-sync","suites":["replication-couchdb.test.js","sync-directions","positive"],"updatePoint":{"line":200,"column":30},"line":200,"code":"            it('push-only-sync', async () => {\n                const c = await humansCollection.create(10, undefined, false);\n                const c2 = await humansCollection.create(10, undefined, false);\n                const replicationState = c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false,\n                    direction: {\n                        pull: false,\n                        push: true\n                    }\n                });\n                assert.ok(isRxCollection(replicationState.collection));\n                await AsyncTestUtil.waitUntil(async () => {\n                    const docs = await c2.find().exec();\n                    return docs.length === 20;\n                });\n                await AsyncTestUtil.wait(10);\n                const nonSyncedDocs = await c.find().exec();\n                assert.strictEqual(nonSyncedDocs.length, 10);\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"pull-only-sync","suites":["replication-couchdb.test.js","sync-directions","positive"],"updatePoint":{"line":223,"column":30},"line":223,"code":"            it('pull-only-sync', async () => {\n                const c = await humansCollection.create(10, undefined, false);\n                const c2 = await humansCollection.create(10, undefined, false);\n                c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false,\n                    direction: {\n                        pull: true,\n                        push: false\n                    }\n                });\n                await AsyncTestUtil.waitUntil(async () => {\n                    const docs = await c.find().exec();\n                    return docs.length === 20;\n                });\n                await promiseWait(10);\n                const nonSyncedDocs = await c2.find().exec();\n                assert.strictEqual(nonSyncedDocs.length, 10);\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should not allow non-way-sync","suites":["replication-couchdb.test.js","sync-directions","negative"],"updatePoint":{"line":247,"column":45},"line":247,"code":"            it('should not allow non-way-sync', async () => {\n                const c = await humansCollection.create(0);\n                const c2 = await humansCollection.create(10, undefined, false);\n                await AsyncTestUtil.assertThrows(\n                    () => c.syncCouchDB({\n                        remote: c2,\n                        direction: {\n                            push: false,\n                            pull: false\n                        }\n                    }),\n                    'RxError',\n                    'direction'\n                );\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should only sync documents that match the query","suites":["replication-couchdb.test.js","query-based sync","positive"],"updatePoint":{"line":268,"column":63},"line":268,"code":"            it('should only sync documents that match the query', async () => {\n                const c = await humansCollection.create(0, undefined, false);\n                const c2 = await humansCollection.create(10, undefined, false);\n                const query = c.find().where('firstName').eq('foobar');\n\n                const matchingDoc = schemaObjects.human();\n                matchingDoc.firstName = 'foobar';\n                await c2.insert(matchingDoc);\n\n                c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false,\n                    query: query\n                });\n\n                await AsyncTestUtil.waitUntil(async () => {\n                    const ds = await c.find().exec();\n                    return ds.length === 1;\n                });\n                await promiseWait(10);\n                const docs = await c.find().exec();\n\n                assert.strictEqual(docs.length, 1);\n                assert.strictEqual(docs[0].firstName, 'foobar');\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should not allow queries from other collection","suites":["replication-couchdb.test.js","query-based sync","negative"],"updatePoint":{"line":298,"column":62},"line":298,"code":"            it('should not allow queries from other collection', async () => {\n                const c = await humansCollection.create(0, undefined, false);\n                const c2 = await humansCollection.create(10, undefined, false);\n                const otherCollection = await humansCollection.create(0, undefined, false);\n\n                const query = otherCollection.find().where('firstName').eq('foobar');\n                await AsyncTestUtil.assertThrows(\n                    () => c.syncCouchDB({\n                        remote: c2,\n                        query\n                    }),\n                    'RxError',\n                    'same'\n                );\n\n                c.database.destroy();\n                c2.database.destroy();\n                otherCollection.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should be able to get the event-emitter after some time","suites":["replication-couchdb.test.js","._pouchEventEmitterObject"],"updatePoint":{"line":321,"column":71},"line":321,"code":"            it('should be able to get the event-emitter after some time', async () => {\n                const c = await humansCollection.create(0);\n                const c2 = await humansCollection.create(10);\n                const repState = await c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false\n                });\n\n                await AsyncTestUtil.waitUntil(\n                    () => !!repState._pouchEventEmitterObject\n                );\n                const pouchEventEmitter: any = repState._pouchEventEmitterObject;\n                assert.ok(pouchEventEmitter);\n                assert.strictEqual(typeof pouchEventEmitter.on, 'function');\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should emit change-events","suites":["replication-couchdb.test.js","change$"],"updatePoint":{"line":341,"column":41},"line":341,"code":"            it('should emit change-events', async () => {\n                const c = await humansCollection.create(0);\n                const c2 = await humansCollection.create(10);\n                const repState = await c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false\n                });\n                const emited = [];\n                repState.change$.subscribe(cE => emited.push(cE));\n                await AsyncTestUtil.waitUntil(() => emited.length >= 1);\n                await c2.insert(schemaObjects.human());\n                await AsyncTestUtil.waitUntil(() => emited.length >= 2);\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should be active","suites":["replication-couchdb.test.js","active$"],"updatePoint":{"line":359,"column":32},"line":359,"code":"            it('should be active', async () => {\n                const c = await humansCollection.create();\n                const c2 = await humansCollection.create(10);\n                const repState = await c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false\n                });\n                const emited: any[] = [];\n                repState.active$.subscribe(cE => emited.push(cE));\n                await AsyncTestUtil.waitUntil(() => emited.pop() === true);\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should not be alive","suites":["replication-couchdb.test.js","alive$"],"updatePoint":{"line":375,"column":35},"line":375,"code":"            it('should not be alive', async () => {\n                const server = await SpawnServer.spawn();\n                server.close(true);\n                const c = await humansCollection.create(0);\n\n                const repState = c.syncCouchDB({\n                    remote: server.url\n                });\n\n                const emited: any[] = [];\n                repState.alive$.subscribe(cE => emited.push(cE));\n\n                assert.strictEqual(emited[emited.length - 1], false);\n\n                c.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should be alive and transit to not alive","suites":["replication-couchdb.test.js","alive$"],"updatePoint":{"line":391,"column":56},"line":391,"code":"            it('should be alive and transit to not alive', async () => {\n                const server = await SpawnServer.spawn();\n                const c = await humansCollection.create(0);\n\n                const repState = c.syncCouchDB({\n                    remote: server.url\n                });\n\n                const emited: any[] = [];\n                repState.alive$.subscribe(cE => emited.push(cE));\n                await AsyncTestUtil.waitUntil(() => !!emited[emited.length - 1]);\n\n                assert.strictEqual(emited[emited.length - 1], true);\n\n                server.close(true);\n                const obj = schemaObjects.human();\n                await c.insert(obj);\n\n                await AsyncTestUtil.waitUntil(() => !emited[emited.length - 1]);\n                assert.strictEqual(emited[emited.length - 1], false);\n\n                c.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should always be false on live-replication","suites":["replication-couchdb.test.js","complete$"],"updatePoint":{"line":416,"column":58},"line":416,"code":"            it('should always be false on live-replication', async () => {\n                const c = await humansCollection.create();\n                const c2 = await humansCollection.create(10);\n                const repState = await c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false\n                });\n                const beFalse = await repState.complete$.pipe(first()).toPromise();\n                assert.strictEqual(beFalse, false);\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should emit true on non-live-replication when done","suites":["replication-couchdb.test.js","complete$"],"updatePoint":{"line":429,"column":66},"line":429,"code":"            it('should emit true on non-live-replication when done', async () => {\n                const c = await humansCollection.create(10);\n                const c2 = await humansCollection.create(10);\n                const repState = await c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: true,\n                    direction: {\n                        pull: true,\n                        push: true\n                    },\n                    options: {\n                        live: false,\n                        retry: true\n                    }\n                });\n\n                const emited: any[] = [];\n                const sub = repState.complete$.subscribe(ev => emited.push(ev));\n                await AsyncTestUtil.waitUntil(() => {\n                    const lastEv = emited[emited.length - 1];\n                    let ret = false;\n                    try {\n                        if (\n                            lastEv.push.ok === true &&\n                            lastEv.pull.ok === true\n                        ) ret = true;\n                    } catch (e) { }\n                    return ret;\n                });\n                sub.unsubscribe();\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should emit one event per doc","suites":["replication-couchdb.test.js","docs$"],"updatePoint":{"line":465,"column":45},"line":465,"code":"            it('should emit one event per doc', async () => {\n                const c = await humansCollection.create(0);\n                const c2 = await humansCollection.create(10);\n                const repState = await c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false\n                });\n                const emitedDocs: any[] = [];\n                repState.docs$.subscribe(doc => emitedDocs.push(doc));\n\n                await AsyncTestUtil.waitUntil(() => emitedDocs.length === 10);\n                emitedDocs.forEach(doc => assert.ok(doc.firstName));\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should not emit","suites":["replication-couchdb.test.js","denied$"],"updatePoint":{"line":483,"column":31},"line":483,"code":"            it('should not emit', async () => {\n                const c = await humansCollection.create(0);\n                const c2 = await humansCollection.create(10);\n                const repState = await c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false\n                });\n                const emitted = [];\n                repState.denied$.subscribe(doc => emitted.push(doc));\n\n                await AsyncTestUtil.wait(100);\n                assert.strictEqual(emitted.length, 0);\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should have the full data when resolved","suites":["replication-couchdb.test.js",".awaitInitialReplication()"],"updatePoint":{"line":501,"column":55},"line":501,"code":"            it('should have the full data when resolved', async () => {\n                const c = await humansCollection.create(0);\n                const c2 = await humansCollection.create(10);\n                const repState = await c.syncCouchDB({\n                    remote: c2,\n                    waitForLeadership: false,\n                    options: {\n                        live: false\n                    }\n                });\n                await repState.awaitInitialReplication();\n                const docs = await c.find().exec();\n                assert.strictEqual(docs.length, 10);\n\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"collection: should get an event when a doc syncs","suites":["replication-couchdb.test.js","positive"],"updatePoint":{"line":522,"column":64},"line":522,"code":"            it('collection: should get an event when a doc syncs', async () => {\n                const syncC = await humansCollection.create(0);\n                const syncPouch = syncC;\n\n                const c = await humansCollection.create(0, 'colsource' + randomCouchString(5));\n                const c2 = await humansCollection.create(0, 'colsync' + randomCouchString(5));\n                c.syncCouchDB({\n                    remote: syncPouch\n                });\n                c2.syncCouchDB({\n                    remote: syncPouch\n                });\n\n                const pw8 = AsyncTestUtil.waitResolveable(1700);\n                const events: any[] = [];\n                c2.$.subscribe(e => {\n                    events.push(e);\n                    pw8.resolve();\n                });\n\n                const obj = schemaObjects.human();\n                await c.insert(obj);\n                await pw8.promise;\n                await AsyncTestUtil.waitUntil(() => {\n                    const amount = events.length;\n                    if (amount > 1) {\n                        throw new Error('too many events');\n                    }\n                    return amount === 1;\n                });\n                assert.ok(events[0]);\n\n                syncC.database.destroy();\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"query: should re-find when a docs syncs","suites":["replication-couchdb.test.js","positive"],"updatePoint":{"line":559,"column":55},"line":559,"code":"            it('query: should re-find when a docs syncs', async () => {\n                const syncC = await humansCollection.create(0);\n                const syncPouch = syncC;\n\n                const c = await humansCollection.create(0, 'colsource' + randomCouchString(5));\n                const c2 = await humansCollection.create(0, 'colsync' + randomCouchString(5));\n                c.syncCouchDB({\n                    remote: syncPouch\n                });\n                c2.syncCouchDB({\n                    remote: syncPouch\n                });\n\n                const pw8 = AsyncTestUtil.waitResolveable(10000);\n                const results = [];\n                c2.find().$.subscribe(res => {\n                    results.push(res);\n                    if (results.length === 2) pw8.resolve();\n                });\n                assert.strictEqual(results.length, 0);\n                await promiseWait(5);\n\n\n                const obj = schemaObjects.human();\n                await c.insert(obj);\n                await pw8.promise;\n\n                assert.strictEqual(results.length, 2);\n\n                syncC.database.destroy();\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"document: should change field when doc saves","suites":["replication-couchdb.test.js","positive"],"updatePoint":{"line":592,"column":60},"line":592,"code":"            it('document: should change field when doc saves', async () => {\n                const syncC = await humansCollection.create(0);\n                const syncPouch = syncC;\n\n                const c = await humansCollection.create(0, 'colsource' + randomCouchString(5));\n                const c2 = await humansCollection.create(0, 'colsync' + randomCouchString(5));\n                c.syncCouchDB({\n                    remote: syncPouch\n                });\n                c2.syncCouchDB({\n                    remote: syncPouch\n                });\n\n                // insert and w8 for sync\n                const pw8 = AsyncTestUtil.waitResolveable(1400);\n                let results = null;\n                c2.find().$.subscribe(res => {\n                    results = res;\n                    if (results && results.length > 0) pw8.resolve();\n                });\n\n                const obj = schemaObjects.human();\n                await c.insert(obj);\n                await pw8.promise;\n\n                const doc: any = await c.findOne().exec();\n                const doc2: any = await c2.findOne().exec();\n\n\n                const patchPromise = doc.atomicPatch({ firstName: 'foobar' });\n                await waitUntil(() => doc2.firstName === 'foobar');\n\n                await patchPromise;\n\n                assert.strictEqual(doc2.firstName, 'foobar');\n                assert.strictEqual(doc.firstName, 'foobar');\n\n                syncC.database.destroy();\n                c.database.destroy();\n                c2.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should get the correct event when an attachment is replicated","suites":["replication-couchdb.test.js","positive"],"updatePoint":{"line":633,"column":77},"line":633,"code":"            it('should get the correct event when an attachment is replicated', async () => {\n                const remoteCollection = await humansCollection.createAttachments(1);\n                const collection = await humansCollection.createAttachments(0, randomCouchString(5));\n                collection.syncCouchDB({\n                    remote: remoteCollection\n                });\n\n                const emitted: RxChangeEvent<HumanDocumentType>[] = [];\n                const sub = collection.$.subscribe(cE => {\n                    emitted.push(cE);\n                });\n\n                const doc = await remoteCollection.findOne().exec(true);\n                await doc.putAttachment({\n                    id: 'cat.txt',\n                    data: blobBufferUtil.createBlobBuffer('meow', 'text/plain'),\n                    type: 'text/plain'\n                });\n\n                await waitUntil(() => flattenEvents(emitted).length >= 1);\n                if (flattenEvents(emitted).length > 1) {\n                    throw new Error('too much events emitted');\n                }\n\n                const firstEvent = flattenEvents(emitted)[0];\n                if (!firstEvent || !firstEvent.documentData) {\n                    throw new Error('firstEvent event missing');\n                }\n                assert.strictEqual(\n                    firstEvent.documentData._attachments['cat.txt'].type,\n                    'text/plain'\n                );\n\n                sub.unsubscribe();\n                remoteCollection.database.destroy();\n                collection.database.destroy();\n            });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"#630 Query cache is not being invalidated by replication","suites":["replication-couchdb.test.js","ISSUES"],"updatePoint":{"line":674,"column":68},"line":674,"code":"        it('#630 Query cache is not being invalidated by replication', async () => {\n            // create a schema\n            const mySchema = {\n                version: 0,\n                primaryKey: 'passportId',\n                type: 'object',\n                properties: {\n                    passportId: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    firstName: {\n                        type: 'string'\n                    },\n                    lastName: {\n                        type: 'string'\n                    },\n                    age: {\n                        type: 'integer',\n                        minimum: 0,\n                        maximum: 150\n                    }\n                }\n            };\n\n            // create a database\n            const db1 = await createRxDatabase({\n                name: randomCouchString(12),\n                storage: getRxStoragePouch('memory'),\n            });\n            // create a collection\n            const collections1 = await db1.addCollections({\n                crawlstate: {\n                    schema: mySchema\n                }\n            });\n            const collection1 = collections1.crawlstate;\n\n            // insert a document\n            await collection1.insert({\n                passportId: 'foobar',\n                firstName: 'Bob',\n                lastName: 'Kelso',\n                age: 56\n            });\n\n            // create another database\n            const db2 = await createRxDatabase({\n                name: randomCouchString(12),\n                storage: getRxStoragePouch('memory'),\n            });\n            // create a collection\n            const collections2 = await db2.addCollections({\n                crawlstate: {\n                    schema: mySchema\n                }\n            });\n            const collection2 = collections2.crawlstate;\n\n            // query for all documents on db2-collection2 (query will be cached)\n            const documents = await collection2.find().exec();\n            assert.ok(documents);\n\n            // Replicate from db1-collection1 to db2-collection2\n            const pullstate: RxCouchDBReplicationState = collection2.syncCouchDB({\n                remote: collection1,\n                direction: {\n                    pull: true,\n                    push: false\n                },\n                options: {\n                    live: false\n                }\n            });\n\n            // Wait for replication to complete\n            await pullstate.complete$\n                .pipe(\n                    filter(completed => completed.ok === true),\n                    first()\n                ).toPromise();\n\n\n\n            await waitUntil(async () => {\n                // query for all documents on db2-collection2 again (result is read from cache which doesnt contain replicated doc)\n                // collection2._queryCache.destroy();\n                const newDocs = await collection2.find().exec();\n                return newDocs.length === 1;\n            });\n\n            // clean up afterwards\n            db1.destroy();\n            db2.destroy();\n        });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"#641 using a collections internal pouch for replication should be prevented","suites":["replication-couchdb.test.js","ISSUES"],"updatePoint":{"line":769,"column":87},"line":769,"code":"        it('#641 using a collections internal pouch for replication should be prevented', async () => {\n            const colA = await humansCollection.create(0);\n            const colB = await humansCollection.create(0);\n\n            await AsyncTestUtil.assertThrows(\n                () => colA.syncCouchDB({\n                    remote: colB.storageInstance.internals.pouch,\n                    direction: {\n                        pull: true,\n                        push: false\n                    },\n                    options: {\n                        live: false\n                    }\n                }),\n                'RxError',\n                'pouchdb as remote'\n            );\n\n            colA.database.destroy();\n            colB.database.destroy();\n        });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should auto-cancel non-live replications when completed to not cause memory leak","suites":["replication-couchdb.test.js","ISSUES"],"updatePoint":{"line":791,"column":92},"line":791,"code":"        it('should auto-cancel non-live replications when completed to not cause memory leak', async () => {\n            const collection = await humansCollection.create(10, randomCouchString(10), false);\n            const syncCollection = await humansCollection.create(0, randomCouchString(10), false);\n\n            const syncOptions: SyncOptions = {\n                remote: syncCollection,\n                direction: {\n                    pull: true,\n                    push: true\n                },\n                options: {\n                    live: false\n                }\n            };\n\n            const syncState = collection.syncCouchDB(syncOptions);\n            await syncState.awaitInitialReplication();\n\n            await waitUntil(() => syncState.canceled === true);\n\n            collection.database.destroy();\n            syncCollection.database.destroy();\n        });","file":"unit/replication-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"spawn, reach and close a server","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":188,"column":47},"line":188,"code":"            it('spawn, reach and close a server', async () => {\n                const server = await SpawnServer.spawn();\n                const res = await server.client.query(`{\n                    info\n                }`);\n                if (!res.data) {\n                    console.log(JSON.stringify(res, null, 4));\n                    throw new Error('res has error');\n                }\n                assert.strictEqual(res.data.info, 1);\n                server.close();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"server.setDocument()","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":200,"column":36},"line":200,"code":"            it('server.setDocument()', async () => {\n                const server = await SpawnServer.spawn<WithDeleted<HumanWithTimestampDocumentType>>();\n                const doc = getTestData(1).pop();\n                if (!doc) {\n                    throw new Error('missing doc');\n                }\n                const res = await server.setDocument(doc);\n\n                /**\n                 * Because no conflicts have arised,\n                 * an empty array must be returned.\n                 */\n                assert.strictEqual(\n                    res.data.writeHumans.length,\n                    0\n                );\n                server.close();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should be able to use the ws-subscriptions","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":218,"column":58},"line":218,"code":"            it('should be able to use the ws-subscriptions', async () => {\n                const server = await SpawnServer.spawn();\n\n                const endpointUrl = server.url.ws;\n\n                const client = createClient({\n                    url: endpointUrl,\n                    shouldRetry: () => false,\n                    webSocketImpl: IsomorphicWebSocket,\n                });\n\n                const query = `subscription onHumanChanged {\n                    humanChanged {\n                        documents {\n                            id,\n                            name,\n                            age,\n                            updatedAt,\n                            deleted\n                        },\n                        checkpoint {\n                            id\n                            updatedAt\n                        }\n                    }\n                }`;\n\n                const emitted: any[] = [];\n                const emittedError = [];\n\n                client.subscribe({ query: query },\n                    {\n                        next: (data: any) => {\n                            emitted.push(data);\n                        },\n                        error: (error: any) => {\n                            emittedError.push(error);\n                        },\n                        complete: () => {\n                        }\n                    });\n\n                // we have to wait here until the connection is established\n                await wait(300);\n\n                const doc = getTestData(1).pop();\n                await server.setDocument(ensureNotFalsy(doc));\n\n                await waitUntil(() => emitted.length === 1);\n                assert.ok(emitted[0].data.humanChanged.checkpoint.id);\n                assert.strictEqual(emittedError.length, 0);\n\n                await server.close();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should pull all documents in one batch","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":274,"column":54},"line":274,"code":"            it('should pull all documents in one batch', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(getTestData(batchSize))\n                ]);\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    live: false,\n                    deletedField: 'deleted'\n                });\n                assert.strictEqual(replicationState.isStopped(), false);\n                ensureReplicationHasNoErrors(replicationState);\n\n                await waitUntil(async () => {\n                    const docs = await c.find().exec();\n                    return docs.length === batchSize;\n                });\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should pull all documents in multiple batches","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":299,"column":61},"line":299,"code":"            it('should pull all documents in multiple batches', async () => {\n                const amount = batchSize * 4;\n                const testData = getTestData(amount);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(testData)\n                ]);\n\n                c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    live: false,\n                    deletedField: 'deleted'\n                });\n\n                await waitUntil(async () => {\n                    const ds = await c.find().exec();\n                    return ds.length === amount;\n                });\n\n                // all of test-data should be in the database\n                const docs = await c.find().exec();\n                const ids = docs.map((d: any) => d.primary);\n                const notInDb = testData.find(doc => !ids.includes(doc.id));\n                if (notInDb) throw new Error('not in db: ' + notInDb.id);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should pull documents from a custom dataPath if one is specified","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":331,"column":80},"line":331,"code":"            it('should pull documents from a custom dataPath if one is specified', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(getTestData(batchSize))\n                ]);\n\n                const collectionQueryBuilder = (checkpoint: any, limit: number) => {\n                    if (!checkpoint) {\n                        checkpoint = {\n                            id: '',\n                            updatedAt: 0\n                        };\n                    }\n\n                    const query = `query($checkpoint: CheckpointInput, $limit: Int!)\n                    {\n                        collectionFeedForRxDBReplication(checkpoint: $checkpoint, limit: $limit) {\n                            collection {\n                                documents {\n                                    id\n                                    name\n                                    age\n                                    updatedAt\n                                    deleted\n                                }\n                                checkpoint {\n                                    id\n                                    updatedAt\n                                }\n                            }\n                        }\n                    }`;\n\n                    const variables = {\n                        checkpoint,\n                        limit\n                    };\n\n                    return {\n                        query,\n                        variables\n                    };\n                };\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: collectionQueryBuilder,\n                        dataPath: 'data.collectionFeedForRxDBReplication.collection'\n                    },\n                    deletedField: 'deleted'\n                });\n                ensureReplicationHasNoErrors(replicationState);\n                assert.strictEqual(replicationState.isStopped(), false);\n\n                await waitUntil(async () => {\n                    const docs = await c.find().exec();\n                    return docs.length === batchSize;\n                });\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should pull all documents when they have the same timestamp because they are also sorted by id","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":395,"column":110},"line":395,"code":"            it('should pull all documents when they have the same timestamp because they are also sorted by id', async () => {\n                const amount = batchSize * 2;\n                const testData = getTestData(amount);\n                const timestamp = getTimestamp();\n                testData.forEach(d => d.updatedAt = timestamp);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(testData)\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    live: false,\n                    deletedField: 'deleted'\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docsInDb = await c.find().exec();\n                assert.strictEqual(docsInDb.length, amount);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should handle deleted documents","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":423,"column":47},"line":423,"code":"            it('should handle deleted documents', async () => {\n                const doc: any = schemaObjects.humanWithTimestamp();\n                doc['deleted'] = true;\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn([doc])\n                ]);\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    deletedField: 'deleted'\n                });\n                ensureReplicationHasNoErrors(replicationState);\n                await replicationState.awaitInitialReplication();\n                const docs = await c.find().exec();\n\n                assert.strictEqual(docs.length, 0);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should handle truthy deleted flag values","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":450,"column":56},"line":450,"code":"            it('should handle truthy deleted flag values', async () => {\n                const doc: any = schemaObjects.humanWithTimestamp();\n                doc['deletedAt'] = Math.floor(new Date().getTime());\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn([doc])\n                ]);\n\n                const deletedAtQueryBuilder = (checkpoint: any, limit: number) => {\n                    if (!checkpoint) {\n                        checkpoint = {\n                            id: '',\n                            updatedAt: 0\n                        };\n                    }\n\n                    const query = `query FeedForRxDBReplication($checkpoint: CheckpointInput, $limit: Int!)\n                    {\n                        collectionFeedForRxDBReplication(checkpoint: $checkpoint, limit: $limit) {\n                            collection {\n                                documents {\n                                    id\n                                    name\n                                    age\n                                    updatedAt\n                                    deletedAt\n                                }\n                                checkpoint {\n                                    id\n                                    updatedAt\n                                }\n                            }\n                        }\n                    }`;\n\n                    const variables = {\n                        checkpoint,\n                        limit\n                    };\n\n                    return {\n                        query,\n                        variables\n                    };\n                }\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        queryBuilder: deletedAtQueryBuilder,\n                        dataPath: 'data.collectionFeedForRxDBReplication.collection'\n                    },\n                    deletedField: 'deletedAt'\n                });\n                ensureReplicationHasNoErrors(replicationState);\n\n                await replicationState.awaitInitialReplication();\n                const docs = await c.find().exec();\n                assert.strictEqual(docs.length, 0);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should retry on errors","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":513,"column":38},"line":513,"code":"            it('should retry on errors', async () => {\n                const amount = batchSize * 4;\n                const testData = getTestData(amount);\n\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(testData)\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: {\n                        http: ERROR_URL\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    deletedField: 'deleted'\n                });\n                replicationState.retryTime = 100;\n\n\n                // on the first error, we switch out the graphql-client\n                await replicationState.error$.pipe(\n                    first()\n                ).toPromise().then(() => {\n                    const client = GraphQLClient({\n                        url: server.url.http\n                    });\n                    replicationState.clientState.client = client;\n                });\n\n                await replicationState.awaitInitialReplication();\n                const docs = await c.find().exec();\n                assert.strictEqual(docs.length, amount);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should also get documents that come in afterwards","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":554,"column":65},"line":554,"code":"            it('should also get documents that come in afterwards', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(getTestData(1))\n                ]);\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n\n\n                // wait until first replication is done\n                await replicationState.awaitInitialReplication();\n\n                // add document & trigger pull\n                const doc = getTestData(1).pop();\n                if (!doc) {\n                    throw new Error('doc missing');\n                }\n                await server.setDocument(doc);\n\n                await replicationState.reSync();\n\n                await waitUntil(async () => {\n                    const docs = await c.find().exec();\n                    return docs.length === 2;\n                });\n\n                server.close();\n                await c.database.destroy();\n\n                // replication should be canceled when collection is destroyed\n                assert.ok(replicationState.isStopped());\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should overwrite the local doc if the remote gets deleted","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":593,"column":73},"line":593,"code":"            it('should overwrite the local doc if the remote gets deleted', async () => {\n                const amount = 3;\n\n                const testData = getTestData(amount);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(testData)\n                ]);\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docs = await c.find().exec();\n                assert.strictEqual(docs.length, amount);\n                await wait(250);\n\n                const firstDoc: typeof testData[0] = clone(testData[0]);\n                firstDoc.updatedAt = new Date().getTime();\n                firstDoc.deleted = true;\n\n                await server.setDocument(firstDoc);\n\n                await replicationState.reSync();\n                await replicationState.awaitInSync();\n\n                const docs2 = await c.find().exec();\n\n                assert.strictEqual(docs2.length, amount - 1);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should overwrite the client doc if it was deleted locally before synced from the server","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":633,"column":103},"line":633,"code":"            it('should overwrite the client doc if it was deleted locally before synced from the server', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(0);\n                const localDoc: any = schemaObjects.humanWithTimestamp();\n                const rxDoc = await c.insert(localDoc);\n                await rxDoc.remove();\n\n                const docs = await c.find().exec();\n                assert.strictEqual(docs.length, 0);\n\n                const server = await SpawnServer.spawn<HumanWithTimestampDocumentType>();\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n                await replicationState.awaitInitialReplication();\n\n                localDoc['deleted'] = false;\n                await server.setDocument(localDoc);\n\n\n                await replicationState.reSync();\n                await replicationState.awaitInSync();\n\n                const docsAfter = await c.find().exec();\n                assert.strictEqual(docsAfter.length, 1);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should fail because initial replication never resolves","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":667,"column":70},"line":667,"code":"            it('should fail because initial replication never resolves', async () => {\n                if (config.isFastMode()) {\n                    // this test takes too long, do not run in fast mode\n                    return;\n                }\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn()\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: {\n                        http: ERROR_URL\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n\n                let timeoutId: any;\n                const timeout = new Promise((_, reject) => {\n                    timeoutId = setTimeout(() => {\n                        clearTimeout(timeoutId);\n                        reject(new Error('Timeout reached'));\n                    },\n                        // small buffer until the promise rejects\n                        1000);\n                });\n\n                const raceProm = Promise.race([\n                    replicationState.awaitInitialReplication(),\n                    timeout\n                ]).then(_ => clearTimeout(timeoutId));\n\n                // error should be thrown because awaitInitialReplication() should never resolve\n                await assertThrows(() => raceProm, Error, 'Timeout');\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should send all documents in one batch","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":713,"column":54},"line":713,"code":"            it('should send all documents in one batch', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(batchSize),\n                    SpawnServer.spawn()\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: false,\n                    retryTime: 1000,\n                    deletedField: 'deleted'\n                });\n                ensureReplicationHasNoErrors(replicationState);\n\n\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, batchSize);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should send all documents in multiple batches","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":740,"column":61},"line":740,"code":"            it('should send all documents in multiple batches', async () => {\n                const amount = batchSize * 3;\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(amount),\n                    SpawnServer.spawn()\n                ]);\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: false,\n                    deletedField: 'deleted'\n                });\n                await replicationState.awaitInitialReplication();\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, amount);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should send deletions","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":762,"column":37},"line":762,"code":"            it('should send deletions', async () => {\n                const amount = batchSize;\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(amount),\n                    SpawnServer.spawn<WithDeleted<HumanWithTimestampDocumentType>>()\n                ]);\n\n                const doc = await c.findOne().exec(true);\n                await doc.remove();\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: false,\n                    deletedField: 'deleted'\n                });\n\n                await replicationState.awaitInitialReplication();\n                const docsOnServer = server.getDocuments();\n\n                const shouldBeDeleted = docsOnServer.find((d: any) => d.id === doc.primary);\n                assert.strictEqual((shouldBeDeleted as any).deleted, true);\n\n                server.close();\n                await c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should trigger push on db-changes that have not resulted from the replication","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":791,"column":93},"line":791,"code":"            it('should trigger push on db-changes that have not resulted from the replication', async () => {\n                const amount = batchSize;\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(amount),\n                    SpawnServer.spawn()\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n                ensureReplicationHasNoErrors(replicationState);\n\n\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, amount);\n\n                // check for inserts\n                await c.insert(schemaObjects.humanWithTimestamp());\n                await waitUntil(() => {\n                    const docsOnServer2 = server.getDocuments();\n                    return docsOnServer2.length === amount + 1;\n                });\n\n                // check for deletes\n                await c.findOne().remove();\n                await replicationState.awaitInSync();\n                await waitUntil(() => {\n                    const docsOnServer2 = server.getDocuments();\n                    const oneShouldBeDeleted = docsOnServer2.find((d: any) => d.deleted === true);\n                    return !!oneShouldBeDeleted;\n                }, 1000, 100);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should not send index-documents","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":834,"column":47},"line":834,"code":"            it('should not send index-documents', async () => {\n                const server = await SpawnServer.spawn();\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n\n                const schema = clone(schemas.humanWithTimestamp);\n                schema.indexes = ['name'];\n                const collections = await db.addCollections({\n                    humans: {\n                        schema\n                    }\n                });\n                const collection = collections.humans;\n\n                const replicationState = collection.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: false,\n                    deletedField: 'deleted'\n                });\n\n                const emitted = [];\n                replicationState.error$.subscribe((err: any) => {\n                    emitted.push(err);\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, 0);\n                assert.strictEqual(emitted.length, 0);\n\n                server.close();\n                db.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should push and pull all docs; live: false","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":877,"column":58},"line":877,"code":"            it('should push and pull all docs; live: false', async () => {\n                const amount = batchSize * 4;\n                const testData = getTestData(amount);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(amount),\n                    SpawnServer.spawn(testData)\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    live: false,\n                    deletedField: 'deleted'\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, amount * 2);\n\n                const docsOnDb = await c.find().exec();\n                assert.strictEqual(docsOnDb.length, amount * 2);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should allow asynchronous push and pull queryBuilders","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":910,"column":69},"line":910,"code":"            it('should allow asynchronous push and pull queryBuilders', async () => {\n                const amount = batchSize * 4;\n                const testData = getTestData(amount);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(amount),\n                    SpawnServer.spawn(testData)\n                ]);\n\n                const asyncPushQueryBuilder = (doc: any): Promise<any> => {\n                    return pushQueryBuilder(doc);\n                };\n                const asyncQueryBuilder = (doc: any, limit: number): Promise<any> => {\n                    return pullQueryBuilder(doc, limit);\n                };\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: asyncPushQueryBuilder\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder: asyncQueryBuilder\n                    },\n                    live: false,\n                    deletedField: 'deleted'\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, amount * 2);\n\n                const docsOnDb = await c.find().exec();\n                assert.strictEqual(docsOnDb.length, amount * 2);\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should push and pull some docs; live: true","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":950,"column":58},"line":950,"code":"            it('should push and pull some docs; live: true', async () => {\n                const amount = batchSize;\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(amount),\n                    SpawnServer.spawn(getTestData(amount))\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                let docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, amount * 2);\n\n                const docsOnDb = await c.find().exec();\n                assert.strictEqual(docsOnDb.length, amount * 2);\n\n                // insert one on local and one on server\n                const doc: any = schemaObjects.humanWithTimestamp({\n                    id: 'z-some-local'\n                });\n                doc['deleted'] = false;\n                await server.setDocument(doc);\n\n                docsOnServer = server.getDocuments();\n                const insertData = schemaObjects.humanWithTimestamp({\n                    id: 'z-some-server'\n                });\n                await c.insert(insertData);\n\n                await replicationState.reSync();\n                await replicationState.awaitInSync();\n\n                await waitUntil(async () => {\n                    await replicationState.reSync();\n                    docsOnServer = server.getDocuments();\n                    const shouldBe = (amount * 2) + 2;\n                    return docsOnServer.length === shouldBe;\n                });\n                await waitUntil(async () => {\n                    await replicationState.reSync();\n                    const docsOnClient = await c.find().exec();\n                    return docsOnClient.length === (amount * 2) + 2;\n                });\n                await replicationState.awaitInSync();\n                await server.close();\n                await c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should push and pull many docs; live: true","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1010,"column":58},"line":1010,"code":"            it('should push and pull many docs; live: true', async () => {\n                const amount = batchSize * 4;\n                const testData = getTestData(amount);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(amount),\n                    SpawnServer.spawn(testData)\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, amount * 2);\n\n                const docsOnDb = await c.find().exec();\n                assert.strictEqual(docsOnDb.length, amount * 2);\n\n\n                // insert one on local and one on server\n                const doc: any = schemaObjects.humanWithTimestamp({\n                    name: 'many1local'\n                });\n                doc['deleted'] = false;\n                await server.setDocument(doc);\n                await c.insert(schemaObjects.humanWithTimestamp({\n                    name: 'many1server'\n                }));\n\n                await waitUntil(async () => {\n                    /**\n                     * we have to do replicationState.run() each time\n                     * because pouchdb takes a while until the update_seq is increased\n                     */\n                    await replicationState.reSync();\n                    const docsOnServer2 = server.getDocuments();\n                    const shouldBe = (amount * 2) + 2;\n                    return docsOnServer2.length === shouldBe;\n                });\n                await waitUntil(() => {\n                    const docsOnDb2 = server.getDocuments();\n                    return docsOnDb2.length === (amount * 2) + 2;\n                });\n\n                await replicationState.awaitInSync();\n                await server.close();\n                await c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should work with multiInstance","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1070,"column":46},"line":1070,"code":"            it('should work with multiInstance', async () => {\n                if (!config.storage.hasMultiInstance) {\n                    return;\n                }\n                if (config.isFastMode()) {\n                    // TODO this test randomly fails in fast mode with lokijs storage.\n                    return;\n                }\n                const name = randomCouchString(10);\n                const server = await SpawnServer.spawn();\n\n                const db1 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n\n                const collections1 = await db1.addCollections({\n                    humansmulti: {\n                        schema: schemas.humanWithTimestamp\n                    }\n                });\n                const collection1 = collections1.humansmulti;\n                const collections2 = await db2.addCollections({\n                    humansmulti: {\n                        schema: schemas.humanWithTimestamp\n                    }\n                });\n                const collection2 = collections2.humansmulti;\n\n                collection1.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n                collection2.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: false,\n                    deletedField: 'deleted'\n                });\n\n\n                // insert to collection1\n                await collection1.insert(schemaObjects.humanWithTimestamp({\n                    name: 'mt1'\n                }));\n                await waitUntil(async () => {\n                    const docs = await collection2.find().exec();\n                    return docs.length === 1;\n                });\n\n                // insert to collection2\n                await collection2.insert(schemaObjects.humanWithTimestamp({\n                    name: 'mt2'\n                }));\n                await waitUntil(async () => {\n                    const docs = await collection1.find().exec();\n                    return docs.length === 2;\n                });\n\n                await db1.destroy();\n                await db2.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should not do more requests then needed","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1154,"column":55},"line":1154,"code":"            it('should not do more requests then needed', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn()\n                ]);\n\n                let pullCount = 0;\n                let pushCount = 0;\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize: 20,\n                        queryBuilder: args => {\n                            pushCount++;\n                            return pushQueryBuilder(args);\n                        }\n                    },\n                    pull: {\n                        batchSize: 20,\n                        queryBuilder: (args, limit: number) => {\n                            pullCount++;\n                            return pullQueryBuilder(args, limit);\n                        }\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n\n                await replicationState.awaitInitialReplication();\n\n                // function getStats() {\n                //     return ensureNotFalsy(replicationState.internalReplicationState).stats;\n                // }\n\n                // pullCount should be exactly 1 because pull was started on replication start\n                assert.strictEqual(pullCount, 1);\n                assert.strictEqual(pushCount, 0);\n\n                // insert one document at the client\n                await c.insert(schemaObjects.humanWithTimestamp());\n\n                /**\n                 * After the insert,\n                 * exactly one push must be triggered\n                 * and then one pull should have happened afterwards\n                 */\n                await waitUntil(() => pushCount === 1);\n                await waitUntil(() => pullCount === 1);\n\n                /**\n                 * Even after some time,\n                 * no more requests should have happened\n                 */\n                await wait(250);\n                assert.strictEqual(pushCount, 1);\n                assert.strictEqual(pullCount, 1);\n\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should pull all ongoing document writes from the server","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1218,"column":71},"line":1218,"code":"            it('should pull all ongoing document writes from the server', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn()\n                ]);\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder,\n                        streamQueryBuilder: pullStreamQueryBuilder\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n                ensureReplicationHasNoErrors(replicationState);\n                await replicationState.awaitInSync();\n\n                const testDocData = getTestData(1)[0];\n\n                // insert on remote\n                await server.setDocument(testDocData);\n                await waitUntil(async () => {\n                    const docs = await c.find().exec();\n                    return docs.length === 1;\n                });\n                // update on remote\n                const updateDocData: typeof testDocData = clone(testDocData);\n                updateDocData.name = 'updated';\n                await server.setDocument(updateDocData);\n                await waitUntil(async () => {\n                    const doc = await c.findOne().exec(true);\n                    return doc.name === 'updated';\n                });\n                // delete on remote\n                const deleteDocData: typeof testDocData = clone(updateDocData);\n                deleteDocData.deleted = true;\n                await server.setDocument(deleteDocData);\n                await waitUntil(async () => {\n                    const doc = await c.findOne().exec();\n                    return !doc;\n                }, 1000, 200);\n\n                await server.close();\n                await c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should respect the pull.responseModifier","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1268,"column":56},"line":1268,"code":"            it('should respect the pull.responseModifier', async () => {\n                const checkpointIterationModeAmount = 5;\n                const eventObservationModeAmount = 3;\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(getTestData(checkpointIterationModeAmount))\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize: 2,\n                        queryBuilder: pullQueryBuilder,\n                        streamQueryBuilder: pullStreamQueryBuilder,\n                        responseModifier(\n                            originalResponse: ReplicationPullHandlerResult<HumanWithTimestampDocumentType, any>,\n                            origin,\n                            _requestCheckpoint\n                        ) {\n                            originalResponse.documents = originalResponse.documents.map(doc => {\n                                doc.name = doc.name + '-response-modified-' + origin;\n                                return doc;\n                            });\n                            return originalResponse;\n                        }\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n                ensureReplicationHasNoErrors(replicationState);\n\n                await replicationState.awaitInitialReplication();\n\n                let docsOnLocal = await c.find().exec();\n                assert.strictEqual(\n                    docsOnLocal.filter(d => d.name.endsWith('response-modified-handler')).length,\n                    checkpointIterationModeAmount\n                );\n\n\n                // ensure it also runs on pull.stream$\n                await Promise.all(\n                    getTestData(3).map(d => server.setDocument(d))\n                );\n                await waitUntil(async () => {\n                    const docs = await c.find().exec();\n                    return docs.length === (checkpointIterationModeAmount + eventObservationModeAmount);\n                });\n                docsOnLocal = await c.find().exec();\n                assert.strictEqual(\n                    docsOnLocal.filter(d => d.name.endsWith('response-modified-stream')).length,\n                    eventObservationModeAmount\n                );\n\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should emit the received documents when pulling","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1329,"column":63},"line":1329,"code":"            it('should emit the received documents when pulling', async () => {\n                const testData = getTestData(batchSize);\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(testData)\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    deletedField: 'deleted'\n                });\n\n                const emitted: RxDocumentData<HumanWithTimestampDocumentType>[] = [];\n                const sub = replicationState.received$.subscribe((doc: any) => emitted.push(doc));\n\n\n                await replicationState.awaitInitialReplication();\n                assert.strictEqual(emitted.length, batchSize);\n\n\n                assert.deepStrictEqual(\n                    emitted.map(d => d.id).sort(),\n                    testData.map(d => d.id).sort()\n                );\n                emitted.forEach(d => assert.strictEqual(d._deleted, false));\n\n                sub.unsubscribe();\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should emit the send documents when pushing","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1363,"column":59},"line":1363,"code":"            it('should emit the send documents when pushing', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(batchSize),\n                    SpawnServer.spawn()\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        queryBuilder: pushQueryBuilder,\n                        batchSize\n                    },\n                    live: false,\n                    deletedField: 'deleted'\n                });\n\n                const emitted: any[] = [];\n                const sub = replicationState.send$.subscribe((doc: any) => emitted.push(doc));\n                await replicationState.awaitInitialReplication();\n\n                assert.strictEqual(emitted.length, batchSize);\n\n                const docs = await c.find().exec();\n                assert.deepStrictEqual(\n                    emitted.map(d => d.id).sort(),\n                    docs.map(d => d.primary).sort()\n                );\n\n                sub.unsubscribe();\n                server.close();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should emit an error when the server is not reachable","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1395,"column":69},"line":1395,"code":"            it('should emit an error when the server is not reachable', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(0);\n                const replicationState = c.syncGraphQL({\n                    url: {\n                        http: ERROR_URL\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    deletedField: 'deleted'\n                });\n\n                const error = await replicationState.error$.pipe(\n                    first()\n                ).toPromise();\n\n                assert.strictEqual(ensureNotFalsy(error).parameters.direction, 'pull');\n                replicationState.cancel();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should contain include replication action data in push request failure","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1416,"column":86},"line":1416,"code":"            it('should contain include replication action data in push request failure', async () => {\n                const c = await humansCollection.createHumanWithTimestamp(0);\n                const replicationState = c.syncGraphQL({\n                    url: {\n                        http: ERROR_URL\n                    },\n                    push: {\n                        queryBuilder: pushQueryBuilder,\n                    },\n                    deletedField: 'deleted'\n                });\n\n                const localDoc = schemaObjects.humanWithTimestamp();\n                await c.insert(localDoc);\n\n                const error = ensureNotFalsy(\n                    await replicationState.error$.pipe(\n                        first()\n                    ).toPromise()\n                );\n                const firstRow = (error as any).parameters.pushRows[0];\n                const newDocState = firstRow.newDocumentState;\n\n                assert.strictEqual(ensureNotFalsy(error).parameters.direction, 'push');\n                assert.strictEqual(newDocState.id, localDoc.id);\n                assert.strictEqual(newDocState.name, localDoc.name);\n                assert.strictEqual(newDocState.age, localDoc.age);\n                assert.strictEqual(newDocState.updatedAt, localDoc.updatedAt);\n\n                replicationState.cancel();\n                c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"assumption: buildSchema() fails on non-graphql input","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1451,"column":68},"line":1451,"code":"            it('assumption: buildSchema() fails on non-graphql input', () => {\n                assert.throws(\n                    () => buildSchema('foobar')\n                );\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should create a valid output","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1456,"column":44},"line":1456,"code":"            it('should create a valid output', () => {\n                const output = graphQLSchemaFromRxSchema({\n                    human: {\n                        schema: schemas.humanWithTimestamp,\n                        checkpointFields: [\n                            'id',\n                            'updatedAt'\n                        ],\n                        deletedField: 'customDeleted'\n                    }\n                });\n\n                assert.ok(output.asString.includes('customDeleted'));\n                const build = buildSchema(output.asString);\n                assert.ok(build);\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should create a valid output with subscription params","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1472,"column":69},"line":1472,"code":"            it('should create a valid output with subscription params', () => {\n                const output = graphQLSchemaFromRxSchema({\n                    human: {\n                        schema: schemas.humanWithTimestamp,\n                        checkpointFields: [\n                            'id',\n                            'updatedAt'\n                        ],\n                        headerFields: [\n                            'lol'\n                        ]\n                    },\n                    deepNestedHuman: {\n                        schema: schemas.deepNestedHuman,\n                        checkpointFields: [\n                            'passportId'\n                        ],\n                        headerFields: [\n                            'foo'\n                        ]\n                    },\n                    /**\n                     * A schema without header fields must\n                     * not create a broken schema.\n                     */\n                    noHeader: {\n                        schema: schemas.humanWithTimestamp,\n                        checkpointFields: [\n                            'id',\n                            'updatedAt'\n                        ]\n                    },\n                });\n                assert.strictEqual(\n                    output.asString.includes('NoHeaderInputHeaders'),\n                    false\n                );\n\n                const build = buildSchema(output.asString);\n                assert.ok(build);\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"assumption: parseQuery() fails on non-graphql input","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1515,"column":67},"line":1515,"code":"            it('assumption: parseQuery() fails on non-graphql input', () => {\n                assert.throws(\n                    () => parseQuery('foobar')\n                );\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should create a valid builder","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1520,"column":45},"line":1520,"code":"            it('should create a valid builder', async () => {\n                const builder = pullQueryBuilderFromRxSchema(\n                    'human', {\n                    schema: schemas.humanWithTimestamp,\n                    checkpointFields: [\n                        'id',\n                        'updatedAt'\n                    ]\n                });\n\n                const output = await builder({\n                    id: 'foo',\n                    updatedAt: 12343\n                }, batchSize);\n\n                const parsed = parseQuery(output.query);\n                assert.ok(parsed);\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"builder should work on null-document","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1538,"column":52},"line":1538,"code":"            it('builder should work on null-document', async () => {\n                const builder = pullQueryBuilderFromRxSchema(\n                    'human', {\n                    schema: schemas.humanWithTimestamp,\n                    checkpointFields: [\n                        'id',\n                        'updatedAt'\n                    ]\n                });\n\n                const output = await builder(null, batchSize);\n                const parsed = parseQuery(output.query);\n                assert.ok(parsed);\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should create a valid builder","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1554,"column":45},"line":1554,"code":"            it('should create a valid builder', async () => {\n                const builder = pullStreamBuilderFromRxSchema(\n                    'human', {\n                    schema: schemas.humanWithTimestamp,\n                    checkpointFields: [\n                        'id',\n                        'updatedAt'\n                    ],\n                    headerFields: ['AUTH_TOKEN']\n                });\n\n                const output = await builder({\n                    AUTH_TOKEN: 'foobar'\n                });\n\n                assert.strictEqual(output.variables.headers.AUTH_TOKEN, 'foobar');\n                const parsed = parseQuery(output.query);\n                assert.ok(parsed);\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"builder should work on null-document","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1573,"column":52},"line":1573,"code":"            it('builder should work on null-document', async () => {\n                const builder = pullStreamBuilderFromRxSchema(\n                    'human', {\n                    schema: schemas.humanWithTimestamp,\n                    checkpointFields: [\n                        'id',\n                        'updatedAt'\n                    ]\n                });\n\n                const output = await builder({});\n                const parsed = parseQuery(output.query);\n                assert.ok(parsed);\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should create a valid builder","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1589,"column":45},"line":1589,"code":"            it('should create a valid builder', async () => {\n                const builder = pushQueryBuilderFromRxSchema(\n                    'human', {\n                    schema: schemas.humanWithTimestamp,\n                    checkpointFields: [\n                        'id',\n                        'updatedAt'\n                    ],\n                    deletedField: 'deleted'\n                });\n\n                // build valid output for insert document\n                const output = await builder([{\n                    newDocumentState: {\n                        id: 'foo',\n                        name: 'foo',\n                        age: 1234,\n                        updatedAt: 12343,\n                        _attachments: {},\n                        _rev: '1-foobar'\n                    }\n                }]);\n\n                const parsed = parseQuery(output.query);\n                const firstPushRowDoc: HumanWithTimestampDocumentType = output.variables.humanPushRow[0].newDocumentState;\n\n                // should not have added internal properties\n                assert.ok(!firstPushRowDoc.hasOwnProperty('_rev'));\n                assert.ok(!firstPushRowDoc.hasOwnProperty('_attachments'));\n                assert.ok(!firstPushRowDoc.hasOwnProperty('_deleted'));\n\n                // build valid output for deleted document\n                const outputDeleted = await builder([{\n                    newDocumentState: {\n                        id: 'foo',\n                        _deleted: true\n                    }\n                }]);\n                parseQuery(outputDeleted.query);\n\n                // should not have added internal properties\n                const firstPushRowDocDeleted: HumanWithTimestampDocumentType = outputDeleted.variables.humanPushRow[0].newDocumentState;\n                assert.ok(!firstPushRowDocDeleted.hasOwnProperty('_rev'));\n                assert.ok(!firstPushRowDocDeleted.hasOwnProperty('_attachments'));\n                assert.ok(!firstPushRowDocDeleted.hasOwnProperty('_deleted'));\n\n                assert.ok(parsed);\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should keep the deleted value","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1637,"column":45},"line":1637,"code":"            it('should keep the deleted value', async () => {\n                const docData = schemaObjects.humanWithTimestamp();\n                /**\n                 * The GraphQL replication will\n                 * internally switch out _deleted with the deleted flag.\n                 * So the pushQueryBuilder MUST NOT switch out again.\n                 */\n                (docData as any).deleted = true;\n                const ownPushQueryBuilder = pushQueryBuilderFromRxSchema(\n                    'human',\n                    {\n                        checkpointFields: [\n                            'id',\n                            'updatedAt'\n                        ],\n                        schema: schemas.humanWithTimestamp,\n                        deletedField: 'deleted'\n                    }\n                );\n                const pushData = await ownPushQueryBuilder([{\n                    newDocumentState: docData\n                }]);\n                const pushDoc = pushData.variables.humanPushRow[0].newDocumentState;\n                assert.ok(pushDoc.deleted);\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should work with encryption","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1664,"column":43},"line":1664,"code":"            it('should work with encryption', async () => {\n                if (config.storage.name !== 'pouchdb') {\n                    // TODO\n                    return;\n                }\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: wrappedKeyEncryptionStorage({\n                        storage: config.storage.getStorage(),\n                    }),\n                    multiInstance: true,\n                    eventReduce: true,\n                    ignoreDuplicate: true,\n                    password: randomCouchString(10)\n                });\n                const schema: RxJsonSchema<HumanWithTimestampDocumentType> = clone(schemas.humanWithTimestamp);\n                schema.encrypted = ['name'];\n                const collections = await db.addCollections({\n                    humans: {\n                        schema\n                    }\n                });\n                const collection = collections.humans;\n\n                const testData = getTestData(1);\n                testData[0].name = 'Alice';\n                const server = await SpawnServer.spawn(testData);\n\n                const replicationState: RxGraphQLReplicationState<HumanWithTimestampDocumentType, any> = collection.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    deletedField: 'deleted'\n                });\n                await replicationState.awaitInitialReplication();\n\n                const docs = await collection.find().exec();\n                assert.strictEqual(docs.length, 1);\n                assert.strictEqual(docs[0].name, 'Alice');\n\n                const pouchDocs = await collection.storageInstance.internals.pouch.find({\n                    selector: {}\n                });\n                assert.ok(pouchDocs.docs[0].name !== 'Alice');\n\n                db.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"pull should work with keyCompression","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1713,"column":52},"line":1713,"code":"            it('pull should work with keyCompression', async () => {\n                if (config.storage.name !== 'pouchdb') {\n                    return;\n                }\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: wrappedKeyCompressionStorage({\n                        storage: config.storage.getStorage(),\n                    }),\n                    multiInstance: true,\n                    eventReduce: true,\n                    ignoreDuplicate: true,\n                    password: randomCouchString(10)\n                });\n                const schema = clone(schemas.humanWithTimestamp);\n                schema.keyCompression = true;\n                const collections = await db.addCollections({\n                    humans: {\n                        schema\n                    }\n                });\n                const collection = collections.humans;\n                const testData = getTestData(1);\n                testData[0].name = 'Alice';\n                const server = await SpawnServer.spawn(testData);\n\n                const replicationState = collection.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    deletedField: 'deleted'\n                });\n                await replicationState.awaitInitialReplication();\n\n                const docs = await collection.find().exec();\n                assert.strictEqual(docs.length, 1);\n                assert.strictEqual(docs[0].name, 'Alice');\n\n                const pouchDocs = await collection.storageInstance.internals.pouch.find({\n                    selector: {}\n                });\n\n                // first key must be compressed\n                assert.ok(Object.keys(pouchDocs.docs[0])[0].startsWith('|'));\n\n                server.close();\n                db.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"push should work with keyCompression","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1763,"column":52},"line":1763,"code":"            it('push should work with keyCompression', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: wrappedKeyCompressionStorage({\n                        storage: config.storage.getStorage()\n                    }),\n                    multiInstance: true,\n                    eventReduce: true,\n                    ignoreDuplicate: true,\n                    password: randomCouchString(10)\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: enableKeyCompression(schemas.humanWithTimestamp)\n                    }\n                });\n                const collection = collections.humans;\n                await collection.insert(schemaObjects.humanWithTimestamp());\n\n                const server = await SpawnServer.spawn<HumanWithTimestampDocumentType>([]);\n\n                const replicationState = collection.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        /**\n                         * TODO for whatever reason this test\n                         * does not work with batchSize=1\n                         */\n                        batchSize: 10,\n                        queryBuilder: doc => {\n                            const ret = pushQueryBuilder(doc);\n                            return ret;\n                        }\n                    },\n                    deletedField: 'deleted'\n                });\n                ensureReplicationHasNoErrors(replicationState);\n\n                await replicationState.awaitInitialReplication();\n\n                const serverDocs = server.getDocuments();\n                assert.strictEqual(serverDocs.length, 1);\n                assert.ok(serverDocs[0].age);\n\n                server.close();\n                db.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should pass and change credentials in GraphQL client","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1810,"column":68},"line":1810,"code":"            it('should pass and change credentials in GraphQL client', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(getTestData(1))\n                ]);\n\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    headers: {\n                        originalHeader: '1'\n\n                    },\n                    credentials: 'none',\n                    live: true,\n                    deletedField: 'deleted'\n                });\n                assert.strictEqual(replicationState.clientState.credentials, 'none')\n\n                replicationState.setCredentials('same-origin')\n\n                assert.deepStrictEqual(replicationState.clientState.headers, { originalHeader: '1' })\n                assert.strictEqual(replicationState.clientState.credentials, 'same-origin')\n\n                server.close();\n                await c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should work with headers","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1840,"column":40},"line":1840,"code":"            it('should work with headers', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(getTestData(1))\n                ]);\n\n                server.requireHeader('Authorization', 'password');\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    headers: {\n                        Authorization: 'password'\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n                await replicationState.awaitInitialReplication();\n\n                const docs = await c.find().exec();\n                assert.strictEqual(docs.length, 1);\n\n                server.close();\n                await c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should work after headers change","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1867,"column":48},"line":1867,"code":"            it('should work after headers change', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(getTestData(1))\n                ]);\n\n                server.requireHeader('Authorization', 'password');\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    headers: {\n                        Authorization: 'password'\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n                await replicationState.awaitInitialReplication();\n\n                server.requireHeader('Authorization', '1234');\n                const doc = getTestData(1).pop();\n                if (!doc) {\n                    throw new Error('missing doc');\n                }\n                await server.setDocument(doc);\n\n                replicationState.setHeaders({\n                    'Authorization': '1234'\n                });\n                await replicationState.reSync();\n                await replicationState.awaitInSync();\n\n                const docs = await c.find().exec();\n                assert.strictEqual(docs.length, 2);\n\n                server.close();\n                await c.database.destroy();\n\n                // replication should be canceled when collection is destroyed\n                assert.ok(replicationState.isStopped());\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should not lose error information","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1910,"column":49},"line":1910,"code":"            it('should not lose error information', async () => {\n                const [c, server] = await Promise.all([\n                    humansCollection.createHumanWithTimestamp(0),\n                    SpawnServer.spawn(getTestData(1))\n                ]);\n\n                server.requireHeader('Authorization', 'password');\n                const replicationState = c.syncGraphQL({\n                    url: server.url,\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    headers: {\n                        Authorization: 'wrong-password'\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n                const replicationError = await replicationState.error$.pipe(first()).toPromise();\n                assert.notStrictEqual(ensureNotFalsy(replicationError).message, '[object Object]');\n                server.close();\n                await c.database.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"push not working on slow db","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1936,"column":43},"line":1936,"code":"            it('push not working on slow db', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: wrappedKeyEncryptionStorage({\n                        storage: config.storage.getStorage(),\n                    }),\n                    multiInstance: true,\n                    eventReduce: true,\n                    ignoreDuplicate: true,\n                    password: randomCouchString(10)\n                });\n                const schema: RxJsonSchema<any> = clone(schemas.humanWithTimestampAllIndex);\n                schema.encrypted = ['name'];\n                const collections = await db.addCollections({\n                    humans: {\n                        schema\n                    }\n                });\n                const collection = collections.humans;\n\n                // insert data to slow down the db\n                const amount = 30;\n                await Promise.all(\n                    new Array(amount).fill(0)\n                        .map(() => schemaObjects.humanWithTimestamp())\n                        .map(d => collection.insert(d))\n                );\n                const server = await SpawnServer.spawn(getTestData(0));\n                const replicationState = collection.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n                await replicationState.awaitInitialReplication();\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, amount);\n\n                // insert one which will trigger an auto push\n                await collection.insert(schemaObjects.humanWithTimestamp());\n\n                await waitUntil(async () => {\n                    const docs = await server.getDocuments();\n                    return docs.length === (amount + 1);\n                });\n\n                server.close();\n                db.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"push not working when big amount of docs was pulled before","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":1988,"column":74},"line":1988,"code":"            it('push not working when big amount of docs was pulled before', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: wrappedKeyEncryptionStorage({\n                        storage: config.storage.getStorage(),\n                    }),\n                    multiInstance: true,\n                    eventReduce: true,\n                    ignoreDuplicate: true,\n                    password: randomCouchString(10)\n                });\n                const schema: RxJsonSchema<any> = clone(schemas.humanWithTimestampAllIndex);\n                schema.encrypted = ['name'];\n                const collections = await db.addCollections({\n                    humans: {\n                        schema\n                    }\n                });\n                const collection = collections.humans;\n\n                const amount = 50;\n                const testData = getTestData(amount);\n                const server = await SpawnServer.spawn(testData);\n\n                const replicationState = collection.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n                ensureReplicationHasNoErrors(replicationState);\n                await replicationState.awaitInitialReplication();\n\n                const docsOnServer = server.getDocuments();\n                assert.strictEqual(docsOnServer.length, amount);\n\n                // insert one which will trigger an auto push\n                const insertedDoc = await collection.insert(schemaObjects.humanWithTimestamp());\n                assert.ok(insertedDoc);\n\n                await waitUntil(async () => {\n                    const docs = await server.getDocuments();\n                    if (docs.length > (amount + 1)) {\n                        throw new Error('too many docs');\n                    }\n                    return docs.length === (amount + 1);\n                });\n\n                server.close();\n                db.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"#1812 updates fail when graphql is enabled","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":2046,"column":58},"line":2046,"code":"            it('#1812 updates fail when graphql is enabled', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: wrappedValidateAjvStorage({\n                        storage: config.storage.getStorage()\n                    }),\n                    multiInstance: false,\n                    eventReduce: true,\n                    password: randomCouchString(10)\n                });\n                const schema: RxJsonSchema<any> = clone(schemas.humanWithTimestampAllIndex);\n                const collections = await db.addCollections({\n                    humans: {\n                        schema\n                    }\n                });\n                const collection = collections.humans;\n\n                const server = await SpawnServer.spawn();\n                assert.strictEqual(server.getDocuments().length, 0);\n\n                // start live replication\n                const replicationState = collection.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n                ensureReplicationHasNoErrors(replicationState);\n\n                // ensure we are in sync even when there are no doc in the db at this moment\n                await replicationState.awaitInitialReplication();\n\n                // add one doc to the client database\n                const testData = ensureNotFalsy(getTestData(1).pop());\n                testData.id = 'first';\n                delete (testData as any).deleted;\n                await collection.insert(testData);\n\n                // sync\n                await replicationState.reSync();\n                await replicationState.awaitInSync();\n\n                assert.strictEqual(server.getDocuments().length, 1);\n\n                // update document\n                const newAge = 1111;\n                const doc = await collection.findOne().exec(true);\n                await doc.atomicPatch({\n                    age: newAge,\n                    updatedAt: new Date().getTime()\n                });\n\n                const docAfter = await collection.findOne().exec(true);\n                assert.strictEqual(docAfter.age, newAge);\n\n                // check server\n                await replicationState.reSync();\n                await replicationState.awaitInSync();\n\n                await waitUntil(() => {\n                    const serverDocs = server.getDocuments();\n                    const notUpdated = serverDocs.find((d: any) => d.age !== newAge);\n                    return !notUpdated;\n                }, 1000, 200);\n\n                await db.destroy();\n                await server.close();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"#3856 atomicUpsert not working","suites":["replication-graphql.test.ts","node"],"updatePoint":{"line":2122,"column":46},"line":2122,"code":"            it('#3856 atomicUpsert not working', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    multiInstance: false,\n                    eventReduce: true,\n                    password: randomCouchString(10),\n                });\n                const schema: RxJsonSchema<any> = clone(schemas.humanWithTimestampAllIndex);\n                const collections = await db.addCollections({\n                    humans: {\n                        schema,\n                    },\n                });\n                const collection = collections.humans;\n\n                const server = await SpawnServer.spawn();\n                assert.strictEqual(server.getDocuments().length, 0);\n\n                // start live replication\n                const replicationState = collection.syncGraphQL({\n                    url: server.url,\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder,\n                    },\n                    pull: {\n                        batchSize,\n                        queryBuilder: pullQueryBuilder,\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n                ensureReplicationHasNoErrors(replicationState);\n\n                // ensure we are in sync even when there are no doc in the db at this moment\n                await replicationState.awaitInitialReplication();\n\n                // add one doc to the client database\n                const testData = getTestData(1).pop();\n                delete (testData as any).deleted;\n                await collection.insert(testData);\n\n                // sync\n                await replicationState.reSync();\n                await replicationState.awaitInSync();\n\n                assert.strictEqual(server.getDocuments().length, 1);\n\n                // update document\n                const newAge = 1111;\n                await collection.atomicUpsert({\n                    id: testData?.id,\n                    age: newAge,\n                    name: testData?.name,\n                    updatedAt: testData?.updatedAt,\n                });\n\n                const docAfter = await collection.findOne().exec(true);\n                assert.strictEqual(docAfter.age, newAge);\n\n                // check server\n                await replicationState.reSync();\n                await replicationState.awaitInSync();\n\n                await waitUntil(() => {\n                    const serverDocs = server.getDocuments();\n                    const notUpdated = serverDocs.find(\n                        (d: any) => d.age !== newAge\n                    );\n                    return !notUpdated;\n                });\n\n                await db.destroy();\n                await server.close();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"push not working on slow db","suites":["replication-graphql.test.ts","browser","issues"],"updatePoint":{"line":2205,"column":43},"line":2205,"code":"            it('push not working on slow db', async () => {\n                const dbName = randomCouchString(10);\n                const db = await createRxDatabase({\n                    name: dbName,\n                    storage: getRxStoragePouch('idb'),\n                    multiInstance: true,\n                    eventReduce: true,\n                    ignoreDuplicate: true\n                });\n                const collections = await db.addCollections({\n                    humans: {\n                        schema: schemas.humanWithTimestampAllIndex\n                    }\n                });\n                const collection = collections.humans;\n\n                // insert data to slow down the db\n                const amount = 30;\n                await Promise.all(\n                    new Array(amount).fill(0)\n                        .map(() => schemaObjects.humanWithTimestamp())\n                        .map(d => collection.insert(d))\n                );\n\n                const replicationState = collection.syncGraphQL({\n                    url: {\n                        http: browserServerUrl\n                    },\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: false,\n                    deletedField: 'deleted'\n                });\n                await replicationState.awaitInitialReplication();\n\n                const docsStart = await getDocsOnServer(replicationState);\n\n                // amount might be bigger if 2 browser run parallel\n                assert.ok(docsStart.length >= amount);\n\n                await db.destroy();\n\n                // insert one in new instance of same db\n                // which will trigger an auto push\n                const db2 = await createRxDatabase({\n                    name: dbName,\n                    storage: getRxStoragePouch('idb'),\n                    multiInstance: true,\n                    eventReduce: true,\n                    ignoreDuplicate: true\n                });\n                const collections2 = await db2.addCollections({\n                    humans: {\n                        schema: schemas.humanWithTimestampAllIndex\n                    }\n                });\n                const collection2 = collections2.humans;\n                const replicationState2 = collection2.syncGraphQL({\n                    url: {\n                        http: browserServerUrl\n                    },\n                    push: {\n                        batchSize,\n                        queryBuilder: pushQueryBuilder\n                    },\n                    live: true,\n                    deletedField: 'deleted'\n                });\n                await replicationState2.awaitInitialReplication();\n                const addDoc = schemaObjects.humanWithTimestamp();\n                await collection2.insert(addDoc);\n\n                await waitUntil(async () => {\n                    const docsEnd = await getDocsOnServer(replicationState);\n                    const found = docsEnd.find(d => d.id === addDoc.id);\n                    return !!found;\n                });\n                db2.destroy();\n            });","file":"unit/replication-graphql.test.ts","skipped":false,"dir":"test"},{"name":"should not write a duplicate checkpoint","suites":["helpers","checkpoint"],"updatePoint":{"line":250,"column":55},"line":250,"code":"            it('should not write a duplicate checkpoint', async () => {\n                const masterInstance = await createRxStorageInstance(1);\n                const forkInstance = await createRxStorageInstance(0);\n                const metaInstance = await createMetaInstance();\n\n                const writeResult = await masterInstance.bulkWrite([{\n                    document: getDocData()\n                }], testContext);\n                assert.deepStrictEqual(writeResult.error, {});\n\n                const replicationState = replicateRxStorageInstance({\n                    identifier: randomCouchString(10),\n                    replicationHandler: rxStorageInstanceToReplicationHandler(\n                        masterInstance,\n                        THROWING_CONFLICT_HANDLER,\n                        defaultHashFunction\n                    ),\n                    forkInstance,\n                    metaInstance,\n                    pullBatchSize: 100,\n                    pushBatchSize: 100,\n                    conflictHandler: THROWING_CONFLICT_HANDLER,\n                    hashFunction: defaultHashFunction\n                });\n                await awaitRxStorageReplicationFirstInSync(replicationState);\n                await awaitRxStorageReplicationInSync(replicationState);\n\n\n                const checkpointDocId = getComposedPrimaryKeyOfDocumentData(\n                    RX_REPLICATION_META_INSTANCE_SCHEMA,\n                    {\n                        isCheckpoint: '1',\n                        itemId: 'down',\n                        replicationIdentifier: replicationState.checkpointKey\n                    }\n                );\n\n                let checkpointDocBefore: any;\n                while (!checkpointDocBefore) {\n                    const response = await replicationState.input.metaInstance.findDocumentsById(\n                        [checkpointDocId],\n                        false\n                    );\n                    if (response[checkpointDocId]) {\n                        checkpointDocBefore = response[checkpointDocId];\n                    }\n                    await wait(20);\n                }\n\n                await setCheckpoint(\n                    replicationState,\n                    'down',\n                    clone(checkpointDocBefore.data)\n                );\n\n                const checkpointDocAfterResult = await replicationState.input.metaInstance.findDocumentsById(\n                    [checkpointDocId],\n                    false\n                );\n                const checkpointDocAfter = getFromObjectOrThrow(checkpointDocAfterResult, checkpointDocId);\n\n                assert.strictEqual(\n                    checkpointDocAfter._rev,\n                    checkpointDocBefore._rev\n                );\n\n                await cleanUp(replicationState, masterInstance);\n            });","file":"unit/replication-protocol.test.ts","skipped":false,"dir":"test"},{"name":"it should write the initial data and also the ongoing insert","suites":["down"],"updatePoint":{"line":322,"column":72},"line":322,"code":"        it('it should write the initial data and also the ongoing insert', async () => {\n            const masterInstance = await createRxStorageInstance(1);\n            const forkInstance = await createRxStorageInstance(0);\n            const metaInstance = await createMetaInstance();\n\n            const replicationState = replicateRxStorageInstance({\n                identifier: randomCouchString(10),\n                replicationHandler: rxStorageInstanceToReplicationHandler(\n                    masterInstance,\n                    THROWING_CONFLICT_HANDLER,\n                    defaultHashFunction\n                ),\n                forkInstance,\n                metaInstance,\n                pullBatchSize: 100,\n                pushBatchSize: 100,\n                conflictHandler: THROWING_CONFLICT_HANDLER,\n                hashFunction: defaultHashFunction\n            });\n            await awaitRxStorageReplicationFirstInSync(replicationState);\n\n            // check inital doc\n            const docsOnFork = await runQuery(forkInstance);\n            assert.strictEqual(docsOnFork.length, 1);\n\n            // check ongoing doc\n            await masterInstance.bulkWrite([{\n                document: getDocData()\n            }], testContext);\n\n            await waitUntil(async () => {\n                const docsOnFork2 = await runQuery(forkInstance);\n                return docsOnFork2.length === 2;\n            });\n\n            await cleanUp(replicationState, masterInstance);\n        });","file":"unit/replication-protocol.test.ts","skipped":false,"dir":"test"},{"name":"it should write the initial data and also the ongoing insert","suites":["up"],"updatePoint":{"line":361,"column":72},"line":361,"code":"        it('it should write the initial data and also the ongoing insert', async () => {\n            const masterInstance = await createRxStorageInstance(0);\n            const forkInstance = await createRxStorageInstance(1);\n            const metaInstance = await createMetaInstance();\n\n\n            const replicationState = replicateRxStorageInstance({\n                identifier: randomCouchString(10),\n                replicationHandler: rxStorageInstanceToReplicationHandler(masterInstance, THROWING_CONFLICT_HANDLER, defaultHashFunction),\n                forkInstance,\n                metaInstance,\n                pullBatchSize: 100,\n                pushBatchSize: 100,\n                conflictHandler: THROWING_CONFLICT_HANDLER,\n                hashFunction: defaultHashFunction\n            });\n            await awaitRxStorageReplicationFirstInSync(replicationState);\n\n            // check inital doc\n            const docsOnMaster = await runQuery(masterInstance);\n            assert.strictEqual(docsOnMaster.length, 1);\n\n\n\n            // check ongoing doc\n            await forkInstance.bulkWrite([{\n                document: getDocData()\n            }], testContext);\n\n            await waitUntil(async () => {\n                const docsOnMaster2 = await runQuery(masterInstance);\n                return docsOnMaster2.length === 2;\n            });\n\n            await cleanUp(replicationState, masterInstance);\n        });","file":"unit/replication-protocol.test.ts","skipped":false,"dir":"test"},{"name":"should replicate the insert and the update and the delete","suites":["up"],"updatePoint":{"line":397,"column":69},"line":397,"code":"        it('should replicate the insert and the update and the delete', async () => {\n            const masterInstance = await createRxStorageInstance(0);\n            const forkInstance = await createRxStorageInstance(1);\n            const metaInstance = await createMetaInstance();\n\n            const replicationState = replicateRxStorageInstance({\n                identifier: randomCouchString(10),\n                replicationHandler: rxStorageInstanceToReplicationHandler(masterInstance, HIGHER_AGE_CONFLICT_HANDLER, defaultHashFunction),\n                forkInstance,\n                metaInstance,\n                pullBatchSize: 100,\n                pushBatchSize: 100,\n                conflictHandler: HIGHER_AGE_CONFLICT_HANDLER,\n                hashFunction: defaultHashFunction\n            });\n\n            const passportId = 'foobar';\n\n            // INSERT\n\n            const docData = getDocData({\n                passportId,\n                age: 1\n            });\n\n            const writeResult = await forkInstance.bulkWrite([{\n                document: docData\n            }], testContext);\n            assert.deepStrictEqual(writeResult.error, {});\n            let previous = getFromObjectOrThrow(writeResult.success, passportId);\n\n            // wait until it is replicated to the master\n            await waitUntil(async () => {\n                const docsAfterUpdate = await masterInstance.findDocumentsById([passportId], false);\n                return docsAfterUpdate[passportId];\n            });\n\n            // UPDATE\n\n            const updateData: typeof docData = clone(docData);\n            updateData.firstName = 'xxx';\n            updateData.age = 2;\n            updateData._rev = EXAMPLE_REVISION_2;\n            updateData._meta.lwt = now();\n\n            const updateResult = await forkInstance.bulkWrite([{\n                previous,\n                document: updateData\n            }], testContext);\n            assert.deepStrictEqual(updateResult.error, {});\n            previous = getFromObjectOrThrow(updateResult.success, passportId);\n\n            // wait until the change is replicated to the master\n            await waitUntil(async () => {\n                const docsAfterUpdate = await masterInstance.findDocumentsById([passportId], false);\n                return docsAfterUpdate[passportId].firstName === 'xxx';\n            });\n            await ensureEqualState(masterInstance, forkInstance);\n\n            // DELETE\n            const deleteData: typeof docData = clone(docData);\n            deleteData._rev = EXAMPLE_REVISION_3;\n            deleteData._deleted = true;\n            deleteData._meta.lwt = now();\n            const deleteResult = await forkInstance.bulkWrite([{\n                previous,\n                document: deleteData\n            }], testContext);\n            assert.deepStrictEqual(deleteResult.error, {});\n\n            // wait until the change is replicated to the master\n            await waitUntil(async () => {\n                const docsAfterUpdate = await masterInstance.findDocumentsById([passportId], false);\n                return !docsAfterUpdate[passportId];\n            });\n            await ensureEqualState(masterInstance, forkInstance);\n\n            await cleanUp(replicationState, masterInstance);\n        });","file":"unit/replication-protocol.test.ts","skipped":false,"dir":"test"},{"name":"should be able to replicate A->Master<-B","suites":["different configurations"],"updatePoint":{"line":478,"column":52},"line":478,"code":"        it('should be able to replicate A->Master<-B', async () => {\n            const masterInstance = await createRxStorageInstance(0);\n            const forkInstanceA = await createRxStorageInstance(0);\n            const metaInstanceA = await createMetaInstance();\n            const forkInstanceB = await createRxStorageInstance(0);\n            const metaInstanceB = await createMetaInstance();\n\n            const replicationStateAtoMaster = replicateRxStorageInstance({\n                identifier: randomCouchString(10),\n                replicationHandler: rxStorageInstanceToReplicationHandler(masterInstance, THROWING_CONFLICT_HANDLER, defaultHashFunction),\n                forkInstance: forkInstanceA,\n                metaInstance: metaInstanceA,\n                pullBatchSize: 100,\n                pushBatchSize: 100,\n                conflictHandler: THROWING_CONFLICT_HANDLER,\n                hashFunction: defaultHashFunction\n            });\n\n            const replicationStateBtoMaster = replicateRxStorageInstance({\n                identifier: randomCouchString(10),\n                replicationHandler: rxStorageInstanceToReplicationHandler(masterInstance, THROWING_CONFLICT_HANDLER, defaultHashFunction),\n                forkInstance: forkInstanceB,\n                metaInstance: metaInstanceB,\n                pullBatchSize: 100,\n                pushBatchSize: 100,\n                conflictHandler: THROWING_CONFLICT_HANDLER,\n                hashFunction: defaultHashFunction\n            });\n\n            // insert a document on A\n            const writeData = getDocData();\n            await forkInstanceA.bulkWrite(\n                [{ document: writeData }],\n                testContext\n            );\n\n            // find the document on B\n            await waitUntil(async () => {\n                try {\n                    const foundAgain = await forkInstanceB.findDocumentsById([writeData.passportId], false);\n                    const foundDoc = getFromObjectOrThrow(foundAgain, writeData.passportId);\n                    assert.strictEqual(foundDoc.passportId, writeData.passportId);\n                    return true;\n                } catch (err) {\n                    return false;\n                }\n            }, 10 * 1000, 100);\n\n            await cleanUp(replicationStateAtoMaster, masterInstance);\n            await cleanUp(replicationStateBtoMaster, masterInstance);\n        });","file":"unit/replication-protocol.test.ts","skipped":false,"dir":"test"},{"name":"should be able to replicate A->B->C->Master","suites":["different configurations"],"updatePoint":{"line":529,"column":55},"line":529,"code":"        it('should be able to replicate A->B->C->Master', async () => {\n            const masterInstance = await createRxStorageInstance(0);\n            const forkInstanceA = await createRxStorageInstance(0);\n            const metaInstanceA = await createMetaInstance();\n            const forkInstanceB = await createRxStorageInstance(0);\n            const metaInstanceB = await createMetaInstance();\n            const forkInstanceC = await createRxStorageInstance(0);\n            const metaInstanceC = await createMetaInstance();\n\n            const replicationStateAtoB = replicateRxStorageInstance({\n                identifier: randomCouchString(10),\n                replicationHandler: rxStorageInstanceToReplicationHandler(forkInstanceB, THROWING_CONFLICT_HANDLER, defaultHashFunction),\n                forkInstance: forkInstanceA,\n                metaInstance: metaInstanceA,\n                pullBatchSize: 100,\n                pushBatchSize: 100,\n                conflictHandler: THROWING_CONFLICT_HANDLER,\n                hashFunction: defaultHashFunction\n            });\n            const replicationStateBtoC = replicateRxStorageInstance({\n                identifier: randomCouchString(10),\n                replicationHandler: rxStorageInstanceToReplicationHandler(forkInstanceC, THROWING_CONFLICT_HANDLER, defaultHashFunction),\n                forkInstance: forkInstanceB,\n                metaInstance: metaInstanceB,\n                pullBatchSize: 100,\n                pushBatchSize: 100,\n                conflictHandler: THROWING_CONFLICT_HANDLER,\n                hashFunction: defaultHashFunction\n            });\n            const replicationStateCtoMaster = replicateRxStorageInstance({\n                identifier: randomCouchString(10),\n                replicationHandler: rxStorageInstanceToReplicationHandler(masterInstance, THROWING_CONFLICT_HANDLER, defaultHashFunction),\n                forkInstance: forkInstanceC,\n                metaInstance: metaInstanceC,\n                pullBatchSize: 100,\n                pushBatchSize: 100,\n                conflictHandler: THROWING_CONFLICT_HANDLER,\n                hashFunction: defaultHashFunction\n            });\n\n            // insert a document on A\n            const writeData = getDocData();\n            await forkInstanceA.bulkWrite(\n                [{ document: writeData }],\n                testContext\n            );\n\n            async function waitUntilADocExists(\n                instance: typeof forkInstanceA\n            ) {\n                await waitUntil(async () => {\n                    try {\n                        const foundAgain = await instance.findDocumentsById([writeData.passportId], false);\n                        const foundDoc = getFromObjectOrThrow(foundAgain, writeData.passportId);\n                        assert.strictEqual(foundDoc.passportId, writeData.passportId);\n                        return true;\n                    } catch (err) {\n                        return false;\n                    }\n                }, 10 * 1000, 50);\n            }\n\n            await Promise.all([\n                waitUntilADocExists(forkInstanceA),\n                waitUntilADocExists(forkInstanceB),\n                waitUntilADocExists(forkInstanceC),\n                waitUntilADocExists(masterInstance)\n            ]);\n\n            // insert a document on Master\n            const writeDataMaster = getDocData();\n            await masterInstance.bulkWrite(\n                [{ document: writeDataMaster }],\n                testContext\n            );\n\n            async function waitUntilMasterDocExists(\n                instance: typeof forkInstanceA\n            ) {\n                await waitUntil(async () => {\n                    try {\n                        const foundAgain = await instance.findDocumentsById([writeDataMaster.passportId], false);\n                        const foundDoc = getFromObjectOrThrow(foundAgain, writeDataMaster.passportId);\n                        assert.strictEqual(foundDoc.passportId, writeDataMaster.passportId);\n                        return true;\n                    } catch (err) {\n                        return false;\n                    }\n                }, 10 * 1000, 50);\n            }\n\n            // find the document on C\n            await waitUntilMasterDocExists(forkInstanceC);\n            // find the document on B\n            await waitUntilMasterDocExists(forkInstanceB);\n            // find the document on A\n            await waitUntilMasterDocExists(forkInstanceA);\n\n            await cleanUp(replicationStateAtoB, masterInstance);\n            await cleanUp(replicationStateBtoC, masterInstance);\n            await cleanUp(replicationStateCtoMaster, masterInstance);\n        });","file":"unit/replication-protocol.test.ts","skipped":false,"dir":"test"},{"name":"on multi instance it should be able to mount on top of the same storage config with a different instance","suites":["different configurations"],"updatePoint":{"line":631,"column":116},"line":631,"code":"        it('on multi instance it should be able to mount on top of the same storage config with a different instance', async () => {\n            if (!config.storage.hasMultiInstance) {\n                return;\n            }\n\n\n            const databaseName = randomCouchString(12);\n            const collectionName = randomCouchString(12);\n\n            const masterInstanceA = await createRxStorageInstance(0, databaseName, collectionName);\n            const masterInstanceB = await createRxStorageInstance(0, databaseName, collectionName);\n\n            const forkInstanceA = await createRxStorageInstance(0);\n            const metaInstanceA = await createMetaInstance();\n            const forkInstanceB = await createRxStorageInstance(0);\n            const metaInstanceB = await createMetaInstance();\n\n\n            const replicationStateAtoMaster = replicateRxStorageInstance({\n                identifier: randomCouchString(10),\n                replicationHandler: rxStorageInstanceToReplicationHandler(masterInstanceA, THROWING_CONFLICT_HANDLER, defaultHashFunction),\n                forkInstance: forkInstanceA,\n                metaInstance: metaInstanceA,\n                pullBatchSize: 100,\n                pushBatchSize: 100,\n                conflictHandler: THROWING_CONFLICT_HANDLER,\n                hashFunction: defaultHashFunction\n            });\n            const replicationStateBtoMaster = replicateRxStorageInstance({\n                identifier: randomCouchString(10),\n                replicationHandler: rxStorageInstanceToReplicationHandler(masterInstanceB, THROWING_CONFLICT_HANDLER, defaultHashFunction),\n                forkInstance: forkInstanceB,\n                metaInstance: metaInstanceB,\n                pullBatchSize: 100,\n                pushBatchSize: 100,\n                conflictHandler: THROWING_CONFLICT_HANDLER,\n                hashFunction: defaultHashFunction\n            });\n\n            // insert a document on A\n            const writeData = getDocData();\n            await forkInstanceA.bulkWrite(\n                [{ document: writeData }],\n                testContext\n            );\n\n\n            // find the document on B\n            await waitUntil(async () => {\n                try {\n                    const foundAgain = await forkInstanceB.findDocumentsById([writeData.passportId], false);\n                    const foundDoc = getFromObjectOrThrow(foundAgain, writeData.passportId);\n                    assert.strictEqual(foundDoc.passportId, writeData.passportId);\n                    return true;\n                } catch (err) {\n                    return false;\n                }\n            }, 10 * 1000, 100);\n\n            await cleanUp(replicationStateAtoMaster, masterInstanceA);\n            await cleanUp(replicationStateBtoMaster, masterInstanceB);\n        });","file":"unit/replication-protocol.test.ts","skipped":false,"dir":"test"},{"name":"both have inserted the exact same document -> no conflict handler must be called","suites":["conflict handling"],"updatePoint":{"line":695,"column":92},"line":695,"code":"        it('both have inserted the exact same document -> no conflict handler must be called', async () => {\n            const masterInstance = await createRxStorageInstance(0);\n            const forkInstance = await createRxStorageInstance(0);\n            const metaInstance = await createMetaInstance();\n            const instances = [masterInstance, forkInstance];\n\n            const document = getDocData();\n\n            await Promise.all(\n                instances\n                    .map(instance => instance.bulkWrite(\n                        [{ document }],\n                        testContext\n                    ))\n            );\n\n            const replicationState = replicateRxStorageInstance({\n                identifier: randomCouchString(10),\n                replicationHandler: rxStorageInstanceToReplicationHandler(masterInstance, THROWING_CONFLICT_HANDLER, defaultHashFunction),\n                forkInstance,\n                metaInstance,\n                pullBatchSize: 100,\n                pushBatchSize: 100,\n                conflictHandler: THROWING_CONFLICT_HANDLER,\n                hashFunction: defaultHashFunction\n            });\n            await awaitRxStorageReplicationFirstInSync(replicationState);\n\n            await ensureEqualState(masterInstance, forkInstance);\n\n            const masterDocs = await runQuery(masterInstance);\n            assert.ok(masterDocs[0]._rev.startsWith('1-'));\n\n            await cleanUp(replicationState, masterInstance);\n        });","file":"unit/replication-protocol.test.ts","skipped":false,"dir":"test"},{"name":"both have inserted the same document with different properties","suites":["conflict handling"],"updatePoint":{"line":730,"column":74},"line":730,"code":"        it('both have inserted the same document with different properties', async () => {\n            const masterInstance = await createRxStorageInstance(0);\n            const forkInstance = await createRxStorageInstance(0);\n            const metaInstance = await createMetaInstance();\n            const instances = [masterInstance, forkInstance];\n\n            const document = getDocData();\n\n\n\n            await Promise.all(\n                instances\n                    .map(async (instance, idx) => {\n                        const docData = Object.assign({}, clone(document), {\n                            firstName: idx === 0 ? 'master' : 'fork',\n                            age: idx\n                        });\n                        docData._rev = createRevision(defaultHashFunction, docData);\n                        docData._meta.lwt = now();\n                        await instance.bulkWrite([{\n                            document: docData\n                        }], testContext)\n                    })\n            );\n\n            const replicationState = replicateRxStorageInstance({\n                identifier: randomCouchString(10),\n                replicationHandler: rxStorageInstanceToReplicationHandler(\n                    masterInstance,\n                    HIGHER_AGE_CONFLICT_HANDLER,\n                    defaultHashFunction\n                ),\n                forkInstance,\n                metaInstance,\n                pullBatchSize: 100,\n                pushBatchSize: 100,\n                conflictHandler: HIGHER_AGE_CONFLICT_HANDLER,\n                hashFunction: defaultHashFunction\n            });\n\n            await awaitRxStorageReplicationFirstInSync(replicationState);\n            await ensureEqualState(masterInstance, forkInstance);\n\n            // revision must be 2 because it had to resolve a conflict.\n            const masterDocs = await runQuery(masterInstance);\n\n            assert.ok(masterDocs[0]._rev.startsWith('2-'));\n\n            /**\n             * Ensure it only contains the _meta fields that we really need.\n             */\n            const masterDoc = (await runQuery(masterInstance))[0];\n            // should only have the 'lwt'\n            assert.strictEqual(Object.keys(masterDoc._meta).length, 1);\n\n            // const forkDoc = (await runQuery(forkInstance))[0];\n            // should only have the 'lwt' AND the current state of the master.\n            // assert.strictEqual(Object.keys(forkDoc._meta).length, 3); // TODO\n\n            cleanUp(replicationState, masterInstance);\n        });","file":"unit/replication-protocol.test.ts","skipped":false,"dir":"test"},{"name":"both have updated the document with different values","suites":["conflict handling"],"updatePoint":{"line":791,"column":64},"line":791,"code":"        it('both have updated the document with different values', async () => {\n            const masterInstance = await createRxStorageInstance(0);\n            const forkInstance = await createRxStorageInstance(0);\n            const metaInstance = await createMetaInstance();\n            const instances = [masterInstance, forkInstance];\n\n            const document = getDocData();\n\n            await Promise.all(\n                instances\n                    .map(async (instance, idx) => {\n                        // insert\n                        const docData = Object.assign({}, clone(document), {\n                            firstName: idx === 0 ? 'master' : 'fork',\n                            age: idx\n                        });\n                        docData._rev = createRevision(defaultHashFunction, docData);\n                        docData._meta.lwt = now();\n                        await instance.bulkWrite([{\n                            document: docData\n                        }], testContext);\n\n                        // update\n                        const newDocData = clone(docData);\n                        newDocData.age = newDocData.age + 1;\n                        newDocData._rev = createRevision(defaultHashFunction, newDocData, docData);\n                        newDocData._meta.lwt = now();\n                        const updateResult = await instance.bulkWrite([{\n                            previous: docData,\n                            document: newDocData\n                        }], testContext);\n                        assert.deepStrictEqual(updateResult.error, {});\n                    })\n            );\n\n\n            const replicationState = replicateRxStorageInstance({\n                identifier: randomCouchString(10),\n                replicationHandler: rxStorageInstanceToReplicationHandler(masterInstance, HIGHER_AGE_CONFLICT_HANDLER, defaultHashFunction),\n                forkInstance,\n                metaInstance,\n                pullBatchSize: 100,\n                pushBatchSize: 100,\n                conflictHandler: HIGHER_AGE_CONFLICT_HANDLER,\n                hashFunction: defaultHashFunction\n            });\n\n            await awaitRxStorageReplicationFirstInSync(replicationState);\n            await ensureEqualState(masterInstance, forkInstance);\n\n            cleanUp(replicationState, masterInstance);\n        });","file":"unit/replication-protocol.test.ts","skipped":false,"dir":"test"},{"name":"doing many writes on the fork should not lead to many writes on the master","suites":["conflict handling"],"updatePoint":{"line":843,"column":86},"line":843,"code":"        it('doing many writes on the fork should not lead to many writes on the master', async () => {\n            const writeAmount = config.isFastMode() ? 5 : 100;\n\n            const masterInstance = await createRxStorageInstance(0);\n            const forkInstance = await createRxStorageInstance(0);\n            const metaInstance = await createMetaInstance();\n\n            /**\n            * Wrap bulkWrite() to count the calls\n            */\n            let writesOnMaster = 0;\n            let writesOnFork = 0;\n            const masterBulkWriteBefore = masterInstance.bulkWrite.bind(masterInstance);\n            masterInstance.bulkWrite = (i) => {\n                writesOnMaster++;\n                return masterBulkWriteBefore(i, testContext);\n            };\n            const forkBulkWriteBefore = forkInstance.bulkWrite.bind(forkInstance);\n            forkInstance.bulkWrite = (i) => {\n                writesOnFork++;\n                return forkBulkWriteBefore(i, testContext);\n            };\n\n\n            const replicationState = replicateRxStorageInstance({\n                identifier: randomCouchString(10),\n                replicationHandler: rxStorageInstanceToReplicationHandler(masterInstance, HIGHER_AGE_CONFLICT_HANDLER, defaultHashFunction),\n                forkInstance,\n                metaInstance,\n                pullBatchSize: Math.ceil(writeAmount / 4),\n                pushBatchSize: Math.ceil(writeAmount / 4),\n                conflictHandler: HIGHER_AGE_CONFLICT_HANDLER,\n                /**\n                 * To give the fork some time to do additional writes\n                 * before the persistence is running,\n                 * we await 50 milliseconds.\n                 */\n                waitBeforePersist: () => promiseWait(70),\n                hashFunction: defaultHashFunction\n            });\n\n            // insert\n            const document = getDocData();\n            document.passportId = 'foobar-x';\n            const docId = document.passportId;\n            const docData = Object.assign({}, clone(document), {\n                age: 0\n            });\n            docData._rev = createRevision(defaultHashFunction, docData);\n            docData._meta.lwt = now();\n            const insertResult = await forkInstance.bulkWrite([{\n                document: docData\n            }], testContext);\n            assert.deepStrictEqual(insertResult.error, {});\n\n\n            let updateId = 10;\n            async function updateDocOnce() {\n                let done = false;\n                while (!done) {\n                    if (randomBoolean()) {\n                        await wait(0);\n                    }\n                    const current = await forkInstance.findDocumentsById([docId], true);\n                    const currentDocState = getFromObjectOrThrow(current, docId);\n                    const newDocState = clone(currentDocState);\n                    newDocState._meta.lwt = now();\n                    newDocState.lastName = randomCouchString(12);\n                    newDocState.age = updateId++;\n                    newDocState._rev = createRevision(defaultHashFunction, newDocState, currentDocState);\n\n                    const writeRow = {\n                        previous: currentDocState,\n                        document: newDocState\n                    };\n                    const writeResult = await forkInstance.bulkWrite([writeRow], testContext);\n                    if (Object.keys(writeResult.success).length > 0) {\n                        done = true;\n                    }\n                }\n            }\n\n\n            let writesDone = 0;\n            while (writeAmount > writesDone) {\n                writesDone++;\n                await updateDocOnce();\n            }\n\n            /**\n             * Check write amounts.\n             * Comparing the write amount in fast mode\n             * makes no sense because we do too less writes\n             * to make a difference.\n             */\n            if (!config.isFastMode()) {\n                assert.ok(\n                    /**\n                     * Here we do a '<=' instead of just a '<'\n                     * because on firefox this randomly fails\n                     * because firefox IndexedDB is so slow.\n                     */\n                    writesOnMaster <= writeAmount,\n                    'Writes on master(' + writesOnMaster + ') not smaller then writeAmount (' + writeAmount + ')'\n                );\n                assert.ok(\n                    writesOnMaster < writesOnFork,\n                    'Writes on master(' + writesOnMaster + ') not smaller then writes on fork (' + writesOnFork + ')'\n                );\n            }\n\n\n            cleanUp(replicationState, masterInstance);\n        });","file":"unit/replication-protocol.test.ts","skipped":false,"dir":"test"},{"name":"do many writes while replication is running","suites":["stability"],"updatePoint":{"line":959,"column":55},"line":959,"code":"        it('do many writes while replication is running', async () => {\n            if (config.storage.name === 'lokijs') {\n                // TODO this test fails in about 1/20 times in lokijs\n                return;\n            }\n\n            const writeAmount = config.isFastMode() ? 5 : 30;\n\n            const masterInstance = await createRxStorageInstance(0);\n            const forkInstance = await createRxStorageInstance(0);\n            const metaInstance = await createMetaInstance();\n\n            const instances = [masterInstance, forkInstance];\n            const replicationState = replicateRxStorageInstance({\n                identifier: randomCouchString(10),\n                replicationHandler: rxStorageInstanceToReplicationHandler(masterInstance, HIGHER_AGE_CONFLICT_HANDLER, defaultHashFunction),\n                forkInstance,\n                metaInstance,\n                pullBatchSize: Math.ceil(writeAmount / 4),\n                pushBatchSize: Math.ceil(writeAmount / 4),\n                conflictHandler: HIGHER_AGE_CONFLICT_HANDLER,\n                hashFunction: defaultHashFunction\n            });\n\n            // insert\n            const document = getDocData();\n            document.passportId = 'foobar';\n            const docId = document.passportId;\n            await Promise.all(\n                instances\n                    .map(async (instance, idx) => {\n                        // insert\n                        const docData = Object.assign({}, clone(document), {\n                            firstName: idx === 0 ? 'master' : 'fork',\n                            age: idx\n                        });\n                        docData._rev = createRevision(defaultHashFunction, docData);\n                        docData._meta.lwt = now();\n                        const insertResult = await instance.bulkWrite([{\n                            document: docData\n                        }], testContext);\n                        assert.deepStrictEqual(insertResult.error, {});\n                    })\n            );\n            await awaitRxStorageReplicationIdle(replicationState);\n            await ensureEqualState(masterInstance, forkInstance);\n\n            // do many updates\n            let updateId = 10;\n            async function updateDocOnce(\n                instance: RxStorageInstance<HumanDocumentType, any, any>,\n                flag: string\n            ) {\n                let done = false;\n                while (!done) {\n                    if (randomBoolean()) {\n                        await wait(0);\n                    }\n                    const current = await instance.findDocumentsById([docId], true);\n                    const currentDocState = getFromObjectOrThrow(current, docId);\n                    const newDocState: typeof currentDocState = clone(currentDocState);\n                    newDocState._meta.lwt = now();\n                    newDocState.lastName = randomCouchString(12);\n                    newDocState.firstName = flag;\n                    newDocState.age = updateId++;\n                    newDocState._rev = createRevision(defaultHashFunction, newDocState, currentDocState);\n\n                    const writeResult = await instance.bulkWrite([{\n                        previous: currentDocState,\n                        document: newDocState\n                    }], testContext);\n                    if (Object.keys(writeResult.success).length > 0) {\n                        done = true;\n                    }\n                }\n            }\n\n            const promises: Promise<any>[] = [];\n            new Array(writeAmount)\n                .fill(0)\n                .forEach(() => {\n                    instances.forEach((instance, idx) => {\n                        promises.push(\n                            updateDocOnce(\n                                instance,\n                                idx === 0 ? 'master' : 'fork'\n                            )\n                        );\n                    })\n                });\n            await Promise.all(promises);\n\n            await awaitRxStorageReplicationIdle(replicationState);\n            await ensureEqualState(masterInstance, forkInstance);\n            assert.strictEqual(\n                replicationState.stats.down.downstreamResyncOnce,\n                1\n            );\n\n            cleanUp(replicationState, masterInstance);\n        });","file":"unit/replication-protocol.test.ts","skipped":false,"dir":"test"},{"name":"should be able to replicate local documents","suites":["issues"],"updatePoint":{"line":1062,"column":55},"line":1062,"code":"        it('should be able to replicate local documents', async () => {\n            const masterInstance = await config.storage.getStorage().createStorageInstance<RxLocalDocumentData>({\n                databaseInstanceToken: randomCouchString(10),\n                databaseName: randomCouchString(10),\n                collectionName: randomCouchString(10),\n                schema: RX_LOCAL_DOCUMENT_SCHEMA,\n                options: {},\n                multiInstance: true\n            });\n            const forkInstance = await config.storage.getStorage().createStorageInstance<RxLocalDocumentData>({\n                databaseInstanceToken: randomCouchString(10),\n                databaseName: randomCouchString(10),\n                collectionName: randomCouchString(10),\n                schema: RX_LOCAL_DOCUMENT_SCHEMA,\n                options: {},\n                multiInstance: true\n            });\n            const metaInstance = await createMetaInstance();\n\n            // add master doc\n            // check ongoing doc\n            await forkInstance.bulkWrite([{\n                document: {\n                    id: 'master',\n                    data: {\n                        foo: 'bar'\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _meta: {\n                        lwt: now()\n                    },\n                    _rev: EXAMPLE_REVISION_1\n                }\n            }], testContext);\n\n\n            const replicationState = replicateRxStorageInstance<RxLocalDocumentData>({\n                identifier: randomCouchString(10),\n                replicationHandler: rxStorageInstanceToReplicationHandler(masterInstance, THROWING_CONFLICT_HANDLER as any, defaultHashFunction),\n                forkInstance,\n                metaInstance,\n                pullBatchSize: 100,\n                pushBatchSize: 100,\n                conflictHandler: THROWING_CONFLICT_HANDLER as any,\n                hashFunction: defaultHashFunction\n            });\n            await awaitRxStorageReplicationFirstInSync(replicationState);\n\n            const docsOnMaster = await runQuery(masterInstance);\n            assert.strictEqual(docsOnMaster.length, 1);\n\n            // check ongoing doc\n            await forkInstance.bulkWrite([{\n                document: {\n                    id: 'fork',\n                    data: {\n                        foo: 'bar'\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _meta: {\n                        lwt: now()\n                    },\n                    _rev: EXAMPLE_REVISION_1\n                }\n            }], testContext);\n\n            await waitUntil(async () => {\n                const docsOnMaster2 = await runQuery(masterInstance);\n                return docsOnMaster2.length === 2;\n            });\n\n            await cleanUp(replicationState, masterInstance);\n        });","file":"unit/replication-protocol.test.ts","skipped":false,"dir":"test"},{"name":"should not stuck when replicating many document in the initial replication","suites":["issues"],"updatePoint":{"line":1137,"column":86},"line":1137,"code":"        it('should not stuck when replicating many document in the initial replication', async () => {\n            const writeAmount = config.isFastMode() ? 40 : 200;\n\n            const masterInstance = await createRxStorageInstance(0);\n            const forkInstance = await createRxStorageInstance(0);\n            const metaInstance = await createMetaInstance();\n\n            await masterInstance.bulkWrite(\n                new Array(writeAmount)\n                    .fill(0)\n                    .map(() => ({ document: getDocData() })),\n                testContext\n            );\n\n            const replicationState = replicateRxStorageInstance({\n                identifier: randomCouchString(10),\n                replicationHandler: rxStorageInstanceToReplicationHandler(masterInstance, THROWING_CONFLICT_HANDLER, defaultHashFunction),\n                forkInstance,\n                metaInstance,\n                /**\n                 * Must be smaller then the amount of document\n                 */\n                pullBatchSize: 100,\n                pushBatchSize: 100,\n                conflictHandler: THROWING_CONFLICT_HANDLER,\n                hashFunction: defaultHashFunction\n            });\n\n            await awaitRxStorageReplicationFirstInSync(replicationState);\n            await cleanUp(replicationState, masterInstance);\n        });","file":"unit/replication-protocol.test.ts","skipped":false,"dir":"test"},{"name":"should start a server+client and replicate one document from server to the client","suites":[],"updatePoint":{"line":49,"column":89},"line":49,"code":"    it('should start a server+client and replicate one document from server to the client', async () => {\n        const { localCollection, remoteCollection } = await getTestCollections({\n            local: 1,\n            remote: 1\n        });\n\n        const portAndUrl = await nextPortAndUrl();\n\n        await startWebsocketServer({\n            database: remoteCollection.database,\n            port: portAndUrl.port\n        });\n\n        const replicationState = await replicateWithWebsocketServer({\n            collection: localCollection,\n            url: portAndUrl.url\n        });\n        replicationState.error$.subscribe(err => {\n            console.log('got error :');\n            console.log(JSON.stringify(err, null, 4));\n            throw err;\n        });\n\n\n        await replicationState.awaitInSync();\n\n        const serverDocs = await remoteCollection.find().exec();\n        assert.strictEqual(serverDocs.length, 2);\n        const clientDocs = await localCollection.find().exec();\n        assert.strictEqual(clientDocs.length, 2);\n\n        localCollection.database.destroy();\n        remoteCollection.database.destroy();\n    });","file":"unit/replication-websocket.test.ts","skipped":false,"dir":"test"},{"name":"should replicate ongoing writes","suites":[],"updatePoint":{"line":83,"column":39},"line":83,"code":"    it('should replicate ongoing writes', async () => {\n        const { localCollection, remoteCollection } = await getTestCollections({\n            local: 1,\n            remote: 1\n        });\n\n        const clientDoc = await localCollection.findOne().exec(true);\n        const serverDoc = await remoteCollection.findOne().exec(true);\n\n        const portAndUrl = await nextPortAndUrl();\n\n        await startWebsocketServer({\n            database: remoteCollection.database,\n            port: portAndUrl.port\n        });\n\n        const replicationState = await replicateWithWebsocketServer({\n            collection: localCollection,\n            url: portAndUrl.url\n        });\n        replicationState.error$.subscribe(err => {\n            console.log('got error :');\n            console.log(JSON.stringify(err, null, 4));\n            throw err;\n        });\n\n        await replicationState.awaitInSync();\n\n\n        // UPDATE\n        await clientDoc.atomicPatch({\n            name: 'client-edited'\n        });\n        await serverDoc.atomicPatch({\n            name: 'server-edited'\n        });\n\n        await replicationState.awaitInSync();\n\n        const clientDocOnServer = await remoteCollection.findOne(clientDoc.primary).exec(true);\n        assert.strictEqual(clientDocOnServer.name, 'client-edited');\n\n        const serverDocOnClient = await localCollection.findOne(serverDoc.primary).exec(true);\n        assert.strictEqual(serverDocOnClient.name, 'server-edited');\n\n\n        // DELETE\n        await serverDoc.remove();\n        await clientDoc.remove();\n        await replicationState.awaitInSync();\n        const deletedServer = await remoteCollection.findOne().exec();\n        const deletedClient = await localCollection.findOne().exec();\n        assert.ok(!deletedServer);\n        assert.ok(!deletedClient);\n\n        localCollection.database.destroy();\n        remoteCollection.database.destroy();\n    });","file":"unit/replication-websocket.test.ts","skipped":false,"dir":"test"},{"name":"should continue the replication when the connection is broken and established again","suites":[],"updatePoint":{"line":141,"column":91},"line":141,"code":"    it('should continue the replication when the connection is broken and established again', async () => {\n        if (config.isFastMode()) {\n            return;\n        }\n        const { localCollection, remoteCollection } = await getTestCollections({\n            local: 1,\n            remote: 1\n        });\n\n        const clientDoc = await localCollection.findOne().exec(true);\n        const serverDoc = await remoteCollection.findOne().exec(true);\n\n        const portAndUrl = await nextPortAndUrl();\n\n        const serverState = await startWebsocketServer({\n            database: remoteCollection.database,\n            port: portAndUrl.port\n        });\n\n        const replicationState = await replicateWithWebsocketServer({\n            collection: localCollection,\n            url: portAndUrl.url\n        });\n        replicationState.error$.subscribe(err => {\n            console.log('got error :');\n            console.log(JSON.stringify(err, null, 4));\n            throw err;\n        });\n\n        await replicationState.awaitInSync();\n        const serverDocs = await remoteCollection.find().exec();\n        assert.strictEqual(serverDocs.length, 2);\n\n        // go 'offline' by closing the server\n        await serverState.close();\n\n        // modify on both sides while offline\n        await clientDoc.atomicPatch({\n            name: 'client-edited'\n        });\n        await serverDoc.atomicPatch({\n            name: 'server-edited'\n        });\n        await wait(100);\n\n        // go 'online' again by starting a new server on the same port\n        await startWebsocketServer({\n            database: remoteCollection.database,\n            port: portAndUrl.port\n        });\n        await wait(100);\n        await replicationState.awaitInSync();\n        await wait(100);\n        const clientDocOnServer = await remoteCollection.findOne(clientDoc.primary).exec(true);\n        assert.strictEqual(clientDocOnServer.name, 'client-edited');\n        const serverDocOnClient = await localCollection.findOne(serverDoc.primary).exec(true);\n        assert.strictEqual(serverDocOnClient.name, 'server-edited');\n\n        // should still stream the events after the reconnect\n        await remoteCollection.insert(schemaObjects.humanWithTimestamp({\n            id: 'server-doc-after-reconnect'\n        }));\n        await waitUntil(async () => {\n            const doc = await localCollection.findOne('server-doc-after-reconnect').exec();\n            return !!doc;\n        });\n\n        await localCollection.database.destroy();\n        await remoteCollection.database.destroy();\n    });","file":"unit/replication-websocket.test.ts","skipped":false,"dir":"test"},{"name":"should be able to replicate multiple collections at once","suites":[],"updatePoint":{"line":211,"column":64},"line":211,"code":"    it('should be able to replicate multiple collections at once', async () => {\n        const { localCollection, remoteCollection } = await getTestCollections({\n            local: 0,\n            remote: 0\n        });\n        async function getDocIds(collection: RxCollection): Promise<string[]> {\n            const docs = await collection.find().exec();\n            return docs.map(d => d.primary);\n        }\n        const localDatabase = localCollection.database;\n        const remoteDatabase = remoteCollection.database;\n        const portAndUrl = await nextPortAndUrl();\n\n        await localDatabase.addCollections({\n            humans2: {\n                schema: humanWithTimestamp\n            }\n        });\n        await remoteDatabase.addCollections({\n            humans2: {\n                schema: humanWithTimestamp\n            }\n        });\n\n        // add one initial doc to each collection\n        await localCollection.insert(schemaObjects.humanWithTimestamp({\n            id: 'local1'\n        }));\n        await localDatabase.humans2.insert(schemaObjects.humanWithTimestamp({\n            id: 'local2'\n        }));\n        await remoteCollection.insert(schemaObjects.humanWithTimestamp({\n            id: 'remote1'\n        }));\n        await remoteDatabase.humans2.insert(schemaObjects.humanWithTimestamp({\n            id: 'remote2'\n        }));\n\n        await startWebsocketServer({\n            database: remoteCollection.database,\n            port: portAndUrl.port\n        });\n\n        const replicationState1 = await replicateWithWebsocketServer({\n            collection: localDatabase.humans,\n            url: portAndUrl.url\n        });\n        replicationState1.error$.subscribe(err => {\n            console.log('got error1 :');\n            console.log(JSON.stringify(err, null, 4));\n        });\n        const replicationState2 = await replicateWithWebsocketServer({\n            collection: localDatabase.humans2,\n            url: portAndUrl.url\n        });\n        replicationState2.error$.subscribe(err => {\n            console.log('got error2 :');\n            console.log(JSON.stringify(err, null, 4));\n        });\n\n        await replicationState1.awaitInSync();\n        await replicationState2.awaitInSync();\n\n        assert.deepStrictEqual(\n            await getDocIds(localCollection),\n            [\n                'local1',\n                'remote1'\n            ]\n        );\n        assert.deepStrictEqual(\n            await getDocIds(remoteCollection),\n            [\n                'local1',\n                'remote1'\n            ]\n        );\n        assert.deepStrictEqual(\n            await getDocIds(localDatabase.humans2),\n            [\n                'local2',\n                'remote2'\n            ]\n        );\n        assert.deepStrictEqual(\n            await getDocIds(remoteDatabase.humans2),\n            [\n                'local2',\n                'remote2'\n            ]\n        );\n\n        // make an ongoing change\n        async function updateDoc(\n            collection: RxCollection<schemaObjects.HumanWithTimestampDocumentType>,\n            id: string\n        ) {\n            const doc = await collection.findOne(id).exec(true);\n            await doc.atomicPatch({ name: 'updated' });\n        }\n        await updateDoc(localCollection, 'local1');\n        await updateDoc(localDatabase.humans2, 'local2');\n        await updateDoc(remoteCollection, 'remote1');\n        await updateDoc(remoteDatabase.humans2, 'remote2');\n\n        await replicationState1.awaitInSync();\n        await replicationState2.awaitInSync();\n\n        async function ensureUpdated(\n            collection: RxCollection<schemaObjects.HumanWithTimestampDocumentType>\n        ) {\n            const docs = await collection.find().exec();\n            docs.forEach(doc => assert.strictEqual(doc.name, 'updated'))\n        }\n        await ensureUpdated(localCollection);\n        await ensureUpdated(localDatabase.humans2);\n        await ensureUpdated(remoteCollection);\n        await ensureUpdated(remoteDatabase.humans2);\n\n        localDatabase.destroy();\n        remoteDatabase.destroy();\n    });","file":"unit/replication-websocket.test.ts","skipped":false,"dir":"test"},{"name":"should be able to replicate multiple clients at once","suites":[],"updatePoint":{"line":334,"column":60},"line":334,"code":"    it('should be able to replicate multiple clients at once', async () => {\n        const portAndUrl = await nextPortAndUrl();\n        const [\n            serverCollection,\n            clientOneCollection,\n            clientTwoCollection\n        ] = await Promise.all([\n            humansCollection.createHumanWithTimestamp(0, undefined, false),\n            humansCollection.createHumanWithTimestamp(0, undefined, false),\n            humansCollection.createHumanWithTimestamp(0, undefined, false)\n        ]);\n\n        await startWebsocketServer({\n            database: serverCollection.database,\n            port: portAndUrl.port\n        });\n\n        const replicationState1 = await replicateWithWebsocketServer({\n            collection: clientOneCollection,\n            url: portAndUrl.url\n        });\n\n        const replicationState2 = await replicateWithWebsocketServer({\n            collection: clientTwoCollection,\n            url: portAndUrl.url\n        });\n        const awaitInSync = async () => {\n            await replicationState1.awaitInSync();\n            await replicationState2.awaitInSync();\n        };\n        await awaitInSync();\n\n\n        await serverCollection.insert(schemaObjects.humanWithTimestamp({\n            id: 'server-doc'\n        }));\n\n        await wait(100);\n        await awaitInSync();\n\n        await clientOneCollection.findOne('server-doc').exec(true);\n        await clientTwoCollection.findOne('server-doc').exec(true);\n\n        await Promise.all([\n            serverCollection.database.destroy(),\n            clientOneCollection.database.destroy(),\n            clientTwoCollection.database.destroy()\n        ]);\n    });","file":"unit/replication-websocket.test.ts","skipped":false,"dir":"test"},{"name":"should replicate both sides","suites":["replication.test.js"],"updatePoint":{"line":98,"column":39},"line":98,"code":"        it('should replicate both sides', async () => {\n            const docsPerSide = 15;\n            const { localCollection, remoteCollection } = await getTestCollections({\n                local: docsPerSide,\n                remote: docsPerSide\n            });\n\n\n            const batchSize = 12;\n            const pullHandler = getPullHandler(remoteCollection);\n            const pushHandler = getPushHandler(remoteCollection);\n            const replicationState = replicateRxCollection({\n                collection: localCollection,\n                replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                live: false,\n                pull: {\n                    batchSize,\n                    handler: (lastPulledCheckpoint: CheckpointType, pullBatchSize: number) => {\n                        // ensure the batchSize from the settings is respected\n                        assert.strictEqual(pullBatchSize, batchSize);\n                        return pullHandler(lastPulledCheckpoint, pullBatchSize);\n                    }\n                },\n                push: {\n                    batchSize,\n                    handler: (docs) => {\n                        if (docs.length > batchSize) {\n                            throw new Error('push got more docs then the batch size');\n                        }\n                        return pushHandler(docs);\n                    }\n                }\n            });\n            replicationState.error$.subscribe(err => {\n                console.log('got error :');\n                console.log(JSON.stringify(err, null, 4));\n                throw err;\n            });\n\n            await replicationState.awaitInitialReplication();\n\n            const docsLocal = await localCollection.find().exec();\n            const docsRemote = await remoteCollection.find().exec();\n\n            assert.strictEqual(\n                docsLocal.length,\n                docsRemote.length\n            );\n            assert.strictEqual(\n                docsLocal.length,\n                docsPerSide * 2\n            );\n\n            localCollection.database.destroy();\n            remoteCollection.database.destroy();\n        });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should allow asynchronous push and pull modifiers","suites":["replication.test.js"],"updatePoint":{"line":154,"column":61},"line":154,"code":"        it('should allow asynchronous push and pull modifiers', async () => {\n            const { localCollection, remoteCollection } = await getTestCollections({ local: 5, remote: 5 });\n            const replicationState = replicateRxCollection({\n                collection: localCollection,\n                replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                live: false,\n                pull: {\n                    handler: getPullHandler(remoteCollection),\n                    modifier: async (doc) => {\n                        await wait(0);\n                        doc = clone(doc);\n                        doc.name = 'pull-modified';\n                        return doc;\n                    }\n                },\n                push: {\n                    handler: getPushHandler(remoteCollection),\n                    modifier: async (doc) => {\n                        await wait(0);\n                        doc = clone(doc);\n                        doc.name = 'push-modified';\n                        return doc;\n                    }\n                }\n            });\n            await replicationState.awaitInitialReplication();\n\n            const docsLocal = await localCollection.find().exec();\n            const docsRemote = await remoteCollection.find().exec();\n\n            const pullModifiedLocal = docsLocal.filter(d => d.name === 'pull-modified');\n            assert.strictEqual(pullModifiedLocal.length, 5);\n\n            const pushModifiedRemote = docsRemote.filter(d => d.name === 'push-modified');\n            assert.strictEqual(pushModifiedRemote.length, 5);\n\n            localCollection.database.destroy();\n            remoteCollection.database.destroy();\n        });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should not save pulled documents that do not match the schema","suites":["replication.test.js"],"updatePoint":{"line":193,"column":73},"line":193,"code":"        it('should not save pulled documents that do not match the schema', async () => {\n            const { localCollection, remoteCollection } = await getTestCollections({ local: 0, remote: 5 });\n\n            /**\n             * Use collection with different schema\n             * to provoke validation errors.\n             */\n            const otherSchema = clone(schemas.humanWithTimestamp);\n            otherSchema.properties.age.maximum = 0;\n            const otherSchemaCollection = await humansCollection.createBySchema(\n                otherSchema,\n                undefined,\n                wrappedValidateAjvStorage({\n                    storage: config.storage.getStorage()\n                })\n            );\n\n            const replicationState = replicateRxCollection({\n                collection: otherSchemaCollection as any,\n                replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                live: false,\n                pull: {\n                    handler: getPullHandler(remoteCollection)\n                },\n                push: {\n                    handler: getPushHandler(remoteCollection)\n                }\n            });\n            const errors: any[] = [];\n            replicationState.error$.subscribe(err => errors.push(err));\n            await replicationState.awaitInitialReplication();\n\n            await wait(config.isFastMode() ? 0 : 100);\n\n            const docsLocal = await otherSchemaCollection.find().exec();\n            assert.strictEqual(docsLocal.length, 0);\n\n\n            assert.strictEqual(errors.length, 1);\n            assert.ok(errors[0].message.includes('does not match schema'));\n\n\n            localCollection.database.destroy();\n            remoteCollection.database.destroy();\n            otherSchemaCollection.database.destroy();\n        });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should replicate all writes","suites":["replication.test.js"],"updatePoint":{"line":241,"column":39},"line":241,"code":"        it('should replicate all writes', async () => {\n            const { localCollection, remoteCollection } = await getTestCollections({ local: 0, remote: 0 });\n\n            const replicationState = replicateRxCollection({\n                collection: localCollection,\n                replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                live: true,\n                pull: {\n                    handler: getPullHandler(remoteCollection)\n                },\n                push: {\n                    handler: getPushHandler(remoteCollection)\n                }\n            });\n            replicationState.error$.subscribe(err => {\n                console.log('got error :');\n                console.dir(err);\n            });\n\n            await replicationState.awaitInitialReplication();\n            const docsRemoteQuery = await remoteCollection.findOne();\n\n            // insert\n            const id = 'foobar';\n            const docData = schemaObjects.humanWithTimestamp({\n                id\n            });\n            const doc = await localCollection.insert(docData);\n            await waitUntil(async () => {\n                const remoteDoc = await docsRemoteQuery.exec();\n                return !!remoteDoc;\n            });\n\n            // UPDATE\n            await doc.atomicPatch({\n                age: 100\n            });\n            await waitUntil(async () => {\n                const remoteDoc = await docsRemoteQuery.exec(true);\n                return remoteDoc.age === 100;\n            });\n\n            // DELETE\n            await wait(100);\n            await doc.remove();\n            await waitUntil(async () => {\n                const remoteDoc = await docsRemoteQuery.exec();\n                return !remoteDoc;\n            });\n\n            localCollection.database.destroy();\n            remoteCollection.database.destroy();\n        });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"#3994 should respect the push.batchSize","suites":["replication.test.js"],"updatePoint":{"line":297,"column":51},"line":297,"code":"        it('#3994 should respect the push.batchSize', async () => {\n            const { localCollection, remoteCollection } = await getTestCollections({ local: 0, remote: 0 });\n\n            const batchSize = 2;\n            const replicationState = replicateRxCollection({\n                collection: localCollection,\n                replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                live: true,\n                pull: {\n                    handler: getPullHandler(remoteCollection)\n                },\n                push: {\n                    handler: (docs) => {\n                        if (docs.length === 0 || docs.length > batchSize) {\n                            throw new Error('push.batchSize(' + batchSize + ') not respected ' + docs.length);\n                        }\n                        return getPushHandler(remoteCollection)(docs);\n                    },\n                    batchSize\n                }\n            });\n            replicationState.error$.subscribe(err => {\n                console.log('got error :');\n                console.dir(err);\n                throw err;\n            });\n\n            /**\n             * Insert many documents at once to\n             * produce an eventBulk that contains many documents\n             */\n            await localCollection.bulkInsert(\n                new Array(10).fill(0).map((() => schemaObjects.humanWithTimestamp()))\n            );\n\n            await replicationState.awaitInSync();\n\n            const docsOnRemote = await remoteCollection.find().exec();\n            assert.strictEqual(\n                docsOnRemote.length,\n                10\n            );\n\n            localCollection.database.destroy();\n            remoteCollection.database.destroy();\n        });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should run first replication by default","suites":["replication.test.js","autoStart"],"updatePoint":{"line":346,"column":55},"line":346,"code":"            it('should run first replication by default', async () => {\n                const { localCollection, remoteCollection } = await getTestCollections({ local: 0, remote: 0 });\n                const replicationState = replicateRxCollection({\n                    collection: localCollection,\n                    replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                    live: false,\n                    autoStart: true,\n                    waitForLeadership: false\n                });\n                await replicationState.awaitInitialReplication();\n                assert.ok(\n                    ensureNotFalsy(replicationState.internalReplicationState).stats.down.downstreamResyncOnce > 0\n                );\n\n                localCollection.database.destroy();\n                remoteCollection.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should not run first replication when autoStart is set to false","suites":["replication.test.js","autoStart"],"updatePoint":{"line":363,"column":79},"line":363,"code":"            it('should not run first replication when autoStart is set to false', async () => {\n                const { localCollection, remoteCollection } = await getTestCollections({ local: 0, remote: 0 });\n                const replicationState = replicateRxCollection({\n                    collection: localCollection,\n                    replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                    live: false,\n                    autoStart: false,\n                    waitForLeadership: false\n                });\n\n                await wait(100);\n\n\n                // not replicated\n                assert.ok(!replicationState.internalReplicationState);\n\n                localCollection.database.destroy();\n                remoteCollection.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should resolve after some time","suites":["replication.test.js",".awaitInSync()"],"updatePoint":{"line":384,"column":46},"line":384,"code":"            it('should resolve after some time', async () => {\n                const { localCollection, remoteCollection } = await getTestCollections({ local: 5, remote: 5 });\n\n                const replicationState = replicateRxCollection({\n                    collection: localCollection,\n                    replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                    live: false,\n                    pull: {\n                        handler: getPullHandler(remoteCollection)\n                    },\n                    push: {\n                        handler: getPushHandler(remoteCollection)\n                    }\n                });\n                await replicationState.awaitInSync();\n\n                localCollection.database.destroy();\n                remoteCollection.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should never resolve when offline","suites":["replication.test.js",".awaitInSync()"],"updatePoint":{"line":403,"column":49},"line":403,"code":"            it('should never resolve when offline', async () => {\n                const { localCollection, remoteCollection } = await getTestCollections({ local: 5, remote: 5 });\n\n                const replicationState = replicateRxCollection({\n                    collection: localCollection,\n                    replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                    live: false,\n                    pull: {\n                        handler: async () => {\n                            await wait(100);\n                            throw new Error('always error');\n                        }\n                    },\n                    push: {\n                        handler: getPushHandler(remoteCollection)\n                    }\n                });\n                let resolved = false;\n                replicationState.awaitInSync().then(() => {\n                    resolved = true;\n                });\n                await wait(config.isFastMode() ? 100 : 400);\n                assert.strictEqual(resolved, false);\n\n                localCollection.database.destroy();\n                remoteCollection.database.destroy();\n            });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should clean up the replication meta storage the get collection gets removed","suites":["replication.test.js",".awaitInSync()"],"updatePoint":{"line":431,"column":88},"line":431,"code":"        it('should clean up the replication meta storage the get collection gets removed', async () => {\n            const { localCollection, remoteCollection } = await getTestCollections({ local: 5, remote: 5 });\n            const localDbName = localCollection.database.name;\n\n            const replicationState1 = replicateRxCollection({\n                collection: localCollection,\n                replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                live: true,\n                pull: {\n                    handler: getPullHandler(remoteCollection)\n                },\n                push: {\n                    handler: getPushHandler(remoteCollection)\n                }\n            });\n            await replicationState1.awaitInitialReplication();\n\n            async function docsInMeta(repState: typeof replicationState1): Promise<number> {\n                const metaInstance = ensureNotFalsy(repState.metaInstance);\n                const prepared = repState.collection.database.storage.statics.prepareQuery(\n                    metaInstance.schema,\n                    normalizeMangoQuery(\n                        metaInstance.schema,\n                        {}\n                    )\n                );\n                const result = await metaInstance.query(prepared);\n                return result.documents.length;\n            }\n\n            await localCollection.remove();\n            await localCollection.database.destroy();\n\n\n            const localCollection2 = await humansCollection.createHumanWithTimestamp(0, localDbName, false);\n\n            let continueReplication: Function | null = undefined as any;\n            const continues = new Promise(res => {\n                continueReplication = res;\n            });\n\n            const replicationState2 = replicateRxCollection({\n                collection: localCollection2,\n                replicationIdentifier: REPLICATION_IDENTIFIER_TEST,\n                live: true,\n                pull: {\n                    handler: async (chkpt, bSize) => {\n                        await continues;\n                        return getPullHandler(remoteCollection)(chkpt, bSize);\n                    }\n                },\n                push: {\n                    handler: async (docs) => {\n                        await continues;\n                        return getPushHandler(remoteCollection)(docs);\n                    }\n                },\n                autoStart: false\n            });\n            await replicationState2.start();\n\n            const docsInMetaAfter = await docsInMeta(replicationState2);\n            console.log('docsInMetaAfter: ' + docsInMetaAfter);\n\n            /**\n             * Because in the localCollection2 we do not insert any documents,\n             * there must be less documents in the meta collection\n             * becaues it only contains the checkpoints.\n             */\n            assert.strictEqual(docsInMetaAfter, 0);\n            ensureNotFalsy(continueReplication)();\n\n            /**\n             * the re-created collection should have re-run the replication\n             * and contain all documents from the remove.\n             */\n            await replicationState2.awaitInitialReplication();\n            const localDocs = await localCollection2.find().exec();\n            const remoteDocs = await remoteCollection.find().exec();\n\n            assert.deepStrictEqual(\n                localDocs.map(d => d.toJSON()),\n                remoteDocs.map(d => d.toJSON())\n            );\n\n            localCollection2.database.destroy();\n            remoteCollection.database.destroy();\n        });","file":"unit/replication.test.ts","skipped":false,"dir":"test"},{"name":"should not crash","suites":["rx-collection.test.ts","static",".addCollections()"],"updatePoint":{"line":63,"column":32},"line":63,"code":"            it('should not crash', async () => {\n                const db = await getDb();\n                await db.addCollections({\n                    one: {\n                        schema: schemas.human\n                    },\n                    two: {\n                        schema: schemas.human\n                    }\n                });\n                assert.ok(isRxCollection(db.one));\n                assert.ok(isRxCollection(db.two));\n                db.destroy();\n            });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"human","suites":["rx-collection.test.ts","static","positive"],"updatePoint":{"line":80,"column":25},"line":80,"code":"                it('human', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                    });\n                    await db.addCollections({\n                        human: {\n                            schema: schemas.human\n                        }\n                    });\n                    const collection = db.collections.human;\n                    assert.ok(isRxCollection(collection));\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should create compound-indexes (keyCompression: false)","suites":["rx-collection.test.ts","static","positive"],"updatePoint":{"line":94,"column":74},"line":94,"code":"                it('should create compound-indexes (keyCompression: false)', async () => {\n                    addPouchPlugin(require('pouchdb-adapter-memory'));\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    const schemaJSON = clone(schemas.compoundIndex);\n                    schemaJSON.keyCompression = false;\n\n                    await db.addCollections({\n                        human: {\n                            schema: schemaJSON\n                        }\n                    });\n                    const collection = db.collections.human;\n                    const indexes = await collection.storageInstance.internals.pouch.getIndexes();\n                    assert.strictEqual(indexes.indexes.length, 2);\n                    const lastIndexDefFields = indexes.indexes[1].def.fields;\n                    assert.deepStrictEqual(\n                        lastIndexDefFields,\n                        [\n                            { 'age': 'asc' },\n                            { 'passportCountry': 'asc' },\n                            // the primaryKey index will always be added by RxDB\n                            { _id: 'asc' }\n                        ]\n                    );\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should create compound-indexes (keyCompression: true)","suites":["rx-collection.test.ts","static","positive"],"updatePoint":{"line":123,"column":73},"line":123,"code":"                it('should create compound-indexes (keyCompression: true)', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: wrappedKeyCompressionStorage({\n                            storage: getRxStoragePouch('memory')\n                        })\n                    });\n                    await db.addCollections({\n                        human: {\n                            schema: enableKeyCompression(schemas.compoundIndex)\n                        }\n                    });\n                    const collection = db.collections.human;\n                    const indexes = await collection.storageInstance.internals.pouch.getIndexes();\n                    assert.strictEqual(indexes.indexes.length, 2);\n                    const lastIndexDefFields = indexes.indexes[1].def.fields;\n                    assert.deepStrictEqual(\n                        lastIndexDefFields, [\n                        { 'age': 'asc' },\n                        { '|a': 'asc' },\n                        // the primaryKey index will always be added by RxDB\n                        { _id: 'asc' }\n                    ]\n                    );\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should have the version-number in the pouchdb-prefix","suites":["rx-collection.test.ts","static","positive"],"updatePoint":{"line":149,"column":72},"line":149,"code":"                it('should have the version-number in the pouchdb-prefix', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: getRxStoragePouch('memory'),\n                    });\n                    await db.addCollections({\n                        human: {\n                            schema: schemas.human\n                        }\n                    });\n                    const collection = db.collections.human;\n                    assert.deepStrictEqual(schemas.human.version, 0);\n                    assert.ok(collection.storageInstance.internals.pouch.name.includes('-' + schemas.human.version + '-'));\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not forget the options","suites":["rx-collection.test.ts","static","positive"],"updatePoint":{"line":164,"column":49},"line":164,"code":"                it('should not forget the options', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.human,\n                            options: {\n                                foo: 'bar'\n                            }\n                        }\n                    });\n                    assert.strictEqual(collections.human.options.foo, 'bar');\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"allow not allow lodash","suites":["rx-collection.test.ts","static","positive"],"updatePoint":{"line":184,"column":42},"line":184,"code":"                it('allow not allow lodash', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                    });\n                    await AsyncTestUtil.assertThrows(\n                        () => db.addCollections({\n                            _foobar: {\n                                schema: schemas.human\n                            }\n                        }),\n                        'RxError',\n                        'foobar'\n                    );\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"allow numbers","suites":["rx-collection.test.ts","static","positive"],"updatePoint":{"line":200,"column":33},"line":200,"code":"                it('allow numbers', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                    });\n                    await db.addCollections({\n                        fooba4r: {\n                            schema: schemas.human\n                        },\n                        foobar4: {\n                            schema: schemas.human\n                        }\n                    });\n                    assert.ok(isRxCollection(db.collections.fooba4r));\n                    assert.ok(isRxCollection(db.collections.foobar4));\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"not allow starting numbers","suites":["rx-collection.test.ts","static","negative"],"updatePoint":{"line":219,"column":46},"line":219,"code":"                it('not allow starting numbers', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                    });\n                    await AsyncTestUtil.assertThrows(\n                        () => db.addCollections({\n                            '0foobar': {\n                                schema: schemas.human\n                            }\n                        }),\n                        'RxError'\n                    );\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"not allow uppercase-letters","suites":["rx-collection.test.ts","static","negative"],"updatePoint":{"line":234,"column":47},"line":234,"code":"                it('not allow uppercase-letters', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                    });\n                    await AsyncTestUtil.assertThrows(\n                        () => db.addCollections({\n                            'Foobar': {\n                                schema: schemas.human\n                            }\n                        }),\n                        'RxError'\n                    );\n                    await AsyncTestUtil.assertThrows(\n                        () => db.addCollections({\n                            'fooBar': {\n                                schema: schemas.human\n                            }\n                        }),\n                        'RxError'\n                    );\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should insert a human","suites":["rx-collection.test.ts","instance","positive"],"updatePoint":{"line":263,"column":41},"line":263,"code":"                it('should insert a human', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.human\n                        }\n                    });\n                    await collections.human.insert(schemaObjects.human());\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should insert nested human","suites":["rx-collection.test.ts","instance","positive"],"updatePoint":{"line":276,"column":46},"line":276,"code":"                it('should insert nested human', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                    });\n                    const collections = await db.addCollections({\n                        nestedhuman: {\n                            schema: schemas.nestedHuman\n                        }\n                    });\n                    await collections.nestedhuman.insert(schemaObjects.nestedHuman());\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should insert more than once","suites":["rx-collection.test.ts","instance","positive"],"updatePoint":{"line":289,"column":48},"line":289,"code":"                it('should insert more than once', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                    });\n                    const collections = await db.addCollections({\n                        nestedhuman: {\n                            schema: schemas.nestedHuman\n                        }\n                    });\n                    for (let i = 0; i < 10; i++) {\n                        await collections.nestedhuman.insert(schemaObjects.nestedHuman());\n                    }\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should set default values","suites":["rx-collection.test.ts","instance","positive"],"updatePoint":{"line":304,"column":45},"line":304,"code":"                it('should set default values', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                    });\n                    const collections = await db.addCollections({\n                        nestedhuman: {\n                            schema: schemas.humanDefault\n                        }\n                    });\n\n                    const data = {\n                        passportId: 'foobar',\n                    };\n                    await collections.nestedhuman.insert(data);\n                    const doc = await collections.nestedhuman.findOne().exec(true);\n                    assert.strictEqual((doc as any).age, 20);\n\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should throw a conflict-error","suites":["rx-collection.test.ts","instance","negative"],"updatePoint":{"line":326,"column":49},"line":326,"code":"                it('should throw a conflict-error', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    const docData = schemaObjects.human();\n                    await collection.insert(docData);\n\n                    const err: RxError = await AsyncTestUtil.assertThrows(\n                        () => collection.insert(docData),\n                        'RxError',\n                        'conflict'\n                    ) as any;\n                    assert.deepStrictEqual(err.parameters.id, docData.passportId);\n\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should insert some humans","suites":["rx-collection.test.ts","instance","positive"],"updatePoint":{"line":353,"column":45},"line":353,"code":"                it('should insert some humans', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.human\n                        }\n                    });\n                    const docs = new Array(10).fill(0).map(() => schemaObjects.human());\n                    const ret = await collections.human.bulkInsert(docs);\n\n                    assert.strictEqual(ret.success.length, 10);\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not throw when called with an empty array","suites":["rx-collection.test.ts","instance","positive"],"updatePoint":{"line":369,"column":68},"line":369,"code":"                it('should not throw when called with an empty array', async () => {\n                    const col = await humansCollection.create(0);\n                    await col.bulkInsert([]);\n                    col.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should throw if one already exists","suites":["rx-collection.test.ts","instance","negative"],"updatePoint":{"line":376,"column":54},"line":376,"code":"                it('should throw if one already exists', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    const double = schemaObjects.human();\n                    double.passportId = 'foobar';\n                    await collection.insert(double);\n                    const docs = new Array(10).fill(0).map(() => schemaObjects.human());\n                    docs.push(double);\n                    const ret = await collection.bulkInsert(docs);\n\n                    assert.strictEqual(ret.success.length, 10);\n                    assert.strictEqual(ret.error.length, 1);\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find all","suites":["rx-collection.test.ts","instance",".find()","find all","positive"],"updatePoint":{"line":403,"column":32},"line":403,"code":"                    it('find all', async () => {\n                        const c = await humansCollection.create();\n                        const docs = await c.find().exec();\n                        assert.ok(docs.length >= 10);\n                        for (const doc of docs) {\n                            assert.ok(isRxDocument(doc));\n                        }\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find 2 times","suites":["rx-collection.test.ts","instance",".find()","find all","positive"],"updatePoint":{"line":412,"column":36},"line":412,"code":"                    it('find 2 times', async () => {\n                        const c = await humansCollection.create();\n                        const docs = await c.find().exec();\n                        const docs2 = await c.find().exec();\n                        assert.ok(docs.length >= 10);\n                        assert.ok(docs2.length >= 10);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find all by empty object","suites":["rx-collection.test.ts","instance",".find()","find all","positive"],"updatePoint":{"line":433,"column":48},"line":433,"code":"                    it('find all by empty object', async () => {\n                        const c = await humansCollection.create();\n                        const docs = await c.find().exec();\n                        assert.ok(docs.length >= 10);\n                        for (const doc of docs) {\n                            assert.ok(isRxDocument(doc));\n                        }\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find nothing with empty collection","suites":["rx-collection.test.ts","instance",".find()","find all","positive"],"updatePoint":{"line":442,"column":58},"line":442,"code":"                    it('find nothing with empty collection', async () => {\n                        const db = await createRxDatabase({\n                            name: randomCouchString(10),\n                            storage: config.storage.getStorage(),\n                        });\n                        await db.addCollections({\n                            humanx: {\n                                schema: schemas.human\n                            }\n                        });\n                        const collection = db.humanx;\n                        const docs = await collection.find().exec();\n                        assert.deepStrictEqual(docs, []);\n                        db.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should crash with string as query","suites":["rx-collection.test.ts","instance",".find()","find all","negative"],"updatePoint":{"line":480,"column":57},"line":480,"code":"                    it('should crash with string as query', async () => {\n                        const c = await humansCollection.create();\n                        await AsyncTestUtil.assertThrows(\n                            () => (c as any).find('foobar').exec(),\n                            'RxError',\n                            'findOne'\n                        );\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should crash with array as query","suites":["rx-collection.test.ts","instance",".find()","find all","negative"],"updatePoint":{"line":489,"column":56},"line":489,"code":"                    it('should crash with array as query', async () => {\n                        const c = await humansCollection.create();\n                        await AsyncTestUtil.assertThrows(\n                            () => (c as any).find([]).exec(),\n                            'RxTypeError'\n                        );\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find first by passportId","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":501,"column":48},"line":501,"code":"                    it('find first by passportId', async () => {\n                        const c = await humansCollection.create();\n                        let docs = await c.find().exec();\n                        docs = shuffleArray(docs);\n                        const last: any = docs.pop();\n                        const passportId = last._data.passportId;\n                        let doc: any = await c.find({\n                            selector: {\n                                passportId\n                            }\n                        }).exec();\n                        assert.strictEqual(doc.length, 1);\n                        doc = doc[0];\n                        assert.deepStrictEqual(doc['data'], last.data);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find none with random passportId","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":517,"column":56},"line":517,"code":"                    it('find none with random passportId', async () => {\n                        const c = await humansCollection.create();\n                        const query = c.find({\n                            selector: {\n                                passportId: randomCouchString(10)\n                            }\n                        });\n                        const docs = await query.exec();\n                        assert.strictEqual(docs.length, 0);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find via $eq","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":528,"column":36},"line":528,"code":"                    it('find via $eq', async () => {\n                        const c = await humansCollection.create();\n                        let docs = await c.find().exec();\n                        docs = shuffleArray(docs);\n                        const last: any = docs.pop();\n                        const passportId = last._data.passportId;\n                        let doc: any = await c.find({\n                            selector: {\n                                passportId: {\n                                    $eq: passportId\n                                }\n                            }\n                        }).exec();\n                        assert.strictEqual(doc.length, 1);\n                        doc = doc[0];\n                        assert.deepStrictEqual(doc['data'], last.data);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should find the 2 documents with the or-method","suites":["rx-collection.test.ts","instance",".find()","negative"],"updatePoint":{"line":550,"column":66},"line":550,"code":"                it('should find the 2 documents with the or-method', async () => {\n                    const c = await humansCollection.create(10);\n                    // add 2 docs to be found\n                    await c.insert({\n                        passportId: randomString(12),\n                        firstName: 'foobarAlice',\n                        lastName: 'aliceLastName',\n                        age: randomNumber(10, 50)\n                    });\n                    await c.insert({\n                        passportId: randomString(12),\n                        firstName: 'foobarBob',\n                        lastName: 'bobLastName',\n                        age: randomNumber(10, 50)\n                    });\n                    const query = c.find().or([{\n                        firstName: 'foobarAlice'\n                    }, {\n                        firstName: 'foobarBob'\n                    }]);\n\n                    const results = await query.exec();\n                    assert.strictEqual(results.length, 2);\n                    const foundFirstNames = results.map(doc => doc.firstName);\n                    assert.ok(foundFirstNames.includes('foobarAlice'));\n                    assert.ok(foundFirstNames.includes('foobarBob'));\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should find the correct documents via $or on the primary key","suites":["rx-collection.test.ts","instance",".find()","negative"],"updatePoint":{"line":578,"column":80},"line":578,"code":"                it('should find the correct documents via $or on the primary key', async () => {\n                    const c = await humansCollection.createPrimary(10);\n                    const allDocs = await c.find().exec();\n                    const firstFive = allDocs.slice(0, 5);\n                    const selector = {\n                        $or: firstFive.map(doc => ({ passportId: doc.passportId }))\n                    };\n                    const found = await c.find({\n                        selector\n                    }).exec();\n\n                    assert.strictEqual(firstFive.length, found.length);\n                    const firstId = firstFive[0].passportId;\n                    assert.ok(\n                        found.map(d => d.passportId).includes(firstId)\n                    );\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"sort by age desc (with own index-search)","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":599,"column":64},"line":599,"code":"                    it('sort by age desc (with own index-search)', async () => {\n                        const c = await humansCollection.createAgeIndex();\n                        const query = c.find({\n                            selector: {\n                                age: {\n                                    $gt: 0\n                                }\n                            }\n                        }).sort({ age: 'desc' });\n\n                        assert.ok(isRxQuery(query));\n                        const docs = await query.exec();\n                        assert.strictEqual(docs.length, 20);\n                        assert.ok(ensureNotFalsy(docs[0]._data.age) >= ensureNotFalsy(docs[1]._data.age));\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"sort by age desc (with default index-search)","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":615,"column":68},"line":615,"code":"                    it('sort by age desc (with default index-search)', async () => {\n                        const c = await humansCollection.createAgeIndex();\n                        const docs = await c.find().sort({\n                            age: 'desc'\n                        }).exec();\n                        assert.strictEqual(docs.length, 20);\n                        assert.ok(ensureNotFalsy(docs[0]._data.age) >= ensureNotFalsy(docs[1]._data.age));\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"sort by age asc","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":624,"column":39},"line":624,"code":"                    it('sort by age asc', async () => {\n                        const c = await humansCollection.createAgeIndex();\n                        const docs = await c.find().sort({\n                            age: 'asc'\n                        }).exec();\n                        assert.strictEqual(docs.length, 20);\n                        assert.ok(ensureNotFalsy(docs[0]._data.age) <= ensureNotFalsy(docs[1]._data.age));\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"sort by non-top-level-key as index (no keycompression)","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":633,"column":78},"line":633,"code":"                    it('sort by non-top-level-key as index (no keycompression)', async () => {\n                        const db = await createRxDatabase({\n                            name: randomCouchString(10),\n                            storage: getRxStoragePouch('memory'),\n                        });\n                        const schemaObj = clone(schemas.humanSubIndex);\n                        schemaObj.keyCompression = false;\n                        await db.addCollections({\n                            human: {\n                                schema: schemaObj\n                            }\n                        });\n                        const collection = db.human;\n                        const objects = new Array(10).fill(0).map(() => {\n                            return {\n                                passportId: randomCouchString(10),\n                                other: {\n                                    age: randomNumber(10, 50)\n                                }\n                            };\n                        });\n                        await Promise.all(objects.map(o => collection.insert(o)));\n\n                        // do it manually\n                        const all = await collection.storageInstance.internals.pouch.find({\n                            selector: {\n                                'other.age': {\n                                    '$gt': 0\n                                }\n                            },\n                            sort: [\n                                { 'other.age': 'asc' },\n                                { _id: 'asc' }\n                            ]\n                        });\n                        assert.strictEqual(all.docs.length, 10);\n\n                        // with RxQuery\n                        const query = collection.find().sort({\n                            'other.age': 'asc'\n                        });\n                        const docs = await query.exec();\n\n                        let lastAge = 0;\n                        docs.forEach((doc: any) => {\n                            assert.ok(doc.other.age >= lastAge);\n                            lastAge = doc.other.age;\n                        });\n                        db.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"sort by non-top-level-key as index (with keycompression)","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":683,"column":80},"line":683,"code":"                    it('sort by non-top-level-key as index (with keycompression)', async () => {\n                        if (config.storage.name === 'lokijs') {\n                            // TODO why does this test not work on lokijs?\n                            return;\n                        }\n                        const db = await createRxDatabase({\n                            name: randomCouchString(10),\n                            storage: config.storage.getStorage(),\n                        });\n                        await db.addCollections({\n                            human: {\n                                schema: schemas.humanSubIndex\n                            }\n                        });\n                        const collection = db.human;\n                        const objects = new Array(10).fill(0).map(() => {\n                            return {\n                                passportId: randomCouchString(10),\n                                other: {\n                                    age: randomNumber(10, 50)\n                                }\n                            };\n                        });\n                        await Promise.all(objects.map(o => collection.insert(o)));\n\n                        // with RxQuery\n                        const query = collection.find().sort({\n                            'other.age': 'asc'\n                        });\n                        const docs = await query.exec();\n\n                        let lastAge = 0;\n                        docs.forEach((doc: any) => {\n                            assert.ok(doc.other.age >= lastAge);\n                            lastAge = doc.other.age;\n                        });\n                        db.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"validate results","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":721,"column":40},"line":721,"code":"                    it('validate results', async () => {\n                        const c = await humansCollection.createAgeIndex(0);\n                        const docsData = new Array(10)\n                            .fill(0)\n                            .map((_v, idx) => {\n                                const docData = schemaObjects.human();\n                                docData.age = idx + 10;\n                                return docData;\n                            });\n                        await c.bulkInsert(docsData);\n\n                        const desc = await c.find().sort({\n                            age: 'desc'\n                        }).exec();\n                        const asc = await c.find().sort({\n                            age: 'asc'\n                        }).exec();\n                        const ascIds = asc.map(d => d.primary);\n                        const descIds = desc.map(d => d.primary);\n                        const reverseDescIds = descIds.slice(0).reverse();\n\n                        assert.deepStrictEqual(ascIds, reverseDescIds);\n\n                        /**\n                         * TODO Here we have increasing age-values for the test data.\n                         * But we also should include two documents with the same age,\n                         * to ensure the sorting is deterministic. But this fails\n                         * for the pouchdb RxStorage at this point in time.\n                         */\n\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find the same twice","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":753,"column":43},"line":753,"code":"                    it('find the same twice', async () => {\n                        const c = await humansCollection.createNested(5);\n                        const doc1 = await c.findOne().sort({\n                            passportId: 'asc'\n                        }).exec(true);\n                        const doc2 = await c.findOne().sort({\n                            passportId: 'asc'\n                        }).exec(true);\n                        assert.strictEqual(doc1._data.passportId, doc2._data.passportId);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"sort by compound index with id","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":764,"column":54},"line":764,"code":"                    it('sort by compound index with id', async () => {\n                        const c = await humansCollection.createIdAndAgeIndex();\n                        const query = c.find({\n                            selector: {\n                                age: {\n                                    $gt: 0\n                                }\n                            }\n                        }).sort({\n                            age: 'desc',\n                            id: 'desc'\n                        });\n\n                        assert.ok(isRxQuery(query));\n                        const docs = await query.exec();\n\n                        assert.strictEqual(docs.length, 20);\n                        assert.ok(\n                            docs[0]._data.age > docs[1]._data.age ||\n                            (\n                                docs[0]._data.age === docs[1]._data.age &&\n                                docs[0]._data.id > docs[1]._data.id\n                            )\n                        );\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"throw when sort is not index","suites":["rx-collection.test.ts","instance",".find()","negative"],"updatePoint":{"line":792,"column":52},"line":792,"code":"                    it('throw when sort is not index', async () => {\n                        if (config.storage.name !== 'pouchdb') {\n                            return;\n                        }\n                        const c = await humansCollection.create();\n                        await c.find().exec();\n                        await AsyncTestUtil.assertThrows(\n                            () => c.find({\n                                selector: {\n                                    age: {\n                                        $gt: 0\n                                    }\n                                }\n                            })\n                                .sort({\n                                    age: 'desc'\n                                })\n                                .exec(),\n                            Error\n                        );\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"#146 throw when field not in schema (object)","suites":["rx-collection.test.ts","instance",".find()","negative"],"updatePoint":{"line":814,"column":68},"line":814,"code":"                    it('#146 throw when field not in schema (object)', async () => {\n                        if (config.storage.name !== 'pouchdb') {\n                            return;\n                        }\n                        const c = await humansCollection.createAgeIndex();\n                        await AsyncTestUtil.assertThrows(\n                            () => c.find().sort({\n                                foobar: 'desc'\n                            }).exec(),\n                            'RxError',\n                            'not defined in the schema'\n                        );\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"#146 throw when field not in schema (string)","suites":["rx-collection.test.ts","instance",".find()","negative"],"updatePoint":{"line":828,"column":68},"line":828,"code":"                    it('#146 throw when field not in schema (string)', async () => {\n                        if (config.storage.name !== 'pouchdb') {\n                            return;\n                        }\n                        const c = await humansCollection.createAgeIndex();\n                        await AsyncTestUtil.assertThrows(\n                            () => c.find().sort('foobar').exec(),\n                            'RxError',\n                            'not defined in the schema'\n                        );\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"get first","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":844,"column":33},"line":844,"code":"                    it('get first', async () => {\n                        const c = await humansCollection.create();\n                        const docs = await c.find().limit(1).exec();\n                        assert.strictEqual(docs.length, 1);\n                        assert.ok(isRxDocument(docs[0]));\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"get last in order","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":851,"column":41},"line":851,"code":"                    it('get last in order', async () => {\n                        const c = await humansCollection.create(10);\n                        const docs = await c.find().sort({\n                            passportId: 'asc'\n                        }).exec();\n                        let firstDoc: any = await c.find().sort({\n                            passportId: 'asc'\n                        }).limit(1).exec();\n                        firstDoc = firstDoc[0];\n\n                        let last: any = await c.find().sort({\n                            passportId: 'desc'\n                        }).limit(1).exec();\n                        last = last[0];\n\n                        assert.strictEqual(last['_data'].passportId, docs[(docs.length - 1)]._data.passportId);\n                        assert.notStrictEqual(firstDoc['_data'].passportId, last['_data'].passportId);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"reset limit with .limit(null)","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":870,"column":53},"line":870,"code":"                    it('reset limit with .limit(null)', async () => {\n                        const c = await humansCollection.create();\n                        const docs = await c.find().limit(1).limit(null).exec();\n                        assert.ok(docs.length > 1);\n                        assert.ok(isRxDocument(docs[0]));\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"skip first","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":881,"column":34},"line":881,"code":"                    it('skip first', async () => {\n                        const c = await humansCollection.create(\n                            2,\n                            randomCouchString(10),\n                            false,\n                            false\n                        );\n\n                        const query: any = {\n                            selector: {\n                                passportId: {\n                                    /**\n                                     * TODO The skip-query randomly returns wrong results\n                                     * when this $ne is not set.\n                                     * We should create an issue at the pouchdb repo.\n                                     */\n                                    $ne: RANDOM_STRING\n                                }\n                            },\n                            sort: [\n                                { passportId: 'asc' }\n                            ]\n                        };\n\n                        const docs = await c.find(query).exec();\n                        const noFirstQuery = c.find(query).skip(1);\n                        const noFirst = await noFirstQuery.exec();\n                        assert.strictEqual(noFirst.length, 1);\n                        assert.strictEqual(noFirst[0]._data.passportId, docs[1]._data.passportId);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"skip first in order","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":912,"column":43},"line":912,"code":"                    it('skip first in order', async () => {\n                        /**\n                         * TODO this test fails on pouchdb when the schema contains an index.\n                         * Likely because pouchdb then skips the internal index-document, not the\n                         * human documents, which then returns wrong results.\n                         * Wait for the next pouchdb release and then try again,\n                         * or create an issue at the pouchdb repo.\n                         */\n                        // const c = humansCollection.create(5);\n\n                        const db = await createRxDatabase<{ humans: RxCollection<HumanDocumentType> }>({\n                            name: randomCouchString(10),\n                            storage: config.storage.getStorage(),\n                            eventReduce: true\n                        });\n                        const collections = await db.addCollections({\n                            humans: {\n                                schema: schemas.humanDefault\n                            }\n                        });\n                        const c = collections.humans;\n                        await Promise.all(\n                            new Array(5)\n                                .fill(0)\n                                .map(() => c.insert(schemaObjects.human()))\n                        );\n\n                        const docs = await c.find().sort({\n                            passportId: 'asc'\n                        }).exec();\n                        const noFirst = await c.find().sort({\n                            passportId: 'asc'\n                        }).skip(1).exec();\n\n                        assert.strictEqual(noFirst[0]._data.passportId, docs[1]._data.passportId);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"reset skip with .skip(null)","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":975,"column":51},"line":975,"code":"                    it('reset skip with .skip(null)', async () => {\n                        const c = await humansCollection.create();\n                        const docs = await c.find().exec();\n                        const noFirst = await c.find().skip(1).skip(null).exec();\n                        assert.notStrictEqual(noFirst[0]._data.passportId, docs[1]._data.passportId);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find the one where the regex matches","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":990,"column":60},"line":990,"code":"                    it('find the one where the regex matches', async () => {\n                        const c = await humansCollection.create(10);\n                        const matchHuman = schemaObjects.human();\n                        matchHuman.firstName = 'FooMatchBar';\n                        await c.insert(matchHuman);\n                        const docs = await c.find()\n                            .where('firstName').regex(/Match/)\n                            .exec();\n                        assert.strictEqual(docs.length, 1);\n                        const firstDoc = docs[0];\n                        assert.strictEqual(firstDoc.get('firstName'), matchHuman.firstName);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"case sensitive regex","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":1003,"column":44},"line":1003,"code":"                    it('case sensitive regex', async () => {\n                        const c = await humansCollection.create(10);\n                        const matchHuman = schemaObjects.human();\n                        matchHuman.firstName = 'FooMatchBar';\n                        await c.insert(matchHuman);\n                        const docs = await c.find()\n                            .where('firstName').regex(/match/i)\n                            .exec();\n\n                        assert.strictEqual(docs.length, 1);\n                        const firstDoc = docs[0];\n                        assert.strictEqual(firstDoc.get('firstName'), matchHuman.firstName);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"regex on index","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":1017,"column":38},"line":1017,"code":"                    it('regex on index', async () => {\n                        const c = await humansCollection.create(10);\n                        const matchHuman = schemaObjects.human();\n                        matchHuman.firstName = 'FooMatchBar';\n                        await c.insert(matchHuman);\n                        const docs = await c.find()\n                            .where('firstName').regex(/Match/)\n                            .exec();\n\n                        assert.strictEqual(docs.length, 1);\n                        const firstDoc = docs[0];\n                        assert.strictEqual(firstDoc.get('firstName'), matchHuman.firstName);\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"regex on primary should throw","suites":["rx-collection.test.ts","instance",".find()","negative"],"updatePoint":{"line":1036,"column":53},"line":1036,"code":"                    it('regex on primary should throw', async () => {\n                        if (!config.storage.hasRegexSupport) {\n                            return;\n                        }\n\n                        // TODO run this check in dev-mode so it behaves equal on all storage implementations.\n                        if (config.storage.name !== 'pouchdb') {\n                            return;\n                        }\n                        const c = await humansCollection.createPrimary(0);\n                        await AsyncTestUtil.assertThrows(\n                            () => c.find().where('passportId').regex(/Match/).exec(),\n                            'RxError',\n                            'regex'\n                        );\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should remove all documents","suites":["rx-collection.test.ts","instance",".find()","negative"],"updatePoint":{"line":1056,"column":47},"line":1056,"code":"                it('should remove all documents', async () => {\n                    const c = await humansCollection.create(10);\n                    const query = c.find();\n\n\n                    const removed = await query.remove();\n                    assert.strictEqual(removed.length, 10);\n                    removed.forEach(doc => {\n                        assert.ok(isRxDocument(doc));\n                        assert.strictEqual(doc.deleted, true);\n                    });\n                    const docsAfter = await c.find().exec();\n                    assert.strictEqual(docsAfter.length, 0);\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should remove only found documents","suites":["rx-collection.test.ts","instance",".find()","negative"],"updatePoint":{"line":1071,"column":54},"line":1071,"code":"                it('should remove only found documents', async () => {\n                    const c = await humansCollection.create(10);\n                    const query = c.find().limit(5);\n\n                    const removed = await query.remove();\n                    assert.strictEqual(removed.length, 5);\n                    removed.forEach(doc => {\n                        assert.ok(isRxDocument(doc));\n                        assert.strictEqual(doc.deleted, true);\n                    });\n                    const docsAfter = await c.find().exec();\n                    assert.strictEqual(docsAfter.length, 5);\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"remove on findOne","suites":["rx-collection.test.ts","instance",".find()","negative"],"updatePoint":{"line":1085,"column":37},"line":1085,"code":"                it('remove on findOne', async () => {\n                    const c = await humansCollection.create(10);\n                    const query = c.findOne();\n                    const removed: any = await query.remove();\n                    assert.ok(isRxDocument(removed));\n                    assert.strictEqual(removed.deleted, true);\n                    const docsAfter = await c.find().exec();\n                    assert.strictEqual(docsAfter.length, 9);\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"#3785 should work when the collection name contains a dash or other special characters","suites":["rx-collection.test.ts","instance",".find()","negative"],"updatePoint":{"line":1098,"column":106},"line":1098,"code":"                it('#3785 should work when the collection name contains a dash or other special characters', async () => {\n                    if (\n                        !config.storage.hasPersistence ||\n                        /**\n                         * TODO this test makes no sense in dexie-worker\n                         * because there we use the in-memory persistence\n                         * which is not really persistent between different writes.\n                         */\n                        config.storage.name === 'dexie-worker'\n                    ) {\n                        return;\n                    }\n\n                    const collectionNames: string[] = [\n                        'name_with_a_-_in',\n                        'name_no_dash',\n                        'dollar$collection'\n                    ].sort();\n\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                    });\n\n                    const collectionsCreator: { [k: string]: RxCollectionCreator } = {};\n                    collectionNames.forEach(collectionName => {\n                        collectionsCreator[collectionName] = {\n                            schema: schemas.human\n                        };\n                    });\n                    await db.addCollections(collectionsCreator);\n\n                    /**\n                     * Add a document to each collection\n                     */\n                    const docData = schemaObjects.simpleHuman();\n                    await Promise.all(\n                        Object.keys(db.collections).map(collectionName => {\n                            return db.collections[collectionName].insert(docData);\n                        })\n                    );\n\n                    const removedCollections = await db.remove();\n\n                    assert.deepStrictEqual(\n                        removedCollections.sort(),\n                        collectionNames\n                    );\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"#3788 removing the collection should also remove all changes","suites":["rx-collection.test.ts","instance",".find()","negative"],"updatePoint":{"line":1150,"column":80},"line":1150,"code":"                it('#3788 removing the collection should also remove all changes', async () => {\n                    if (!config.storage.hasMultiInstance) {\n                        return;\n                    }\n\n                    const dbName = randomCouchString();\n\n                    const createDb = async () => {\n                        const db = await createRxDatabase({\n                            name: dbName,\n                            storage: config.storage.getStorage(),\n                            ignoreDuplicate: true\n                        });\n                        await db.addCollections({\n                            'human-2': { schema: schemas.human }\n                        });\n                        return db;\n                    }\n\n                    const db1 = await createDb();\n\n                    await db1.collections['human-2'].insert(schemaObjects.simpleHuman());\n\n                    // remove the collection on one database\n                    await db1['human-2'].remove();\n                    await db1.destroy();\n\n                    const db2 = await createDb();\n\n                    /**\n                     * Getting the changes in the other database should have an empty result.\n                     */\n                    const changesResult = await db2['human-2'].storageInstance.getChangedDocumentsSince(10);\n                    assert.strictEqual(changesResult.documents.length, 0);\n\n                    db2.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should remove some humans","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":1190,"column":49},"line":1190,"code":"                    it('should remove some humans', async () => {\n                        const amount = 5;\n                        const c = await humansCollection.create(amount);\n                        const docList = await c.find().exec();\n\n                        assert.strictEqual(docList.length, amount);\n\n                        const primaryList = docList.map(doc => doc.primary);\n                        const ret = await c.bulkRemove(primaryList);\n                        assert.strictEqual(ret.success.length, amount);\n\n                        const finalList = await c.find().exec();\n                        assert.strictEqual(finalList.length, 0);\n\n                        c.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not throw when called with an empty array","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":1206,"column":72},"line":1206,"code":"                    it('should not throw when called with an empty array', async () => {\n                        const col = await humansCollection.create(0);\n                        await col.bulkRemove([]);\n                        col.database.destroy();\n                    });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"sets a field in all documents","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":1214,"column":49},"line":1214,"code":"                it('sets a field in all documents', async () => {\n                    const c = await humansCollection.create(2);\n                    const query = c.find();\n                    await query.update({\n                        $set: {\n                            firstName: 'new first name'\n                        }\n                    });\n                    const docsAfterUpdate = await c.find().exec();\n                    for (const doc of docsAfterUpdate) {\n                        assert.strictEqual(doc._data.firstName, 'new first name');\n                    }\n\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"unsets fields in all documents","suites":["rx-collection.test.ts","instance",".find()","positive"],"updatePoint":{"line":1229,"column":50},"line":1229,"code":"                it('unsets fields in all documents', async () => {\n                    // TODO should work on all storage implementations\n                    if (config.storage.name !== 'pouchdb') {\n                        return;\n                    }\n                    const c = await humansCollection.create(10);\n                    const query = c.find();\n                    await query.update({\n                        $unset: {\n                            age: ''\n                        }\n                    });\n                    const docsAfterUpdate = await c.find().exec();\n                    for (const doc of docsAfterUpdate) {\n                        assert.strictEqual(doc.age, undefined);\n                    }\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find a single document","suites":["rx-collection.test.ts","instance",".findOne()","positive"],"updatePoint":{"line":1251,"column":42},"line":1251,"code":"                it('find a single document', async () => {\n                    const c = await humansCollection.create();\n                    const doc = await c.findOne().exec();\n                    assert.ok(isRxDocument(doc));\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"not crash on empty db","suites":["rx-collection.test.ts","instance",".findOne()","positive"],"updatePoint":{"line":1257,"column":41},"line":1257,"code":"                it('not crash on empty db', async () => {\n                    const c = await humansCollection.create(0);\n                    const docs = await c.find().limit(1).exec();\n                    assert.strictEqual(docs.length, 0);\n                    const doc = await c.findOne().exec();\n                    assert.strictEqual(doc, null);\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find different on .skip()","suites":["rx-collection.test.ts","instance",".findOne()","positive"],"updatePoint":{"line":1265,"column":45},"line":1265,"code":"                it('find different on .skip()', async () => {\n                    const c = await humansCollection.create();\n                    const doc: any = await c.findOne().exec();\n                    const doc2: any = await c.findOne().skip(2).exec();\n                    assert.ok(isRxDocument(doc));\n                    assert.ok(isRxDocument(doc2));\n                    assert.notStrictEqual(doc._data.passportId, doc2._data.passportId);\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find by primary","suites":["rx-collection.test.ts","instance",".findOne()","positive"],"updatePoint":{"line":1274,"column":35},"line":1274,"code":"                it('find by primary', async () => {\n                    const c = await humansCollection.create();\n                    const doc: any = await c.findOne().exec();\n                    const _id = doc.primary;\n                    assert.strictEqual(typeof _id, 'string');\n                    const docById: any = await c.findOne(_id).exec();\n                    assert.deepStrictEqual(docById.data, doc.data);\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"find by primary in parallel","suites":["rx-collection.test.ts","instance",".findOne()","positive"],"updatePoint":{"line":1283,"column":47},"line":1283,"code":"                it('find by primary in parallel', async () => {\n                    // TODO should work on all storage implementations\n                    if (config.storage.name !== 'pouchdb') {\n                        return;\n                    }\n\n                    const c = await humansCollection.createPrimary(0);\n\n                    const docData = schemaObjects.simpleHuman();\n                    const primary = docData.passportId;\n\n                    const notExist = await c.findOne(primary).exec();\n                    assert.strictEqual(notExist, null);\n\n                    const insertedDoc = await c.insert(docData);\n                    assert.ok(isRxDocument(insertedDoc));\n\n                    const results = await Promise.all([\n                        c.findOne(primary).exec(true),\n                        c.findOne(primary).exec(true)\n                    ]);\n                    assert.ok(isRxDocument(results[0]));\n\n                    assert.ok(results[0] === results[1]);\n\n                    await results[0].atomicPatch({ firstName: 'foobar' });\n\n                    const results2 = await Promise.all([\n                        c.findOne(primary).exec(),\n                        c.findOne(primary).exec()\n                    ]);\n                    assert.ok(isRxDocument(results2[0]));\n                    assert.ok(results2[0] === results2[1]);\n\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"BUG: should throw when no-string given (number)","suites":["rx-collection.test.ts","instance",".findOne()","negative"],"updatePoint":{"line":1341,"column":67},"line":1341,"code":"                it('BUG: should throw when no-string given (number)', async () => {\n                    const c = await humansCollection.create();\n                    assert.throws(\n                        () => (c as any).findOne(5),\n                        TypeError\n                    );\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"BUG: should throw when no-string given (array)","suites":["rx-collection.test.ts","instance",".findOne()","negative"],"updatePoint":{"line":1349,"column":66},"line":1349,"code":"                it('BUG: should throw when no-string given (array)', async () => {\n                    const c = await humansCollection.create();\n                    assert.throws(\n                        () => (c as any).findOne([]),\n                        TypeError\n                    );\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"insert and update","suites":["rx-collection.test.ts","instance",".findOne()","negative"],"updatePoint":{"line":1360,"column":33},"line":1360,"code":"            it('insert and update', async () => {\n                const c = await humansCollection.create(0);\n                const amount = 5;\n\n                // insert\n                await c.bulkUpsert(\n                    new Array(amount).fill(0).map(() => schemaObjects.human())\n                );\n                let allDocs = await c.find().exec();\n                assert.strictEqual(allDocs.length, 5);\n\n                // update\n                const docsData = allDocs.map(d => {\n                    const data = d.toMutableJSON();\n                    data.age = 100;\n                    return data;\n                });\n                await c.bulkUpsert(docsData);\n                allDocs = await c.find().exec();\n                assert.strictEqual(allDocs.length, 5);\n                allDocs.forEach(d => assert.strictEqual(d.age, 100));\n\n                c.database.destroy();\n            });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"insert when not exists","suites":["rx-collection.test.ts","instance","positive"],"updatePoint":{"line":1387,"column":42},"line":1387,"code":"                it('insert when not exists', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    const obj = schemaObjects.simpleHuman();\n                    obj.firstName = 'foobar';\n                    await collection.upsert(obj);\n                    const doc = await collection.findOne().exec();\n                    assert.strictEqual(doc.firstName, 'foobar');\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"overwrite exisiting document","suites":["rx-collection.test.ts","instance","positive"],"updatePoint":{"line":1405,"column":48},"line":1405,"code":"                it('overwrite exisiting document', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage(),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    const obj = schemaObjects.simpleHuman();\n                    await collection.insert(obj);\n                    obj.firstName = 'foobar';\n                    await collection.upsert(obj);\n                    const doc = await collection.findOne().exec();\n                    assert.strictEqual(doc.firstName, 'foobar');\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"overwrite twice","suites":["rx-collection.test.ts","instance","positive"],"updatePoint":{"line":1424,"column":35},"line":1424,"code":"                it('overwrite twice', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage()\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    const obj = schemaObjects.simpleHuman();\n\n                    await collection.insert(obj);\n                    obj.firstName = 'foobar';\n                    await collection.upsert(obj);\n\n                    obj.firstName = 'foobar2';\n                    await collection.upsert(obj);\n\n                    const doc = await collection.findOne().exec();\n                    assert.strictEqual(doc.firstName, 'foobar2');\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"overwrite deleted","suites":["rx-collection.test.ts","instance","positive"],"updatePoint":{"line":1448,"column":37},"line":1448,"code":"                it('overwrite deleted', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage()\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    const objData = schemaObjects.simpleHuman();\n\n                    const doc = await collection.insert(objData);\n\n                    await doc.atomicPatch({\n                        firstName: 'alice'\n                    });\n                    await doc.remove();\n\n                    objData.firstName = 'foobar';\n                    await collection.upsert(objData);\n\n                    const docAfter = await collection.findOne(objData.passportId).exec(true);\n                    assert.strictEqual(docAfter.firstName, 'foobar');\n\n                    /**\n                     * The storage must have auto-resolved the conflict\n                     * because it was an insert to overwrite a previously deleted document.\n                     * Therefore the revision height must be 4 and do not start with 1 again.\n                     * @link https://github.com/pubkey/rxdb/pull/3839\n                     */\n                    const parsedRev = parseRevision(docAfter.toJSON(true)._rev);\n                    assert.strictEqual(parsedRev.height, 4);\n\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"throw when primary missing","suites":["rx-collection.test.ts","instance","negative"],"updatePoint":{"line":1487,"column":46},"line":1487,"code":"                it('throw when primary missing', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage()\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    const obj = schemaObjects.simpleHuman();\n                    await collection.insert(obj);\n                    const cloned: any = clone(obj);\n\n                    cloned.firstName = 'foobar';\n                    delete cloned.passportId;\n                    await AsyncTestUtil.assertThrows(\n                        () => collection.upsert(cloned),\n                        'RxError',\n                        'without primary'\n                    );\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should work in serial","suites":["rx-collection.test.ts","instance",".atomicUpsert()"],"updatePoint":{"line":1515,"column":41},"line":1515,"code":"                it('should work in serial', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const docData = schemaObjects.simpleHuman();\n                    const primary = docData.passportId;\n                    await c.findOne(primary).exec();\n                    await c.atomicUpsert(docData);\n                    await c.findOne(primary).exec();\n                    const docData2 = clone(docData);\n                    docData.firstName = 'foobar';\n\n                    await c.atomicUpsert(docData2);\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not crash when upserting the same doc in parallel","suites":["rx-collection.test.ts","instance",".atomicUpsert()"],"updatePoint":{"line":1528,"column":76},"line":1528,"code":"                it('should not crash when upserting the same doc in parallel', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const docData = schemaObjects.simpleHuman();\n                    const docs = await Promise.all([\n                        c.atomicUpsert(docData),\n                        c.atomicUpsert(docData)\n                    ]);\n                    assert.ok(docs[0] === docs[1]);\n                    assert.ok(isRxDocument(docs[0]));\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not crash when upserting the same doc in parallel 3 times","suites":["rx-collection.test.ts","instance",".atomicUpsert()"],"updatePoint":{"line":1539,"column":84},"line":1539,"code":"                it('should not crash when upserting the same doc in parallel 3 times', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const docData = schemaObjects.simpleHuman();\n                    const docs = await Promise.all([\n                        c.atomicUpsert(docData),\n                        c.atomicUpsert(docData),\n                        c.atomicUpsert(docData)\n                    ]);\n                    assert.ok(docs[0] === docs[1]);\n                    assert.ok(isRxDocument(docs[0]));\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not crash when upserting the same doc in parallel many times with random waits","suites":["rx-collection.test.ts","instance",".atomicUpsert()"],"updatePoint":{"line":1551,"column":105},"line":1551,"code":"                it('should not crash when upserting the same doc in parallel many times with random waits', async function () {\n                    const c = await humansCollection.createPrimary(0);\n                    const docData = schemaObjects.simpleHuman();\n                    docData.firstName = 'test-many-atomic-upsert';\n\n                    let t = 0;\n                    const amount = config.isFastMode() ? 20 : 200;\n\n                    const docs = await Promise.all(\n                        new Array(amount)\n                            .fill(0)\n                            .map((_v, idx) => {\n                                const upsertData = clone(docData);\n                                upsertData.lastName = idx + '';\n                                const randomWait = randomBoolean() ? wait(randomNumber(0, 30)) : Promise.resolve();\n                                return randomWait\n                                    .then(() => c.atomicUpsert(upsertData))\n                                    .then(doc => {\n                                        t++;\n                                        return doc;\n                                    });\n                            })\n                    );\n                    assert.strictEqual(t, amount);\n                    assert.ok(docs[0] === docs[1]);\n                    assert.ok(isRxDocument(docs[0]));\n\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should update the value","suites":["rx-collection.test.ts","instance",".atomicUpsert()"],"updatePoint":{"line":1580,"column":43},"line":1580,"code":"                it('should update the value', async function () {\n                    const c = await humansCollection.createPrimary(0);\n                    const docData = schemaObjects.simpleHuman();\n                    const docId = docData.passportId;\n\n                    await Promise.all([\n                        c.atomicUpsert(docData),\n                        c.atomicUpsert(docData),\n                        c.atomicUpsert(docData)\n                    ]);\n\n                    const viaStorage = await c.storageInstance.findDocumentsById([docId], true);\n                    const viaStorageDoc = viaStorage[docId];\n                    assert.ok(parseRevision(viaStorageDoc._rev).height >= 3);\n\n                    const docData2 = clone(docData);\n                    docData2.firstName = 'foobar';\n                    await c.atomicUpsert(docData2);\n                    const doc = await c.findOne().exec(true);\n                    assert.strictEqual(doc.firstName, 'foobar');\n\n\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should work when upserting to existing document","suites":["rx-collection.test.ts","instance",".atomicUpsert()"],"updatePoint":{"line":1604,"column":67},"line":1604,"code":"                it('should work when upserting to existing document', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const docData = schemaObjects.simpleHuman();\n                    await c.insert(docData);\n                    const docs = await Promise.all([\n                        c.atomicUpsert(docData),\n                        c.atomicUpsert(docData),\n                        c.atomicUpsert(docData)\n                    ]);\n                    assert.ok(docs[0] === docs[1]);\n                    assert.ok(isRxDocument(docs[0]));\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should process in the given order","suites":["rx-collection.test.ts","instance",".atomicUpsert()"],"updatePoint":{"line":1617,"column":53},"line":1617,"code":"                it('should process in the given order', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const docData = schemaObjects.simpleHuman();\n                    const order: any[] = [];\n                    await Promise.all([\n                        c.atomicUpsert(docData).then(() => order.push(0)),\n                        c.atomicUpsert(docData).then(() => order.push(1)),\n                        c.atomicUpsert(docData).then(() => order.push(2))\n                    ]);\n                    assert.deepStrictEqual(order, [0, 1, 2]);\n\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should work when inserting on a slow storage","suites":["rx-collection.test.ts","instance",".atomicUpsert()"],"updatePoint":{"line":1630,"column":64},"line":1630,"code":"                it('should work when inserting on a slow storage', async () => {\n                    if (!config.platform.isNode()) return;\n                    // use a 'slow' adapter because memory might be to fast\n                    const leveldown = require('leveldown');\n                    addPouchPlugin(require('pouchdb-adapter-leveldb'));\n                    const db = await createRxDatabase({\n                        name: config.rootPath + 'test_tmp/' + randomCouchString(10),\n                        storage: getRxStoragePouch(leveldown),\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const c = collections.human;\n\n                    const docData = schemaObjects.simpleHuman();\n                    await c.atomicUpsert(docData);\n                    await c.atomicUpsert(docData);\n                    const docData2 = clone(docData);\n                    docData2.firstName = 'foobar1';\n                    await c.atomicUpsert(docData2);\n                    const docs = await c.find().exec();\n                    assert.strictEqual(docs.length, 1);\n                    const doc = await c.findOne().exec();\n                    assert.strictEqual(doc.firstName, 'foobar1');\n\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should set correct default values","suites":["rx-collection.test.ts","instance",".atomicUpsert()"],"updatePoint":{"line":1659,"column":53},"line":1659,"code":"                it('should set correct default values', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage()\n                    });\n\n                    const schema: RxJsonSchema<HumanDocumentType> = clone(schemas.humanDefault);\n\n                    const defaultValue = schema.properties.age.default;\n                    const collections = await db.addCollections({\n                        nestedhuman: {\n                            schema\n                        }\n                    });\n                    const collection = collections.nestedhuman;\n\n                    const doc = await collection.atomicUpsert({\n                        passportId: 'foobar',\n                        firstName: 'foobar2'\n                    });\n\n                    assert.strictEqual(doc.age, defaultValue);\n\n                    // should also set after atomicUpdate when document exists\n                    const afterUpdate = await collection.atomicUpsert({\n                        passportId: 'foobar',\n                        firstName: 'foobar3'\n                    });\n                    assert.strictEqual(afterUpdate.age, defaultValue);\n\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should completely remove fields that are unset","suites":["rx-collection.test.ts","instance",".atomicUpsert()"],"updatePoint":{"line":1691,"column":66},"line":1691,"code":"                it('should completely remove fields that are unset', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage()\n                    });\n                    const schema: RxJsonSchema<HumanDocumentType> = clone(schemas.humanDefault);\n\n                    const collections = await db.addCollections({\n                        nestedhuman: {\n                            schema\n                        }\n                    });\n                    const collection = collections.nestedhuman;\n\n                    const doc = await collection.atomicUpsert({\n                        passportId: 'foobar',\n                        firstName: 'foobar2'\n                    });\n                    assert.strictEqual(doc.firstName, 'foobar2');\n\n                    const afterUpdate = await collection.atomicUpsert({\n                        passportId: 'foobar'\n                    });\n                    assert.strictEqual(typeof afterUpdate.firstName, 'undefined');\n\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not crash","suites":["rx-collection.test.ts","instance","positive"],"updatePoint":{"line":1722,"column":36},"line":1722,"code":"                it('should not crash', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    await c.remove();\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should be possible to re-create the collection with different schema","suites":["rx-collection.test.ts","instance","positive"],"updatePoint":{"line":1727,"column":88},"line":1727,"code":"                it('should be possible to re-create the collection with different schema', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage()\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n\n                    await collection.remove();\n                    const otherSchema: any = clone(schemas.primaryHuman);\n                    otherSchema.properties['foobar'] = {\n                        type: 'string'\n                    };\n                    await db.addCollections({\n                        human: {\n                            schema: otherSchema\n                        }\n                    });\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not contain document when re-creating","suites":["rx-collection.test.ts","instance","positive"],"updatePoint":{"line":1751,"column":64},"line":1751,"code":"                it('should not contain document when re-creating', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage()\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    await Promise.all(\n                        new Array(5).fill(0)\n                            .map(() => collection.insert(schemaObjects.human()))\n                    );\n                    const allDocs = await collection.find().exec();\n                    assert.strictEqual(5, allDocs.length);\n                    await collection.remove();\n\n                    const collections2 = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection2 = collections2.human;\n                    const noDocs = await collection2.find().exec();\n                    assert.strictEqual(0, noDocs.length);\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should have deleted the local documents","suites":["rx-collection.test.ts","instance","positive"],"updatePoint":{"line":1780,"column":59},"line":1780,"code":"                it('should have deleted the local documents', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage()\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman,\n                            localDocuments: true\n                        }\n                    });\n                    const collection = collections.human;\n                    const id = 'foobar';\n                    await collection.insertLocal(id, { foo: 'bar' });\n\n                    await collection.remove();\n\n                    const collections2 = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman,\n                            localDocuments: true\n                        }\n                    });\n                    const collection2 = collections2.human;\n                    const hasLocal = await collection2.getLocal(id);\n                    assert.strictEqual(hasLocal, null);\n\n                    await db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should delete when older versions exist","suites":["rx-collection.test.ts","instance","positive"],"updatePoint":{"line":1809,"column":59},"line":1809,"code":"                it('should delete when older versions exist', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage: config.storage.getStorage()\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n\n                    await Promise.all(\n                        new Array(5).fill(0)\n                            .map(() => collection.insert(schemaObjects.human()))\n                    );\n                    await collection.remove();\n\n                    const otherSchema = clone(schemas.primaryHuman);\n                    otherSchema.version = 1;\n                    const collections2 = await db.addCollections({\n                        human: {\n                            schema: otherSchema,\n                            migrationStrategies: {\n                                1: function (doc: any) {\n                                    return doc;\n                                }\n                            }\n                        }\n                    });\n                    const collection2 = collections2.human;\n\n                    const noDocs = await collection2.find().exec();\n                    assert.strictEqual(noDocs.length, 0);\n                    await Promise.all(\n                        new Array(5).fill(0)\n                            .map(() => collection2.insert(schemaObjects.human()))\n                    );\n                    const fiveDocs = await collection2.find().exec();\n                    assert.strictEqual(fiveDocs.length, 5);\n                    await collection2.remove();\n\n\n                    const collections0Again = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection0Again = collections0Again.human;\n                    const noDocs2 = await collection0Again.find().exec();\n                    assert.strictEqual(noDocs2.length, 0);\n\n                    db.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not be possible to use the cleared collection","suites":["rx-collection.test.ts","instance","negative"],"updatePoint":{"line":1865,"column":72},"line":1865,"code":"                it('should not be possible to use the cleared collection', async () => {\n                    // TODO should work on all storage implementations\n                    if (config.storage.name !== 'pouchdb') {\n                        return;\n                    }\n                    const c = await humansCollection.createPrimary(0);\n                    await c.remove();\n                    await AsyncTestUtil.assertThrows(\n                        () => c.find().exec(),\n                        Error\n                    );\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not have the collection in the collections-list","suites":["rx-collection.test.ts","instance","negative"],"updatePoint":{"line":1878,"column":74},"line":1878,"code":"                it('should not have the collection in the collections-list', async () => {\n                    const c = await humansCollection.createPrimary(0);\n                    const db = c.database;\n                    const name = c.name;\n                    await c.remove();\n                    assert.strictEqual(undefined, db[name]);\n                    c.database.destroy();\n                });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not crash","suites":["rx-collection.test.ts","instance","negative"],"updatePoint":{"line":1889,"column":32},"line":1889,"code":"            it('should not crash', async () => {\n                const c = await humansCollection.create();\n                const res = await c.findByIds([\n                    'foo',\n                    'bar'\n                ]);\n                assert.ok(res);\n                c.database.destroy();\n            });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should find the documents","suites":["rx-collection.test.ts","instance","negative"],"updatePoint":{"line":1898,"column":41},"line":1898,"code":"            it('should find the documents', async () => {\n                const c = await humansCollection.create(5);\n\n                const docs = await c.find().exec();\n                const ids = docs.map(d => d.primary);\n                const res = await c.findByIds(ids);\n\n                assert.ok(res.has(docs[0].primary));\n                assert.strictEqual(res.size, 5);\n\n                c.database.destroy();\n            });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should find the documents when they are not in the docCache","suites":["rx-collection.test.ts","instance","negative"],"updatePoint":{"line":1910,"column":75},"line":1910,"code":"            it('should find the documents when they are not in the docCache', async () => {\n                const c = await humansCollection.create(5);\n                const docs = await c.find().exec();\n                const ids = docs.map(d => d.primary);\n\n                // clear docCache\n                ids.forEach(id => c._docCache.delete(id));\n\n                const res = await c.findByIds(ids);\n                assert.strictEqual(res.size, 5);\n                c.database.destroy();\n            });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should not crash and emit a map","suites":["rx-collection.test.ts","instance","negative"],"updatePoint":{"line":1925,"column":43},"line":1925,"code":"        it('should not crash and emit a map', async () => {\n            const c = await humansCollection.create(5);\n            const docs = await c.find().exec();\n            const ids = docs.map(d => d.primary);\n            const res = await firstValueFrom(c.findByIds$(ids));\n\n            assert.ok(res);\n            assert.ok(res instanceof Map);\n\n            c.database.destroy();\n        });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should emit the correct initial values","suites":["rx-collection.test.ts","instance","negative"],"updatePoint":{"line":1936,"column":50},"line":1936,"code":"        it('should emit the correct initial values', async () => {\n            const c = await humansCollection.create(5);\n\n            const docs = await c.find().exec();\n            const ids = docs.map(d => d.primary);\n            const res = await firstValueFrom(c.findByIds$(ids));\n\n            assert.ok(res.has(docs[0].primary));\n            assert.strictEqual(res.size, 5);\n\n            c.database.destroy();\n        });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"should merge the insert/update/delete event correctly","suites":["rx-collection.test.ts","instance","negative"],"updatePoint":{"line":1948,"column":65},"line":1948,"code":"        it('should merge the insert/update/delete event correctly', async () => {\n            const c = await humansCollection.createPrimary(5);\n            const docs = await c.find().exec();\n            const ids = docs.map(d => d.primary);\n            ids.push('foobar');\n            const obs = c.findByIds$(ids);\n            await firstValueFrom(obs);\n\n            // check insert\n            const addData = schemaObjects.human();\n            addData.passportId = 'foobar';\n            await c.insert(addData);\n            // insert whose id is not in ids-list should not affect anything\n            await c.insert(schemaObjects.human());\n\n            const res2 = await firstValueFrom(obs);\n            assert.strictEqual(res2.size, 6);\n            assert.ok(res2.has('foobar'));\n\n            // check update\n            addData.firstName = 'barfoo';\n            await c.upsert(addData);\n            const res3 = await firstValueFrom(obs);\n            const getDoc = res3.get('foobar');\n            assert.ok(getDoc);\n            assert.strictEqual(getDoc.firstName, 'barfoo');\n\n            // check delete\n            await getDoc.remove();\n            const res4 = await firstValueFrom(obs);\n            assert.strictEqual(false, res4.has('foobar'));\n\n            c.database.destroy();\n        });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"#528  default value ignored when 0","suites":["rx-collection.test.ts","issues"],"updatePoint":{"line":1985,"column":46},"line":1985,"code":"        it('#528  default value ignored when 0', async () => {\n            const schema = {\n                version: 0,\n                primaryKey: 'passportId',\n                type: 'object',\n                properties: {\n                    passportId: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    weight: {\n                        type: 'number',\n                        default: 0\n                    }\n                }\n            };\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage()\n            });\n            const collections = await db.addCollections({\n                humanx: {\n                    schema\n                }\n            });\n            const collection = collections.humanx;\n            const doc = await collection.insert({\n                passportId: randomCouchString(10)\n            });\n            assert.strictEqual(doc.weight, 0);\n            db.destroy();\n        });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"#596 Default value not applied when value is undefined","suites":["rx-collection.test.ts","issues"],"updatePoint":{"line":2017,"column":66},"line":2017,"code":"        it('#596 Default value not applied when value is undefined', async () => {\n            const schema = {\n                version: 0,\n                primaryKey: 'passportId',\n                type: 'object',\n                properties: {\n                    passportId: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    firstName: {\n                        type: 'string'\n                    },\n                    lastName: {\n                        type: 'string'\n                    },\n                    age: {\n                        type: 'integer',\n                        minimum: 0,\n                        maximum: 150\n                    },\n                    score: {\n                        type: 'integer',\n                        default: 100\n                    }\n                }\n            };\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage()\n            });\n            const collections = await db.addCollections({\n                humanx: {\n                    schema\n                }\n            });\n            const collection = collections.humanx;\n\n            // insert a document\n            await collection.insert({\n                passportId: 'foobar',\n                firstName: 'Bob',\n                lastName: 'Kelso',\n                age: 56,\n                score: undefined\n            });\n            const myDocument = await collection\n                .findOne()\n                .where('firstName')\n                .eq('Bob')\n                .exec();\n            assert.strictEqual(myDocument.score, 100);\n            db.destroy();\n        });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"auto_compaction not works on collection-level https://gitter.im/pubkey/rxdb?at=5c42f3dd0721b912a5a4366b","suites":["rx-collection.test.ts","issues"],"updatePoint":{"line":2071,"column":115},"line":2071,"code":"        it('auto_compaction not works on collection-level https://gitter.im/pubkey/rxdb?at=5c42f3dd0721b912a5a4366b', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory')\n            });\n\n            // test with auto_compaction\n            const collections = await db.addCollections({\n                human_compact: {\n                    schema: schemas.primaryHuman,\n                    instanceCreationOptions: {\n                        auto_compaction: true\n                    }\n                }\n            });\n            const collection = collections.human_compact;\n            assert.ok(collection.storageInstance.internals.pouch.auto_compaction);\n            db.destroy();\n        });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"#939 creating a collection mutates the given parameters-object","suites":["rx-collection.test.ts","issues"],"updatePoint":{"line":2090,"column":74},"line":2090,"code":"        it('#939 creating a collection mutates the given parameters-object', async () => {\n            const schema = {\n                version: 0,\n                primaryKey: 'passportId',\n                type: 'object',\n                properties: {\n                    passportId: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    weight: {\n                        type: 'number',\n                        default: 0\n                    }\n                }\n            };\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage()\n            });\n\n            const collectionParams = {\n                schema,\n                methods: {\n                    foo() {\n                        return 'bar';\n                    }\n                },\n                statics: {\n                    foo2() {\n                        return 'bar2';\n                    }\n                }\n            };\n            const cloned = clone(collectionParams);\n            await db.addCollections({\n                humans: collectionParams\n            });\n            assert.deepStrictEqual(Object.keys(cloned), Object.keys(collectionParams));\n            assert.deepStrictEqual(cloned, collectionParams);\n\n            await db.destroy();\n\n            // recreating with the same params-object should work\n            const db2 = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage(),\n            });\n            await db2.addCollections({\n                humans: collectionParams\n            });\n            assert.deepStrictEqual(cloned, collectionParams);\n\n            db2.destroy();\n        });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"#3661 .findByIds$() fires too often","suites":["rx-collection.test.ts","issues"],"updatePoint":{"line":2145,"column":47},"line":2145,"code":"        it('#3661 .findByIds$() fires too often', async () => {\n            const collection = await humansCollection.create(0);\n\n            //  Record subscription\n            const emitted: Map<string, RxDocumentData<HumanDocumentType>>[] = [];\n\n            function createObject(id: string): RxDocumentData<HumanDocumentType> {\n                const ret: RxDocumentData<HumanDocumentType> = Object.assign(\n                    schemaObjects.human(),\n                    {\n                        passportId: id,\n                        _deleted: false,\n                        _attachments: {},\n                        _meta: {\n                            lwt: now()\n                        },\n                        _rev: '1-51b2fae5721cc4d3cf7392f19e6cc118'\n                    }\n                );\n                return ret;\n            }\n\n            const matchingIds = ['a', 'b', 'c', 'd'];\n\n            const sub = collection.findByIds$(matchingIds).subscribe(data => {\n\n                const m = new Map();\n                Array\n                    .from(data.entries())\n                    .forEach(([id, doc]) => {\n                        m.set(id, doc.toJSON(true));\n                    });\n                emitted.push(m);\n            });\n\n            //  test we have a map and no error\n            await AsyncTestUtil.waitUntil(() => emitted.length > 0);\n            await AsyncTestUtil.wait(100);\n\n            /**\n             * Should have emitted exactly once with an empty map\n             * because we have no document at all in the storage.\n             */\n            assert.strictEqual(emitted.length, 1);\n\n            /**\n             * Non-existing documents should not be in the map at all\n             * (also not with undefined value)\n             */\n            assert.strictEqual(emitted[0].size, 0);\n\n\n            //  Simulate a write from a primitive replication\n            await collection.storageInstance.bulkWrite(\n                matchingIds\n                    .map(id => {\n                        const saveMe = createObject(id);\n                        return {\n                            document: saveMe\n                        };\n                    }),\n                'collection-test'\n            );\n\n            // Now we should have more updates and at some point all documents\n            // are in the result set.\n            await AsyncTestUtil.waitUntil(() => lastOfArray(emitted).size === matchingIds.length);\n\n            // wait a bit more\n            await AsyncTestUtil.wait(config.isFastMode() ? 50 : 150);\n            assert.strictEqual(lastOfArray(emitted).size, matchingIds.length);\n\n\n            /**\n             * Each emitted result must have a different result set\n             * because findByIds$ must only emit when data has actually changed.\n             * We cannot just cound the updates.length here because some RxStorage implementations\n             * might return multiple RxChangeEventBulks for a single bulkWrite() operation\n             * or do additional writes. So we have to check for the revisions+docId strings.\n             */\n            const resultIds = new Set<string>();\n            emitted.forEach(oneResult => {\n                let resultId = '';\n                Array.from(oneResult.entries()).forEach(([docId, docData]) => {\n                    resultId += docId + '|' + docData._rev + '-';\n                });\n                if (resultIds.has(resultId)) {\n                    throw new Error('duplicate result ' + resultId);\n                } else {\n                    resultIds.add(resultId);\n                }\n            });\n\n            // should have the same result set as running findByIds() once.\n            const singleQueryDocs = await collection.findByIds(matchingIds);\n\n            const singleResultPlain = matchingIds.map(id => getFromMapOrThrow(singleQueryDocs, id).toJSON(true))\n            const observedResultPlain = matchingIds.map(id => getFromMapOrThrow(lastOfArray(emitted), id))\n            assert.deepStrictEqual(singleResultPlain, observedResultPlain);\n\n            //  And contains the right data\n            const lastEmit = lastOfArray(emitted);\n            assert.strictEqual(lastEmit.get('a')?.passportId, 'a');\n            assert.strictEqual(lastEmit.get('b')?.passportId, 'b');\n            assert.strictEqual(lastEmit.get('c')?.passportId, 'c');\n            assert.strictEqual(lastEmit.get('d')?.passportId, 'd');\n\n            //  Let's try to update something different that should be ignored\n            const sizeBeforeRandomInserts = lastOfArray(emitted).size;\n            await collection.storageInstance.bulkWrite(\n                [\n                    createObject('e'),\n                    createObject('f'),\n                    createObject('g'),\n                    createObject('h')\n                ].map(document => ({ document })),\n                'collection-test'\n            );\n\n            //  Wait a bit to see if we catch anything\n            await wait(config.isFastMode() ? 100 : 300);\n            const sizeAfterRandomInserts = lastOfArray(emitted).size;\n\n            //  Verify that the subscription has not been triggered and no error has been added\n            assert.strictEqual(sizeBeforeRandomInserts, sizeAfterRandomInserts);\n\n            // clean up afterwards\n            sub.unsubscribe();\n            collection.database.destroy();\n        });","file":"unit/rx-collection.test.ts","skipped":false,"dir":"test"},{"name":"normal","suites":[".create()","positive"],"updatePoint":{"line":30,"column":22},"line":30,"code":"            it('normal', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                assert.ok(isRxDatabase(db));\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"with password","suites":[".create()","positive"],"updatePoint":{"line":38,"column":29},"line":38,"code":"            it('with password', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    password: randomCouchString(12)\n                });\n                assert.ok(isRxDatabase(db));\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"2 instances on same adapter (if ignoreDuplicate is true)","suites":[".create()","positive"],"updatePoint":{"line":47,"column":72},"line":47,"code":"            it('2 instances on same adapter (if ignoreDuplicate is true)', async () => {\n                const name = randomCouchString(10);\n                const db = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n\n                assert.strictEqual(\n                    await isRxDatabaseFirstTimeInstantiated(db),\n                    true\n                );\n\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n\n                assert.notStrictEqual(\n                    db.token,\n                    db2.token\n                );\n\n                if (config.storage.hasMultiInstance) {\n                    assert.strictEqual(\n                        await isRxDatabaseFirstTimeInstantiated(db2),\n                        false\n                    );\n                }\n\n                db.destroy();\n                db2.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"2 instances on same adapter -> ignoreDuplicate is false but first db gets destroyed","suites":[".create()","positive"],"updatePoint":{"line":81,"column":99},"line":81,"code":"            it('2 instances on same adapter -> ignoreDuplicate is false but first db gets destroyed', async () => {\n                const name = randomCouchString(10);\n                const db = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage()\n                });\n                await db.destroy();\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage()\n                });\n                db2.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"2 password-instances on same adapter","suites":[".create()","positive"],"updatePoint":{"line":94,"column":52},"line":94,"code":"            it('2 password-instances on same adapter', async () => {\n                if (\n                    config.storage.name === 'lokijs'\n                ) {\n                    /**\n                     * TODO on lokijs this test somehow fails\n                     * to properly clean up the open broadcast channels.\n                     */\n                    return;\n                }\n                const name = randomCouchString(10);\n                const password = randomCouchString(12);\n                const db = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    password,\n                    ignoreDuplicate: true\n                });\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    password,\n                    ignoreDuplicate: true\n                });\n                db.destroy();\n                db2.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should not forget the options","suites":[".create()","positive"],"updatePoint":{"line":121,"column":45},"line":121,"code":"            it('should not forget the options', async () => {\n                const name = randomCouchString(10);\n                const password = randomCouchString(12);\n                const db = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    password,\n                    ignoreDuplicate: true,\n                    options: {\n                        foo: 'bar'\n                    }\n                });\n                assert.strictEqual(db.options.foo, 'bar');\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should not forget the instanceCreationOptions","suites":[".create()","positive"],"updatePoint":{"line":136,"column":61},"line":136,"code":"            it('should not forget the instanceCreationOptions', async () => {\n                const name = randomCouchString(10);\n                const password = randomCouchString(12);\n                const db = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    instanceCreationOptions: {\n                        ajax: 'bar'\n                    },\n                    password,\n                    ignoreDuplicate: true\n                });\n                assert.strictEqual(db.internalStore.options.ajax, 'bar');\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should respect the given hashFunction","suites":[".create()","positive"],"updatePoint":{"line":151,"column":53},"line":151,"code":"            it('should respect the given hashFunction', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage(),\n                    hashFunction(i: string) {\n                        return fastUnsecureHash(i) + 'xxx';\n                    }\n                });\n\n                const cols = await db.addCollections({\n                    human: {\n                        schema: schemas.human\n                    }\n                });\n                const collection: RxCollection<schemas.HumanDocumentType> = cols.human;\n                const doc = await collection.insert(schemaObjects.human());\n                const rev = doc.toJSON(true)._rev;\n                assert.ok(rev.endsWith('xxx'));\n\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should crash with invalid token","suites":[".create()","negative"],"updatePoint":{"line":174,"column":47},"line":174,"code":"            it('should crash with invalid token', async () => {\n                await AsyncTestUtil.assertThrows(\n                    () => createRxDatabase({\n                        name: null,\n                        storage: config.storage.getStorage(),\n                    } as any),\n                    'RxTypeError',\n                    'null'\n                );\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should crash with and ending slash","suites":[".create()","negative"],"updatePoint":{"line":184,"column":50},"line":184,"code":"            it('should crash with and ending slash', async () => {\n                await AsyncTestUtil.assertThrows(\n                    () => createRxDatabase({\n                        name: '/foo/bar/',\n                        storage: config.storage.getStorage(),\n                    } as any),\n                    'RxError',\n                    'ending'\n                );\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"do not allow 2 databases with same name and adapter","suites":[".create()","negative"],"updatePoint":{"line":194,"column":67},"line":194,"code":"            it('do not allow 2 databases with same name and adapter', async () => {\n                const name = randomCouchString(10);\n                const db = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage()\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => createRxDatabase({\n                        name,\n                        storage: config.storage.getStorage()\n                    }),\n                    'RxError',\n                    'ignoreDuplicate'\n                );\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"human","suites":[".addCollections()","positive"],"updatePoint":{"line":214,"column":21},"line":214,"code":"            it('human', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                const collections = await db.addCollections({\n                    human0: {\n                        schema: schemas.human\n                    }\n                });\n                const collection = collections.human0;\n                assert.ok(isRxCollection(collection));\n\n                // make sure defineGetter works\n                assert.strictEqual(db.human0, collection);\n\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"the schema-object should be saved in the internal storage instance","suites":[".addCollections()","positive"],"updatePoint":{"line":232,"column":82},"line":232,"code":"            it('the schema-object should be saved in the internal storage instance', async () => {\n                if (config.storage.name !== 'pouchdb') {\n                    return;\n                }\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                await db.addCollections({\n                    human0: {\n                        schema: schemas.human\n                    }\n                });\n                // TODO check storage instance instead of pouchdb\n                const colDoc = await (db.internalStore.internals.pouch as any).get('collection|human0-' + schemas.human.version);\n                const compareSchema = createRxSchema(schemas.human);\n                assert.deepStrictEqual(compareSchema.jsonSchema, colDoc.data.schema);\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"collectionsCollection should contain schema.version","suites":[".addCollections()","positive"],"updatePoint":{"line":251,"column":67},"line":251,"code":"            it('collectionsCollection should contain schema.version', async () => {\n                if (config.storage.name !== 'pouchdb') {\n                    return;\n                }\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                const collections = await db.addCollections({\n                    human: {\n                        schema: schemas.human\n                    }\n                });\n                const collection = collections.human;\n                const version = collection.schema.version;\n                assert.deepStrictEqual(version, 0);\n                // TODO check storage instance instead of pouchdb\n                const internalDoc = await (db.internalStore.internals.pouch as any).get('collection|human-' + version);\n                assert.deepStrictEqual(internalDoc.data.version, version);\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"create 2 times on same adapter","suites":[".addCollections()","positive"],"updatePoint":{"line":272,"column":46},"line":272,"code":"            it('create 2 times on same adapter', async () => {\n                const name = randomCouchString(10);\n                const collectionName = 'foobar';\n                const db1 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n                await db1.addCollections({\n                    [collectionName]: {\n                        schema: schemas.human\n                    }\n                });\n                await db2.addCollections({\n                    [collectionName]: {\n                        schema: schemas.human\n                    }\n                });\n                db1.destroy();\n                db2.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should not do a write to the internalStore when creating a previous existing collection","suites":[".addCollections()","positive"],"updatePoint":{"line":298,"column":103},"line":298,"code":"            it('should not do a write to the internalStore when creating a previous existing collection', async () => {\n                const name = randomCouchString(10);\n                const collectionName = 'foobar';\n                const db1 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n                await db1.addCollections({\n                    [collectionName]: {\n                        schema: schemas.human\n                    }\n                });\n\n                async function getStoreDocs(db: RxDatabase) {\n                    const result = await db.internalStore.query(\n                        db.storage.statics.prepareQuery(\n                            db.internalStore.schema,\n                            {\n                                selector: {\n                                    context: 'collection'\n                                },\n                                sort: [{ id: 'asc' }],\n                                skip: 0\n                            }\n                        )\n                    );\n                    return result.documents;\n                }\n                const storeDocsBefore = await getStoreDocs(db1);\n                await db1.destroy();\n\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n\n                await db2.addCollections({\n                    [collectionName]: {\n                        schema: schemas.human\n                    }\n                });\n\n                const storeDocsAfter = await getStoreDocs(db2);\n\n                /**\n                 * Revision must still be the same as before\n                 * because no write happened.\n                 */\n                assert.strictEqual(\n                    storeDocsBefore[0]._rev,\n                    storeDocsAfter[0]._rev\n                );\n\n                await db2.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"broken schema (nostringIndex)","suites":[".addCollections()","negative"],"updatePoint":{"line":357,"column":45},"line":357,"code":"            it('broken schema (nostringIndex)', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        human6: {\n                            schema: schemas.noStringIndex\n                        }\n                    }),\n                    'RxError'\n                );\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"call 2 times on same name","suites":[".addCollections()","negative"],"updatePoint":{"line":372,"column":41},"line":372,"code":"            it('call 2 times on same name', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                await db.addCollections({\n                    human2: {\n                        schema: schemas.human\n                    }\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        human2: {\n                            schema: schemas.human\n                        }\n                    }),\n                    'RxError'\n                );\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"crypt-schema without db-password","suites":[".addCollections()","negative"],"updatePoint":{"line":392,"column":48},"line":392,"code":"            it('crypt-schema without db-password', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                let hasThrown = false;\n                try {\n                    await db.addCollections({\n                        human7: {\n                            schema: schemas.encryptedHuman\n                        }\n                    });\n                } catch (err) {\n                    hasThrown = true;\n                }\n                assert.ok(hasThrown);\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"2 different schemas on same collection","suites":[".addCollections()","negative"],"updatePoint":{"line":410,"column":54},"line":410,"code":"            it('2 different schemas on same collection', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                const cols = await db.addCollections({\n                    human8: {\n                        schema: schemas.human\n                    }\n                });\n                await cols.human8.insert(schemaObjects.human());\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        human8: {\n                            schema: schemas.bigHuman\n                        }\n                    }),\n                    'RxError',\n                    'already exists'\n                );\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"not allow collectionNames starting with lodash","suites":[".addCollections()","negative"],"updatePoint":{"line":432,"column":62},"line":432,"code":"            it('not allow collectionNames starting with lodash', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                await AsyncTestUtil.assertThrows(\n                    () => db.addCollections({\n                        _test: {\n                            schema: schemas.human\n                        }\n                    }),\n                    'RxError',\n                    'UT2'\n                );\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"not allow collectionNames which are properties of RxDatabase","suites":[".addCollections()","negative"],"updatePoint":{"line":448,"column":76},"line":448,"code":"            it('not allow collectionNames which are properties of RxDatabase', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                const forbidden = [\n                    'name',\n                    'token',\n                    'isLeader',\n                    '$emit',\n                    'destroy'\n                ];\n                let t = 0;\n                while (t < forbidden.length) {\n                    const colName = forbidden[t];\n                    await AsyncTestUtil.assertThrows(\n                        () => db.addCollections({\n                            [colName]: {\n                                schema: schemas.human\n                            }\n                        }),\n                        'RxError',\n                        'not allowed'\n                    );\n                    t++;\n                }\n                db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"create 2 times on same adapter with different schema","suites":[".addCollections()","negative"],"updatePoint":{"line":476,"column":68},"line":476,"code":"            it('create 2 times on same adapter with different schema', async () => {\n                if (!config.storage.hasMultiInstance) {\n                    return;\n                }\n                if (config.storage.name === 'lokijs') {\n                    // TODO\n                    return;\n                }\n                const name = randomCouchString(10);\n                const collectionName = 'foobar';\n                const db1 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n                const db2 = await createRxDatabase({\n                    name,\n                    storage: config.storage.getStorage(),\n                    ignoreDuplicate: true\n                });\n                const col1 = await db1.addCollections({\n                    [collectionName]: {\n                        schema: schemas.human\n                    }\n                });\n                await col1[collectionName].insert(schemaObjects.human());\n                await AsyncTestUtil.assertThrows(\n                    () => db2.addCollections({\n                        [collectionName]: {\n                            schema: schemas.bigHuman\n                        }\n                    }),\n                    'RxError',\n                    'different'\n                );\n                db1.destroy();\n                db2.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should not crash on destroy","suites":[".destroy()","positive"],"updatePoint":{"line":518,"column":43},"line":518,"code":"            it('should not crash on destroy', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                await db.addCollections({\n                    foobar: {\n                        schema: schemas.human\n                    }\n                });\n                await db.destroy();\n                assert.strictEqual(db.destroyed, true);\n                await db.destroy();\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should not crash if destroy is called twice","suites":[".destroy()","positive"],"updatePoint":{"line":532,"column":59},"line":532,"code":"            it('should not crash if destroy is called twice', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: config.storage.getStorage()\n                });\n                await db.addCollections({\n                    foobar: {\n                        schema: schemas.human\n                    }\n                });\n                await db.destroy();\n                await db.destroy();\n                assert.strictEqual(db.destroyed, true);\n            });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should not crash","suites":[".remove()"],"updatePoint":{"line":549,"column":28},"line":549,"code":"        it('should not crash', async () => {\n            const c = await humansCollection.create(10);\n            await c.database.remove();\n        });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should be possible to recreate the database with other password","suites":[".remove()"],"updatePoint":{"line":553,"column":75},"line":553,"code":"        it('should be possible to recreate the database with other password', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                password: 'fo222222obar'\n            });\n            await db.remove();\n\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                password: 'foo2222333333bar2'\n            });\n            await db2.remove();\n        });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should have deleted the local documents","suites":[".remove()"],"updatePoint":{"line":569,"column":51},"line":569,"code":"        it('should have deleted the local documents', async () => {\n            const name = randomCouchString(10);\n            const db = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                localDocuments: true\n            });\n\n            const id = 'foobar';\n            await db.insertLocal(id, { foo: 'bar' });\n\n            await db.remove();\n\n            const db2 = await createRxDatabase({\n                name,\n                storage: config.storage.getStorage(),\n                localDocuments: true\n            });\n\n            const hasLocal = await db2.getLocal(id);\n            assert.strictEqual(hasLocal, null);\n\n            await db2.remove();\n        });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"#677 wrong pouch-location when path as collection-name","suites":["ISSUES"],"updatePoint":{"line":595,"column":66},"line":595,"code":"        it('#677 wrong pouch-location when path as collection-name', () => {\n            const pouchPathNormal = getPouchLocation(\n                'mydb',\n                'humans',\n                5\n            );\n            assert.strictEqual(pouchPathNormal, 'mydb-rxdb-5-humans');\n\n            const pouchPath = getPouchLocation(\n                'mydb',\n                'subfolder/humans',\n                5\n            );\n            assert.strictEqual(pouchPath, 'subfolder/mydb-rxdb-5-humans');\n        });","file":"unit/rx-database.test.ts","skipped":false,"dir":"test"},{"name":"should get an object with all main-fields","suites":["rx-document.test.js","RxSchema.getDocumentPrototype()"],"updatePoint":{"line":35,"column":57},"line":35,"code":"            it('should get an object with all main-fields', () => {\n                const schema = createRxSchema(schemas.human);\n                assert.ok(schema);\n                const proto = schema.getDocumentPrototype();\n                assert.ok(proto);\n                const testObjData: any = schemaObjects.human();\n                const testObj: any = {\n                    get(path: string) {\n                        return testObjData[path];\n                    },\n                    get$(path: string) {\n                        return 'Observable:' + path;\n                    },\n                    populate(path: string) {\n                        return 'Promise:' + path;\n                    },\n                    set(path: string, val: any) {\n                        testObjData[path] = val;\n                    }\n                };\n                Object.setPrototypeOf(\n                    testObj,\n                    proto\n                );\n\n                assert.strictEqual(testObj['passportId'], testObjData.passportId);\n                Object.keys(testObjData).forEach(k => {\n                    assert.strictEqual(testObj[k], testObjData[k]); // getter attribute\n                    assert.strictEqual(testObj[k + '$'], 'Observable:' + k); // getter observable\n                    assert.strictEqual(testObj[k + '_'], 'Promise:' + k); // getter populate\n                    // test setter\n                    testObj[k] = 'foo';\n                    assert.strictEqual(testObjData[k], 'foo');\n                });\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should get a prototype with all orm-methods","suites":["rx-document.test.js","RxCollection.getDocumentOrmPrototype()"],"updatePoint":{"line":72,"column":59},"line":72,"code":"            it('should get a prototype with all orm-methods', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.humanFinal,\n                        methods: {\n                            foo() {\n                                return 'bar';\n                            }\n                        }\n                    }\n                });\n\n                const proto = getDocumentOrmPrototype(cols.humans);\n                const testObj: any = {};\n                Object.setPrototypeOf(\n                    testObj,\n                    proto\n                );\n                assert.strictEqual(testObj['foo'](), 'bar');\n\n                db.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should get a valid prototype","suites":["rx-document.test.js","RxCollection.getDocumentPrototype()"],"updatePoint":{"line":100,"column":44},"line":100,"code":"            it('should get a valid prototype', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.human,\n                        methods: {\n                            foo() {\n                                return 'bar';\n                            }\n                        }\n                    }\n                });\n                const proto = getDocumentPrototype(cols.humans);\n\n                assert.strictEqual(typeof proto.remove, 'function'); // from baseProto\n                assert.strictEqual(proto.foo(), 'bar'); // from orm-proto\n\n                db.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"get a value","suites":["rx-document.test.js","RxCollection.getDocumentPrototype()"],"updatePoint":{"line":126,"column":23},"line":126,"code":"        it('get a value', async () => {\n            const c = await humansCollection.create(1);\n            const doc: any = await c.findOne().exec(true);\n            const value = doc.get('passportId');\n            assert.strictEqual(typeof value, 'string');\n            c.database.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"get a nested value","suites":["rx-document.test.js","RxCollection.getDocumentPrototype()"],"updatePoint":{"line":133,"column":30},"line":133,"code":"        it('get a nested value', async () => {\n            const c = await humansCollection.createNested(5);\n            const doc = await c.findOne().exec(true);\n            const value = doc.get('mainSkill.name');\n            assert.strictEqual(typeof value, 'string');\n            const value2 = doc.get('mainSkill.level');\n            assert.strictEqual(typeof value2, 'number');\n            c.database.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"get undefined on undefined value","suites":["rx-document.test.js","RxCollection.getDocumentPrototype()"],"updatePoint":{"line":142,"column":44},"line":142,"code":"        it('get undefined on undefined value', async () => {\n            const c = await humansCollection.createNested(5);\n            const doc = await c.findOne().exec(true);\n            const value = doc.get('foobar');\n            assert.strictEqual(value, undefined);\n            c.database.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"delete 1 document","suites":["rx-document.test.js","positive"],"updatePoint":{"line":152,"column":33},"line":152,"code":"            it('delete 1 document', async () => {\n                const c = await humansCollection.create(5);\n                const docs = await c.find().exec();\n                assert.ok(docs.length > 1);\n                const first = docs[0];\n                await first.remove();\n                const docsAfter = await c.find().exec();\n                docsAfter.map(doc => {\n                    if (doc._data.passportId === first._data.passportId)\n                        throw new Error('still here after remove()');\n                });\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should remove all revisions","suites":["rx-document.test.js","positive"],"updatePoint":{"line":165,"column":43},"line":165,"code":"            it('should remove all revisions', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec();\n                assert.ok(doc);\n\n                // update some times to generate revisions\n                await doc.atomicUpdate((docData: any) => {\n                    docData.age++;\n                    return docData;\n                });\n                await doc.atomicUpdate((docData: any) => {\n                    docData.age++;\n                    return docData;\n                });\n                await doc.atomicUpdate((docData: any) => {\n                    docData.age = 100;\n                    return docData;\n                });\n                const doc2: any = await c.findOne().exec();\n                assert.strictEqual(doc2.age, 100);\n\n                await doc2.remove();\n                const doc3 = await c.findOne().exec();\n                assert.strictEqual(doc3, null);\n\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"delete all in parrallel","suites":["rx-document.test.js","positive"],"updatePoint":{"line":192,"column":39},"line":192,"code":"            it('delete all in parrallel', async () => {\n                const c = await humansCollection.create(5);\n                const docs = await c.find().exec();\n                const fns: any[] = [];\n                docs.map(doc => fns.push(doc.remove()));\n                await Promise.all(fns);\n                const docsAfter = await c.find().exec();\n                assert.strictEqual(docsAfter.length, 0);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"save and then remove","suites":["rx-document.test.js","positive"],"updatePoint":{"line":202,"column":36},"line":202,"code":"            it('save and then remove', async () => {\n                const c = await humansCollection.create(5);\n                const docs = await c.find().exec();\n                assert.ok(docs.length > 1);\n                const first = docs[0];\n\n                await first.atomicPatch({ firstName: 'foobar' });\n\n                await first.remove();\n                const docsAfter = await c.find().exec();\n                docsAfter.map(doc => {\n                    if (doc._data.passportId === first._data.passportId)\n                        throw new Error('still here after remove()');\n                });\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"delete doc twice","suites":["rx-document.test.js","negative"],"updatePoint":{"line":220,"column":32},"line":220,"code":"            it('delete doc twice', async () => {\n                const c = await humansCollection.create(5);\n                const doc: any = await c.findOne().exec();\n                await doc.remove();\n                await AsyncTestUtil.assertThrows(\n                    () => doc.remove(),\n                    'RxError',\n                    'already'\n                );\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"$set a value with a mongo like query","suites":["rx-document.test.js","positive"],"updatePoint":{"line":235,"column":52},"line":235,"code":"            it('$set a value with a mongo like query', async () => {\n                const c = await humansCollection.createPrimary(1);\n                const doc: any = await c.findOne().exec(true);\n                await doc.update({\n                    $set: {\n                        firstName: 'new first name'\n                    }\n                });\n                const updatedDoc = await c.findOne({\n                    selector: {\n                        firstName: 'new first name'\n                    }\n                }).exec(true);\n                assert.strictEqual(updatedDoc.firstName, 'new first name');\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"$unset a value with a mongo like query","suites":["rx-document.test.js","positive"],"updatePoint":{"line":251,"column":54},"line":251,"code":"            it('$unset a value with a mongo like query', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec(true);\n                await doc.update({\n                    $unset: {\n                        age: ''\n                    }\n                });\n                const updatedDoc: any = await c.findOne().exec(true);\n                assert.strictEqual(updatedDoc.age, undefined);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"$inc a value with a mongo like query","suites":["rx-document.test.js","positive"],"updatePoint":{"line":263,"column":52},"line":263,"code":"            it('$inc a value with a mongo like query', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec(true);\n                const agePrev = doc.age;\n                await doc.update({\n                    $inc: {\n                        age: 1\n                    }\n                });\n                assert.strictEqual(doc.age, agePrev + 1);\n                await doc.save;\n                const updatedDoc: any = await c.findOne().exec(true);\n                assert.strictEqual(updatedDoc.age, agePrev + 1);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should throw when final field is modified","suites":["rx-document.test.js","negative"],"updatePoint":{"line":280,"column":57},"line":280,"code":"            it('should throw when final field is modified', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.humanFinal,\n                        methods: {\n                            foo() {\n                                return 'bar';\n                            }\n                        }\n                    }\n                });\n                const docData = schemaObjects.human();\n                docData.age = 1;\n                const doc = await cols.humans.insert(docData);\n                await AsyncTestUtil.assertThrows(\n                    () => doc.update({\n                        $inc: {\n                            age: 1\n                        }\n                    }),\n                    'RxError',\n                    'final'\n                );\n                db.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"run one update","suites":["rx-document.test.js","positive"],"updatePoint":{"line":313,"column":30},"line":313,"code":"            it('run one update', async () => {\n                const c = await humansCollection.createNested(1);\n                const doc = await c.findOne().exec(true);\n\n                const returnedDoc = await doc.atomicUpdate((innerDoc: any) => {\n                    innerDoc.firstName = 'foobar';\n                    return innerDoc;\n                });\n                assert.strictEqual('foobar', doc.firstName);\n                assert.ok(doc === returnedDoc);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"run two updates (last write wins)","suites":["rx-document.test.js","positive"],"updatePoint":{"line":325,"column":49},"line":325,"code":"            it('run two updates (last write wins)', async () => {\n                const c = await humansCollection.createNested(1);\n                const doc = await c.findOne().exec(true);\n\n                doc.atomicUpdate((innerDoc: any) => {\n                    innerDoc.firstName = 'foobar';\n                    return innerDoc;\n                });\n                await doc.atomicUpdate((innerDoc: any) => {\n                    innerDoc.firstName = 'foobar2';\n                    return innerDoc;\n                });\n                assert.strictEqual('foobar2', doc.firstName);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"do many updates (last write wins)","suites":["rx-document.test.js","positive"],"updatePoint":{"line":340,"column":49},"line":340,"code":"            it('do many updates (last write wins)', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec(true);\n                let lastPromise;\n                let t = 0;\n                new Array(10).fill(0)\n                    .map(() => {\n                        t++;\n                        return t;\n                    })\n                    .forEach(x => lastPromise = doc.atomicUpdate((innerDoc: any) => {\n                        innerDoc.age = x;\n                        return innerDoc;\n                    }));\n                await lastPromise;\n                assert.strictEqual(t, doc.age);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"run async functions","suites":["rx-document.test.js","positive"],"updatePoint":{"line":358,"column":35},"line":358,"code":"            it('run async functions', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec();\n                let lastPromise;\n                let t = 0;\n                new Array(10).fill(0)\n                    .map(() => {\n                        t++;\n                        return t;\n                    })\n                    .forEach(x => lastPromise = doc.atomicUpdate(async (innerDoc: any) => {\n                        await promiseWait(1);\n                        innerDoc.age = x;\n                        return innerDoc;\n                    }));\n                await lastPromise;\n                assert.strictEqual(t, doc.age);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should work when inserting on a slow storage","suites":["rx-document.test.js","positive"],"updatePoint":{"line":377,"column":60},"line":377,"code":"            it('should work when inserting on a slow storage', async () => {\n                if (\n                    !config.platform.isNode() ||\n                    config.storage.name !== 'pouchdb'\n                ) {\n                    return;\n                }\n                // use a 'slow' adapter because memory might be to fast\n                const leveldown = require('leveldown');\n                const db = await createRxDatabase({\n                    name: config.rootPath + 'test_tmp/' + randomCouchString(10),\n                    storage: getRxStoragePouch(leveldown),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.primaryHuman\n                    }\n                });\n                const c = cols.humans;\n                await c.insert(schemaObjects.simpleHuman());\n                const doc = await c.findOne().exec();\n\n                doc.atomicUpdate((innerDoc: any) => {\n                    innerDoc.firstName = 'foobar';\n                    return innerDoc;\n                });\n\n                await doc.atomicUpdate((innerDoc: any) => {\n                    innerDoc.firstName = 'foobar2';\n                    return innerDoc;\n                });\n\n                await AsyncTestUtil.wait(50);\n\n                await doc.atomicUpdate((innerDoc: any) => {\n                    innerDoc.firstName = 'foobar3';\n                    return innerDoc;\n                });\n                assert.strictEqual('foobar3', doc.firstName);\n\n                db.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should be persistent when re-creating the database","suites":["rx-document.test.js","positive"],"updatePoint":{"line":419,"column":66},"line":419,"code":"            it('should be persistent when re-creating the database', async () => {\n                if (!config.platform.isNode()) return;\n                // use a 'slow' adapter because memory might be to fast\n                const leveldown = require('leveldown');\n\n                const dbName = config.rootPath + 'test_tmp/' + randomCouchString(10);\n                const db = await createRxDatabase({\n                    name: dbName,\n                    storage: getRxStoragePouch(leveldown),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.primaryHuman\n                    }\n                });\n                const c = cols.humans;\n                await c.insert(schemaObjects.simpleHuman());\n                const doc = await c.findOne().exec();\n                const docData = doc.toJSON();\n                assert.ok(docData);\n                await doc.atomicUpdate((innerDoc: any) => {\n                    innerDoc.firstName = 'foobar';\n                    return innerDoc;\n                });\n                assert.strictEqual(doc.firstName, 'foobar');\n                await db.destroy();\n\n                // same again\n                const db2 = await createRxDatabase({\n                    name: dbName,\n                    storage: getRxStoragePouch(leveldown),\n                });\n                const cols2 = await db2.addCollections({\n                    humans: {\n                        schema: schemas.primaryHuman\n                    }\n                });\n                const c2 = cols2.humans;\n                const doc2 = await c2.findOne().exec();\n                assert.strictEqual(doc.passportId, doc2.passportId);\n                const docData2 = doc2.toJSON();\n                assert.ok(docData2);\n                assert.strictEqual(doc2.firstName, 'foobar');\n                db2.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should retry on conflict errors","suites":["rx-document.test.js","positive"],"updatePoint":{"line":464,"column":47},"line":464,"code":"            it('should retry on conflict errors', async () => {\n                const dbName = randomCouchString(10);\n                const db = await createRxDatabase({\n                    name: dbName,\n                    storage: getRxStoragePouch('memory'),\n                });\n\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.primaryHuman\n                    }\n                });\n                const c = cols.humans;\n                const doc = await c.insert(schemaObjects.simpleHuman());\n                const db2 = await createRxDatabase({\n                    name: dbName,\n                    storage: getRxStoragePouch('memory'),\n                    ignoreDuplicate: true\n                });\n                const cols2 = await db2.addCollections({\n                    humans: {\n                        schema: schemas.primaryHuman\n                    }\n                });\n                const c2 = cols2.humans;\n                const doc2 = await c2.findOne().exec(true);\n\n                await Promise.all([\n                    doc.atomicUpdate((d: any) => {\n                        d.firstName = 'foobar1';\n                        return d;\n                    }),\n                    doc2.atomicUpdate((d: any) => {\n                        d.firstName = 'foobar2';\n                        return d;\n                    })\n                ]);\n\n                db.destroy();\n                db2.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should throw when final field is modified","suites":["rx-document.test.js","negative"],"updatePoint":{"line":507,"column":57},"line":507,"code":"            it('should throw when final field is modified', async () => {\n                const db = await createRxDatabase({\n                    name: randomCouchString(10),\n                    storage: getRxStoragePouch('memory'),\n                });\n                const cols = await db.addCollections({\n                    humans: {\n                        schema: schemas.humanFinal,\n                        methods: {\n                            foo() {\n                                return 'bar';\n                            }\n                        }\n                    }\n                });\n                const col = cols.humans;\n                const docData = schemaObjects.human();\n                docData.age = 1;\n                const doc = await col.insert(docData);\n\n                await AsyncTestUtil.assertThrows(\n                    () => doc.atomicUpdate((data: any) => {\n                        data.age = 100;\n                        return data;\n                    }),\n                    'RxError',\n                    'final'\n                );\n                db.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should still be useable if previous mutation function has thrown","suites":["rx-document.test.js","negative"],"updatePoint":{"line":537,"column":80},"line":537,"code":"            it('should still be useable if previous mutation function has thrown', async () => {\n                const col = await humansCollection.create(1);\n                const doc = await col.findOne().exec(true);\n\n                // non-async mutation\n                try {\n                    await doc.atomicUpdate(() => {\n                        throw new Error('throws intentional A');\n                    });\n                } catch (err) { }\n\n                // async mutation\n                try {\n                    await doc.atomicUpdate(async () => {\n                        await wait(10);\n                        throw new Error('throws intentional B');\n                    });\n                } catch (err) { }\n\n                // non throwing mutation\n                await doc.atomicUpdate(d => {\n                    d.age = 150;\n                    return d;\n                });\n\n                assert.strictEqual(doc.age, 150);\n                col.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"run one update","suites":["rx-document.test.js","positive"],"updatePoint":{"line":569,"column":30},"line":569,"code":"            it('run one update', async () => {\n                const c = await humansCollection.createNested(1);\n                const doc = await c.findOne().exec(true);\n\n                const returnedDoc = await doc.atomicPatch({\n                    firstName: 'foobar'\n                });\n                assert.strictEqual('foobar', doc.firstName);\n                assert.ok(doc === returnedDoc);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"unset optional property by assigning undefined","suites":["rx-document.test.js","positive"],"updatePoint":{"line":580,"column":62},"line":580,"code":"            it('unset optional property by assigning undefined', async () => {\n                const c = await humansCollection.createNested(1);\n                const doc = await c.findOne().exec(true);\n\n                assert.ok(doc.mainSkill);\n\n                await doc.atomicPatch({\n                    mainSkill: undefined\n                });\n\n                assert.strictEqual(doc.mainSkill, undefined);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should get the documents data as json","suites":["rx-document.test.js","positive"],"updatePoint":{"line":596,"column":49},"line":596,"code":"        it('should get the documents data as json', async () => {\n            const c = await humansCollection.create(1);\n            const doc: any = await c.findOne().exec();\n            const json = doc.toJSON(true);\n\n            assert.ok(json.passportId);\n            assert.ok(json.firstName);\n            assert.ok(json._rev); // when toJSON(true), the _rev field is also returned\n            c.database.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should get a fresh object each time","suites":["rx-document.test.js","positive"],"updatePoint":{"line":606,"column":47},"line":606,"code":"        it('should get a fresh object each time', async () => {\n            const c = await humansCollection.create(1);\n            const doc = await c.findOne().exec(true);\n            const json = doc.toJSON();\n            const json2 = doc.toJSON();\n            assert.ok(json !== json2);\n            c.database.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should not return meta fields if not wanted","suites":["rx-document.test.js","positive"],"updatePoint":{"line":614,"column":55},"line":614,"code":"        it('should not return meta fields if not wanted', async () => {\n            const c = await humansCollection.create(0);\n            await c.insert({\n                passportId: 'aatspywninca',\n                firstName: 'Tester',\n                lastName: 'Test',\n                age: 10\n            });\n            const newHuman = await c.findOne('aatspywninca').exec(true);\n            const jsonWithWithoutMetaFields = newHuman.toJSON();\n\n            const metaField = Object.keys(jsonWithWithoutMetaFields).find(key => key.startsWith('_'));\n            if (metaField) {\n                throw new Error('should not contain meta field ' + metaField);\n            }\n\n            c.database.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should not return _attachments if not wanted","suites":["rx-document.test.js","positive"],"updatePoint":{"line":632,"column":56},"line":632,"code":"        it('should not return _attachments if not wanted', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n                multiInstance: false,\n                ignoreDuplicate: true\n            });\n            const schemaJson = AsyncTestUtil.clone(schemas.human);\n            schemaJson.attachments = {};\n            const cols = await db.addCollections({\n                humans: {\n                    schema: schemaJson\n                }\n            });\n            const c = cols.humans;\n\n            const doc = await c.insert(schemaObjects.human());\n            await doc.putAttachment({\n                id: 'sampledata',\n                data: blobBufferUtil.createBlobBuffer('foo bar', 'application/octet-stream'),\n                type: 'application/octet-stream'\n            });\n\n            const withMeta = doc.toJSON(true);\n            assert.ok(withMeta._rev);\n            assert.ok(withMeta._attachments);\n\n            const withoutMeta = doc.toJSON(false);\n            assert.strictEqual(typeof withoutMeta._rev, 'undefined');\n            assert.strictEqual(typeof withoutMeta._attachments, 'undefined');\n\n            db.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should be able to mutate the output","suites":["rx-document.test.js","positive"],"updatePoint":{"line":667,"column":47},"line":667,"code":"        it('should be able to mutate the output', async () => {\n            const c = await humansCollection.create(1);\n            const doc = await c.findOne().exec(true);\n            const json = doc.toMutableJSON();\n            json.firstName = 'alice';\n            c.database.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"top-value","suites":["rx-document.test.js","get"],"updatePoint":{"line":677,"column":25},"line":677,"code":"            it('top-value', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec(true);\n                const passportId = doc.get('passportId');\n                assert.strictEqual(doc.passportId, passportId);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"hidden properties should not show up","suites":["rx-document.test.js","get"],"updatePoint":{"line":684,"column":52},"line":684,"code":"            it('hidden properties should not show up', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec(true);\n                assert.ok(!Object.keys(doc).includes('lastName_'));\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"nested-value","suites":["rx-document.test.js","get"],"updatePoint":{"line":690,"column":28},"line":690,"code":"            it('nested-value', async () => {\n                const c = await humansCollection.createNested(1);\n                const doc = await c.findOne().exec(true);\n                const mainSkillLevel = doc.get('mainSkill.level');\n                assert.strictEqual(doc.mainSkill.level, mainSkillLevel);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"deep-nested-value","suites":["rx-document.test.js","get"],"updatePoint":{"line":697,"column":33},"line":697,"code":"            it('deep-nested-value', async () => {\n                const c = await humansCollection.createDeepNested(1);\n                const doc = await c.findOne().exec(true);\n                const value = doc.get('mainSkill.attack.count');\n                assert.strictEqual(doc.mainSkill.attack.count, value);\n\n                const value2 = doc.get('mainSkill.attack.good');\n                assert.strictEqual(doc.mainSkill.attack.good, value2);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"top-value-observable","suites":["rx-document.test.js","get"],"updatePoint":{"line":707,"column":36},"line":707,"code":"            it('top-value-observable', async () => {\n                const c = await humansCollection.create(1);\n                const doc: any = await c.findOne().exec(true);\n                const obs = doc.firstName$;\n                assert.ok(obs.subscribe);\n\n                let value = null;\n                obs.subscribe((newVal: any) => {\n                    value = newVal;\n                });\n\n                await doc.atomicPatch({ firstName: 'foobar' });\n\n                await promiseWait(5);\n                assert.strictEqual(value, 'foobar');\n\n                // resubscribe should emit again\n                let value2 = null;\n                obs.subscribe((newVal: any) => {\n                    value2 = newVal;\n                });\n                await promiseWait(5);\n                assert.strictEqual(value2, 'foobar');\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"nested-value-observable","suites":["rx-document.test.js","get"],"updatePoint":{"line":732,"column":39},"line":732,"code":"            it('nested-value-observable', async () => {\n                const c = await humansCollection.createNested(1);\n                const doc = await c.findOne().exec(true);\n                const obs: Observable<any> = (doc.mainSkill as any).level$;\n                assert.ok(obs['subscribe']);\n\n                let value = null;\n                (doc.mainSkill as any).level$.subscribe((newVal: any) => {\n                    value = newVal;\n                });\n\n                await doc.atomicPatch({\n                    mainSkill: {\n                        name: randomCouchString(5),\n                        level: 10\n                    }\n                });\n                await promiseWait(5);\n                assert.strictEqual(value, 10);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"deep-nested-value-observable","suites":["rx-document.test.js","get"],"updatePoint":{"line":753,"column":44},"line":753,"code":"            it('deep-nested-value-observable', async () => {\n                const c = await humansCollection.createDeepNested(1);\n                const doc = await c.findOne().exec(true);\n                const obs = (doc.mainSkill.attack as any).good$;\n                assert.ok(obs.subscribe);\n\n                let value = null;\n                (doc.mainSkill.attack as any).good$.subscribe((newVal: any) => {\n                    value = newVal;\n                });\n                await doc.atomicPatch({\n                    mainSkill: {\n                        name: 'foobar',\n                        attack: {\n                            good: true,\n                            count: 100\n                        }\n\n                    }\n                });\n                await promiseWait(5);\n                assert.strictEqual(value, true);\n                c.database.destroy();\n            });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"#66 - insert -> remove -> upsert does not give new state","suites":["rx-document.test.js","get"],"updatePoint":{"line":780,"column":68},"line":780,"code":"        it('#66 - insert -> remove -> upsert does not give new state', async () => {\n            const c = await humansCollection.createPrimary(0);\n            const docData = schemaObjects.simpleHuman();\n            const primary = docData.passportId;\n\n\n            // insert\n            await c.insert(docData);\n            const doc1 = await c.findOne(primary).exec(true);\n            assert.strictEqual(doc1.firstName, docData.firstName);\n\n            // remove\n            await doc1.remove();\n\n            // upsert\n            docData.firstName = 'foobar';\n            await c.upsert(docData);\n            const doc2 = await c.findOne(primary).exec(true);\n            assert.strictEqual(doc2.firstName, 'foobar');\n\n            c.database.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"#76 - deepEqual does not work correctly for Arrays","suites":["rx-document.test.js","get"],"updatePoint":{"line":826,"column":62},"line":826,"code":"        it('#76 - deepEqual does not work correctly for Arrays', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n            });\n            const cols = await await db.addCollections({\n                heroes: {\n                    schema: schemas.simpleArrayHero\n                }\n            });\n            const col = cols.heroes;\n            const docData = {\n                name: 'foobar',\n                skills: [\n                    'skill1',\n                    'skill2',\n                    'skill3'\n                ]\n            };\n            await col.insert(docData);\n            const doc = await col.findOne().exec();\n            assert.strictEqual(doc.skills.length, 3);\n\n            const newSkill = 'newSikSkill';\n            await doc.atomicPatch({ skills: doc.skills.concat(newSkill) });\n\n            const colDump = await col.exportJSON();\n            const afterSkills = colDump.docs[0].skills;\n            assert.strictEqual(afterSkills.length, 4);\n            assert.ok(afterSkills.includes(newSkill));\n            db.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"#646 Skip defining getter and setter when property not defined in schema","suites":["rx-document.test.js","get"],"updatePoint":{"line":858,"column":84},"line":858,"code":"        it('#646 Skip defining getter and setter when property not defined in schema', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n            });\n            const schema = {\n                version: 0,\n                primaryKey: 'key',\n                type: 'object',\n                properties: {\n                    key: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    value: {\n                        type: 'object'\n                    }\n                },\n                required: ['key']\n            };\n            const cols = await await db.addCollections({\n                heroes: {\n                    schema\n                }\n            });\n            const col = cols.heroes;\n\n            const doc = await col.insert({\n                key: 'foobar',\n                value: {\n                    x: {\n                        foo: 'bar'\n                    }\n                }\n            });\n\n            const value = doc.get('value.x');\n            assert.strictEqual(value.foo, 'bar');\n\n            db.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"#830 should return a rejected promise when already deleted","suites":["rx-document.test.js","get"],"updatePoint":{"line":899,"column":70},"line":899,"code":"        it('#830 should return a rejected promise when already deleted', async () => {\n            const c = await humansCollection.createPrimary(1);\n            const doc = await c.findOne().exec(true);\n            assert.ok(doc);\n            await doc.remove();\n            assert.ok(doc.deleted);\n            const ret = doc.remove();\n            if (!ret) {\n                throw new Error('missing');\n            }\n            assert.strictEqual(typeof ret.then, 'function'); // ensure it's a promise\n            await AsyncTestUtil.assertThrows(\n                () => ret,\n                'RxError',\n                'already deleted'\n            );\n            c.database.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"#1325 populate should return null when value is falsy","suites":["rx-document.test.js","get"],"updatePoint":{"line":917,"column":65},"line":917,"code":"        it('#1325 populate should return null when value is falsy', async () => {\n            const collection = await humansCollection.createRelated();\n            const doc = await collection.findOne({\n                selector: {\n                    bestFriend: { $exists: true }\n                }\n            }).exec(true);\n\n            await doc.update({\n                $set: {\n                    bestFriend: ''\n                }\n            });\n            const populate = await doc.populate('bestFriend');\n\n            assert.strictEqual(populate, null);\n\n            collection.database.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"#3839 executing insert -> remove -> insert -> remove fails","suites":["rx-document.test.js","get"],"updatePoint":{"line":939,"column":70},"line":939,"code":"        it('#3839 executing insert -> remove -> insert -> remove fails', async () => {\n            // create a schema\n            const mySchema = {\n                title: 'example schema',\n                version: 0,\n                description: 'describes an example collection schema',\n                primaryKey: 'name',\n                type: 'object',\n                properties: {\n                    name: {\n                        $comment: 'primary key MUST have a maximum length!',\n                        type: 'string',\n                        maxLength: 100,\n                    },\n                    gender: {\n                        type: 'string',\n                    },\n                    birthyear: {\n                        type: 'integer',\n                        final: true,\n                        minimum: 1900,\n                        maximum: 2099,\n                    },\n                },\n                required: ['name', 'gender'],\n            };\n\n            // generate a random database-name\n            const name = randomCouchString(10);\n\n            // create a database\n            const db = await createRxDatabase({\n                name,\n                /**\n                 * By calling config.storage.getStorage(),\n                 * we can ensure that all variations of RxStorage are tested in the CI.\n                 */\n                storage: config.storage.getStorage(),\n                eventReduce: true,\n                ignoreDuplicate: true\n            });\n            // create a collection\n            const collections = await db.addCollections({\n                mycollection: {\n                    schema: mySchema\n                }\n            });\n\n            // insert a document\n            await collections.mycollection.insert({\n                name: 'test1',\n                gender: 'male',\n                birthyear: 2000\n            });\n\n            // remove a document\n            await collections.mycollection.findOne({\n                selector: {\n                    name: 'test1'\n                }\n            }).remove();\n\n            // insert document again\n            await collections.mycollection.insert({\n                name: 'test1',\n                gender: 'male',\n                birthyear: 2000\n            });\n\n            // remove document again\n            await collections.mycollection.findOne({\n                selector: {\n                    name: 'test1'\n                }\n            }).remove();\n\n            // clean up afterwards\n            db.destroy();\n        });","file":"unit/rx-document.test.ts","skipped":false,"dir":"test"},{"name":"should throw dev-mode error on wrong query object","suites":["rx-query.test.ts"],"updatePoint":{"line":27,"column":61},"line":27,"code":"        it('should throw dev-mode error on wrong query object', async () => {\n            const col = await humansCollection.create(0);\n\n            await AsyncTestUtil.assertThrows(\n                () => col.find({ foo: 'bar' } as any),\n                'RxTypeError',\n                'no valid query params'\n            );\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should throw error when custom index not in schema indexes","suites":["rx-query.test.ts"],"updatePoint":{"line":38,"column":70},"line":38,"code":"        it('should throw error when custom index not in schema indexes', async () => {\n            const col = await humansCollection.create(0);\n            await AsyncTestUtil.assertThrows(\n                () => col.find({\n                    selector: {},\n                    index: ['f', 'o', 'b', 'a', 'r']\n                }).getPreparedQuery(),\n                'RxError',\n                'not in schem'\n            );\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should NOT throw error when custom index is in schema indexes","suites":["rx-query.test.ts"],"updatePoint":{"line":50,"column":73},"line":50,"code":"        it('should NOT throw error when custom index is in schema indexes', async () => {\n            const col = await humansCollection.createAgeIndex(0);\n            col.find({\n                selector: {},\n                index: ['age']\n            }).getPreparedQuery();\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should produce the correct selector-object","suites":["rx-query.test.ts"],"updatePoint":{"line":60,"column":54},"line":60,"code":"        it('should produce the correct selector-object', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age');\n            const queryObj = q.mangoQuery;\n            assert.deepStrictEqual(queryObj, {\n                selector: {\n                    name: {\n                        '$ne': 'Alice'\n                    },\n                    age: {\n                        '$gt': 18,\n                        '$lt': 67\n                    }\n                },\n                sort: [{\n                    age: 'desc'\n                }],\n                limit: 10\n            });\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should get a valid string-representation","suites":["rx-query.test.ts"],"updatePoint":{"line":87,"column":52},"line":87,"code":"        it('should get a valid string-representation', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age');\n            const str = q.toString();\n            const mustString = '{\"op\":\"find\",\"other\":{\"queryBuilderPath\":\"age\"},\"query\":{\"limit\":10,\"selector\":{\"age\":{\"$gt\":18,\"$lt\":67},\"name\":{\"$ne\":\"Alice\"}},\"sort\":[{\"age\":\"desc\"}]}}';\n            assert.strictEqual(str, mustString);\n            const str2 = q.toString();\n            assert.strictEqual(str2, mustString);\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should get a valid string-representation with two sort params","suites":["rx-query.test.ts"],"updatePoint":{"line":102,"column":73},"line":102,"code":"        it('should get a valid string-representation with two sort params', async () => {\n            const col = await humansCollection.createAgeIndex();\n            const q = col.find().sort({\n                passportId: 'desc', age: 'desc'\n            });\n            const str = q.toString();\n            const mustString = '{\"op\":\"find\",\"other\":{},\"query\":{\"selector\":{},\"sort\":[{\"passportId\":\"desc\"},{\"age\":\"desc\"}]}}';\n            assert.strictEqual(str, mustString);\n            const str2 = q.toString();\n            assert.strictEqual(str2, mustString);\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"ISSUE #190: should contain the regex","suites":["rx-query.test.ts"],"updatePoint":{"line":115,"column":48},"line":115,"code":"        it('ISSUE #190: should contain the regex', async () => {\n            if (!config.storage.hasRegexSupport) {\n                return;\n            }\n\n            const col = await humansCollection.create(0);\n            const queryWithoutRegex = col.find();\n            const queryWithRegex = queryWithoutRegex.where('color').regex(new RegExp(/foobar/g));\n            const queryString = queryWithRegex.toString();\n\n            assert.ok(queryString.includes('foobar'));\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"same queries should return the same string","suites":["rx-query.test.ts"],"updatePoint":{"line":128,"column":54},"line":128,"code":"        it('same queries should return the same string', async () => {\n            const col1 = await humansCollection.create(0);\n            const col2 = await humansCollection.create(0);\n\n            const query1 = col1.find()\n                .where('age').gt(10)\n                .where('name').ne('foobar')\n                .sort('passportId').toString();\n\n            const query2 = col2.find()\n                .where('age').gt(10)\n                .where('name').ne('foobar')\n                .sort('passportId').toString();\n\n            assert.strictEqual(query1, query2);\n            col1.database.destroy();\n            col2.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"same queries should return the same string even if on same collection","suites":["rx-query.test.ts"],"updatePoint":{"line":146,"column":81},"line":146,"code":"        it('same queries should return the same string even if on same collection', async () => {\n            const col = await humansCollection.create(0);\n\n            const query1 = col.find()\n                .where('age').gt(10)\n                .where('name').ne('foobar')\n                .sort('passportId').toString();\n\n            const query2 = col.find()\n                .where('age').gt(10)\n                .where('name').ne('foobar')\n                .sort('passportId').toString();\n\n            assert.strictEqual(query1, query2);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should not be the same object (sort)","suites":["rx-query.test.ts"],"updatePoint":{"line":164,"column":48},"line":164,"code":"        it('should not be the same object (sort)', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age');\n            const q2 = q.sort('name');\n            assert.ok(isRxQuery(q2));\n            assert.notStrictEqual(q, q2);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should not be the same object (where)","suites":["rx-query.test.ts"],"updatePoint":{"line":176,"column":49},"line":176,"code":"        it('should not be the same object (where)', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age');\n            const q2 = q.where('name').eq('foobar');\n            assert.ok(isRxQuery(q2));\n            assert.notStrictEqual(q, q2);\n            assert.ok(q.id < q2.id);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"return the same object","suites":["rx-query.test.ts"],"updatePoint":{"line":191,"column":34},"line":191,"code":"        it('return the same object', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age');\n            const q2 = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age');\n\n            assert.deepStrictEqual(q, q2);\n            assert.strictEqual(q.id, q2.id);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should return the same object after exec","suites":["rx-query.test.ts"],"updatePoint":{"line":208,"column":52},"line":208,"code":"        it('should return the same object after exec', async () => {\n            const col = await humansCollection.createPrimary(0);\n            const docData = schemaObjects.simpleHuman();\n            await col.insert(docData);\n            const query = col.findOne(docData.passportId);\n            await query.exec();\n            const query2 = col.findOne(docData.passportId);\n            await query2.exec();\n            assert.strictEqual(query.id, query2.id);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should have the correct amount of cached queries","suites":["rx-query.test.ts"],"updatePoint":{"line":219,"column":60},"line":219,"code":"        it('should have the correct amount of cached queries', async () => {\n            const col = await humansCollection.create(0);\n            const q3 = col.find()\n                .where('name').ne('Bob');\n            assert.ok(q3);\n            const q = col.find()\n                .where('name').ne('Alice');\n            assert.ok(q);\n            const q2 = col.find()\n                .where('name').ne('Bob');\n            assert.ok(q2);\n            assert.strictEqual(col._queryCache._map.size, 4);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"return another object","suites":["rx-query.test.ts"],"updatePoint":{"line":233,"column":33},"line":233,"code":"        it('return another object', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age');\n            const q2 = col.find()\n                .where('name').ne('foobar')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age');\n\n            assert.notStrictEqual(q, q2);\n            assert.notStrictEqual(q.id, q2.id);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"ISSUE: ensure its the same query","suites":["rx-query.test.ts"],"updatePoint":{"line":250,"column":44},"line":250,"code":"        it('ISSUE: ensure its the same query', async () => {\n            const col = await humansCollection.create(0);\n\n            const query1 = col.find()\n                .where('age').gt(10)\n                .where('name').ne('foobar')\n                .sort('passportId');\n\n            const query2 = col.find()\n                .where('age').gt(10)\n                .where('name').ne('foobar')\n                .sort('passportId');\n\n            assert.ok(query1 === query2);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should distinguish between different sort-orders","suites":["rx-query.test.ts"],"updatePoint":{"line":267,"column":60},"line":267,"code":"        it('should distinguish between different sort-orders', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('-age')\n                .sort('name');\n            const q2 = col.find()\n                .where('name').ne('Alice')\n                .where('age').gt(18).lt(67)\n                .limit(10)\n                .sort('name')\n                .sort('-age');\n\n            assert.notStrictEqual(q, q2);\n            assert.notStrictEqual(q.id, q2.id);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should reuse the cached result object in the document","suites":["rx-query.test.ts"],"updatePoint":{"line":294,"column":65},"line":294,"code":"        it('should reuse the cached result object in the document', async () => {\n            const col = await humansCollection.create(1);\n            const query = col.find({\n                selector: {\n                    firstName: {\n                        $ne: 'foobar'\n                    }\n                }\n            });\n            const docs = await query.exec();\n            const doc = docs[0];\n            if (!doc) {\n                throw new Error('doc missing');\n            }\n\n            const docDataObject = doc._dataSync$.getValue();\n            const inQueryCacheObject = ensureNotFalsy(query._result).docsData[0];\n\n            assert.ok(\n                docDataObject === inQueryCacheObject\n            );\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should match","suites":["rx-query.test.ts"],"updatePoint":{"line":320,"column":24},"line":320,"code":"        it('should match', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find().where('firstName').ne('foobar');\n            const docData = schemaObjects.human();\n            assert.ok(q.doesDocumentDataMatch(docData));\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should not match","suites":["rx-query.test.ts"],"updatePoint":{"line":327,"column":28},"line":327,"code":"        it('should not match', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find().where('firstName').ne('foobar');\n            const docData = schemaObjects.human();\n            docData.firstName = 'foobar';\n            assert.strictEqual(false, q.doesDocumentDataMatch(docData));\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should match ($gt)","suites":["rx-query.test.ts"],"updatePoint":{"line":335,"column":30},"line":335,"code":"        it('should match ($gt)', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find().where('age').gt(1);\n            const docData = schemaObjects.human();\n            docData.age = 5;\n            assert.ok(q.doesDocumentDataMatch(docData));\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should not match ($gt)","suites":["rx-query.test.ts"],"updatePoint":{"line":343,"column":34},"line":343,"code":"        it('should not match ($gt)', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find().where('age').gt(100);\n            const docData = schemaObjects.human();\n            docData.age = 5;\n            assert.strictEqual(false, q.doesDocumentDataMatch(docData));\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"BUG: this should match","suites":["rx-query.test.ts"],"updatePoint":{"line":351,"column":34},"line":351,"code":"        it('BUG: this should match', async () => {\n            const col = await humansCollection.create(0);\n            const q = col.find();\n\n            const docData = {\n                passportId: 'foobar',\n                color: 'green',\n                hp: 100,\n                maxHP: 767,\n                name: 'asdfsadf',\n                _rev: '1-971bfd0b8749eb33b6aae7f6c0dc2cd4'\n            };\n\n            assert.strictEqual(true, q.doesDocumentDataMatch(docData));\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"BUG should not match regex","suites":["rx-query.test.ts"],"updatePoint":{"line":367,"column":38},"line":367,"code":"        it('BUG should not match regex', async () => {\n            if (!config.storage.hasRegexSupport) {\n                return;\n            }\n            const col = await humansCollection.create(0);\n\n\n            // TODO using $and fails, we have to open an issue at the pouchdb repo\n            /*\n           const q = col.find({\n                selector: {\n                    $and: [{\n                        color: {\n                            $regex: new RegExp('f', 'i')\n                        }\n                    }]\n                }\n            });\n            */\n\n            const q = col.find({\n                selector: {\n                    color: {\n                        $regex: new RegExp('f', 'i')\n                    }\n                }\n            });\n\n            const docData = {\n                _id: 'mydoc',\n                color: 'green',\n                hp: 100,\n                maxHP: 767,\n                name: 'asdfsadf',\n                _rev: '1-971bfd0b8749eb33b6aae7f6c0dc2cd4'\n            };\n\n            assert.strictEqual(false, q.doesDocumentDataMatch(docData));\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should throw if top level field is not known to the schema","suites":["rx-query.test.ts"],"updatePoint":{"line":409,"column":70},"line":409,"code":"        it('should throw if top level field is not known to the schema', async () => {\n            const col = await humansCollection.create(0);\n\n            await AsyncTestUtil.assertThrows(\n                () => col.find({\n                    selector: {\n                        asdfasdfasdf: 'asdf'\n                    }\n                }).exec(),\n                'RxError',\n                'QU13'\n            );\n\n            // should also detect wrong fields inside of $and\n            await AsyncTestUtil.assertThrows(\n                () => col.find({\n                    selector: {\n                        $and: [\n                            {\n                                asdfasdfasdf: 'asdf'\n                            },\n                            {\n                                asdfasdfasdf: 'asdf'\n                            }\n                        ]\n                    }\n                }).exec(),\n                'RxError',\n                'QU13'\n            );\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"reusing exec should not make a execOverDatabase","suites":["rx-query.test.ts"],"updatePoint":{"line":442,"column":59},"line":442,"code":"        it('reusing exec should not make a execOverDatabase', async () => {\n            const col = await humansCollection.create(2);\n            const q = col.find().where('passportId').ne('Alice');\n\n\n            let results = await q.exec();\n            assert.strictEqual(results.length, 2);\n            assert.strictEqual(q._execOverDatabaseCount, 1);\n\n            await promiseWait(5);\n            results = await q.exec();\n            assert.strictEqual(results.length, 2);\n            assert.strictEqual(q._execOverDatabaseCount, 1);\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should execOverDatabase when still subscribed and changeEvent comes in","suites":["rx-query.test.ts"],"updatePoint":{"line":458,"column":82},"line":458,"code":"        it('should execOverDatabase when still subscribed and changeEvent comes in', async () => {\n            const col = await humansCollection.create(2);\n\n            // it is assumed that this query can never handled by event-reduce\n            const query = col.find().sort('-passportId').limit(1);\n\n            const fired: any[] = [];\n            const sub1 = query.$.subscribe(res => {\n                fired.push(res);\n            });\n\n            await AsyncTestUtil.waitUntil(() => fired.length === 1);\n\n            assert.strictEqual(query._execOverDatabaseCount, 1);\n            assert.strictEqual(query._latestChangeEvent, 2);\n\n            const addObj = schemaObjects.human();\n            addObj.passportId = 'zzzzzzzz';\n            await col.insert(addObj);\n            assert.strictEqual(query.collection._changeEventBuffer.counter, 3);\n\n            await AsyncTestUtil.waitUntil(() => query._latestChangeEvent === 3);\n            assert.strictEqual(query._latestChangeEvent, 3);\n\n            await AsyncTestUtil.waitUntil(() => fired.length === 2);\n            assert.strictEqual(fired[1].pop().passportId, addObj.passportId);\n            sub1.unsubscribe();\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"reusing exec should execOverDatabase when change happened that cannot be optimized","suites":["rx-query.test.ts"],"updatePoint":{"line":487,"column":94},"line":487,"code":"        it('reusing exec should execOverDatabase when change happened that cannot be optimized', async () => {\n            const col = await humansCollection.create(2);\n\n            // it is assumed that this query can never handled by event-reduce\n            const q = col.find()\n                .where('firstName').ne('AliceFoobar')\n                .sort('passportId')\n                .skip(1);\n\n            let results = await q.exec();\n            assert.strictEqual(results.length, 1);\n            assert.strictEqual(q._execOverDatabaseCount, 1);\n            assert.strictEqual(q._latestChangeEvent, 2);\n\n            const addDoc = schemaObjects.human();\n\n            // set _id to first value to force a re-exec-over database\n            addDoc.passportId = '1-aaaaaaaaaaaaaaaaaaaaaaaaaaa';\n            addDoc.firstName = 'NotAliceFoobar';\n\n            await col.insert(addDoc);\n            assert.strictEqual(q.collection._changeEventBuffer.counter, 3);\n\n            assert.strictEqual(q._latestChangeEvent, 2);\n\n            await promiseWait(1);\n            results = await q.exec();\n            assert.strictEqual(results.length, 2);\n            assert.strictEqual(q._execOverDatabaseCount, 2);\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"querying fast should still return the same RxDocument","suites":["rx-query.test.ts"],"updatePoint":{"line":519,"column":65},"line":519,"code":"        it('querying fast should still return the same RxDocument', async () => {\n            if (\n                !config.platform.isNode() ||\n                config.storage.name !== 'pouchdb'\n            ) {\n                return;\n            }\n            // use a 'slow' adapter because memory might be to fast\n            const leveldown = require('leveldown');\n            const db = await createRxDatabase({\n                name: config.rootPath + 'test_tmp/' + randomCouchString(10),\n                storage: getRxStoragePouch(leveldown),\n            });\n            const cols = await db.addCollections({\n                humans: {\n                    schema: schemas.human\n                }\n            });\n            const c = cols.humans;\n            await c.insert(schemaObjects.human());\n\n            const query1 = c.findOne().where('age').gt(0);\n            const query2 = c.findOne().where('age').gt(1);\n            const docs = await Promise.all([\n                query1.exec(),\n                query2.exec()\n            ]);\n            assert.ok(docs[0] === docs[1]);\n\n            db.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"querying after insert should always return the correct amount","suites":["rx-query.test.ts"],"updatePoint":{"line":550,"column":73},"line":550,"code":"        it('querying after insert should always return the correct amount', async () => {\n            const col = await humansCollection.create(0);\n\n            const amount = 100;\n            const query = col.find({\n                selector: {\n                    age: {\n                        $gt: 1\n                    }\n                }\n            });\n            let inserted = 0;\n            while (inserted < amount) {\n                const docData = schemaObjects.human();\n                docData.age = 10;\n                await col.insert(docData);\n                inserted = inserted + 1;\n                const results = await query.exec();\n                assert.strictEqual(results.length, inserted);\n            }\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should not make more requests then needed","suites":["rx-query.test.ts"],"updatePoint":{"line":573,"column":53},"line":573,"code":"        it('should not make more requests then needed', async () => {\n            const col = await humansCollection.createPrimary(0);\n            const docData = schemaObjects.simpleHuman();\n            const otherData = () => {\n                const data = clone(docData);\n                data.firstName = AsyncTestUtil.randomString();\n                return data;\n            };\n            await col.insert(docData);\n\n            const emitted = [];\n            const query = col.findOne(docData.passportId);\n            query.$.subscribe((data: any) => emitted.push(data.toJSON()));\n\n            await AsyncTestUtil.waitUntil(() => emitted.length === 1);\n            assert.strictEqual(query._execOverDatabaseCount, 1);\n\n            const doc = await query.exec();\n            assert.ok(doc);\n            assert.strictEqual(query._execOverDatabaseCount, 1);\n\n            await col.upsert(otherData());\n            await AsyncTestUtil.waitUntil(() => emitted.length === 2);\n            assert.strictEqual(query._execOverDatabaseCount, 1);\n\n            await col.atomicUpsert(otherData());\n            await AsyncTestUtil.waitUntil(() => emitted.length === 3);\n            assert.strictEqual(query._execOverDatabaseCount, 1);\n\n            await Promise.all(\n                new Array(2)\n                    .fill(0)\n                    .map(() => otherData())\n                    .map(data => col.atomicUpsert(data))\n            );\n            await AsyncTestUtil.waitUntil(() => emitted.length === 5);\n            assert.strictEqual(query._execOverDatabaseCount, 1);\n\n            await Promise.all(\n                new Array(10)\n                    .fill(0)\n                    .map(() => otherData())\n                    .map(data => col.atomicUpsert(data))\n            );\n            await AsyncTestUtil.waitUntil(() => emitted.length === 15);\n            assert.strictEqual(query._execOverDatabaseCount, 1);\n\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"should not make more requests then needed on atomic upsert","suites":["rx-query.test.ts"],"updatePoint":{"line":622,"column":70},"line":622,"code":"        it('should not make more requests then needed on atomic upsert', async () => {\n            const col = await humansCollection.createPrimary(0);\n            const docData = schemaObjects.simpleHuman();\n            let count = 0;\n            const otherData = () => {\n                const data = clone(docData);\n                data.firstName = '' + count;\n                count++;\n                return data;\n            };\n\n            const emitted = [];\n            const query = col.findOne(docData.passportId);\n            query.$.subscribe(doc => {\n                if (!doc) emitted.push(null);\n                else emitted.push(doc.toJSON());\n            });\n\n            await Promise.all(\n                new Array(10)\n                    .fill(0)\n                    .map(() => otherData())\n                    .map(data => col.atomicUpsert(data))\n            );\n\n            assert.strictEqual(query._execOverDatabaseCount, 1);\n            col.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"exec from other database-instance","suites":["rx-query.test.ts"],"updatePoint":{"line":650,"column":45},"line":650,"code":"        it('exec from other database-instance', async () => {\n            const dbName = randomCouchString(10);\n            const schema = schemas.averageSchema();\n            const db = await createRxDatabase({\n                name: dbName,\n                eventReduce: true,\n                storage: getRxStoragePouch('memory'),\n            });\n            const cols = await db.addCollections({\n                human: {\n                    schema\n                }\n            });\n            const col = cols.human;\n\n            await Promise.all(\n                new Array(10)\n                    .fill(0)\n                    .map(() => schemaObjects.averageSchema())\n                    .map(data => col.insert(data))\n            );\n\n            await db.destroy();\n\n            const db2 = await createRxDatabase({\n                name: dbName,\n                storage: getRxStoragePouch('memory'),\n                eventReduce: true,\n                ignoreDuplicate: true\n            });\n            const cols2 = await db2.addCollections({\n                human: {\n                    schema\n                }\n            });\n            const col2 = cols2.human;\n\n            const allDocs = await col2.find().exec();\n            assert.strictEqual(allDocs.length, 10);\n\n            db2.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"exec(true) should throw if missing","suites":["rx-query.test.ts"],"updatePoint":{"line":692,"column":46},"line":692,"code":"        it('exec(true) should throw if missing', async () => {\n            const c = await humansCollection.create(0);\n\n            await AsyncTestUtil.assertThrows(\n                () => c.findOne().exec(true),\n                'RxError',\n                'throwIfMissing'\n            );\n\n            c.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"exec(true) should throw used with non-findOne","suites":["rx-query.test.ts"],"updatePoint":{"line":703,"column":57},"line":703,"code":"        it('exec(true) should throw used with non-findOne', async () => {\n            const c = await humansCollection.create(0);\n            await AsyncTestUtil.assertThrows(\n                () => c.find().exec(true),\n                'RxError',\n                'findOne'\n            );\n            c.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"isFindOneByIdQuery(): .findOne(documentId) should use RxStorage().findDocumentsById() instead of RxStorage().query()","suites":["rx-query.test.ts"],"updatePoint":{"line":712,"column":128},"line":712,"code":"        it('isFindOneByIdQuery(): .findOne(documentId) should use RxStorage().findDocumentsById() instead of RxStorage().query()', async () => {\n            const c = await humansCollection.create();\n            const docData = schemaObjects.simpleHuman();\n            const docId = 'foobar';\n            docData.passportId = docId;\n            await c.insert(docData);\n\n\n            // overwrite .query() to track the amount of calls\n            let queryCalls = 0;\n            const queryBefore = c.storageInstance.query.bind(c.storageInstance);\n            c.storageInstance.query = function (preparedQuery) {\n                queryCalls = queryCalls + 1;\n                return queryBefore(preparedQuery);\n            };\n\n            /**\n             * None of these operations should lead to a call to .query()\n             */\n            const operations = [\n                () => c.findOne(docId).exec(true),\n                () => c.find({\n                    selector: {\n                        passportId: docId\n                    },\n                    limit: 1\n                }).exec(),\n                () => c.find({\n                    selector: {\n                        passportId: {\n                            $eq: docId\n                        }\n                    },\n                    limit: 1\n                }).exec(),\n                () => c.find({\n                    selector: {\n                        passportId: {\n                            $eq: docId\n                        }\n                    }\n                    /**\n                     * Even without limit here,\n                     * it should detect that we look for a document that is $eq\n                     * to the primary key, so it can always\n                     * only find one document.\n                     */\n                }).exec()\n            ];\n            for (const operation of operations) {\n                await operation();\n            }\n\n            assert.strictEqual(queryCalls, 0);\n            c.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"updates a value on a query","suites":["rx-query.test.ts","positive"],"updatePoint":{"line":771,"column":42},"line":771,"code":"            it('updates a value on a query', async () => {\n                const c = await humansCollection.create(2);\n                const query = c.find();\n                await query.update({\n                    $set: {\n                        firstName: 'new first name'\n                    }\n                });\n                const docs = await query.exec();\n                for (const doc of docs)\n                    assert.strictEqual(doc._data.firstName, 'new first name');\n                c.database.destroy();\n            });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"$unset a value on a query","suites":["rx-query.test.ts","positive"],"updatePoint":{"line":784,"column":41},"line":784,"code":"            it('$unset a value on a query', async () => {\n                const c = await humansCollection.create(2);\n                const query = c.find();\n                await query.update({\n                    $unset: {\n                        age: ''\n                    }\n                });\n                const docs = await query.exec();\n                for (const doc of docs)\n                    assert.strictEqual(doc._data.age, undefined);\n                c.database.destroy();\n            });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"dont crash when findOne with no result","suites":["rx-query.test.ts","positive"],"updatePoint":{"line":797,"column":54},"line":797,"code":"            it('dont crash when findOne with no result', async () => {\n                const c = await humansCollection.create(2);\n                const query = c.findOne().where('age').gt(1000000);\n                await query.update({\n                    $set: {\n                        firstName: 'new first name'\n                    }\n                });\n                const doc = await query.exec();\n                assert.strictEqual(doc, null);\n                c.database.destroy();\n            });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#267 query for null-fields","suites":["rx-query.test.ts","positive"],"updatePoint":{"line":812,"column":38},"line":812,"code":"        it('#267 query for null-fields', async () => {\n            if (config.storage.name !== 'pouchdb') {\n                /**\n                 * This test only runs in pouchdb,\n                 * TODO this should run on every RxStorage because it is a valid mongodb query.\n                 * @link https://docs.mongodb.com/manual/tutorial/query-for-null-fields/#faq-developers-query-for-nulls\n                 */\n                return;\n            }\n            const c = await humansCollection.create(2);\n            const foundDocs = await c.find({\n                selector: {\n                    passportId: null\n                }\n            }).exec();\n            assert.ok(Array.isArray(foundDocs));\n            c.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#278 queryCache breaks when pointer out of bounds","suites":["rx-query.test.ts","positive"],"updatePoint":{"line":830,"column":61},"line":830,"code":"        it('#278 queryCache breaks when pointer out of bounds', async () => {\n            if (!config.platform.isNode()) {\n                // dont do this on browsers because firefox takes too long\n                return;\n            }\n\n            const c = await humansCollection.createPrimary(0);\n\n            // insert some docs\n            const insertAmount = 100;\n            await c.bulkInsert(\n                new Array(insertAmount)\n                    .fill(0)\n                    .map((_v, idx) => schemaObjects.human(undefined, idx))\n            );\n\n            // make and exec query\n            const query = c.find();\n            const docs = await query.exec();\n            assert.strictEqual(docs.length, insertAmount);\n\n            // produces changeEvents\n            await c.bulkInsert(\n                new Array(300) // higher than ChangeEventBuffer.limit\n                    .fill(0)\n                    .map(() => schemaObjects.human())\n            );\n\n\n            // re-exec query\n            const docs2 = await query.exec();\n            assert.strictEqual(docs2.length, 400);\n\n            // try same with upserts\n            const docData = new Array(200)\n                .fill(0)\n                .map(() => schemaObjects.human());\n            await c.bulkInsert(docData);\n\n            const docs3 = await query.exec();\n            assert.strictEqual(docs3.length, 600);\n\n            let docData2 = clone(docData);\n            // because we have no bulkUpsert, we only upsert 10 docs to speed up the test.\n            docData2 = docData2.slice(0, 10);\n            docData2.forEach((doc: any) => doc.lastName = doc.lastName + '1');\n            await Promise.all(\n                docData2.map(doc => c.upsert(doc))\n            );\n\n            const docs4 = await query.exec();\n            assert.strictEqual(docs4.length, 600);\n\n            c.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#585 sort by sub-path not working","suites":["rx-query.test.ts","positive"],"updatePoint":{"line":885,"column":45},"line":885,"code":"        it('#585 sort by sub-path not working', async () => {\n            const schema = {\n                version: 0,\n                type: 'object',\n                primaryKey: 'id',\n                keyCompression: false,\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    info: {\n                        type: 'object',\n                        properties: {\n                            title: {\n                                type: 'string',\n                                maxLength: 1000\n                            },\n                        },\n                    }\n                },\n                indexes: ['info.title']\n            };\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n            });\n            const cols = await db.addCollections({\n                humans: {\n                    schema\n                }\n            });\n            const col = cols.humans;\n\n            await col.storageInstance.internals.pouch.createIndex({\n                name: 'idx-rxdb-info',\n                ddoc: 'idx-rxdb-info',\n                index: {\n                    fields: ['info']\n                }\n            });\n            await col.storageInstance.internals.pouch.createIndex({\n                name: 'idx-rxdb-info.title',\n                ddoc: 'idx-rxdb-info.title',\n                index: {\n                    fields: ['info.title']\n                }\n            });\n\n            await col.insert({\n                id: '1',\n                info: {\n                    title: 'bbtest'\n                }\n            });\n            await col.insert({\n                id: '2',\n                info: {\n                    title: 'aatest'\n                }\n            });\n            await col.insert({\n                id: '3',\n                info: {\n                    title: 'cctest'\n                }\n            });\n\n            const foundDocs = await col\n                .find()\n                .sort('info.title')\n                .exec();\n            assert.strictEqual(foundDocs.length, 3);\n            assert.strictEqual(foundDocs[0].info.title, 'aatest');\n\n            const foundDocsDesc = await col\n                .find()\n                .sort('-info.title')\n                .exec();\n            assert.strictEqual(foundDocsDesc.length, 3);\n            assert.strictEqual(foundDocsDesc[0].info.title, 'cctest');\n\n            db.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#609 default index on primaryKey when better possible","suites":["rx-query.test.ts","positive"],"updatePoint":{"line":969,"column":65},"line":969,"code":"        it('#609 default index on primaryKey when better possible', async () => {\n            if (config.storage.name !== 'pouchdb') {\n                return;\n            }\n\n            const mySchema: RxJsonSchema<{ name: string; passportId: string; }> = {\n                version: 0,\n                keyCompression: false,\n                primaryKey: 'name',\n                type: 'object',\n                properties: {\n                    name: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    passportId: {\n                        type: 'string',\n                        maxLength: 100\n                    }\n                },\n                indexes: ['passportId']\n            };\n            const collection = await humansCollection.createBySchema(mySchema);\n\n            await collection.insert({\n                name: 'abc',\n                passportId: 'foobar'\n            });\n\n            // first query, no sort\n            const q1 = collection.findOne({\n                selector: {\n                    passportId: 'foofbar'\n                },\n                /**\n                 * TODO if we do not set a sorting,\n                 * the primaryKey sorting will still be added by RxDb\n                 * which causes PouchDB to pick the wrong index.\n                 * This looks like a pouchdb bug, create a test there.\n                 */\n                sort: [\n                    { passportId: 'asc' }\n                ]\n            });\n            const explained1 = await collection.storageInstance.internals.pouch.explain(q1.getPreparedQuery());\n\n            assert.ok(explained1.index.ddoc);\n            assert.ok(explained1.index.ddoc.startsWith('_design/idx-'));\n\n            // second query, with sort\n            const q2 = collection.findOne({\n                selector: {\n                    passportId: 'foofbar'\n                }\n            }).sort('passportId');\n            const explained2 = await collection.storageInstance.internals.pouch.explain(q2.getPreparedQuery());\n            assert.ok(explained2.index.ddoc);\n            assert.ok(explained2.index.ddoc.startsWith('_design/idx-'));\n\n            collection.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#698 Same query producing a different result","suites":["rx-query.test.ts","positive"],"updatePoint":{"line":1030,"column":56},"line":1030,"code":"        it('#698 Same query producing a different result', async () => {\n            const mySchema: RxJsonSchema<{ id: string; event_id: number; user_id: string; created_at: number }> = {\n                version: 0,\n                keyCompression: false,\n                primaryKey: 'id',\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    event_id: {\n                        type: 'number'\n                    },\n                    user_id: {\n                        type: 'string'\n                    },\n                    created_at: {\n                        type: 'number',\n                        minimum: 0,\n                        maximum: 10000000000000000,\n                        multipleOf: 1\n                    }\n                },\n                indexes: ['created_at']\n            };\n            const collection = await humansCollection.createBySchema(mySchema);\n\n            await collection.insert({\n                id: randomCouchString(12),\n                event_id: 1,\n                user_id: '6',\n                created_at: 1337\n            });\n            await collection.insert({\n                id: randomCouchString(12),\n                event_id: 2,\n                user_id: '6',\n                created_at: 1337\n            });\n\n\n            /* eslint-disable */\n            const selector = {\n                $and: [{\n                    event_id: {\n                        $eq: 2\n                    }\n                }, {\n                    user_id: {\n                        $eq: '6'\n                    }\n                },\n                {\n                    created_at: {\n                        $gt: 0\n                    }\n                }, {\n                    user_id: {\n                        $eq: '6'\n                    }\n                },\n                {\n                    created_at: {\n                        $gt: 0\n                    }\n                }\n                ]\n            };\n            /* eslint-enable */\n\n            const resultDocs1 = await collection\n                .find({\n                    selector\n                })\n                .exec();\n            const resultData1: any[] = resultDocs1.map(doc => doc.toJSON());\n\n            const resultDocs2 = await collection\n                .find()\n                .where('event_id').eq(2)\n                .where('user_id').eq('6')\n                .where('created_at').gt(0)\n                .exec();\n            const resultData2 = resultDocs2.map(doc => doc.toJSON());\n\n            assert.strictEqual(resultData1.length, 1);\n            assert.strictEqual(resultData1[0]['event_id'], 2);\n            assert.deepStrictEqual(resultData1, resultData2);\n\n            collection.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"698#issuecomment-402604237 mutating a returned array should not affect exec-calls afterwards","suites":["rx-query.test.ts","positive"],"updatePoint":{"line":1122,"column":104},"line":1122,"code":"        it('698#issuecomment-402604237 mutating a returned array should not affect exec-calls afterwards', async () => {\n            const c = await humansCollection.create(2);\n            const query = c.find();\n\n            // exec-calls\n            const result1: any = await query.exec();\n            assert.strictEqual(result1.length, 2);\n            result1.push({\n                foo: 'bar'\n            });\n            const result2 = await query.exec();\n            assert.strictEqual(result2.length, 2);\n\n            c.database.destroy();\n\n            // subscriptions\n            const c2 = await humansCollection.create(2);\n            const query2 = c2.find();\n            const res1: any = await firstValueFrom(query2.$);\n            res1.push({\n                foo: 'bar'\n            });\n            const res2 = await firstValueFrom(query2.$);\n            assert.strictEqual(res2.length, 2);\n\n            c2.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#724 find() does not find all matching documents","suites":["rx-query.test.ts","positive"],"updatePoint":{"line":1149,"column":60},"line":1149,"code":"        it('#724 find() does not find all matching documents', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n            });\n            const schema: RxJsonSchema<{ roomId: string; sessionId: string }> = {\n                version: 0,\n                primaryKey: 'roomId',\n                type: 'object',\n                properties: {\n                    roomId: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    sessionId: {\n                        type: 'string'\n                    }\n                }\n            };\n            const collections = await db.addCollections({\n                roomsession: {\n                    schema\n                }\n            });\n            const roomsession = collections.roomsession;\n            const roomId = 'roomId';\n            const sessionId = 'sessionID';\n            await roomsession.insert({\n                roomId,\n                sessionId\n            });\n\n            const foundByRoomId = await roomsession.findOne({\n                selector: {\n                    roomId\n                }\n            }).exec();\n            const foundByRoomAndSessionId = await roomsession.findOne({\n                selector: {\n                    roomId,\n                    sessionId\n                }\n            }).exec();\n            const foundBySessionId = await roomsession.findOne({\n                selector: {\n                    sessionId\n                }\n            }).exec();\n\n            assert(foundByRoomId !== null); // fail\n            assert(foundByRoomAndSessionId !== null); // fail\n            assert(foundBySessionId !== null); // pass\n            assert(foundBySessionId.roomId === roomId && foundBySessionId.sessionId === sessionId); // pass\n\n            db.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#815 Allow null value for strings","suites":["rx-query.test.ts","positive"],"updatePoint":{"line":1205,"column":45},"line":1205,"code":"        it('#815 Allow null value for strings', async () => {\n            if (config.storage.name !== 'pouchdb') {\n                return;\n            }\n\n            // create a schema\n            const mySchema = {\n                version: 0,\n                primaryKey: 'passportId',\n                type: 'object',\n                properties: {\n                    passportId: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    firstName: {\n                        type: 'string'\n                    },\n                    lastName: {\n                        type: ['string', 'null']\n                    },\n                    age: {\n                        type: 'integer',\n                        minimum: 0,\n                        maximum: 150\n                    }\n                }\n            };\n\n            // generate a random database-name\n            const name = randomCouchString(10);\n\n            // create a database\n            const db = await createRxDatabase({\n                name,\n                storage: getRxStoragePouch('memory'),\n                eventReduce: true,\n                ignoreDuplicate: true\n            });\n            // create a collection\n            const collections = await db.addCollections({\n                mycollection: {\n                    schema: mySchema\n                }\n            });\n            const collection = collections.mycollection;\n\n            // insert a document\n            await collection.insert({\n                passportId: 'foobar',\n                firstName: 'Bob1',\n                age: 56\n            });\n            await collection.insert({\n                passportId: 'foobaz',\n                firstName: 'Bob2',\n                lastName: null,\n                age: 56\n            });\n\n            const queryOK = collection.find();\n            const docsOK = await queryOK.exec();\n            assert.strictEqual(docsOK.length, 2);\n\n            const selector = {\n                lastName: null\n            };\n\n            const pouchResult = await collection.storageInstance.internals.pouch.find({\n                selector\n            });\n            const pouchDocs = pouchResult.docs;\n            const query = collection.find({\n                selector\n            });\n            const docs = await query.exec();\n\n            assert.strictEqual(pouchDocs.length, docs.length);\n            assert.strictEqual(pouchDocs[0].firstName, docs[0].firstName);\n\n            db.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"gitter: query with regex does not return correct results","suites":["rx-query.test.ts","positive"],"updatePoint":{"line":1290,"column":68},"line":1290,"code":"        it('gitter: query with regex does not return correct results', async () => {\n            if (!config.storage.hasRegexSupport) {\n                return;\n            }\n\n            // create a schema\n            const mySchema = {\n                version: 0,\n                primaryKey: 'passportId',\n                type: 'object',\n                properties: {\n                    passportId: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    firstName: {\n                        type: 'string'\n                    },\n                    lastName: {\n                        type: ['string', 'null']\n                    }\n                }\n            };\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n                eventReduce: true,\n                ignoreDuplicate: true\n            });\n\n            // create a collection\n            const collections = await db.addCollections({\n                mycollection: {\n                    schema: mySchema\n                }\n            });\n            const collection = collections.mycollection;\n\n            // insert documents\n            await collection.bulkInsert([\n                {\n                    passportId: 'doc1',\n                    firstName: 'John',\n                    lastName: 'Doe'\n                }, {\n                    passportId: 'doc2',\n                    firstName: 'Martin',\n                    lastName: 'Smith'\n                }\n            ]);\n            const allDocs = await collection.find().exec();\n            assert.strictEqual(allDocs.length, 2);\n\n            // test 1 with RegExp object\n            const regexp = new RegExp('^Doe$', 'i');\n            const result1 = await collection.find({\n                selector: {\n                    lastName: { $regex: regexp }\n                }\n            }).exec();\n\n            // test 2 with regex string\n            const result2 = await collection.find({\n                selector: {\n                    lastName: { $regex: '^Doe$' }\n                }\n            }).exec();\n\n\n            // both results should only have the doc1\n            assert.strictEqual(result1.length, 1);\n            assert.strictEqual(result1[0].passportId, 'doc1');\n            assert.deepStrictEqual(\n                result1.map(d => d.toJSON()),\n                result2.map(d => d.toJSON())\n            );\n\n            db.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#2071 RxCollection.findOne().exec() returns deleted document while find().exec() not","suites":["rx-query.test.ts","positive"],"updatePoint":{"line":1369,"column":96},"line":1369,"code":"        it('#2071 RxCollection.findOne().exec() returns deleted document while find().exec() not', async () => {\n            const c = await humansCollection.create(1);\n\n            // delete it\n            const doc = await c.findOne();\n            await doc.remove();\n\n            // now find() returns empty array\n            const docs = await c.find().exec();\n            assert.strictEqual(docs.length, 0);\n\n            // findOne() still returns the deleted object\n            const doc2 = await c.findOne().exec();\n            assert.strictEqual(doc2, null);\n\n            c.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#2213 prepareQuery should handle all comparison operators","suites":["rx-query.test.ts","positive"],"updatePoint":{"line":1386,"column":69},"line":1386,"code":"        it('#2213 prepareQuery should handle all comparison operators', async () => {\n            const collection = await humansCollection.createAgeIndex(0);\n            await collection.insert({\n                passportId: 'foobar',\n                firstName: 'Bob',\n                lastName: 'Kelso',\n                age: 56\n            });\n\n            await collection.insert({\n                passportId: 'foobar2',\n                firstName: 'Bob2',\n                lastName: 'Kelso2',\n                age: 58\n            });\n\n            const myDocument = await collection.findOne({\n                selector: {\n                    age: {\n                        $gte: 57,\n                    },\n                },\n                sort: [{ age: 'asc' }]\n            }).exec(true);\n\n            assert.strictEqual(myDocument.age, 58);\n\n            collection.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"gitter: mutating find-params causes different results","suites":["rx-query.test.ts","positive"],"updatePoint":{"line":1418,"column":65},"line":1418,"code":"        it('gitter: mutating find-params causes different results', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n                eventReduce: false\n            });\n            const schema = clone(schemas.human);\n            schema.keyCompression = false;\n\n            const cols = await db.addCollections({\n                humans: {\n                    schema\n                }\n            });\n            const c = cols.humans;\n\n            const docDataMatching = schemaObjects.human();\n            docDataMatching.age = 42;\n            await c.insert(docDataMatching);\n\n            const docDataNotMatching = schemaObjects.human();\n            docDataNotMatching.age = 99;\n            await c.insert(docDataNotMatching);\n\n            const queryParams = {\n                selector: {\n                    age: 42\n                }\n            };\n            const queryMatching = c.find(queryParams);\n            const queryMatchingOne = c.findOne(queryParams);\n\n            const res1 = await queryMatching.exec();\n            const resOne1 = await queryMatchingOne.exec();\n            assert.strictEqual(res1.length, 1);\n            assert.ok(resOne1);\n            assert.strictEqual(resOne1.age, 42);\n\n            queryParams.selector.age = 0;\n\n            // trigger a write so the results are not cached\n            const addData = schemaObjects.human();\n            addData.age = 55;\n            await c.insert(addData);\n\n            const res2 = await queryMatching.exec();\n            const resOne2 = await queryMatchingOne.exec();\n\n            assert.strictEqual(res2.length, 1);\n            assert.ok(res2);\n            assert.strictEqual(resOne2.age, 42);\n\n            db.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#3498 RxQuery returns outdated result in second subscription","suites":["rx-query.test.ts","positive"],"updatePoint":{"line":1472,"column":72},"line":1472,"code":"        it('#3498 RxQuery returns outdated result in second subscription', async () => {\n            const schema = {\n                version: 0,\n                primaryKey: 'id',\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    field: {\n                        type: 'boolean'\n                    }\n                }\n            } as const;\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: getRxStoragePouch('memory'),\n                eventReduce: true,\n                ignoreDuplicate: true\n            });\n            const collection = (await db.addCollections({\n                collection: {\n                    schema\n                }\n            })).collection;\n\n            const doc = await collection.insert({ id: 'testid', field: false });\n\n            // Bug only happens the second time the query is used\n            const result1 = await collection.find({ selector: { field: false } }).exec();\n            assert.strictEqual(result1.length, 1);\n\n            await doc.update({\n                $set: {\n                    field: true\n                }\n            });\n\n            const obs = collection.find({ selector: { field: false } }).$;\n            const result2a: any[][] = [];\n            const result2b: any[][] = [];\n            const sub2 = obs.subscribe((d) => result2b.push(d));\n            const sub1 = obs.subscribe((d) => result2a.push(d));\n\n            await promiseWait(5);\n\n            sub1.unsubscribe();\n            sub2.unsubscribe();\n\n            assert.strictEqual(Math.max(...result2a.map(r => r.length)), 0);\n            assert.strictEqual(Math.max(...result2b.map(r => r.length)), 0);\n\n            db.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"#3631 Sorting a query adds in deleted documents","suites":["rx-query.test.ts","positive"],"updatePoint":{"line":1527,"column":59},"line":1527,"code":"        it('#3631 Sorting a query adds in deleted documents', async () => {\n            const c = await humansCollection.createAgeIndex(1);\n            const doc = await c.findOne().exec(true);\n            await doc.remove();\n\n            const queryResult = await c.find({\n                selector: {},\n                sort: [\n                    { age: 'asc' }\n                ]\n            }).exec();\n\n            // should not have found the deleted document\n            assert.strictEqual(queryResult.length, 0);\n\n            c.database.destroy();\n        });","file":"unit/rx-query.test.ts","skipped":false,"dir":"test"},{"name":"get single indexes","suites":["static",".getIndexes()"],"updatePoint":{"line":28,"column":34},"line":28,"code":"            it('get single indexes', () => {\n                const indexes = getIndexes(schemas.human);\n                assert.strictEqual(indexes.length, 1);\n                assert.deepStrictEqual(indexes[0], ['firstName']);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get multiple indexes","suites":["static",".getIndexes()"],"updatePoint":{"line":33,"column":36},"line":33,"code":"            it('get multiple indexes', () => {\n                const indexes = getIndexes(schemas.bigHuman);\n                assert.ok(indexes.length > 1);\n                assert.deepStrictEqual(indexes[0], ['firstName']);\n                assert.deepStrictEqual(indexes[1], ['dnaHash']);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get sub-index","suites":["static",".getIndexes()"],"updatePoint":{"line":39,"column":29},"line":39,"code":"            it('get sub-index', () => {\n                const indexes = getIndexes(schemas.humanSubIndex);\n                assert.strictEqual(indexes.length, 1);\n                assert.deepStrictEqual(indexes[0], ['other.age']);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get no index","suites":["static",".getIndexes()"],"updatePoint":{"line":44,"column":28},"line":44,"code":"            it('get no index', () => {\n                const indexes = getIndexes(schemas.noIndexHuman);\n                assert.strictEqual(indexes.length, 0);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get compoundIndex","suites":["static",".getIndexes()"],"updatePoint":{"line":48,"column":33},"line":48,"code":"            it('get compoundIndex', () => {\n                const indexes = getIndexes(schemas.compoundIndex);\n                assert.ok(Array.isArray(indexes));\n                assert.ok(Array.isArray(indexes[0]));\n                assert.deepStrictEqual(indexes[0], ['age', 'passportCountry']);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate human","suites":["static",".checkSchema()","positive"],"updatePoint":{"line":57,"column":34},"line":57,"code":"                it('validate human', () => {\n                    checkSchema(schemas.human);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate bigHuman","suites":["static",".checkSchema()","positive"],"updatePoint":{"line":60,"column":37},"line":60,"code":"                it('validate bigHuman', () => {\n                    checkSchema(schemas.bigHuman);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate without index","suites":["static",".checkSchema()","positive"],"updatePoint":{"line":63,"column":42},"line":63,"code":"                it('validate without index', () => {\n                    checkSchema(schemas.noIndexHuman);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate with compoundIndexes","suites":["static",".checkSchema()","positive"],"updatePoint":{"line":66,"column":49},"line":66,"code":"                it('validate with compoundIndexes', () => {\n                    checkSchema(schemas.compoundIndex);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate empty","suites":["static",".checkSchema()","positive"],"updatePoint":{"line":69,"column":34},"line":69,"code":"                it('validate empty', () => {\n                    checkSchema(schemas.empty);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate with defaults","suites":["static",".checkSchema()","positive"],"updatePoint":{"line":72,"column":42},"line":72,"code":"                it('validate with defaults', () => {\n                    checkSchema(schemas.humanDefault);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validate point","suites":["static",".checkSchema()","positive"],"updatePoint":{"line":75,"column":34},"line":75,"code":"                it('validate point', () => {\n                    checkSchema(schemas.point);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"validates deep nested indexes","suites":["static",".checkSchema()","positive"],"updatePoint":{"line":78,"column":49},"line":78,"code":"                it('validates deep nested indexes', () => {\n                    checkSchema(schemas.humanWithDeepNestedIndexes);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"break when index defined at object property level","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":83,"column":69},"line":83,"code":"                it('break when index defined at object property level', () => {\n                    assert.throws(() => checkSchema({\n                        version: 0,\n                        primaryKey: 'id',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            name: {\n                                type: 'string',\n                                index: true\n                            } as any,\n                            job: {\n                                type: 'object',\n                                properties: {\n                                    name: {\n                                        type: 'string',\n                                        index: true\n                                    } as any,\n                                    manager: {\n                                        type: 'object',\n                                        properties: {\n                                            fullName: {\n                                                type: 'string',\n                                                index: true\n                                            } as any\n                                        }\n                                    }\n                                }\n                            }\n                        },\n                        required: ['job']\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"break when compoundIndex is specified in a separate field","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":119,"column":77},"line":119,"code":"                it('break when compoundIndex is specified in a separate field', () => {\n                    assert.throws(() => checkSchema({\n                        version: 0,\n                        primaryKey: 'id',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            name: {\n                                type: 'string',\n                                index: true\n                            } as any\n                        },\n                        compoundIndexes: ['id', 'name']\n                    } as any), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"throw when underscore field is used as property name","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":137,"column":72},"line":137,"code":"                it('throw when underscore field is used as property name', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        primaryKey: '_asdf',\n                        type: 'object',\n                        properties: {\n                            _asdf: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            firstName: {\n                                type: 'string'\n                            }\n                        },\n                        required: ['firstName']\n                    } as any), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"break when index is no string","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":155,"column":49},"line":155,"code":"                it('break when index is no string', () => {\n                    assert.throws(() => checkSchema(schemas.noStringIndex), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"break when index does not exist in schema properties","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":158,"column":72},"line":158,"code":"                it('break when index does not exist in schema properties', () => {\n                    assert.throws(() => checkSchema(schemas.notExistingIndex), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"break compoundIndex key is no string","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":161,"column":56},"line":161,"code":"                it('break compoundIndex key is no string', () => {\n                    assert.throws(() => checkSchema(schemas.compoundIndexNoString), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"break on wrong formated compundIndex","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":164,"column":56},"line":164,"code":"                it('break on wrong formated compundIndex', () => {\n                    assert.throws(() => checkSchema(schemas.wrongCompoundFormat), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"break when dots in fieldname","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":167,"column":48},"line":167,"code":"                it('break when dots in fieldname', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        description: 'dot in fieldname',\n                        primaryKey: 'my.field',\n                        type: 'object',\n                        properties: {\n                            'my.field': {\n                                type: 'string',\n                                maxLength: 100\n                            }\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"break when required is set via required: true","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":182,"column":65},"line":182,"code":"                it('break when required is set via required: true', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        primaryKey: 'myfield',\n                        type: 'object',\n                        properties: {\n                            'myfield': {\n                                type: 'string',\n                                required: true,\n                                maxLength: 100\n                            } as any\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not allow $-char in fieldnames","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":201,"column":57},"line":201,"code":"                it('should not allow $-char in fieldnames', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        primaryKey: 'id',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            'firstName$': {\n                                type: 'string'\n                            }\n                        }\n                    }), Error);\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        primaryKey: 'id',\n                        description: '$ in fieldname',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            'first$Name': {\n                                type: 'string'\n                            }\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not allow $-char in nested fieldnames","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":234,"column":64},"line":234,"code":"                it('should not allow $-char in nested fieldnames', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        description: '$ in nested fieldname',\n                        primaryKey: 'id',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            'things': {\n                                type: 'object',\n                                properties: {\n                                    first$Name: {\n                                        type: 'string'\n                                    }\n                                }\n                            }\n                        }\n                    }), Error);\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        description: '$ in nested fieldname',\n                        primaryKey: 'id',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            'things': {\n                                type: 'object',\n                                properties: {\n                                    firstName$: {\n                                        type: 'string'\n                                    }\n                                }\n                            }\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not allow ending lodash _ in fieldnames (reserved for populate)","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":278,"column":90},"line":278,"code":"                it('should not allow ending lodash _ in fieldnames (reserved for populate)', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        primaryKey: 'id',\n                        description: '_ in fieldname',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            'firstName_': {\n                                type: 'string'\n                            }\n                        }\n                    }), Error, 'underscore');\n                    // nested\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        description: 'dot in fieldname',\n                        primaryKey: 'id',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            'foo': {\n                                type: 'object',\n                                properties: {\n                                    'name_': {\n                                        type: 'string'\n                                    }\n                                }\n                            }\n                        }\n                    }), Error, 'underscore');\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not allow RxDocument-properties as top-fieldnames (own)","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":318,"column":82},"line":318,"code":"                it('should not allow RxDocument-properties as top-fieldnames (own)', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        description: 'collection as fieldname',\n                        primaryKey: 'collection',\n                        type: 'object',\n                        properties: {\n                            collection: {\n                                type: 'string',\n                                maxLength: 100\n                            }\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not allow RxDocument-properties as top-fieldnames (prototype)","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":333,"column":88},"line":333,"code":"                it('should not allow RxDocument-properties as top-fieldnames (prototype)', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        description: 'populate as fieldname',\n                        primaryKey: 'populate',\n                        type: 'object',\n                        properties: {\n                            populate: {\n                                type: 'string',\n                                maxLength: 100\n                            }\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"throw when no version","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":348,"column":41},"line":348,"code":"                it('throw when no version', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        description: 'schema without version',\n                        type: 'object',\n                        properties: {\n                            'foobar': {\n                                type: 'string'\n                            }\n                        }\n                    } as any), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"throw when version < 0","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":360,"column":42},"line":360,"code":"                it('throw when version < 0', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: -10,\n                        description: 'schema with negative version',\n                        primaryKey: 'foobar',\n                        type: 'object',\n                        properties: {\n                            'foobar': {\n                                type: 'string',\n                                maxLength: 100\n                            }\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"throw when version no number","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":375,"column":48},"line":375,"code":"                it('throw when version no number', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 'foobar',\n                        description: 'save as fieldname',\n                        primaryKey: 'foobar',\n                        properties: {\n                            'foobar': {\n                                type: 'string',\n                                maxLength: 100\n                            }\n                        }\n                    } as any), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"throw when defaults on non-first-level field","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":389,"column":64},"line":389,"code":"                it('throw when defaults on non-first-level field', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        description: 'save as fieldname',\n                        primaryKey: 'foobar',\n                        type: 'object',\n                        properties: {\n                            foobar: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            deeper: {\n                                type: 'object',\n                                properties: {\n                                    name: {\n                                        type: 'string',\n                                        default: 'foobar'\n                                    } as any\n                                }\n                            }\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"throw when _id is not primary","suites":["static",".checkSchema()","negative"],"updatePoint":{"line":413,"column":49},"line":413,"code":"                it('throw when _id is not primary', () => {\n                    assert.throws(() => checkSchema({\n                        title: 'schema',\n                        version: 0,\n                        primaryKey: 'userId',\n                        description: 'save as fieldname',\n                        type: 'object',\n                        properties: {\n                            userId: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            _id: {\n                                type: 'string',\n                            },\n                            firstName: {\n                                type: 'string'\n                            }\n                        },\n                        required: ['firstName']\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should sort array with objects and strings","suites":["static",".fillWithDefaultSettings() / .normalizeRxJsonSchema()"],"updatePoint":{"line":438,"column":58},"line":438,"code":"            it('should sort array with objects and strings', () => {\n                const val = ['firstName', 'lastName', {\n                    name: 2\n                }];\n                const normalized = sortObject(val);\n                assert.deepStrictEqual(val, normalized);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should be the same object","suites":["static",".fillWithDefaultSettings() / .normalizeRxJsonSchema()"],"updatePoint":{"line":445,"column":41},"line":445,"code":"            it('should be the same object', () => {\n                const schema = normalizeRxJsonSchema(schemas.humanNormalizeSchema1);\n                assert.deepStrictEqual(schema, schemas.humanNormalizeSchema1);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should deep sort one schema with different orders to be the same","suites":["static",".fillWithDefaultSettings() / .normalizeRxJsonSchema()"],"updatePoint":{"line":449,"column":80},"line":449,"code":"            it('should deep sort one schema with different orders to be the same', () => {\n                const schema1 = normalizeRxJsonSchema(schemas.humanNormalizeSchema1);\n                const schema2 = normalizeRxJsonSchema(schemas.humanNormalizeSchema2);\n                assert.deepStrictEqual(schema1, schema2);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not sort indexes array in the schema (related with https://github.com/pubkey/rxdb/pull/1695#issuecomment-554636433)","suites":["static",".fillWithDefaultSettings() / .normalizeRxJsonSchema()"],"updatePoint":{"line":454,"column":138},"line":454,"code":"            it('should not sort indexes array in the schema (related with https://github.com/pubkey/rxdb/pull/1695#issuecomment-554636433)', () => {\n                const schema = normalizeRxJsonSchema(schemas.humanWithSimpleAndCompoundIndexes);\n                assert.deepStrictEqual(schema.indexes, schemas.humanWithSimpleAndCompoundIndexes.indexes);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should have added the primaryKey to indexes that did not contain it","suites":["static",".fillWithDefaultSettings() / .normalizeRxJsonSchema()"],"updatePoint":{"line":458,"column":83},"line":458,"code":"            it('should have added the primaryKey to indexes that did not contain it', () => {\n                const schema: RxJsonSchema<any> = fillWithDefaultSettings({\n                    primaryKey: 'id',\n                    version: 0,\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    },\n                    required: ['id'],\n                    indexes: [\n                        'age',\n                        ['foo', 'bar'],\n                        ['bar', 'id', 'foo']\n                    ]\n                });\n                const normalizedSchema = normalizeRxJsonSchema(schema);\n                assert.deepStrictEqual(\n                    normalizedSchema.indexes,\n                    [\n                        ['age', 'id'],\n                        ['foo', 'bar', 'id'],\n                        ['bar', 'id', 'foo']\n                    ]\n                );\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"create human","suites":["static",".create()","positive"],"updatePoint":{"line":489,"column":32},"line":489,"code":"                it('create human', () => {\n                    const schema = createRxSchema(schemas.human);\n                    assert.strictEqual(schema.constructor.name, 'RxSchema');\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"create nested","suites":["static",".create()","positive"],"updatePoint":{"line":493,"column":33},"line":493,"code":"                it('create nested', () => {\n                    const schema = createRxSchema(schemas.nestedHuman);\n                    assert.strictEqual(schema.constructor.name, 'RxSchema');\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"create point","suites":["static",".create()","positive"],"updatePoint":{"line":497,"column":32},"line":497,"code":"                it('create point', () => {\n                    const schema = createRxSchema(schemas.point);\n                    assert.strictEqual(schema.constructor.name, 'RxSchema');\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should have indexes human","suites":["static",".create()","positive"],"updatePoint":{"line":501,"column":45},"line":501,"code":"                it('should have indexes human', () => {\n                    const schema = createRxSchema(schemas.human);\n                    assert.strictEqual(schema.indexes[0][0], 'firstName');\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"broken schema (nostringIndex)","suites":["static",".create()","negative"],"updatePoint":{"line":507,"column":49},"line":507,"code":"                it('broken schema (nostringIndex)', () => {\n                    assert.throws(() => createRxSchema(schemas.noStringIndex), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"first-level field is \"language\" is forbitten","suites":["static",".create()","negative"],"updatePoint":{"line":510,"column":64},"line":510,"code":"                it('first-level field is \"language\" is forbitten', () => {\n                    assert.throws(() => createRxSchema<any>({\n                        title: 'schema',\n                        version: 0,\n                        primaryKey: 'foo',\n                        description: 'dot in fieldname',\n                        type: 'object',\n                        properties: {\n                            foo: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            language: {\n                                type: 'string'\n                            }\n                        }\n                    }), Error);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should contain the field","suites":["static",".getFinalFields()"],"updatePoint":{"line":531,"column":40},"line":531,"code":"            it('should contain the field', () => {\n                const ret = getFinalFields({\n                    version: 0,\n                    primaryKey: 'myField',\n                    type: 'object',\n                    properties: {\n                        myField: {\n                            type: 'string',\n                            maxLength: 100,\n                            final: true\n                        }\n                    }\n                });\n                assert.ok(ret.includes('myField'));\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should contain the primary","suites":["static",".getFinalFields()"],"updatePoint":{"line":546,"column":42},"line":546,"code":"            it('should contain the primary', () => {\n                const ret = getFinalFields({\n                    version: 0,\n                    primaryKey: 'myField',\n                    type: 'object',\n                    properties: {\n                        myField: {\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    }\n                });\n                assert.deepStrictEqual(ret, ['myField']);\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get empty array when current==0","suites":["instance",".getPreviousVersions()"],"updatePoint":{"line":564,"column":47},"line":564,"code":"            it('get empty array when current==0', () => {\n                const schema = createRxSchema({\n                    title: 'schema',\n                    version: 0,\n                    primaryKey: 'foobar',\n                    type: 'object',\n                    properties: {\n                        'foobar': {\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    }\n                });\n                assert.deepStrictEqual(\n                    getPreviousVersions(schema.jsonSchema),\n                    []\n                );\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get valid array when current==5","suites":["instance",".getPreviousVersions()"],"updatePoint":{"line":582,"column":47},"line":582,"code":"            it('get valid array when current==5', () => {\n                const schema = createRxSchema({\n                    title: 'schema',\n                    version: 5,\n                    primaryKey: 'foobar',\n                    type: 'object',\n                    properties: {\n                        'foobar': {\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    }\n                });\n                assert.deepStrictEqual(\n                    getPreviousVersions(schema.jsonSchema),\n                    [0, 1, 2, 3, 4]\n                );\n            });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should hash","suites":["instance",".hash","positive"],"updatePoint":{"line":603,"column":31},"line":603,"code":"                it('should hash', () => {\n                    const schema = createRxSchema(schemas.human);\n                    const hash = schema.hash;\n                    assert.strictEqual(typeof hash, 'string');\n                    assert.ok(hash.length > 5);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should normalize one schema with two different orders and generate for each the same hash","suites":["instance",".hash","positive"],"updatePoint":{"line":609,"column":109},"line":609,"code":"                it('should normalize one schema with two different orders and generate for each the same hash', () => {\n                    const schema1 = createRxSchema(schemas.humanNormalizeSchema1);\n                    const schema2 = createRxSchema(schemas.humanNormalizeSchema2);\n                    const hash1 = schema1.hash;\n                    const hash2 = schema2.hash;\n                    assert.strictEqual(hash1, hash2);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should allow a valid change","suites":["instance",".validateChange()","positive"],"updatePoint":{"line":620,"column":47},"line":620,"code":"                it('should allow a valid change', () => {\n                    const schema = createRxSchema(schemas.human);\n                    const dataBefore = schemaObjects.human();\n                    const dataAfter = clone(dataBefore);\n                    dataAfter.age = 100;\n\n                    schema.validateChange(dataBefore, dataAfter);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not allow to change the primary","suites":["instance",".validateChange()","negative"],"updatePoint":{"line":630,"column":58},"line":630,"code":"                it('should not allow to change the primary', async () => {\n                    const schema = createRxSchema(schemas.primaryHuman);\n                    const dataBefore = schemaObjects.human();\n                    const dataAfter = clone(dataBefore);\n                    dataAfter.passportId = 'foobar';\n\n                    await AsyncTestUtil.assertThrows(\n                        () => schema.validateChange(dataBefore, dataAfter),\n                        'RxError',\n                        'final'\n                    );\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not allow to change a final field","suites":["instance",".validateChange()","negative"],"updatePoint":{"line":642,"column":60},"line":642,"code":"                it('should not allow to change a final field', async () => {\n                    const schema = createRxSchema(schemas.humanFinal);\n                    const dataBefore = schemaObjects.human();\n                    dataBefore.age = 1;\n                    const dataAfter = clone(dataBefore);\n                    dataAfter.age = 100;\n\n                    await AsyncTestUtil.assertThrows(\n                        () => schema.validateChange(dataBefore, dataAfter),\n                        'RxError',\n                        'final'\n                    );\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get firstLevel","suites":["instance",".getSchemaByObjectPath()","positive"],"updatePoint":{"line":659,"column":34},"line":659,"code":"                it('get firstLevel', () => {\n                    const schema = createRxSchema(schemas.human);\n                    const schemaObj = getSchemaByObjectPath(schema.jsonSchema, 'passportId');\n                    assert.strictEqual(schemaObj.type, 'string');\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get deeper","suites":["instance",".getSchemaByObjectPath()","positive"],"updatePoint":{"line":664,"column":30},"line":664,"code":"                it('get deeper', () => {\n                    const schema = createRxSchema(schemas.nestedHuman);\n                    const schemaObj = getSchemaByObjectPath(schema.jsonSchema, 'mainSkill');\n                    assert.ok(schemaObj.properties);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"get nested","suites":["instance",".getSchemaByObjectPath()","positive"],"updatePoint":{"line":669,"column":30},"line":669,"code":"                it('get nested', () => {\n                    const schema = createRxSchema(schemas.nestedHuman);\n                    const schemaObj = getSchemaByObjectPath(schema.jsonSchema, 'mainSkill.name');\n                    assert.strictEqual(schemaObj.type, 'string');\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should fill all unset fields","suites":["instance",".fillObjectWithDefaults()","positive"],"updatePoint":{"line":679,"column":48},"line":679,"code":"                it('should fill all unset fields', () => {\n                    const schema = createRxSchema(schemas.humanDefault);\n                    const data = {\n                        foo: 'bar'\n                    };\n                    const filled = schema.fillObjectWithDefaults(data);\n                    assert.ok(data !== filled);\n                    assert.strictEqual(filled.foo, 'bar');\n                    assert.strictEqual(filled.age, 20);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should not overwrite given values","suites":["instance",".fillObjectWithDefaults()","positive"],"updatePoint":{"line":689,"column":53},"line":689,"code":"                it('should not overwrite given values', () => {\n                    const schema = createRxSchema(schemas.humanDefault);\n                    const data = {\n                        foo: 'bar',\n                        age: 40\n                    };\n                    const data2 = clone(data);\n                    const filled = schema.fillObjectWithDefaults(data);\n                    const filled2 = schema.fillObjectWithDefaults(data2);\n                    assert.ok(data !== filled);\n                    assert.strictEqual(filled.foo, 'bar');\n                    assert.strictEqual(filled.age, 40);\n                    assert.strictEqual(filled2.foo, 'bar');\n                    assert.strictEqual(filled2.age, 40);\n                });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"#590 Strange schema behavior with sub-sub-index","suites":["issues"],"updatePoint":{"line":708,"column":59},"line":708,"code":"        it('#590 Strange schema behavior with sub-sub-index', async () => {\n            const schema: RxJsonSchema<{ id: string, fileInfo: any }> = {\n                version: 0,\n                primaryKey: 'id',\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    fileInfo: {\n                        type: 'object',\n                        properties: {\n                            watch: {\n                                type: 'object',\n                                properties: {\n                                    time: {\n                                        type: 'number',\n                                        minimum: 0,\n                                        maximum: 10000,\n                                        multipleOf: 1\n                                    }\n                                }\n                            }\n                        },\n                    },\n                },\n                indexes: ['fileInfo.watch.time']\n            };\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage()\n            });\n            const cols = await db.addCollections({\n                items: {\n                    schema\n                }\n            });\n\n            await cols.items.insert({\n                id: '1',\n                fileInfo: {\n                    watch: {\n                        time: 1\n                    }\n                }\n            });\n\n            const query = cols.items.find({\n                selector: {\n                    'fileInfo.watch.time': {\n                        $gt: -9999999999999999999999999999\n                    }\n                },\n                sort: [\n                    { 'fileInfo.watch.time': 'asc' }\n                ]\n            });\n\n            const found = await query.exec();\n            assert.strictEqual(found.length, 1);\n            assert.strictEqual(found[0].fileInfo.watch.time, 1);\n            db.destroy();\n        });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"#620 indexes should not be required","suites":["issues"],"updatePoint":{"line":772,"column":47},"line":772,"code":"        it('#620 indexes should not be required', async () => {\n            const mySchema: RxJsonSchema<{ passportId: string, firstName: string; lastName: string; age: number; }> = {\n                version: 0,\n                primaryKey: 'passportId',\n                type: 'object',\n                properties: {\n                    passportId: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    firstName: {\n                        type: 'string'\n                    },\n                    lastName: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    age: {\n                        type: 'integer',\n                        minimum: 0,\n                        maximum: 150\n                    }\n                },\n                indexes: ['lastName']\n            };\n            // create a database\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage()\n            });\n            const collections = await db.addCollections({\n                test: {\n                    schema: mySchema\n                }\n            });\n            await collections.test.insert({\n                passportId: 'foobar',\n                firstName: 'Bob',\n                age: 56\n            });\n            db.destroy();\n        });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"#697 Indexes do not work in objects named \"properties\"","suites":["issues"],"updatePoint":{"line":814,"column":66},"line":814,"code":"        it('#697 Indexes do not work in objects named \"properties\"', async () => {\n            const mySchema: RxJsonSchema<{ id: string; properties: any }> = {\n                version: 0,\n                primaryKey: 'id',\n                type: 'object',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    properties: {\n                        type: 'object',\n                        properties: {\n                            name: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            content: {\n                                type: 'string',\n                                maxLength: 100\n                            }\n                        }\n                    },\n                },\n                indexes: ['properties.name', 'properties.content']\n            };\n\n            // create a database\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage()\n            });\n            const collections = await db.addCollections({\n                test: {\n                    schema: mySchema\n                }\n            });\n\n            await collections.test.insert({\n                id: randomCouchString(12),\n                properties: {\n                    name: 'Title',\n                    content: 'Post content'\n                }\n            });\n\n            db.destroy();\n        });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"#697(2) should also work deep nested","suites":["issues"],"updatePoint":{"line":862,"column":48},"line":862,"code":"        it('#697(2) should also work deep nested', async () => {\n            const mySchema: RxJsonSchema<{ id: string; properties: any; }> = {\n                version: 0,\n                type: 'object',\n                primaryKey: 'id',\n                properties: {\n                    id: {\n                        type: 'string',\n                        maxLength: 100\n                    },\n                    properties: {\n                        type: 'object',\n                        properties: {\n                            name: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            properties: {\n                                type: 'string',\n                                maxLength: 100\n                            }\n                        }\n                    },\n                },\n                indexes: ['properties.name', 'properties.properties']\n            };\n\n            // create a database\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage()\n            });\n            const collections = await db.addCollections({\n                test: {\n                    schema: mySchema\n                }\n            });\n\n            await collections.test.insert({\n                id: randomCouchString(12),\n                properties: {\n                    name: 'Title',\n                    properties: 'Post content'\n                }\n            });\n\n            assert.deepStrictEqual(\n                [\n                    ['properties.name', 'id'],\n                    ['properties.properties', 'id']\n                ],\n                collections.test.schema.indexes\n            );\n\n            db.destroy();\n        });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"#3994 must work with a boolean index","suites":["issues"],"updatePoint":{"line":921,"column":48},"line":921,"code":"        it('#3994 must work with a boolean index', async () => {\n            const db = await createRxDatabase({\n                name: randomCouchString(10),\n                storage: config.storage.getStorage()\n            });\n\n            const mySchema = {\n                'keyCompression': false,\n                'version': 0,\n                'primaryKey': '_id',\n                'type': 'object',\n                'properties': {\n                    '_id': {\n                        'type': 'string',\n                        'maxLength': 100\n                    },\n                    'data': {\n                        'type': 'object'\n                    },\n                    'isNew': {\n                        'type': 'boolean',\n                        'default': false\n                    },\n                    'createdAt': {\n                        'type': 'string',\n                        'format': 'date-time',\n                        'maxLength': 24\n                    },\n                    'updatedAt': {\n                        'type': 'string',\n                        'format': 'date-time',\n                        'maxLength': 24\n                    }\n                },\n                'required': [\n                    '_id',\n                    'data',\n                    'createdAt',\n                    'updatedAt',\n                    'isNew'\n                ],\n                'indexes': [\n                    'createdAt',\n                    'updatedAt',\n                    'isNew'\n                ]\n            };\n            await db.addCollections({\n                test: {\n                    schema: mySchema\n                }\n            });\n\n            db.destroy();\n        });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"w8 a bit","suites":["wait a bit"],"updatePoint":{"line":978,"column":20},"line":978,"code":"        it('w8 a bit', async () => {\n            await AsyncTestUtil.wait(0);\n        });","file":"unit/rx-schema.test.ts","skipped":false,"dir":"test"},{"name":"should sort in the correct order","suites":["RxStorageDexieStatics",".getSortComparator()"],"updatePoint":{"line":38,"column":48},"line":38,"code":"            it('should sort in the correct order', () => {\n                const docA = schemaObjects.human(\n                    randomCouchString(10),\n                    1\n                );\n                const docB = schemaObjects.human(\n                    randomCouchString(10),\n                    2\n                );\n                const query: MangoQuery<HumanDocumentType> = {\n                    selector: {},\n                    sort: [\n                        { age: 'asc' }\n                    ]\n                }\n                const schema = fillWithDefaultSettings(human);\n                const preparedQuery = RxStorageDexieStatics.prepareQuery(\n                    schema,\n                    normalizeMangoQuery(schema, query)\n                );\n                const comparator = RxStorageDexieStatics.getSortComparator<HumanDocumentType>(\n                    humanMinimal as any,\n                    preparedQuery\n                );\n                const sortResult = comparator(docA, docB);\n                assert.strictEqual(sortResult, -1);\n                const sortResultReverse = comparator(docB, docA);\n                assert.strictEqual(sortResultReverse, 1);\n            });","file":"unit/rx-storage-dexie.test.ts","skipped":false,"dir":"test"},{"name":"should find the matching document","suites":["RxStorageDexieStatics",".getQueryMatcher()"],"updatePoint":{"line":69,"column":49},"line":69,"code":"            it('should find the matching document', () => {\n                const docMatching = schemaObjects.human(\n                    randomCouchString(10),\n                    1\n                );\n                const docNotMatching = schemaObjects.human(\n                    randomCouchString(10),\n                    2\n                );\n                const query: MangoQuery = {\n                    selector: {\n                        age: 1\n                    }\n                };\n                const schema = fillWithDefaultSettings(humanMinimal);\n                const preparedQuery = RxStorageDexieStatics.prepareQuery(\n                    schema,\n                    normalizeMangoQuery(schema, query)\n                );\n                const matcher = RxStorageDexieStatics.getQueryMatcher(\n                    schema,\n                    preparedQuery\n                );\n                const matching = matcher(docMatching as any);\n                assert.ok(matching);\n\n                const notMatching = matcher(docNotMatching as any);\n                assert.strictEqual(notMatching, false);\n            });","file":"unit/rx-storage-dexie.test.ts","skipped":false,"dir":"test"},{"name":"should start with the primary key","suites":["helper",".getDexieStoreSchema()"],"updatePoint":{"line":102,"column":49},"line":102,"code":"            it('should start with the primary key', () => {\n                const dexieSchema = getDexieStoreSchema({\n                    primaryKey: 'id',\n                    type: 'object',\n                    version: 0,\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    }\n                });\n                assert.ok(dexieSchema.startsWith('id'));\n            });","file":"unit/rx-storage-dexie.test.ts","skipped":false,"dir":"test"},{"name":"should contains the indexes","suites":["helper",".getDexieStoreSchema()"],"updatePoint":{"line":116,"column":43},"line":116,"code":"            it('should contains the indexes', () => {\n                const dexieSchema = getDexieStoreSchema({\n                    primaryKey: 'id',\n                    type: 'object',\n                    version: 0,\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        age: {\n                            type: 'number'\n                        }\n                    },\n                    indexes: [\n                        ['age', 'id']\n                    ]\n                });\n                assert.ok(dexieSchema.startsWith('id, [age+id]'));\n            });","file":"unit/rx-storage-dexie.test.ts","skipped":false,"dir":"test"},{"name":"should respect a custom index","suites":[".query()"],"updatePoint":{"line":139,"column":41},"line":139,"code":"        it('should respect a custom index', async () => {\n            /**\n             * This test should only run when dexie\n             */\n            assert.strictEqual(config.storage.name, 'dexie');\n\n            const storage = config.storage.getStorage();\n\n            let schema = clone(humanSchemaLiteral) as any;\n            schema.indexes.push(['passportId', 'age']);\n            /*\n                        schema.indexes.push(['age']);\n                        schema.indexes.push(['age', 'passportId']);\n                        schema.indexes.push(['age', 'firstName', 'passportId']);\n                        schema.indexes.push(['firstName', 'age', 'passportId']);\n                        */\n            schema = fillWithDefaultSettings(schema);\n\n            const databaseName = randomCouchString(12);\n            const storageInstance = await storage.createStorageInstance<HumanDocumentType>({\n                databaseInstanceToken: randomCouchString(10),\n                databaseName,\n                collectionName: randomCouchString(12),\n                schema,\n                options: {},\n                multiInstance: false\n            });\n\n            await storageInstance.bulkWrite(\n                new Array(5).fill(0).map(() => {\n                    const data = schemaObjects.human() as any;\n                    data._attachments = {};\n                    data._deleted = false;\n                    data.age = 18;\n                    data._meta = {\n                        lwt: now()\n                    };\n                    data._rev = createRevision(defaultHashFunction, data);\n                    return {\n                        document: data\n                    }\n                }),\n                'dexie-test'\n            );\n\n            // const hasIndexes = await pouch.getIndexes();\n\n            async function analyzeQuery(query: MangoQuery<HumanDocumentType>) {\n                const preparedQuery = storage.statics.prepareQuery(\n                    schema,\n                    normalizeMangoQuery(schema, query)\n                );\n                const queryPlan = preparedQuery.queryPlan;\n                const result = await storageInstance.query(preparedQuery);\n                return {\n                    query,\n                    preparedQuery,\n                    queryPlan,\n                    result: result.documents\n                };\n            }\n\n            const defaultAnalyzed = await analyzeQuery({\n                selector: {},\n                sort: [\n                    { passportId: 'asc' }\n                ]\n            });\n\n            const customIndexAnalyzed = await analyzeQuery({\n                selector: {},\n                sort: [\n                    { passportId: 'asc' }\n                ],\n                index: ['passportId', 'age']\n            });\n\n            // default should use default index\n            assert.deepStrictEqual(\n                defaultAnalyzed.queryPlan.index,\n                ['passportId']\n            );\n\n            // custom should use the custom index\n            (customIndexAnalyzed.query as any).index.forEach((indexKey: string) => {\n                if (indexKey !== 'passportId') {\n                    assert.ok(ensureNotFalsy(customIndexAnalyzed.queryPlan.index).includes(indexKey));\n                }\n            });\n\n            /**\n             * The primaryPath must always be the last index field\n             * to have deterministic sorting.\n             */\n            assert.ok(ensureNotFalsy(customIndexAnalyzed.queryPlan.index).includes('passportId'));\n\n            // both queries should have returned the same documents\n            assert.deepStrictEqual(\n                defaultAnalyzed.result,\n                customIndexAnalyzed.result\n            );\n\n            storageInstance.close();\n        });","file":"unit/rx-storage-dexie.test.ts","skipped":false,"dir":"test"},{"name":"open and close","suites":["RxStorageInstance","creation"],"updatePoint":{"line":172,"column":30},"line":172,"code":"            it('open and close', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n                await storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"open many instances on the same database name","suites":["RxStorageInstance","creation"],"updatePoint":{"line":183,"column":61},"line":183,"code":"            it('open many instances on the same database name', async () => {\n                const databaseName = randomCouchString(12);\n                const amount = 20;\n                const storage = config.storage.getStorage();\n                const instances = await Promise.all(\n                    new Array(amount).fill(0).map(() => storage.createStorageInstance<TestDocType>({\n                        databaseInstanceToken: randomCouchString(10),\n                        databaseName,\n                        collectionName: randomCouchString(12),\n                        schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                        options: {},\n                        multiInstance: false\n                    }))\n                );\n                await Promise.all(instances.map(instance => instance.close()));\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"must throw if keyCompression is set but no key-compression plugin is used","suites":["RxStorageInstance","creation"],"updatePoint":{"line":204,"column":89},"line":204,"code":"            it('must throw if keyCompression is set but no key-compression plugin is used', async () => {\n                const schema = getPseudoSchemaForVersion<TestDocType>(0, 'key');\n                schema.keyCompression = true;\n                let hasThrown = false;\n                try {\n                    await config.storage.getStorage().createStorageInstance<TestDocType>({\n                        databaseInstanceToken: randomCouchString(10),\n                        databaseName: randomCouchString(12),\n                        collectionName: randomCouchString(12),\n                        schema,\n                        options: {},\n                        multiInstance: false\n                    });\n                } catch (error: any) {\n                    const errorString = error.toString();\n                    assert.ok(errorString.includes('UT5'));\n                    hasThrown = true;\n                }\n                assert.ok(hasThrown);\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"must throw if encryption is defined in schema is set but no encryption plugin is used","suites":["RxStorageInstance","creation"],"updatePoint":{"line":229,"column":101},"line":229,"code":"            it('must throw if encryption is defined in schema is set but no encryption plugin is used', async () => {\n                const schema = getPseudoSchemaForVersion<TestDocType>(0, 'key');\n                schema.attachments = {\n                    encrypted: true\n                };\n                let hasThrown = false;\n                try {\n                    await config.storage.getStorage().createStorageInstance<TestDocType>({\n                        databaseInstanceToken: randomCouchString(10),\n                        databaseName: randomCouchString(12),\n                        collectionName: randomCouchString(12),\n                        schema,\n                        options: {},\n                        multiInstance: false\n                    });\n                } catch (error: any) {\n                    const errorString = error.toString();\n                    assert.ok(errorString.includes('UT6'));\n                    hasThrown = true;\n                }\n                assert.ok(hasThrown);\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should write the document","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":253,"column":41},"line":253,"code":"            it('should write the document', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const docData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'barfoo1',\n                    _deleted: false,\n                    _meta: {\n                        lwt: now()\n                    },\n                    _rev: EXAMPLE_REVISION_1,\n                    _attachments: {}\n                };\n                const writeResponse = await storageInstance.bulkWrite(\n                    [{\n                        document: clone(docData)\n                    }],\n                    testContext\n                );\n\n                assert.deepStrictEqual(writeResponse.error, {});\n                const first = getFromObjectOrThrow(writeResponse.success, 'foobar');\n                assert.deepStrictEqual(docData, first);\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should error on conflict","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":285,"column":40},"line":285,"code":"            it('should error on conflict', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const writeData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'barfoo',\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n\n                await storageInstance.bulkWrite(\n                    [{\n                        document: writeData\n                    }],\n                    testContext\n                );\n                const writeResponse = await storageInstance.bulkWrite(\n                    [{\n                        document: writeData\n                    }],\n                    testContext\n                );\n\n                assert.deepStrictEqual(writeResponse.success, {});\n                const first = getFromObjectOrThrow(writeResponse.error, 'foobar');\n                assert.strictEqual(first.status, 409);\n                assert.strictEqual(first.documentId, 'foobar');\n\n                /**\n                 * The conflict error state must contain the\n                 * document state in the database.\n                 * This ensures that we can continue resolving the conflict\n                 * without having to pull the document out of the db first.\n                 */\n                assert.ok(ensureNotFalsy(first.documentInDb).value, writeData.value);\n\n                /**\n                 * The documentInDb must not have any additional attributes.\n                 * Some RxStorage implementations store meta fields \n                 * together with normal document data.\n                 * These fields must never be leaked to 409 conflict errors\n                 */\n                assert.deepStrictEqual(\n                    Object.keys(ensureNotFalsy(first.documentInDb)).sort(),\n                    Object.keys(writeData).sort()\n                );\n\n                assert.ok(first.writeRow);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"when inserting the same document at the same time, the first call must succeed while the seconds has a conflict","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":347,"column":127},"line":347,"code":"            it('when inserting the same document at the same time, the first call must succeed while the seconds has a conflict', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const writeData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'barfoo',\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n\n\n                const [first, second] = await Promise.all([\n                    storageInstance.bulkWrite(\n                        [{\n                            document: Object.assign({}, writeData, {\n                                value: 'first'\n                            })\n                        }],\n                        testContext\n                    ),\n                    storageInstance.bulkWrite(\n                        [{\n                            document: Object.assign({}, writeData, {\n                                value: 'second'\n                            })\n                        }],\n                        testContext\n                    )\n                ]);\n\n                assert.deepStrictEqual(first.error, {});\n                assert.strictEqual(getFromObjectOrThrow(first.success, 'foobar').value, 'first');\n                assert.strictEqual(getFromObjectOrThrow(second.error, 'foobar').status, 409);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should not find the deleted document","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":394,"column":52},"line":394,"code":"            it('should not find the deleted document', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                // make an insert\n                const insertData = {\n                    key: 'foobar',\n                    value: 'barfoo1',\n                    _deleted: false,\n                    _rev: EXAMPLE_REVISION_1,\n                    _attachments: {},\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n                const insertResponse = await storageInstance.bulkWrite(\n                    [{\n                        document: insertData\n                    }],\n                    testContext\n                );\n                assert.deepStrictEqual(insertResponse.error, {});\n                const first = getFromObjectOrThrow(insertResponse.success, 'foobar');\n\n\n                // make an update\n                const updateData = Object.assign({}, insertData, {\n                    value: 'barfoo2',\n                    _rev: EXAMPLE_REVISION_2,\n                    _meta: {\n                        lwt: now()\n                    }\n                });\n                const updateResponse = await storageInstance.bulkWrite(\n                    [{\n                        previous: insertData,\n                        document: updateData\n                    }],\n                    testContext\n                );\n                assert.deepStrictEqual(updateResponse.error, {});\n\n                // make the delete\n                const deleteResponse = await storageInstance.bulkWrite(\n                    [{\n                        previous: updateData,\n                        document: Object.assign({}, first, {\n                            _deleted: true,\n                            _rev: EXAMPLE_REVISION_3,\n                            _meta: {\n                                lwt: now()\n                            }\n                        })\n                    }],\n                    testContext\n                );\n                assert.deepStrictEqual(deleteResponse.error, {});\n\n                const foundDoc = await storageInstance.findDocumentsById(['foobar'], false);\n                assert.deepStrictEqual(foundDoc, {});\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should NOT be able to overwrite a deleted the document","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":463,"column":70},"line":463,"code":"            it('should NOT be able to overwrite a deleted the document', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const docId = 'undeleteMe';\n                const insertResponse = await storageInstance.bulkWrite(\n                    [{\n                        document: {\n                            key: docId,\n                            value: 'barfoo1',\n                            _deleted: false,\n                            _attachments: {},\n                            _rev: EXAMPLE_REVISION_1,\n                            _meta: {\n                                lwt: now()\n                            }\n                        }\n                    }],\n                    testContext\n                );\n\n                assert.deepStrictEqual(insertResponse.error, {});\n                let previous = getFromObjectOrThrow(insertResponse.success, docId);\n\n                const updateResponse = await storageInstance.bulkWrite(\n                    [{\n                        previous: previous,\n                        document: Object.assign({}, previous, {\n                            value: 'barfoo2',\n                            _rev: EXAMPLE_REVISION_2,\n                            _meta: {\n                                lwt: now()\n                            }\n                        })\n                    }],\n                    testContext\n                );\n                assert.deepStrictEqual(updateResponse.error, {});\n                previous = getFromObjectOrThrow(updateResponse.success, docId);\n\n\n                const deleteResponse = await storageInstance.bulkWrite(\n                    [{\n                        previous: previous,\n                        document: Object.assign({}, previous, {\n                            _deleted: true,\n                            _rev: EXAMPLE_REVISION_3,\n                            _meta: {\n                                lwt: now()\n                            }\n                        })\n                    }],\n                    testContext\n                );\n                assert.deepStrictEqual(deleteResponse.error, {});\n                previous = getFromObjectOrThrow(deleteResponse.success, docId);\n\n                /**\n                 * Doing an un-delete without sending the previous state,\n                 * must cause a conflict error.\n                 * \n                 * This is the behavior at the RxStorage level.\n                 * In contrast, RxDB itself will allow to re-insert an already deleted RxDocument.\n                 */\n                const undeleteConflictResponse = await storageInstance.bulkWrite(\n                    [{\n                        document: Object.assign({}, previous, {\n                            _deleted: false,\n                            value: 'aaa',\n                            _rev: EXAMPLE_REVISION_4,\n                            _meta: {\n                                lwt: now()\n                            }\n                        })\n                    }],\n                    testContext\n                );\n                assert.deepStrictEqual(undeleteConflictResponse.success, {});\n\n                /**\n                 * Doing the un-delete with sending the previous,\n                 * should work.\n                 */\n                const undeleteResponse = await storageInstance.bulkWrite(\n                    [{\n                        previous,\n                        document: Object.assign({}, previous, {\n                            _deleted: false,\n                            value: 'aaa',\n                            _rev: EXAMPLE_REVISION_4,\n                            _meta: {\n                                lwt: now()\n                            }\n                        })\n                    }],\n                    testContext\n                );\n                const third = getFromObjectOrThrow(undeleteResponse.success, docId);\n                assert.strictEqual(third.value, 'aaa');\n\n                const foundDoc = await storageInstance.findDocumentsById([docId], false);\n                assert.ok(foundDoc[docId]);\n                assert.deepStrictEqual(foundDoc[docId].value, 'aaa');\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to update the state of a deleted document","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":581,"column":72},"line":581,"code":"            it('should be able to update the state of a deleted document', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n                const docId = 'foobar';\n\n                // insert\n                const docData: RxDocumentData<TestDocType> = {\n                    key: docId,\n                    value: 'barfoo1',\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n                const insertResponse = await storageInstance.bulkWrite([{\n                    document: docData\n                }], testContext);\n                assert.deepStrictEqual(insertResponse.error, {});\n                let previous = insertResponse.success[docId];\n\n                // delete\n                const deleteResponse = await storageInstance.bulkWrite([{\n                    previous,\n                    document: Object.assign({}, docData, {\n                        _deleted: true,\n                        _rev: EXAMPLE_REVISION_2,\n                        _meta: { lwt: now() }\n                    })\n                }], testContext);\n                assert.deepStrictEqual(deleteResponse.error, {});\n                previous = deleteResponse.success[docId];\n\n                // modify deleted\n                const modifyResponse = await storageInstance.bulkWrite([{\n                    previous,\n                    document: Object.assign({}, docData, {\n                        value: 'barfoo2',\n                        _deleted: true,\n                        _rev: EXAMPLE_REVISION_3,\n                        _meta: { lwt: now() }\n                    })\n                }], testContext);\n                assert.deepStrictEqual(modifyResponse.error, {});\n                previous = modifyResponse.success[docId];\n                assert.strictEqual(previous.value, 'barfoo2');\n\n                // check modified\n                const docs = await storageInstance.findDocumentsById([docId], true);\n                const doc = docs[docId];\n                assert.ok(doc);\n                assert.strictEqual(doc.value, 'barfoo2');\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to unset a property","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":643,"column":50},"line":643,"code":"            it('should be able to unset a property', async () => {\n                const schema = getTestDataSchema();\n                schema.required = ['key'];\n\n                const storageInstance = await config.storage.getStorage().createStorageInstance<OptionalValueTestDoc>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: schema as any,\n                    options: {},\n                    multiInstance: false\n                });\n                const docId = 'foobar';\n                const insertData: RxDocumentWriteData<OptionalValueTestDoc> = {\n                    key: docId,\n                    value: 'barfoo1',\n                    _attachments: {},\n                    _deleted: false,\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n                const writeResponse = await storageInstance.bulkWrite(\n                    [{\n                        document: insertData\n                    }],\n                    testContext\n                );\n                const insertResponse = getFromObjectOrThrow(writeResponse.success, docId);\n                const insertDataAfterWrite: RxDocumentData<OptionalValueTestDoc> = Object.assign(\n                    {},\n                    insertResponse,\n                    {\n                        _rev: insertResponse._rev\n                    }\n                );\n\n                const updateResponse = await storageInstance.bulkWrite(\n                    [{\n                        previous: insertDataAfterWrite,\n                        document: {\n                            key: docId,\n                            _attachments: {},\n                            _deleted: false,\n                            _rev: EXAMPLE_REVISION_2,\n                            _meta: {\n                                lwt: now()\n                            }\n                        }\n                    }],\n                    testContext\n                );\n                const updateResponseDoc = getFromObjectOrThrow(updateResponse.success, docId);\n                delete (updateResponseDoc as any)._deleted;\n                delete (updateResponseDoc as any)._rev;\n                delete (updateResponseDoc as any)._meta;\n\n                assert.deepStrictEqual(\n                    updateResponseDoc,\n                    {\n                        key: docId,\n                        _attachments: {}\n                    }\n                )\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to store a complex document with key compression","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":711,"column":79},"line":711,"code":"            it('should be able to store a complex document with key compression', async () => {\n                const databaseName = randomCouchString(12);\n                const schema = fillWithDefaultSettings(schemas.averageSchema());\n                const compressionState = getCompressionStateByRxJsonSchema(schema);\n                const storageInstance = await config.storage.getStorage().createStorageInstance<any>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName,\n                    collectionName: randomCouchString(12),\n                    schema: compressionState.schema,\n                    options: {},\n                    multiInstance: false\n                });\n\n                const docData = Object.assign(\n                    schemaObjects.averageSchema(),\n                    {\n                        _attachments: {},\n                        _deleted: false,\n                        _rev: EXAMPLE_REVISION_1,\n                        _meta: {\n                            lwt: now()\n                        }\n                    }\n                );\n                const compressedDocData = compressObject(\n                    compressionState.table,\n                    docData\n                );\n                const writeResponse = await storageInstance.bulkWrite([\n                    {\n                        document: compressedDocData\n                    }\n                ], testContext);\n                assert.deepStrictEqual(writeResponse.error, {});\n\n                const getDocFromDb = await storageInstance.findDocumentsById([docData.id], false);\n                assert.deepStrictEqual(\n                    getDocFromDb[docData.id],\n                    compressedDocData\n                );\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to do a write where only _meta fields are changed","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":754,"column":80},"line":754,"code":"            it('should be able to do a write where only _meta fields are changed', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const key = 'foobar';\n                let docData: RxDocumentWriteData<TestDocType> = {\n                    key,\n                    value: 'barfoo1',\n                    _attachments: {},\n                    _deleted: false,\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now(),\n                        foobar: 0\n                    }\n                };\n                docData._rev = createRevision(defaultHashFunction, docData);\n\n                const res1 = await storageInstance.bulkWrite(\n                    [{\n                        document: clone(docData)\n                    }],\n                    testContext\n                );\n                assert.deepStrictEqual(res1.error, {});\n\n                // change once\n                let newDocData: RxDocumentWriteData<TestDocType> = clone(docData);\n                newDocData._meta.foobar = 1;\n                newDocData._meta.lwt = now();\n                newDocData._rev = createRevision(defaultHashFunction, newDocData, docData);\n\n                const res2 = await storageInstance.bulkWrite(\n                    [{\n                        previous: docData,\n                        document: clone(newDocData)\n                    }],\n                    testContext\n                );\n                assert.deepStrictEqual(res2.error, {});\n                docData = newDocData;\n\n                // change again\n                newDocData = clone(docData);\n                newDocData._meta.foobar = 2;\n                newDocData._meta.lwt = now();\n                newDocData._rev = createRevision(defaultHashFunction, newDocData, docData);\n                assert.strictEqual(parseRevision(newDocData._rev).height, 3);\n\n                const res3 = await storageInstance.bulkWrite(\n                    [{\n                        previous: docData,\n                        document: clone(newDocData)\n                    }],\n                    testContext\n                );\n                assert.deepStrictEqual(res3.error, {});\n                docData = newDocData;\n\n\n                const viaStorage = await storageInstance.findDocumentsById([key], true);\n                const viaStorageDoc = ensureNotFalsy(viaStorage[key]);\n                assert.strictEqual(parseRevision(viaStorageDoc._rev).height, 3);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to create another instance after a write","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":826,"column":71},"line":826,"code":"            it('should be able to create another instance after a write', async () => {\n                const databaseName = randomCouchString(12);\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName,\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n                const docData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'barfoo1',\n                    _attachments: {},\n                    _deleted: false,\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n                await storageInstance.bulkWrite(\n                    [{\n                        document: clone(docData)\n                    }],\n                    testContext\n                );\n                const storageInstance2 = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName,\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n                await storageInstance2.bulkWrite(\n                    [{\n                        document: Object.assign(\n                            clone(docData),\n                            {\n                                _rev: EXAMPLE_REVISION_2,\n                            }\n                        )\n                    }],\n                    testContext\n                );\n                await Promise.all([\n                    storageInstance.close(),\n                    storageInstance2.close()\n                ]);\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to jump more then 1 revision height in a single write operation","suites":["RxStorageInstance",".bulkWrite()"],"updatePoint":{"line":876,"column":94},"line":876,"code":"            it('should be able to jump more then 1 revision height in a single write operation', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                // insert\n                const docData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'barfoo1',\n                    _deleted: false,\n                    _meta: {\n                        lwt: now()\n                    },\n                    _rev: EXAMPLE_REVISION_1,\n                    _attachments: {}\n                };\n                const insertResponse = await storageInstance.bulkWrite(\n                    [{\n                        document: clone(docData)\n                    }],\n                    testContext\n                );\n                assert.deepStrictEqual(insertResponse.error, {});\n\n                // update\n                const updated = flatCloneDocWithMeta(docData);\n                updated.value = 'barfoo2';\n                updated._meta.lwt = now();\n                updated._rev = EXAMPLE_REVISION_4;\n                const updateResponse = await storageInstance.bulkWrite(\n                    [{\n                        previous: docData,\n                        document: updated\n                    }],\n                    testContext\n                );\n                assert.deepStrictEqual(updateResponse.error, {});\n\n                // find again\n                const getDocFromDb = await storageInstance.findDocumentsById([docData.key], false);\n                const docFromDb = getFromObjectOrThrow(getDocFromDb, docData.key);\n                assert.strictEqual(docFromDb._rev, EXAMPLE_REVISION_4);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should sort in the correct order","suites":["RxStorageInstance",".getSortComparator()"],"updatePoint":{"line":928,"column":48},"line":928,"code":"            it('should sort in the correct order', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<{\n                    _id: string;\n                    age: number;\n                }>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: fillWithDefaultSettings({\n                        version: 0,\n                        type: 'object',\n                        primaryKey: '_id',\n                        properties: {\n                            _id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            age: {\n                                type: 'number'\n                            }\n                        },\n                        required: [\n                            '_id',\n                            'age'\n                        ]\n                    }),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const query: FilledMangoQuery<any> = {\n                    selector: {},\n                    limit: 1000,\n                    sort: [\n                        { age: 'asc' }\n                    ],\n                    skip: 0\n                };\n                const preparedQuery = config.storage.getStorage().statics.prepareQuery(\n                    storageInstance.schema,\n                    query\n                );\n\n                const comparator = config.storage.getStorage().statics.getSortComparator(\n                    storageInstance.schema,\n                    preparedQuery\n                );\n\n                const doc1: any = schemaObjects.human();\n                doc1._id = 'aa';\n                doc1.age = 1;\n                const doc2: any = schemaObjects.human();\n                doc2._id = 'bb';\n                doc2.age = 100;\n\n                // should sort in the correct order\n                assert.deepStrictEqual(\n                    [doc1, doc2],\n                    [doc1, doc2].sort(comparator)\n                );\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should still sort in correct order when docs do not match the selector","suites":["RxStorageInstance",".getSortComparator()"],"updatePoint":{"line":991,"column":86},"line":991,"code":"            it('should still sort in correct order when docs do not match the selector', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getTestDataSchema(),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const matchingValue = 'foobar';\n                const query: FilledMangoQuery<TestDocType> = {\n                    selector: {\n                        value: {\n                            $eq: matchingValue\n                        }\n                    },\n                    sort: [\n                        { key: 'asc' }\n                    ],\n                    skip: 0\n                };\n                const preparedQuery = config.storage.getStorage().statics.prepareQuery(\n                    storageInstance.schema,\n                    query\n                );\n\n                const comparator = config.storage.getStorage().statics.getSortComparator(\n                    storageInstance.schema,\n                    preparedQuery\n                );\n\n                const docs: TestDocType[] = [\n                    {\n                        value: matchingValue,\n                        key: 'aaa'\n                    },\n                    {\n                        value: 'barfoo',\n                        key: 'bbb'\n                    }\n                ];\n\n                const result = comparator(\n                    docs[0],\n                    docs[1]\n\n                );\n                assert.strictEqual(result, -1);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should work with a more complex query","suites":["RxStorageInstance",".getSortComparator()"],"updatePoint":{"line":1043,"column":53},"line":1043,"code":"            it('should work with a more complex query', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getTestDataSchema(),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const matchingValue = 'aaa';\n                const query: FilledMangoQuery<TestDocType> = {\n                    selector: {\n                        $or: [\n                            {\n                                value: matchingValue,\n                                key: matchingValue\n                            },\n                            {\n                                value: 'barfoo',\n                                key: 'barfoo'\n                            }\n                        ],\n                        key: matchingValue\n                    },\n                    sort: [\n                        { key: 'asc' }\n                    ],\n                    skip: 0\n                };\n\n                const preparedQuery = config.storage.getStorage().statics.prepareQuery(\n                    storageInstance.schema,\n                    query\n                );\n\n                const comparator = config.storage.getStorage().statics.getSortComparator(\n                    storageInstance.schema,\n                    preparedQuery\n                );\n\n                const docs: TestDocType[] = [\n                    {\n                        value: matchingValue,\n                        key: matchingValue\n                    },\n                    {\n                        value: 'bbb',\n                        key: 'bbb'\n                    }\n                ];\n\n                const result = comparator(\n                    docs[0],\n                    docs[1]\n\n                );\n                assert.strictEqual(result, -1);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should match the right docs","suites":["RxStorageInstance",".getQueryMatcher()"],"updatePoint":{"line":1106,"column":43},"line":1106,"code":"            it('should match the right docs', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion(0, '_id' as any),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const query: FilledMangoQuery<TestDocType> = {\n                    selector: {\n                        age: {\n                            $gt: 10,\n                            $ne: 50\n                        }\n                    },\n                    sort: [\n                        {\n                            _id: 'asc'\n                        }\n                    ],\n                    skip: 0\n                };\n\n                const queryMatcher = config.storage.getStorage().statics.getQueryMatcher(\n                    storageInstance.schema,\n                    config.storage.getStorage().statics.prepareQuery(\n                        storageInstance.schema,\n                        query\n                    )\n                );\n\n                const doc1: any = schemaObjects.human();\n                doc1._id = 'aa';\n                doc1.age = 1;\n                const doc2: any = schemaObjects.human();\n                doc2._id = 'bb';\n                doc2.age = 100;\n\n                assert.strictEqual(queryMatcher(doc1), false);\n                assert.strictEqual(queryMatcher(doc2), true);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should not match deleted documents","suites":["RxStorageInstance",".getQueryMatcher()"],"updatePoint":{"line":1151,"column":50},"line":1151,"code":"            it('should not match deleted documents', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<{ _id: string }>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<{ _id: string }>(0, '_id' as any),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const query: FilledMangoQuery<{ _id: string }> = {\n                    selector: {},\n                    sort: [\n                        { _id: 'asc' }\n                    ],\n                    skip: 0\n                };\n\n                const queryMatcher = config.storage.getStorage().statics.getQueryMatcher(\n                    storageInstance.schema,\n                    config.storage.getStorage().statics.prepareQuery(\n                        storageInstance.schema,\n                        query\n                    )\n                );\n\n                const doc1: any = schemaObjects.human();\n                doc1._deleted = true;\n                assert.strictEqual(\n                    queryMatcher(doc1),\n                    false\n                );\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should match the nested document","suites":["RxStorageInstance",".getQueryMatcher()"],"updatePoint":{"line":1186,"column":48},"line":1186,"code":"            it('should match the nested document', () => {\n                const schema = getNestedDocSchema();\n                const query: FilledMangoQuery<NestedDoc> = {\n                    selector: {\n                        'nes.ted': {\n                            $eq: 'barfoo'\n                        }\n                    },\n                    sort: [\n                        { id: 'asc' }\n                    ],\n                    skip: 0\n                };\n\n                const queryMatcher = config.storage.getStorage().statics.getQueryMatcher(\n                    schema,\n                    config.storage.getStorage().statics.prepareQuery(\n                        schema,\n                        query\n                    )\n                );\n\n                const notMatchingDoc = {\n                    id: 'foobar',\n                    nes: {\n                        ted: 'xxx'\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n                const matchingDoc = {\n                    id: 'foobar',\n                    nes: {\n                        ted: 'barfoo'\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n\n                assert.strictEqual(\n                    queryMatcher(notMatchingDoc),\n                    false\n                );\n                assert.strictEqual(\n                    queryMatcher(matchingDoc),\n                    true\n                );\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should find all documents","suites":["RxStorageInstance",".query()"],"updatePoint":{"line":1244,"column":41},"line":1244,"code":"            it('should find all documents', async () => {\n                const storageInstance = await config.storage\n                    .getStorage()\n                    .createStorageInstance<{ key: string; value: string; }>({\n                        databaseInstanceToken: randomCouchString(10),\n                        databaseName: randomCouchString(12),\n                        collectionName: randomCouchString(12),\n                        schema: getPseudoSchemaForVersion<{ key: string; value: string; }>(0, 'key'),\n                        options: {},\n                        multiInstance: false\n                    });\n\n                const writeData = {\n                    key: 'foobar',\n                    value: 'barfoo',\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n\n                await storageInstance.bulkWrite(\n                    [{\n                        document: writeData\n                    }],\n                    testContext\n                );\n\n\n                const writeData2 = {\n                    key: 'foobar2',\n                    value: 'barfoo2',\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n                await storageInstance.bulkWrite(\n                    [{\n                        document: writeData2\n                    }],\n                    testContext\n                );\n\n                const preparedQuery = config.storage.getStorage().statics.prepareQuery(\n                    storageInstance.schema,\n                    {\n                        selector: {},\n                        sort: [{ key: 'asc' }],\n                        skip: 0\n                    }\n                );\n                const allDocs = await storageInstance.query(preparedQuery);\n                const first = allDocs.documents[0];\n                assert.ok(first);\n                assert.strictEqual(first.value, 'barfoo');\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should sort in the correct order","suites":["RxStorageInstance",".query()"],"updatePoint":{"line":1307,"column":48},"line":1307,"code":"            it('should sort in the correct order', async () => {\n                const storageInstance = await config.storage\n                    .getStorage()\n                    .createStorageInstance<{ key: string; value: string; }>({\n                        databaseInstanceToken: randomCouchString(10),\n                        databaseName: randomCouchString(12),\n                        collectionName: randomCouchString(12),\n                        schema: getTestDataSchema(),\n                        options: {},\n                        multiInstance: false\n                    });\n\n                await storageInstance.bulkWrite([\n                    {\n                        document: getWriteData({ value: 'a' })\n                    },\n                    {\n                        document: getWriteData({ value: 'b' })\n                    },\n                    {\n                        document: getWriteData({ value: 'c' })\n                    },\n                ], testContext);\n\n                const preparedQuery = config.storage.getStorage().statics.prepareQuery(\n                    storageInstance.schema,\n                    {\n                        selector: {},\n                        sort: [\n                            { value: 'desc' }\n                        ],\n                        skip: 0\n                    }\n                );\n                const allDocs = await storageInstance.query(preparedQuery);\n\n                assert.strictEqual(allDocs.documents[0].value, 'c');\n                assert.strictEqual(allDocs.documents[1].value, 'b');\n                assert.strictEqual(allDocs.documents[2].value, 'a');\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should have the same deterministic order of .query() and .getSortComparator()","suites":["RxStorageInstance",".query()"],"updatePoint":{"line":1353,"column":93},"line":1353,"code":"            it('should have the same deterministic order of .query() and .getSortComparator()', async () => {\n                const schema: RxJsonSchema<RxDocumentData<RandomDoc>> = fillWithDefaultSettings({\n                    version: 0,\n                    primaryKey: 'id',\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        equal: {\n                            type: 'string',\n                            maxLength: 20,\n                            enum: ['foobar']\n                        },\n                        increment: {\n                            type: 'number',\n                            minimum: 0,\n                            maximum: 1000,\n                            multipleOf: 1\n                        },\n                        random: {\n                            type: 'string',\n                            maxLength: 100\n                        }\n                    },\n                    indexes: [\n                        /**\n                         * RxDB wil always append the primaryKey to an index\n                         * if the primaryKey was not used in the index before.\n                         * This ensures we have a deterministic sorting when querying documents\n                         * from that index.\n                         */\n                        ['equal', 'id'],\n                        ['increment', 'id'],\n                        ['random', 'id'],\n                        [\n                            'equal',\n                            'increment',\n                            'id'\n                        ]\n                    ],\n                    required: [\n                        'id',\n                        'equal',\n                        'increment',\n                        'random'\n                    ]\n                });\n                const storageInstance = await config.storage\n                    .getStorage()\n                    .createStorageInstance<RandomDoc>({\n                        databaseInstanceToken: randomCouchString(10),\n                        databaseName: randomCouchString(12),\n                        collectionName: randomCouchString(12),\n                        schema,\n                        options: {},\n                        multiInstance: false\n                    });\n\n                const docData: RxDocumentWriteData<RandomDoc>[] = new Array(6)\n                    .fill(0)\n                    .map((_x, idx) => ({\n                        id: randomString(10),\n                        equal: 'foobar',\n                        random: randomString(10),\n                        increment: idx + 1,\n                        _deleted: false,\n                        _attachments: {},\n                        _rev: EXAMPLE_REVISION_1,\n                        _meta: {\n                            lwt: now()\n                        }\n                    }));\n                const writeResponse: RxStorageBulkWriteResponse<RandomDoc> = await storageInstance.bulkWrite(\n                    docData.map(d => ({ document: d })),\n                    testContext\n                );\n                if (Object.keys(writeResponse.error).length > 0) {\n                    throw new Error('could not save');\n                }\n                const docs = Object.values(writeResponse.success);\n\n                async function testQuery(query: FilledMangoQuery<RandomDoc>): Promise<void> {\n                    const preparedQuery = config.storage.getStorage().statics.prepareQuery(\n                        storageInstance.schema,\n                        query\n                    );\n                    const docsViaQuery = (await storageInstance.query(preparedQuery)).documents;\n                    const sortComparator = config.storage.getStorage().statics.getSortComparator(\n                        storageInstance.schema,\n                        preparedQuery\n                    );\n                    const docsViaSort = shuffleArray(docs).sort(sortComparator);\n                    assert.deepStrictEqual(docsViaQuery, docsViaSort);\n                }\n                const queries: FilledMangoQuery<RandomDoc>[] = [\n                    {\n                        selector: {},\n                        sort: [\n                            { id: 'asc' }\n                        ],\n                        skip: 0\n                    },\n                    {\n                        selector: {},\n                        sort: [\n                            { equal: 'asc' },\n                            /**\n                             * RxDB will always append the primaryKey as last sort parameter\n                             * if the primary key is not used in the sorting before.\n                             */\n                            { id: 'asc' }\n                        ],\n                        skip: 0\n                    },\n                    {\n                        selector: {},\n                        sort: [\n                            { increment: 'desc' },\n                            { id: 'asc' }\n                        ],\n                        skip: 0\n                    },\n                    {\n                        selector: {},\n                        sort: [\n                            { equal: 'asc' },\n                            { increment: 'desc' },\n                            { id: 'asc' }\n                        ],\n                        skip: 0\n                    }\n                ];\n                for (const query of queries) {\n                    await testQuery(query);\n                }\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to search over a nested object","suites":["RxStorageInstance",".query()"],"updatePoint":{"line":1493,"column":61},"line":1493,"code":"            it('should be able to search over a nested object', async () => {\n                const schema = getNestedDocSchema();\n                const storageInstance = await config.storage\n                    .getStorage()\n                    .createStorageInstance<NestedDoc>({\n                        databaseInstanceToken: randomCouchString(10),\n                        databaseName: randomCouchString(12),\n                        collectionName: randomCouchString(12),\n                        schema,\n                        options: {},\n                        multiInstance: false\n                    });\n                const insertResult = await storageInstance.bulkWrite([\n                    {\n                        document: {\n                            id: 'foobar',\n                            nes: {\n                                ted: 'barfoo'\n                            },\n                            _deleted: false,\n                            _attachments: {},\n                            _rev: EXAMPLE_REVISION_1,\n                            _meta: {\n                                lwt: now()\n                            }\n                        }\n                    }\n                ], testContext);\n                assert.deepStrictEqual(insertResult.error, {});\n\n                const preparedQuery = config.storage.getStorage().statics.prepareQuery<NestedDoc>(\n                    schema,\n                    {\n                        selector: {\n                            'nes.ted': {\n                                $eq: 'barfoo'\n                            }\n                        },\n                        sort: [\n                            { 'nes.ted': 'asc' },\n                            { id: 'asc' }\n                        ],\n                        skip: 0\n                    }\n                );\n\n                const results = await storageInstance.query(preparedQuery);\n                assert.strictEqual(results.documents.length, 1);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"querying many documents should work","suites":["RxStorageInstance",".query()"],"updatePoint":{"line":1548,"column":51},"line":1548,"code":"            it('querying many documents should work', async () => {\n                const schema = getTestDataSchema();\n                const storageInstance = await config.storage\n                    .getStorage()\n                    .createStorageInstance<TestDocType>({\n                        databaseInstanceToken: randomCouchString(10),\n                        databaseName: randomCouchString(12),\n                        collectionName: randomCouchString(12),\n                        schema,\n                        options: {},\n                        multiInstance: false\n                    });\n\n                const amount = 100;\n\n                await storageInstance.bulkWrite(\n                    new Array(amount)\n                        .fill(0)\n                        .map((_v, idx) => ({\n                            document: getWriteData({\n                                key: idx.toString().padStart(5, '0') + '-' + randomString(10),\n                                value: idx + ''\n                            })\n                        })),\n                    testContext\n                );\n\n                const preparedQuery = config.storage.getStorage().statics.prepareQuery<TestDocType>(\n                    schema,\n                    {\n                        selector: {},\n                        skip: 0,\n                        sort: [\n                            { key: 'asc' }\n                        ]\n                    }\n                );\n                const results = await storageInstance.query(preparedQuery);\n                assert.strictEqual(results.documents.length, amount);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should find the documents","suites":["RxStorageInstance",".findDocumentsById()"],"updatePoint":{"line":1592,"column":41},"line":1592,"code":"            it('should find the documents', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const docData = {\n                    key: 'foobar',\n                    value: 'barfoo',\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n                await storageInstance.bulkWrite(\n                    [{\n                        document: docData\n                    }],\n                    testContext\n                );\n\n                const found = await storageInstance.findDocumentsById(['foobar'], false);\n                const foundDoc = getFromObjectOrThrow(found, 'foobar');\n                assert.deepStrictEqual(foundDoc, docData);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should find deleted documents","suites":["RxStorageInstance",".findDocumentsById()"],"updatePoint":{"line":1625,"column":45},"line":1625,"code":"            it('should find deleted documents', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const insertResult = await storageInstance.bulkWrite(\n                    [{\n                        document: {\n                            key: 'foobar',\n                            value: 'barfoo',\n                            _deleted: false,\n                            _attachments: {},\n                            _rev: EXAMPLE_REVISION_1,\n                            _meta: {\n                                lwt: now()\n                            }\n                        }\n                    }],\n                    testContext\n                );\n                const previous = getFromObjectOrThrow(insertResult.success, 'foobar');\n\n                await storageInstance.bulkWrite(\n                    [{\n                        previous,\n                        document: {\n                            key: 'foobar',\n                            value: 'barfoo2',\n                            _deleted: true,\n                            _attachments: {},\n                            _rev: EXAMPLE_REVISION_2,\n                            _meta: {\n                                lwt: now()\n                            }\n                        }\n                    }],\n                    testContext\n                );\n\n                const found = await storageInstance.findDocumentsById(['foobar'], true);\n                const foundDeleted = getFromObjectOrThrow(found, 'foobar');\n\n                // even on deleted documents, we must get the other properties.\n                assert.strictEqual(foundDeleted.value, 'barfoo2');\n                assert.strictEqual(foundDeleted._deleted, true);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"if withDeleted=true then even the non-deleted document must be found","suites":["RxStorageInstance",".findDocumentsById()"],"updatePoint":{"line":1678,"column":84},"line":1678,"code":"            it('if withDeleted=true then even the non-deleted document must be found', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const insertResult = await storageInstance.bulkWrite(\n                    [\n                        {\n                            document: {\n                                key: 'del',\n                                value: 'barfoo',\n                                _deleted: false,\n                                _attachments: {},\n                                _rev: EXAMPLE_REVISION_1,\n                                _meta: {\n                                    lwt: now()\n                                }\n                            }\n                        },\n                        {\n                            document: {\n                                key: 'non-del',\n                                value: 'barfoo',\n                                _deleted: false,\n                                _attachments: {},\n                                _rev: EXAMPLE_REVISION_1,\n                                _meta: {\n                                    lwt: now()\n                                }\n                            }\n                        }\n                    ],\n                    testContext\n                );\n                const previous = getFromObjectOrThrow(insertResult.success, 'del');\n                const deleteWriteResult = await storageInstance.bulkWrite(\n                    [{\n                        previous,\n                        document: {\n                            key: 'del',\n                            value: 'barfoo',\n                            _deleted: true,\n                            _attachments: {},\n                            _rev: EXAMPLE_REVISION_2,\n                            _meta: {\n                                lwt: now()\n                            }\n                        }\n                    }],\n                    testContext\n                );\n                assert.deepStrictEqual(deleteWriteResult.error, {});\n\n                const found = await storageInstance.findDocumentsById([\n                    'del',\n                    'non-del'\n                ], true);\n\n                assert.strictEqual(\n                    Object.keys(found).length,\n                    2\n                );\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should get the latest change","suites":["RxStorageInstance",".getChangedDocumentsSince()"],"updatePoint":{"line":1750,"column":44},"line":1750,"code":"            it('should get the latest change', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<{ key: string }>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n                let checkpoint: any;\n                async function getChanges(): Promise<RxDocumentData<{ key: string }>[]> {\n                    const res = await storageInstance.getChangedDocumentsSince(10, checkpoint);\n                    if (res.documents.length > 0) {\n                        checkpoint = res.checkpoint;\n                    }\n                    return res.documents;\n                }\n\n                // should not return anything if nothing has happened\n                const docsEmpty = await getChanges();\n                assert.strictEqual(docsEmpty.length, 0);\n\n                // insert one\n                const insertResult = await storageInstance.bulkWrite([\n                    {\n                        document: {\n                            key: 'foobar',\n                            _deleted: false,\n                            _attachments: {},\n                            _rev: EXAMPLE_REVISION_1,\n                            _meta: {\n                                lwt: now()\n                            }\n                        }\n                    }\n                ], testContext);\n                const docsAfterInsert = await getChanges();\n                assert.strictEqual(docsAfterInsert.length, 1);\n                assert.strictEqual(docsAfterInsert[0].key, 'foobar');\n\n\n                /**\n                 * When there are no resulting documents on\n                 * a call to getChangedDocumentsSince(),\n                 * the exact same given checkpoint must be returned.\n                 * By doing this, we can remove much complexity everywhere else\n                 * when we work with checkpoints.\n                 */\n                const checkpointTest = checkpoint;\n                const emptyResult = await storageInstance.getChangedDocumentsSince(10, checkpointTest);\n                assert.strictEqual(emptyResult.documents.length, 0);\n                assert.deepStrictEqual(emptyResult.checkpoint, checkpointTest);\n\n                // the checkpoint must match the checkpoint-schema of the RxStorage.statics\n                const checkpointSchema = config.storage.getStorage().statics.checkpointSchema;\n                const ajv = new Ajv({\n                    strict: false\n                });\n                const validator = ajv.compile(checkpointSchema);\n                const isValid = validator(checkpointTest);\n                assert.ok(isValid);\n\n\n                // delete one\n                await storageInstance.bulkWrite([\n                    {\n                        previous: getFromObjectOrThrow(insertResult.success, 'foobar'),\n                        document: {\n                            key: 'foobar',\n                            _deleted: true,\n                            _attachments: {},\n                            _rev: EXAMPLE_REVISION_2,\n                            _meta: {\n                                lwt: now()\n                            }\n                        }\n                    }\n                ], testContext);\n                const docsAfterDelete = await getChanges();\n                assert.strictEqual(docsAfterDelete.length, 1);\n                assert.strictEqual(docsAfterDelete[0].key, 'foobar');\n                assert.strictEqual(docsAfterDelete[0]._deleted, true);\n\n                // get only the last change when requesting with empty checkpoint\n                const resTotal = await storageInstance.getChangedDocumentsSince(100);\n                assert.strictEqual(resTotal.documents.length, 1);\n                assert.strictEqual(resTotal.documents[0].key, 'foobar');\n                assert.strictEqual(resTotal.documents[0]._deleted, true);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should return the correct amount of documents","suites":["RxStorageInstance",".getChangedDocumentsSince()"],"updatePoint":{"line":1841,"column":61},"line":1841,"code":"            it('should return the correct amount of documents', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getTestDataSchema(),\n                    options: {},\n                    multiInstance: false\n                });\n\n                let previous: any;\n                const insertResult = await storageInstance.bulkWrite([\n                    {\n                        document: getWriteData({ key: 'foobar', value: '0' })\n                    },\n                    // also add another random document\n                    {\n                        document: getWriteData()\n                    }\n                ], testContext);\n                assert.deepStrictEqual(insertResult.error, {});\n                previous = getFromObjectOrThrow(insertResult.success, 'foobar');\n\n                // update the document many times\n                let t = 0;\n                while (t < 10) {\n                    t++;\n                    const newDoc = clone(previous);\n                    newDoc.value = t + '';\n                    const newRev = createRevision(defaultHashFunction, newDoc, previous);\n                    newDoc._rev = newRev;\n                    newDoc._meta.lwt = now();\n                    const updateResult = await storageInstance.bulkWrite([\n                        {\n                            previous,\n                            document: newDoc\n                        }\n                    ], testContext);\n                    assert.deepStrictEqual(updateResult.error, {});\n                    previous = getFromObjectOrThrow(updateResult.success, 'foobar');\n                }\n\n                // should return both documents when called without checkpoint\n                const resultWithoutCheckpoint = await storageInstance.getChangedDocumentsSince(10);\n                assert.strictEqual(resultWithoutCheckpoint.documents.length, 2);\n                // the foobar-doc must have the latest value\n                const foobarRow = resultWithoutCheckpoint.documents.find(doc => doc.key === 'foobar');\n                assert.strictEqual(ensureNotFalsy(foobarRow).value, '10');\n\n                // insert many more documents\n                const insertManyResult = await storageInstance.bulkWrite(\n                    new Array(10)\n                        .fill(0)\n                        .map(() => ({ document: getWriteData() })),\n                    testContext\n                );\n                assert.deepStrictEqual(insertManyResult.error, {});\n\n                // should return both documents when called without checkpoint\n                const resultManyWithoutCheckpoint = await storageInstance.getChangedDocumentsSince(100);\n                assert.strictEqual(resultManyWithoutCheckpoint.documents.length, 12);\n\n\n                // first get 5 and then another 5 and then again.\n                const resultFirstFive = await storageInstance.getChangedDocumentsSince(5);\n                const resultSecondFive = await storageInstance.getChangedDocumentsSince(5, resultFirstFive.checkpoint);\n                const resultThirdFive = await storageInstance.getChangedDocumentsSince(5, resultSecondFive.checkpoint);\n                assert.strictEqual(resultFirstFive.documents.length + resultSecondFive.documents.length + resultThirdFive.documents.length, 12);\n                const resultFourthFive = await storageInstance.getChangedDocumentsSince(5, resultThirdFive.checkpoint);\n                assert.strictEqual(resultFourthFive.documents.length, 0);\n\n\n                // delete the document\n                const newDoc = clone(previous);\n                newDoc.value = t + '';\n                newDoc._deleted = true;\n                newDoc._meta.lwt = now();\n                const newRev = createRevision(defaultHashFunction, newDoc, previous);\n                newDoc._rev = newRev;\n                const deleteResult = await storageInstance.bulkWrite([\n                    {\n                        previous,\n                        document: newDoc\n                    }\n                ], testContext);\n                assert.deepStrictEqual(deleteResult.error, {});\n\n                const resultAfterDelete = await storageInstance.getChangedDocumentsSince(5, resultThirdFive.checkpoint);\n                assert.strictEqual(resultAfterDelete.documents.length, 1);\n                assert.strictEqual(resultAfterDelete.documents[0]._deleted, true);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to correctly itterate over the checkpoints","suites":["RxStorageInstance",".getChangedDocumentsSince()"],"updatePoint":{"line":1934,"column":73},"line":1934,"code":"            it('should be able to correctly itterate over the checkpoints', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getTestDataSchema(),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const writeAmount = config.isFastMode() ? 40 : 100;\n                await storageInstance.bulkWrite(\n                    new Array(writeAmount / 5)\n                        .fill(0)\n                        .map(() => ({ document: getWriteData() })),\n                    testContext\n                );\n                let writesDone = writeAmount / 5;\n                let lastCheckpoint: any;\n                const docs: ById<RxDocumentData<TestDocType>> = {};\n\n                let fetchRuns = 0;\n                while (Object.keys(docs).length < writeAmount) {\n                    fetchRuns++;\n                    const result = await storageInstance.getChangedDocumentsSince(\n                        writeAmount / 10,\n                        lastCheckpoint\n                    );\n                    result.documents.forEach(doc => {\n                        const id = doc.key;\n                        docs[id] = doc;\n                    });\n                    lastCheckpoint = result.checkpoint;\n                    if (writesDone < writeAmount) {\n                        await storageInstance.bulkWrite(\n                            new Array(writeAmount / 5)\n                                .fill(0)\n                                .map(() => ({ document: getWriteData() })),\n                            testContext\n                        );\n                        writesDone = writesDone + (writeAmount / 5);\n                    }\n                }\n\n                assert.strictEqual(fetchRuns, 10);\n                assert.strictEqual(Object.keys(docs).length, writeAmount);\n                assert.strictEqual(writesDone, writeAmount);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should emit exactly one event on write","suites":["RxStorageInstance",".changeStream()"],"updatePoint":{"line":1986,"column":54},"line":1986,"code":"            it('should emit exactly one event on write', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const emitted: EventBulk<RxStorageChangeEvent<TestDocType>, any>[] = [];\n                const sub = storageInstance.changeStream()\n                    .pipe(\n                        /**\n                         * Ensure the observable of changeStream()\n                         * is compatible with rxjs operators.\n                         */\n                        map(x => x),\n                        filter(() => true)\n                    )\n                    .subscribe(x => {\n                        emitted.push(x);\n                    });\n\n                const writeData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'one',\n                    _deleted: false,\n                    _rev: EXAMPLE_REVISION_1,\n                    _attachments: {},\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n\n                const context = randomCouchString();\n\n                // insert\n                await storageInstance.bulkWrite([{\n                    document: writeData\n                }], context);\n\n                /**\n                 * Do not await any time after the insert.\n                 * By definition, a call to bulkWrite()\n                 * must have emitted all of its resulting events\n                 * BEFORE the call to bulkWrite() returns.\n                 */\n\n                assert.strictEqual(emitted.length, 1);\n                assert.strictEqual(emitted[0].events.length, 1);\n\n                // should contain the _meta data\n                assert.ok((emitted)[0].events[0].documentData._meta.lwt);\n\n                /**\n                 * Using the checkpoint from the event must not return any newer documents.\n                 * This ensures that during replication, we can continue from the given checkpoint\n                 * without missing out any document writes.\n                 */\n                await storageInstance.bulkWrite(\n                    new Array(10).fill(0).map(() => ({ document: getWriteData() })),\n                    context\n                );\n                const lastEvent = lastOfArray(emitted);\n\n                assert.strictEqual(\n                    lastEvent.context,\n                    context\n                );\n\n                /**\n                 * We cannot just use the checkpoint of the last event,\n                 * because by definition, the checkpoints must be stacked up\n                 * so that they are compatible with the sharding RxStorage.\n                 */\n                const lastCheckpoint = stackCheckpoints(\n                    emitted.map(ev => ev.checkpoint)\n                );\n                const emptyResult = await storageInstance.getChangedDocumentsSince(\n                    100,\n                    lastCheckpoint\n                );\n                assert.strictEqual(\n                    emptyResult.documents.length,\n                    0\n                );\n\n\n                sub.unsubscribe();\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should emit all events","suites":["RxStorageInstance",".changeStream()"],"updatePoint":{"line":2078,"column":38},"line":2078,"code":"            it('should emit all events', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const emitted: EventBulk<RxStorageChangeEvent<RxDocumentData<TestDocType>>, any>[] = [];\n                const sub = storageInstance.changeStream().subscribe(x => {\n                    emitted.push(x);\n                });\n\n                let previous: RxDocumentData<TestDocType> | undefined;\n                const writeData = {\n                    key: 'foobar',\n                    value: 'one',\n                    _rev: EXAMPLE_REVISION_1,\n                    _deleted: false,\n                    _attachments: {},\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n\n                // insert\n                const firstWriteResult = await storageInstance.bulkWrite([{\n                    previous,\n                    document: writeData\n                }], testContext);\n                previous = getFromObjectOrThrow(firstWriteResult.success, writeData.key);\n\n                // update\n                const originalBeforeUpdate = clone(writeData);\n                const updateResult = await storageInstance.bulkWrite([{\n                    previous,\n                    document: Object.assign({}, writeData, {\n                        _rev: EXAMPLE_REVISION_2,\n                        _meta: {\n                            lwt: now()\n                        }\n                    })\n                }], testContext);\n                previous = getFromObjectOrThrow(updateResult.success, writeData.key);\n\n                // should not mutate the input or add additional properties to output\n                originalBeforeUpdate._rev = (previous as any)._rev;\n                originalBeforeUpdate._meta = (previous as any)._meta;\n                assert.deepStrictEqual(originalBeforeUpdate, previous);\n\n                // delete\n                const deleteBulkWriteResponse = await storageInstance.bulkWrite([{\n                    previous,\n                    document: Object.assign({}, writeData, {\n                        _rev: EXAMPLE_REVISION_3,\n                        _deleted: true,\n                        _meta: {\n                            lwt: now()\n                        }\n                    })\n                }], testContext);\n                assert.deepStrictEqual(deleteBulkWriteResponse.error, {});\n\n                await waitUntil(() => {\n                    return flattenEvents(emitted).length === 3;\n                });\n                const emittedEvents = flattenEvents(emitted);\n                const lastEvent = lastOfArray(emittedEvents);\n                if (!lastEvent) {\n                    throw new Error('missing last event');\n                }\n\n                /**\n                 * The previous doc data must still contain the given revision height.\n                 * This changed because in the past we increased the rev height\n                 * to be compliant with strange PouchDB behavior.\n                 */\n                const lastRevision = parseRevision(ensureNotFalsy(lastEvent.previousDocumentData)._rev);\n                assert.strictEqual(lastRevision.height, 2);\n\n                assert.strictEqual(lastEvent.operation, 'DELETE');\n                assert.ok(lastEvent.previousDocumentData);\n\n                sub.unsubscribe();\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"it should not emit an empty eventBulk when the write had only errors","suites":["RxStorageInstance",".changeStream()"],"updatePoint":{"line":2166,"column":84},"line":2166,"code":"            it('it should not emit an empty eventBulk when the write had only errors', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const emitted: EventBulk<RxStorageChangeEvent<RxDocumentData<TestDocType>>, any>[] = [];\n                const sub = storageInstance.changeStream().subscribe(x => {\n                    emitted.push(x);\n                });\n\n                const writeData = {\n                    key: 'foobar',\n                    value: 'one',\n                    _rev: EXAMPLE_REVISION_1,\n                    _deleted: false,\n                    _attachments: {},\n                    _meta: {\n                        lwt: now()\n                    }\n                };\n\n                // insert\n                const firstWriteResult = await storageInstance.bulkWrite([{\n                    document: writeData\n                }], testContext);\n                assert.deepStrictEqual(firstWriteResult.error, {});\n\n                // insert again to cause conflict error\n                const secondWriteResult = await storageInstance.bulkWrite([{\n                    document: writeData\n                }], testContext);\n                assert.deepStrictEqual(secondWriteResult.success, {});\n\n                assert.strictEqual(emitted.length, 1);\n                assert.strictEqual(emitted[0].events.length, 1);\n\n                sub.unsubscribe();\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to store and retrieve an attachment","suites":["RxStorageInstance","attachments"],"updatePoint":{"line":2215,"column":66},"line":2215,"code":"            it('should be able to store and retrieve an attachment', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: Object.assign(\n                        getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                        {\n                            attachments: {}\n                        }\n                    ),\n                    options: {},\n                    multiInstance: false\n                });\n                const attachmentData = new Array(20).fill('a').join('');\n\n\n                const dataBlobBuffer = blobBufferUtil.createBlobBuffer(\n                    attachmentData,\n                    'text/plain'\n                );\n                const dataStringBase64 = await blobBufferUtil.toBase64String(dataBlobBuffer);\n                const attachmentHash = await hashAttachmentData(dataStringBase64);\n                const dataLength = getAttachmentSize(dataStringBase64);\n\n                const writeData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'one',\n                    _rev: EXAMPLE_REVISION_1,\n                    _deleted: false,\n                    _meta: {\n                        lwt: now()\n                    },\n                    _attachments: {\n                        foo: {\n                            digest: 'md5-' + attachmentHash,\n                            length: dataLength,\n                            data: dataStringBase64,\n                            type: 'text/plain'\n                        }\n                    }\n                };\n                await writeSingle<TestDocType>(\n                    storageInstance,\n                    {\n                        document: writeData\n                    },\n                    testContext\n                );\n\n                const attachmentDataAfter = await storageInstance.getAttachmentData('foobar', 'foo');\n                assert.strictEqual(attachmentDataAfter, dataStringBase64);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should return the correct attachment object on all document fetch methods","suites":["RxStorageInstance","attachments"],"updatePoint":{"line":2270,"column":89},"line":2270,"code":"            it('should return the correct attachment object on all document fetch methods', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: Object.assign(\n                        getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                        {\n                            attachments: {}\n                        }\n                    ),\n                    options: {},\n                    multiInstance: false\n                });\n                const emitted: EventBulk<RxStorageChangeEvent<any>, any>[] = [];\n                const sub = storageInstance.changeStream().subscribe(x => {\n                    emitted.push(x);\n                });\n\n                const attachmentData = new Array(20).fill('a').join('');\n                const dataBlobBuffer = blobBufferUtil.createBlobBuffer(\n                    attachmentData,\n                    'text/plain'\n                );\n\n                const dataStringBase64 = await blobBufferUtil.toBase64String(dataBlobBuffer);\n                const attachmentHash = await hashAttachmentData(dataStringBase64);\n                const dataLength = getAttachmentSize(dataStringBase64);\n\n                const writeData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'one',\n                    _rev: EXAMPLE_REVISION_1,\n                    _deleted: false,\n                    _meta: {\n                        lwt: now()\n                    },\n                    _attachments: {\n                        foo: {\n                            digest: 'md5-' + attachmentHash,\n                            length: dataLength,\n                            data: dataStringBase64,\n                            type: 'text/plain'\n                        }\n                    }\n                };\n\n\n                const writeResult = await writeSingle<TestDocType>(\n                    storageInstance,\n                    {\n                        document: writeData\n                    },\n                    testContext\n                );\n                await waitUntil(() => flattenEvents(emitted).length === 1);\n\n                assert.strictEqual(writeResult._attachments.foo.type, 'text/plain');\n                assert.strictEqual(writeResult._attachments.foo.digest, 'md5-' + attachmentHash);\n\n                /**\n                 * When getting the document from the storage again,\n                 * it should contain the same attachment digest and length\n                 */\n                const docFromStorage = await getSingleDocument(\n                    storageInstance,\n                    'foobar'\n                );\n                assert.strictEqual(\n                    writeResult._attachments.foo.digest,\n                    ensureNotFalsy(docFromStorage)._attachments.foo.digest\n                );\n                assert.strictEqual(\n                    writeResult._attachments.foo.length,\n                    ensureNotFalsy(docFromStorage)._attachments.foo.length\n                );\n\n                // check in query() result\n                const queryResult = await storageInstance.query(\n                    config.storage.getStorage().statics.prepareQuery(\n                        storageInstance.schema,\n                        {\n                            selector: {},\n                            sort: [\n                                { key: 'asc' }\n                            ],\n                            skip: 0\n                        }\n                    )\n                );\n                assert.strictEqual(queryResult.documents[0]._attachments.foo.type, 'text/plain');\n                assert.strictEqual(queryResult.documents[0]._attachments.foo.length, dataLength);\n\n                // check in findDocumentsById() result\n                const byId = await storageInstance.findDocumentsById([writeData.key], false);\n                const byIdDoc = getFromObjectOrThrow(byId, writeData.key);\n                assert.strictEqual(byIdDoc._attachments.foo.type, 'text/plain');\n                assert.strictEqual(byIdDoc._attachments.foo.length, dataLength);\n                assert.ok(!(byIdDoc._attachments.foo as any).data);\n\n                // test the emitted event\n                const firstEventAttachment = flattenEvents(emitted)[0].documentData._attachments.foo;\n                assert.strictEqual(firstEventAttachment.type, 'text/plain');\n                assert.strictEqual(firstEventAttachment.length, dataLength);\n                assert.ok(!(firstEventAttachment as any).data);\n\n                const changesResult = await storageInstance.getChangedDocumentsSince(1000);\n                const firstChange = changesResult.documents[0];\n                if (!firstChange) {\n                    throw new Error('first change missing');\n                }\n                assert.strictEqual(firstChange.key, 'foobar');\n\n                sub.unsubscribe();\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to add multiple attachments, one each write","suites":["RxStorageInstance","attachments"],"updatePoint":{"line":2386,"column":74},"line":2386,"code":"            it('should be able to add multiple attachments, one each write', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: Object.assign(\n                        getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                        {\n                            attachments: {}\n                        }\n                    ),\n                    options: {},\n                    multiInstance: false\n                });\n\n                let previous: RxDocumentData<TestDocType> | undefined;\n\n                const dataBlobBuffer = blobBufferUtil.createBlobBuffer(randomString(20), 'text/plain');\n                const dataString = await blobBufferUtil.toBase64String(dataBlobBuffer);\n                const dataStringBase64 = await blobBufferUtil.toBase64String(dataBlobBuffer);\n                const attachmentHash = await hashAttachmentData(dataStringBase64);\n                const writeData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'one',\n                    _rev: EXAMPLE_REVISION_1,\n                    _deleted: false,\n                    _meta: {\n                        lwt: now()\n                    },\n                    _attachments: {\n                        foo: {\n                            digest: 'md5-' + attachmentHash,\n                            length: blobBufferUtil.size(dataBlobBuffer),\n                            data: dataString,\n                            type: 'text/plain'\n                        }\n                    }\n                };\n\n                previous = await writeSingle<TestDocType>(\n                    storageInstance,\n                    {\n                        previous,\n                        document: Object.assign({}, writeData, {\n                            _meta: {\n                                lwt: now()\n                            }\n                        })\n                    },\n                    testContext\n                );\n\n                if (!previous) {\n                    throw new Error('previous missing');\n                }\n\n                writeData._attachments = flatClone(previous._attachments) as any;\n\n                const data2 = blobBufferUtil.createBlobBuffer(randomString(20), 'text/plain');\n                const dataStringBase642 = await blobBufferUtil.toBase64String(data2);\n                const attachmentHash2 = await hashAttachmentData(dataStringBase642);\n                const dataString2 = await blobBufferUtil.toBase64String(data2);\n                writeData._attachments.bar = {\n                    data: dataString2,\n                    digest: 'md5-' + attachmentHash2,\n                    length: blobBufferUtil.size(data2),\n                    type: 'text/plain'\n                };\n                writeData._rev = EXAMPLE_REVISION_2;\n\n                previous = await writeSingle<TestDocType>(\n                    storageInstance,\n                    {\n                        previous,\n                        document: Object.assign({}, writeData, {\n                            _meta: {\n                                lwt: now()\n                            }\n                        })\n                    },\n                    testContext\n                );\n                if (!previous) {\n                    throw new Error('previous missing');\n                }\n\n                assert.strictEqual(Object.keys(previous._attachments).length, 2);\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"_deleted documents must loose all attachments","suites":["RxStorageInstance","attachments"],"updatePoint":{"line":2475,"column":61},"line":2475,"code":"            it('_deleted documents must loose all attachments', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: Object.assign(\n                        getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                        {\n                            attachments: {}\n                        }\n                    ),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const data = blobBufferUtil.createBlobBuffer(randomString(20), 'text/plain');\n                const dataStringBase64 = await blobBufferUtil.toBase64String(data);\n                const attachmentHash = await hashAttachmentData(dataStringBase64);\n                const dataString = await blobBufferUtil.toBase64String(data);\n                const writeData: RxDocumentWriteData<TestDocType> = {\n                    key: 'foobar',\n                    value: 'one',\n                    _rev: EXAMPLE_REVISION_1,\n                    _deleted: false,\n                    _meta: {\n                        lwt: now()\n                    },\n                    _attachments: {\n                        foo: {\n                            digest: 'md5-' + attachmentHash,\n                            length: blobBufferUtil.size(data),\n                            data: dataString,\n                            type: 'text/plain'\n                        }\n                    }\n                };\n                await storageInstance.bulkWrite([{ document: writeData }], testContext);\n                await storageInstance.getAttachmentData('foobar', 'foo');\n\n                const deleteData = clone(writeData);\n                deleteData._meta.lwt = now();\n                deleteData._deleted = true;\n                deleteData._attachments = {};\n                deleteData._rev = EXAMPLE_REVISION_2;\n\n                await storageInstance.bulkWrite(\n                    [{ previous: writeData, document: deleteData }],\n                    testContext\n                );\n\n                let hasThrown = false;\n                try {\n                    await storageInstance.getAttachmentData('foobar', 'foo');\n                } catch (err) {\n                    hasThrown = true;\n                }\n                assert.ok(hasThrown);\n\n                storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should have cleaned up the deleted document","suites":["RxStorageInstance",".cleanup"],"updatePoint":{"line":2537,"column":59},"line":2537,"code":"            it('should have cleaned up the deleted document', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const id = 'foobar';\n                const nonDeletedId = 'foobar2';\n\n                /**\n                 * Insert one that does not get deleted\n                 * and should still be there after the cleanup\n                 */\n                await storageInstance.bulkWrite([{\n                    document: {\n                        key: nonDeletedId,\n                        value: 'barfoo',\n                        _rev: EXAMPLE_REVISION_1,\n                        _deleted: false,\n                        _meta: {\n                            lwt: now()\n                        },\n                        _attachments: {}\n                    }\n                }], testContext);\n\n\n                /**\n                 * Insert\n                 */\n                const insertResult = await storageInstance.bulkWrite([{\n                    document: {\n                        key: id,\n                        value: 'barfoo',\n                        _attachments: {},\n                        _rev: EXAMPLE_REVISION_1,\n                        _meta: {\n                            lwt: now()\n                        },\n                        _deleted: false\n                    }\n                }], testContext);\n                const previous = getFromObjectOrThrow(insertResult.success, id);\n\n                /**\n                 * Delete\n                 */\n                const deleteResult = await storageInstance.bulkWrite([{\n                    previous,\n                    document: {\n                        key: id,\n                        value: 'barfoo',\n                        _rev: EXAMPLE_REVISION_2,\n                        _deleted: true,\n                        _meta: {\n                            lwt: now()\n                        },\n                        _attachments: {}\n                    }\n                }], testContext);\n                getFromObjectOrThrow(deleteResult.success, id);\n\n                /**\n                 * Running .cleanup() with a height minimumDeletedTime\n                 * should not remove the deleted document.\n                 */\n                await storageInstance.cleanup(1000 * 60 * 60);\n\n                const mustBeThereButDeleted = await storageInstance.findDocumentsById(\n                    [id],\n                    true\n                );\n                const doc = mustBeThereButDeleted[id];\n                assert.ok(doc._deleted);\n\n                // clean up the deleted document\n                await storageInstance.cleanup(0);\n\n                if (config.storage.name === 'pouchdb') {\n                    /**\n                     * PouchDB is not able to fully purge a document\n                     * so it makes no sense to check if the deleted document\n                     * was removed on cleanup.\n                     */\n                    await storageInstance.close();\n                    return;\n                }\n\n                const mustNotBeThere = await storageInstance.findDocumentsById(\n                    [id],\n                    true\n                );\n                assert.deepStrictEqual(mustNotBeThere, {});\n\n                /**\n                 * Other docs must still be there\n                 */\n                const nonDeletedDoc = await storageInstance.findDocumentsById(\n                    [nonDeletedId],\n                    true\n                );\n                assert.ok(nonDeletedDoc[nonDeletedId]);\n\n                await storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should at some time return true (when all docs are cleaned up)","suites":["RxStorageInstance",".cleanup"],"updatePoint":{"line":2646,"column":78},"line":2646,"code":"            it('should at some time return true (when all docs are cleaned up)', async () => {\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n\n                let done = false;\n                while (!done) {\n                    done = await storageInstance.cleanup(0);\n                }\n\n                const id = 'foobar';\n                /**\n                 * Insert\n                 */\n                const insertResult = await storageInstance.bulkWrite([{\n                    document: {\n                        key: id,\n                        value: 'barfoo',\n                        _attachments: {},\n                        _rev: EXAMPLE_REVISION_1,\n                        _meta: {\n                            lwt: now()\n                        },\n                        _deleted: false\n                    }\n                }], testContext);\n                const previous = getFromObjectOrThrow(insertResult.success, id);\n\n                /**\n                 * Delete\n                 */\n                const deleteResult = await storageInstance.bulkWrite([{\n                    previous,\n                    document: {\n                        key: id,\n                        value: 'barfoo',\n                        _rev: EXAMPLE_REVISION_2,\n                        _deleted: true,\n                        _meta: {\n                            lwt: now()\n                        },\n                        _attachments: {}\n                    }\n                }], testContext);\n                getFromObjectOrThrow(deleteResult.success, id);\n\n                done = false;\n                while (!done) {\n                    done = await storageInstance.cleanup(0);\n                }\n\n                await storageInstance.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should have deleted all data","suites":["RxStorageInstance",".remove()"],"updatePoint":{"line":2707,"column":44},"line":2707,"code":"            it('should have deleted all data', async () => {\n                const databaseName = randomCouchString(12);\n                const collectionName = randomCouchString(12);\n\n                const storageInstance = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName,\n                    collectionName,\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n                await storageInstance.bulkWrite([\n                    {\n                        document: {\n                            key: 'foobar',\n                            value: 'barfoo',\n                            _deleted: false,\n                            _rev: EXAMPLE_REVISION_1,\n                            _meta: {\n                                lwt: now()\n                            },\n                            _attachments: {}\n                        }\n                    }\n                ], testContext);\n\n\n                await storageInstance.remove();\n                const storageInstance2 = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName,\n                    collectionName,\n                    schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                    options: {},\n                    multiInstance: false\n                });\n\n                const docs = await storageInstance2.findDocumentsById(['foobar'], false);\n                assert.strictEqual(Object.keys(docs).length, 0);\n\n                storageInstance2.close();\n            });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to write and read documents","suites":["multiInstance"],"updatePoint":{"line":2794,"column":54},"line":2794,"code":"        it('should be able to write and read documents', async () => {\n            const instances = await getMultiInstanceRxStorageInstance();\n\n            const emittedB: EventBulk<RxStorageChangeEvent<TestDocType>, any>[] = [];\n            instances.b.changeStream().subscribe(ev => emittedB.push(ev));\n            const emittedA: EventBulk<RxStorageChangeEvent<TestDocType>, any>[] = [];\n            instances.a.changeStream().subscribe(ev => emittedA.push(ev));\n\n            // insert a document on A\n            const writeData = getWriteData();\n            await instances.a.bulkWrite([{ document: writeData }], testContext);\n\n            // find the document on B\n            await waitUntil(async () => {\n                try {\n                    const foundAgain = await instances.b.findDocumentsById([writeData.key], false);\n                    const foundDoc = getFromObjectOrThrow(foundAgain, writeData.key);\n                    assert.strictEqual(foundDoc.key, writeData.key);\n                    return true;\n                } catch (err) {\n                    return false;\n                }\n            }, 10 * 1000, 100);\n\n            // find via query\n            const preparedQuery: PreparedQuery<TestDocType> = config.storage.getStorage().statics.prepareQuery<TestDocType>(\n                instances.b.schema,\n                {\n                    selector: {},\n                    limit: 1,\n                    sort: [{ key: 'asc' }],\n                    skip: 0\n                }\n            );\n\n            const foundViaQuery = await instances.b.query(preparedQuery);\n            assert.strictEqual(foundViaQuery.documents.length, 1);\n            const foundViaQueryDoc = foundViaQuery.documents.find(doc => doc.key === writeData.key);\n            assert.ok(foundViaQueryDoc);\n\n            // close both\n            await closeMultiInstanceRxStorageInstance(instances);\n        });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should be able to finish a query even when the leading instance gets closed","suites":["multiInstance"],"updatePoint":{"line":2843,"column":87},"line":2843,"code":"        it('should be able to finish a query even when the leading instance gets closed', async () => {\n            const instances = await getMultiInstanceRxStorageInstance();\n\n            // insert a document on A\n            await instances.a.bulkWrite([{ document: getWriteData() }], testContext);\n\n            const preparedQuery: PreparedQuery<TestDocType> = config.storage.getStorage()\n                .statics\n                .prepareQuery<TestDocType>(\n                    instances.b.schema,\n                    {\n                        selector: {},\n                        limit: 1,\n                        sort: [{ key: 'asc' }],\n                        skip: 0\n                    }\n                );\n\n            const queryResultBefore = await instances.b.query(preparedQuery);\n            assert.ok(queryResultBefore);\n\n            // close A while starting a query on B\n            const queryResultPromise = instances.b.query(preparedQuery);\n            instances.a.close();\n\n            // the query should still resolve.\n            await queryResultPromise;\n\n            await instances.b.close();\n        });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should not mix up documents stored with different schema versions","suites":["multiInstance"],"updatePoint":{"line":2873,"column":77},"line":2873,"code":"        it('should not mix up documents stored with different schema versions', async () => {\n            const storageInstanceV0 = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                databaseInstanceToken: randomCouchString(10),\n                databaseName: randomCouchString(12),\n                collectionName: randomCouchString(12),\n                schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                options: {},\n                multiInstance: false\n            });\n            const storageInstanceV1 = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                databaseInstanceToken: randomCouchString(10),\n                databaseName: randomCouchString(12),\n                collectionName: randomCouchString(12),\n                schema: getPseudoSchemaForVersion<TestDocType>(1, 'key'),\n                options: {},\n                multiInstance: false\n            });\n\n            const writeResponseV0 = await storageInstanceV0.bulkWrite(\n                [{\n                    document: {\n                        key: 'foobar0',\n                        value: '0',\n                        _deleted: false,\n                        _meta: {\n                            lwt: now()\n                        },\n                        _rev: EXAMPLE_REVISION_1,\n                        _attachments: {}\n                    }\n                }],\n                testContext\n            );\n            const writeResponseV1 = await storageInstanceV1.bulkWrite(\n                [{\n                    document: {\n                        key: 'foobar1',\n                        value: '1',\n                        _deleted: false,\n                        _meta: {\n                            lwt: now()\n                        },\n                        _rev: EXAMPLE_REVISION_1,\n                        _attachments: {}\n                    }\n                }],\n                testContext\n            );\n            assert.deepStrictEqual(writeResponseV0.error, {});\n            assert.deepStrictEqual(writeResponseV1.error, {});\n\n\n            const plainQuery = {\n                selector: {},\n                sort: [{ key: 'asc' }]\n            };\n            const preparedQueryV0 = config.storage.getStorage().statics.prepareQuery(\n                getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                clone(plainQuery)\n            );\n            const resultV0 = await storageInstanceV0.query(preparedQueryV0);\n            assert.strictEqual(resultV0.documents.length, 1);\n            assert.strictEqual(resultV0.documents[0].value, '0');\n\n\n            const preparedQueryV1 = config.storage.getStorage().statics.prepareQuery(\n                getPseudoSchemaForVersion<TestDocType>(1, 'key'),\n                clone(plainQuery)\n            );\n            const resultV1 = await storageInstanceV1.query(preparedQueryV1);\n            assert.strictEqual(resultV1.documents.length, 1);\n            assert.strictEqual(resultV1.documents[0].value, '1');\n\n\n            storageInstanceV0.close();\n            storageInstanceV1.close();\n        });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should not mix up documents stored in a different database name","suites":["multiInstance"],"updatePoint":{"line":2950,"column":75},"line":2950,"code":"        it('should not mix up documents stored in a different database name', async () => {\n            const collectionName = 'aaaaa';\n            const schema = getPseudoSchemaForVersion<TestDocType>(0, 'key');\n            const storageInstance1 = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                databaseInstanceToken: randomCouchString(10),\n                databaseName: randomCouchString(12),\n                collectionName,\n                schema,\n                options: {},\n                multiInstance: false\n            });\n\n            const writeResponse = await storageInstance1.bulkWrite(\n                [{\n                    document: {\n                        key: 'foobar0',\n                        value: '0',\n                        _deleted: false,\n                        _meta: {\n                            lwt: now()\n                        },\n                        _rev: EXAMPLE_REVISION_1,\n                        _attachments: {}\n                    }\n                }],\n                testContext\n            );\n            assert.deepStrictEqual(writeResponse.error, {});\n            await storageInstance1.close();\n\n\n            const storageInstance2 = await config.storage.getStorage().createStorageInstance<TestDocType>({\n                databaseInstanceToken: randomCouchString(10),\n                databaseName: randomCouchString(12),\n                collectionName,\n                schema,\n                options: {},\n                multiInstance: false\n            });\n\n            const allDocsQuery = config.storage.getStorage().statics.prepareQuery(\n                schema,\n                {\n                    selector: {},\n                    skip: 0,\n                    sort: [{ key: 'asc' }]\n                }\n            );\n            const allDocs = await storageInstance2.query(allDocsQuery);\n            assert.deepStrictEqual(allDocs.documents, []);\n\n            storageInstance2.close();\n        });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"should emit events from one instance to the other","suites":["multiInstance"],"updatePoint":{"line":3003,"column":61},"line":3003,"code":"        it('should emit events from one instance to the other', async () => {\n            const instances = await getMultiInstanceRxStorageInstance();\n\n            const emittedB: any[] = [];\n            const sub = instances.b.changeStream().subscribe(ev => emittedB.push(ev));\n\n            const writeData = getWriteData();\n            await instances.a.bulkWrite([{\n                document: writeData\n            }], testContext);\n\n\n            await waitUntil(() => emittedB.length > 0);\n            assert.strictEqual(emittedB[0].events[0].documentId, writeData.key);\n\n            sub.unsubscribe();\n            await closeMultiInstanceRxStorageInstance(instances);\n        });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"documents that are stored on different schema versions, should not interfer","suites":["migration"],"updatePoint":{"line":3023,"column":87},"line":3023,"code":"        it('documents that are stored on different schema versions, should not interfer', async () => {\n            const storage = config.storage.getStorage();\n            const databaseName = randomCouchString(12);\n            const collectionName = randomCouchString(12);\n            const storageInstanceZero = await storage.createStorageInstance<TestDocType>({\n                databaseInstanceToken: randomCouchString(10),\n                databaseName,\n                collectionName,\n                schema: getPseudoSchemaForVersion<TestDocType>(0, 'key'),\n                options: {},\n                multiInstance: false\n            });\n            const storageInstanceOne = await storage.createStorageInstance<TestDocType>({\n                databaseInstanceToken: randomCouchString(10),\n                databaseName,\n                collectionName,\n                schema: getPseudoSchemaForVersion<TestDocType>(1, 'key'),\n                options: {},\n                multiInstance: false\n            });\n\n            const writeResultZero = await storageInstanceZero.bulkWrite(\n                [{ document: getWriteData({ value: 'zero' }) }],\n                testContext\n            );\n            assert.deepStrictEqual(writeResultZero.error, {});\n\n            const writeResultOne = await storageInstanceOne.bulkWrite(\n                [{ document: getWriteData({ value: 'one' }) }],\n                testContext\n            );\n            assert.deepStrictEqual(writeResultOne.error, {});\n\n            const docsZero = await storageInstanceZero.query(\n                storage.statics.prepareQuery(\n                    storageInstanceZero.schema,\n                    {\n                        selector: {},\n                        sort: [\n                            { key: 'asc' }\n                        ],\n                        skip: 0\n                    }\n                )\n            );\n            assert.strictEqual(docsZero.documents.length, 1);\n            assert.strictEqual(docsZero.documents[0].value, 'zero');\n\n            const docsOne = await storageInstanceOne.query(\n                storage.statics.prepareQuery(\n                    storageInstanceOne.schema,\n                    {\n                        selector: {},\n                        sort: [\n                            { key: 'asc' }\n                        ],\n                        skip: 0\n                    }\n                )\n            );\n            assert.strictEqual(docsOne.documents.length, 1);\n            assert.strictEqual(docsOne.documents[0].value, 'one');\n\n            storageInstanceZero.close();\n            storageInstanceOne.close();\n        });","file":"unit/rx-storage-implementations.test.ts","skipped":false,"dir":"test"},{"name":"create/write/remove","suites":["rx-storage-lokijs.test.js"],"updatePoint":{"line":36,"column":31},"line":36,"code":"        it('create/write/remove', async () => {\n            const collection = await humansCollections.create(\n                10,\n                randomCouchString(10),\n                true,\n                true,\n                getRxStorageLoki()\n            );\n            const doc = await collection.findOne().exec(true);\n            assert.ok(doc);\n\n            const storageInstance: RxStorageInstanceLoki<HumanDocumentType> = collection.storageInstance as any;\n            assert.ok(storageInstance.internals.leaderElector);\n\n            await collection.database.destroy();\n        });","file":"unit/rx-storage-lokijs.test.ts","skipped":false,"dir":"test"},{"name":"should work with 2 instances","suites":["rx-storage-lokijs.test.js"],"updatePoint":{"line":52,"column":40},"line":52,"code":"        it('should work with 2 instances', async () => {\n            const databaseName = randomCouchString(12);\n            const col1 = await humansCollections.createMultiInstance(\n                databaseName,\n                0,\n                null,\n                getRxStorageLoki()\n            );\n            await col1.database.waitForLeadership();\n            const col2 = await humansCollections.createMultiInstance(\n                databaseName,\n                0,\n                null,\n                getRxStorageLoki()\n            );\n            await col1.insert(schemaObjects.human());\n            const doc2 = await col2.findOne().exec(true);\n            assert.ok(doc2);\n            const doc3 = await col1.findOne().exec(true);\n            assert.ok(doc3);\n\n            // the database storage of col2 should not have internal localState\n            assert.ok(col1.database.internalStore.internals.localState);\n            assert.ok(!col2.database.internalStore.internals.localState);\n\n            /**\n             * Only col1 should be leader\n             * and so only col1 should have a localState.\n             */\n            assert.ok(col1.storageInstance.internals.localState);\n            assert.ok(!col2.storageInstance.internals.localState);\n\n            /**\n             * The query on the non-leading instance\n             * must return the correct query results.\n             */\n            await col2.insert(schemaObjects.human());\n            await col1.insert(schemaObjects.human());\n            await waitUntil(async () => {\n                const res = await col2.find().exec();\n                if (res.length > 3) {\n                    throw new Error('got too much docs');\n                }\n                return res.length === 3;\n            });\n\n            col1.database.destroy();\n            col2.database.destroy();\n        });","file":"unit/rx-storage-lokijs.test.ts","skipped":false,"dir":"test"},{"name":"should not have localState if not leader","suites":["rx-storage-lokijs.test.js"],"updatePoint":{"line":101,"column":52},"line":101,"code":"        it('should not have localState if not leader', async () => {\n            const databaseName = randomCouchString(12);\n            const amount = 5;\n            const cols = await Promise.all(\n                new Array(amount).fill(0)\n                    .map(() => humansCollections.createMultiInstance(\n                        databaseName,\n                        0,\n                        null,\n                        getRxStorageLoki()\n                    ))\n            );\n            const getLeaders = () => {\n                return cols.filter(col => {\n                    const storageInstance = col.storageInstance;\n                    const leaderElector: LeaderElector = storageInstance.internals.leaderElector;\n                    return leaderElector.isLeader;\n                });\n            }\n\n            // wait until one is leader\n            await waitUntil(() => {\n                const leaderAmount = getLeaders().length;\n                if (leaderAmount > 1) {\n                    throw new Error('duplicate leaders detected');\n                } else if (leaderAmount === 1) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }, 50 * 1000, 200);\n\n            // add some collections after leader is elected\n            await Promise.all(\n                new Array(amount).fill(0)\n                    .map(async () => {\n                        const col = await humansCollections.createMultiInstance(\n                            databaseName,\n                            0,\n                            null,\n                            getRxStorageLoki()\n                        );\n                        cols.push(col);\n                    })\n            );\n\n            /**\n             * Run some operations on non-leading instance\n             * to emulate real world usage\n             */\n            const firstNonLeading = cols.find(col => !col.database.isLeader());\n            if (!firstNonLeading) {\n                throw new Error('no non leading instance');\n            }\n            await firstNonLeading.insert({\n                passportId: randomCouchString(10),\n                firstName: 'foo',\n                lastName: 'bar',\n                age: 10,\n            });\n            await firstNonLeading.insertLocal(\n                randomCouchString(10),\n                { foo: 'bar' }\n            );\n\n            /**\n             * The non-leading instances should not\n             * have localState set in its storage instances.\n             */\n            cols.forEach(col => {\n                const mustHaveLocal = col.storageInstance.internals.leaderElector.isLeader;\n                assert.strictEqual(mustHaveLocal, !!col.database.internalStore.internals.localState);\n                assert.strictEqual(mustHaveLocal, !!col.storageInstance.internals.localState);\n            });\n\n            cols.forEach(col => col.database.destroy());\n        });","file":"unit/rx-storage-lokijs.test.ts","skipped":false,"dir":"test"},{"name":"listening to queries must work","suites":["rx-storage-lokijs.test.js"],"updatePoint":{"line":178,"column":42},"line":178,"code":"        it('listening to queries must work', async () => {\n            const databaseName = randomCouchString(12);\n            const col1 = await humansCollections.createMultiInstance(\n                databaseName,\n                0,\n                null,\n                getRxStorageLoki()\n            );\n            await col1.database.waitForLeadership();\n            const col2 = await humansCollections.createMultiInstance(\n                databaseName,\n                0,\n                null,\n                getRxStorageLoki()\n            );\n            let lastResult1: any[];\n            let lastResult2: any[];\n\n            const sub1 = col1.find().$.subscribe(res => lastResult1 = res);\n            const sub2 = col1.find().$.subscribe(res => lastResult2 = res);\n\n            await waitUntil(() => !!lastResult1 && !!lastResult2);\n\n            await col2.insert(schemaObjects.human());\n            await waitUntil(() => lastResult1.length === 1 && lastResult2.length === 1);\n\n            sub1.unsubscribe();\n            sub2.unsubscribe();\n            col1.database.destroy();\n            col2.database.destroy();\n        });","file":"unit/rx-storage-lokijs.test.ts","skipped":false,"dir":"test"},{"name":"should use the given adapter","suites":["rx-storage-lokijs.test.js"],"updatePoint":{"line":209,"column":40},"line":209,"code":"        it('should use the given adapter', async () => {\n            if (!config.platform.isNode()) {\n                return;\n            }\n            /**\n             * @link https://github.com/techfort/LokiJS/blob/master/tutorials/Persistence%20Adapters.md#an-example-using-fastest-and-most-scalable-lokifsstructuredadapter-for-nodejs-might-look-like-\n             */\n            const lfsa = require('lokijs/src/loki-fs-structured-adapter.js');\n            const adapter = new lfsa();\n            const storage = getRxStorageLoki({\n                adapter\n            });\n\n            const databaseName = 'lokijs-fs-adapter-test-' + randomCouchString(12);\n            const dbLocation = path.join(\n                __dirname,\n                '../',\n                databaseName\n            );\n\n            const storageInstance = await storage.createStorageInstance<{ key: string }>({\n                databaseInstanceToken: randomCouchString(10),\n                databaseName: dbLocation,\n                collectionName: randomCouchString(12),\n                schema: getPseudoSchemaForVersion(0, 'key'),\n                options: {},\n                multiInstance: false\n            });\n\n            const localState = await ensureNotFalsy(storageInstance.internals.localState);\n            assert.ok(localState.databaseState.database.persistenceAdapter === adapter);\n            const writeResponse = await storageInstance.bulkWrite([{\n                document: {\n                    key: 'foobar',\n                    _deleted: false,\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    },\n                    _attachments: {}\n                }\n            }], 'loki-test');\n            assert.deepStrictEqual(writeResponse.error, {});\n\n            /**\n             * It should have written the file to the filesystem\n             * on the next autosave which is called on close()\n             */\n            await storageInstance.close();\n            const exists = fs.existsSync(dbLocation + '.db');\n            assert.ok(exists);\n        });","file":"unit/rx-storage-lokijs.test.ts","skipped":false,"dir":"test"},{"name":"should have called the autosaveCallback","suites":["rx-storage-lokijs.test.js"],"updatePoint":{"line":261,"column":51},"line":261,"code":"        it('should have called the autosaveCallback', async () => {\n            if (!config.platform.isNode()) {\n                return;\n            }\n            const lfsa = require('lokijs/src/loki-fs-structured-adapter.js');\n            const adapter = new lfsa();\n\n            let callbackCalledCount = 0;\n            const storage = getRxStorageLoki({\n                adapter,\n                autosaveCallback: () => callbackCalledCount = callbackCalledCount + 1\n            });\n            const databaseName = 'lokijs-fs-test-autosaveCallback-' + randomCouchString(12);\n            const dbLocation = path.join(\n                __dirname,\n                '../',\n                databaseName\n            );\n            const storageInstance = await storage.createStorageInstance<{ key: string }>({\n                databaseInstanceToken: randomCouchString(10),\n                databaseName: dbLocation,\n                collectionName: randomCouchString(12),\n                schema: getPseudoSchemaForVersion(0, 'key'),\n                options: {},\n                multiInstance: false\n            });\n\n            await storageInstance.bulkWrite([{\n                document: {\n                    key: 'foobar',\n                    _deleted: false,\n                    _rev: EXAMPLE_REVISION_1,\n                    _meta: {\n                        lwt: now()\n                    },\n                    _attachments: {}\n                }\n            }], 'loki-test');\n\n            await waitUntil(() => callbackCalledCount === 1);\n            await storageInstance.close();\n        });","file":"unit/rx-storage-lokijs.test.ts","skipped":false,"dir":"test"},{"name":"must not use setTimeout internally","suites":["rx-storage-lokijs.test.js","#3666 RxDB with lokijs works bad in Safari and FF when using multiple tabs"],"updatePoint":{"line":317,"column":50},"line":317,"code":"            it('must not use setTimeout internally', async () => {\n                if (\n                    // run only on node to ensure that rewriting the setTimeout works properly.\n                    !config.platform.isNode() ||\n                    // do not run in fast mode because we overwrite global.setTimeout which break parallel tests.\n                    config.isFastMode()\n                ) {\n                    return;\n                }\n\n                const oldSetTimeout = global.setTimeout;\n                (global as any).setTimeout = (fn: Function, time: number) => {\n                    throw new Error('LokiJS must not use setTimeout(' + fn.toString() + ', ' + time + ')');\n                }\n\n                const storage = getRxStorageLoki({\n                    /**\n                     * Do not set a persistence adapter.\n                     * It is allowed to use setTimeout in the persistence\n                     * because it is required to have it to determine when the database is isdle.\n                     * Also the persistence happens in the background so it is not that bad\n                     * if the setTimeout takes longer because the browser throttled the tab.\n                     */\n                });\n\n                const storageInstance = await storage.createStorageInstance({\n                    databaseInstanceToken: randomCouchString(10),\n                    databaseName: randomCouchString(12),\n                    collectionName: randomCouchString(12),\n                    multiInstance: false,\n                    options: {},\n                    schema: fillWithDefaultSettings(schemas.human)\n                });\n\n                const firstDocData = Object.assign(schemaObjects.human(), {\n                    _deleted: false,\n                    _meta: {\n                        lwt: now()\n                    },\n                    _rev: EXAMPLE_REVISION_1,\n                    _attachments: {}\n                });\n                await storageInstance.bulkWrite([\n                    {\n                        document: firstDocData\n                    }\n                ], 'loki-test');\n\n                await storageInstance.bulkWrite([\n                    {\n                        document: Object.assign(schemaObjects.human(), {\n                            _deleted: false,\n                            _attachments: {},\n                            _meta: {\n                                lwt: now()\n                            },\n                            _rev: '1-51b2fae5721cc4d3cf7392f19e6cc118'\n                        })\n                    }\n                ], 'loki-test');\n                const preparedQuery = storage.statics.prepareQuery(\n                    fillWithDefaultSettings(schemas.human),\n                    {\n                        selector: {},\n                        sort: [{\n                            passportId: 'asc'\n                        }],\n                        skip: 0\n                    }\n                );\n                await storageInstance.query(preparedQuery);\n                await storageInstance.findDocumentsById([firstDocData.passportId], false);\n\n                await storageInstance.close();\n\n                // reset the global.setTimeout so the following tests work properly.\n                global.setTimeout = oldSetTimeout;\n            });","file":"unit/rx-storage-lokijs.test.ts","skipped":false,"dir":"test"},{"name":"should move the $lastWriteAt value to _meta.lwt","suites":["rx-storage-lokijs.test.js","#3666 RxDB with lokijs works bad in Safari and FF when using multiple tabs"],"updatePoint":{"line":398,"column":59},"line":398,"code":"        it('should move the $lastWriteAt value to _meta.lwt', async () => {\n            if (!config.platform.isNode()) {\n                return;\n            }\n            const lfsa = require('lokijs/src/loki-fs-structured-adapter.js');\n            const adapter = new lfsa();\n            const storage = getRxStorageLoki({\n                adapter\n            });\n\n            const databaseName = 'lokijs-migration-test-' + randomCouchString(12);\n            const dbLocation = path.join(\n                __dirname,\n                '../',\n                databaseName\n            );\n            const collectionName = randomCouchString(12);\n            const storageInstance = await storage.createStorageInstance<{ key: string }>({\n                databaseInstanceToken: randomCouchString(10),\n                databaseName: dbLocation,\n                collectionName,\n                schema: getPseudoSchemaForVersion(0, 'key'),\n                options: {},\n                multiInstance: false\n            });\n\n            const key = 'foobar';\n            const lwtValue = 1000;\n            const localState = ensureNotFalsy(await storageInstance.internals.localState);\n            localState.collection.insert({\n                key,\n                $lastWriteAt: lwtValue,\n                _deleted: false,\n                _attachments: {},\n                _rev: '1-62080c42d471e3d2625e49dcca3b8e3e'\n            });\n            // manually trigger the save queue because we did a write to the internal loki db. \n            await localState.databaseState.saveQueue.addWrite();\n\n            await storageInstance.close();\n\n            const storageInstance2 = await storage.createStorageInstance<{ key: string }>({\n                databaseInstanceToken: randomCouchString(10),\n                databaseName: dbLocation,\n                collectionName,\n                schema: getPseudoSchemaForVersion(0, 'key'),\n                options: {},\n                multiInstance: false\n            });\n\n            const docFromStorage = await storageInstance2.findDocumentsById([key], true);\n            const doc = ensureNotFalsy(docFromStorage[key]);\n\n            assert.ok(doc._meta);\n            assert.strictEqual(doc._meta.lwt, lwtValue);\n            assert.ok(!doc.hasOwnProperty('$lastWriteAt'));\n\n            storageInstance2.close();\n        });","file":"unit/rx-storage-lokijs.test.ts","skipped":false,"dir":"test"},{"name":".hashAttachmentData() must return the same hash as pouchdb creates for an attachment","suites":["utils"],"updatePoint":{"line":52,"column":96},"line":52,"code":"        it('.hashAttachmentData() must return the same hash as pouchdb creates for an attachment', async () => {\n            const pouch: PouchDBInstance = new PouchDB(\n                randomCouchString(12),\n                {\n                    adapter: 'memory'\n                }\n            ) as any;\n\n            const attachmentData = 'foobaasdfasdfsadfr';\n            const attachmentDataBlobBuffer = blobBufferUtil.createBlobBuffer(\n                attachmentData,\n                'text/plain'\n            );\n            const attachmentDataBBase64 = await blobBufferUtil.toBase64String(attachmentDataBlobBuffer);\n            const attachmentId = 'myText';\n            const docId = 'myDoc';\n\n            const rxdbHash = await hashAttachmentData(attachmentDataBBase64);\n\n            await pouch.put({\n                _id: docId,\n                _attachments: {\n                    [attachmentId]: {\n                        data: attachmentDataBBase64,\n                        type: 'text/plain'\n                    }\n                }\n            });\n            const pouchDoc = await pouch.get(docId);\n            assert.strictEqual(\n                pouchDoc._attachments[attachmentId].digest,\n                'md5-' + rxdbHash\n            );\n\n            const size = getAttachmentSize(attachmentDataBBase64);\n            assert.strictEqual(pouchDoc._attachments[attachmentId].length, size);\n\n            pouch.destroy();\n        });","file":"unit/rx-storage-pouchdb.test.ts","skipped":false,"dir":"test"},{"name":"should not throw when added to pouch","suites":["custom events plugin"],"updatePoint":{"line":93,"column":48},"line":93,"code":"        it('should not throw when added to pouch', () => {\n            addCustomEventsPluginToPouch();\n        });","file":"unit/rx-storage-pouchdb.test.ts","skipped":false,"dir":"test"},{"name":"should emit data on bulkDocs","suites":["custom events plugin"],"updatePoint":{"line":96,"column":40},"line":96,"code":"        it('should emit data on bulkDocs', async () => {\n            const pouch: PouchDBInstance = new PouchDB(\n                randomCouchString(12),\n                {\n                    adapter: 'memory'\n                }\n            ) as any;\n            await pouch.info();\n            (pouch as any).primaryPath = '_id';\n\n            const emitted: EventBulk<RxStorageChangeEvent<RxDocumentData<any>>, any>[] = [];\n            const sub = getCustomEventEmitterByPouch(pouch).subject.subscribe(ev => {\n                emitted.push(ev);\n            });\n\n            await pouch.bulkDocs([{\n                _id: 'foo',\n                val: 'bar'\n            }], {\n                // add custom data to the options which should be passed through\n                custom: {\n                    foo: 'bar'\n                }\n            } as any);\n\n            await waitUntil(() => flattenEvents(emitted).length === 1);\n\n            const first = flattenEvents(emitted)[0];\n            assert.deepStrictEqual(\n                first.operation,\n                'INSERT'\n            );\n\n            pouch.destroy();\n            sub.unsubscribe();\n        });","file":"unit/rx-storage-pouchdb.test.ts","skipped":false,"dir":"test"},{"name":"should respect a custom index","suites":[".query()"],"updatePoint":{"line":134,"column":41},"line":134,"code":"        it('should respect a custom index', async () => {\n            const storage = getRxStoragePouch('memory');\n            let schema = clone(humanSchemaLiteral);\n            schema.indexes.push(['age']);\n            schema.indexes.push(['passportId', 'age']);\n            schema.indexes.push(['age', 'passportId']);\n            schema.indexes.push(['age', 'firstName', 'passportId']);\n            schema.indexes.push(['firstName', 'age', 'passportId']);\n            schema = normalizeRxJsonSchema(schema);\n\n            const storageInstance = await storage.createStorageInstance<HumanDocumentType>({\n                databaseInstanceToken: randomCouchString(10),\n                databaseName: randomCouchString(12),\n                collectionName: randomCouchString(12),\n                schema,\n                options: {},\n                multiInstance: false\n            });\n\n            await storageInstance.bulkWrite(\n                new Array(5).fill(0).map(() => {\n                    const data: RxDocumentWriteData<HumanDocumentType> = Object.assign(\n                        schemaObjects.human(),\n                        {\n                            _attachments: {},\n                            _deleted: false,\n                            _rev: EXAMPLE_REVISION_1,\n                            _meta: {\n                                lwt: now()\n                            }\n                        }\n                    );\n                    data.age = 18;\n                    return {\n                        document: data\n                    }\n                }),\n                'pouchdb-test'\n            );\n\n            const pouch = storageInstance.internals.pouch;\n            // const hasIndexes = await pouch.getIndexes();\n\n            async function analyzeQuery(query: MangoQuery<HumanDocumentType>) {\n                const preparedQuery = storage.statics.prepareQuery(\n                    schema,\n                    normalizeMangoQuery(schema, query)\n                );\n                const explained = await pouch.explain(preparedQuery);\n                const result = await pouch.find(preparedQuery);\n                return {\n                    query,\n                    preparedQuery,\n                    explained,\n                    result: result.docs\n                };\n            }\n\n            const defaultAnalyzed = await analyzeQuery({\n                selector: {},\n                sort: [\n                    { passportId: 'asc' }\n                ]\n            });\n\n            const customIndexAnalyzed = await analyzeQuery({\n                selector: {},\n                sort: [\n                    { passportId: 'asc' }\n                ],\n                index: ['passportId', 'age']\n            });\n\n            // default should use default index\n            assert.strictEqual(\n                defaultAnalyzed.explained.index.ddoc,\n                null\n            );\n\n            // custom should use the custom index\n            (customIndexAnalyzed.query as any).index.forEach((indexKey: string) => {\n                if (indexKey !== 'passportId') {\n                    assert.ok(ensureNotFalsy(customIndexAnalyzed.explained.index.ddoc).includes(indexKey));\n                }\n            });\n            assert.ok(ensureNotFalsy(customIndexAnalyzed.explained.index.ddoc).includes('_id'));\n\n            // both queries should have returned the same documents\n            assert.deepStrictEqual(\n                defaultAnalyzed.result,\n                customIndexAnalyzed.result\n            );\n\n            storageInstance.close();\n        });","file":"unit/rx-storage-pouchdb.test.ts","skipped":false,"dir":"test"},{"name":"should run and sync","suites":[],"updatePoint":{"line":55,"column":27},"line":55,"code":"    it('should run and sync', async function () {\n        this.timeout(12 * 1000);\n        const port = await nextPort();\n        const serverCollection = await humansCollection.create(0, 'human');\n        await serverCollection.database.serverCouchDB({\n            path: '/db',\n            port\n        });\n\n        // check access to path\n        const colUrl = 'http://0.0.0.0:' + port + '/db/human';\n        const gotJson = await request(colUrl);\n        const got = JSON.parse(gotJson);\n\n        assert.strictEqual(got.doc_count, 1);\n\n        const clientCollection = await humansCollection.create(0, 'humanclient');\n\n        // sync\n        clientCollection.syncCouchDB({\n            remote: colUrl,\n            direction: {\n                pull: true,\n                push: true\n            }\n        });\n\n        // insert one doc on each side\n        const insertServer = schemaObjects.human();\n        insertServer.firstName = 'server';\n        await serverCollection.insert(insertServer);\n\n        await wait(200);\n\n        const insertClient = schemaObjects.human();\n        insertClient.firstName = 'client';\n        await clientCollection.insert(insertClient);\n\n        await AsyncTestUtil.waitUntil(async () => {\n            const serverDocs = await serverCollection.find().exec();\n            return serverDocs.length === 2;\n        });\n\n        clientCollection.database.destroy();\n        serverCollection.database.destroy();\n    });","file":"unit/server-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should run and sync as sub app for express","suites":[],"updatePoint":{"line":101,"column":50},"line":101,"code":"    it('should run and sync as sub app for express', async function () {\n        this.timeout(12 * 1000);\n        const port = await nextPort();\n        const serverCollection = await humansCollection.create(0);\n        const { app, server } = await serverCollection.database.serverCouchDB({\n            path: '/',\n            port,\n            cors: false,\n            startServer: false\n        });\n\n        // check if server was returned\n        if (server !== null) {\n            return Promise.reject(\n                new Error('Server was created')\n            );\n        }\n\n        // create new express app and mount sub app\n        const customApp = express();\n        customApp.use('/rxdb', app);\n        const customServer = customApp.listen(port);\n\n        // check access to path\n        const colUrl = 'http://0.0.0.0:' + port + '/rxdb/human';\n        const gotJson = await request(colUrl);\n\n        const got = JSON.parse(gotJson);\n        assert.strictEqual(got.doc_count, 1);\n\n        const clientCollection = await humansCollection.create(0);\n\n        // sync\n        clientCollection.syncCouchDB({\n            remote: colUrl\n        });\n\n        // insert one doc on each side\n        await clientCollection.insert(schemaObjects.human());\n        await serverCollection.insert(schemaObjects.human());\n\n        // both collections should have 2 documents\n        await AsyncTestUtil.waitUntil(async () => {\n            const serverDocs = await serverCollection.find().exec();\n            const clientDocs = await clientCollection.find().exec();\n            return (clientDocs.length === 2 && serverDocs.length === 2);\n        });\n\n        clientCollection.database.destroy();\n        serverCollection.database.destroy();\n\n        // custom server has to closed independently\n        customServer.close();\n    });","file":"unit/server-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should send cors when defined for missing origin","suites":[],"updatePoint":{"line":155,"column":56},"line":155,"code":"    it('should send cors when defined for missing origin', async function () {\n        this.timeout(12 * 1000);\n        const port = await nextPort();\n        const serverCollection = await humansCollection.create(0);\n        await serverCollection.database.serverCouchDB({\n            path: '/db',\n            port,\n            cors: true\n        });\n        const colUrl = 'http://0.0.0.0:' + port + '/db/human';\n\n        await new Promise((res, rej) => {\n            requestR({\n                method: 'GET',\n                url: colUrl,\n            }, (error, response) => {\n                if (error) rej(error);\n\n                const responseHeaders: any = Object.keys(response.headers).reduce((acc, header) => ({\n                    ...acc,\n                    [header.toLowerCase()]: response.headers[header]\n                }), {});\n                const originHeaderName = 'Access-Control-Allow-Origin'.toLowerCase();\n                const credentialsHeaderName = 'Access-Control-Allow-Credentials'.toLowerCase();\n\n                const hasOriginHeader = responseHeaders[originHeaderName] === '*';\n                const hasCredentialsHeader = responseHeaders[credentialsHeaderName] === 'true';\n\n                if (!hasOriginHeader || !hasCredentialsHeader) {\n                    rej(\n                        new Error(\n                            'cors headers not set: ' +\n                            JSON.stringify(response.headers, null, 2)\n                        )\n                    );\n                } else res(null);\n            });\n        });\n\n        serverCollection.database.destroy();\n    });","file":"unit/server-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should send cors when defined for present origin","suites":[],"updatePoint":{"line":196,"column":56},"line":196,"code":"    it('should send cors when defined for present origin', async function () {\n        this.timeout(12 * 1000);\n        const port = await nextPort();\n        const serverCollection = await humansCollection.create(0);\n        await serverCollection.database.serverCouchDB({\n            path: '/db',\n            port,\n            cors: true\n        });\n        const colUrl = 'http://0.0.0.0:' + port + '/db/human';\n\n        const origin = 'example.com';\n        await new Promise((res, rej) => {\n            requestR({\n                method: 'GET',\n                url: colUrl,\n                headers: {\n                    'Origin': origin,\n                }\n            }, (error, response) => {\n                if (error) rej(error);\n\n                const responseHeaders: any = Object.keys(response.headers).reduce((acc, header) => ({\n                    ...acc,\n                    [header.toLowerCase()]: response.headers[header]\n                }), {});\n                const originHeaderName = 'Access-Control-Allow-Origin'.toLowerCase();\n                const credentialsHeaderName = 'Access-Control-Allow-Credentials'.toLowerCase();\n\n                const hasOriginHeader = responseHeaders[originHeaderName] === origin;\n                const hasCredentialsHeader = responseHeaders[credentialsHeaderName] === 'true';\n\n                if (!hasOriginHeader || !hasCredentialsHeader) {\n                    rej(\n                        new Error(\n                            'cors headers not set: ' +\n                            JSON.stringify(response.headers, null, 2)\n                        )\n                    );\n                } else res(null);\n            });\n        });\n\n        serverCollection.database.destroy();\n    });","file":"unit/server-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should free port when database is destroyed","suites":[],"updatePoint":{"line":241,"column":51},"line":241,"code":"    it('should free port when database is destroyed', async () => {\n        const port = 5000;\n        const col1 = await humansCollection.create(0);\n        await col1.database.serverCouchDB({\n            port\n        });\n        await col1.database.destroy();\n\n        const col2 = await humansCollection.create(0);\n        await col2.database.serverCouchDB({\n            port\n        });\n        await col2.database.destroy();\n    });","file":"unit/server-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"using node-websql with an absolute path should work","suites":[],"updatePoint":{"line":255,"column":59},"line":255,"code":"    it('using node-websql with an absolute path should work', async () => {\n        addPouchPlugin(NodeWebsqlAdapter);\n        const dbName = config.rootPath + 'test_tmp/' + randomCouchString(10);\n        const db1 = await createRxDatabase({\n            name: dbName,\n            storage: getRxStoragePouch('leveldb'),\n            multiInstance: false\n        });\n        const cols1 = await db1.addCollections({\n            human: {\n                schema: schemas.human\n            }\n        });\n        const col1 = cols1.human;\n\n        await col1.insert(schemaObjects.human());\n\n        await db1.serverCouchDB({\n            port: await nextPort()\n        });\n\n        await col1.insert(schemaObjects.human());\n\n        await db1.destroy();\n    });","file":"unit/server-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"using full leveldown-module should work","suites":[],"updatePoint":{"line":280,"column":47},"line":280,"code":"    it('using full leveldown-module should work', async () => {\n        addPouchPlugin(NodeWebsqlAdapter);\n        const db1 = await createRxDatabase({\n            name: config.rootPath + 'test_tmp/' + randomCouchString(10),\n            storage: getRxStoragePouch(levelDown),\n            multiInstance: false\n        });\n        const cols1 = await db1.addCollections({\n            human: {\n                schema: schemas.human\n            }\n        });\n        const col1 = cols1.human;\n\n        await col1.insert(schemaObjects.human());\n\n        const port = await nextPort();\n        await db1.serverCouchDB({\n            port\n        });\n\n        await col1.insert(schemaObjects.human());\n\n        await AsyncTestUtil.waitUntil(async () => {\n            const serverDocs = await col1.find().exec();\n            return (serverDocs.length === 2);\n        });\n\n\n        await db1.destroy();\n    });","file":"unit/server-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should work on filesystem-storage","suites":[],"updatePoint":{"line":313,"column":41},"line":313,"code":"    it('should work on filesystem-storage', async function () {\n        addPouchPlugin(NodeWebsqlAdapter);\n\n        const port = await nextPort();\n        console.log('should work on filesystem-storage port: ' + port);\n\n        const directoryName = 'couchdb-filesystem-test';\n        const testDir = path.join(\n            config.rootPath,\n            'test_tmp'\n        );\n\n        // clean up from previous run\n        const dirs: string[] = fs.readdirSync(testDir);\n        dirs\n            .filter(dir => dir.startsWith(directoryName))\n            .forEach(dir => fs.rmdirSync(path.join(testDir, dir), { recursive: true, force: true }));\n\n        const clientDBName = path.join(testDir, directoryName + '-client');\n        const serverDBName = path.join(testDir, directoryName + '-server');\n        fs.mkdirSync(clientDBName, { recursive: true });\n        fs.mkdirSync(serverDBName, { recursive: true });\n\n        const clientDatabase = await createRxDatabase({\n            name: clientDBName,\n            storage: getRxStoragePouch('leveldb'),\n            multiInstance: false\n        });\n        const cols1 = await clientDatabase.addCollections({\n            human: {\n                schema: schemas.human\n            }\n        });\n        const clientCollection = cols1.human;\n\n        const serverDatabase = await createRxDatabase({\n            name: serverDBName,\n            storage: getRxStoragePouch('leveldb'),\n            multiInstance: false\n        });\n        const cols2 = await serverDatabase.addCollections({\n            human: {\n                schema: schemas.human\n            }\n        });\n        const serverCollection = cols2.human;\n        const emitted: any[] = [];\n        serverCollection.$.subscribe(e => {\n            emitted.push(e);\n        });\n\n        const couchdbServer = await serverDatabase.serverCouchDB({\n            port\n        });\n        assert.ok(couchdbServer.pouchApp);\n\n        const replicationState = await clientCollection.syncCouchDB({\n            remote: 'http://0.0.0.0:' + port + '/db/human',\n            direction: {\n                push: true,\n                pull: true\n            },\n            options: {\n                live: true\n            }\n        });\n        replicationState.error$.subscribe(err => {\n            console.log('# replication error:');\n            console.dir(err);\n        });\n\n        // both collections should have 2 documents\n        await serverCollection.insert(schemaObjects.human('server-doc'))\n        await waitUntil(() => serverCollection.find().exec().then(r => r.length === 1));\n        await waitUntil(() => clientCollection.find().exec().then(r => r.length === 1));\n\n        await clientCollection.insert(schemaObjects.human('client-doc'));\n        // both collections should have 2 docs\n        await waitUntil(() => clientCollection.find().exec().then(r => r.length === 2));\n        await waitUntil(async () => {\n            const docs = await serverCollection.find().exec();\n            if (docs.length > 2) {\n                throw new Error('too many documents');\n            }\n            return docs.length === 2;\n        });\n\n        // must have emitted both events\n        assert.strictEqual(emitted.length, 2);\n        await clientDatabase.destroy();\n        await serverDatabase.destroy();\n    });","file":"unit/server-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should work for collections with later schema versions","suites":[],"updatePoint":{"line":405,"column":62},"line":405,"code":"    it('should work for collections with later schema versions', async function () {\n        this.timeout(12 * 1000);\n        const port = await nextPort();\n        const serverCollection = await humansCollection.createMigrationCollection(0);\n        const serverResponse = await serverCollection.database.serverCouchDB({\n            path: '/db',\n            port\n        });\n        assert.ok(serverResponse);\n\n\n        // check access to path\n        const colUrl = 'http://0.0.0.0:' + port + '/db/human';\n        const gotJson = await request(colUrl);\n        const got = JSON.parse(gotJson);\n        assert.strictEqual(got.doc_count, 1);\n\n        const clientCollection = await humansCollection.createMigrationCollection(0);\n\n        // sync\n        clientCollection.syncCouchDB({\n            remote: colUrl\n        });\n\n        // insert one doc on each side\n        await clientCollection.insert(schemaObjects.simpleHumanV3());\n        await serverCollection.insert(schemaObjects.simpleHumanV3());\n\n        // both collections should have 2 documents\n        await AsyncTestUtil.waitUntil(async () => {\n            const serverDocs = await serverCollection.find().exec();\n            const clientDocs = await clientCollection.find().exec();\n            return (clientDocs.length === 2 && serverDocs.length === 2);\n        });\n\n        await clientCollection.database.destroy();\n        await serverCollection.database.destroy();\n    });","file":"unit/server-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should work for dynamic collection-names","suites":[],"updatePoint":{"line":443,"column":48},"line":443,"code":"    it('should work for dynamic collection-names', async () => {\n        const port = await nextPort();\n        const name = 'foobar';\n        const serverCollection = await humansCollection.create(0, name);\n        await serverCollection.database.serverCouchDB({\n            port\n        });\n        const clientCollection = await humansCollection.create(0, name);\n\n        // sync\n        clientCollection.syncCouchDB({\n            remote: 'http://0.0.0.0:' + port + '/db/' + name\n        });\n\n        // insert one doc on each side\n        await clientCollection.insert(schemaObjects.human());\n        await serverCollection.insert(schemaObjects.human());\n\n        // both collections should have 2 documents\n        await AsyncTestUtil.waitUntil(async () => {\n            const serverDocs = await serverCollection.find().exec();\n            const clientDocs = await clientCollection.find().exec();\n            return (clientDocs.length === 2 && serverDocs.length === 2);\n        });\n\n        await clientCollection.database.destroy();\n        await serverCollection.database.destroy();\n    });","file":"unit/server-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should throw if collections that created after server()","suites":[],"updatePoint":{"line":471,"column":63},"line":471,"code":"    it('should throw if collections that created after server()', async () => {\n        const port = await nextPort();\n        const db1 = await createRxDatabase({\n            name: randomCouchString(10),\n            storage: getRxStoragePouch('memory'),\n            multiInstance: false\n        });\n        await db1.serverCouchDB({\n            port\n        });\n        await AsyncTestUtil.assertThrows(\n            () => db1.addCollections({\n                human: {\n                    schema: schemas.human\n                }\n            }),\n            'RxError',\n            'after'\n        );\n        await db1.destroy();\n    });","file":"unit/server-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should throw on startup when port is already used","suites":[],"updatePoint":{"line":492,"column":57},"line":492,"code":"    it('should throw on startup when port is already used', async () => {\n        const port = await nextPort();\n        const db1 = await createRxDatabase({\n            name: randomCouchString(10),\n            storage: getRxStoragePouch('memory'),\n            multiInstance: false\n        });\n        await db1.serverCouchDB({\n            port\n        });\n\n        // wait until started up\n        await AsyncTestUtil.waitUntil(async () => {\n            try {\n                const gotJson = await request('http://0.0.0.0:' + port + '/db/');\n                JSON.parse(gotJson);\n                return true;\n            } catch (err) {\n                return false;\n            }\n        });\n\n        const db2 = await createRxDatabase({\n            name: randomCouchString(10),\n            storage: getRxStoragePouch('memory'),\n            multiInstance: false\n        });\n\n        let hasThrown = false;\n        try {\n            await db2.serverCouchDB({ port });\n        } catch (err) {\n            hasThrown = true;\n        }\n        assert.ok(hasThrown);\n\n        db1.destroy();\n        db2.destroy();\n    });","file":"unit/server-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"using couchdb AND websocket replication must work correctly","suites":[],"updatePoint":{"line":531,"column":67},"line":531,"code":"    it('using couchdb AND websocket replication must work correctly', async () => {\n        const couchPort = await nextPort();\n        const couchUrl = 'http://0.0.0.0:' + couchPort + '/db/human';\n        const websocketPort = await nextPort();\n        const websocketUrl = 'ws://localhost:' + websocketPort;\n\n        const datastoreDBName = config.rootPath + 'test_tmp/datastore-' + randomCouchString(10);\n        type Collections = {\n            human: RxCollection<schemas.HumanDocumentType>\n        }\n\n        const datastoreDB = await createRxDatabase<Collections>({\n            name: datastoreDBName,\n            storage: wrappedValidateAjvStorage({\n                storage: getRxStoragePouch('leveldb')\n            }),\n            multiInstance: false\n        });\n        await datastoreDB.addCollections({\n            human: {\n                schema: schemas.human\n            }\n        });\n\n        await datastoreDB.serverCouchDB({\n            port: couchPort\n        });\n        await startWebsocketServer({\n            database: datastoreDB,\n            port: websocketPort\n        });\n\n\n        const couchClientDBName = config.rootPath + 'test_tmp/couchclient-' + randomCouchString(10);\n        const couchClientDB = await createRxDatabase<Collections>({\n            name: couchClientDBName,\n            storage: wrappedValidateAjvStorage({\n                storage: getRxStoragePouch('leveldb')\n            }),\n            multiInstance: false\n        });\n        await couchClientDB.addCollections({\n            human: {\n                schema: schemas.human\n            }\n        });\n        await couchClientDB.human.syncCouchDB({\n            remote: couchUrl,\n            direction: {\n                push: true,\n                pull: true\n            },\n            options: {\n                live: true\n            }\n        });\n\n\n        /**\n         * We also create an instance that replicates via non-live one-time couchdb replication.\n         */\n        const couchOnceClientDBName = config.rootPath + 'test_tmp/couchonceclient-' + randomCouchString(10);\n        const couchOnceClientDB = await createRxDatabase<Collections>({\n            name: couchOnceClientDBName,\n            storage: wrappedValidateAjvStorage({\n                storage: getRxStoragePouch('leveldb')\n            }),\n            multiInstance: false\n        });\n        await couchOnceClientDB.addCollections({\n            human: {\n                schema: schemas.human\n            }\n        });\n        async function syncCouchOnce() {\n            const state = await couchOnceClientDB.human.syncCouchDB({\n                remote: couchUrl,\n                direction: {\n                    push: true,\n                    pull: true\n                },\n                options: {\n                    live: false,\n                    retry: true,\n                    batch_size: 10,\n                    batches_limit: 1\n                }\n            });\n            await firstValueFrom(\n                state.complete$.pipe(\n                    filter(x => !!x),\n                )\n            );\n        }\n        await syncCouchOnce();\n\n\n\n        const websocketClientDB = await createRxDatabase<Collections>({\n            name: randomCouchString(10),\n            storage: getRxStoragePouch('memory'),\n            multiInstance: false\n        });\n        await websocketClientDB.addCollections({\n            human: {\n                schema: schemas.human\n            }\n        });\n\n        const websocketReplicationState = await replicateWithWebsocketServer({\n            collection: websocketClientDB.human,\n            url: websocketUrl\n        });\n        await websocketReplicationState.awaitInSync();\n\n        async function waitUntilDocExists(\n            collection: RxCollection,\n            docId: string\n        ) {\n            await waitUntil(() => {\n                const doc = collection.findOne(docId).exec();\n                return !!doc;\n            });\n        }\n\n        const emittedDatastore: RxChangeEvent<schemas.HumanDocumentType>[] = [];\n        datastoreDB.$.subscribe(ev => {\n            emittedDatastore.push(ev);\n        });\n        const emittedCouchClient: RxChangeEvent<schemas.HumanDocumentType>[] = [];\n        couchClientDB.$.subscribe(ev => emittedCouchClient.push(ev));\n        const emittedWebsocketClient: RxChangeEvent<schemas.HumanDocumentType>[] = [];\n        websocketClientDB.$.subscribe(ev => emittedWebsocketClient.push(ev));\n\n\n        // insert datastore\n        await datastoreDB.human.insert(schemaObjects.human('doc-datastore'));\n        await waitUntilDocExists(websocketClientDB.human, 'doc-datastore');\n        await waitUntilDocExists(couchClientDB.human, 'doc-datastore');\n        await syncCouchOnce();\n        await waitUntilDocExists(couchOnceClientDB.human, 'doc-datastore');\n\n        // insert websocket\n        await websocketClientDB.human.insert(schemaObjects.human('doc-websocket'));\n        await waitUntilDocExists(datastoreDB.human, 'doc-websocket');\n        await waitUntilDocExists(couchClientDB.human, 'doc-websocket');\n        await syncCouchOnce();\n        await waitUntilDocExists(couchOnceClientDB.human, 'doc-websocket');\n\n        // insert couch client\n        await couchClientDB.human.insert(schemaObjects.human('doc-couch'));\n        await waitUntilDocExists(datastoreDB.human, 'doc-couch');\n        await waitUntilDocExists(websocketClientDB.human, 'doc-couch');\n        await syncCouchOnce();\n        await waitUntilDocExists(couchOnceClientDB.human, 'doc-couch');\n\n        // insert couch once client\n        await couchOnceClientDB.human.insert(schemaObjects.human('doc-couch-once'));\n        await syncCouchOnce();\n        await waitUntilDocExists(datastoreDB.human, 'doc-couch-once');\n        await waitUntilDocExists(couchClientDB.human, 'doc-couch-once');\n        await waitUntilDocExists(websocketClientDB.human, 'doc-couch-once');\n\n\n        // check events\n        async function ensureCorrectEmits(ar: RxChangeEvent<schemas.HumanDocumentType>[]) {\n            await waitUntil(() => ar.length === 4);\n        }\n        await ensureCorrectEmits(emittedDatastore);\n        await ensureCorrectEmits(emittedCouchClient);\n        await ensureCorrectEmits(emittedWebsocketClient);\n\n        await Promise.all([\n            datastoreDB.destroy(),\n            couchClientDB.destroy(),\n            couchOnceClientDB.destroy(),\n            websocketClientDB.destroy()\n        ]);\n    });","file":"unit/server-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"use the path when given","suites":["issues","#1447 server path not working"],"updatePoint":{"line":712,"column":39},"line":712,"code":"            it('use the path when given', async function () {\n                this.timeout(12 * 1000);\n                const port = await nextPort();\n                const path = '/db2';\n                const serverCollection = await humansCollection.create(0);\n                await serverCollection.database.serverCouchDB({\n                    path,\n                    port\n                });\n\n                const colUrl = 'http://0.0.0.0:' + port + path + '/human';\n                const gotJson = await request(colUrl);\n                const got = JSON.parse(gotJson);\n                assert.strictEqual(got.doc_count, 1);\n\n                serverCollection.database.destroy();\n            });","file":"unit/server-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"use the path with ending slash","suites":["issues","#1447 server path not working"],"updatePoint":{"line":729,"column":46},"line":729,"code":"            it('use the path with ending slash', async function () {\n                this.timeout(12 * 1000);\n                const port = await nextPort();\n                const path = '/db3/';\n                const serverCollection = await humansCollection.create(0);\n                await serverCollection.database.serverCouchDB({\n                    path,\n                    port\n                });\n\n                const colUrl = 'http://0.0.0.0:' + port + path + 'human';\n                const gotJson = await request(colUrl);\n                const got = JSON.parse(gotJson);\n                assert.strictEqual(got.doc_count, 1);\n\n                serverCollection.database.destroy();\n            });","file":"unit/server-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should be able to use the root /","suites":["issues","#1447 server path not working"],"updatePoint":{"line":746,"column":48},"line":746,"code":"            it('should be able to use the root /', async function () {\n                this.timeout(12 * 1000);\n                const port = await nextPort();\n                const path = '/';\n                const serverCollection = await humansCollection.create(0);\n                await serverCollection.database.serverCouchDB({\n                    path,\n                    port\n                });\n\n                const colUrl = 'http://0.0.0.0:' + port + path + 'human';\n                const gotJson = await request(colUrl);\n                const got = JSON.parse(gotJson);\n                assert.strictEqual(got.doc_count, 1);\n\n                serverCollection.database.destroy();\n            });","file":"unit/server-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"having a collection with leveldb and no docs, will break the replication","suites":["issues","#1447 server path not working"],"updatePoint":{"line":763,"column":88},"line":763,"code":"            it('having a collection with leveldb and no docs, will break the replication', async function () {\n                const dbName = config.rootPath + 'test_tmp/' + randomCouchString(10);\n                const db = await createRxDatabase({\n                    name: dbName,\n                    storage: getRxStoragePouch('leveldb'),\n                    multiInstance: false\n                });\n                const cols = await db.addCollections({\n                    human: {\n                        schema: schemas.human\n                    }\n                });\n                const col = cols.human;\n\n                const port = await nextPort();\n                await db.serverCouchDB({\n                    port\n                });\n                await AsyncTestUtil.waitUntil(async () => {\n                    try {\n                        const gotJson = await request('http://localhost:' + port + '/db/' + col.name);\n                        const got = JSON.parse(gotJson);\n                        return !!got.doc_count;\n                    } catch (err) {\n                        console.dir(err);\n                        return false;\n                    }\n                });\n                db.destroy();\n            });","file":"unit/server-couchdb.test.ts","skipped":false,"dir":"test"},{"name":"should work with a string","suites":["util.test.js",".fastUnsecureHash()"],"updatePoint":{"line":32,"column":37},"line":32,"code":"        it('should work with a string', () => {\n            const hash = fastUnsecureHash('foobar');\n            assert.strictEqual(typeof hash, 'string');\n            assert.ok(hash.length > 0);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should get the same hash twice","suites":["util.test.js",".fastUnsecureHash()"],"updatePoint":{"line":37,"column":42},"line":37,"code":"        it('should get the same hash twice', () => {\n            const str = randomCouchString(10);\n            const hash = fastUnsecureHash(str);\n            const hash2 = fastUnsecureHash(str);\n            assert.strictEqual(hash, hash2);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should work with a very large string","suites":["util.test.js",".fastUnsecureHash()"],"updatePoint":{"line":43,"column":48},"line":43,"code":"        it('should work with a very large string', () => {\n            const str = randomCouchString(5000);\n            const hash = fastUnsecureHash(str);\n            assert.strictEqual(typeof hash, 'string');\n            assert.ok(hash.length > 0);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should return the same values for the same document data","suites":["util.test.js",".createRevision()"],"updatePoint":{"line":101,"column":68},"line":101,"code":"        it('should return the same values for the same document data', () => {\n            const hash1 = createRevision(\n                defaultHashFunction,\n                {\n                    foo: 'bar',\n                    bar: 'foo',\n                    _deleted: false,\n                    _attachments: {},\n                    _meta: {\n                        lwt: 1\n                    }\n                } as any\n            );\n            const hash2 = createRevision(\n                defaultHashFunction,\n                {\n                    foo: 'bar',\n                    bar: 'foo',\n                    // _rev_tree and _rev must be ignored from hashing\n                    _rev: '1-asdf',\n                    _rev_tree: 'foobar',\n                    _deleted: false,\n                    _attachments: {},\n                    _meta: {\n                        lwt: 1\n                    }\n                }\n            );\n            assert.strictEqual(hash1, hash2);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should sort when regex in object","suites":["util.test.js",".sortObject()"],"updatePoint":{"line":133,"column":44},"line":133,"code":"        it('should sort when regex in object', () => {\n            const obj = {\n                color: {\n                    '$regex': /foobar/g\n                }\n            };\n            const sorted = sortObject(obj);\n            assert.ok(sorted.color.$regex instanceof RegExp);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should validate a normal string","suites":["util.test.js",".validateDatabaseName()","positive"],"updatePoint":{"line":145,"column":47},"line":145,"code":"            it('should validate a normal string', () => {\n                validateDatabaseName('foobar');\n            });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should allow _ and $ after the first character","suites":["util.test.js",".validateDatabaseName()","positive"],"updatePoint":{"line":148,"column":62},"line":148,"code":"            it('should allow _ and $ after the first character', () => {\n                validateDatabaseName('foo_bar');\n                validateDatabaseName('foobar_');\n                validateDatabaseName('foobar$');\n            });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should not allow _ and $ as the first character","suites":["util.test.js",".validateDatabaseName()","positive"],"updatePoint":{"line":153,"column":63},"line":153,"code":"            it('should not allow _ and $ as the first character', async () => {\n                await AsyncTestUtil.assertThrows(\n                    () => validateDatabaseName('$foobar'),\n                    'RxError',\n                    'UT2'\n                );\n                await AsyncTestUtil.assertThrows(\n                    () => validateDatabaseName('_foobar'),\n                    'RxError',\n                    'UT2'\n                );\n            });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should validate foldernames","suites":["util.test.js",".validateDatabaseName()","positive"],"updatePoint":{"line":165,"column":43},"line":165,"code":"            it('should validate foldernames', () => {\n                validateDatabaseName('./foobar'); // unix\n                validateDatabaseName('.\\\\foobar'); // windows\n            });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should not validate a spaced string","suites":["util.test.js",".validateDatabaseName()","negative"],"updatePoint":{"line":171,"column":51},"line":171,"code":"            it('should not validate a spaced string', async () => {\n                await AsyncTestUtil.assertThrows(\n                    () => validateDatabaseName('foo bar'),\n                    'RxError',\n                    'UT2'\n                );\n            });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should increase the returned value each time","suites":["util.test.js",".now()"],"updatePoint":{"line":181,"column":56},"line":181,"code":"        it('should increase the returned value each time', () => {\n            const values: Set<number> = new Set();\n            const runs = 500;\n\n            new Array(runs)\n                .fill(0)\n                .forEach(() => {\n                    values.add(now());\n                });\n\n            // ensure we had no duplicates\n            assert.strictEqual(values.size, runs);\n\n            // ensure that all values have maximum two decimals\n            Array.from(values.values()).forEach(val => {\n                const asString = val.toString();\n                const afterDot = asString.split('.')[1];\n                if (\n                    afterDot &&\n                    afterDot.length > 2\n                ) {\n                    throw new Error('too many decmials on ' + asString);\n                }\n            });\n\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should correctly encode/decode in a circle","suites":["util.test.js","base64 helpers"],"updatePoint":{"line":209,"column":54},"line":209,"code":"        it('should correctly encode/decode in a circle', () => {\n            const str = 'foobar';\n            const circled = b64DecodeUnicode(b64EncodeUnicode(str));\n            assert.strictEqual(str, circled);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should be able to decode this big base64","suites":["util.test.js","base64 helpers"],"updatePoint":{"line":214,"column":52},"line":214,"code":"        it('should be able to decode this big base64', () => {\n            const decoded = b64DecodeUnicode(BIG_BASE64);\n            assert.ok(decoded);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should be able to run all functions","suites":["util.test.js","blobBufferUtil"],"updatePoint":{"line":220,"column":47},"line":220,"code":"        it('should be able to run all functions', async () => {\n            const text = 'foobar';\n            const blobBuffer = blobBufferUtil.createBlobBuffer(text, 'plain/text');\n            assert.ok(blobBufferUtil.isBlobBuffer(blobBuffer));\n            const asString = await blobBufferUtil.toString(blobBuffer);\n            assert.strictEqual(text, asString);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should be able to run often in circle","suites":["util.test.js","blobBufferUtil"],"updatePoint":{"line":227,"column":49},"line":227,"code":"        it('should be able to run often in circle', async () => {\n            const text = 'foobar';\n            let blobBuffer = blobBufferUtil.createBlobBuffer(text, 'plain/text');\n            let asString = await blobBufferUtil.toString(blobBuffer);\n            blobBuffer = blobBufferUtil.createBlobBuffer(asString, 'plain/text');\n            asString = await blobBufferUtil.toString(blobBuffer);\n            blobBuffer = blobBufferUtil.createBlobBuffer(asString, 'plain/text');\n            asString = await blobBufferUtil.toString(blobBuffer);\n\n            assert.strictEqual(text, asString);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":".size() should return a deterministic value","suites":["util.test.js","blobBufferUtil"],"updatePoint":{"line":238,"column":55},"line":238,"code":"        it('.size() should return a deterministic value', () => {\n            const amount = 30;\n            const str = randomCouchString(amount);\n            const blobBuffer = blobBufferUtil.createBlobBuffer(str, 'plain/text');\n            const size = blobBufferUtil.size(blobBuffer);\n            assert.strictEqual(size, amount);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should do the correct base64 conversion","suites":["util.test.js","blobBufferUtil"],"updatePoint":{"line":245,"column":51},"line":245,"code":"        it('should do the correct base64 conversion', async () => {\n            const plain = 'aaa';\n            const base64 = 'YWFh';\n\n            const blobBuffer = blobBufferUtil.createBlobBuffer(plain, 'plain/text');\n            assert.strictEqual(\n                await blobBufferUtil.toBase64String(blobBuffer),\n                base64\n            );\n            assert.strictEqual(\n                await blobBufferUtil.toString(blobBuffer),\n                plain\n            );\n\n            const blobBufferFromb64 = await blobBufferUtil.createBlobBufferFromBase64(base64, 'plain/text');\n            assert.strictEqual(\n                await blobBufferUtil.toBase64String(blobBufferFromb64),\n                base64\n            );\n            assert.strictEqual(\n                await blobBufferUtil.toString(blobBufferFromb64),\n                plain\n            );\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should work with non latin-1 chars","suites":["util.test.js","blobBufferUtil"],"updatePoint":{"line":269,"column":46},"line":269,"code":"        it('should work with non latin-1 chars', async () => {\n            const plain = 'a';\n            const base64 = 'YcOkw58=';\n            const blobBuffer = blobBufferUtil.createBlobBuffer(plain, 'plain/text');\n            assert.strictEqual(\n                await blobBufferUtil.toString(blobBuffer),\n                plain\n            );\n            assert.strictEqual(\n                await blobBufferUtil.toBase64String(blobBuffer),\n                base64\n            );\n            assert.strictEqual(\n                await blobBufferUtil.toString(blobBuffer),\n                plain\n            );\n            const blobBufferFromb64 = await blobBufferUtil.createBlobBufferFromBase64(base64, 'plain/text');\n            assert.strictEqual(\n                await blobBufferUtil.toString(blobBufferFromb64),\n                plain\n            );\n            assert.strictEqual(\n                await blobBufferUtil.toBase64String(blobBufferFromb64),\n                base64\n            );\n            assert.strictEqual(\n                await blobBufferUtil.toString(blobBufferFromb64),\n                plain\n            );\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should not allow to mutate the object","suites":["util.test.js",".deepFreezeWhenDevMode()"],"updatePoint":{"line":306,"column":49},"line":306,"code":"        it('should not allow to mutate the object', () => {\n            const obj = {\n                foo: 'bar'\n            };\n            const frozen = deepFreezeWhenDevMode(obj);\n            assert.throws(\n                () => (frozen as any).foo = 'xxx'\n            );\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should freeze the given object and not create a new frozen one","suites":["util.test.js",".deepFreezeWhenDevMode()"],"updatePoint":{"line":315,"column":74},"line":315,"code":"        it('should freeze the given object and not create a new frozen one', () => {\n            const obj = {\n                foo: 'bar'\n            };\n            const frozen = deepFreezeWhenDevMode(obj);\n            assert.ok(obj === frozen);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should sort correctly by lwt","suites":["util.test.js",".sortDocumentsByLastWriteTime()"],"updatePoint":{"line":326,"column":40},"line":326,"code":"        it('should sort correctly by lwt', () => {\n            const docs: RxDocumentData<SortDocType>[] = [\n                {\n                    id: 'a',\n                    _meta: {\n                        lwt: 1000\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1\n                },\n                {\n                    id: 'a',\n                    _meta: {\n                        lwt: 999\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1\n                },\n                {\n                    id: 'a',\n                    _meta: {\n                        lwt: 1001\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1\n                }\n            ];\n            const sorted = sortDocumentsByLastWriteTime(sortDocPrimary, docs);\n            assert.strictEqual(sorted[0]._meta.lwt, 999);\n            assert.strictEqual(sorted[1]._meta.lwt, 1000);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should sort correctly by id","suites":["util.test.js",".sortDocumentsByLastWriteTime()"],"updatePoint":{"line":360,"column":39},"line":360,"code":"        it('should sort correctly by id', () => {\n            const docs: RxDocumentData<SortDocType>[] = [\n                {\n                    id: 'b',\n                    _meta: {\n                        lwt: 1000\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1\n                },\n                {\n                    id: 'a',\n                    _meta: {\n                        lwt: 999\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1\n                },\n                {\n                    id: 'c',\n                    _meta: {\n                        lwt: 1001\n                    },\n                    _deleted: false,\n                    _attachments: {},\n                    _rev: EXAMPLE_REVISION_1\n                }\n            ];\n            const sorted = sortDocumentsByLastWriteTime(sortDocPrimary, docs);\n            assert.strictEqual(sorted[0].id, 'a');\n            assert.strictEqual(sorted[1].id, 'b');\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should return the given argument in case of integer","suites":["util.test.js",".ensureInteger()"],"updatePoint":{"line":396,"column":63},"line":396,"code":"        it('should return the given argument in case of integer', () => {\n            assert.doesNotThrow(() => ensureInteger(56));\n            assert.strictEqual(ensureInteger(56), 56);\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should throw error for  argument","suites":["util.test.js",".ensureInteger()"],"updatePoint":{"line":409,"column":56},"line":409,"code":"            it(`should throw error for ${value} argument`, () => {\n                assert.throws(() => ensureInteger(value));\n            });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should split into the correct amounts of batches","suites":["util.test.js",".batchArray()"],"updatePoint":{"line":415,"column":60},"line":415,"code":"        it('should split into the correct amounts of batches', () => {\n            const getArrayWithItems = (amount: number) => {\n                return new Array(amount).fill(0);\n            }\n\n            assert.strictEqual(\n                batchArray(getArrayWithItems(10), 10).length,\n                1\n            );\n            assert.strictEqual(\n                batchArray(getArrayWithItems(10), 5).length,\n                2\n            );\n            assert.strictEqual(\n                batchArray(getArrayWithItems(10), 3).length,\n                4\n            );\n            assert.strictEqual(\n                batchArray(getArrayWithItems(10), 9).length,\n                2\n            );\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"should get the correct values","suites":["util.test.js",".objectPathMonad()"],"updatePoint":{"line":439,"column":41},"line":439,"code":"        it('should get the correct values', () => {\n            const docData = {\n                top: 'top',\n                nes: {\n                    ted: 'nested'\n                }\n            }\n            assert.strictEqual(\n                objectPathMonad('top')(docData),\n                'top'\n            );\n\n            assert.strictEqual(\n                objectPathMonad('nes.ted')(docData),\n                'nested'\n            );\n            assert.strictEqual(\n                objectPathMonad('notHereTop')(docData),\n                undefined\n            );\n            assert.strictEqual(\n                objectPathMonad('not.here.nes.ted')(docData),\n                undefined\n            );\n        });","file":"unit/util.test.ts","skipped":false,"dir":"test"},{"name":"validate one human","suites":["RxStorageInstance","positive"],"updatePoint":{"line":79,"column":38},"line":79,"code":"                it('validate one human', async () => {\n                    const instance = await getRxStorageInstance(schemas.human);\n                    await instance.bulkWrite([{\n                        document: toRxDocumentData(schemaObjects.human())\n                    }], testContext);\n                    await instance.close();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"validate one point","suites":["RxStorageInstance","positive"],"updatePoint":{"line":87,"column":38},"line":87,"code":"                it('validate one point', async () => {\n                    const instance = await getRxStorageInstance(schemas.point);\n                    await instance.bulkWrite([{\n                        document: toRxDocumentData(schemaObjects.point())\n                    }], testContext);\n                    await instance.close();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"validate without non-required","suites":["RxStorageInstance","positive"],"updatePoint":{"line":94,"column":49},"line":94,"code":"                it('validate without non-required', async () => {\n                    const instance = await getRxStorageInstance(schemas.human);\n                    const obj: any = schemaObjects.human();\n                    delete obj.age;\n\n                    await instance.bulkWrite([{\n                        document: toRxDocumentData(obj)\n                    }], testContext);\n                    await instance.close();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"validate nested","suites":["RxStorageInstance","positive"],"updatePoint":{"line":104,"column":35},"line":104,"code":"                it('validate nested', async () => {\n                    const instance = await getRxStorageInstance(schemas.nestedHuman);\n                    const obj: any = schemaObjects.nestedHuman();\n                    await instance.bulkWrite([{\n                        document: toRxDocumentData(obj)\n                    }], testContext);\n                    await instance.close();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"validate with decimal _meta.lwt times","suites":["RxStorageInstance","positive"],"updatePoint":{"line":112,"column":57},"line":112,"code":"                it('validate with decimal _meta.lwt times', async () => {\n                    const instance = await getRxStorageInstance(schemas.nestedHuman);\n                    const amount = config.isFastMode() ? 10 : 155;\n                    const writeRows = new Array(amount)\n                        .fill(0)\n                        .map(() => schemaObjects.nestedHuman())\n                        .map(obj => toRxDocumentData(obj))\n                        .map(document => ({ document }));\n\n                    try {\n                        await instance.bulkWrite(writeRows, testContext);\n                    } catch (err) {\n                        console.dir('errored:');\n                        console.dir(err);\n                        throw err;\n                    }\n\n                    await instance.close();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"should allow this complex regex pattern","suites":["RxStorageInstance","positive"],"updatePoint":{"line":132,"column":59},"line":132,"code":"                it('should allow this complex regex pattern', async () => {\n                    const schema: RxJsonSchema<{ id: string }> = {\n                        version: 0,\n                        primaryKey: 'id',\n                        required: ['id'],\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 40,\n                                pattern: '^[a-zA-Z_: 0-9\\\\-\\\\.]{3,40}$',\n                            }\n                        }\n                    };\n                    const instance = await getRxStorageInstance(schema);\n\n                    // valid\n                    await instance.bulkWrite([{\n                        document: toRxDocumentData({\n                            id: 'abcd-:2'\n                        } as any)\n                    }], testContext);\n\n                    // non valid\n                    await assertThrows(\n                        () => instance.bulkWrite([{\n                            document: toRxDocumentData({\n                                id: 'a'\n                            } as any)\n                        }], testContext),\n                        'RxError',\n                        'VD2'\n                    );\n                    await instance.close();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"should work with a schema as nested additionalProperties","suites":["RxStorageInstance","positive"],"updatePoint":{"line":167,"column":76},"line":167,"code":"                it('should work with a schema as nested additionalProperties', async () => {\n                    const jsonSchema: any = clone(schemas.heroArray);\n                    jsonSchema.properties.skills.items['additionalProperties'] = {type: 'number'};\n                    const instance = await getRxStorageInstance(jsonSchema);\n\n                    // valid\n                    await instance.bulkWrite([{\n                        document: toRxDocumentData({\n                            name: 'foobar',\n                            skills: [\n                                {\n                                    name: 'foo',\n                                    damage: 10,\n                                    nonDefinedField: 42\n                                }\n                            ],\n                        })\n                    }], testContext);\n\n                    // non valid\n                    await assertThrows(\n                        () => instance.bulkWrite([{\n                            document: toRxDocumentData({\n                                name: 'foobar',\n                                skills: [\n                                    {\n                                        name: 'foo',\n                                        damage: 10,\n                                        nonDefinedField: 'foobar'\n                                    }\n                                ],\n                            })\n                        }], testContext),\n                        'RxError',\n                        'VD2'\n                    );\n                    await instance.close();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"not validate other object","suites":["RxStorageInstance","negative"],"updatePoint":{"line":207,"column":45},"line":207,"code":"                it('not validate other object', async () => {\n                    const instance = await getRxStorageInstance(schemas.human);\n                    await assertThrows(\n                        () => instance.bulkWrite([{\n                            document: toRxDocumentData({\n                                foo: 'bar'\n                            } as any)\n                        }], testContext),\n                        'RxError',\n                        'VD2'\n                    );\n                    await instance.close();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"required field not given","suites":["RxStorageInstance","negative"],"updatePoint":{"line":220,"column":44},"line":220,"code":"                it('required field not given', async () => {\n                    const instance = await getRxStorageInstance(schemas.human);\n                    const obj: any = schemaObjects.human();\n                    delete obj.lastName;\n\n                    await assertThrows(\n                        () => instance.bulkWrite([{\n                            document: toRxDocumentData(obj)\n                        }], testContext),\n                        'RxError',\n                        'required'\n                    );\n                    await instance.close();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"overflow maximum int","suites":["RxStorageInstance","negative"],"updatePoint":{"line":234,"column":40},"line":234,"code":"                it('overflow maximum int', async () => {\n                    const instance = await getRxStorageInstance(schemas.human);\n                    const obj: any = schemaObjects.human();\n                    obj.age = 1000;\n\n                    await assertThrows(\n                        () => instance.bulkWrite([{\n                            document: toRxDocumentData(obj)\n                        }], testContext),\n                        'RxError',\n                        'maximum'\n                    );\n                    await instance.close();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"additional property","suites":["RxStorageInstance","negative"],"updatePoint":{"line":248,"column":39},"line":248,"code":"                it('additional property', async () => {\n                    const instance = await getRxStorageInstance(schemas.human);\n                    const obj: any = schemaObjects.human();\n                    obj['token'] = randomCouchString(5);\n\n                    await assertThrows(\n                        () => instance.bulkWrite([{\n                            document: toRxDocumentData(obj)\n                        }], testContext),\n                        'RxError',\n                        'dditional properties'\n                    );\n                    await instance.close();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"should respect nested additionalProperties: false","suites":["RxStorageInstance","negative"],"updatePoint":{"line":262,"column":69},"line":262,"code":"                it('should respect nested additionalProperties: false', async () => {\n                    const jsonSchema: any = clone(schemas.heroArray);\n                    jsonSchema.properties.skills.items['additionalProperties'] = false;\n                    const instance = await getRxStorageInstance(jsonSchema);\n                    const obj = {\n                        name: 'foobar',\n                        skills: [\n                            {\n                                name: 'foo',\n                                damage: 10,\n                                nonDefinedField: 'foobar'\n                            }\n                        ],\n                    };\n                    await assertThrows(\n                        () => instance.bulkWrite([{\n                            document: toRxDocumentData(obj)\n                        }], testContext),\n                        'RxError',\n                        'dditional properties'\n                    );\n                    await instance.close();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"do not allow primary==null","suites":["RxStorageInstance","negative"],"updatePoint":{"line":285,"column":46},"line":285,"code":"                it('do not allow primary==null', async () => {\n                    const instance = await getRxStorageInstance(schemas.primaryHuman);\n                    const obj: any = schemaObjects.simpleHuman();\n                    obj.passportId = null;\n                    await assertThrows(\n                        () => instance.bulkWrite([{\n                            document: toRxDocumentData(obj)\n                        }], testContext),\n                        'RxError',\n                        'not match'\n                    );\n                    await instance.close();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"should throw if enum does not match","suites":["RxStorageInstance","negative"],"updatePoint":{"line":298,"column":55},"line":298,"code":"                it('should throw if enum does not match', async () => {\n                    const schema: RxJsonSchema<{ id: string; childProperty: 'A' | 'B' | 'C' }> = {\n                        version: 0,\n                        primaryKey: 'id',\n                        type: 'object',\n                        properties: {\n                            id: {\n                                type: 'string',\n                                maxLength: 100\n                            },\n                            childProperty: {\n                                type: 'string',\n                                enum: ['A', 'B', 'C']\n                            }\n                        }\n                    };\n                    const instance = await getRxStorageInstance(schema);\n\n                    // this must work\n                    await instance.bulkWrite([{\n                        document: toRxDocumentData({\n                            id: randomCouchString(12),\n                            childProperty: 'A'\n                        })\n                    }], testContext);\n\n                    // this must not work\n                    await assertThrows(\n                        () => instance.bulkWrite([{\n                            document: toRxDocumentData({\n                                id: randomCouchString(12),\n                                childProperty: 'Z'\n                            } as any)\n                        }], testContext),\n                        'RxError',\n                        'enum'\n                    );\n\n                    await instance.close();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"accessible error-parameters","suites":["RxStorageInstance","error layout"],"updatePoint":{"line":340,"column":47},"line":340,"code":"                it('accessible error-parameters', async () => {\n                    const instance = await getRxStorageInstance(schemas.human);\n                    const obj = schemaObjects.human();\n                    (obj as any)['foobar'] = 'barfoo';\n                    let hasThrown = false;\n                    try {\n                        await instance.bulkWrite([{\n                            document: toRxDocumentData(obj)\n                        }], testContext);\n                    } catch (err) {\n                        const message = (err as any).parameters.errors[0].message;\n                        assert.ok(message.includes('dditional'));\n                        hasThrown = true;\n                    }\n                    assert.ok(hasThrown);\n                    await instance.close();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"final fields should be required","suites":["RxStorageInstance","error layout"],"updatePoint":{"line":357,"column":51},"line":357,"code":"                it('final fields should be required', async () => {\n                    const instance = await getRxStorageInstance(schemas.humanFinal);\n                    let hasThrown = false;\n                    const obj = {\n                        passportId: 'foobar',\n                        firstName: 'foo',\n                        lastName: 'bar'\n                    };\n                    try {\n                        await instance.bulkWrite([{\n                            document: toRxDocumentData(obj)\n                        }], testContext);\n                    } catch (err) {\n                        const deepParam = (err as any).parameters.errors[0];\n                        assert.ok(\n                            JSON.stringify(deepParam).includes('age')\n                        );\n                        hasThrown = true;\n                    }\n                    assert.ok(hasThrown);\n                    await instance.close();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"should not insert broken human (required missing)","suites":["RxDatabase","RxCollection().insert()"],"updatePoint":{"line":383,"column":69},"line":383,"code":"                it('should not insert broken human (required missing)', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.human\n                        }\n                    });\n                    const human: any = schemaObjects.human();\n                    delete human.firstName;\n                    await assertThrows(\n                        () => collections.human.insert(human),\n                        'RxError',\n                        'not match schema'\n                    );\n                    db.destroy();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"should get no event on non-succes-insert","suites":["RxDatabase","RxCollection().insert()"],"updatePoint":{"line":402,"column":60},"line":402,"code":"                it('should get no event on non-succes-insert', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage\n                    });\n                    const cols = await db.addCollections({\n                        foobar: {\n                            schema: schemas.human\n                        }\n                    });\n                    const c = cols.foobar;\n\n                    let calls = 0;\n                    const sub = db.$.subscribe(() => {\n                        calls++;\n                    });\n                    await assertThrows(\n                        () => c.insert({\n                            foo: 'baar'\n                        }),\n                        'RxError',\n                        'schema'\n                    );\n                    assert.strictEqual(calls, 0);\n                    sub.unsubscribe();\n                    db.destroy();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"should not insert human with additional prop","suites":["RxDatabase","RxCollection().insert()"],"updatePoint":{"line":429,"column":64},"line":429,"code":"                it('should not insert human with additional prop', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.human\n                        }\n                    });\n                    const human: any = schemaObjects.human();\n                    human['any'] = randomCouchString(20);\n                    await assertThrows(\n                        () => collections.human.insert(human),\n                        'RxError',\n                        'not match schema'\n                    );\n                    db.destroy();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"should not insert when primary is missing","suites":["RxDatabase","RxCollection().insert()"],"updatePoint":{"line":448,"column":61},"line":448,"code":"                it('should not insert when primary is missing', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    await assertThrows(\n                        () => collections.human.insert({\n                            firstName: 'foo',\n                            lastName: 'bar',\n                            age: 20\n                        }),\n                        'RxError',\n                        'required'\n                    );\n                    db.destroy();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"throw when schema not matching","suites":["RxDatabase","RxCollection().upsert()"],"updatePoint":{"line":471,"column":50},"line":471,"code":"                it('throw when schema not matching', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.primaryHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    const obj: any = schemaObjects.simpleHuman();\n                    obj.firstName = 'foobar';\n                    obj['foo'] = 'bar';\n                    await assertThrows(\n                        () => collection.upsert(obj),\n                        'RxError',\n                        'not match'\n                    );\n                    await db.destroy();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"should throw when not matching schema","suites":["RxDatabase","RxCollection().atomicUpsert()","negative"],"updatePoint":{"line":495,"column":61},"line":495,"code":"                    it('should throw when not matching schema', async () => {\n                        const db = await createRxDatabase({\n                            name: randomCouchString(10),\n                            storage\n                        });\n                        const collections = await db.addCollections({\n                            human: {\n                                schema: schemas.primaryHuman\n                            }\n                        });\n                        const collection = collections.human;\n                        const docData = schemaObjects.simpleHuman();\n                        await Promise.all([\n                            collection.atomicUpsert(docData),\n                            collection.atomicUpsert(docData),\n                            collection.atomicUpsert(docData)\n                        ]);\n                        const docData2 = clone(docData);\n                        docData2['firstName'] = 1337 as any;\n                        await assertThrows(\n                            () => collection.atomicUpsert(docData2),\n                            'RxError',\n                            'schema'\n                        );\n                        db.destroy();\n                    });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"should throw when not matching schema","suites":["RxDatabase","RxDocument.atomicUpdate()"],"updatePoint":{"line":524,"column":57},"line":524,"code":"                it('should throw when not matching schema', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.human\n                        }\n                    });\n                    const collection = collections.human;\n                    const doc = await collection.insert(schemaObjects.human());\n                    await doc.atomicUpdate((innerDoc: any) => {\n                        innerDoc.age = 50;\n                        return innerDoc;\n                    });\n                    assert.strictEqual(doc.age, 50);\n                    await assertThrows(\n                        () => doc.atomicUpdate((innerDoc: any) => {\n                            innerDoc.age = 'foobar';\n                            return innerDoc;\n                        }),\n                        'RxError',\n                        'schema'\n                    );\n                    db.destroy();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"should crash on non document field","suites":["RxDatabase","RxDocument.atomicPatch()"],"updatePoint":{"line":553,"column":54},"line":553,"code":"                it('should crash on non document field', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.nestedHuman\n                        }\n                    });\n                    const collection = collections.human;\n                    const doc = await collection.insert(schemaObjects.nestedHuman());\n                    await assertThrows(\n                        () => doc.atomicPatch({\n                            foobar: 'foobar'\n                        } as any),\n                        'RxError'\n                    );\n                    db.destroy();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"should throw if preInsert hook invalidates the schema","suites":["RxDatabase","RxCollection() hooks"],"updatePoint":{"line":575,"column":73},"line":575,"code":"                it('should throw if preInsert hook invalidates the schema', async () => {\n                    const db = await createRxDatabase({\n                        name: randomCouchString(10),\n                        storage\n                    });\n                    const collections = await db.addCollections({\n                        human: {\n                            schema: schemas.human\n                        }\n                    });\n                    const collection = collections.human;\n                    const human = schemaObjects.human();\n\n                    collection.preInsert(function (doc: any) {\n                        doc.lastName = 1337;\n                    }, false);\n\n                    await assertThrows(\n                        () => collection.insert(human),\n                        'RxError',\n                        'not match'\n                    );\n                    db.destroy();\n                });","file":"unit/validate.test.ts","skipped":false,"dir":"test"},{"name":"#734 Invalid value persists in document after failed update","suites":["issues"],"updatePoint":{"line":602,"column":75},"line":602,"code":"            it('#734 Invalid value persists in document after failed update', async () => {\n                // create a schema\n                const schemaEnum = ['A', 'B'];\n                const mySchema: RxJsonSchema<{ id: string, children: any[] }> = {\n                    version: 0,\n                    primaryKey: 'id',\n                    required: ['id'],\n                    type: 'object',\n                    properties: {\n                        id: {\n                            type: 'string',\n                            maxLength: 100\n                        },\n                        children: {\n                            type: 'array',\n                            items: {\n                                type: 'object',\n                                properties: {\n                                    name: {\n                                        type: 'string'\n                                    },\n                                    abLetter: {\n                                        type: 'string',\n                                        enum: schemaEnum,\n                                    },\n                                }\n                            }\n                        }\n                    }\n                };\n\n                // generate a random database-name\n                const name = randomCouchString(10);\n\n                // create a database\n                const db = await createRxDatabase({\n                    name,\n                    storage,\n                    ignoreDuplicate: true\n                });\n                // create a collection\n                const colName = randomCouchString(10);\n                const collections = await db.addCollections({\n                    [colName]: {\n                        schema: mySchema\n                    }\n                });\n                const collection = collections[colName];\n\n                // insert a document\n                const child1 = {\n                    name: 'foo',\n                    abLetter: 'A'\n                };\n                const child2 = {\n                    name: 'bar',\n                    abLetter: 'B'\n                };\n                const doc = await collection.insert({\n                    id: randomCouchString(12),\n                    children: [\n                        child1,\n                        child2\n                    ],\n                });\n\n                const colDoc = await collection.findOne({\n                    selector: {\n                        id: doc.id\n                    }\n                }).exec();\n\n\n                try {\n                    await colDoc.update({\n                        $set: {\n                            'children.1.abLetter': 'invalidEnumValue',\n                        },\n                    });\n                } catch (err) { }\n\n                assert.strictEqual(colDoc.children[1].abLetter, 'B');\n\n\n                // clean up afterwards\n                db.destroy();\n            });","file":"unit/validate.test.ts","skipped":false,"dir":"test"}]}