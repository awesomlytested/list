{"repo":"n8n-io/n8n","url":"https://github.com/n8n-io/n8n","branch":"master","configs":[{"package":"n8n","lang":"ts","dir":"packages/cli/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"n8n-core","lang":"ts","dir":"packages/core/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"n8n-editor-ui","lang":"js","dir":"packages/editor-ui/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"n8n-nodes-base","lang":"ts","dir":"packages/nodes-base/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"n8n-workflow","lang":"ts","dir":"packages/workflow/test","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"POST /login should log user in","suites":[],"updatePoint":{"line":46,"column":36},"line":46,"code":"test('POST /login should log user in', async () => {\n\tconst ownerPassword = randomValidPassword();\n\tconst owner = await testDb.createUser({\n\t\tpassword: ownerPassword,\n\t\tglobalRole: globalOwnerRole,\n\t});\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst response = await authlessAgent.post('/login').send({\n\t\temail: owner.email,\n\t\tpassword: ownerPassword,\n\t});\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst {\n\t\tid,\n\t\temail,\n\t\tfirstName,\n\t\tlastName,\n\t\tpassword,\n\t\tpersonalizationAnswers,\n\t\tglobalRole,\n\t\tresetPasswordToken,\n\t} = response.body.data;\n\n\texpect(validator.isUUID(id)).toBe(true);\n\texpect(email).toBe(owner.email);\n\texpect(firstName).toBe(owner.firstName);\n\texpect(lastName).toBe(owner.lastName);\n\texpect(password).toBeUndefined();\n\texpect(personalizationAnswers).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(resetPasswordToken).toBeUndefined();\n\texpect(globalRole).toBeDefined();\n\texpect(globalRole.name).toBe('owner');\n\texpect(globalRole.scope).toBe('global');\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeDefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /login should return 401 Unauthorized if no cookie","suites":[],"updatePoint":{"line":89,"column":60},"line":89,"code":"test('GET /login should return 401 Unauthorized if no cookie', async () => {\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst response = await authlessAgent.get('/login');\n\n\texpect(response.statusCode).toBe(401);\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeUndefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /login should return cookie if UM is disabled","suites":[],"updatePoint":{"line":100,"column":55},"line":100,"code":"test('GET /login should return cookie if UM is disabled', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconfig.set('userManagement.isInstanceOwnerSetUp', false);\n\n\tawait Db.collections.Settings.update(\n\t\t{ key: 'userManagement.isInstanceOwnerSetUp' },\n\t\t{ value: JSON.stringify(false) },\n\t);\n\n\tconst authOwnerShellAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\tconst response = await authOwnerShellAgent.get('/login');\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeDefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /login should return 401 Unauthorized if invalid cookie","suites":[],"updatePoint":{"line":120,"column":65},"line":120,"code":"test('GET /login should return 401 Unauthorized if invalid cookie', async () => {\n\tconst invalidAuthAgent = utils.createAgent(app);\n\tinvalidAuthAgent.jar.setCookie(`${AUTH_COOKIE_NAME}=invalid`);\n\n\tconst response = await invalidAuthAgent.get('/login');\n\n\texpect(response.statusCode).toBe(401);\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeUndefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /login should return logged-in owner shell","suites":[],"updatePoint":{"line":132,"column":52},"line":132,"code":"test('GET /login should return logged-in owner shell', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\tconst response = await authMemberAgent.get('/login');\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst {\n\t\tid,\n\t\temail,\n\t\tfirstName,\n\t\tlastName,\n\t\tpassword,\n\t\tpersonalizationAnswers,\n\t\tglobalRole,\n\t\tresetPasswordToken,\n\t} = response.body.data;\n\n\texpect(validator.isUUID(id)).toBe(true);\n\texpect(email).toBeDefined();\n\texpect(firstName).toBeNull();\n\texpect(lastName).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(personalizationAnswers).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(resetPasswordToken).toBeUndefined();\n\texpect(globalRole).toBeDefined();\n\texpect(globalRole.name).toBe('owner');\n\texpect(globalRole.scope).toBe('global');\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeUndefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /login should return logged-in member shell","suites":[],"updatePoint":{"line":167,"column":53},"line":167,"code":"test('GET /login should return logged-in member shell', async () => {\n\tconst memberShell = await testDb.createUserShell(globalMemberRole);\n\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: memberShell });\n\n\tconst response = await authMemberAgent.get('/login');\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst {\n\t\tid,\n\t\temail,\n\t\tfirstName,\n\t\tlastName,\n\t\tpassword,\n\t\tpersonalizationAnswers,\n\t\tglobalRole,\n\t\tresetPasswordToken,\n\t} = response.body.data;\n\n\texpect(validator.isUUID(id)).toBe(true);\n\texpect(email).toBeDefined();\n\texpect(firstName).toBeNull();\n\texpect(lastName).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(personalizationAnswers).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(resetPasswordToken).toBeUndefined();\n\texpect(globalRole).toBeDefined();\n\texpect(globalRole.name).toBe('member');\n\texpect(globalRole.scope).toBe('global');\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeUndefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /login should return logged-in owner","suites":[],"updatePoint":{"line":202,"column":46},"line":202,"code":"test('GET /login should return logged-in owner', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: owner });\n\n\tconst response = await authOwnerAgent.get('/login');\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst {\n\t\tid,\n\t\temail,\n\t\tfirstName,\n\t\tlastName,\n\t\tpassword,\n\t\tpersonalizationAnswers,\n\t\tglobalRole,\n\t\tresetPasswordToken,\n\t} = response.body.data;\n\n\texpect(validator.isUUID(id)).toBe(true);\n\texpect(email).toBe(owner.email);\n\texpect(firstName).toBe(owner.firstName);\n\texpect(lastName).toBe(owner.lastName);\n\texpect(password).toBeUndefined();\n\texpect(personalizationAnswers).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(resetPasswordToken).toBeUndefined();\n\texpect(globalRole).toBeDefined();\n\texpect(globalRole.name).toBe('owner');\n\texpect(globalRole.scope).toBe('global');\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeUndefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /login should return logged-in member","suites":[],"updatePoint":{"line":237,"column":47},"line":237,"code":"test('GET /login should return logged-in member', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: member });\n\n\tconst response = await authMemberAgent.get('/login');\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst {\n\t\tid,\n\t\temail,\n\t\tfirstName,\n\t\tlastName,\n\t\tpassword,\n\t\tpersonalizationAnswers,\n\t\tglobalRole,\n\t\tresetPasswordToken,\n\t} = response.body.data;\n\n\texpect(validator.isUUID(id)).toBe(true);\n\texpect(email).toBe(member.email);\n\texpect(firstName).toBe(member.firstName);\n\texpect(lastName).toBe(member.lastName);\n\texpect(password).toBeUndefined();\n\texpect(personalizationAnswers).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(resetPasswordToken).toBeUndefined();\n\texpect(globalRole).toBeDefined();\n\texpect(globalRole.name).toBe('member');\n\texpect(globalRole.scope).toBe('global');\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeUndefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /logout should log user out","suites":[],"updatePoint":{"line":272,"column":38},"line":272,"code":"test('POST /logout should log user out', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: owner });\n\n\tconst response = await authOwnerAgent.post('/logout');\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body).toEqual(LOGGED_OUT_RESPONSE_BODY);\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeUndefined();\n});","file":"integration/auth.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":" should return 401 Unauthorized if no cookie","suites":[],"updatePoint":{"line":40,"column":59},"line":40,"code":"\ttest(`${route} should return 401 Unauthorized if no cookie`, async () => {\n\t\tconst response = await request(app)[method](endpoint).use(utils.prefix(REST_PATH_SEGMENT));\n\n\t\texpect(response.statusCode).toBe(401);\n\t});","file":"integration/auth.mw.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":" should return 403 Forbidden for member","suites":[],"updatePoint":{"line":50,"column":54},"line":50,"code":"\ttest(`${route} should return 403 Forbidden for member`, async () => {\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: member });\n\t\tconst response = await authMemberAgent[method](endpoint);\n\n\t\texpect(response.statusCode).toBe(403);\n\t});","file":"integration/auth.mw.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /credentials should create cred","suites":[],"updatePoint":{"line":48,"column":42},"line":48,"code":"test('POST /credentials should create cred', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\tconst payload = credentialPayload();\n\n\tconst response = await authOwnerAgent.post('/credentials').send(payload);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, name, type, nodesAccess, data: encryptedData } = response.body.data;\n\n\texpect(name).toBe(payload.name);\n\texpect(type).toBe(payload.type);\n\texpect(nodesAccess[0].nodeType).toBe(payload.nodesAccess[0].nodeType);\n\texpect(encryptedData).not.toBe(payload.data);\n\n\tconst credential = await Db.collections.Credentials.findOneOrFail(id);\n\n\texpect(credential.name).toBe(payload.name);\n\texpect(credential.type).toBe(payload.type);\n\texpect(credential.nodesAccess[0].nodeType).toBe(payload.nodesAccess[0].nodeType);\n\texpect(credential.data).not.toBe(payload.data);\n\n\tconst sharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\trelations: ['user', 'credentials'],\n\t\twhere: { credentials: credential },\n\t});\n\n\texpect(sharedCredential.user.id).toBe(ownerShell.id);\n\texpect(sharedCredential.credentials.name).toBe(payload.name);\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /credentials should fail with invalid inputs","suites":[],"updatePoint":{"line":81,"column":55},"line":81,"code":"test('POST /credentials should fail with invalid inputs', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\tawait Promise.all(\n\t\tINVALID_PAYLOADS.map(async (invalidPayload) => {\n\t\t\tconst response = await authOwnerAgent.post('/credentials').send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\t\t}),\n\t);\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /credentials should fail with missing encryption key","suites":[],"updatePoint":{"line":93,"column":63},"line":93,"code":"test('POST /credentials should fail with missing encryption key', async () => {\n\tconst mock = jest.spyOn(UserSettings, 'getEncryptionKey');\n\tmock.mockRejectedValue(new Error(RESPONSE_ERROR_MESSAGES.NO_ENCRYPTION_KEY));\n\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\tconst response = await authOwnerAgent.post('/credentials').send(credentialPayload());\n\n\texpect(response.statusCode).toBe(500);\n\n\tmock.mockRestore();\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /credentials should ignore ID in payload","suites":[],"updatePoint":{"line":107,"column":51},"line":107,"code":"test('POST /credentials should ignore ID in payload', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\tconst firstResponse = await authOwnerAgent\n\t\t.post('/credentials')\n\t\t.send({ id: '8', ...credentialPayload() });\n\n\texpect(firstResponse.body.data.id).not.toBe('8');\n\n\tconst secondResponse = await authOwnerAgent\n\t\t.post('/credentials')\n\t\t.send({ id: 8, ...credentialPayload() });\n\n\texpect(secondResponse.body.data.id).not.toBe(8);\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /credentials/:id should delete owned cred for owner","suites":[],"updatePoint":{"line":124,"column":64},"line":124,"code":"test('DELETE /credentials/:id should delete owned cred for owner', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\tconst savedCredential = await saveCredential(credentialPayload(), { user: ownerShell });\n\n\tconst response = await authOwnerAgent.delete(`/credentials/${savedCredential.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body).toEqual({ data: true });\n\n\tconst deletedCredential = await Db.collections.Credentials.findOne(savedCredential.id);\n\n\texpect(deletedCredential).toBeUndefined(); // deleted\n\n\tconst deletedSharedCredential = await Db.collections.SharedCredentials.findOne();\n\n\texpect(deletedSharedCredential).toBeUndefined(); // deleted\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /credentials/:id should delete non-owned cred for owner","suites":[],"updatePoint":{"line":143,"column":68},"line":143,"code":"test('DELETE /credentials/:id should delete non-owned cred for owner', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst savedCredential = await saveCredential(credentialPayload(), { user: member });\n\n\tconst response = await authOwnerAgent.delete(`/credentials/${savedCredential.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body).toEqual({ data: true });\n\n\tconst deletedCredential = await Db.collections.Credentials.findOne(savedCredential.id);\n\n\texpect(deletedCredential).toBeUndefined(); // deleted\n\n\tconst deletedSharedCredential = await Db.collections.SharedCredentials.findOne();\n\n\texpect(deletedSharedCredential).toBeUndefined(); // deleted\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /credentials/:id should delete owned cred for member","suites":[],"updatePoint":{"line":163,"column":65},"line":163,"code":"test('DELETE /credentials/:id should delete owned cred for member', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: member });\n\tconst savedCredential = await saveCredential(credentialPayload(), { user: member });\n\n\tconst response = await authMemberAgent.delete(`/credentials/${savedCredential.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body).toEqual({ data: true });\n\n\tconst deletedCredential = await Db.collections.Credentials.findOne(savedCredential.id);\n\n\texpect(deletedCredential).toBeUndefined(); // deleted\n\n\tconst deletedSharedCredential = await Db.collections.SharedCredentials.findOne();\n\n\texpect(deletedSharedCredential).toBeUndefined(); // deleted\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /credentials/:id should not delete non-owned cred for member","suites":[],"updatePoint":{"line":182,"column":73},"line":182,"code":"test('DELETE /credentials/:id should not delete non-owned cred for member', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: member });\n\tconst savedCredential = await saveCredential(credentialPayload(), { user: ownerShell });\n\n\tconst response = await authMemberAgent.delete(`/credentials/${savedCredential.id}`);\n\n\texpect(response.statusCode).toBe(404);\n\n\tconst shellCredential = await Db.collections.Credentials.findOne(savedCredential.id);\n\n\texpect(shellCredential).toBeDefined(); // not deleted\n\n\tconst deletedSharedCredential = await Db.collections.SharedCredentials.findOne();\n\n\texpect(deletedSharedCredential).toBeDefined(); // not deleted\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /credentials/:id should fail if cred not found","suites":[],"updatePoint":{"line":201,"column":59},"line":201,"code":"test('DELETE /credentials/:id should fail if cred not found', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\tconst response = await authOwnerAgent.delete('/credentials/123');\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /credentials/:id should update owned cred for owner","suites":[],"updatePoint":{"line":210,"column":63},"line":210,"code":"test('PATCH /credentials/:id should update owned cred for owner', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\tconst savedCredential = await saveCredential(credentialPayload(), { user: ownerShell });\n\tconst patchPayload = credentialPayload();\n\n\tconst response = await authOwnerAgent\n\t\t.patch(`/credentials/${savedCredential.id}`)\n\t\t.send(patchPayload);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, name, type, nodesAccess, data: encryptedData } = response.body.data;\n\n\texpect(name).toBe(patchPayload.name);\n\texpect(type).toBe(patchPayload.type);\n\texpect(nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess[0].nodeType);\n\texpect(encryptedData).not.toBe(patchPayload.data);\n\n\tconst credential = await Db.collections.Credentials.findOneOrFail(id);\n\n\texpect(credential.name).toBe(patchPayload.name);\n\texpect(credential.type).toBe(patchPayload.type);\n\texpect(credential.nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess[0].nodeType);\n\texpect(credential.data).not.toBe(patchPayload.data);\n\n\tconst sharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\trelations: ['credentials'],\n\t\twhere: { credentials: credential },\n\t});\n\n\texpect(sharedCredential.credentials.name).toBe(patchPayload.name); // updated\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /credentials/:id should update non-owned cred for owner","suites":[],"updatePoint":{"line":244,"column":67},"line":244,"code":"test('PATCH /credentials/:id should update non-owned cred for owner', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst savedCredential = await saveCredential(credentialPayload(), { user: member });\n\tconst patchPayload = credentialPayload();\n\n\tconst response = await authOwnerAgent\n\t\t.patch(`/credentials/${savedCredential.id}`)\n\t\t.send(patchPayload);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, name, type, nodesAccess, data: encryptedData } = response.body.data;\n\n\texpect(name).toBe(patchPayload.name);\n\texpect(type).toBe(patchPayload.type);\n\texpect(nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess[0].nodeType);\n\texpect(encryptedData).not.toBe(patchPayload.data);\n\n\tconst credential = await Db.collections.Credentials.findOneOrFail(id);\n\n\texpect(credential.name).toBe(patchPayload.name);\n\texpect(credential.type).toBe(patchPayload.type);\n\texpect(credential.nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess[0].nodeType);\n\texpect(credential.data).not.toBe(patchPayload.data);\n\n\tconst sharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\trelations: ['credentials'],\n\t\twhere: { credentials: credential },\n\t});\n\n\texpect(sharedCredential.credentials.name).toBe(patchPayload.name); // updated\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /credentials/:id should update owned cred for member","suites":[],"updatePoint":{"line":279,"column":64},"line":279,"code":"test('PATCH /credentials/:id should update owned cred for member', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: member });\n\tconst savedCredential = await saveCredential(credentialPayload(), { user: member });\n\tconst patchPayload = credentialPayload();\n\n\tconst response = await authMemberAgent\n\t\t.patch(`/credentials/${savedCredential.id}`)\n\t\t.send(patchPayload);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, name, type, nodesAccess, data: encryptedData } = response.body.data;\n\n\texpect(name).toBe(patchPayload.name);\n\texpect(type).toBe(patchPayload.type);\n\texpect(nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess[0].nodeType);\n\texpect(encryptedData).not.toBe(patchPayload.data);\n\n\tconst credential = await Db.collections.Credentials.findOneOrFail(id);\n\n\texpect(credential.name).toBe(patchPayload.name);\n\texpect(credential.type).toBe(patchPayload.type);\n\texpect(credential.nodesAccess[0].nodeType).toBe(patchPayload.nodesAccess[0].nodeType);\n\texpect(credential.data).not.toBe(patchPayload.data);\n\n\tconst sharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\trelations: ['credentials'],\n\t\twhere: { credentials: credential },\n\t});\n\n\texpect(sharedCredential.credentials.name).toBe(patchPayload.name); // updated\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /credentials/:id should not update non-owned cred for member","suites":[],"updatePoint":{"line":313,"column":72},"line":313,"code":"test('PATCH /credentials/:id should not update non-owned cred for member', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: member });\n\tconst savedCredential = await saveCredential(credentialPayload(), { user: ownerShell });\n\tconst patchPayload = credentialPayload();\n\n\tconst response = await authMemberAgent\n\t\t.patch(`/credentials/${savedCredential.id}`)\n\t\t.send(patchPayload);\n\n\texpect(response.statusCode).toBe(404);\n\n\tconst shellCredential = await Db.collections.Credentials.findOneOrFail(savedCredential.id);\n\n\texpect(shellCredential.name).not.toBe(patchPayload.name); // not updated\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /credentials/:id should fail with invalid inputs","suites":[],"updatePoint":{"line":331,"column":60},"line":331,"code":"test('PATCH /credentials/:id should fail with invalid inputs', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\tconst savedCredential = await saveCredential(credentialPayload(), { user: ownerShell });\n\n\tawait Promise.all(\n\t\tINVALID_PAYLOADS.map(async (invalidPayload) => {\n\t\t\tconst response = await authOwnerAgent\n\t\t\t\t.patch(`/credentials/${savedCredential.id}`)\n\t\t\t\t.send(invalidPayload);\n\n\t\t\texpect(response.statusCode).toBe(400);\n\t\t}),\n\t);\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /credentials/:id should fail if cred not found","suites":[],"updatePoint":{"line":347,"column":58},"line":347,"code":"test('PATCH /credentials/:id should fail if cred not found', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\tconst response = await authOwnerAgent.patch('/credentials/123').send(credentialPayload());\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /credentials/:id should fail with missing encryption key","suites":[],"updatePoint":{"line":356,"column":68},"line":356,"code":"test('PATCH /credentials/:id should fail with missing encryption key', async () => {\n\tconst mock = jest.spyOn(UserSettings, 'getEncryptionKey');\n\tmock.mockRejectedValue(new Error(RESPONSE_ERROR_MESSAGES.NO_ENCRYPTION_KEY));\n\n\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\tconst response = await authOwnerAgent.post('/credentials').send(credentialPayload());\n\n\texpect(response.statusCode).toBe(500);\n\n\tmock.mockRestore();\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials should retrieve all creds for owner","suites":[],"updatePoint":{"line":371,"column":58},"line":371,"code":"test('GET /credentials should retrieve all creds for owner', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\tfor (let i = 0; i < 3; i++) {\n\t\tawait saveCredential(credentialPayload(), { user: ownerShell });\n\t}\n\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tawait saveCredential(credentialPayload(), { user: member });\n\n\tconst response = await authOwnerAgent.get('/credentials');\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data.length).toBe(4); // 3 owner + 1 member\n\n\tawait Promise.all(\n\t\tresponse.body.data.map(async (credential: CredentialsEntity) => {\n\t\t\tconst { name, type, nodesAccess, data: encryptedData } = credential;\n\n\t\t\texpect(typeof name).toBe('string');\n\t\t\texpect(typeof type).toBe('string');\n\t\t\texpect(typeof nodesAccess[0].nodeType).toBe('string');\n\t\t\texpect(encryptedData).toBeUndefined();\n\t\t}),\n\t);\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials should retrieve owned creds for member","suites":[],"updatePoint":{"line":400,"column":61},"line":400,"code":"test('GET /credentials should retrieve owned creds for member', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: member });\n\n\tfor (let i = 0; i < 3; i++) {\n\t\tawait saveCredential(credentialPayload(), { user: member });\n\t}\n\n\tconst response = await authMemberAgent.get('/credentials');\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data.length).toBe(3);\n\n\tawait Promise.all(\n\t\tresponse.body.data.map(async (credential: CredentialsEntity) => {\n\t\t\tconst { name, type, nodesAccess, data: encryptedData } = credential;\n\n\t\t\texpect(typeof name).toBe('string');\n\t\t\texpect(typeof type).toBe('string');\n\t\t\texpect(typeof nodesAccess[0].nodeType).toBe('string');\n\t\t\texpect(encryptedData).toBeUndefined();\n\t\t}),\n\t);\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials should not retrieve non-owned creds for member","suites":[],"updatePoint":{"line":425,"column":69},"line":425,"code":"test('GET /credentials should not retrieve non-owned creds for member', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: member });\n\n\tfor (let i = 0; i < 3; i++) {\n\t\tawait saveCredential(credentialPayload(), { user: ownerShell });\n\t}\n\n\tconst response = await authMemberAgent.get('/credentials');\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data.length).toBe(0); // owner's creds not returned\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should retrieve owned cred for owner","suites":[],"updatePoint":{"line":440,"column":63},"line":440,"code":"test('GET /credentials/:id should retrieve owned cred for owner', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\tconst savedCredential = await saveCredential(credentialPayload(), { user: ownerShell });\n\n\tconst firstResponse = await authOwnerAgent.get(`/credentials/${savedCredential.id}`);\n\n\texpect(firstResponse.statusCode).toBe(200);\n\n\texpect(typeof firstResponse.body.data.name).toBe('string');\n\texpect(typeof firstResponse.body.data.type).toBe('string');\n\texpect(typeof firstResponse.body.data.nodesAccess[0].nodeType).toBe('string');\n\texpect(firstResponse.body.data.data).toBeUndefined();\n\n\tconst secondResponse = await authOwnerAgent\n\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t.query({ includeData: true });\n\n\texpect(secondResponse.statusCode).toBe(200);\n\texpect(typeof secondResponse.body.data.name).toBe('string');\n\texpect(typeof secondResponse.body.data.type).toBe('string');\n\texpect(typeof secondResponse.body.data.nodesAccess[0].nodeType).toBe('string');\n\texpect(secondResponse.body.data.data).toBeDefined();\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should retrieve owned cred for member","suites":[],"updatePoint":{"line":465,"column":64},"line":465,"code":"test('GET /credentials/:id should retrieve owned cred for member', async () => {\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: member });\n\tconst savedCredential = await saveCredential(credentialPayload(), { user: member });\n\n\tconst firstResponse = await authMemberAgent.get(`/credentials/${savedCredential.id}`);\n\n\texpect(firstResponse.statusCode).toBe(200);\n\n\texpect(typeof firstResponse.body.data.name).toBe('string');\n\texpect(typeof firstResponse.body.data.type).toBe('string');\n\texpect(typeof firstResponse.body.data.nodesAccess[0].nodeType).toBe('string');\n\texpect(firstResponse.body.data.data).toBeUndefined();\n\n\tconst secondResponse = await authMemberAgent\n\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t.query({ includeData: true });\n\n\texpect(secondResponse.statusCode).toBe(200);\n\n\texpect(typeof secondResponse.body.data.name).toBe('string');\n\texpect(typeof secondResponse.body.data.type).toBe('string');\n\texpect(typeof secondResponse.body.data.nodesAccess[0].nodeType).toBe('string');\n\texpect(secondResponse.body.data.data).toBeDefined();\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should not retrieve non-owned cred for member","suites":[],"updatePoint":{"line":491,"column":72},"line":491,"code":"test('GET /credentials/:id should not retrieve non-owned cred for member', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: member });\n\tconst savedCredential = await saveCredential(credentialPayload(), { user: ownerShell });\n\n\tconst response = await authMemberAgent.get(`/credentials/${savedCredential.id}`);\n\n\texpect(response.statusCode).toBe(404);\n\texpect(response.body.data).toBeUndefined(); // owner's cred not returned\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should fail with missing encryption key","suites":[],"updatePoint":{"line":503,"column":66},"line":503,"code":"test('GET /credentials/:id should fail with missing encryption key', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\tconst savedCredential = await saveCredential(credentialPayload(), { user: ownerShell });\n\n\tconst mock = jest.spyOn(UserSettings, 'getEncryptionKey');\n\tmock.mockRejectedValue(new Error(RESPONSE_ERROR_MESSAGES.NO_ENCRYPTION_KEY));\n\n\n\tconst response = await authOwnerAgent\n\t\t.get(`/credentials/${savedCredential.id}`)\n\t\t.query({ includeData: true });\n\n\texpect(response.statusCode).toBe(500);\n\n\tmock.mockRestore();\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /credentials/:id should return 404 if cred not found","suites":[],"updatePoint":{"line":521,"column":62},"line":521,"code":"test('GET /credentials/:id should return 404 if cred not found', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\tconst response = await authMemberAgent.get('/credentials/789');\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/credentials.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /me should return sanitized owner shell","suites":["Owner shell"],"updatePoint":{"line":40,"column":50},"line":40,"code":"\ttest('GET /me should return sanitized owner shell', async () => {\n\t\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\t\tconst authOwnerShellAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\t\tconst response = await authOwnerShellAgent.get('/me');\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst {\n\t\t\tid,\n\t\t\temail,\n\t\t\tfirstName,\n\t\t\tlastName,\n\t\t\tpersonalizationAnswers,\n\t\t\tglobalRole,\n\t\t\tpassword,\n\t\t\tresetPasswordToken,\n\t\t\tisPending,\n\t\t} = response.body.data;\n\n\t\texpect(validator.isUUID(id)).toBe(true);\n\t\texpect(email).toBeNull();\n\t\texpect(firstName).toBeNull();\n\t\texpect(lastName).toBeNull();\n\t\texpect(personalizationAnswers).toBeNull();\n\t\texpect(password).toBeUndefined();\n\t\texpect(resetPasswordToken).toBeUndefined();\n\t\texpect(isPending).toBe(true);\n\t\texpect(globalRole.name).toBe('owner');\n\t\texpect(globalRole.scope).toBe('global');\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me should succeed with valid inputs","suites":["Owner shell"],"updatePoint":{"line":72,"column":49},"line":72,"code":"\ttest('PATCH /me should succeed with valid inputs', async () => {\n\t\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\t\tconst authOwnerShellAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\t\tfor (const validPayload of VALID_PATCH_ME_PAYLOADS) {\n\t\t\tconst response = await authOwnerShellAgent.patch('/me').send(validPayload);\n\n\t\t\texpect(response.statusCode).toBe(200);\n\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\temail,\n\t\t\t\tfirstName,\n\t\t\t\tlastName,\n\t\t\t\tpersonalizationAnswers,\n\t\t\t\tglobalRole,\n\t\t\t\tpassword,\n\t\t\t\tresetPasswordToken,\n\t\t\t\tisPending,\n\t\t\t} = response.body.data;\n\n\t\t\texpect(validator.isUUID(id)).toBe(true);\n\t\t\texpect(email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(firstName).toBe(validPayload.firstName);\n\t\t\texpect(lastName).toBe(validPayload.lastName);\n\t\t\texpect(personalizationAnswers).toBeNull();\n\t\t\texpect(password).toBeUndefined();\n\t\t\texpect(resetPasswordToken).toBeUndefined();\n\t\t\texpect(isPending).toBe(false);\n\t\t\texpect(globalRole.name).toBe('owner');\n\t\t\texpect(globalRole.scope).toBe('global');\n\n\t\t\tconst storedOwnerShell = await Db.collections.User.findOneOrFail(id);\n\n\t\t\texpect(storedOwnerShell.email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(storedOwnerShell.firstName).toBe(validPayload.firstName);\n\t\t\texpect(storedOwnerShell.lastName).toBe(validPayload.lastName);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me should fail with invalid inputs","suites":["Owner shell"],"updatePoint":{"line":112,"column":48},"line":112,"code":"\ttest('PATCH /me should fail with invalid inputs', async () => {\n\t\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\t\tconst authOwnerShellAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\t\tfor (const invalidPayload of INVALID_PATCH_ME_PAYLOADS) {\n\t\t\tconst response = await authOwnerShellAgent.patch('/me').send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\n\t\t\tconst storedOwnerShell = await Db.collections.User.findOneOrFail();\n\t\t\texpect(storedOwnerShell.email).toBeNull();\n\t\t\texpect(storedOwnerShell.firstName).toBeNull();\n\t\t\texpect(storedOwnerShell.lastName).toBeNull();\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me/password should fail for shell","suites":["Owner shell"],"updatePoint":{"line":127,"column":47},"line":127,"code":"\ttest('PATCH /me/password should fail for shell', async () => {\n\t\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\t\tconst authOwnerShellAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\t\tconst validPasswordPayload = {\n\t\t\tcurrentPassword: randomValidPassword(),\n\t\t\tnewPassword: randomValidPassword(),\n\t\t};\n\n\t\tconst validPayloads = [validPasswordPayload, ...INVALID_PASSWORD_PAYLOADS];\n\n\t\tawait Promise.all(\n\t\t\tvalidPayloads.map(async (payload) => {\n\t\t\t\tconst response = await authOwnerShellAgent.patch('/me/password').send(payload);\n\t\t\t\texpect([400, 500].includes(response.statusCode)).toBe(true);\n\n\t\t\t\tconst storedMember = await Db.collections.User.findOneOrFail();\n\n\t\t\t\tif (payload.newPassword) {\n\t\t\t\t\texpect(storedMember.password).not.toBe(payload.newPassword);\n\t\t\t\t}\n\n\t\t\t\tif (payload.currentPassword) {\n\t\t\t\t\texpect(storedMember.password).not.toBe(payload.currentPassword);\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\tconst storedOwnerShell = await Db.collections.User.findOneOrFail();\n\t\texpect(storedOwnerShell.password).toBeNull();\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /me/survey should succeed with valid inputs","suites":["Owner shell"],"updatePoint":{"line":159,"column":55},"line":159,"code":"\ttest('POST /me/survey should succeed with valid inputs', async () => {\n\t\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\t\tconst authOwnerShellAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\t\tconst validPayloads = [SURVEY, {}];\n\n\t\tfor (const validPayload of validPayloads) {\n\t\t\tconst response = await authOwnerShellAgent.post('/me/survey').send(validPayload);\n\n\t\t\texpect(response.statusCode).toBe(200);\n\t\t\texpect(response.body).toEqual(SUCCESS_RESPONSE_BODY);\n\n\t\t\tconst storedShellOwner = await Db.collections.User.findOneOrFail({\n\t\t\t\twhere: { email: IsNull() },\n\t\t\t});\n\n\t\t\texpect(storedShellOwner.personalizationAnswers).toEqual(validPayload);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /me should return sanitized member","suites":["Member"],"updatePoint":{"line":194,"column":45},"line":194,"code":"\ttest('GET /me should return sanitized member', async () => {\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: member });\n\n\t\tconst response = await authMemberAgent.get('/me');\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst {\n\t\t\tid,\n\t\t\temail,\n\t\t\tfirstName,\n\t\t\tlastName,\n\t\t\tpersonalizationAnswers,\n\t\t\tglobalRole,\n\t\t\tpassword,\n\t\t\tresetPasswordToken,\n\t\t\tisPending,\n\t\t} = response.body.data;\n\n\t\texpect(validator.isUUID(id)).toBe(true);\n\t\texpect(email).toBe(member.email);\n\t\texpect(firstName).toBe(member.firstName);\n\t\texpect(lastName).toBe(member.lastName);\n\t\texpect(personalizationAnswers).toBeNull();\n\t\texpect(password).toBeUndefined();\n\t\texpect(resetPasswordToken).toBeUndefined();\n\t\texpect(isPending).toBe(false);\n\t\texpect(globalRole.name).toBe('member');\n\t\texpect(globalRole.scope).toBe('global');\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me should succeed with valid inputs","suites":["Member"],"updatePoint":{"line":226,"column":49},"line":226,"code":"\ttest('PATCH /me should succeed with valid inputs', async () => {\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: member });\n\n\t\tfor (const validPayload of VALID_PATCH_ME_PAYLOADS) {\n\t\t\tconst response = await authMemberAgent.patch('/me').send(validPayload);\n\n\t\t\texpect(response.statusCode).toBe(200);\n\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\temail,\n\t\t\t\tfirstName,\n\t\t\t\tlastName,\n\t\t\t\tpersonalizationAnswers,\n\t\t\t\tglobalRole,\n\t\t\t\tpassword,\n\t\t\t\tresetPasswordToken,\n\t\t\t\tisPending,\n\t\t\t} = response.body.data;\n\n\t\t\texpect(validator.isUUID(id)).toBe(true);\n\t\t\texpect(email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(firstName).toBe(validPayload.firstName);\n\t\t\texpect(lastName).toBe(validPayload.lastName);\n\t\t\texpect(personalizationAnswers).toBeNull();\n\t\t\texpect(password).toBeUndefined();\n\t\t\texpect(resetPasswordToken).toBeUndefined();\n\t\t\texpect(isPending).toBe(false);\n\t\t\texpect(globalRole.name).toBe('member');\n\t\t\texpect(globalRole.scope).toBe('global');\n\n\t\t\tconst storedMember = await Db.collections.User.findOneOrFail(id);\n\n\t\t\texpect(storedMember.email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(storedMember.firstName).toBe(validPayload.firstName);\n\t\t\texpect(storedMember.lastName).toBe(validPayload.lastName);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me should fail with invalid inputs","suites":["Member"],"updatePoint":{"line":266,"column":48},"line":266,"code":"\ttest('PATCH /me should fail with invalid inputs', async () => {\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: member });\n\n\t\tfor (const invalidPayload of INVALID_PATCH_ME_PAYLOADS) {\n\t\t\tconst response = await authMemberAgent.patch('/me').send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\n\t\t\tconst storedMember = await Db.collections.User.findOneOrFail();\n\t\t\texpect(storedMember.email).toBe(member.email);\n\t\t\texpect(storedMember.firstName).toBe(member.firstName);\n\t\t\texpect(storedMember.lastName).toBe(member.lastName);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me/password should succeed with valid inputs","suites":["Member"],"updatePoint":{"line":281,"column":58},"line":281,"code":"\ttest('PATCH /me/password should succeed with valid inputs', async () => {\n\t\tconst memberPassword = randomValidPassword();\n\t\tconst member = await testDb.createUser({\n\t\t\tpassword: memberPassword,\n\t\t\tglobalRole: globalMemberRole,\n\t\t});\n\t\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: member });\n\n\t\tconst validPayload = {\n\t\t\tcurrentPassword: memberPassword,\n\t\t\tnewPassword: randomValidPassword(),\n\t\t};\n\n\t\tconst response = await authMemberAgent.patch('/me/password').send(validPayload);\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(response.body).toEqual(SUCCESS_RESPONSE_BODY);\n\n\t\tconst storedMember = await Db.collections.User.findOneOrFail();\n\t\texpect(storedMember.password).not.toBe(member.password);\n\t\texpect(storedMember.password).not.toBe(validPayload.newPassword);\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me/password should fail with invalid inputs","suites":["Member"],"updatePoint":{"line":303,"column":57},"line":303,"code":"\ttest('PATCH /me/password should fail with invalid inputs', async () => {\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: member });\n\n\t\tfor (const payload of INVALID_PASSWORD_PAYLOADS) {\n\t\t\tconst response = await authMemberAgent.patch('/me/password').send(payload);\n\t\t\texpect([400, 500].includes(response.statusCode)).toBe(true);\n\n\t\t\tconst storedMember = await Db.collections.User.findOneOrFail();\n\n\t\t\tif (payload.newPassword) {\n\t\t\t\texpect(storedMember.password).not.toBe(payload.newPassword);\n\t\t\t}\n\t\t\tif (payload.currentPassword) {\n\t\t\t\texpect(storedMember.password).not.toBe(payload.currentPassword);\n\t\t\t}\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /me/survey should succeed with valid inputs","suites":["Member"],"updatePoint":{"line":322,"column":55},"line":322,"code":"\ttest('POST /me/survey should succeed with valid inputs', async () => {\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst authMemberAgent = utils.createAgent(app, { auth: true, user: member });\n\n\t\tconst validPayloads = [SURVEY, {}];\n\n\t\tfor (const validPayload of validPayloads) {\n\t\t\tconst response = await authMemberAgent.post('/me/survey').send(validPayload);\n\t\t\texpect(response.statusCode).toBe(200);\n\t\t\texpect(response.body).toEqual(SUCCESS_RESPONSE_BODY);\n\n\t\t\tconst { personalizationAnswers: storedAnswers } = await Db.collections.User.findOneOrFail();\n\n\t\t\texpect(storedAnswers).toEqual(validPayload);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /me should return sanitized owner","suites":["Owner"],"updatePoint":{"line":349,"column":44},"line":349,"code":"\ttest('GET /me should return sanitized owner', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: owner });\n\n\t\tconst response = await authOwnerAgent.get('/me');\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tconst {\n\t\t\tid,\n\t\t\temail,\n\t\t\tfirstName,\n\t\t\tlastName,\n\t\t\tpersonalizationAnswers,\n\t\t\tglobalRole,\n\t\t\tpassword,\n\t\t\tresetPasswordToken,\n\t\t\tisPending,\n\t\t} = response.body.data;\n\n\t\texpect(validator.isUUID(id)).toBe(true);\n\t\texpect(email).toBe(owner.email);\n\t\texpect(firstName).toBe(owner.firstName);\n\t\texpect(lastName).toBe(owner.lastName);\n\t\texpect(personalizationAnswers).toBeNull();\n\t\texpect(password).toBeUndefined();\n\t\texpect(resetPasswordToken).toBeUndefined();\n\t\texpect(isPending).toBe(false);\n\t\texpect(globalRole.name).toBe('owner');\n\t\texpect(globalRole.scope).toBe('global');\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"PATCH /me should succeed with valid inputs","suites":["Owner"],"updatePoint":{"line":381,"column":49},"line":381,"code":"\ttest('PATCH /me should succeed with valid inputs', async () => {\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: owner });\n\n\t\tfor (const validPayload of VALID_PATCH_ME_PAYLOADS) {\n\t\t\tconst response = await authOwnerAgent.patch('/me').send(validPayload);\n\n\t\t\texpect(response.statusCode).toBe(200);\n\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\temail,\n\t\t\t\tfirstName,\n\t\t\t\tlastName,\n\t\t\t\tpersonalizationAnswers,\n\t\t\t\tglobalRole,\n\t\t\t\tpassword,\n\t\t\t\tresetPasswordToken,\n\t\t\t\tisPending,\n\t\t\t} = response.body.data;\n\n\t\t\texpect(validator.isUUID(id)).toBe(true);\n\t\t\texpect(email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(firstName).toBe(validPayload.firstName);\n\t\t\texpect(lastName).toBe(validPayload.lastName);\n\t\t\texpect(personalizationAnswers).toBeNull();\n\t\t\texpect(password).toBeUndefined();\n\t\t\texpect(resetPasswordToken).toBeUndefined();\n\t\t\texpect(isPending).toBe(false);\n\t\t\texpect(globalRole.name).toBe('owner');\n\t\t\texpect(globalRole.scope).toBe('global');\n\n\t\t\tconst storedOwner = await Db.collections.User.findOneOrFail(id);\n\n\t\t\texpect(storedOwner.email).toBe(validPayload.email.toLowerCase());\n\t\t\texpect(storedOwner.firstName).toBe(validPayload.firstName);\n\t\t\texpect(storedOwner.lastName).toBe(validPayload.lastName);\n\t\t}\n\t});","file":"integration/me.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /owner should create owner and enable isInstanceOwnerSetUp","suites":[],"updatePoint":{"line":44,"column":69},"line":44,"code":"test('POST /owner should create owner and enable isInstanceOwnerSetUp', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\tconst newOwnerData = {\n\t\temail: randomEmail(),\n\t\tfirstName: randomName(),\n\t\tlastName: randomName(),\n\t\tpassword: randomValidPassword(),\n\t};\n\n\tconst response = await authOwnerAgent.post('/owner').send(newOwnerData);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst {\n\t\tid,\n\t\temail,\n\t\tfirstName,\n\t\tlastName,\n\t\tpersonalizationAnswers,\n\t\tglobalRole,\n\t\tpassword,\n\t\tresetPasswordToken,\n\t\tisPending,\n\t} = response.body.data;\n\n\texpect(validator.isUUID(id)).toBe(true);\n\texpect(email).toBe(newOwnerData.email);\n\texpect(firstName).toBe(newOwnerData.firstName);\n\texpect(lastName).toBe(newOwnerData.lastName);\n\texpect(personalizationAnswers).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(isPending).toBe(false);\n\texpect(resetPasswordToken).toBeUndefined();\n\texpect(globalRole.name).toBe('owner');\n\texpect(globalRole.scope).toBe('global');\n\n\tconst storedOwner = await Db.collections.User.findOneOrFail(id);\n\texpect(storedOwner.password).not.toBe(newOwnerData.password);\n\texpect(storedOwner.email).toBe(newOwnerData.email);\n\texpect(storedOwner.firstName).toBe(newOwnerData.firstName);\n\texpect(storedOwner.lastName).toBe(newOwnerData.lastName);\n\n\tconst isInstanceOwnerSetUpConfig = config.getEnv('userManagement.isInstanceOwnerSetUp');\n\texpect(isInstanceOwnerSetUpConfig).toBe(true);\n\n\tconst isInstanceOwnerSetUpSetting = await utils.isInstanceOwnerSetUp();\n\texpect(isInstanceOwnerSetUpSetting).toBe(true);\n});","file":"integration/owner.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /owner should create owner with lowercased email","suites":[],"updatePoint":{"line":95,"column":59},"line":95,"code":"test('POST /owner should create owner with lowercased email', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\tconst newOwnerData = {\n\t\temail: randomEmail().toUpperCase(),\n\t\tfirstName: randomName(),\n\t\tlastName: randomName(),\n\t\tpassword: randomValidPassword(),\n\t};\n\n\tconst response = await authOwnerAgent.post('/owner').send(newOwnerData);\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst { id, email } = response.body.data;\n\n\texpect(id).toBe(ownerShell.id);\n\texpect(email).toBe(newOwnerData.email.toLowerCase());\n\n\tconst storedOwner = await Db.collections.User.findOneOrFail(id);\n\texpect(storedOwner.email).toBe(newOwnerData.email.toLowerCase());\n});","file":"integration/owner.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /owner should fail with invalid inputs","suites":[],"updatePoint":{"line":119,"column":49},"line":119,"code":"test('POST /owner should fail with invalid inputs', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\tawait Promise.all(\n\t\tINVALID_POST_OWNER_PAYLOADS.map(async (invalidPayload) => {\n\t\t\tconst response = await authOwnerAgent.post('/owner').send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\t\t}),\n\t);\n});","file":"integration/owner.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /owner/skip-setup should persist skipping setup to the DB","suites":[],"updatePoint":{"line":131,"column":68},"line":131,"code":"test('POST /owner/skip-setup should persist skipping setup to the DB', async () => {\n\tconst ownerShell = await testDb.createUserShell(globalOwnerRole);\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: ownerShell });\n\n\tconst response = await authOwnerAgent.post('/owner/skip-setup').send();\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst skipConfig = config.getEnv('userManagement.skipInstanceOwnerSetup');\n\texpect(skipConfig).toBe(true);\n\n\tconst { value } = await Db.collections.Settings.findOneOrFail({\n\t\tkey: 'userManagement.skipInstanceOwnerSetup',\n\t});\n\texpect(value).toBe('true');\n});","file":"integration/owner.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /forgot-password should send password reset email","suites":[],"updatePoint":{"line":54,"column":56},"line":53,"code":"test(\n\t'POST /forgot-password should send password reset email',\n\tasync () => {\n\t\tif (!isSmtpAvailable) utils.skipSmtpTest(expect);\n\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\t\tconst authlessAgent = utils.createAgent(app);\n\t\tconst member = await testDb.createUser({\n\t\t\temail: 'test@test.com',\n\t\t\tglobalRole: globalMemberRole,\n\t\t});\n\n\t\tawait utils.configureSmtp();\n\n\t\tawait Promise.all(\n\t\t\t[{ email: owner.email }, { email: member.email.toUpperCase() }].map(async (payload) => {\n\t\t\t\tconst response = await authlessAgent.post('/forgot-password').send(payload);\n\n\t\t\t\texpect(response.statusCode).toBe(200);\n\t\t\t\texpect(response.body).toEqual({});\n\n\t\t\t\tconst user = await Db.collections.User.findOneOrFail({ email: payload.email });\n\t\t\t\texpect(user.resetPasswordToken).toBeDefined();\n\t\t\t\texpect(user.resetPasswordTokenExpiration).toBeGreaterThan(Math.ceil(Date.now() / 1000));\n\t\t\t}),\n\t\t);\n\t},\n\tSMTP_TEST_TIMEOUT,\n);","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /forgot-password should fail if emailing is not set up","suites":[],"updatePoint":{"line":84,"column":65},"line":84,"code":"test('POST /forgot-password should fail if emailing is not set up', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst response = await authlessAgent.post('/forgot-password').send({ email: owner.email });\n\n\texpect(response.statusCode).toBe(500);\n\n\tconst storedOwner = await Db.collections.User.findOneOrFail({ email: owner.email });\n\texpect(storedOwner.resetPasswordToken).toBeNull();\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /forgot-password should fail with invalid inputs","suites":[],"updatePoint":{"line":97,"column":59},"line":97,"code":"test('POST /forgot-password should fail with invalid inputs', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\tconst invalidPayloads = [\n\t\trandomEmail(),\n\t\t[randomEmail()],\n\t\t{},\n\t\t[{ name: randomName() }],\n\t\t[{ email: randomName() }],\n\t];\n\n\tawait Promise.all(\n\t\tinvalidPayloads.map(async (invalidPayload) => {\n\t\t\tconst response = await authlessAgent.post('/forgot-password').send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\n\t\t\tconst storedOwner = await Db.collections.User.findOneOrFail({ email: owner.email });\n\t\t\texpect(storedOwner.resetPasswordToken).toBeNull();\n\t\t}),\n\t);\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /forgot-password should fail if user is not found","suites":[],"updatePoint":{"line":123,"column":60},"line":123,"code":"test('POST /forgot-password should fail if user is not found', async () => {\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\tconst response = await authlessAgent.post('/forgot-password').send({ email: randomEmail() });\n\n\texpect(response.statusCode).toBe(200); // expect 200 to remain vague\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /resolve-password-token should succeed with valid inputs","suites":[],"updatePoint":{"line":133,"column":66},"line":133,"code":"test('GET /resolve-password-token should succeed with valid inputs', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst resetPasswordToken = uuid();\n\tconst resetPasswordTokenExpiration = Math.floor(Date.now() / 1000) + 100;\n\n\tawait Db.collections.User.update(owner.id, {\n\t\tresetPasswordToken,\n\t\tresetPasswordTokenExpiration,\n\t});\n\n\tconst response = await authlessAgent\n\t\t.get('/resolve-password-token')\n\t\t.query({ userId: owner.id, token: resetPasswordToken });\n\n\texpect(response.statusCode).toBe(200);\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /resolve-password-token should fail with invalid inputs","suites":[],"updatePoint":{"line":153,"column":65},"line":153,"code":"test('GET /resolve-password-token should fail with invalid inputs', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\tconst first = await authlessAgent.get('/resolve-password-token').query({ token: uuid() });\n\n\tconst second = await authlessAgent.get('/resolve-password-token').query({ userId: owner.id });\n\n\tfor (const response of [first, second]) {\n\t\texpect(response.statusCode).toBe(400);\n\t}\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /resolve-password-token should fail if user is not found","suites":[],"updatePoint":{"line":169,"column":66},"line":169,"code":"test('GET /resolve-password-token should fail if user is not found', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\tconst response = await authlessAgent\n\t\t.get('/resolve-password-token')\n\t\t.query({ userId: owner.id, token: uuid() });\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /resolve-password-token should fail if token is expired","suites":[],"updatePoint":{"line":183,"column":65},"line":183,"code":"test('GET /resolve-password-token should fail if token is expired', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst resetPasswordToken = uuid();\n\tconst resetPasswordTokenExpiration = Math.floor(Date.now() / 1000) - 1;\n\n\tawait Db.collections.User.update(owner.id, {\n\t\tresetPasswordToken,\n\t\tresetPasswordTokenExpiration,\n\t});\n\n\tconfig.set('userManagement.emails.mode', 'smtp');\n\n\tconst response = await authlessAgent\n\t\t.get('/resolve-password-token')\n\t\t.query({ userId: owner.id, token: resetPasswordToken });\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /change-password should succeed with valid inputs","suites":[],"updatePoint":{"line":205,"column":60},"line":205,"code":"test('POST /change-password should succeed with valid inputs', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst resetPasswordToken = uuid();\n\tconst resetPasswordTokenExpiration = Math.floor(Date.now() / 1000) + 100;\n\n\tawait Db.collections.User.update(owner.id, {\n\t\tresetPasswordToken,\n\t\tresetPasswordTokenExpiration,\n\t});\n\n\tconst passwordToStore = randomValidPassword();\n\n\tconst response = await authlessAgent.post('/change-password').send({\n\t\ttoken: resetPasswordToken,\n\t\tuserId: owner.id,\n\t\tpassword: passwordToStore,\n\t});\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeDefined();\n\n\tconst { password: storedPassword } = await Db.collections.User.findOneOrFail(owner.id);\n\n\tconst comparisonResult = await compare(passwordToStore, storedPassword);\n\texpect(comparisonResult).toBe(true);\n\texpect(storedPassword).not.toBe(passwordToStore);\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /change-password should fail with invalid inputs","suites":[],"updatePoint":{"line":238,"column":59},"line":238,"code":"test('POST /change-password should fail with invalid inputs', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst resetPasswordToken = uuid();\n\tconst resetPasswordTokenExpiration = Math.floor(Date.now() / 1000) + 100;\n\n\tawait Db.collections.User.update(owner.id, {\n\t\tresetPasswordToken,\n\t\tresetPasswordTokenExpiration,\n\t});\n\n\tconst invalidPayloads = [\n\t\t{ token: uuid() },\n\t\t{ id: owner.id },\n\t\t{ password: randomValidPassword() },\n\t\t{ token: uuid(), id: owner.id },\n\t\t{ token: uuid(), password: randomValidPassword() },\n\t\t{ id: owner.id, password: randomValidPassword() },\n\t\t{\n\t\t\tid: owner.id,\n\t\t\tpassword: randomInvalidPassword(),\n\t\t\ttoken: resetPasswordToken,\n\t\t},\n\t\t{\n\t\t\tid: owner.id,\n\t\t\tpassword: randomValidPassword(),\n\t\t\ttoken: uuid(),\n\t\t},\n\t];\n\n\tawait Promise.all(\n\t\tinvalidPayloads.map(async (invalidPayload) => {\n\t\t\tconst response = await authlessAgent.post('/change-password').query(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\n\t\t\tconst { password: storedPassword } = await Db.collections.User.findOneOrFail();\n\t\t\texpect(owner.password).toBe(storedPassword);\n\t\t}),\n\t);\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /change-password should fail when token has expired","suites":[],"updatePoint":{"line":281,"column":62},"line":281,"code":"test('POST /change-password should fail when token has expired', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst resetPasswordToken = uuid();\n\tconst resetPasswordTokenExpiration = Math.floor(Date.now() / 1000) - 1;\n\n\tawait Db.collections.User.update(owner.id, {\n\t\tresetPasswordToken,\n\t\tresetPasswordTokenExpiration,\n\t});\n\n\tconst passwordToStore = randomValidPassword();\n\n\tconst response = await authlessAgent.post('/change-password').send({\n\t\ttoken: resetPasswordToken,\n\t\tuserId: owner.id,\n\t\tpassword: passwordToStore,\n\t});\n\n\texpect(response.statusCode).toBe(404);\n});","file":"integration/passwordReset.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /users should return all users","suites":[],"updatePoint":{"line":72,"column":40},"line":72,"code":"test('GET /users should return all users', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: owner });\n\n\tawait testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst response = await authOwnerAgent.get('/users');\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body.data.length).toBe(2);\n\n\tawait Promise.all(\n\t\tresponse.body.data.map(async (user: User) => {\n\t\t\tconst {\n\t\t\t\tid,\n\t\t\t\temail,\n\t\t\t\tfirstName,\n\t\t\t\tlastName,\n\t\t\t\tpersonalizationAnswers,\n\t\t\t\tglobalRole,\n\t\t\t\tpassword,\n\t\t\t\tresetPasswordToken,\n\t\t\t\tisPending,\n\t\t\t} = user;\n\n\t\t\texpect(validator.isUUID(id)).toBe(true);\n\t\t\texpect(email).toBeDefined();\n\t\t\texpect(firstName).toBeDefined();\n\t\t\texpect(lastName).toBeDefined();\n\t\t\texpect(personalizationAnswers).toBeUndefined();\n\t\t\texpect(password).toBeUndefined();\n\t\t\texpect(resetPasswordToken).toBeUndefined();\n\t\t\texpect(isPending).toBe(false);\n\t\t\texpect(globalRole).toBeDefined();\n\t\t}),\n\t);\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /users/:id should delete the user","suites":[],"updatePoint":{"line":110,"column":46},"line":110,"code":"test('DELETE /users/:id should delete the user', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: owner });\n\n\tconst userToDelete = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst newWorkflow = new WorkflowEntity();\n\n\tObject.assign(newWorkflow, {\n\t\tname: randomName(),\n\t\tactive: false,\n\t\tconnections: {},\n\t\tnodes: [],\n\t});\n\n\tconst savedWorkflow = await Db.collections.Workflow.save(newWorkflow);\n\n\tawait Db.collections.SharedWorkflow.save({\n\t\trole: workflowOwnerRole,\n\t\tuser: userToDelete,\n\t\tworkflow: savedWorkflow,\n\t});\n\n\tconst newCredential = new CredentialsEntity();\n\n\tObject.assign(newCredential, {\n\t\tname: randomName(),\n\t\tdata: '',\n\t\ttype: '',\n\t\tnodesAccess: [],\n\t});\n\n\tconst savedCredential = await Db.collections.Credentials.save(newCredential);\n\n\tawait Db.collections.SharedCredentials.save({\n\t\trole: credentialOwnerRole,\n\t\tuser: userToDelete,\n\t\tcredentials: savedCredential,\n\t});\n\n\tconst response = await authOwnerAgent.delete(`/users/${userToDelete.id}`);\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body).toEqual(SUCCESS_RESPONSE_BODY);\n\n\tconst user = await Db.collections.User.findOne(userToDelete.id);\n\texpect(user).toBeUndefined(); // deleted\n\n\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOne({\n\t\trelations: ['user'],\n\t\twhere: { user: userToDelete },\n\t});\n\texpect(sharedWorkflow).toBeUndefined(); // deleted\n\n\tconst sharedCredential = await Db.collections.SharedCredentials.findOne({\n\t\trelations: ['user'],\n\t\twhere: { user: userToDelete },\n\t});\n\texpect(sharedCredential).toBeUndefined(); // deleted\n\n\tconst workflow = await Db.collections.Workflow.findOne(savedWorkflow.id);\n\texpect(workflow).toBeUndefined(); // deleted\n\n\t// TODO: Include active workflow and check whether webhook has been removed\n\n\tconst credential = await Db.collections.Credentials.findOne(savedCredential.id);\n\texpect(credential).toBeUndefined(); // deleted\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /users/:id should fail to delete self","suites":[],"updatePoint":{"line":179,"column":50},"line":179,"code":"test('DELETE /users/:id should fail to delete self', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: owner });\n\n\tconst response = await authOwnerAgent.delete(`/users/${owner.id}`);\n\n\texpect(response.statusCode).toBe(400);\n\n\tconst user = await Db.collections.User.findOne(owner.id);\n\texpect(user).toBeDefined();\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /users/:id should fail if user to delete is transferee","suites":[],"updatePoint":{"line":191,"column":67},"line":191,"code":"test('DELETE /users/:id should fail if user to delete is transferee', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: owner });\n\n\tconst { id: idToDelete } = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst response = await authOwnerAgent.delete(`/users/${idToDelete}`).query({\n\t\ttransferId: idToDelete,\n\t});\n\n\texpect(response.statusCode).toBe(400);\n\n\tconst user = await Db.collections.User.findOne(idToDelete);\n\texpect(user).toBeDefined();\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"DELETE /users/:id with transferId should perform transfer","suites":[],"updatePoint":{"line":207,"column":63},"line":207,"code":"test('DELETE /users/:id with transferId should perform transfer', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: owner });\n\n\tconst userToDelete = await Db.collections.User.save({\n\t\tid: uuid(),\n\t\temail: randomEmail(),\n\t\tpassword: randomValidPassword(),\n\t\tfirstName: randomName(),\n\t\tlastName: randomName(),\n\t\tcreatedAt: new Date(),\n\t\tupdatedAt: new Date(),\n\t\tglobalRole: workflowOwnerRole,\n\t});\n\n\tconst newWorkflow = new WorkflowEntity();\n\n\tObject.assign(newWorkflow, {\n\t\tname: randomName(),\n\t\tactive: false,\n\t\tconnections: {},\n\t\tnodes: [],\n\t});\n\n\tconst savedWorkflow = await Db.collections.Workflow.save(newWorkflow);\n\n\tawait Db.collections.SharedWorkflow.save({\n\t\trole: workflowOwnerRole,\n\t\tuser: userToDelete,\n\t\tworkflow: savedWorkflow,\n\t});\n\n\tconst newCredential = new CredentialsEntity();\n\n\tObject.assign(newCredential, {\n\t\tname: randomName(),\n\t\tdata: '',\n\t\ttype: '',\n\t\tnodesAccess: [],\n\t});\n\n\tconst savedCredential = await Db.collections.Credentials.save(newCredential);\n\n\tawait Db.collections.SharedCredentials.save({\n\t\trole: credentialOwnerRole,\n\t\tuser: userToDelete,\n\t\tcredentials: savedCredential,\n\t});\n\n\tconst response = await authOwnerAgent.delete(`/users/${userToDelete.id}`).query({\n\t\ttransferId: owner.id,\n\t});\n\n\texpect(response.statusCode).toBe(200);\n\n\tconst sharedWorkflow = await Db.collections.SharedWorkflow.findOneOrFail({\n\t\trelations: ['user'],\n\t\twhere: { user: owner },\n\t});\n\n\tconst sharedCredential = await Db.collections.SharedCredentials.findOneOrFail({\n\t\trelations: ['user'],\n\t\twhere: { user: owner },\n\t});\n\n\tconst deletedUser = await Db.collections.User.findOne(userToDelete);\n\n\texpect(sharedWorkflow.user.id).toBe(owner.id);\n\texpect(sharedCredential.user.id).toBe(owner.id);\n\texpect(deletedUser).toBeUndefined();\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /resolve-signup-token should validate invite token","suites":[],"updatePoint":{"line":279,"column":60},"line":279,"code":"test('GET /resolve-signup-token should validate invite token', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: owner });\n\n\tconst memberShell = await testDb.createUserShell(globalMemberRole);\n\n\tconst response = await authOwnerAgent\n\t\t.get('/resolve-signup-token')\n\t\t.query({ inviterId: owner.id })\n\t\t.query({ inviteeId: memberShell.id });\n\n\texpect(response.statusCode).toBe(200);\n\texpect(response.body).toEqual({\n\t\tdata: {\n\t\t\tinviter: {\n\t\t\t\tfirstName: owner.firstName,\n\t\t\t\tlastName: owner.lastName,\n\t\t\t},\n\t\t},\n\t});\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"GET /resolve-signup-token should fail with invalid inputs","suites":[],"updatePoint":{"line":301,"column":63},"line":301,"code":"test('GET /resolve-signup-token should fail with invalid inputs', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: owner });\n\n\tconst { id: inviteeId } = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst first = await authOwnerAgent.get('/resolve-signup-token').query({ inviterId: owner.id });\n\n\tconst second = await authOwnerAgent.get('/resolve-signup-token').query({ inviteeId });\n\n\tconst third = await authOwnerAgent.get('/resolve-signup-token').query({\n\t\tinviterId: '5531199e-b7ae-425b-a326-a95ef8cca59d',\n\t\tinviteeId: 'cb133beb-7729-4c34-8cd1-a06be8834d9d',\n\t});\n\n\t// user is already set up, so call should error\n\tconst fourth = await authOwnerAgent\n\t\t.get('/resolve-signup-token')\n\t\t.query({ inviterId: owner.id })\n\t\t.query({ inviteeId });\n\n\t// cause inconsistent DB state\n\tawait Db.collections.User.update(owner.id, { email: '' });\n\tconst fifth = await authOwnerAgent\n\t\t.get('/resolve-signup-token')\n\t\t.query({ inviterId: owner.id })\n\t\t.query({ inviteeId });\n\n\tfor (const response of [first, second, third, fourth, fifth]) {\n\t\texpect(response.statusCode).toBe(400);\n\t}\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /users/:id should fill out a user shell","suites":[],"updatePoint":{"line":334,"column":50},"line":334,"code":"test('POST /users/:id should fill out a user shell', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst memberShell = await testDb.createUserShell(globalMemberRole);\n\n\tconst memberData = {\n\t\tinviterId: owner.id,\n\t\tfirstName: randomName(),\n\t\tlastName: randomName(),\n\t\tpassword: randomValidPassword(),\n\t};\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst response = await authlessAgent.post(`/users/${memberShell.id}`).send(memberData);\n\n\tconst {\n\t\tid,\n\t\temail,\n\t\tfirstName,\n\t\tlastName,\n\t\tpersonalizationAnswers,\n\t\tpassword,\n\t\tresetPasswordToken,\n\t\tglobalRole,\n\t\tisPending,\n\t} = response.body.data;\n\n\texpect(validator.isUUID(id)).toBe(true);\n\texpect(email).toBeDefined();\n\texpect(firstName).toBe(memberData.firstName);\n\texpect(lastName).toBe(memberData.lastName);\n\texpect(personalizationAnswers).toBeNull();\n\texpect(password).toBeUndefined();\n\texpect(resetPasswordToken).toBeUndefined();\n\texpect(isPending).toBe(false);\n\texpect(globalRole).toBeDefined();\n\n\tconst authToken = utils.getAuthToken(response);\n\texpect(authToken).toBeDefined();\n\n\tconst member = await Db.collections.User.findOneOrFail(memberShell.id);\n\texpect(member.firstName).toBe(memberData.firstName);\n\texpect(member.lastName).toBe(memberData.lastName);\n\texpect(member.password).not.toBe(memberData.password);\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /users/:id should fail with invalid inputs","suites":[],"updatePoint":{"line":381,"column":53},"line":381,"code":"test('POST /users/:id should fail with invalid inputs', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst memberShellEmail = randomEmail();\n\n\tconst memberShell = await Db.collections.User.save({\n\t\temail: memberShellEmail,\n\t\tglobalRole: globalMemberRole,\n\t});\n\n\tconst invalidPayloads = [\n\t\t{\n\t\t\tfirstName: randomName(),\n\t\t\tlastName: randomName(),\n\t\t\tpassword: randomValidPassword(),\n\t\t},\n\t\t{\n\t\t\tinviterId: owner.id,\n\t\t\tfirstName: randomName(),\n\t\t\tpassword: randomValidPassword(),\n\t\t},\n\t\t{\n\t\t\tinviterId: owner.id,\n\t\t\tfirstName: randomName(),\n\t\t\tpassword: randomValidPassword(),\n\t\t},\n\t\t{\n\t\t\tinviterId: owner.id,\n\t\t\tfirstName: randomName(),\n\t\t\tlastName: randomName(),\n\t\t},\n\t\t{\n\t\t\tinviterId: owner.id,\n\t\t\tfirstName: randomName(),\n\t\t\tlastName: randomName(),\n\t\t\tpassword: randomInvalidPassword(),\n\t\t},\n\t];\n\n\tawait Promise.all(\n\t\tinvalidPayloads.map(async (invalidPayload) => {\n\t\t\tconst response = await authlessAgent.post(`/users/${memberShell.id}`).send(invalidPayload);\n\t\t\texpect(response.statusCode).toBe(400);\n\n\t\t\tconst storedUser = await Db.collections.User.findOneOrFail({\n\t\t\t\twhere: { email: memberShellEmail },\n\t\t\t});\n\t\t\texpect(storedUser.firstName).toBeNull();\n\t\t\texpect(storedUser.lastName).toBeNull();\n\t\t\texpect(storedUser.password).toBeNull();\n\t\t}),\n\t);\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /users/:id should fail with already accepted invite","suites":[],"updatePoint":{"line":437,"column":62},"line":437,"code":"test('POST /users/:id should fail with already accepted invite', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\n\tconst newMemberData = {\n\t\tinviterId: owner.id,\n\t\tfirstName: randomName(),\n\t\tlastName: randomName(),\n\t\tpassword: randomValidPassword(),\n\t};\n\n\tconst authlessAgent = utils.createAgent(app);\n\n\tconst response = await authlessAgent.post(`/users/${member.id}`).send(newMemberData);\n\n\texpect(response.statusCode).toBe(400);\n\n\tconst storedMember = await Db.collections.User.findOneOrFail({\n\t\twhere: { email: member.email },\n\t});\n\texpect(storedMember.firstName).not.toBe(newMemberData.firstName);\n\texpect(storedMember.lastName).not.toBe(newMemberData.lastName);\n\n\tconst comparisonResult = await compareHash(member.password, storedMember.password);\n\texpect(comparisonResult).toBe(false);\n\texpect(storedMember.password).not.toBe(newMemberData.password);\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /users should fail if emailing is not set up","suites":[],"updatePoint":{"line":465,"column":55},"line":465,"code":"test('POST /users should fail if emailing is not set up', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: owner });\n\n\tconst response = await authOwnerAgent.post('/users').send([{ email: randomEmail() }]);\n\n\texpect(response.statusCode).toBe(500);\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /users should fail if user management is disabled","suites":[],"updatePoint":{"line":474,"column":60},"line":474,"code":"test('POST /users should fail if user management is disabled', async () => {\n\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: owner });\n\n\tconfig.set('userManagement.disabled', true);\n\n\tconst response = await authOwnerAgent.post('/users').send([{ email: randomEmail() }]);\n\n\texpect(response.statusCode).toBe(500);\n});","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /users should email invites and create user shells but ignore existing","suites":[],"updatePoint":{"line":486,"column":77},"line":485,"code":"test(\n\t'POST /users should email invites and create user shells but ignore existing',\n\tasync () => {\n\t\tif (!isSmtpAvailable) utils.skipSmtpTest(expect);\n\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst member = await testDb.createUser({ globalRole: globalMemberRole });\n\t\tconst memberShell = await testDb.createUserShell(globalMemberRole);\n\t\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: owner });\n\n\t\tawait utils.configureSmtp();\n\n\t\tconst testEmails = [\n\t\t\trandomEmail(),\n\t\t\trandomEmail().toUpperCase(),\n\t\t\tmemberShell.email,\n\t\t\tmember.email,\n\t\t];\n\n\t\tconst payload = testEmails.map((e) => ({ email: e }));\n\n\t\tconst response = await authOwnerAgent.post('/users').send(payload);\n\n\t\texpect(response.statusCode).toBe(200);\n\n\t\tfor (const {\n\t\t\tuser: { id, email: receivedEmail },\n\t\t\terror,\n\t\t} of response.body.data) {\n\t\t\texpect(validator.isUUID(id)).toBe(true);\n\t\t\texpect(id).not.toBe(member.id);\n\n\t\t\tconst lowerCasedEmail = receivedEmail.toLowerCase();\n\t\t\texpect(receivedEmail).toBe(lowerCasedEmail);\n\t\t\texpect(payload.some(({ email }) => email.toLowerCase() === lowerCasedEmail)).toBe(true);\n\n\t\t\tif (error) {\n\t\t\t\texpect(error).toBe('Email could not be sent');\n\t\t\t}\n\n\t\t\tconst storedUser = await Db.collections.User.findOneOrFail(id);\n\t\t\tconst { firstName, lastName, personalizationAnswers, password, resetPasswordToken } =\n\t\t\t\tstoredUser;\n\n\t\t\texpect(firstName).toBeNull();\n\t\t\texpect(lastName).toBeNull();\n\t\t\texpect(personalizationAnswers).toBeNull();\n\t\t\texpect(password).toBeNull();\n\t\t\texpect(resetPasswordToken).toBeNull();\n\t\t}\n\t},\n\tSMTP_TEST_TIMEOUT,\n);","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /users should fail with invalid inputs","suites":[],"updatePoint":{"line":540,"column":45},"line":539,"code":"test(\n\t'POST /users should fail with invalid inputs',\n\tasync () => {\n\t\tif (!isSmtpAvailable) utils.skipSmtpTest(expect);\n\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: owner });\n\n\t\tawait utils.configureSmtp();\n\n\t\tconst invalidPayloads = [\n\t\t\trandomEmail(),\n\t\t\t[randomEmail()],\n\t\t\t{},\n\t\t\t[{ name: randomName() }],\n\t\t\t[{ email: randomName() }],\n\t\t];\n\n\t\tawait Promise.all(\n\t\t\tinvalidPayloads.map(async (invalidPayload) => {\n\t\t\t\tconst response = await authOwnerAgent.post('/users').send(invalidPayload);\n\t\t\t\texpect(response.statusCode).toBe(400);\n\n\t\t\t\tconst users = await Db.collections.User.find();\n\t\t\t\texpect(users.length).toBe(1); // DB unaffected\n\t\t\t}),\n\t\t);\n\t},\n\tSMTP_TEST_TIMEOUT,\n);","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"POST /users should ignore an empty payload","suites":[],"updatePoint":{"line":571,"column":44},"line":570,"code":"test(\n\t'POST /users should ignore an empty payload',\n\tasync () => {\n\t\tif (!isSmtpAvailable) utils.skipSmtpTest(expect);\n\n\t\tconst owner = await testDb.createUser({ globalRole: globalOwnerRole });\n\t\tconst authOwnerAgent = utils.createAgent(app, { auth: true, user: owner });\n\n\t\tawait utils.configureSmtp();\n\n\t\tconst response = await authOwnerAgent.post('/users').send([]);\n\n\t\tconst { data } = response.body;\n\n\t\texpect(response.statusCode).toBe(200);\n\t\texpect(Array.isArray(data)).toBe(true);\n\t\texpect(data.length).toBe(0);\n\n\t\tconst users = await Db.collections.User.find();\n\t\texpect(users.length).toBe(1);\n\t},\n\tSMTP_TEST_TIMEOUT,\n);","file":"integration/users.api.test.ts","skipped":false,"dir":"packages/cli/test"},{"name":"should be able to set and read key data without initial data set","suites":["Credentials","without nodeType set"],"updatePoint":{"line":5,"column":72},"line":5,"code":"\t\ttest('should be able to set and read key data without initial data set', () => {\n\t\t\tconst credentials = new Credentials({ id: null, name: 'testName' }, 'testType', []);\n\n\t\t\tconst key = 'key1';\n\t\t\tconst password = 'password';\n\t\t\t// const nodeType = 'base.noOp';\n\t\t\tconst newData = 1234;\n\n\t\t\tcredentials.setDataKey(key, newData, password);\n\n\t\t\texpect(credentials.getDataKey(key, password)).toEqual(newData);\n\t\t});","file":"Credentials.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to set and read key data with initial data set","suites":["Credentials","without nodeType set"],"updatePoint":{"line":18,"column":69},"line":18,"code":"\t\ttest('should be able to set and read key data with initial data set', () => {\n\t\t\tconst key = 'key2';\n\t\t\tconst password = 'password';\n\n\t\t\t// Saved under \"key1\"\n\t\t\tconst initialData = 4321;\n\t\t\tconst initialDataEncoded = 'U2FsdGVkX1+0baznXt+Ag/ub8A2kHLyoLxn/rR9h4XQ=';\n\n\t\t\tconst credentials = new Credentials(\n\t\t\t\t{ id: null, name: 'testName' },\n\t\t\t\t'testType',\n\t\t\t\t[],\n\t\t\t\tinitialDataEncoded,\n\t\t\t);\n\n\t\t\tconst newData = 1234;\n\n\t\t\t// Set and read new data\n\t\t\tcredentials.setDataKey(key, newData, password);\n\t\t\texpect(credentials.getDataKey(key, password)).toEqual(newData);\n\n\t\t\t// Read the data which got provided encrypted on init\n\t\t\texpect(credentials.getDataKey('key1', password)).toEqual(initialData);\n\t\t});","file":"Credentials.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"should be able to set and read key data without initial data set","suites":["Credentials","with nodeType set"],"updatePoint":{"line":45,"column":72},"line":45,"code":"\t\ttest('should be able to set and read key data without initial data set', () => {\n\t\t\tconst nodeAccess = [\n\t\t\t\t{\n\t\t\t\t\tnodeType: 'base.noOp',\n\t\t\t\t\tuser: 'userName',\n\t\t\t\t\tdate: new Date(),\n\t\t\t\t},\n\t\t\t];\n\n\t\t\tconst credentials = new Credentials({ id: null, name: 'testName' }, 'testType', nodeAccess);\n\n\t\t\tconst key = 'key1';\n\t\t\tconst password = 'password';\n\t\t\tconst nodeType = 'base.noOp';\n\t\t\tconst newData = 1234;\n\n\t\t\tcredentials.setDataKey(key, newData, password);\n\n\t\t\t// Should be able to read with nodeType which has access\n\t\t\texpect(credentials.getDataKey(key, password, nodeType)).toEqual(newData);\n\n\t\t\t// Should not be able to read with nodeType which does NOT have access\n\t\t\t// expect(credentials.getDataKey(key, password, 'base.otherNode')).toThrowError(Error);\n\t\t\ttry {\n\t\t\t\tcredentials.getDataKey(key, password, 'base.otherNode');\n\t\t\t\texpect(true).toBe(false);\n\t\t\t} catch (e) {\n\t\t\t\texpect(e.message).toBe(\n\t\t\t\t\t'The node of type \"base.otherNode\" does not have access to credentials \"testName\" of type \"testType\".',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Get the data which will be saved in database\n\t\t\tconst dbData = credentials.getDataToSave();\n\t\t\texpect(dbData.name).toEqual('testName');\n\t\t\texpect(dbData.type).toEqual('testType');\n\t\t\texpect(dbData.nodesAccess).toEqual(nodeAccess);\n\t\t\t// Compare only the first 6 characters as the rest seems to change with each execution\n\t\t\texpect(dbData.data!.slice(0, 6)).toEqual(\n\t\t\t\t'U2FsdGVkX1+wpQWkj+YTzaPSNTFATjnlmFKIsUTZdhk='.slice(0, 6),\n\t\t\t);\n\t\t});","file":"Credentials.test.ts","skipped":false,"dir":"packages/core/test"},{"name":"runs query to update db","suites":["pgUpdate"],"updatePoint":{"line":5,"column":28},"line":5,"code":"\tit('runs query to update db', async () => {\n\t\tconst updateItem = {id: 1234, name: 'test'};\n\t\tconst nodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tupdateKey: 'id',\n\t\t\tcolumns: 'id,name',\n\t\t\tadditionalFields: {},\n\t\t\treturnFields: '*',\n\t\t};\n\t\tconst getNodeParam = (key) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = {any};\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: updateItem\n\t\t\t}\n\t\t];\n\n\t\tawait PostgresFun.pgUpdate(getNodeParam, pgp, db, items)\n\n\t\texpect(db.any).toHaveBeenCalledWith(`update \\\"myschema\\\".\\\"mytable\\\" as t set \\\"id\\\"=v.\\\"id\\\",\\\"name\\\"=v.\\\"name\\\" from (values(1234,'test')) as v(\\\"id\\\",\\\"name\\\") WHERE v.\\\"id\\\" = t.\\\"id\\\" RETURNING *`);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.js","skipped":false,"dir":"packages/nodes-base/test"},{"name":"runs query to update db if updateKey is not in columns","suites":["pgUpdate"],"updatePoint":{"line":31,"column":59},"line":31,"code":"\tit('runs query to update db if updateKey is not in columns', async () => {\n\t\tconst updateItem = {id: 1234, name: 'test'};\n\t\tconst nodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tupdateKey: 'id',\n\t\t\tcolumns: 'name',\n\t\t\tadditionalFields: {},\n\t\t\treturnFields: '*',\n\t\t};\n\t\tconst getNodeParam = (key) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = {any};\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: updateItem\n\t\t\t}\n\t\t];\n\n\t\tconst results = await PostgresFun.pgUpdate(getNodeParam, pgp, db, items)\n\n\t\texpect(db.any).toHaveBeenCalledWith(`update \\\"myschema\\\".\\\"mytable\\\" as t set \\\"id\\\"=v.\\\"id\\\",\\\"name\\\"=v.\\\"name\\\" from (values(1234,'test')) as v(\\\"id\\\",\\\"name\\\") WHERE v.\\\"id\\\" = t.\\\"id\\\" RETURNING *`);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.js","skipped":false,"dir":"packages/nodes-base/test"},{"name":"runs query to update db with cast as updateKey","suites":["pgUpdate"],"updatePoint":{"line":57,"column":51},"line":57,"code":"\tit('runs query to update db with cast as updateKey', async () => {\n\t\tconst updateItem = {id: '1234', name: 'test'};\n\t\tconst nodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tupdateKey: 'id:uuid',\n\t\t\tcolumns: 'name',\n\t\t\tadditionalFields: {},\n\t\t\treturnFields: '*',\n\t\t};\n\t\tconst getNodeParam = (key) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = {any};\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: updateItem\n\t\t\t}\n\t\t];\n\n\t\tawait PostgresFun.pgUpdate(getNodeParam, pgp, db, items)\n\n\t\texpect(db.any).toHaveBeenCalledWith(`update \\\"myschema\\\".\\\"mytable\\\" as t set \\\"id\\\"=v.\\\"id\\\",\\\"name\\\"=v.\\\"name\\\" from (values('1234'::uuid,'test')) as v(\\\"id\\\",\\\"name\\\") WHERE v.\\\"id\\\" = t.\\\"id\\\" RETURNING *`);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.js","skipped":false,"dir":"packages/nodes-base/test"},{"name":"runs query to update db with cast in target columns","suites":["pgUpdate"],"updatePoint":{"line":83,"column":56},"line":83,"code":"\tit('runs query to update db with cast in target columns', async () => {\n\t\tconst updateItem = {id: '1234', name: 'test'};\n\t\tconst nodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tupdateKey: 'id',\n\t\t\tcolumns: 'id:uuid,name',\n\t\t\tadditionalFields: {},\n\t\t\treturnFields: '*',\n\t\t};\n\t\tconst getNodeParam = (key) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = {any};\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: updateItem\n\t\t\t}\n\t\t];\n\n\t\tawait PostgresFun.pgUpdate(getNodeParam, pgp, db, items)\n\n\t\texpect(db.any).toHaveBeenCalledWith(`update \\\"myschema\\\".\\\"mytable\\\" as t set \\\"id\\\"=v.\\\"id\\\",\\\"name\\\"=v.\\\"name\\\" from (values('1234'::uuid,'test')) as v(\\\"id\\\",\\\"name\\\") WHERE v.\\\"id\\\" = t.\\\"id\\\" RETURNING *`);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.js","skipped":false,"dir":"packages/nodes-base/test"},{"name":"runs query to insert","suites":["pgInsert"],"updatePoint":{"line":113,"column":25},"line":113,"code":"\tit('runs query to insert', async () => {\n\t\tconst insertItem = {id: 1234, name: 'test', age: 34};\n\t\tconst nodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tcolumns: 'id,name,age',\n\t\t\treturnFields: '*',\n\t\t\tadditionalFields: {},\n\t\t};\n\t\tconst getNodeParam = (key) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = {any};\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: insertItem,\n\t\t\t},\n\t\t];\n\n\t\tawait PostgresFun.pgInsert(getNodeParam, pgp, db, items);\n\n\t\texpect(db.any).toHaveBeenCalledWith(`insert into \\\"myschema\\\".\\\"mytable\\\"(\\\"id\\\",\\\"name\\\",\\\"age\\\") values(1234,'test',34) RETURNING *`);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.js","skipped":false,"dir":"packages/nodes-base/test"},{"name":"runs query to insert with type casting","suites":["pgInsert"],"updatePoint":{"line":138,"column":43},"line":138,"code":"\tit('runs query to insert with type casting', async () => {\n\t\tconst insertItem = {id: 1234, name: 'test', age: 34};\n\t\tconst nodeParams = {\n\t\t\ttable: 'mytable',\n\t\t\tschema: 'myschema',\n\t\t\tcolumns: 'id:int,name:text,age',\n\t\t\treturnFields: '*',\n\t\t\tadditionalFields: {},\n\t\t};\n\t\tconst getNodeParam = (key) => nodeParams[key];\n\t\tconst pgp = pgPromise();\n\t\tconst any = jest.fn();\n\t\tconst db = {any};\n\n\t\tconst items = [\n\t\t\t{\n\t\t\t\tjson: insertItem,\n\t\t\t},\n\t\t];\n\n\t\tawait PostgresFun.pgInsert(getNodeParam, pgp, db, items);\n\n\t\texpect(db.any).toHaveBeenCalledWith(`insert into \\\"myschema\\\".\\\"mytable\\\"(\\\"id\\\",\\\"name\\\",\\\"age\\\") values(1234::int,'test'::text,34) RETURNING *`);\n\t});","file":"nodes/Postgres/Postgres.node.functions.test.js","skipped":false,"dir":"packages/nodes-base/test"},{"name":"it should adjust multiple metadata values","suites":["adjustMetadata"],"updatePoint":{"line":4,"column":46},"line":4,"code":"\tit('it should adjust multiple metadata values', async () => {\n\t\tconst additionalFieldsValues = {\n\t\t\tmetadata: {\n\t\t\t\tmetadataProperties: [\n\t\t\t\t\t{\n\t\t\t\t\t\tkey: \"keyA\",\n\t\t\t\t\t\tvalue: \"valueA\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tkey: \"keyB\",\n\t\t\t\t\t\tvalue: \"valueB\"\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t}\n\n\t\tconst adjustedMetadata = helpers.adjustMetadata(additionalFieldsValues)\n\n\t\tconst expectedAdjustedMetadata = {\n\t\t\tmetadata: {\n\t\t\t\tkeyA: \"valueA\",\n\t\t\t\tkeyB: \"valueB\"\n\t\t\t}\n\t\t}\n\t\texpect(adjustedMetadata).toStrictEqual(expectedAdjustedMetadata)\n\t});","file":"nodes/Stripe/helpers.test.js","skipped":false,"dir":"packages/nodes-base/test"},{"name":"should recognize that item on parent level got added (init empty)","suites":["ObservableObject"],"updatePoint":{"line":4,"column":72},"line":4,"code":"\ttest('should recognize that item on parent level got added (init empty)', () => {\n\t\tconst testObject = ObservableObject.create({});\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\ttestObject.a = {};\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\n\t\t// Make sure that \"__dataChanged\" does not returned as a key\n\t\texpect(Object.keys(testObject)).toEqual(['a']);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should not recognize that item on parent level changed if it is empty object and option \"ignoreEmptyOnFirstChild\" === true (init empty)","suites":["ObservableObject"],"updatePoint":{"line":14,"column":142},"line":14,"code":"\ttest('should not recognize that item on parent level changed if it is empty object and option \"ignoreEmptyOnFirstChild\" === true (init empty)', () => {\n\t\tconst testObject = ObservableObject.create({}, undefined, { ignoreEmptyOnFirstChild: true });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\ttestObject.a = {};\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a).toEqual({});\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on parent level changed if it is not empty object and option \"ignoreEmptyOnFirstChild\" === true (init empty)","suites":["ObservableObject"],"updatePoint":{"line":22,"column":142},"line":22,"code":"\ttest('should recognize that item on parent level changed if it is not empty object and option \"ignoreEmptyOnFirstChild\" === true (init empty)', () => {\n\t\tconst testObject = ObservableObject.create({}, undefined, { ignoreEmptyOnFirstChild: true });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\ttestObject.a = { b: 2 };\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual({ b: 2 });\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should not recognize that item on parent level changed if it is empty array and option \"ignoreEmptyOnFirstChild\" === true (init empty)","suites":["ObservableObject"],"updatePoint":{"line":30,"column":141},"line":30,"code":"\ttest('should not recognize that item on parent level changed if it is empty array and option \"ignoreEmptyOnFirstChild\" === true (init empty)', () => {\n\t\tconst testObject = ObservableObject.create({}, undefined, { ignoreEmptyOnFirstChild: true });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\ttestObject.a = [];\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a).toEqual([]);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on parent level changed if it is not empty []] and option \"ignoreEmptyOnFirstChild\" === true (init empty)","suites":["ObservableObject"],"updatePoint":{"line":38,"column":139},"line":38,"code":"\ttest('should recognize that item on parent level changed if it is not empty []] and option \"ignoreEmptyOnFirstChild\" === true (init empty)', () => {\n\t\tconst testObject = ObservableObject.create({}, undefined, { ignoreEmptyOnFirstChild: true });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\ttestObject.a = [1, 2];\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual([1, 2]);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on parent level changed (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":46,"column":76},"line":46,"code":"\ttest('should recognize that item on parent level changed (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: 1 });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a).toEqual(1);\n\t\ttestObject.a = 2;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual(2);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that array on parent level changed (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":55,"column":77},"line":55,"code":"\ttest('should recognize that array on parent level changed (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: [1, 2] });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a).toEqual([1, 2]);\n\t\t(testObject.a as number[]).push(3);\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual([1, 2, 3]);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on first child level changed (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":64,"column":81},"line":64,"code":"\ttest('should recognize that item on first child level changed (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: 1 } });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual(1);\n\t\t(testObject.a! as IDataObject).b = 2;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual(2);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on first child level changed if it is now empty and option \"ignoreEmptyOnFirstChild\" === true (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":73,"column":146},"line":73,"code":"\ttest('should recognize that item on first child level changed if it is now empty and option \"ignoreEmptyOnFirstChild\" === true (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: 1 } }, undefined, {\n\t\t\tignoreEmptyOnFirstChild: true,\n\t\t});\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual(1);\n\t\ttestObject.a = {};\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual({});\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on first child level changed if it is now empty and option \"ignoreEmptyOnFirstChild\" === false (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":84,"column":147},"line":84,"code":"\ttest('should recognize that item on first child level changed if it is now empty and option \"ignoreEmptyOnFirstChild\" === false (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: 1 } }, undefined, {\n\t\t\tignoreEmptyOnFirstChild: false,\n\t\t});\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual(1);\n\t\ttestObject.a = {};\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a).toEqual({});\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that array on first child level changed (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":95,"column":82},"line":95,"code":"\ttest('should recognize that array on first child level changed (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: [1, 2] } });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual([1, 2]);\n\t\t((testObject.a! as IDataObject).b as number[]).push(3);\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual([1, 2, 3]);\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on second child level changed (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":104,"column":82},"line":104,"code":"\ttest('should recognize that item on second child level changed (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: { c: 1 } } });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual({ c: 1 });\n\t\texpect(((testObject.a! as IDataObject).b! as IDataObject).c).toEqual(1);\n\t\t((testObject.a! as IDataObject).b! as IDataObject).c = 2;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual({ c: 2 });\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on parent level got deleted (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":114,"column":80},"line":114,"code":"\ttest('should recognize that item on parent level got deleted (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: 1 });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a!).toEqual(1);\n\t\tdelete testObject.a;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a!).toEqual(undefined);\n\t\texpect(testObject).toEqual({});\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on parent level got deleted even with and option \"ignoreEmptyOnFirstChild\" === true (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":124,"column":136},"line":124,"code":"\ttest('should recognize that item on parent level got deleted even with and option \"ignoreEmptyOnFirstChild\" === true (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: 1 }, undefined, {\n\t\t\tignoreEmptyOnFirstChild: true,\n\t\t});\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect(testObject.a!).toEqual(1);\n\t\tdelete testObject.a;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect(testObject.a!).toEqual(undefined);\n\t\texpect(testObject).toEqual({});\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on second child level got deleted (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":136,"column":86},"line":136,"code":"\ttest('should recognize that item on second child level got deleted (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: { c: 1 } } });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual({ c: 1 });\n\t\tdelete (testObject.a! as IDataObject).b;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual(undefined);\n\t\texpect(testObject).toEqual({ a: {} });\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should recognize that item on second child level changed with null (init data exists)","suites":["ObservableObject"],"updatePoint":{"line":146,"column":92},"line":146,"code":"\ttest('should recognize that item on second child level changed with null (init data exists)', () => {\n\t\tconst testObject = ObservableObject.create({ a: { b: { c: null } } });\n\t\texpect(testObject.__dataChanged).toBeFalsy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual({ c: null });\n\t\texpect(((testObject.a! as IDataObject).b! as IDataObject).c).toEqual(null);\n\t\t((testObject.a! as IDataObject).b! as IDataObject).c = 2;\n\t\texpect(testObject.__dataChanged).toBeTruthy();\n\t\texpect((testObject.a! as IDataObject).b).toEqual({ c: 2 });\n\t});","file":"ObservableObject.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in valid URLs","suites":["getDomainBase should return protocol plus domain"],"updatePoint":{"line":9,"column":20},"line":9,"code":"\ttest('in valid URLs', () => {\n\t\tfor (const url of validUrls(numericId)) {\n\t\t\tconst { full, protocolPlusDomain } = url;\n\t\t\texpect(getDomainBase(full)).toBe(protocolPlusDomain);\n\t\t}\n\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in malformed URLs","suites":["getDomainBase should return protocol plus domain"],"updatePoint":{"line":16,"column":24},"line":16,"code":"\ttest('in malformed URLs', () => {\n\t\tfor (const url of malformedUrls(numericId)) {\n\t\t\tconst { full, protocolPlusDomain } = url;\n\t\t\texpect(getDomainBase(full)).toBe(protocolPlusDomain);\n\t\t}\n\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in valid URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing strings containing at least one number"],"updatePoint":{"line":26,"column":21},"line":26,"code":"\t\ttest('in valid URLs', () => {\n\t\t\tfor (const url of validUrls(alphanumericId)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in malformed URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing strings containing at least one number"],"updatePoint":{"line":33,"column":25},"line":33,"code":"\t\ttest('in malformed URLs', () => {\n\t\t\tfor (const url of malformedUrls(alphanumericId)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in valid URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing UUIDs"],"updatePoint":{"line":42,"column":21},"line":42,"code":"\t\ttest('in valid URLs', () => {\n\t\t\tfor (const url of uuidUrls(validUrls)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in malformed URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing UUIDs"],"updatePoint":{"line":49,"column":25},"line":49,"code":"\t\ttest('in malformed URLs', () => {\n\t\t\tfor (const url of uuidUrls(malformedUrls)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in valid URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing emails"],"updatePoint":{"line":58,"column":21},"line":58,"code":"\t\ttest('in valid URLs', () => {\n\t\t\tfor (const url of validUrls(email)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"in malformed URLs","suites":["getDomainPath should return pathname, excluding query string","anonymizing emails"],"updatePoint":{"line":65,"column":25},"line":65,"code":"\t\ttest('in malformed URLs', () => {\n\t\t\tfor (const url of malformedUrls(email)) {\n\t\t\t\tconst { full, pathname } = url;\n\t\t\t\texpect(getDomainPath(full)).toBe(pathname);\n\t\t\t}\n\t\t});","file":"TelemetryHelpers.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"should also resolve all child parameters when the parent get requested","suites":["Workflow","getParameterValue"],"updatePoint":{"line":1200,"column":78},"line":1200,"code":"\t\ttest('should also resolve all child parameters when the parent get requested', () => {\n\t\t\tconst nodeTypes = Helpers.NodeTypes();\n\n\t\t\tconst nodes: INode[] = [\n\t\t\t\t{\n\t\t\t\t\tname: 'Node1',\n\t\t\t\t\tparameters: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tstring: [\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tname: 'name1',\n\t\t\t\t\t\t\t\t\tvalue: 'value1',\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tname: 'name2',\n\t\t\t\t\t\t\t\t\tvalue: '={{$parameter.values.string[0].value}}A',\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'test.setMulti',\n\t\t\t\t\ttypeVersion: 1,\n\t\t\t\t\tposition: [100, 100],\n\t\t\t\t},\n\t\t\t];\n\t\t\tconst connections: IConnections = {};\n\n\t\t\tconst workflow = new Workflow({ nodes, connections, active: false, nodeTypes });\n\t\t\tconst activeNodeName = 'Node1';\n\n\t\t\tconst runExecutionData: IRunExecutionData = {\n\t\t\t\tresultData: {\n\t\t\t\t\trunData: {\n\t\t\t\t\t\tNode1: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstartTime: 1,\n\t\t\t\t\t\t\t\texecutionTime: 1,\n\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\tmain: [\n\t\t\t\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tjson: {},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tconst itemIndex = 0;\n\t\t\tconst runIndex = 0;\n\t\t\tconst connectionInputData: INodeExecutionData[] =\n\t\t\t\trunExecutionData.resultData.runData!['Node1']![0]!.data!.main[0]!;\n\t\t\tconst parameterName = 'values';\n\n\t\t\tconst parameterValue = nodes.find((node) => node.name === activeNodeName)!.parameters[\n\t\t\t\tparameterName\n\t\t\t];\n\t\t\tconst result = workflow.expression.getParameterValue(\n\t\t\t\tparameterValue,\n\t\t\t\trunExecutionData,\n\t\t\t\trunIndex,\n\t\t\t\titemIndex,\n\t\t\t\tactiveNodeName,\n\t\t\t\tconnectionInputData,\n\t\t\t\t'manual',\n\t\t\t\ttimezone,\n\t\t\t\t{},\n\t\t\t);\n\n\t\t\texpect(result).toEqual({\n\t\t\t\tstring: [\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'name1',\n\t\t\t\t\t\tvalue: 'value1',\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: 'name2',\n\t\t\t\t\t\tvalue: 'value1A',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Should return parent nodes of nodes","suites":["Workflow","getParentNodesByDepth"],"updatePoint":{"line":1541,"column":43},"line":1541,"code":"\t\ttest('Should return parent nodes of nodes', () => {\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Start')).toEqual([]);\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t]);\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set1')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t]);\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Should return parent up to depth","suites":["Workflow","getParentNodesByDepth"],"updatePoint":{"line":1564,"column":40},"line":1564,"code":"\t\ttest('Should return parent up to depth', () => {\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set1', 0)).toEqual([]);\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set1', 1)).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t]);\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Should return all parents with depth of -1","suites":["Workflow","getParentNodesByDepth"],"updatePoint":{"line":1575,"column":50},"line":1575,"code":"\t\ttest('Should return all parents with depth of -1', () => {\n\t\t\texpect(SIMPLE_WORKFLOW.getParentNodesByDepth('Set1', -1)).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t]);\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Should return parents of nodes with all connected output indicies","suites":["Workflow","getParentNodesByDepth"],"updatePoint":{"line":1590,"column":73},"line":1590,"code":"\t\ttest('Should return parents of nodes with all connected output indicies', () => {\n\t\t\texpect(WORKFLOW_WITH_SWITCH.getParentNodesByDepth('Switch')).toEqual([]);\n\t\t\texpect(WORKFLOW_WITH_SWITCH.getParentNodesByDepth('Set1')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Switch',\n\t\t\t\t},\n\t\t\t]);\n\t\t\texpect(WORKFLOW_WITH_SWITCH.getParentNodesByDepth('Set')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [1, 2],\n\t\t\t\t\tname: 'Switch',\n\t\t\t\t},\n\t\t\t]);\n\n\t\t\texpect(WORKFLOW_WITH_SWITCH.getParentNodesByDepth('Set2')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set1',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [1, 2, 0],\n\t\t\t\t\tname: 'Switch',\n\t\t\t\t},\n\t\t\t]);\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"Should handle loops within workflows","suites":["Workflow","getParentNodesByDepth"],"updatePoint":{"line":1626,"column":44},"line":1626,"code":"\t\ttest('Should handle loops within workflows', () => {\n\t\t\texpect(WORKFLOW_WITH_LOOPS.getParentNodesByDepth('Start')).toEqual([]);\n\t\t\texpect(WORKFLOW_WITH_LOOPS.getParentNodesByDepth('Set')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0, 2],\n\t\t\t\t\tname: 'Switch',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set1',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 3,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t]);\n\t\t\texpect(WORKFLOW_WITH_LOOPS.getParentNodesByDepth('Switch')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set1',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t]);\n\t\t\texpect(WORKFLOW_WITH_LOOPS.getParentNodesByDepth('Set1')).toEqual([\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Start',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 1,\n\t\t\t\t\tindicies: [0],\n\t\t\t\t\tname: 'Set',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tdepth: 2,\n\t\t\t\t\tindicies: [0, 2],\n\t\t\t\t\tname: 'Switch',\n\t\t\t\t},\n\t\t\t]);\n\t\t});","file":"Workflow.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").all()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":156,"column":32},"line":156,"code":"\t\ttest('test $(\"NodeName\").all()', () => {\n\t\t\texpect(proxy.$('Rename').all()[1].json.data).toEqual(160);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").all() length","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":159,"column":39},"line":159,"code":"\t\ttest('test $(\"NodeName\").all() length', () => {\n\t\t\texpect(proxy.$('Rename').all().length).toEqual(5);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").item()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":162,"column":33},"line":162,"code":"\t\ttest('test $(\"NodeName\").item()', () => {\n\t\t\texpect(proxy.$('Rename').item().json.data).toEqual(105);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").item(2)","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":165,"column":34},"line":165,"code":"\t\ttest('test $(\"NodeName\").item(2)', () => {\n\t\t\texpect(proxy.$('Rename').item(2).json.data).toEqual(121);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").first()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":168,"column":34},"line":168,"code":"\t\ttest('test $(\"NodeName\").first()', () => {\n\t\t\texpect(proxy.$('Rename').first().json.data).toEqual(105);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $(\"NodeName\").last()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":171,"column":33},"line":171,"code":"\t\ttest('test $(\"NodeName\").last()', () => {\n\t\t\texpect(proxy.$('Rename').last().json.data).toEqual(950);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $input.all()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":175,"column":25},"line":175,"code":"\t\ttest('test $input.all()', () => {\n\t\t\texpect(proxy.$input.all()[1].json.length).toEqual(160);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $input.all() length","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":178,"column":32},"line":178,"code":"\t\ttest('test $input.all() length', () => {\n\t\t\texpect(proxy.$input.all().length).toEqual(5);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $input.item()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":181,"column":26},"line":181,"code":"\t\ttest('test $input.item()', () => {\n\t\t\texpect(proxy.$input.item().json.length).toEqual(105);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $thisItem","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":184,"column":22},"line":184,"code":"\t\ttest('test $thisItem', () => {\n\t\t\texpect(proxy.$thisItem.json.length).toEqual(105);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $input.item(2)","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":187,"column":27},"line":187,"code":"\t\ttest('test $input.item(2)', () => {\n\t\t\texpect(proxy.$input.item(2).json.length).toEqual(121);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $input.first()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":190,"column":27},"line":190,"code":"\t\ttest('test $input.first()', () => {\n\t\t\texpect(proxy.$input.first().json.length).toEqual(105);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"},{"name":"test $input.last()","suites":["WorkflowDataProxy","test data proxy"],"updatePoint":{"line":193,"column":26},"line":193,"code":"\t\ttest('test $input.last()', () => {\n\t\t\texpect(proxy.$input.last().json.length).toEqual(950);\n\t\t});","file":"WorkflowDataProxy.test.ts","skipped":false,"dir":"packages/workflow/test"}]}