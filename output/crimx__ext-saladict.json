{
    "repo": "crimx/ext-saladict",
    "url": "https://github.com/crimx/ext-saladict",
    "branch": "dev",
    "configs": [
        {
            "package": "saladict",
            "lang": "ts",
            "dir": "test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        }
    ],
    "tests": [
        {
            "name": "storage..clear",
            "suites": [
                "Browser API Wapper",
                "Storage"
            ],
            "updatePoint": {
                "line": 21,
                "column": 31
            },
            "line": 21,
            "code": "      it(`storage.${area}.clear`, () => {\n        storage[area].clear()\n        expect(browser.storage[area].clear.calledOnce).toBeTruthy()\n      })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "storage..remove",
            "suites": [
                "Browser API Wapper",
                "Storage"
            ],
            "updatePoint": {
                "line": 25,
                "column": 32
            },
            "line": 25,
            "code": "      it(`storage.${area}.remove`, () => {\n        const key = `key-${area}`\n        storage[area].remove(key)\n        expect(browser.storage[area].remove.calledWith(key)).toBeTruthy()\n      })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "storage..get",
            "suites": [
                "Browser API Wapper",
                "Storage"
            ],
            "updatePoint": {
                "line": 30,
                "column": 29
            },
            "line": 30,
            "code": "      it(`storage.${area}.get`, () => {\n        const key = `key-${area}`\n        storage[area].get(key)\n        expect(browser.storage[area].get.calledWith(key)).toBeTruthy()\n      })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "storage..set",
            "suites": [
                "Browser API Wapper",
                "Storage"
            ],
            "updatePoint": {
                "line": 35,
                "column": 29
            },
            "line": 35,
            "code": "      it(`storage.${area}.set`, () => {\n        const key = { key: area }\n        storage[area].set(key)\n        expect(browser.storage[area].set.calledWith(key)).toBeTruthy()\n      })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "with cb",
            "suites": [
                "Browser API Wapper",
                "Storage",
                "storage..addListener"
            ],
            "updatePoint": {
                "line": 46,
                "column": 19
            },
            "line": 46,
            "code": "        it('with cb', () => {\n          const cb = jest.fn()\n          let cbCall = 0\n          storage[area].addListener(cb)\n          expect(browser.storage.onChanged.addListener.calledOnce).toBeTruthy()\n\n          browser.storage.onChanged.dispatch(changes, otherArea)\n          expect(cb).toHaveBeenCalledTimes(cbCall)\n\n          browser.storage.onChanged.dispatch(changes, area)\n          expect(cb).toHaveBeenCalledTimes(++cbCall)\n          expect(cb).toBeCalledWith(changes, area)\n        })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "with key and cb",
            "suites": [
                "Browser API Wapper",
                "Storage",
                "storage..addListener"
            ],
            "updatePoint": {
                "line": 59,
                "column": 27
            },
            "line": 59,
            "code": "        it('with key and cb', () => {\n          const cb = jest.fn()\n          let cbCall = 0\n          storage[area].addListener('key', cb)\n          expect(browser.storage.onChanged.addListener.calledOnce).toBeTruthy()\n\n          browser.storage.onChanged.dispatch(changes, otherArea)\n          expect(cb).toHaveBeenCalledTimes(cbCall)\n\n          browser.storage.onChanged.dispatch({ badKey: 'value' }, area)\n          expect(cb).toHaveBeenCalledTimes(cbCall)\n\n          browser.storage.onChanged.dispatch(changes, area)\n          expect(cb).toHaveBeenCalledTimes(++cbCall)\n          expect(cb).toBeCalledWith(changes, area)\n        })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "with cb remove addListener with cb",
            "suites": [
                "Browser API Wapper",
                "Storage",
                "storage..removeListener"
            ],
            "updatePoint": {
                "line": 81,
                "column": 46
            },
            "line": 81,
            "code": "        it('with cb remove addListener with cb', () => {\n          const cb = jest.fn()\n          let cbCall = 0\n          storage[area].addListener(cb)\n\n          // won't affect cb\n          storage[area].removeListener('key', cb)\n          expect(\n            browser.storage.onChanged.removeListener.calledOnce\n          ).toBeTruthy()\n\n          browser.storage.onChanged.dispatch(changes, area)\n          expect(cb).toHaveBeenCalledTimes(++cbCall)\n          expect(cb).toBeCalledWith(changes, area)\n\n          storage[area].removeListener(cb)\n          expect(\n            browser.storage.onChanged.removeListener.calledTwice\n          ).toBeTruthy()\n\n          browser.storage.onChanged.dispatch(changes, area)\n          expect(cb).toHaveBeenCalledTimes(cbCall)\n\n          browser.storage.onChanged.dispatch({ badKey: 'value' }, area)\n          expect(cb).toHaveBeenCalledTimes(cbCall)\n        })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "with cb, remove addListener with key and cb",
            "suites": [
                "Browser API Wapper",
                "Storage",
                "storage..removeListener"
            ],
            "updatePoint": {
                "line": 108,
                "column": 55
            },
            "line": 108,
            "code": "        it('with cb, remove addListener with key and cb', () => {\n          const cb = jest.fn()\n          let cbCall = 0\n          storage[area].addListener('key', cb)\n\n          browser.storage.onChanged.dispatch(changes, area)\n          expect(cb).toHaveBeenCalledTimes(++cbCall)\n          expect(cb).toBeCalledWith(changes, area)\n\n          storage[area].removeListener(cb)\n          expect(\n            browser.storage.onChanged.removeListener.calledOnce\n          ).toBeTruthy()\n\n          browser.storage.onChanged.dispatch(changes, area)\n          expect(cb).toHaveBeenCalledTimes(cbCall)\n\n          browser.storage.onChanged.dispatch({ badKey: 'value' }, area)\n          expect(cb).toHaveBeenCalledTimes(cbCall)\n        })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "with key and cb",
            "suites": [
                "Browser API Wapper",
                "Storage",
                "storage..removeListener"
            ],
            "updatePoint": {
                "line": 129,
                "column": 27
            },
            "line": 129,
            "code": "        it('with key and cb', () => {\n          const cb = jest.fn()\n          let cbCall = 0\n          storage[area].addListener('key', cb)\n\n          // won't affect key + cb\n          storage[area].removeListener('badkey', cb)\n          expect(\n            browser.storage.onChanged.removeListener.calledOnce\n          ).toBeTruthy()\n\n          browser.storage.onChanged.dispatch(changes, area)\n          expect(cb).toHaveBeenCalledTimes(++cbCall)\n          expect(cb).toBeCalledWith(changes, area)\n\n          storage[area].removeListener('key', cb)\n          expect(\n            browser.storage.onChanged.removeListener.calledTwice\n          ).toBeTruthy()\n\n          browser.storage.onChanged.dispatch(changes, area)\n          expect(cb).toHaveBeenCalledTimes(cbCall)\n\n          browser.storage.onChanged.dispatch({ badKey: 'value' }, area)\n          expect(cb).toHaveBeenCalledTimes(cbCall)\n        })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "with key",
            "suites": [
                "Browser API Wapper",
                "Storage",
                "storage..createStream"
            ],
            "updatePoint": {
                "line": 162,
                "column": 20
            },
            "line": 162,
            "code": "        it('with key', () => {\n          const nextStub = jest.fn()\n          const errorStub = jest.fn()\n          const completeStub = jest.fn()\n          storage[area]\n            .createStream<typeof changes.key>('key')\n            .pipe(take(1))\n            .subscribe(nextStub, errorStub, completeStub)\n          expect(browser.storage.onChanged.addListener.calledOnce).toBeTruthy()\n          expect(nextStub).toHaveBeenCalledTimes(0)\n          expect(errorStub).toHaveBeenCalledTimes(0)\n          expect(completeStub).toHaveBeenCalledTimes(0)\n\n          browser.storage.onChanged.dispatch(changes, otherArea)\n          expect(nextStub).toHaveBeenCalledTimes(0)\n          expect(errorStub).toHaveBeenCalledTimes(0)\n          expect(completeStub).toHaveBeenCalledTimes(0)\n\n          browser.storage.onChanged.dispatch(changes, area)\n          expect(nextStub).toHaveBeenCalledTimes(1)\n          expect(errorStub).toHaveBeenCalledTimes(0)\n          expect(completeStub).toHaveBeenCalledTimes(1)\n          expect(nextStub).toBeCalledWith(changes.key)\n        })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "storage.clear",
            "suites": [
                "Browser API Wapper",
                "Storage",
                "storage..createStream"
            ],
            "updatePoint": {
                "line": 189,
                "column": 21
            },
            "line": 189,
            "code": "    it('storage.clear', () => {\n      storage.clear()\n      expect(browser.storage.sync.clear.calledOnce).toBeTruthy()\n      expect(browser.storage.local.clear.calledOnce).toBeTruthy()\n    })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "with cb",
            "suites": [
                "Browser API Wapper",
                "Storage",
                "storage.addListener"
            ],
            "updatePoint": {
                "line": 198,
                "column": 17
            },
            "line": 198,
            "code": "      it('with cb', () => {\n        const cb = jest.fn()\n        let cbCall = 0\n        storage.addListener(cb)\n        expect(browser.storage.onChanged.addListener.calledOnce).toBeTruthy()\n        expect(cb).toHaveBeenCalledTimes(cbCall)\n\n        storageArea.forEach(area => {\n          browser.storage.onChanged.dispatch(changes, area)\n          expect(cb).toHaveBeenCalledTimes(++cbCall)\n          browser.storage.onChanged.dispatch(otherChanges, area)\n          expect(cb).toHaveBeenCalledTimes(++cbCall)\n        })\n      })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "with key and cb",
            "suites": [
                "Browser API Wapper",
                "Storage",
                "storage.addListener"
            ],
            "updatePoint": {
                "line": 212,
                "column": 25
            },
            "line": 212,
            "code": "      it('with key and cb', () => {\n        const cb = jest.fn()\n        let cbCall = 0\n        storage.addListener('key', cb)\n        expect(browser.storage.onChanged.addListener.calledOnce).toBeTruthy()\n        expect(cb).toHaveBeenCalledTimes(cbCall)\n\n        const changes = {\n          key: { newValue: 'new value', oldValue: 'old value' }\n        }\n        const otherChanges = { otherKey: 'other value' }\n        storageArea.forEach(area => {\n          browser.storage.onChanged.dispatch(changes, area)\n          expect(cb).toHaveBeenCalledTimes(++cbCall)\n          browser.storage.onChanged.dispatch(otherChanges, area)\n          expect(cb).toHaveBeenCalledTimes(cbCall)\n        })\n      })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "with cb",
            "suites": [
                "Browser API Wapper",
                "Storage",
                "storage.removeListener"
            ],
            "updatePoint": {
                "line": 235,
                "column": 17
            },
            "line": 235,
            "code": "      it('with cb', () => {\n        const cb = jest.fn()\n        let cbCall = 0\n        storage.addListener(cb)\n\n        storageArea.forEach(area => {\n          browser.storage.onChanged.dispatch(changes, area)\n          expect(cb).toHaveBeenCalledTimes(++cbCall)\n          browser.storage.onChanged.dispatch(otherChanges, area)\n          expect(cb).toHaveBeenCalledTimes(++cbCall)\n        })\n\n        storage.removeListener(cb)\n        expect(browser.storage.onChanged.removeListener.calledOnce).toBeTruthy()\n\n        storageArea.forEach(area => {\n          browser.storage.onChanged.dispatch(changes, area)\n          expect(cb).toHaveBeenCalledTimes(cbCall)\n          browser.storage.onChanged.dispatch(otherChanges, area)\n          expect(cb).toHaveBeenCalledTimes(cbCall)\n        })\n      })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "with key and cb",
            "suites": [
                "Browser API Wapper",
                "Storage",
                "storage.removeListener"
            ],
            "updatePoint": {
                "line": 258,
                "column": 25
            },
            "line": 258,
            "code": "      it('with key and cb', () => {\n        const cb = jest.fn()\n        let cbCall = 0\n        storage.addListener('key', cb)\n\n        storageArea.forEach(area => {\n          browser.storage.onChanged.dispatch(changes, area)\n          expect(cb).toHaveBeenCalledTimes(++cbCall)\n          browser.storage.onChanged.dispatch(otherChanges, area)\n          expect(cb).toHaveBeenCalledTimes(cbCall)\n        })\n\n        storage.removeListener('otherKey', cb)\n        expect(browser.storage.onChanged.removeListener.calledOnce).toBeTruthy()\n\n        storageArea.forEach(area => {\n          browser.storage.onChanged.dispatch(changes, area)\n          expect(cb).toHaveBeenCalledTimes(++cbCall)\n          browser.storage.onChanged.dispatch(otherChanges, area)\n          expect(cb).toHaveBeenCalledTimes(cbCall)\n        })\n\n        storage.removeListener('key', cb)\n        expect(\n          browser.storage.onChanged.removeListener.calledTwice\n        ).toBeTruthy()\n\n        storageArea.forEach(area => {\n          browser.storage.onChanged.dispatch(changes, area)\n          expect(cb).toHaveBeenCalledTimes(cbCall)\n          browser.storage.onChanged.dispatch(otherChanges, area)\n          expect(cb).toHaveBeenCalledTimes(cbCall)\n        })\n      })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "with key",
            "suites": [
                "Browser API Wapper",
                "Storage",
                "storage.createStream"
            ],
            "updatePoint": {
                "line": 301,
                "column": 18
            },
            "line": 301,
            "code": "      it('with key', () => {\n        const nextStub = jest.fn()\n        const errorStub = jest.fn()\n        const completeStub = jest.fn()\n        storage\n          .createStream<typeof changes2.key2>('key2')\n          .pipe(take(1))\n          .subscribe(nextStub, errorStub, completeStub)\n        expect(browser.storage.onChanged.addListener.calledOnce).toBeTruthy()\n        expect(nextStub).toHaveBeenCalledTimes(0)\n        expect(errorStub).toHaveBeenCalledTimes(0)\n        expect(completeStub).toHaveBeenCalledTimes(0)\n\n        browser.storage.onChanged.dispatch(changes1, 'local')\n        expect(nextStub).toHaveBeenCalledTimes(0)\n        expect(errorStub).toHaveBeenCalledTimes(0)\n        expect(completeStub).toHaveBeenCalledTimes(0)\n\n        browser.storage.onChanged.dispatch(changes2, 'sync')\n        expect(nextStub).toHaveBeenCalledTimes(1)\n        expect(errorStub).toHaveBeenCalledTimes(0)\n        expect(completeStub).toHaveBeenCalledTimes(1)\n        expect(nextStub).toBeCalledWith(changes2.key2)\n      })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "message.send",
            "suites": [
                "Browser API Wapper",
                "Message"
            ],
            "updatePoint": {
                "line": 329,
                "column": 20
            },
            "line": 329,
            "code": "    it('message.send', () => {\n      const tabId = 1\n      const msg: Message = { type: 'OPEN_QS_PANEL' }\n\n      message.send(msg)\n      expect(browser.runtime.sendMessage.calledWith(msg)).toBeTruthy()\n      expect(browser.tabs.sendMessage.notCalled).toBeTruthy()\n\n      browser.runtime.sendMessage.flush()\n      browser.tabs.sendMessage.flush()\n      browser.runtime.sendMessage.callsFake(() => Promise.resolve({}))\n      browser.tabs.sendMessage.callsFake(() => Promise.resolve({}))\n\n      message.send(tabId, msg)\n      expect(browser.tabs.sendMessage.calledWith(tabId, msg)).toBeTruthy()\n      expect(browser.runtime.sendMessage.notCalled).toBeTruthy()\n    })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "message.addListener",
            "suites": [
                "Browser API Wapper",
                "Message"
            ],
            "updatePoint": {
                "line": 346,
                "column": 27
            },
            "line": 346,
            "code": "    it('message.addListener', () => {\n      const cb1 = jest.fn()\n      const cb2 = jest.fn()\n      let cb1Call = 0\n      let cb2Call = 0\n      message.addListener(cb1)\n      message.addListener('OPEN_QS_PANEL', cb2)\n      expect(browser.runtime.onMessage.addListener.calledTwice).toBeTruthy()\n      expect(cb1).toHaveBeenCalledTimes(cb1Call)\n      expect(cb2).toHaveBeenCalledTimes(cb2Call)\n\n      browser.runtime.onMessage.dispatch({ type: 'CLOSE_QS_PANEL' })\n      expect(cb1).toHaveBeenCalledTimes(++cb1Call)\n      expect(cb2).toHaveBeenCalledTimes(cb2Call)\n\n      browser.runtime.onMessage.dispatch({ type: 'OPEN_QS_PANEL' })\n      expect(cb1).toHaveBeenCalledTimes(++cb1Call)\n      expect(cb2).toHaveBeenCalledTimes(++cb2Call)\n    })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "message.removeListener",
            "suites": [
                "Browser API Wapper",
                "Message"
            ],
            "updatePoint": {
                "line": 365,
                "column": 30
            },
            "line": 365,
            "code": "    it('message.removeListener', () => {\n      const cb1 = jest.fn()\n      const cb2 = jest.fn()\n      let cb1Call = 0\n      const cb2Call = 0\n      message.addListener('OPEN_QS_PANEL', cb1)\n      message.addListener('CLOSE_QS_PANEL', cb2)\n      browser.runtime.onMessage.dispatch({ type: 'OPEN_QS_PANEL' })\n      expect(cb1).toHaveBeenCalledTimes(++cb1Call)\n      expect(cb2).toHaveBeenCalledTimes(cb2Call)\n\n      message.removeListener('QUERY_QS_PANEL', cb1)\n      message.removeListener(cb2)\n      expect(browser.runtime.onMessage.removeListener.calledTwice).toBeTruthy()\n\n      browser.runtime.onMessage.dispatch({ type: 'OPEN_QS_PANEL' })\n      browser.runtime.onMessage.dispatch({ type: 'CLOSE_QS_PANEL' })\n      expect(cb1).toHaveBeenCalledTimes(++cb1Call)\n      expect(cb2).toHaveBeenCalledTimes(cb2Call)\n\n      message.removeListener('OPEN_QS_PANEL', cb1)\n      browser.runtime.onMessage.dispatch({ type: 'OPEN_QS_PANEL' })\n      expect(cb1).toHaveBeenCalledTimes(cb1Call)\n    })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "without argument",
            "suites": [
                "Browser API Wapper",
                "Message",
                "message.createStream"
            ],
            "updatePoint": {
                "line": 390,
                "column": 26
            },
            "line": 390,
            "code": "      it('without argument', () => {\n        const nextStub = jest.fn()\n        const errorStub = jest.fn()\n        const completeStub = jest.fn()\n        message\n          .createStream()\n          .pipe(take(2))\n          .subscribe(nextStub, errorStub, completeStub)\n        expect(browser.runtime.onMessage.addListener.calledOnce).toBeTruthy()\n        expect(nextStub).toHaveBeenCalledTimes(0)\n        expect(errorStub).toHaveBeenCalledTimes(0)\n        expect(completeStub).toHaveBeenCalledTimes(0)\n\n        browser.runtime.onMessage.dispatch({ type: 1 })\n        expect(nextStub).toHaveBeenCalledTimes(1)\n        expect(errorStub).toHaveBeenCalledTimes(0)\n        expect(completeStub).toHaveBeenCalledTimes(0)\n        expect(nextStub).toBeCalledWith({ type: 1 })\n\n        browser.runtime.onMessage.dispatch({ type: 2 })\n        expect(nextStub).toHaveBeenCalledTimes(2)\n        expect(errorStub).toHaveBeenCalledTimes(0)\n        expect(completeStub).toHaveBeenCalledTimes(1)\n        expect(nextStub).toBeCalledWith({ type: 2 })\n      })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "with message type",
            "suites": [
                "Browser API Wapper",
                "Message",
                "message.createStream"
            ],
            "updatePoint": {
                "line": 416,
                "column": 27
            },
            "line": 416,
            "code": "      it('with message type', () => {\n        const nextStub = jest.fn()\n        const errorStub = jest.fn()\n        const completeStub = jest.fn()\n        message\n          .createStream('OPEN_QS_PANEL')\n          .pipe(take(1))\n          .subscribe(nextStub, errorStub, completeStub)\n        expect(browser.runtime.onMessage.addListener.calledOnce).toBeTruthy()\n        expect(nextStub).toHaveBeenCalledTimes(0)\n        expect(errorStub).toHaveBeenCalledTimes(0)\n        expect(completeStub).toHaveBeenCalledTimes(0)\n\n        browser.runtime.onMessage.dispatch({ type: 'CLOSE_QS_PANEL' })\n        expect(nextStub).toHaveBeenCalledTimes(0)\n        expect(errorStub).toHaveBeenCalledTimes(0)\n        expect(completeStub).toHaveBeenCalledTimes(0)\n\n        browser.runtime.onMessage.dispatch({ type: 'OPEN_QS_PANEL' })\n        expect(nextStub).toHaveBeenCalledTimes(1)\n        expect(errorStub).toHaveBeenCalledTimes(0)\n        expect(completeStub).toHaveBeenCalledTimes(1)\n        expect(nextStub).toBeCalledWith({ type: 'OPEN_QS_PANEL' })\n      })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "message.self.initClient",
            "suites": [
                "Browser API Wapper",
                "Message",
                "message.createStream"
            ],
            "updatePoint": {
                "line": 442,
                "column": 31
            },
            "line": 442,
            "code": "    it('message.self.initClient', () => {\n      browser.runtime.sendMessage.withArgs({ type: 'PAGE_INFO' }).returns(\n        Promise.resolve({\n          pageId: 'pageId',\n          faviconURL: 'faviconURL',\n          pageTitle: 'pageTitle',\n          pageURL: 'pageURL'\n        })\n      )\n      return message.self.initClient().then(() => {\n        expect(\n          browser.runtime.sendMessage.calledWith({ type: 'PAGE_INFO' })\n        ).toBeTruthy()\n        expect(window.pageId).toBe('pageId')\n        expect(window.faviconURL).toBe('faviconURL')\n        expect(window.pageTitle).toBe('pageTitle')\n        expect(window.pageURL).toBe('pageURL')\n      })\n    })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "From tab",
            "suites": [
                "Browser API Wapper",
                "Message",
                "message.self.initServer"
            ],
            "updatePoint": {
                "line": 469,
                "column": 18
            },
            "line": 469,
            "code": "      it('From tab', done => {\n        message.self.initServer()\n        expect(browser.runtime.onMessage.addListener.calledOnce).toBeTruthy()\n\n        browser.runtime.onMessage['_listeners']\n          [0]({ type: 'PAGE_INFO' }, { tab })\n          .then(response => {\n            expect(response).toEqual({\n              pageId: tab.id,\n              faviconURL: tab.favIconUrl,\n              pageTitle: tab.title,\n              pageURL: tab.url\n            })\n            done()\n          })\n      })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "From browser action page",
            "suites": [
                "Browser API Wapper",
                "Message",
                "message.self.initServer"
            ],
            "updatePoint": {
                "line": 486,
                "column": 34
            },
            "line": 486,
            "code": "      it('From browser action page', done => {\n        message.self.initServer()\n        expect(browser.runtime.onMessage.addListener.calledOnce).toBeTruthy()\n\n        const sendResponse = jest.fn()\n        browser.runtime.onMessage['_listeners']\n          [0]({ type: 'PAGE_INFO' }, {}, sendResponse)\n          .then(response => {\n            expect(response).toHaveProperty('pageId', 'popup')\n            done()\n          })\n      })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "Self page message transmission",
            "suites": [
                "Browser API Wapper",
                "Message",
                "message.self.initServer"
            ],
            "updatePoint": {
                "line": 499,
                "column": 40
            },
            "line": 499,
            "code": "      it('Self page message transmission', () => {\n        message.self.initServer()\n        expect(browser.runtime.onMessage.addListener.calledOnce).toBeTruthy()\n\n        browser.runtime.onMessage.dispatch({ type: '[[1]]', __pageId__: 1 }, {})\n        expect(\n          browser.runtime.sendMessage.calledWith({ type: '1', __pageId__: 1 })\n        ).toBeTruthy()\n        browser.runtime.sendMessage.resetHistory()\n\n        browser.runtime.onMessage.dispatch(\n          { type: '[[1]]', __pageId__: 1 },\n          { tab }\n        )\n        expect(\n          browser.tabs.sendMessage.calledWith(tab.id, {\n            type: '1',\n            __pageId__: 1\n          })\n        ).toBeTruthy()\n      })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "message.self.send",
            "suites": [
                "Browser API Wapper",
                "Message",
                "message.self.initServer"
            ],
            "updatePoint": {
                "line": 521,
                "column": 25
            },
            "line": 521,
            "code": "    it('message.self.send', () => {\n      window.pageId = 1\n      message.self.send({\n        type: 'QUERY_PANEL_STATE',\n        payload: 'value'\n      })\n      expect(\n        browser.runtime.sendMessage.calledWith({\n          type: '[[QUERY_PANEL_STATE]]',\n          __pageId__: window.pageId,\n          payload: 'value'\n        })\n      ).toBeTruthy()\n    })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "message.self.addListener",
            "suites": [
                "Browser API Wapper",
                "Message",
                "message.self.initServer"
            ],
            "updatePoint": {
                "line": 535,
                "column": 32
            },
            "line": 535,
            "code": "    it('message.self.addListener', () => {\n      window.pageId = 1\n      const cb1 = jest.fn()\n      const cb2 = jest.fn()\n      let cb1Call = 0\n      let cb2Call = 0\n      message.self.addListener(cb1)\n      message.addListener(cb2)\n      expect(browser.runtime.onMessage.addListener.calledTwice).toBeTruthy()\n      expect(cb1).toHaveBeenCalledTimes(cb1Call)\n      expect(cb2).toHaveBeenCalledTimes(cb2Call)\n\n      browser.runtime.onMessage.dispatch({ type: 1, __pageId__: window.pageId })\n      expect(cb1).toHaveBeenCalledTimes(++cb1Call)\n      expect(cb2).toHaveBeenCalledTimes(cb2Call)\n\n      browser.runtime.onMessage.dispatch({ type: 1 })\n      expect(cb1).toHaveBeenCalledTimes(cb1Call)\n      expect(cb2).toHaveBeenCalledTimes(++cb2Call)\n\n      browser.runtime.onMessage.dispatch({\n        type: 1,\n        __pageId__: window.pageId + 2\n      })\n      expect(cb1).toHaveBeenCalledTimes(cb1Call)\n      expect(cb2).toHaveBeenCalledTimes(cb2Call)\n    })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "message.self.removeListener",
            "suites": [
                "Browser API Wapper",
                "Message",
                "message.self.initServer"
            ],
            "updatePoint": {
                "line": 562,
                "column": 35
            },
            "line": 562,
            "code": "    it('message.self.removeListener', () => {\n      window.pageId = 1\n      const cb1 = jest.fn()\n      let cb1Call = 0\n      message.self.addListener(cb1)\n      browser.runtime.onMessage.dispatch({ __pageId__: window.pageId })\n      expect(cb1).toHaveBeenCalledTimes(++cb1Call)\n\n      message.self.removeListener(cb1)\n      expect(browser.runtime.onMessage.removeListener.calledOnce).toBeTruthy()\n\n      browser.runtime.onMessage.dispatch({ __pageId__: window.pageId })\n      expect(cb1).toHaveBeenCalledTimes(cb1Call)\n    })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "without argument",
            "suites": [
                "Browser API Wapper",
                "Message",
                "message.self.createStream"
            ],
            "updatePoint": {
                "line": 577,
                "column": 26
            },
            "line": 577,
            "code": "      it('without argument', () => {\n        window.pageId = 1\n        const nextStub = jest.fn()\n        const errorStub = jest.fn()\n        const completeStub = jest.fn()\n        message.self\n          .createStream()\n          .pipe(take(2))\n          .subscribe(nextStub, errorStub, completeStub)\n        expect(browser.runtime.onMessage.addListener.calledOnce).toBeTruthy()\n        expect(nextStub).toHaveBeenCalledTimes(0)\n        expect(errorStub).toHaveBeenCalledTimes(0)\n        expect(completeStub).toHaveBeenCalledTimes(0)\n\n        browser.runtime.onMessage.dispatch({\n          type: 1,\n          __pageId__: window.pageId\n        })\n        expect(nextStub).toHaveBeenCalledTimes(1)\n        expect(errorStub).toHaveBeenCalledTimes(0)\n        expect(completeStub).toHaveBeenCalledTimes(0)\n        expect(nextStub).toBeCalledWith({ type: 1, __pageId__: window.pageId })\n\n        browser.runtime.onMessage.dispatch({\n          type: 2,\n          __pageId__: window.pageId\n        })\n        expect(nextStub).toHaveBeenCalledTimes(2)\n        expect(errorStub).toHaveBeenCalledTimes(0)\n        expect(completeStub).toHaveBeenCalledTimes(1)\n        expect(nextStub).toBeCalledWith({ type: 2, __pageId__: window.pageId })\n      })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "with message type",
            "suites": [
                "Browser API Wapper",
                "Message",
                "message.self.createStream"
            ],
            "updatePoint": {
                "line": 610,
                "column": 27
            },
            "line": 610,
            "code": "      it('with message type', () => {\n        window.pageId = 1\n        const nextStub = jest.fn()\n        const errorStub = jest.fn()\n        const completeStub = jest.fn()\n        message.self\n          .createStream('OPEN_QS_PANEL')\n          .pipe(take(1))\n          .subscribe(nextStub, errorStub, completeStub)\n        expect(browser.runtime.onMessage.addListener.calledOnce).toBeTruthy()\n        expect(nextStub).toHaveBeenCalledTimes(0)\n        expect(errorStub).toHaveBeenCalledTimes(0)\n        expect(completeStub).toHaveBeenCalledTimes(0)\n\n        browser.runtime.onMessage.dispatch({\n          type: 'CLOSE_QS_PANEL',\n          __pageId__: window.pageId\n        })\n        expect(nextStub).toHaveBeenCalledTimes(0)\n        expect(errorStub).toHaveBeenCalledTimes(0)\n        expect(completeStub).toHaveBeenCalledTimes(0)\n\n        browser.runtime.onMessage.dispatch({\n          type: 'OPEN_QS_PANEL',\n          __pageId__: window.pageId\n        })\n        expect(nextStub).toHaveBeenCalledTimes(1)\n        expect(errorStub).toHaveBeenCalledTimes(0)\n        expect(completeStub).toHaveBeenCalledTimes(1)\n        expect(nextStub.mock.calls[0][0]).toEqual({\n          type: 'OPEN_QS_PANEL',\n          __pageId__: window.pageId\n        })\n      })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "Existing tab",
            "suites": [
                "Browser API Wapper",
                "openUrl"
            ],
            "updatePoint": {
                "line": 649,
                "column": 20
            },
            "line": 649,
            "code": "    it('Existing tab', () => {\n      browser.tabs.query.returns(\n        Promise.resolve([\n          {\n            windowId: 10,\n            index: 1\n          }\n        ])\n      )\n      return openUrl(url).then(() => {\n        expect(browser.tabs.query.calledWith({ url })).toBeTruthy()\n        expect(\n          browser.tabs.highlight.calledWith({ tabs: 1, windowId: 10 })\n        ).toBeTruthy()\n        expect(browser.tabs.create.notCalled).toBeTruthy()\n      })\n    })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "New tab",
            "suites": [
                "Browser API Wapper",
                "openUrl"
            ],
            "updatePoint": {
                "line": 666,
                "column": 15
            },
            "line": 666,
            "code": "    it('New tab', () => {\n      browser.tabs.query.returns(Promise.resolve([]))\n      return openUrl(url).then(() => {\n        expect(browser.tabs.query.calledWith({ url })).toBeTruthy()\n        expect(browser.tabs.highlight.notCalled).toBeTruthy()\n        expect(\n          browser.tabs.create.calledWith(sinon.match({ url }))\n        ).toBeTruthy()\n      })\n    })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "Concat extension base url",
            "suites": [
                "Browser API Wapper",
                "openUrl"
            ],
            "updatePoint": {
                "line": 676,
                "column": 33
            },
            "line": 676,
            "code": "    it('Concat extension base url', () => {\n      browser.tabs.query.returns(Promise.resolve([]))\n      browser.runtime.getURL.returns('test')\n      return openUrl(url, true).then(() => {\n        expect(browser.runtime.getURL.calledWith(url)).toBeTruthy()\n        expect(\n          browser.tabs.create.calledWith(sinon.match({ url: 'test' }))\n        ).toBeTruthy()\n      })\n    })",
            "file": "specs/_helpers/browser-api.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should convert chs to chz",
            "suites": [
                "Chs to Chz"
            ],
            "updatePoint": {
                "line": 4,
                "column": 31
            },
            "line": 4,
            "code": "  it('should convert chs to chz', () => {\n    expect(chsToChz('龙龟')).toBe('龍龜')\n  })",
            "file": "specs/_helpers/chs-to-chz.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "isContainChinese should return ture if text contains Chinese",
            "suites": [
                "Language Check"
            ],
            "updatePoint": {
                "line": 9,
                "column": 66
            },
            "line": 9,
            "code": "  it('isContainChinese should return ture if text contains Chinese', () => {\n    expect(isContainChinese('lo你ve.')).toBeTruthy()\n  })",
            "file": "specs/_helpers/lang-check.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "isContainChinese should return false if text does not contain Chinese",
            "suites": [
                "Language Check"
            ],
            "updatePoint": {
                "line": 12,
                "column": 75
            },
            "line": 12,
            "code": "  it('isContainChinese should return false if text does not contain Chinese', () => {\n    expect(isContainChinese('love.')).toBeFalsy()\n  })",
            "file": "specs/_helpers/lang-check.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "isContainEnglish should return ture if text contains English",
            "suites": [
                "Language Check"
            ],
            "updatePoint": {
                "line": 15,
                "column": 66
            },
            "line": 15,
            "code": "  it('isContainEnglish should return ture if text contains English', () => {\n    expect(isContainEnglish('lo你ve.')).toBeTruthy()\n  })",
            "file": "specs/_helpers/lang-check.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "isContainEnglish should return ture if text does not contain English",
            "suites": [
                "Language Check"
            ],
            "updatePoint": {
                "line": 18,
                "column": 74
            },
            "line": 18,
            "code": "  it('isContainEnglish should return ture if text does not contain English', () => {\n    expect(isContainEnglish('你.')).toBeFalsy()\n  })",
            "file": "specs/_helpers/lang-check.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return false with all meaningless characters",
            "suites": [
                "Language Check",
                "Check supported languages",
                "with matchAll on"
            ],
            "updatePoint": {
                "line": 52,
                "column": 61
            },
            "line": 52,
            "code": "      it('should return false with all meaningless characters', () => {\n        expect(tl('。「')).toBe(false)\n        expect(tl('。「', 'chinese')).toBe(false)\n        expect(tl('。「', 'english')).toBe(false)\n        expect(tl('。「', 'others')).toBe(false)\n        expect(tl('1234')).toBe(false)\n        expect(tl('1234', 'chinese')).toBe(false)\n        expect(tl('1234', 'others')).toBe(false)\n      })",
            "file": "specs/_helpers/lang-check.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should work with CJK",
            "suites": [
                "Language Check",
                "Check supported languages",
                "with matchAll on"
            ],
            "updatePoint": {
                "line": 62,
                "column": 30
            },
            "line": 62,
            "code": "      it('should work with CJK', () => {\n        expect(tl('你好', 'chinese')).toBe(true)\n        expect(tl('コイル', 'japanese')).toBe(true)\n        expect(tl('你好', 'japanese')).toBe(false)\n\n        expect(tl('你好電脳コイル', 'chinese')).toBe(false)\n        expect(tl('你好電脳コイル', 'japanese')).toBe(false)\n        expect(tl('你好電脳コイル', 'chinese', 'japanese')).toBe(true)\n\n        expect(tl('你好 電脳コイル。', 'chinese', 'japanese')).toBe(false)\n        expect(tl('你好電脳コイル。', 'chinese', 'japanese', 'others')).toBe(\n          true\n        )\n\n        expect(tl('你好 電脳コイル❤️', 'chinese', 'japanese')).toBe(false)\n        expect(tl('你好電脳コイル❤️', 'chinese', 'japanese', 'others')).toBe(\n          true\n        )\n      })",
            "file": "specs/_helpers/lang-check.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should work with Latins",
            "suites": [
                "Language Check",
                "Check supported languages",
                "with matchAll on"
            ],
            "updatePoint": {
                "line": 82,
                "column": 33
            },
            "line": 82,
            "code": "      it('should work with Latins', () => {\n        expect(tl('Love you', 'english')).toBe(true)\n        expect(tl('é', 'french')).toBe(true)\n        expect(tl('Love you', 'french')).toBe(false)\n\n        expect(tl('bon appétit', 'english')).toBe(false)\n        expect(tl('bon appétit', 'french')).toBe(false)\n        expect(tl('bon appétit', 'english', 'french')).toBe(true)\n\n        expect(tl('bon appétit?', 'english', 'french')).toBe(false)\n        expect(tl('bon appétit?', 'english', 'french', 'others')).toBe(true)\n\n        expect(tl('bon appétit❤️', 'english', 'french')).toBe(false)\n        expect(tl('bon appétit❤️', 'english', 'french', 'others')).toBe(true)\n      })",
            "file": "specs/_helpers/lang-check.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return false with all meaningless characters",
            "suites": [
                "Language Check",
                "Check supported languages",
                "with matchAll off"
            ],
            "updatePoint": {
                "line": 102,
                "column": 61
            },
            "line": 102,
            "code": "      it('should return false with all meaningless characters', () => {\n        expect(tl('。「')).toBe(false)\n        expect(tl('。「', 'chinese')).toBe(false)\n        expect(tl('。「', 'english')).toBe(false)\n        expect(tl('。「', 'others')).toBe(false)\n        expect(tl('1')).toBe(false)\n        expect(tl('1', 'english')).toBe(false)\n        expect(tl('1', 'others')).toBe(false)\n      })",
            "file": "specs/_helpers/lang-check.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should work with CJK",
            "suites": [
                "Language Check",
                "Check supported languages",
                "with matchAll off"
            ],
            "updatePoint": {
                "line": 112,
                "column": 30
            },
            "line": 112,
            "code": "      it('should work with CJK', () => {\n        expect(tl('你好', 'chinese')).toBe(true)\n        expect(tl('コイル', 'japanese')).toBe(true)\n        expect(tl('你好', 'japanese')).toBe(false)\n\n        expect(tl('你好電脳コイル', 'chinese')).toBe(true)\n        expect(tl('你好電脳コイル', 'japanese')).toBe(true)\n        expect(tl('你好電脳コイル', 'chinese', 'japanese')).toBe(true)\n\n        expect(tl('你好 電脳コイル。', 'chinese', 'japanese')).toBe(true)\n        expect(tl('你好電脳コイル。', 'chinese', 'japanese', 'others')).toBe(\n          true\n        )\n\n        expect(tl('你好 電脳コイル❤️。', 'chinese', 'japanese')).toBe(true)\n        expect(tl('你好電脳コイル❤️。', 'chinese', 'japanese', 'others')).toBe(\n          true\n        )\n        expect(tl('❤️', 'others')).toBe(true)\n        expect(tl('你好電脳コイル❤️。', 'others')).toBe(true)\n        expect(tl('你好電脳コイル。', 'others')).toBe(false)\n      })",
            "file": "specs/_helpers/lang-check.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should work with Latins",
            "suites": [
                "Language Check",
                "Check supported languages",
                "with matchAll off"
            ],
            "updatePoint": {
                "line": 135,
                "column": 33
            },
            "line": 135,
            "code": "      it('should work with Latins', () => {\n        expect(tl('Love you', 'english')).toBe(true)\n        expect(tl('é', 'french')).toBe(true)\n        expect(tl('Love you', 'french')).toBe(false)\n\n        expect(tl('bon appétit', 'english')).toBe(true)\n        expect(tl('bon appétit', 'french')).toBe(true)\n        expect(tl('bon appétit', 'english', 'french')).toBe(true)\n\n        expect(tl('bon appétit?', 'english', 'french')).toBe(true)\n        expect(tl('bon appétit?', 'english', 'french', 'others')).toBe(true)\n\n        expect(tl('❤️', 'english', 'french')).toBe(false)\n        expect(tl('❤️', 'others')).toBe(true)\n        expect(tl('bon appétit❤️', 'english', 'french')).toBe(true)\n        expect(tl('bon appétit❤️', 'english', 'french', 'others')).toBe(true)\n      })",
            "file": "specs/_helpers/lang-check.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should init with default profile the first time",
            "suites": [
                "Profile Manager"
            ],
            "updatePoint": {
                "line": 31,
                "column": 53
            },
            "line": 31,
            "code": "  it('should init with default profile the first time', async () => {\n    fakeStorageGet({})\n\n    const profile = await profileManager.initProfiles()\n    expect(typeof profile).toBe('object')\n    expect(\n      browser.storage.sync.set.calledWith(\n        sinon.match({\n          profileIDList: sinon.match.array,\n          activeProfileID: sinon.match.string\n        })\n      )\n    ).toBeTruthy()\n  })",
            "file": "specs/_helpers/profile-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should keep existing profiles when init",
            "suites": [
                "Profile Manager"
            ],
            "updatePoint": {
                "line": 46,
                "column": 45
            },
            "line": 46,
            "code": "  it('should keep existing profiles when init', async () => {\n    const id1 = getDefaultProfileID()\n    const id2 = getDefaultProfileID()\n    const profile1 = getDefaultProfile(id1.id)\n    const profile2 = getDefaultProfile(id2.id)\n    const deflatedProfile1 = profileManager.deflate(profile1)\n    const deflatedProfile2 = profileManager.deflate(profile2)\n    fakeStorageGet({\n      profileIDList: [id1, id2],\n      activeProfileID: profile2.id,\n      [profile1.id]: deflatedProfile1,\n      [profile2.id]: deflatedProfile2\n    })\n\n    const profile = await profileManager.initProfiles()\n    expect(profile).toEqual(profile2)\n    expect(\n      browser.storage.sync.set.calledWith(\n        sinon.match({\n          profileIDList: [id1, id2],\n          activeProfileID: profile2.id\n        })\n      )\n    ).toBeTruthy()\n    expect(\n      browser.storage.sync.set.calledWith(\n        sinon.match({\n          [profile1.id]: deflatedProfile1\n        })\n      )\n    ).toBeTruthy()\n    expect(\n      browser.storage.sync.set.calledWith(\n        sinon.match({\n          [profile2.id]: deflatedProfile2\n        })\n      )\n    ).toBeTruthy()\n  })",
            "file": "specs/_helpers/profile-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should remove detached keys when init",
            "suites": [
                "Profile Manager"
            ],
            "updatePoint": {
                "line": 86,
                "column": 43
            },
            "line": 86,
            "code": "  it('should remove detached keys when init', async () => {\n    const id1 = getDefaultProfileID()\n    const id2 = getDefaultProfileID()\n    const profile1 = getDefaultProfile(id1.id)\n    const profile2 = getDefaultProfile(id2.id)\n    const detached1 = getDefaultProfile()\n    const detached2 = getDefaultProfile()\n    fakeStorageGet({\n      profileIDList: [id1, id2],\n      activeProfileID: profile2.id,\n      [profile1.id]: profileManager.deflate(profile1),\n      [profile2.id]: profileManager.deflate(profile2),\n      [detached1.id]: detached1,\n      [detached2.id]: detached2\n    })\n\n    const profile = await profileManager.initProfiles()\n    expect(profile).toEqual(profile2)\n    expect(\n      browser.storage.sync.set.calledWith(\n        sinon.match({\n          profileIDList: [id1, id2],\n          activeProfileID: profile2.id\n        })\n      )\n    ).toBeTruthy()\n  })",
            "file": "specs/_helpers/profile-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should reset to default profile",
            "suites": [
                "Profile Manager"
            ],
            "updatePoint": {
                "line": 114,
                "column": 37
            },
            "line": 114,
            "code": "  it('should reset to default profile', async () => {\n    const id1 = getDefaultProfileID()\n    const id2 = getDefaultProfileID()\n    const profile1 = getDefaultProfile(id1.id)\n    const profile2 = getDefaultProfile(id2.id)\n    fakeStorageGet({\n      profileIDList: [id1, id2],\n      activeProfileID: profile2.id,\n      [profile1.id]: profileManager.deflate(profile1),\n      [profile2.id]: profileManager.deflate(profile2)\n    })\n\n    await profileManager.resetAllProfiles()\n    expect(\n      browser.storage.sync.remove.calledWith(\n        sinon.match([\n          profile1.id,\n          profile2.id,\n          'profileIDList',\n          'activeProfileID',\n          'configProfileIDs',\n          'activeConfigID'\n        ])\n      )\n    ).toBeTruthy()\n    expect(\n      browser.storage.sync.set.calledWith(\n        sinon.match({\n          profileIDList: sinon.match.array,\n          activeProfileID: sinon.match.string\n        })\n      )\n    ).toBeTruthy()\n  })",
            "file": "specs/_helpers/profile-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should add profile",
            "suites": [
                "Profile Manager"
            ],
            "updatePoint": {
                "line": 149,
                "column": 24
            },
            "line": 149,
            "code": "  it('should add profile', async () => {\n    const id1 = getDefaultProfileID()\n    const id2 = getDefaultProfileID()\n    const profile1 = getDefaultProfile(id1.id)\n    const profile2 = getDefaultProfile(id2.id)\n    fakeStorageGet({\n      profileIDList: [id1, id2],\n      activeProfileID: profile2.id,\n      [profile1.id]: profileManager.deflate(profile1),\n      [profile2.id]: profileManager.deflate(profile2)\n    })\n\n    const id3 = getDefaultProfileID()\n    await profileManager.addProfile(id3)\n    expect(\n      browser.storage.sync.set.calledWith({\n        profileIDList: [id1, id2, id3],\n        [id3.id]: sinon.match.object\n      })\n    ).toBeTruthy()\n  })",
            "file": "specs/_helpers/profile-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should remove profile",
            "suites": [
                "Profile Manager"
            ],
            "updatePoint": {
                "line": 171,
                "column": 27
            },
            "line": 171,
            "code": "  it('should remove profile', async () => {\n    const id1 = getDefaultProfileID()\n    const id2 = getDefaultProfileID()\n    const profile1 = getDefaultProfile(id1.id)\n    const profile2 = getDefaultProfile(id2.id)\n    fakeStorageGet({\n      profileIDList: [id1, id2],\n      activeProfileID: profile2.id,\n      [profile1.id]: profileManager.deflate(profile1),\n      [profile2.id]: profileManager.deflate(profile2)\n    })\n\n    await profileManager.removeProfile(profile1.id)\n    expect(browser.storage.sync.remove.calledWith(profile1.id)).toBeTruthy()\n    expect(\n      browser.storage.sync.set.calledWith({\n        profileIDList: [id2]\n      })\n    ).toBeTruthy()\n  })",
            "file": "specs/_helpers/profile-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should get active profile",
            "suites": [
                "Profile Manager"
            ],
            "updatePoint": {
                "line": 192,
                "column": 31
            },
            "line": 192,
            "code": "  it('should get active profile', async () => {\n    const id1 = getDefaultProfileID()\n    const id2 = getDefaultProfileID()\n    const profile1 = getDefaultProfile(id1.id)\n    const profile2 = getDefaultProfile(id2.id)\n    fakeStorageGet({\n      profileIDList: [id1, id2],\n      activeProfileID: profile2.id,\n      [profile1.id]: profileManager.deflate(profile1),\n      [profile2.id]: profileManager.deflate(profile2)\n    })\n\n    expect((await profileManager.getActiveProfile()).id).toBe(profile2.id)\n  })",
            "file": "specs/_helpers/profile-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should update profile ID list",
            "suites": [
                "Profile Manager"
            ],
            "updatePoint": {
                "line": 207,
                "column": 35
            },
            "line": 207,
            "code": "  it('should update profile ID list', async () => {\n    const id1 = getDefaultProfileID()\n    const id2 = getDefaultProfileID()\n    await profileManager.updateProfileIDList([id2, id1])\n    expect(\n      browser.storage.sync.set.calledWith({\n        profileIDList: [id2, id1]\n      })\n    ).toBeTruthy()\n  })",
            "file": "specs/_helpers/profile-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should update active profile ID",
            "suites": [
                "Profile Manager"
            ],
            "updatePoint": {
                "line": 218,
                "column": 37
            },
            "line": 218,
            "code": "  it('should update active profile ID', async () => {\n    const id1 = getDefaultProfileID()\n    await profileManager.updateActiveProfileID(id1.id)\n    expect(\n      browser.storage.sync.set.calledWith({\n        activeProfileID: id1.id\n      })\n    ).toBeTruthy()\n  })",
            "file": "specs/_helpers/profile-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should update active profile",
            "suites": [
                "Profile Manager"
            ],
            "updatePoint": {
                "line": 228,
                "column": 34
            },
            "line": 228,
            "code": "  it('should update active profile', async () => {\n    const profile = getDefaultProfile()\n    await profileManager.updateProfile(profile)\n    expect(\n      browser.storage.sync.set.calledWith({\n        [profile.id]: sinon.match(profileManager.deflate(profile))\n      })\n    ).toBeTruthy()\n  })",
            "file": "specs/_helpers/profile-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should add storage event listener",
            "suites": [
                "Profile Manager",
                "add active profile listener"
            ],
            "updatePoint": {
                "line": 258,
                "column": 41
            },
            "line": 258,
            "code": "    it('should add storage event listener', () => {\n      expect(browser.storage.onChanged.addListener.calledOnce).toBeTruthy()\n    })",
            "file": "specs/_helpers/profile-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should fire if active profile has changed",
            "suites": [
                "Profile Manager",
                "add active profile listener"
            ],
            "updatePoint": {
                "line": 262,
                "column": 49
            },
            "line": 262,
            "code": "    it('should fire if active profile has changed', async () => {\n      const newProfile2: Profile = {\n        ...profile2,\n        mtaAutoUnfold: 'popup'\n      }\n      browser.storage.onChanged.dispatch(\n        {\n          [profile2.id]: {\n            newValue: newProfile2,\n            oldValue: profile2\n          }\n        },\n        'sync'\n      )\n      await timer(0)\n      expect(callback).toBeCalledWith({\n        newProfile: newProfile2,\n        oldProfile: profile2\n      })\n    })",
            "file": "specs/_helpers/profile-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not fire if active profile has not changed",
            "suites": [
                "Profile Manager",
                "add active profile listener"
            ],
            "updatePoint": {
                "line": 283,
                "column": 57
            },
            "line": 283,
            "code": "    it('should not fire if active profile has not changed', async () => {\n      browser.storage.onChanged.dispatch(\n        {\n          [profile1.id]: {\n            newValue: {\n              ...profile1,\n              mtaAutoUnfold: 'popup'\n            },\n            oldValue: profile1\n          }\n        },\n        'sync'\n      )\n      await timer(0)\n      expect(callback).toHaveBeenCalledTimes(0)\n    })",
            "file": "specs/_helpers/profile-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should fire if active profile ID has changed",
            "suites": [
                "Profile Manager",
                "add active profile listener"
            ],
            "updatePoint": {
                "line": 300,
                "column": 52
            },
            "line": 300,
            "code": "    it('should fire if active profile ID has changed', async () => {\n      browser.storage.onChanged.dispatch(\n        {\n          activeProfileID: {\n            newValue: profile1.id\n          }\n        },\n        'sync'\n      )\n      await timer(0)\n      expect(callback).toBeCalledWith({\n        newProfile: profile1\n      })\n    })",
            "file": "specs/_helpers/profile-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should fire if active profile ID has changed (with last ID)",
            "suites": [
                "Profile Manager",
                "add active profile listener"
            ],
            "updatePoint": {
                "line": 315,
                "column": 67
            },
            "line": 315,
            "code": "    it('should fire if active profile ID has changed (with last ID)', async () => {\n      browser.storage.onChanged.dispatch(\n        {\n          activeProfileID: {\n            newValue: profile1.id,\n            oldValue: profile2.id\n          }\n        },\n        'sync'\n      )\n      await timer(0)\n      expect(callback).toBeCalledWith({\n        newProfile: profile1,\n        oldProfile: profile2\n      })\n    })",
            "file": "specs/_helpers/profile-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should create active profile stream",
            "suites": [
                "Profile Manager",
                "add active profile listener"
            ],
            "updatePoint": {
                "line": 333,
                "column": 41
            },
            "line": 333,
            "code": "  it('should create active profile stream', async () => {\n    const id1 = getDefaultProfileID()\n    const id2 = getDefaultProfileID()\n    const profile1 = getDefaultProfile(id1.id)\n    const profile2 = getDefaultProfile(id2.id)\n    fakeStorageGet({\n      profileIDList: [id1, id2],\n      activeProfileID: profile2.id,\n      [profile1.id]: profileManager.deflate(profile1),\n      [profile2.id]: profileManager.deflate(profile2)\n    })\n    const subscriber = jest.fn()\n\n    profileManager.createActiveProfileStream().subscribe(subscriber)\n    await timer(0)\n    expect(subscriber).toBeCalledWith(profile2)\n\n    browser.storage.onChanged.dispatch(\n      {\n        activeProfileID: {\n          newValue: profile1.id,\n          oldValue: profile2.id\n        }\n      },\n      'sync'\n    )\n    await timer(0)\n    expect(subscriber).toBeCalledWith(profile1)\n  })",
            "file": "specs/_helpers/profile-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "All resolved",
            "suites": [
                "Promise More",
                "reflect"
            ],
            "updatePoint": {
                "line": 12,
                "column": 20
            },
            "line": 12,
            "code": "    it('All resolved', () => {\n      const resolveSpy = jest.fn()\n      const rejectSpy = jest.fn()\n      const catchSpy = jest.fn()\n      return pm\n        .reflect([1, 2, 3])\n        .then(resolveSpy, rejectSpy)\n        .catch(catchSpy)\n        .then(() => {\n          expect(resolveSpy).toBeCalledWith([1, 2, 3])\n          expect(rejectSpy).not.toBeCalled()\n          expect(catchSpy).not.toBeCalled()\n        })\n    })",
            "file": "specs/_helpers/promise-more.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "Partly rejected",
            "suites": [
                "Promise More",
                "reflect"
            ],
            "updatePoint": {
                "line": 26,
                "column": 23
            },
            "line": 26,
            "code": "    it('Partly rejected', () => {\n      const resolveSpy = jest.fn()\n      const rejectSpy = jest.fn()\n      const catchSpy = jest.fn()\n      return pm\n        .reflect([1, 2, Promise.reject(null)])\n        .then(resolveSpy, rejectSpy)\n        .catch(catchSpy)\n        .then(() => {\n          expect(resolveSpy).toBeCalledWith([1, 2, null])\n          expect(rejectSpy).not.toBeCalled()\n          expect(catchSpy).not.toBeCalled()\n        })\n    })",
            "file": "specs/_helpers/promise-more.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "All rejected",
            "suites": [
                "Promise More",
                "reflect"
            ],
            "updatePoint": {
                "line": 40,
                "column": 20
            },
            "line": 40,
            "code": "    it('All rejected', () => {\n      const resolveSpy = jest.fn()\n      const rejectSpy = jest.fn()\n      const catchSpy = jest.fn()\n      return pm\n        .reflect([\n          Promise.reject(null),\n          Promise.reject(null),\n          Promise.reject(null)\n        ])\n        .then(resolveSpy, rejectSpy)\n        .catch(catchSpy)\n        .then(() => {\n          expect(resolveSpy).toBeCalledWith([null, null, null])\n          expect(rejectSpy).not.toBeCalled()\n          expect(catchSpy).not.toBeCalled()\n        })\n    })",
            "file": "specs/_helpers/promise-more.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "All resolved",
            "suites": [
                "Promise More",
                "any"
            ],
            "updatePoint": {
                "line": 61,
                "column": 20
            },
            "line": 61,
            "code": "    it('All resolved', () => {\n      const resolveSpy = jest.fn()\n      const rejectSpy = jest.fn()\n      const catchSpy = jest.fn()\n      return pm\n        .any([1, 2, 3])\n        .then(resolveSpy, rejectSpy)\n        .catch(catchSpy)\n        .then(() => {\n          expect(resolveSpy).toBeCalledWith([1, 2, 3])\n          expect(rejectSpy).not.toBeCalled()\n          expect(catchSpy).not.toBeCalled()\n        })\n    })",
            "file": "specs/_helpers/promise-more.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "Partly rejected",
            "suites": [
                "Promise More",
                "any"
            ],
            "updatePoint": {
                "line": 75,
                "column": 23
            },
            "line": 75,
            "code": "    it('Partly rejected', () => {\n      const resolveSpy = jest.fn()\n      const rejectSpy = jest.fn()\n      const catchSpy = jest.fn()\n      return pm\n        .any([1, 2, Promise.reject(null)])\n        .then(resolveSpy, rejectSpy)\n        .catch(catchSpy)\n        .then(() => {\n          expect(resolveSpy).toBeCalledWith([1, 2, null])\n          expect(rejectSpy).not.toBeCalled()\n          expect(catchSpy).not.toBeCalled()\n        })\n    })",
            "file": "specs/_helpers/promise-more.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "All rejected",
            "suites": [
                "Promise More",
                "any"
            ],
            "updatePoint": {
                "line": 89,
                "column": 20
            },
            "line": 89,
            "code": "    it('All rejected', () => {\n      const resolveSpy = jest.fn()\n      const rejectSpy = jest.fn()\n      const catchSpy = jest.fn()\n      return pm\n        .any([Promise.reject(null), Promise.reject(null), Promise.reject(null)])\n        .then(resolveSpy, rejectSpy)\n        .catch(catchSpy)\n        .then(() => {\n          expect(resolveSpy).not.toBeCalled()\n          expect(rejectSpy).toBeCalledWith(expect.any(Error))\n          expect(catchSpy).not.toBeCalled()\n        })\n    })",
            "file": "specs/_helpers/promise-more.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "All resolved",
            "suites": [
                "Promise More",
                "first"
            ],
            "updatePoint": {
                "line": 106,
                "column": 20
            },
            "line": 106,
            "code": "    it('All resolved', () => {\n      const resolveSpy = jest.fn()\n      const rejectSpy = jest.fn()\n      const catchSpy = jest.fn()\n      return pm\n        .first([1, 2, 3])\n        .then(resolveSpy, rejectSpy)\n        .catch(catchSpy)\n        .then(() => {\n          expect(resolveSpy).toBeCalledWith(1)\n          expect(rejectSpy).not.toBeCalled()\n          expect(catchSpy).not.toBeCalled()\n        })\n    })",
            "file": "specs/_helpers/promise-more.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "Partly rejected",
            "suites": [
                "Promise More",
                "first"
            ],
            "updatePoint": {
                "line": 120,
                "column": 23
            },
            "line": 120,
            "code": "    it('Partly rejected', () => {\n      const resolveSpy = jest.fn()\n      const rejectSpy = jest.fn()\n      const catchSpy = jest.fn()\n      return pm\n        .first([Promise.reject(null), 2, 3])\n        .then(resolveSpy, rejectSpy)\n        .catch(catchSpy)\n        .then(() => {\n          expect(resolveSpy).toBeCalledWith(2)\n          expect(rejectSpy).not.toBeCalled()\n          expect(catchSpy).not.toBeCalled()\n        })\n    })",
            "file": "specs/_helpers/promise-more.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "All rejected",
            "suites": [
                "Promise More",
                "first"
            ],
            "updatePoint": {
                "line": 134,
                "column": 20
            },
            "line": 134,
            "code": "    it('All rejected', () => {\n      const resolveSpy = jest.fn()\n      const rejectSpy = jest.fn()\n      const catchSpy = jest.fn()\n      return pm\n        .first([\n          Promise.reject(null),\n          Promise.reject(null),\n          Promise.reject(null)\n        ])\n        .then(resolveSpy, rejectSpy)\n        .catch(catchSpy)\n        .then(() => {\n          expect(resolveSpy).not.toBeCalled()\n          expect(rejectSpy).toBeCalledWith(expect.any(Error))\n          expect(catchSpy).not.toBeCalled()\n        })\n    })",
            "file": "specs/_helpers/promise-more.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "timer",
            "suites": [
                "Promise More",
                "first"
            ],
            "updatePoint": {
                "line": 154,
                "column": 11
            },
            "line": 154,
            "code": "  it('timer', () => {\n    const resolveSpy = jest.fn()\n    const rejectSpy = jest.fn()\n    const catchSpy = jest.fn()\n\n    const p = pm\n      .timer(10)\n      .then(resolveSpy, rejectSpy)\n      .catch(catchSpy)\n\n    expect(setTimeout).toBeCalledWith(expect.any(Function), 10)\n    jest.runAllTimers()\n    return p.then(() => {\n      expect(resolveSpy).toHaveBeenCalledTimes(1)\n      expect(rejectSpy).not.toBeCalled()\n      expect(catchSpy).not.toBeCalled()\n    })\n  })",
            "file": "specs/_helpers/promise-more.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "Finish before Timeout",
            "suites": [
                "Promise More",
                "timeout"
            ],
            "updatePoint": {
                "line": 174,
                "column": 29
            },
            "line": 174,
            "code": "    it('Finish before Timeout', () => {\n      const resolveSpy = jest.fn()\n      const rejectSpy = jest.fn()\n      const catchSpy = jest.fn()\n\n      const job = new Promise((resolve, reject) => {\n        setTimeout(() => resolve('job'), 10)\n      })\n\n      const p = pm\n        .timeout(job, 100)\n        .then(resolveSpy, rejectSpy)\n        .catch(catchSpy)\n\n      expect(setTimeout).toBeCalledWith(expect.any(Function), 100)\n      jest.runAllTimers()\n      return p.then(() => {\n        expect(resolveSpy).toHaveBeenCalledTimes(1)\n        expect(resolveSpy).toBeCalledWith('job')\n        expect(rejectSpy).not.toBeCalled()\n        expect(catchSpy).not.toBeCalled()\n      })\n    })",
            "file": "specs/_helpers/promise-more.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "load",
            "suites": [
                "Audio Manager"
            ],
            "updatePoint": {
                "line": 29,
                "column": 10
            },
            "line": 29,
            "code": "  it('load', () => {\n    const url = 'https://e.a/load.mp3'\n    expect(audioManager.load(url)).toBe(mockAudioInstances[0])\n    expect(mockAudio).toBeCalledWith(url)\n  })",
            "file": "specs/background/audio-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "play",
            "suites": [
                "Audio Manager"
            ],
            "updatePoint": {
                "line": 35,
                "column": 10
            },
            "line": 35,
            "code": "  it('play', () => {\n    const url = 'https://e.b/play.mp3'\n    expect(audioManager.play(url)).toBeInstanceOf(Promise)\n    expect(mockAudio).toBeCalledWith(url)\n    expect(mockAudioInstances.length).toBe(1)\n    expect(mockAudioInstances[0].play).toHaveBeenCalledTimes(1)\n  })",
            "file": "specs/background/audio-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "play x 2 interrupted",
            "suites": [
                "Audio Manager"
            ],
            "updatePoint": {
                "line": 43,
                "column": 26
            },
            "line": 43,
            "code": "  it('play x 2 interrupted', () => {\n    const url1 = 'https://e.b/play1.mp3'\n    const url2 = 'https://e.b/play2.mp3'\n    expect(audioManager.load(url1)).toBe(mockAudioInstances[0])\n    expect(mockAudio).toBeCalledWith(url1)\n    expect(audioManager.play(url2)).toBeInstanceOf(Promise)\n    expect(mockAudio).toBeCalledWith(url2)\n    expect(mockAudioInstances.length).toBe(2)\n    expect(mockAudioInstances[0].play).toHaveBeenCalledTimes(0)\n    expect(mockAudioInstances[0].pause).toHaveBeenCalledTimes(1)\n    expect(mockAudioInstances[1].play).toHaveBeenCalledTimes(1)\n    expect(mockAudioInstances[1].pause).toHaveBeenCalledTimes(0)\n  })",
            "file": "specs/background/audio-manager.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "init",
            "suites": [
                "Context Menus",
                "Context Menus Click"
            ],
            "updatePoint": {
                "line": 48,
                "column": 12
            },
            "line": 48,
            "code": "    it('init', () => {\n      expect(browser.contextMenus.onClicked.addListener.calledOnce).toBeTruthy()\n    })",
            "file": "specs/background/context-menus.spec.ts",
            "skipped": true,
            "dir": "test"
        },
        {
            "name": "google_page_translate",
            "suites": [
                "Context Menus",
                "Context Menus Click"
            ],
            "updatePoint": {
                "line": 52,
                "column": 29
            },
            "line": 52,
            "code": "    it('google_page_translate', async () => {\n      browser.tabs.executeScript.flush()\n      browser.tabs.executeScript.callsFake(() => Promise.resolve())\n      browser.contextMenus.onClicked.dispatch({\n        menuItemId: 'google_page_translate'\n      })\n      expect(browser.tabs.executeScript.calledOnce).toBeTruthy()\n    })",
            "file": "specs/background/context-menus.spec.ts",
            "skipped": true,
            "dir": "test"
        },
        {
            "name": "youdao_page_translate",
            "suites": [
                "Context Menus",
                "Context Menus Click"
            ],
            "updatePoint": {
                "line": 60,
                "column": 29
            },
            "line": 60,
            "code": "    it('youdao_page_translate', () => {\n      browser.tabs.executeScript.flush()\n      browser.tabs.executeScript.callsFake(() => Promise.resolve())\n      browser.contextMenus.onClicked.dispatch({\n        menuItemId: 'youdao_page_translate'\n      })\n      expect(\n        browser.tabs.executeScript.calledWith({ file: sinon.match('youdao') })\n      ).toBeTruthy()\n    })",
            "file": "specs/background/context-menus.spec.ts",
            "skipped": true,
            "dir": "test"
        },
        {
            "name": "view_as_pdf",
            "suites": [
                "Context Menus",
                "Context Menus Click"
            ],
            "updatePoint": {
                "line": 70,
                "column": 19
            },
            "line": 70,
            "code": "    it('view_as_pdf', async () => {\n      browser.tabs.query.onFirstCall().returns(Promise.resolve([]))\n      browser.contextMenus.onClicked.dispatch({ menuItemId: 'view_as_pdf' })\n      await timer(0)\n      expect(openUrl).toHaveBeenCalledTimes(1)\n    })",
            "file": "specs/background/context-menus.spec.ts",
            "skipped": true,
            "dir": "test"
        },
        {
            "name": "search_history",
            "suites": [
                "Context Menus",
                "Context Menus Click"
            ],
            "updatePoint": {
                "line": 76,
                "column": 22
            },
            "line": 76,
            "code": "    it('search_history', async () => {\n      browser.tabs.query.onFirstCall().returns(Promise.resolve([]))\n      browser.contextMenus.onClicked.dispatch({ menuItemId: 'search_history' })\n      await timer(0)\n      expect(openUrl).toHaveBeenCalledTimes(1)\n      expect(openUrl).toBeCalledWith(expect.stringContaining('history'))\n    })",
            "file": "specs/background/context-menus.spec.ts",
            "skipped": true,
            "dir": "test"
        },
        {
            "name": "notebook",
            "suites": [
                "Context Menus",
                "Context Menus Click"
            ],
            "updatePoint": {
                "line": 83,
                "column": 16
            },
            "line": 83,
            "code": "    it('notebook', async () => {\n      browser.tabs.query.onFirstCall().returns(Promise.resolve([]))\n      browser.contextMenus.onClicked.dispatch({ menuItemId: 'notebook' })\n      await timer(0)\n      expect(openUrl).toHaveBeenCalledTimes(1)\n      expect(openUrl).toBeCalledWith(expect.stringContaining('notebook'))\n    })",
            "file": "specs/background/context-menus.spec.ts",
            "skipped": true,
            "dir": "test"
        },
        {
            "name": "default",
            "suites": [
                "Context Menus",
                "Context Menus Click"
            ],
            "updatePoint": {
                "line": 90,
                "column": 15
            },
            "line": 90,
            "code": "    it('default', async () => {\n      browser.tabs.query.onFirstCall().returns(Promise.resolve([]))\n      browser.contextMenus.onClicked.dispatch({ menuItemId: 'bing_dict' })\n      await timer(0)\n      expect(openUrl).toHaveBeenCalledTimes(1)\n      expect(openUrl).toBeCalledWith(expect.stringContaining('bing'))\n    })",
            "file": "specs/background/context-menus.spec.ts",
            "skipped": true,
            "dir": "test"
        },
        {
            "name": "should set menus on init",
            "suites": [
                "Context Menus",
                "initListener"
            ],
            "updatePoint": {
                "line": 113,
                "column": 32
            },
            "line": 113,
            "code": "    it('should set menus on init', done => {\n      const { init } = require('@/background/context-menus')\n      take(1)(init(config.contextMenus)).subscribe(() => {\n        expect(browser.contextMenus.removeAll.calledOnce).toBeTruthy()\n        expect(\n          browser.contextMenus.create.calledWithMatch(\n            { id: 'youdao' },\n            sinon.match.func\n          )\n        ).toBeTruthy()\n        expect(\n          browser.contextMenus.create.calledWithMatch(\n            { id: 'dictcn' },\n            sinon.match.func\n          )\n        ).toBeTruthy()\n        done()\n      })\n    })",
            "file": "specs/background/context-menus.spec.ts",
            "skipped": true,
            "dir": "test"
        },
        {
            "name": "should not init setup when called multiple times",
            "suites": [
                "Context Menus",
                "initListener"
            ],
            "updatePoint": {
                "line": 133,
                "column": 56
            },
            "line": 133,
            "code": "    it('should not init setup when called multiple times', done => {\n      const { init } = require('@/background/context-menus')\n      take(1)(init(config.contextMenus)).subscribe(() => {\n        expect(browser.contextMenus.removeAll.calledOnce).toBeTruthy()\n\n        const setMenus2$$ = init(config.contextMenus)\n        const setMenus3$$ = init(config.contextMenus)\n\n        expect(browser.contextMenus.removeAll.calledOnce).toBeTruthy()\n        expect(setMenus2$$).toBe(setMenus3$$)\n\n        done()\n      })\n    })",
            "file": "specs/background/context-menus.spec.ts",
            "skipped": true,
            "dir": "test"
        },
        {
            "name": "should do nothing when contex menus config didn't change",
            "suites": [
                "Context Menus",
                "initListener"
            ],
            "updatePoint": {
                "line": 148,
                "column": 64
            },
            "line": 148,
            "code": "    it(\"should do nothing when contex menus config didn't change\", done => {\n      const newConfig = specialConfig()\n      newConfig.active = !newConfig.active\n\n      const { init } = require('@/background/context-menus')\n      take(1)(init(config.contextMenus)).subscribe(() => {\n        expect(browser.contextMenus.removeAll.calledOnce).toBeTruthy()\n        configManager.dispatchConfigChangedEvent(newConfig, config)\n        setTimeout(() => {\n          expect(browser.contextMenus.removeAll.calledOnce).toBeTruthy()\n          done()\n        }, 0)\n      })\n    })",
            "file": "specs/background/context-menus.spec.ts",
            "skipped": true,
            "dir": "test"
        },
        {
            "name": "should set menus at first time change",
            "suites": [
                "Context Menus",
                "initListener"
            ],
            "updatePoint": {
                "line": 163,
                "column": 45
            },
            "line": 163,
            "code": "    it('should set menus at first time change', done => {\n      const newConfig = specialConfig()\n      newConfig.contextMenus.selected.pop()\n\n      const { init } = require('@/background/context-menus')\n      take(1)(init(config.contextMenus)).subscribe(() => {\n        expect(browser.contextMenus.removeAll.calledOnce).toBeTruthy()\n        configManager.dispatchConfigChangedEvent(newConfig)\n        setTimeout(() => {\n          expect(browser.contextMenus.removeAll.calledTwice).toBeTruthy()\n          done()\n        }, 0)\n      })\n    })",
            "file": "specs/background/context-menus.spec.ts",
            "skipped": true,
            "dir": "test"
        },
        {
            "name": "should set menus when contex menus config changed",
            "suites": [
                "Context Menus",
                "initListener"
            ],
            "updatePoint": {
                "line": 178,
                "column": 57
            },
            "line": 178,
            "code": "    it('should set menus when contex menus config changed', done => {\n      const newConfig = specialConfig()\n      newConfig.contextMenus.selected.pop()\n\n      const { init } = require('@/background/context-menus')\n      take(1)(init(config.contextMenus)).subscribe(() => {\n        expect(browser.contextMenus.removeAll.calledOnce).toBeTruthy()\n        configManager.dispatchConfigChangedEvent(newConfig, config)\n        setTimeout(() => {\n          expect(browser.contextMenus.removeAll.calledTwice).toBeTruthy()\n          done()\n        }, 0)\n      })\n    })",
            "file": "specs/background/context-menus.spec.ts",
            "skipped": true,
            "dir": "test"
        },
        {
            "name": "should only set twice if source emits values during the first setting",
            "suites": [
                "Context Menus",
                "initListener"
            ],
            "updatePoint": {
                "line": 193,
                "column": 77
            },
            "line": 193,
            "code": "    it('should only set twice if source emits values during the first setting', done => {\n      const { init } = require('@/background/context-menus')\n      take(1)(init(config.contextMenus)).subscribe(() => {\n        expect(browser.contextMenus.removeAll.calledOnce).toBeTruthy()\n\n        const newConfig1 = specialConfig()\n        newConfig1.contextMenus.selected = ['bing_dict']\n\n        const newConfig2 = specialConfig()\n        newConfig2.contextMenus.selected = ['iciba']\n\n        const newConfig3 = specialConfig()\n        newConfig3.contextMenus.selected = ['oxford']\n\n        const newConfig4 = specialConfig()\n        newConfig4.contextMenus.selected = ['youdao']\n\n        configManager.dispatchConfigChangedEvent(newConfig1, config)\n        configManager.dispatchConfigChangedEvent(newConfig2, newConfig1)\n        configManager.dispatchConfigChangedEvent(newConfig3, newConfig2)\n        configManager.dispatchConfigChangedEvent(newConfig4, newConfig3)\n\n        setTimeout(() => {\n          expect(browser.contextMenus.removeAll.calledThrice).toBeTruthy()\n          expect(\n            browser.contextMenus.create.calledWithMatch(\n              { id: 'bing_dict' },\n              sinon.match.func\n            )\n          ).toBeTruthy()\n          expect(\n            browser.contextMenus.create.calledWithMatch(\n              { id: 'iciba' },\n              sinon.match.func\n            )\n          ).toBeFalsy()\n          expect(\n            browser.contextMenus.create.calledWithMatch(\n              { id: 'oxford' },\n              sinon.match.func\n            )\n          ).toBeFalsy()\n          expect(\n            browser.contextMenus.create.calledWithMatch(\n              { id: 'youdao' },\n              sinon.match.func\n            )\n          ).toBeTruthy()\n          done()\n        }, 0)\n      })\n    })",
            "file": "specs/background/context-menus.spec.ts",
            "skipped": true,
            "dir": "test"
        },
        {
            "name": "should properly set up",
            "suites": [
                "Initialization"
            ],
            "updatePoint": {
                "line": 92,
                "column": 28
            },
            "line": 92,
            "code": "  it('should properly set up', async () => {\n    await timer(0)\n    expect(browser.runtime.onInstalled.addListener.calledOnce).toBeTruthy()\n    expect(browser.runtime.onStartup.addListener.calledOnce).toBeTruthy()\n    expect(browser.notifications.onClicked.addListener.calledOnce).toBeTruthy()\n    expect(\n      browser.notifications.onButtonClicked.addListener.calledOnce\n    ).toBeTruthy()\n    expect(initMenus).toHaveBeenCalledTimes(0)\n    expect(initPdf).toHaveBeenCalledTimes(0)\n  })",
            "file": "specs/background/initialization.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not check update if last check was just now",
            "suites": [
                "Initialization",
                "onStartup"
            ],
            "updatePoint": {
                "line": 110,
                "column": 58
            },
            "line": 110,
            "code": "    it('should not check update if last check was just now', async () => {\n      browser.storage.local.get.onFirstCall().returns(\n        Promise.resolve({\n          lastCheckUpdate: Date.now()\n        })\n      )\n      browser.runtime.onStartup.dispatch()\n\n      await timer(0)\n      expect(checkUpdate).toHaveBeenCalledTimes(0)\n    })",
            "file": "specs/background/initialization.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not start sniffing if sniff config is off",
            "suites": [
                "PDF Sniffer"
            ],
            "updatePoint": {
                "line": 47,
                "column": 54
            },
            "line": 47,
            "code": "  it('should not start sniffing if sniff config is off', async () => {\n    ;(window.appConfig as AppConfigMutable).pdfSniff = false\n    initPdf(window.appConfig)\n    await timer(0)\n    expect(\n      browser.webRequest.onBeforeRequest.addListener.notCalled\n    ).toBeTruthy()\n    expect(\n      browser.webRequest.onHeadersReceived.addListener.notCalled\n    ).toBeTruthy()\n    expect(configManager.addConfigListener).toHaveBeenCalledTimes(1)\n  })",
            "file": "specs/background/pdf-sniffer.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should start snifffing if sniff config is on",
            "suites": [
                "PDF Sniffer"
            ],
            "updatePoint": {
                "line": 60,
                "column": 50
            },
            "line": 60,
            "code": "  it('should start snifffing if sniff config is on', async () => {\n    ;(window.appConfig as AppConfigMutable).pdfSniff = true\n    initPdf(window.appConfig)\n    await timer(0)\n    expect(\n      browser.webRequest.onBeforeRequest.addListener.calledOnce\n    ).toBeTruthy()\n    expect(\n      browser.webRequest.onHeadersReceived.addListener.calledOnce\n    ).toBeTruthy()\n    expect(configManager.addConfigListener).toHaveBeenCalledTimes(1)\n  })",
            "file": "specs/background/pdf-sniffer.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should stop sniffing if sniff config is turned off",
            "suites": [
                "PDF Sniffer"
            ],
            "updatePoint": {
                "line": 73,
                "column": 56
            },
            "line": 73,
            "code": "  it('should stop sniffing if sniff config is turned off', async () => {\n    ;(window.appConfig as AppConfigMutable).pdfSniff = true\n    initPdf(window.appConfig)\n    await timer(0)\n    changeConfig(\n      { ...window.appConfig, pdfSniff: false },\n      { ...window.appConfig, pdfSniff: true }\n    )\n    await timer(0)\n    expect(\n      browser.webRequest.onBeforeRequest.addListener.calledOnce\n    ).toBeTruthy()\n    expect(\n      browser.webRequest.onHeadersReceived.addListener.calledOnce\n    ).toBeTruthy()\n    expect(\n      browser.webRequest.onBeforeRequest.removeListener.calledOnce\n    ).toBeTruthy()\n    expect(\n      browser.webRequest.onHeadersReceived.removeListener.calledOnce\n    ).toBeTruthy()\n    expect(configManager.addConfigListener).toHaveBeenCalledTimes(1)\n  })",
            "file": "specs/background/pdf-sniffer.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should start snifffing only once if init multiple times",
            "suites": [
                "PDF Sniffer"
            ],
            "updatePoint": {
                "line": 97,
                "column": 61
            },
            "line": 97,
            "code": "  it('should start snifffing only once if init multiple times', async () => {\n    ;(window.appConfig as AppConfigMutable).pdfSniff = true\n    initPdf(window.appConfig)\n    initPdf(window.appConfig)\n    initPdf(window.appConfig)\n    initPdf(window.appConfig)\n    await timer(0)\n    expect(\n      browser.webRequest.onBeforeRequest.addListener.calledOnce\n    ).toBeTruthy()\n    expect(\n      browser.webRequest.onHeadersReceived.addListener.calledOnce\n    ).toBeTruthy()\n    expect(configManager.addConfigListener).toHaveBeenCalledTimes(1)\n  })",
            "file": "specs/background/pdf-sniffer.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should start snifffing only once if being turned on multiple times",
            "suites": [
                "PDF Sniffer"
            ],
            "updatePoint": {
                "line": 113,
                "column": 72
            },
            "line": 113,
            "code": "  it('should start snifffing only once if being turned on multiple times', async () => {\n    ;(window.appConfig as AppConfigMutable).pdfSniff = false\n    initPdf(window.appConfig)\n    await timer(0)\n    changeConfig(\n      { ...window.appConfig, pdfSniff: true },\n      { ...window.appConfig, pdfSniff: false }\n    )\n    changeConfig(\n      { ...window.appConfig, pdfSniff: true },\n      { ...window.appConfig, pdfSniff: false }\n    )\n    await timer(0)\n    expect(\n      browser.webRequest.onBeforeRequest.addListener.calledOnce\n    ).toBeTruthy()\n    expect(\n      browser.webRequest.onHeadersReceived.addListener.calledOnce\n    ).toBeTruthy()\n    expect(configManager.addConfigListener).toHaveBeenCalledTimes(1)\n  })",
            "file": "specs/background/pdf-sniffer.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should intercept ftp/file pdf request and redirect to pdf.js",
            "suites": [
                "PDF Sniffer"
            ],
            "updatePoint": {
                "line": 135,
                "column": 66
            },
            "line": 135,
            "code": "  it('should intercept ftp/file pdf request and redirect to pdf.js', async () => {\n    ;(window.appConfig as AppConfigMutable).pdfSniff = true\n    initPdf(window.appConfig)\n    await timer(0)\n    const handler = browser.webRequest.onBeforeRequest['_listeners'][0]\n    expect(handler({ url: urlPdf })).toEqual({\n      redirectUrl: expect.stringMatching(urlPdfEncoded)\n    })\n    expect(handler({ url: urlTxt })).toEqual({\n      redirectUrl: expect.stringMatching(urlTxtEncoded)\n    })\n  })",
            "file": "specs/background/pdf-sniffer.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not intercept ftp/file pdf request if the url matches blacklist",
            "suites": [
                "PDF Sniffer"
            ],
            "updatePoint": {
                "line": 148,
                "column": 76
            },
            "line": 148,
            "code": "  it('should not intercept ftp/file pdf request if the url matches blacklist', async () => {\n    ;(window.appConfig as AppConfigMutable).pdfSniff = true\n    ;(window.appConfig as AppConfigMutable).pdfBlacklist = [\n      [matchPatternToRegExpStr(urlPdf), urlPdf]\n    ]\n    initPdf(window.appConfig)\n    await timer(0)\n    const handler = browser.webRequest.onBeforeRequest['_listeners'][0]\n    expect(handler({ url: urlPdf })).toBeUndefined()\n    expect(handler({ url: urlTxt })).toEqual({\n      redirectUrl: expect.stringMatching(urlTxtEncoded)\n    })\n  })",
            "file": "specs/background/pdf-sniffer.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should intercept ftp/file pdf request if the url matches whitelist",
            "suites": [
                "PDF Sniffer"
            ],
            "updatePoint": {
                "line": 162,
                "column": 72
            },
            "line": 162,
            "code": "  it('should intercept ftp/file pdf request if the url matches whitelist', async () => {\n    ;(window.appConfig as AppConfigMutable).pdfSniff = true\n    ;(window.appConfig as AppConfigMutable).pdfWhitelist = [\n      [matchPatternToRegExpStr(urlPdf), urlPdf]\n    ]\n    initPdf(window.appConfig)\n    await timer(0)\n    const handler = browser.webRequest.onBeforeRequest['_listeners'][0]\n    expect(handler({ url: urlPdf })).toEqual({\n      redirectUrl: expect.stringMatching(urlPdfEncoded)\n    })\n    expect(handler({ url: urlTxt })).toEqual({\n      redirectUrl: expect.stringMatching(urlTxtEncoded)\n    })\n  })",
            "file": "specs/background/pdf-sniffer.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should intercept ftp/file pdf request if the url matches both blacklist and whitelist",
            "suites": [
                "PDF Sniffer"
            ],
            "updatePoint": {
                "line": 178,
                "column": 91
            },
            "line": 178,
            "code": "  it('should intercept ftp/file pdf request if the url matches both blacklist and whitelist', async () => {\n    ;(window.appConfig as AppConfigMutable).pdfSniff = true\n    ;(window.appConfig as AppConfigMutable).pdfBlacklist = [\n      [matchPatternToRegExpStr(urlPdf), urlPdf]\n    ]\n    ;(window.appConfig as AppConfigMutable).pdfWhitelist = [\n      [matchPatternToRegExpStr(urlPdf), urlPdf]\n    ]\n    initPdf(window.appConfig)\n    await timer(0)\n    const handler = browser.webRequest.onBeforeRequest['_listeners'][0]\n    expect(handler({ url: urlPdf })).toEqual({\n      redirectUrl: expect.stringMatching(urlPdfEncoded)\n    })\n    expect(handler({ url: urlTxt })).toEqual({\n      redirectUrl: expect.stringMatching(urlTxtEncoded)\n    })\n  })",
            "file": "specs/background/pdf-sniffer.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "No PDF Content",
            "suites": [
                "PDF Sniffer",
                "intercept http/https pdf request and redirect to pdf.js"
            ],
            "updatePoint": {
                "line": 198,
                "column": 22
            },
            "line": 198,
            "code": "    it('No PDF Content', async () => {\n      ;(window.appConfig as AppConfigMutable).pdfSniff = true\n      initPdf(window.appConfig)\n      await timer(0)\n      const handler = browser.webRequest.onHeadersReceived['_listeners'][0]\n      expect(handler({ resposeHeaders: [], url: urlPdf })).toBeUndefined()\n\n      const otherResponseHeaders = [{ name: 'content-type', value: 'other' }]\n      expect(\n        handler({ responseHeaders: otherResponseHeaders, url: urlPdf })\n      ).toBeUndefined()\n    })",
            "file": "specs/background/pdf-sniffer.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "With PDF Content Type",
            "suites": [
                "PDF Sniffer",
                "intercept http/https pdf request and redirect to pdf.js"
            ],
            "updatePoint": {
                "line": 211,
                "column": 29
            },
            "line": 211,
            "code": "    it('With PDF Content Type', async () => {\n      ;(window.appConfig as AppConfigMutable).pdfSniff = true\n      initPdf(window.appConfig)\n      await timer(0)\n      const handler = browser.webRequest.onHeadersReceived['_listeners'][0]\n      const responseHeaders = [\n        { name: 'content-type', value: 'application/pdf' }\n      ]\n      expect(handler({ responseHeaders, url: urlPdf })).toEqual({\n        redirectUrl: expect.stringMatching(urlPdfEncoded)\n      })\n      expect(handler({ responseHeaders, url: urlTxt })).toEqual({\n        redirectUrl: expect.stringMatching(urlTxtEncoded)\n      })\n    })",
            "file": "specs/background/pdf-sniffer.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "PDF url with octet-stream Content Type",
            "suites": [
                "PDF Sniffer",
                "intercept http/https pdf request and redirect to pdf.js"
            ],
            "updatePoint": {
                "line": 227,
                "column": 46
            },
            "line": 227,
            "code": "    it('PDF url with octet-stream Content Type', async () => {\n      ;(window.appConfig as AppConfigMutable).pdfSniff = true\n      initPdf(window.appConfig)\n      await timer(0)\n      const handler = browser.webRequest.onHeadersReceived['_listeners'][0]\n      const responseHeaders = [\n        { name: 'content-type', value: 'application/octet-stream' }\n      ]\n      expect(handler({ responseHeaders, url: urlPdf })).toEqual({\n        redirectUrl: expect.stringMatching(urlPdfEncoded)\n      })\n      expect(handler({ responseHeaders, url: urlTxt })).toBeUndefined()\n    })",
            "file": "specs/background/pdf-sniffer.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not intercept if the url matches blacklist",
            "suites": [
                "PDF Sniffer",
                "intercept http/https pdf request and redirect to pdf.js"
            ],
            "updatePoint": {
                "line": 241,
                "column": 57
            },
            "line": 241,
            "code": "    it('should not intercept if the url matches blacklist', () => {\n      ;(window.appConfig as AppConfigMutable).pdfSniff = true\n      ;(window.appConfig as AppConfigMutable).pdfBlacklist = [\n        [matchPatternToRegExpStr(urlPdf), urlPdf]\n      ]\n      initPdf(window.appConfig)\n      const handler = browser.webRequest.onHeadersReceived['_listeners'][0]\n      const responseHeaders = [\n        { name: 'content-type', value: 'application/pdf' }\n      ]\n      expect(handler({ responseHeaders, url: urlPdf })).toBeUndefined()\n      expect(handler({ responseHeaders, url: urlTxt })).toEqual({\n        redirectUrl: expect.stringMatching(urlTxtEncoded)\n      })\n    })",
            "file": "specs/background/pdf-sniffer.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should intercept if the url matches whitelist",
            "suites": [
                "PDF Sniffer",
                "intercept http/https pdf request and redirect to pdf.js"
            ],
            "updatePoint": {
                "line": 257,
                "column": 53
            },
            "line": 257,
            "code": "    it('should intercept if the url matches whitelist', async () => {\n      ;(window.appConfig as AppConfigMutable).pdfSniff = true\n      ;(window.appConfig as AppConfigMutable).pdfWhitelist = [\n        [matchPatternToRegExpStr(urlPdf), urlPdf]\n      ]\n      initPdf(window.appConfig)\n      await timer(0)\n      const handler = browser.webRequest.onHeadersReceived['_listeners'][0]\n      const responseHeaders = [\n        { name: 'content-type', value: 'application/pdf' }\n      ]\n      expect(handler({ responseHeaders, url: urlPdf })).toEqual({\n        redirectUrl: expect.stringMatching(urlPdfEncoded)\n      })\n      expect(handler({ responseHeaders, url: urlTxt })).toEqual({\n        redirectUrl: expect.stringMatching(urlTxtEncoded)\n      })\n    })",
            "file": "specs/background/pdf-sniffer.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should intercept if the url matches both blacklist and whitelist",
            "suites": [
                "PDF Sniffer",
                "intercept http/https pdf request and redirect to pdf.js"
            ],
            "updatePoint": {
                "line": 276,
                "column": 72
            },
            "line": 276,
            "code": "    it('should intercept if the url matches both blacklist and whitelist', async () => {\n      ;(window.appConfig as AppConfigMutable).pdfSniff = true\n      ;(window.appConfig as AppConfigMutable).pdfBlacklist = [\n        [matchPatternToRegExpStr(urlPdf), urlPdf]\n      ]\n      ;(window.appConfig as AppConfigMutable).pdfWhitelist = [\n        [matchPatternToRegExpStr(urlPdf), urlPdf]\n      ]\n      initPdf(window.appConfig)\n      await timer(0)\n      const handler = browser.webRequest.onHeadersReceived['_listeners'][0]\n      const responseHeaders = [\n        { name: 'content-type', value: 'application/pdf' }\n      ]\n      expect(handler({ responseHeaders, url: urlPdf })).toEqual({\n        redirectUrl: expect.stringMatching(urlPdfEncoded)\n      })\n      expect(handler({ responseHeaders, url: urlTxt })).toEqual({\n        redirectUrl: expect.stringMatching(urlTxtEncoded)\n      })\n    })",
            "file": "specs/background/pdf-sniffer.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should warn if Anki Connect is not running.",
            "suites": [
                "Sync service Anki Connect",
                "init"
            ],
            "updatePoint": {
                "line": 37,
                "column": 51
            },
            "line": 37,
            "code": "    it('should warn if Anki Connect is not running.', async () => {\n      const config = Service.getDefaultConfig()\n\n      const service = new Service(config)\n      service.addWord = jest.fn(async () => null)\n\n      let error: Error | undefined\n      try {\n        await service.init()\n      } catch (e) {\n        error = e\n      }\n\n      expect(service.addWord).toHaveBeenCalledTimes(0)\n      expect(error?.message).toBe('server')\n    })",
            "file": "specs/background/sync-manager/services/ankiconnect.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should warn if deck does not exist in Anki.",
            "suites": [
                "Sync service Anki Connect",
                "init"
            ],
            "updatePoint": {
                "line": 54,
                "column": 51
            },
            "line": 54,
            "code": "    it('should warn if deck does not exist in Anki.', async () => {\n      const config = Service.getDefaultConfig()\n\n      mockRequest(data => {\n        switch (data.action) {\n          case 'version':\n            return [200, { result: 6, error: null }]\n          case 'deckNames':\n            return [200, { result: [], error: null }]\n          default:\n            return [404]\n        }\n      })\n\n      const service = new Service(config)\n      service.addWord = jest.fn(async () => null)\n\n      let error: Error | undefined\n      try {\n        await service.init()\n      } catch (e) {\n        error = e\n      }\n\n      expect(service.addWord).toHaveBeenCalledTimes(0)\n      expect(error?.message).toBe('deck')\n    })",
            "file": "specs/background/sync-manager/services/ankiconnect.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should warn if note type does not exist in Anki.",
            "suites": [
                "Sync service Anki Connect",
                "init"
            ],
            "updatePoint": {
                "line": 82,
                "column": 56
            },
            "line": 82,
            "code": "    it('should warn if note type does not exist in Anki.', async () => {\n      const config = Service.getDefaultConfig()\n\n      mockRequest(data => {\n        switch (data.action) {\n          case 'version':\n            return [200, { result: 6, error: null }]\n          case 'deckNames':\n            return [200, { result: [config.deckName], error: null }]\n          case 'modelNames':\n            return [200, { result: [], error: null }]\n          default:\n            return [404]\n        }\n      })\n\n      const service = new Service(config)\n      service.addWord = jest.fn(async () => null)\n\n      let error: Error | undefined\n      try {\n        await service.init()\n      } catch (e) {\n        error = e\n      }\n\n      expect(service.addWord).toHaveBeenCalledTimes(0)\n      expect(error?.message).toBe('notetype')\n    })",
            "file": "specs/background/sync-manager/services/ankiconnect.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should init successfully",
            "suites": [
                "Sync service Anki Connect",
                "init"
            ],
            "updatePoint": {
                "line": 112,
                "column": 32
            },
            "line": 112,
            "code": "    it('should init successfully', async () => {\n      const config = Service.getDefaultConfig()\n\n      mockRequest(data => {\n        switch (data.action) {\n          case 'version':\n            return [200, { result: 6, error: null }]\n          case 'deckNames':\n            return [200, { result: [config.deckName], error: null }]\n          case 'modelNames':\n            return [200, { result: [config.noteType], error: null }]\n          default:\n            return [404]\n        }\n      })\n\n      const service = new Service(config)\n      service.addWord = jest.fn(async () => null)\n\n      let error: Error | undefined\n      try {\n        await service.init()\n      } catch (e) {\n        error = e\n      }\n\n      expect(service.addWord).toHaveBeenCalledTimes(0)\n      expect(error).toBeUndefined()\n    })",
            "file": "specs/background/sync-manager/services/ankiconnect.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "upload: should success",
            "suites": [
                "Sync service WebDAV"
            ],
            "updatePoint": {
                "line": 109,
                "column": 28
            },
            "line": 109,
            "code": "  it('upload: should success', async () => {\n    const config: SyncConfig = {\n      enable: true,\n      url: 'https://example.com/dav/',\n      user: 'user',\n      passwd: 'passwd',\n      duration: 0\n    }\n\n    const fetchInit = {\n      upload: jest.fn(() => new Response())\n    }\n    mockFetch(config, fetchInit)\n\n    const words = [getWord(), getWord({ text: 'word' })]\n    helpers.getNotebook.mockImplementationOnce(() => Promise.resolve(words))\n\n    const service = new Service(config)\n\n    await service.add({ force: true })\n\n    expect(fetchInit.upload).toHaveBeenCalledTimes(1)\n    expect(fetchInit.upload).lastCalledWith(\n      ...fetchArgs.upload(\n        config,\n        expect.stringContaining(JSON.stringify(words))\n      )\n    )\n  })",
            "file": "specs/background/sync-manager/services/webdav.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should save file on first download",
            "suites": [
                "Sync service WebDAV",
                "download"
            ],
            "updatePoint": {
                "line": 140,
                "column": 42
            },
            "line": 140,
            "code": "    it('should save file on first download', async () => {\n      const config: SyncConfig = {\n        enable: true,\n        url: 'https://example.com/dav/',\n        user: 'user',\n        passwd: 'passwd',\n        duration: 0\n      }\n\n      const words = [\n        getWord({\n          ...newWord({ text: 'test' }),\n          date: Date.now()\n        })\n      ]\n      const timestamp = Date.now()\n      const file: NotebookFile = { timestamp, words }\n\n      const etag = 'etag222'\n\n      const fetchInit = {\n        download: jest.fn(\n          () =>\n            new Response(JSON.stringify(file), {\n              headers: {\n                etag\n              }\n            })\n        )\n      }\n\n      mockFetch(config, fetchInit)\n\n      const service = new Service(config)\n\n      await service.download({})\n\n      expect(helpers.setNotebook).lastCalledWith(words)\n      expect(helpers.setMeta).lastCalledWith('webdav', { timestamp, etag })\n      expect(fetchInit.download).toHaveBeenCalledTimes(1)\n      expect(fetchInit.download).lastCalledWith(...fetchArgs.download(config))\n    })",
            "file": "specs/background/sync-manager/services/webdav.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should save file if etag changed",
            "suites": [
                "Sync service WebDAV",
                "download"
            ],
            "updatePoint": {
                "line": 183,
                "column": 40
            },
            "line": 183,
            "code": "    it('should save file if etag changed', async () => {\n      const config: SyncConfig = {\n        enable: true,\n        url: 'https://example.com/dav/',\n        user: 'user',\n        passwd: 'passwd',\n        duration: 0\n      }\n\n      const words = [\n        getWord({\n          ...newWord({ text: 'test' }),\n          date: Date.now()\n        })\n      ]\n      const timestamp = Date.now()\n      const file: NotebookFile = { timestamp, words }\n\n      const etagOrigin = 'etag12345'\n      const etag = 'etag222'\n\n      const fetchInit = {\n        download: jest.fn(\n          () =>\n            new Response(JSON.stringify(file), {\n              headers: {\n                etag\n              }\n            })\n        )\n      }\n\n      mockFetch(config, fetchInit)\n\n      const service = new Service(config)\n      service.meta = { etag: etagOrigin }\n\n      await service.download({})\n\n      expect(helpers.setNotebook).lastCalledWith(words)\n      expect(helpers.setMeta).lastCalledWith('webdav', { timestamp, etag })\n      expect(fetchInit.download).toHaveBeenCalledTimes(1)\n      expect(fetchInit.download).lastCalledWith(\n        ...fetchArgs.download(config, {\n          'If-None-Match': etagOrigin,\n          'If-Modified-Since': etagOrigin\n        })\n      )\n    })",
            "file": "specs/background/sync-manager/services/webdav.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should do nothing if 304 (same etag)",
            "suites": [
                "Sync service WebDAV",
                "download"
            ],
            "updatePoint": {
                "line": 233,
                "column": 44
            },
            "line": 233,
            "code": "    it('should do nothing if 304 (same etag)', async () => {\n      const config: SyncConfig = {\n        enable: true,\n        url: 'https://example.com/dav/',\n        user: 'user',\n        passwd: 'passwd',\n        duration: 0\n      }\n\n      const etag = 'etag222'\n\n      const fetchInit = {\n        download: jest.fn(\n          () =>\n            new Response(null, {\n              status: 304,\n              headers: {\n                etag\n              }\n            })\n        )\n      }\n\n      mockFetch(config, fetchInit)\n\n      const service = new Service(config)\n      service.meta = { etag }\n\n      await service.download({})\n\n      expect(helpers.setNotebook).toHaveBeenCalledTimes(0)\n      expect(helpers.setMeta).toHaveBeenCalledTimes(0)\n      expect(fetchInit.download).toHaveBeenCalledTimes(1)\n      expect(fetchInit.download).lastCalledWith(\n        ...fetchArgs.download(config, {\n          'If-None-Match': etag,\n          'If-Modified-Since': etag\n        })\n      )\n    })",
            "file": "specs/background/sync-manager/services/webdav.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should do nothing if etags are different but timestamps are identical",
            "suites": [
                "Sync service WebDAV",
                "download"
            ],
            "updatePoint": {
                "line": 274,
                "column": 77
            },
            "line": 274,
            "code": "    it('should do nothing if etags are different but timestamps are identical', async () => {\n      const config: SyncConfig = {\n        enable: true,\n        url: 'https://example.com/dav/',\n        user: 'user',\n        passwd: 'passwd',\n        duration: 0\n      }\n\n      const file: NotebookFile = {\n        timestamp: Date.now(),\n        words: [\n          {\n            ...newWord({ text: 'test' }),\n            date: Date.now()\n          }\n        ]\n      }\n\n      const etagOrigin = 'etag12345'\n      const etag = 'etag222'\n\n      const fetchInit = {\n        download: jest.fn(\n          () =>\n            new Response(JSON.stringify(file), {\n              headers: {\n                etag\n              }\n            })\n        )\n      }\n\n      mockFetch(config, fetchInit)\n\n      const service = new Service(config)\n      service.meta = {\n        etag: etagOrigin,\n        timestamp: file.timestamp\n      }\n\n      await service.download({})\n\n      expect(helpers.setNotebook).toHaveBeenCalledTimes(0)\n      expect(helpers.setMeta).toHaveBeenCalledTimes(1)\n      expect(fetchInit.download).toHaveBeenCalledTimes(1)\n      expect(fetchInit.download).lastCalledWith(\n        ...fetchArgs.download(config, {\n          'If-None-Match': etagOrigin,\n          'If-Modified-Since': etagOrigin\n        })\n      )\n    })",
            "file": "specs/background/sync-manager/services/webdav.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should do nothing if etags are different but timestamps are identical",
            "suites": [
                "Sync service WebDAV",
                "download"
            ],
            "updatePoint": {
                "line": 328,
                "column": 77
            },
            "line": 328,
            "code": "    it('should do nothing if etags are different but timestamps are identical', async () => {\n      const config: SyncConfig = {\n        enable: true,\n        url: 'https://example.com/dav/',\n        user: 'user',\n        passwd: 'passwd',\n        duration: 0\n      }\n\n      const file: NotebookFile = {\n        timestamp: Date.now(),\n        words: [\n          getWord({\n            ...newWord({ text: 'test' }),\n            date: Date.now()\n          })\n        ]\n      }\n\n      const etagOrigin = 'etag12345'\n      const etag = 'etag222'\n\n      const fetchInit = {\n        download: jest.fn(\n          () =>\n            new Response(JSON.stringify(file), {\n              headers: {\n                etag\n              }\n            })\n        )\n      }\n\n      mockFetch(config, fetchInit)\n\n      const service = new Service(config)\n      service.meta = {\n        etag: etagOrigin,\n        timestamp: file.timestamp\n      }\n\n      await service.download({})\n\n      expect(helpers.setNotebook).toHaveBeenCalledTimes(0)\n      expect(helpers.setMeta).toHaveBeenCalledTimes(1)\n      expect(fetchInit.download).toHaveBeenCalledTimes(1)\n      expect(fetchInit.download).lastCalledWith(\n        ...fetchArgs.download(config, {\n          'If-None-Match': etagOrigin,\n          'If-Modified-Since': etagOrigin\n        })\n      )\n    })",
            "file": "specs/background/sync-manager/services/webdav.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should do nothing if words are corrupted",
            "suites": [
                "Sync service WebDAV",
                "download"
            ],
            "updatePoint": {
                "line": 382,
                "column": 48
            },
            "line": 382,
            "code": "    it('should do nothing if words are corrupted', async () => {\n      const config: SyncConfig = {\n        enable: true,\n        url: 'https://example.com/dav/',\n        user: 'user',\n        passwd: 'passwd',\n        duration: 0\n      }\n\n      const file: NotebookFile = {\n        timestamp: Date.now(),\n        words: ['corrupted format'] as any\n      }\n\n      const etag = 'etag222'\n\n      const fetchInit = {\n        download: jest.fn(\n          () =>\n            new Response(JSON.stringify(file), {\n              headers: {\n                etag\n              }\n            })\n        )\n      }\n\n      mockFetch(config, fetchInit)\n\n      const service = new Service(config)\n\n      try {\n        await service.download({})\n      } catch (e) {\n        expect(e.message).toBe('format')\n      }\n\n      expect(helpers.setNotebook).toHaveBeenCalledTimes(0)\n      expect(helpers.setMeta).toHaveBeenCalledTimes(0)\n      expect(fetchInit.download).toHaveBeenCalledTimes(1)\n      expect(fetchInit.download).lastCalledWith(...fetchArgs.download(config))\n    })",
            "file": "specs/background/sync-manager/services/webdav.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should do nothing if network failed",
            "suites": [
                "Sync service WebDAV",
                "download"
            ],
            "updatePoint": {
                "line": 425,
                "column": 43
            },
            "line": 425,
            "code": "    it('should do nothing if network failed', async () => {\n      const config: SyncConfig = {\n        enable: true,\n        url: 'https://example.com/dav/',\n        user: 'user',\n        passwd: 'passwd',\n        duration: 0\n      }\n\n      const fetchInit = {\n        download: jest.fn(\n          () =>\n            new Response(null, {\n              status: 404\n            })\n        )\n      }\n\n      mockFetch(config, fetchInit)\n\n      const service = new Service(config)\n\n      try {\n        await service.download({})\n      } catch (e) {\n        expect(e.message).toBe('network')\n      }\n\n      expect(helpers.setNotebook).toHaveBeenCalledTimes(0)\n      expect(helpers.setMeta).toHaveBeenCalledTimes(0)\n      expect(fetchInit.download).toHaveBeenCalledTimes(1)\n      expect(fetchInit.download).lastCalledWith(...fetchArgs.download(config))\n    })",
            "file": "specs/background/sync-manager/services/webdav.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should create dir and upload files on first init",
            "suites": [
                "Sync service WebDAV",
                "initServer"
            ],
            "updatePoint": {
                "line": 461,
                "column": 56
            },
            "line": 461,
            "code": "    it('should create dir and upload files on first init', async () => {\n      const config: SyncConfig = {\n        enable: true,\n        url: 'https://example.com/dav/',\n        user: 'user',\n        passwd: 'passwd',\n        duration: 0\n      }\n\n      const file: NotebookFile = {\n        timestamp: Date.now(),\n        words: [\n          {\n            ...newWord({ text: 'test' }),\n            date: Date.now()\n          }\n        ]\n      }\n      const fileText = JSON.stringify(file)\n\n      const etag = 'etag222'\n\n      const fetchInit = {\n        checkServer: jest.fn(() => new Response(genXML())),\n        upload: jest.fn(() => new Response()),\n        download: jest.fn(\n          () =>\n            new Response(fileText, {\n              headers: {\n                etag\n              }\n            })\n        ),\n        createDir: jest.fn(() => new Response())\n      }\n\n      mockFetch(config, fetchInit)\n\n      const service = new Service(config)\n      service.download = jest.fn(() => Promise.resolve())\n\n      await service.init()\n\n      expect(service.download).toHaveBeenCalledTimes(0)\n      expect(fetchInit.checkServer).toHaveBeenCalledTimes(1)\n      expect(fetchInit.checkServer).lastCalledWith(\n        ...fetchArgs.checkServer(config)\n      )\n      expect(fetchInit.createDir).toHaveBeenCalledTimes(1)\n      expect(fetchInit.createDir).lastCalledWith(...fetchArgs.createDir(config))\n      expect(fetchInit.upload).toHaveBeenCalledTimes(0)\n      expect(fetchInit.download).toHaveBeenCalledTimes(0)\n      expect(helpers.setMeta).toHaveBeenCalledTimes(0)\n      expect(helpers.setNotebook).toHaveBeenCalledTimes(0)\n    })",
            "file": "specs/background/sync-manager/services/webdav.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should do nothing if local files are older",
            "suites": [
                "Sync service WebDAV",
                "initServer"
            ],
            "updatePoint": {
                "line": 517,
                "column": 50
            },
            "line": 517,
            "code": "    it('should do nothing if local files are older', async () => {\n      const config: SyncConfig = {\n        enable: true,\n        url: 'https://example.com/dav/',\n        user: 'user',\n        passwd: 'passwd',\n        duration: 0\n      }\n\n      const file: NotebookFile = {\n        timestamp: Date.now(),\n        words: [\n          {\n            ...newWord({ text: 'test' }),\n            date: Date.now()\n          }\n        ]\n      }\n      const fileText = JSON.stringify(file)\n\n      const etagLocal = 'etag12345'\n      const etag = 'etag222'\n\n      const fetchInit = {\n        checkServer: jest.fn(() => new Response(genXML(true))),\n        upload: jest.fn(() => new Response()),\n        download: jest.fn(\n          () =>\n            new Response(fileText, {\n              headers: {\n                etag\n              }\n            })\n        ),\n        createDir: jest.fn(() => new Response())\n      }\n\n      helpers.getMeta.mockImplementationOnce(\n        (): Promise<SyncMeta> =>\n          Promise.resolve({\n            timestamp: file.timestamp - 100,\n            etag: etagLocal\n          })\n      )\n      mockFetch(config, fetchInit)\n\n      const service = new Service(config)\n      service.download = jest.fn(() => Promise.resolve())\n\n      await service.init()\n\n      expect(service.download).toHaveBeenCalledTimes(0)\n      expect(fetchInit.checkServer).toHaveBeenCalledTimes(1)\n      expect(fetchInit.checkServer).lastCalledWith(\n        ...fetchArgs.checkServer(config)\n      )\n      // @upstream JSDOM missing namespace selector support\n      // expect(fetchInit.createDir).toHaveBeenCalledTimes(0)\n      expect(fetchInit.upload).toHaveBeenCalledTimes(0)\n      expect(fetchInit.download).toHaveBeenCalledTimes(0)\n      expect(helpers.setMeta).toHaveBeenCalledTimes(0)\n      expect(helpers.setNotebook).toHaveBeenCalledTimes(0)\n    })",
            "file": "specs/background/sync-manager/services/webdav.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should reject with \"network\" if netword errored",
            "suites": [
                "Sync service WebDAV",
                "initServer"
            ],
            "updatePoint": {
                "line": 581,
                "column": 55
            },
            "line": 581,
            "code": "    it('should reject with \"network\" if netword errored', async () => {\n      const config: SyncConfig = {\n        enable: true,\n        url: 'https://example.com/dav/',\n        user: 'user',\n        passwd: 'passwd',\n        duration: 0\n      }\n\n      const fetchInit = {\n        checkServer: jest.fn(() => new Response(null, { status: 404 })),\n        upload: jest.fn(() => new Response()),\n        download: jest.fn(() => new Response()),\n        createDir: jest.fn(() => new Response())\n      }\n\n      mockFetch(config, fetchInit)\n\n      const service = new Service(config)\n      service.download = jest.fn(() => Promise.resolve())\n\n      try {\n        await service.init()\n      } catch (e) {\n        expect(e.message).toBe('network')\n      }\n\n      expect(service.download).toHaveBeenCalledTimes(0)\n      expect(fetchInit.checkServer).toHaveBeenCalledTimes(1)\n      expect(fetchInit.checkServer).lastCalledWith(\n        ...fetchArgs.checkServer(config)\n      )\n      // @upstream JSDOM missing namespace selector support\n      // expect(fetchInit.createDir).toHaveBeenCalledTimes(0)\n      expect(fetchInit.upload).toHaveBeenCalledTimes(0)\n      expect(fetchInit.download).toHaveBeenCalledTimes(0)\n      expect(helpers.setMeta).toHaveBeenCalledTimes(0)\n      expect(helpers.setNotebook).toHaveBeenCalledTimes(0)\n    })",
            "file": "specs/background/sync-manager/services/webdav.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should reject with \"mkcol\" if cannot create dir",
            "suites": [
                "Sync service WebDAV",
                "initServer"
            ],
            "updatePoint": {
                "line": 621,
                "column": 55
            },
            "line": 621,
            "code": "    it('should reject with \"mkcol\" if cannot create dir', async () => {\n      const config: SyncConfig = {\n        enable: true,\n        url: 'https://example.com/dav/',\n        user: 'user',\n        passwd: 'passwd',\n        duration: 0\n      }\n\n      const fetchInit = {\n        checkServer: jest.fn(() => new Response(genXML(true))),\n        upload: jest.fn(() => new Response()),\n        download: jest.fn(() => new Response()),\n        createDir: jest.fn(() => new Response(null, { status: 504 }))\n      }\n\n      mockFetch(config, fetchInit)\n\n      const service = new Service(config)\n      service.download = jest.fn(() => Promise.resolve())\n\n      try {\n        await service.init()\n      } catch (e) {\n        expect(e.message).toBe('mkcol')\n      }\n\n      expect(service.download).toHaveBeenCalledTimes(0)\n      expect(fetchInit.checkServer).toHaveBeenCalledTimes(1)\n      expect(fetchInit.checkServer).lastCalledWith(\n        ...fetchArgs.checkServer(config)\n      )\n      expect(fetchInit.createDir).toHaveBeenCalledTimes(1)\n      expect(fetchInit.createDir).lastCalledWith(...fetchArgs.createDir(config))\n      expect(fetchInit.upload).toHaveBeenCalledTimes(0)\n      expect(fetchInit.download).toHaveBeenCalledTimes(0)\n      expect(helpers.setMeta).toHaveBeenCalledTimes(0)\n      expect(helpers.setNotebook).toHaveBeenCalledTimes(0)\n    })",
            "file": "specs/background/sync-manager/services/webdav.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse lex result correctly",
            "suites": [
                "Dict/Bing/engine"
            ],
            "updatePoint": {
                "line": 12,
                "column": 39
            },
            "line": 12,
            "code": "  it('should parse lex result correctly', () => {\n    const profile = getDefaultProfile() as ProfileMutable\n    profile.dicts.all.bing.options = {\n      tense: true,\n      phsym: true,\n      cdef: true,\n      related: true,\n      sentence: 4\n    }\n    return retry(() =>\n      search('love', getDefaultConfig(), profile, { isPDF: false }).then(\n        searchResult => {\n          expect(searchResult.audio).toHaveProperty(\n            'us',\n            expect.stringContaining('mp3')\n          )\n          expect(searchResult.audio).toHaveProperty(\n            'uk',\n            expect.stringContaining('mp3')\n          )\n\n          const result = searchResult.result as BingResultLex\n          expect(result.type).toBe('lex')\n          expect((result.phsym as any).length).toBeGreaterThan(0)\n          expect((result.cdef as any).length).toBeGreaterThan(0)\n          expect((result.infs as any).length).toBeGreaterThan(0)\n          expect(result.sentences).toHaveLength(4)\n        }\n      )\n    )\n  })",
            "file": "specs/components/dictionaries/bing/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse machine result correctly",
            "suites": [
                "Dict/Bing/engine"
            ],
            "updatePoint": {
                "line": 44,
                "column": 43
            },
            "line": 44,
            "code": "  it('should parse machine result correctly', () => {\n    return retry(() =>\n      search(\n        'lose yourself in the dark',\n        getDefaultConfig(),\n        getDefaultProfile(),\n        { isPDF: false }\n      ).then(searchResult => {\n        expect(searchResult.audio).toBeUndefined()\n\n        const result = searchResult.result as BingResultMachine\n        expect(result.type).toBe('machine')\n        expect(typeof result.mt).toBe('string')\n        expect(result.mt.length).toBeGreaterThan(0)\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/bing/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse related result correctly",
            "suites": [
                "Dict/Bing/engine"
            ],
            "updatePoint": {
                "line": 62,
                "column": 43
            },
            "line": 62,
            "code": "  it('should parse related result correctly', () => {\n    return retry(() =>\n      search('lovxx', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {\n        expect(searchResult.audio).toBeUndefined()\n\n        const result = searchResult.result as BingResultRelated\n        expect(result.type).toBe('related')\n        expect(result.defs.length).toBeGreaterThan(0)\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/bing/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse result (en) correctly",
            "suites": [
                "Dict/Cambridge/engine"
            ],
            "updatePoint": {
                "line": 13,
                "column": 40
            },
            "line": 13,
            "code": "  it('should parse result (en) correctly', () => {\n    return retry(() =>\n      search('love', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(({ result, audio }) => {\n        expect(audio && typeof audio.uk).toBe('string')\n        expect(audio && typeof audio.us).toBe('string')\n\n        expect(result.length).toBeGreaterThanOrEqual(1)\n\n        expect(result.every(x => typeof x === 'string')).toBeGreaterThanOrEqual(\n          1\n        )\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/cambridge/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse result (zhs) correctly",
            "suites": [
                "Dict/Cambridge/engine"
            ],
            "updatePoint": {
                "line": 30,
                "column": 41
            },
            "line": 30,
            "code": "  it('should parse result (zhs) correctly', () => {\n    return retry(() =>\n      search('house', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(({ result, audio }) => {\n        expect(audio && typeof audio.uk).toBe('string')\n        expect(audio && typeof audio.us).toBe('string')\n\n        expect(result.length).toBeGreaterThanOrEqual(1)\n\n        expect(result.every(x => typeof x === 'string')).toBeGreaterThanOrEqual(\n          1\n        )\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/cambridge/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse result (zht) correctly",
            "suites": [
                "Dict/Cambridge/engine"
            ],
            "updatePoint": {
                "line": 47,
                "column": 41
            },
            "line": 47,
            "code": "  it('should parse result (zht) correctly', () => {\n    const config = getDefaultConfig() as AppConfigMutable\n    config.langCode = 'zh-TW'\n    return retry(() =>\n      search('catch', config, getDefaultProfile(), { isPDF: false }).then(\n        ({ result, audio }) => {\n          expect(audio && typeof audio.uk).toBe('string')\n          expect(audio && typeof audio.us).toBe('string')\n\n          expect(result.length).toBeGreaterThanOrEqual(1)\n\n          expect(\n            result.every(x => typeof x === 'string')\n          ).toBeGreaterThanOrEqual(1)\n        }\n      )\n    )\n  })",
            "file": "specs/components/dictionaries/cambridge/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse result correctly",
            "suites": [
                "Dict/CNKI/engine"
            ],
            "updatePoint": {
                "line": 7,
                "column": 35
            },
            "line": 7,
            "code": "  it('should parse result correctly', () => {\n    return retry(() =>\n      search('love', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(({ result, audio }) => {\n        expect(audio).toBeUndefined()\n        expect(result.dict.length).toBeGreaterThan(0)\n        expect(result.senbi.length).toBeGreaterThan(0)\n        expect(result.seneng.length).toBeGreaterThan(0)\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/cnki/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse result correctly",
            "suites": [
                "Dict/COBUILD/engine"
            ],
            "updatePoint": {
                "line": 7,
                "column": 35
            },
            "line": 7,
            "code": "  it('should parse result correctly', () => {\n    const profile = getDefaultProfile() as ProfileMutable\n    return retry(() =>\n      search('love', getDefaultConfig(), profile, { isPDF: false }).then(\n        searchResult => {\n          expect(searchResult.result).toBeTruthy()\n        }\n      )\n    )\n  })",
            "file": "specs/components/dictionaries/cobuild/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse result correctly",
            "suites": [
                "Dict/Etymonline/engine"
            ],
            "updatePoint": {
                "line": 7,
                "column": 35
            },
            "line": 7,
            "code": "  it('should parse result correctly', () => {\n    const profile = getDefaultProfile() as ProfileMutable\n    profile.dicts.all.etymonline.options = {\n      chart: true,\n      resultnum: 4\n    }\n    return retry(() =>\n      search('love', getDefaultConfig(), profile, { isPDF: false }).then(\n        searchResult => {\n          expect(searchResult.audio).toBeUndefined()\n\n          const result = searchResult.result\n          expect(result.length).toBeGreaterThanOrEqual(1)\n          expect(typeof result[0].title).toBe('string')\n          expect(typeof result[0].href).toBe('string')\n          expect(typeof result[0].def).toBe('string')\n        }\n      )\n    )\n  })",
            "file": "specs/components/dictionaries/etymonline/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse result correctly",
            "suites": [
                "Dict/Eudic/engine"
            ],
            "updatePoint": {
                "line": 7,
                "column": 35
            },
            "line": 7,
            "code": "  it('should parse result correctly', async () => {\n    return retry(() =>\n      search('love', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {\n        expect(searchResult.audio && typeof searchResult.audio.us).toBe(\n          'string'\n        )\n        expect(searchResult.result).toHaveLength(10)\n        const item = searchResult.result[0]\n        expect(typeof item.chs).toBe('string')\n        expect(typeof item.eng).toBe('string')\n        expect(typeof item.mp3).toBe('string')\n        expect(typeof item.channel).toBe('string')\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/eudic/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse result correctly",
            "suites": [
                "Dict/GuoYu/engine"
            ],
            "updatePoint": {
                "line": 7,
                "column": 35
            },
            "line": 7,
            "code": "  it('should parse result correctly', () => {\n    return retry(() =>\n      search('愛', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {\n        expect(searchResult.audio && typeof searchResult.audio.py).toBe(\n          'string'\n        )\n        expect(typeof searchResult.result.t).toBe('string')\n        expect(Array.isArray(searchResult.result.h)).toBeTruthy()\n        expect(searchResult.result.translation).toBeTruthy()\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/guoyu/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse result correctly",
            "suites": [
                "Dict/Jikipedia/engine"
            ],
            "updatePoint": {
                "line": 7,
                "column": 35
            },
            "line": 7,
            "code": "  it('should parse result correctly', () => {\n    return retry(() =>\n      search('xswl', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {\n        expect(typeof searchResult.result.length).toBeGreaterThan(0)\n        expect(searchResult.result[0].title).toBe('string')\n        expect(searchResult.result[0].content).toBe('string')\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/jikipedia/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse result correctly",
            "suites": [
                "Dict/Jukuu/engine"
            ],
            "updatePoint": {
                "line": 7,
                "column": 35
            },
            "line": 7,
            "code": "  it('should parse result correctly', () => {\n    return retry(() =>\n      search('love', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {\n        expect(typeof searchResult.result.lang).toBe('string')\n        expect(searchResult.result.sens.length).toBeGreaterThan(0)\n        expect(typeof searchResult.result.sens[0].trans).toBe('string')\n        expect(searchResult.result.sens[0].trans.length).toBeGreaterThan(0)\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/jukuu/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse lex result correctly",
            "suites": [
                "Dict/Lexico/engine"
            ],
            "updatePoint": {
                "line": 11,
                "column": 39
            },
            "line": 11,
            "code": "  it('should parse lex result correctly', () => {\n    return retry(() =>\n      search('love', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {\n        expect(searchResult.audio && typeof searchResult.audio.uk).toBe(\n          'string'\n        )\n        expect(searchResult.audio && typeof searchResult.audio.us).toBe(\n          'string'\n        )\n\n        const result = searchResult.result as LexicoResultLex\n        expect(result.type).toBe('lex')\n        expect(typeof result.entry).toBe('string')\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/lexico/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse related result correctly",
            "suites": [
                "Dict/Lexico/engine"
            ],
            "updatePoint": {
                "line": 30,
                "column": 43
            },
            "line": 30,
            "code": "  it('should parse related result correctly', () => {\n    return retry(() =>\n      search('jumblish', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {\n        expect(searchResult.audio).toBeUndefined()\n\n        const result = searchResult.result as LexicoResultRelated\n        expect(result.type).toBe('related')\n        expect(result.list.length).toBeGreaterThan(0)\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/lexico/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse lex result (love) correctly",
            "suites": [
                "Dict/Longman/engine"
            ],
            "updatePoint": {
                "line": 11,
                "column": 46
            },
            "line": 11,
            "code": "  it('should parse lex result (love) correctly', () => {\n    const profile = getDefaultProfile() as ProfileMutable\n    profile.dicts.all.longman.options = {\n      wordfams: false,\n      collocations: true,\n      grammar: true,\n      thesaurus: true,\n      examples: true,\n      bussinessFirst: true,\n      related: true\n    }\n\n    return retry(() =>\n      search('love', getDefaultConfig(), profile, { isPDF: false }).then(\n        searchResult => {\n          expect(searchResult.audio && typeof searchResult.audio.uk).toBe(\n            'string'\n          )\n          expect(searchResult.audio && typeof searchResult.audio.us).toBe(\n            'string'\n          )\n\n          const result = searchResult.result as LongmanResultLex\n          expect(result.type).toBe('lex')\n\n          expect(result.bussinessFirst).toBe(true)\n          expect(result.wordfams).toBeUndefined()\n          expect(result.contemporary).toHaveLength(2)\n          expect(result.bussiness).toHaveLength(0)\n\n          result.contemporary.forEach(entry => {\n            expect(entry.title.HWD.length).toBeGreaterThan(0)\n            expect(entry.title.HYPHENATION.length).toBeGreaterThan(0)\n            expect(entry.title.HOMNUM.length).toBeGreaterThan(0)\n            expect(entry.senses.length).toBeGreaterThan(0)\n            expect(typeof entry.phsym).toBe('string')\n            expect(typeof entry.pos).toBe('string')\n            expect(entry.freq).toHaveLength(2)\n            expect(entry.level).toBeDefined()\n            expect((entry.level as any).rate).toBe(3)\n            expect(entry.prons).toHaveLength(2)\n          })\n\n          expect(typeof result.contemporary[0].grammar).toBe('string')\n          expect(typeof result.contemporary[0].thesaurus).toBe('string')\n          expect(result.contemporary[0].examples).toHaveLength(3)\n          expect(result.contemporary[0].topic).toBeUndefined()\n\n          expect(typeof result.contemporary[0].collocations).toBe('string')\n          expect(typeof result.contemporary[0].thesaurus).toBe('string')\n          expect(result.contemporary[1].examples).toHaveLength(4)\n        }\n      )\n    )\n  })",
            "file": "specs/components/dictionaries/longman/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse lex result (profit) correctly",
            "suites": [
                "Dict/Longman/engine"
            ],
            "updatePoint": {
                "line": 67,
                "column": 48
            },
            "line": 67,
            "code": "  it('should parse lex result (profit) correctly', () => {\n    const profile = getDefaultProfile() as ProfileMutable\n    profile.dicts.all.longman.options = {\n      wordfams: true,\n      collocations: true,\n      grammar: true,\n      thesaurus: true,\n      examples: true,\n      bussinessFirst: false,\n      related: true\n    }\n\n    return retry(() =>\n      search('profit', getDefaultConfig(), profile, { isPDF: false }).then(\n        searchResult => {\n          expect(searchResult.audio && typeof searchResult.audio.uk).toBe(\n            'string'\n          )\n          expect(searchResult.audio && typeof searchResult.audio.us).toBe(\n            'string'\n          )\n\n          const result = searchResult.result as LongmanResultLex\n          expect(result.type).toBe('lex')\n\n          expect(result.bussinessFirst).toBe(false)\n          expect((result.wordfams as string).length).toBeGreaterThan(0)\n          expect(result.contemporary).toHaveLength(2)\n          expect(result.bussiness).toHaveLength(2)\n\n          result.contemporary.forEach(entry => {\n            expect(entry.title.HWD.length).toBeGreaterThan(0)\n            expect(entry.title.HYPHENATION.length).toBeGreaterThan(0)\n            expect(entry.title.HOMNUM.length).toBeGreaterThan(0)\n            expect(entry.senses.length).toBeGreaterThan(0)\n            expect(typeof entry.phsym).toBe('string')\n            expect(typeof entry.pos).toBe('string')\n            expect(entry.prons).toHaveLength(2)\n          })\n\n          result.bussiness.forEach(entry => {\n            expect(entry.title.HWD.length).toBeGreaterThan(0)\n            expect(entry.title.HYPHENATION.length).toBeGreaterThan(0)\n            expect(entry.title.HOMNUM.length).toBeGreaterThan(0)\n            expect(entry.senses.length).toBeGreaterThan(0)\n            expect(typeof entry.phsym).toBe('string')\n            expect(typeof entry.pos).toBe('string')\n            expect(entry.freq).toHaveLength(0)\n            expect(entry.level).toBeUndefined()\n            expect(entry.prons).toHaveLength(0)\n          })\n\n          expect(result.contemporary[0].level).toBeDefined()\n          expect((result.contemporary[0].level as any).rate).toBe(3)\n          expect(typeof result.contemporary[0].collocations).toBe('string')\n          expect(typeof result.contemporary[0].thesaurus).toBe('string')\n          expect(result.contemporary[0].freq).toHaveLength(2)\n          expect(result.contemporary[0].examples).toHaveLength(2)\n          expect(typeof result.contemporary[0].topic).toBeTruthy()\n\n          expect(result.contemporary[1].freq).toHaveLength(0)\n          expect(result.contemporary[1].examples).toHaveLength(3)\n          expect(result.contemporary[1].level).toBeDefined()\n          expect((result.contemporary[1].level as any).rate).toBe(1)\n        }\n      )\n    )\n  })",
            "file": "specs/components/dictionaries/longman/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse related result correctly",
            "suites": [
                "Dict/Longman/engine"
            ],
            "updatePoint": {
                "line": 136,
                "column": 43
            },
            "line": 136,
            "code": "  it('should parse related result correctly', () => {\n    return retry(() =>\n      search('jumblish', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {\n        expect(searchResult.audio).toBeUndefined()\n\n        const result = searchResult.result as LongmanResultRelated\n        expect(result.type).toBe('related')\n        expect(typeof result.list).toBe('string')\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/longman/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse lex result correctly",
            "suites": [
                "Dict/Macmillan/engine"
            ],
            "updatePoint": {
                "line": 11,
                "column": 39
            },
            "line": 11,
            "code": "  it('should parse lex result correctly', () => {\n    return retry(() =>\n      search('love', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {\n        expect(searchResult.audio && typeof searchResult.audio.uk).toBe(\n          'string'\n        )\n\n        const result = searchResult.result as MacmillanResultLex\n        expect(result.type).toBe('lex')\n        expect(typeof result.title).toBe('string')\n        expect(typeof result.senses).toBe('string')\n        expect(typeof result.pos).toBe('string')\n        expect(typeof result.sc).toBe('string')\n        expect(typeof result.phsym).toBe('string')\n        expect(typeof result.pron).toBe('string')\n        expect(typeof result.ratting).toBe('number')\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/macmillan/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse related result correctly",
            "suites": [
                "Dict/Macmillan/engine"
            ],
            "updatePoint": {
                "line": 33,
                "column": 43
            },
            "line": 33,
            "code": "  it('should parse related result correctly', () => {\n    return retry(() =>\n      search('jumblish', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {\n        expect(searchResult.audio).toBeUndefined()\n\n        const result = searchResult.result as MacmillanResultRelated\n        expect(result.type).toBe('related')\n        expect(typeof result.list).toBe('string')\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/macmillan/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should search zh dict",
            "suites": [
                "Dict/Naver/engine"
            ],
            "updatePoint": {
                "line": 7,
                "column": 27
            },
            "line": 7,
            "code": "  it('should search zh dict', () => {\n    return retry(() =>\n      search('爱', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {\n        expect(searchResult.result.lang).toBe('zh')\n        expect(typeof searchResult.result.entry).toBe('object')\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/naver/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should search ja dict",
            "suites": [
                "Dict/Naver/engine"
            ],
            "updatePoint": {
                "line": 18,
                "column": 27
            },
            "line": 18,
            "code": "  it('should search ja dict', () => {\n    const profile = getDefaultProfile() as ProfileMutable\n    profile.dicts.all.naver.options.hanAsJa = true\n    return retry(() =>\n      search('愛', getDefaultConfig(), profile, { isPDF: false }).then(\n        searchResult => {\n          expect(searchResult.result.lang).toBe('ja')\n          expect(typeof searchResult.result.entry).toBe('object')\n        }\n      )\n    )\n  })",
            "file": "specs/components/dictionaries/naver/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse result correctly",
            "suites": [
                "Dict/Renren/engine"
            ],
            "updatePoint": {
                "line": 7,
                "column": 35
            },
            "line": 7,
            "code": "  it('should parse result correctly', () => {\n    return retry(() =>\n      search('love', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {})\n    )\n  })",
            "file": "specs/components/dictionaries/renren/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse result correctly",
            "suites": [
                "Dict/Shanbay/engine"
            ],
            "updatePoint": {
                "line": 14,
                "column": 35
            },
            "line": 14,
            "code": "  it('should parse result correctly', () => {\n    return retry(() =>\n      search('hello', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {\n        expect(searchResult.result.title).toBe('hello')\n        expect(typeof (searchResult.audio || {}).us).toBe('string')\n        expect(searchResult.result.id).toBe('shanbay')\n        expect(isContainChinese(searchResult.result.basic || '')).toBeTruthy()\n        expect(searchResult.result.sentences.length).toBeGreaterThanOrEqual(1)\n        expect(searchResult.result.prons.length).toBeGreaterThanOrEqual(1)\n        expect(searchResult.result.prons[0].url).toEqual(\n          (searchResult.audio || {}).us\n        )\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/shanbay/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse result correctly",
            "suites": [
                "Dict/Urban/engine"
            ],
            "updatePoint": {
                "line": 7,
                "column": 35
            },
            "line": 7,
            "code": "  it('should parse result correctly', () => {\n    return retry(() =>\n      search('love', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {\n        expect(searchResult.audio && typeof searchResult.audio.us).toBe(\n          'string'\n        )\n        expect(searchResult.result.length).toBeGreaterThan(0)\n        const item = searchResult.result[0]\n        expect(typeof item.title).toBe('string')\n        expect(typeof item.pron).toBe('string')\n        expect(typeof item.meaning).toBe('string')\n        expect(typeof item.example).toBe('string')\n        expect(typeof item.contributor).toBe('string')\n        expect(typeof item.thumbsUp).toBe('string')\n        expect(typeof item.thumbsDown).toBe('string')\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/urban/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse result correctly",
            "suites": [
                "Dict/Vocabulary/engine"
            ],
            "updatePoint": {
                "line": 7,
                "column": 35
            },
            "line": 7,
            "code": "  it('should parse result correctly', () => {\n    return retry(() =>\n      search('love', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(({ result, audio }) => {\n        expect(audio).toBeUndefined()\n        expect(typeof result.long).toBe('string')\n        expect(typeof result.short).toBe('string')\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/vocabulary/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse result  correctly",
            "suites": [
                "Dict/Weblio/engine"
            ],
            "updatePoint": {
                "line": 8,
                "column": 45
            },
            "line": 8,
            "code": "    it(`should parse result ${text} correctly`, () => {\n      return retry(() =>\n        search(text, getDefaultConfig(), getDefaultProfile(), {\n          isPDF: false\n        }).then(({ result }) => {\n          expect(result.length).toBeGreaterThanOrEqual(1)\n          expect(typeof result[0].title).toBe('string')\n          expect(typeof result[0].def).toBe('string')\n        })\n      )\n    })",
            "file": "specs/components/dictionaries/weblio/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse result  correctly",
            "suites": [
                "Dict/Weblioejje/engine"
            ],
            "updatePoint": {
                "line": 8,
                "column": 45
            },
            "line": 8,
            "code": "    it(`should parse result ${text} correctly`, () => {\n      return retry(() =>\n        search(text, getDefaultConfig(), getDefaultProfile(), {\n          isPDF: false\n        }).then(({ result }) => {\n          expect(result.length).toBeGreaterThanOrEqual(1)\n          for (const { content } of result) {\n            expect(typeof content).toBe('string')\n            expect(content.length).toBeGreaterThan(1)\n          }\n        })\n      )\n    })",
            "file": "specs/components/dictionaries/weblioejje/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse lex result correctly",
            "suites": [
                "Dict/WebsterLearner/engine"
            ],
            "updatePoint": {
                "line": 10,
                "column": 39
            },
            "line": 10,
            "code": "  it('should parse lex result correctly', () => {\n    return retry(() =>\n      search('house', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {\n        expect(searchResult.audio && typeof searchResult.audio.us).toBe(\n          'string'\n        )\n\n        const result = searchResult.result as WebsterLearnerResultLex\n        expect(result.type).toBe('lex')\n        expect(result.items).toHaveLength(2)\n\n        expect(typeof result.items[0].title).toBe('string')\n        expect(result.items[0].title).toBeTruthy()\n\n        expect(typeof result.items[0].pron).toBe('string')\n        expect(result.items[0].pron).toBeTruthy()\n\n        expect(typeof result.items[0].infs).toBe('string')\n        expect(result.items[0].infs).toBeTruthy()\n\n        expect(typeof result.items[0].infsPron).toBe('string')\n        expect(result.items[0].infsPron).toBeTruthy()\n\n        expect(result.items[0].labels).toBeFalsy()\n\n        expect(typeof result.items[0].senses).toBe('string')\n        expect(result.items[0].senses).toBeTruthy()\n\n        expect(result.items[0].arts).toHaveLength(1)\n\n        expect(typeof result.items[0].phrases).toBe('string')\n        expect(result.items[0].phrases).toBeTruthy()\n\n        expect(typeof result.items[0].derived).toBe('string')\n        expect(result.items[0].derived).toBeTruthy()\n\n        // 2\n        expect(typeof result.items[1].title).toBe('string')\n        expect(result.items[1].title).toBeTruthy()\n\n        expect(typeof result.items[1].pron).toBe('string')\n        expect(result.items[1].pron).toBeTruthy()\n\n        expect(typeof result.items[1].infs).toBe('string')\n        expect(result.items[1].infs).toBeTruthy()\n\n        expect(result.items[1].infsPron).toBeFalsy()\n\n        expect(typeof result.items[1].labels).toBe('string')\n        expect(result.items[1].labels).toBeTruthy()\n\n        expect(typeof result.items[1].senses).toBe('string')\n        expect(result.items[1].senses).toBeTruthy()\n\n        expect(result.items[1].arts).toHaveLength(0)\n\n        expect(result.items[1].phrases).toBeFalsy()\n\n        expect(result.items[1].derived).toBeFalsy()\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/websterlearner/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse result correctly",
            "suites": [
                "Dict/Wikipedia/engine"
            ],
            "updatePoint": {
                "line": 7,
                "column": 35
            },
            "line": 7,
            "code": "  it('should parse result correctly', () => {\n    return retry(() =>\n      search('数字', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(({ result }) => {\n        expect(typeof result.title).toBe('string')\n        expect(typeof result.content).toBe('string')\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/wikipedia/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse lex result correctly",
            "suites": [
                "Dict/Youdao/engine"
            ],
            "updatePoint": {
                "line": 11,
                "column": 39
            },
            "line": 11,
            "code": "  it('should parse lex result correctly', () => {\n    return retry(() =>\n      search('love', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {\n        expect(searchResult.audio && typeof searchResult.audio.uk).toBe(\n          'string'\n        )\n        expect(searchResult.audio && typeof searchResult.audio.us).toBe(\n          'string'\n        )\n\n        const result = searchResult.result as YoudaoResultLex\n        expect(result.type).toBe('lex')\n        expect(result.stars).toBe(5)\n        expect(result.prons).toHaveLength(2)\n        expect(typeof result.title).toBe('string')\n        expect(result.title).toBeTruthy()\n        expect(typeof result.rank).toBe('string')\n        expect(result.rank).toBeTruthy()\n        expect(typeof result.pattern).toBe('string')\n        expect(result.pattern).toBeTruthy()\n        expect(typeof result.basic).toBe('string')\n        expect(result.basic).toBeTruthy()\n        expect(typeof result.collins).toBe('string')\n        expect(result.collins).toBeTruthy()\n        expect(typeof result.discrimination).toBe('string')\n        expect(result.discrimination).toBeTruthy()\n        expect(typeof result.sentence).toBe('string')\n        expect(result.sentence).toBeTruthy()\n        expect(result.translation).toBeFalsy()\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/youdao/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse lex result correctly when options are changed",
            "suites": [
                "Dict/Youdao/engine"
            ],
            "updatePoint": {
                "line": 46,
                "column": 64
            },
            "line": 46,
            "code": "  it('should parse lex result correctly when options are changed', () => {\n    const profile = getDefaultProfile() as ProfileMutable\n    profile.dicts.all.youdao.options = {\n      basic: false,\n      collins: false,\n      discrimination: false,\n      sentence: false,\n      translation: false,\n      related: false\n    }\n    return retry(() =>\n      search('love', getDefaultConfig(), profile, { isPDF: false }).then(\n        searchResult => {\n          expect(searchResult.audio && typeof searchResult.audio.uk).toBe(\n            'string'\n          )\n          expect(searchResult.audio && typeof searchResult.audio.us).toBe(\n            'string'\n          )\n\n          const result = searchResult.result as YoudaoResultLex\n          expect(result.type).toBe('lex')\n          expect(result.stars).toBe(5)\n          expect(result.prons).toHaveLength(2)\n          expect(typeof result.title).toBe('string')\n          expect(result.title).toBeTruthy()\n          expect(typeof result.rank).toBe('string')\n          expect(result.rank).toBeTruthy()\n          expect(typeof result.pattern).toBe('string')\n          expect(result.pattern).toBeTruthy()\n          expect(result.basic).toBeFalsy()\n          expect(result.collins).toBeFalsy()\n          expect(result.discrimination).toBeFalsy()\n          expect(result.sentence).toBeFalsy()\n          expect(result.translation).toBeFalsy()\n        }\n      )\n    )\n  })",
            "file": "specs/components/dictionaries/youdao/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse translation result correctly",
            "suites": [
                "Dict/Youdao/engine"
            ],
            "updatePoint": {
                "line": 86,
                "column": 47
            },
            "line": 86,
            "code": "  it('should parse translation result correctly', () => {\n    const text =\n      'She walks in beauty, like the night Of cloudless climes and starry skies.'\n\n    return retry(() =>\n      search(text, getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {\n        expect(!searchResult.audio || !searchResult.audio.uk).toBeTruthy()\n        expect(!searchResult.audio || !searchResult.audio.us).toBeTruthy()\n\n        const result = searchResult.result as YoudaoResultLex\n        expect(result.type).toBe('lex')\n        expect(result.stars).toBeFalsy()\n        expect(result.prons).toHaveLength(0)\n        expect(result.title).toBeFalsy()\n        expect(result.rank).toBeFalsy()\n        expect(result.pattern).toBeFalsy()\n        expect(result.basic).toBeFalsy()\n        expect(result.collins).toBeFalsy()\n        expect(result.discrimination).toBeFalsy()\n        expect(result.sentence).toBeFalsy()\n        expect(result.translation).toBeTruthy()\n        expect(typeof result.translation).toBe('string')\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/youdao/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse related result correctly",
            "suites": [
                "Dict/Youdao/engine"
            ],
            "updatePoint": {
                "line": 114,
                "column": 43
            },
            "line": 114,
            "code": "  it('should parse related result correctly', () => {\n    return retry(() =>\n      search('jumblish', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(searchResult => {\n        expect(searchResult.audio).toBeUndefined()\n\n        const result = searchResult.result as YoudaoResultRelated\n        expect(result.type).toBe('related')\n        expect(typeof result.list).toBe('string')\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/youdao/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse word result correctly",
            "suites": [
                "Dict/Zdic/engine"
            ],
            "updatePoint": {
                "line": 7,
                "column": 40
            },
            "line": 7,
            "code": "  it('should parse word result correctly', () => {\n    return retry(() =>\n      search('爱', getDefaultConfig(), getDefaultProfile(), {\n        isPDF: false\n      }).then(({ result, audio }) => {\n        expect(audio && typeof audio.py).toBeUndefined()\n        expect(result.length).toBeGreaterThan(0)\n      })\n    )\n  })",
            "file": "specs/components/dictionaries/zdic/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should parse phrase result correctly",
            "suites": [
                "Dict/Zdic/engine"
            ],
            "updatePoint": {
                "line": 18,
                "column": 42
            },
            "line": 18,
            "code": "  it('should parse phrase result correctly', () => {\n    const profile = getDefaultProfile() as ProfileMutable\n    profile.dicts.all.zdic.options.audio = true\n    return retry(() =>\n      search('沙拉', getDefaultConfig(), profile, { isPDF: false }).then(\n        ({ result, audio }) => {\n          expect(audio && typeof audio.py).toBe('string')\n          expect(result.length).toBeGreaterThan(0)\n        }\n      )\n    )\n  })",
            "file": "specs/components/dictionaries/zdic/engine.spec.ts",
            "skipped": false,
            "dir": "test"
        }
    ],
    "badge": "crimx__ext-saladict.svg"
}