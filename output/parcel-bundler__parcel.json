{"repo":"parcel-bundler/parcel","url":"https://github.com/parcel-bundler/parcel","branch":"v2","configs":[{"package":"@parcel/config-default","lang":"js","dir":"packages/configs/default/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/codeframe","lang":"js","dir":"packages/core/codeframe/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/core","lang":"js","dir":"packages/core/core/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/diagnostic","lang":"js","dir":"packages/core/diagnostic/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/graph","lang":"js","dir":"packages/core/graph/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/integration-tests","lang":"js","dir":"packages/core/integration-tests/test","framework":"mocha","pattern":"**/*.{js,ts}"},{"package":"resolver-alternative-relative-test","lang":"js","dir":"packages/core/integration-tests/test/integration/resolver-alternative-relative/test","framework":"mocha","pattern":"**/*.{js,ts}"},{"package":"@parcel/logger","lang":"js","dir":"packages/core/logger/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/markdown-ansi","lang":"js","dir":"packages/core/markdown-ansi/test","framework":"mocha","pattern":"**/*.{js,ts}"},{"package":"@parcel/package-manager","lang":"js","dir":"packages/core/package-manager/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/utils","lang":"js","dir":"packages/core/utils/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/workers","lang":"js","dir":"packages/core/workers/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/eslint-plugin","lang":"js","dir":"packages/dev/eslint-plugin/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/reporter-cli","lang":"js","dir":"packages/reporters/cli/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/babel-ast-utils","lang":"js","dir":"packages/shared/babel-ast-utils/test","framework":"mocha","pattern":"**/*.{js,ts}"},{"package":"@parcel/transformer-svg","lang":"js","dir":"packages/transformers/svg/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/babel-plugin-transform-runtime","lang":"js","dir":"packages/utils/babel-plugin-transform-runtime/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/babel-preset-env","lang":"js","dir":"packages/utils/babel-preset-env/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/events","lang":"js","dir":"packages/utils/events/test","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@parcel/fs-write-stream-atomic","lang":"js","dir":"packages/utils/fs-write-stream-atomic/test","framework":"mocha","pattern":"**/*.{js,ts}"},{"package":"@parcel/node-resolver-core","lang":"js","dir":"packages/utils/node-resolver-core/test","framework":"mocha","pattern":"**/*.{js,ts}"}],"tests":[{"name":"includes every package referenced in the config","suites":["@parcel/config-default","package.json"],"updatePoint":{"line":14,"column":55,"index":538},"line":14,"code":"    it('includes every package referenced in the config', () => {\n      let missingReferences = [];\n      for (let reference of configPackageReferences) {\n        if (!packageJsonDependencyNames.has(reference)) {\n          missingReferences.push(reference);\n        }\n      }\n\n      // Assert with deepEqual rather than e.g. missingReferences.size as the\n      // assertion message with deepEqual enumerates the differences nicely\n      assert.deepEqual(missingReferences, []);\n    });","file":"config.test.js","skipped":false,"dir":"packages/configs/default/test"},{"name":"does not include packages not referenced in the config","suites":["@parcel/config-default","package.json"],"updatePoint":{"line":26,"column":62,"index":1031},"line":26,"code":"    it('does not include packages not referenced in the config', () => {\n      let unnecessaryDependencies = [];\n      for (let dependency of packageJsonDependencyNames) {\n        if (!configPackageReferences.has(dependency)) {\n          unnecessaryDependencies.push(dependency);\n        }\n      }\n      assert.deepEqual(unnecessaryDependencies, []);\n    });","file":"config.test.js","skipped":false,"dir":"packages/configs/default/test"},{"name":"should create a codeframe","suites":["codeframe"],"updatePoint":{"line":7,"column":31,"index":232},"line":7,"code":"  it('should create a codeframe', () => {\n    let codeframeString = codeframe('hello world', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 1,\n        line: 1\n      }\n    }, {\n      start: {\n        column: 3,\n        line: 1\n      },\n      end: {\n        column: 5,\n        line: 1\n      }\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^ ^^^');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should create a codeframe with multiple lines","suites":["codeframe"],"updatePoint":{"line":33,"column":51,"index":774},"line":33,"code":"  it('should create a codeframe with multiple lines', () => {\n    let codeframeString = codeframe('hello world\\nEnjoy this nice codeframe', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 1,\n        line: 1\n      }\n    }, {\n      start: {\n        column: 7,\n        line: 1\n      },\n      end: {\n        column: 10,\n        line: 2\n      }\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^     ^^^^^');\n    assert.equal(lines[2], '> 2 | Enjoy this nice codeframe');\n    assert.equal(lines[3], '>   | ^^^^^^^^^^');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should handle unordered overlapping highlights properly","suites":["codeframe"],"updatePoint":{"line":61,"column":61,"index":1471},"line":61,"code":"  it('should handle unordered overlapping highlights properly', () => {\n    let codeframeString = codeframe('hello world\\nEnjoy this nice codeframe', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 1,\n        line: 1\n      }\n    }, {\n      start: {\n        column: 7,\n        line: 1\n      },\n      end: {\n        column: 10,\n        line: 2\n      }\n    }, {\n      start: {\n        column: 4,\n        line: 2\n      },\n      end: {\n        column: 7,\n        line: 2\n      }\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^     ^^^^^');\n    assert.equal(lines[2], '> 2 | Enjoy this nice codeframe');\n    assert.equal(lines[3], '>   | ^^^^^^^^^^');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should handle partial overlapping highlights properly","suites":["codeframe"],"updatePoint":{"line":98,"column":59,"index":2290},"line":98,"code":"  it('should handle partial overlapping highlights properly', () => {\n    let codeframeString = codeframe('hello world\\nEnjoy this nice codeframe', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 1,\n        line: 1\n      }\n    }, {\n      start: {\n        column: 7,\n        line: 1\n      },\n      end: {\n        column: 10,\n        line: 2\n      }\n    }, {\n      start: {\n        column: 4,\n        line: 2\n      },\n      end: {\n        column: 12,\n        line: 2\n      }\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^     ^^^^^');\n    assert.equal(lines[2], '> 2 | Enjoy this nice codeframe');\n    assert.equal(lines[3], '>   | ^^^^^^^^^^^^');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should be able to render inline messages","suites":["codeframe"],"updatePoint":{"line":135,"column":46,"index":3099},"line":135,"code":"  it('should be able to render inline messages', () => {\n    let codeframeString = codeframe('hello world\\nEnjoy this nice codeframe', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 6,\n        line: 1\n      },\n      message: 'test'\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^^^^^^ test');\n    assert.equal(lines[2], '  2 | Enjoy this nice codeframe');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should only render last inline message of a column","suites":["codeframe"],"updatePoint":{"line":154,"column":56,"index":3641},"line":154,"code":"  it('should only render last inline message of a column', () => {\n    let codeframeString = codeframe('hello world\\nEnjoy this nice codeframe', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 3,\n        line: 1\n      },\n      message: 'test'\n    }, {\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 6,\n        line: 1\n      },\n      message: 'this should be printed'\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^^^^^^ this should be printed');\n    assert.equal(lines[2], '  2 | Enjoy this nice codeframe');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should only render last inline message of a column with space","suites":["codeframe"],"updatePoint":{"line":183,"column":67,"index":4377},"line":183,"code":"  it('should only render last inline message of a column with space', () => {\n    let codeframeString = codeframe('hello world\\nEnjoy this nice codeframe', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 1,\n        line: 1\n      },\n      message: 'test'\n    }, {\n      start: {\n        column: 3,\n        line: 1\n      },\n      end: {\n        column: 7,\n        line: 1\n      },\n      message: 'this should be printed'\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^ ^^^^^ this should be printed');\n    assert.equal(lines[2], '  2 | Enjoy this nice codeframe');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should only render last inline message of a column with multiple lines and space","suites":["codeframe"],"updatePoint":{"line":212,"column":86,"index":5133},"line":212,"code":"  it('should only render last inline message of a column with multiple lines and space', () => {\n    let codeframeString = codeframe('hello world\\nEnjoy this nice codeframe\\nThis is another line', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 1,\n        line: 1\n      },\n      message: 'test'\n    }, {\n      start: {\n        column: 3,\n        line: 1\n      },\n      end: {\n        column: 7,\n        line: 1\n      },\n      message: 'this should be printed'\n    }, {\n      start: {\n        column: 3,\n        line: 2\n      },\n      end: {\n        column: 7,\n        line: 3\n      },\n      message: 'message line 2'\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^ ^^^^^ this should be printed');\n    assert.equal(lines[2], '> 2 | Enjoy this nice codeframe');\n    assert.equal(lines[3], '>   |   ^^^^^^^^^^^^^^^^^^^^^^^');\n    assert.equal(lines[4], '> 3 | This is another line');\n    assert.equal(lines[5], '>   | ^^^^^^^ message line 2');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should only render last inline message of a column with multiple lines and space","suites":["codeframe"],"updatePoint":{"line":254,"column":86,"index":6249},"line":254,"code":"  it('should only render last inline message of a column with multiple lines and space', () => {\n    let codeframeString = codeframe('hello world\\nEnjoy this nice codeframe\\nThis is another line', [{\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 1,\n        line: 1\n      },\n      message: 'test'\n    }, {\n      start: {\n        column: 3,\n        line: 1\n      },\n      end: {\n        column: 7,\n        line: 1\n      },\n      message: 'this should be printed'\n    }, {\n      start: {\n        column: 3,\n        line: 2\n      },\n      end: {\n        column: 7,\n        line: 3\n      },\n      message: 'message line 2'\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hello world');\n    assert.equal(lines[1], '>   | ^ ^^^^^ this should be printed');\n    assert.equal(lines[2], '> 2 | Enjoy this nice codeframe');\n    assert.equal(lines[3], '>   |   ^^^^^^^^^^^^^^^^^^^^^^^');\n    assert.equal(lines[4], '> 3 | This is another line');\n    assert.equal(lines[5], '>   | ^^^^^^^ message line 2');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should properly use padding","suites":["codeframe"],"updatePoint":{"line":296,"column":33,"index":7312},"line":296,"code":"  it('should properly use padding', () => {\n    let codeframeString = codeframe('test\\n'.repeat(100), [{\n      start: {\n        column: 2,\n        line: 5\n      },\n      end: {\n        column: 2,\n        line: 5\n      },\n      message: 'test'\n    }], {\n      useColor: false,\n      padding: {\n        before: 2,\n        after: 4\n      }\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 8);\n    assert.equal(lines[0], '  3 | test');\n    assert.equal(lines[2], '> 5 | test');\n    assert.equal(lines[3], '>   |  ^ test');\n    assert.equal(lines[7], '  9 | test');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should properly pad numbers for large files","suites":["codeframe"],"updatePoint":{"line":321,"column":49,"index":7934},"line":321,"code":"  it('should properly pad numbers for large files', () => {\n    let codeframeString = codeframe('test\\n'.repeat(1000), [{\n      start: {\n        column: 2,\n        line: 99\n      },\n      end: {\n        column: 2,\n        line: 99\n      },\n      message: 'test'\n    }, {\n      start: {\n        column: 2,\n        line: 100\n      },\n      end: {\n        column: 2,\n        line: 100\n      },\n      message: 'test 2'\n    }]);\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 7);\n    assert.equal(lines[0], '   98 | test');\n    assert.equal(lines[1], '>  99 | test');\n    assert.equal(lines[2], '>     |  ^ test');\n    assert.equal(lines[3], '> 100 | test');\n    assert.equal(lines[4], '>     |  ^ test 2');\n    assert.equal(lines[5], '  101 | test');\n    assert.equal(lines[6], '  102 | test');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should properly pad numbers for short files","suites":["codeframe"],"updatePoint":{"line":353,"column":49,"index":8764},"line":353,"code":"  it('should properly pad numbers for short files', () => {\n    let codeframeString = codeframe('test\\n'.repeat(1000), [{\n      start: {\n        column: 2,\n        line: 7\n      },\n      end: {\n        column: 2,\n        line: 7\n      },\n      message: 'test'\n    }, {\n      start: {\n        column: 2,\n        line: 12\n      },\n      end: {\n        column: 2,\n        line: 12\n      },\n      message: 'test'\n    }]);\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 11);\n    assert.equal(lines[0], '   6 | test');\n    assert.equal(lines[4], '   9 | test');\n    assert.equal(lines[5], '  10 | test');\n    assert.equal(lines[6], '  11 | test');\n    assert.equal(lines[10], '  14 | test');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should properly use maxLines","suites":["codeframe"],"updatePoint":{"line":383,"column":34,"index":9474},"line":383,"code":"  it('should properly use maxLines', () => {\n    let line = 'test '.repeat(100);\n    let codeframeString = codeframe(`${line}\\n`.repeat(100), [{\n      start: {\n        column: 2,\n        line: 5\n      },\n      end: {\n        column: 2,\n        line: 5\n      },\n      message: 'test'\n    }, {\n      start: {\n        column: 2,\n        line: 12\n      },\n      end: {\n        column: 2,\n        line: 20\n      },\n      message: 'test'\n    }], {\n      useColor: false,\n      maxLines: 10,\n      terminalWidth: 5\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 13);\n    assert.equal(lines[0], '   4 | test test ');\n    assert.equal(lines[7], '  10 | test test ');\n    assert.equal(lines[11], '> 13 | test test ');\n    assert.equal(lines[12], '>    | ^^^^^^^^^^');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should be able to handle tabs","suites":["codeframe"],"updatePoint":{"line":417,"column":35,"index":10280},"line":417,"code":"  it('should be able to handle tabs', () => {\n    let codeframeString = codeframe('hel\\tlo wor\\tld\\nEnjoy thi\\ts nice cod\\teframe', [{\n      start: {\n        column: 5,\n        line: 1\n      },\n      end: {\n        column: 8,\n        line: 1\n      },\n      message: 'test'\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hel  lo wor  ld');\n    assert.equal(lines[1], '>   |      ^^^^ test');\n    assert.equal(lines[2], '  2 | Enjoy thi  s nice cod  eframe');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"should be able to handle tabs with multiple highlights","suites":["codeframe"],"updatePoint":{"line":436,"column":60,"index":10845},"line":436,"code":"  it('should be able to handle tabs with multiple highlights', () => {\n    let codeframeString = codeframe('hel\\tlo wor\\tld\\nEnjoy thi\\ts nice cod\\teframe', [{\n      start: {\n        column: 3,\n        line: 1\n      },\n      end: {\n        column: 5,\n        line: 1\n      },\n      message: 'test'\n    }, {\n      start: {\n        column: 7,\n        line: 1\n      },\n      end: {\n        column: 8,\n        line: 1\n      },\n      message: 'test'\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hel  lo wor  ld');\n    assert.equal(lines[1], '>   |   ^^^^ ^^ test');\n    assert.equal(lines[2], '  2 | Enjoy thi  s nice cod  eframe');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"multiline highlights with tabs","suites":["codeframe"],"updatePoint":{"line":465,"column":36,"index":11533},"line":465,"code":"  it('multiline highlights with tabs', () => {\n    let codeframeString = codeframe('hel\\tlo wor\\tld\\nEnjoy thi\\ts nice cod\\teframe\\ntest', [{\n      start: {\n        column: 3,\n        line: 1\n      },\n      end: {\n        column: 2,\n        line: 3\n      },\n      message: 'test'\n    }], {\n      useColor: false\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines[0], '> 1 | hel  lo wor  ld');\n    assert.equal(lines[1], '>   |   ^^^^^^^^^^^^^');\n    assert.equal(lines[2], '> 2 | Enjoy thi  s nice cod  eframe');\n    assert.equal(lines[3], '>   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^');\n    assert.equal(lines[4], '> 3 | test');\n    assert.equal(lines[5], '>   | ^^ test');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"Should truncate long lines and print message","suites":["codeframe"],"updatePoint":{"line":487,"column":50,"index":12249},"line":487,"code":"  it('Should truncate long lines and print message', () => {\n    let originalLine = 'hello world '.repeat(1000);\n    let codeframeString = codeframe(originalLine, [{\n      start: {\n        column: 1000,\n        line: 1\n      },\n      end: {\n        column: 1200,\n        line: 1\n      },\n      message: 'This is a message'\n    }], {\n      useColor: false,\n      terminalWidth: 25\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 2);\n    assert.equal(lines[0], '> 1 | d hello world hello');\n    assert.equal(lines[1], '>   |      ^^^^^^^^^^^^^^ This is a message');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"Truncation across multiple lines","suites":["codeframe"],"updatePoint":{"line":508,"column":38,"index":12847},"line":508,"code":"  it('Truncation across multiple lines', () => {\n    let originalLine = 'hello world '.repeat(100) + '\\n' + 'new line '.repeat(100);\n    let codeframeString = codeframe(originalLine, [{\n      start: {\n        column: 15,\n        line: 1\n      },\n      end: {\n        column: 400,\n        line: 1\n      },\n      message: 'This is the first line'\n    }, {\n      start: {\n        column: 2,\n        line: 2\n      },\n      end: {\n        column: 100,\n        line: 2\n      },\n      message: 'This is the second line'\n    }], {\n      useColor: false,\n      terminalWidth: 25\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 4);\n    assert.equal(lines[0], '> 1 | ld hello world hell');\n    assert.equal(lines[1], '>   |      ^^^^^^^^^^^^^^ This is the first line');\n    assert.equal(lines[2], '> 2 | new line new line n');\n    assert.equal(lines[3], '>   |  ^^^^^^^^^^^^^^^^^^ This is the second line');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"Truncation across various types and positions of highlights","suites":["codeframe"],"updatePoint":{"line":541,"column":65,"index":13817},"line":541,"code":"  it('Truncation across various types and positions of highlights', () => {\n    let originalLine = 'hello world '.repeat(100) + '\\n' + 'new line '.repeat(100);\n    let codeframeString = codeframe(originalLine, [{\n      start: {\n        column: 2,\n        line: 1\n      },\n      end: {\n        column: 5,\n        line: 1\n      }\n    }, {\n      start: {\n        column: 6,\n        line: 1\n      },\n      end: {\n        column: 10,\n        line: 1\n      },\n      message: 'I have a message'\n    }, {\n      start: {\n        column: 15,\n        line: 1\n      },\n      end: {\n        column: 25,\n        line: 1\n      },\n      message: 'I also have a message'\n    }, {\n      start: {\n        column: 2,\n        line: 2\n      },\n      end: {\n        column: 5,\n        line: 2\n      },\n      message: 'This is the second line'\n    }], {\n      useColor: false,\n      terminalWidth: 25\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 4);\n    assert.equal(lines[0], '> 1 | hello world hello w');\n    assert.equal(lines[1], '>   |  ^^^^^^^^^    ^^^^^ I also have a message');\n    assert.equal(lines[2], '> 2 | new line new line n');\n    assert.equal(lines[3], '>   |  ^^^^ This is the second line');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"Multi-line highlight w/ truncation","suites":["codeframe"],"updatePoint":{"line":593,"column":40,"index":15027},"line":593,"code":"  it('Multi-line highlight w/ truncation', () => {\n    let originalLine = 'hello world '.repeat(100) + '\\n' + 'new line '.repeat(100);\n    let codeframeString = codeframe(originalLine, [{\n      start: {\n        column: 2,\n        line: 1\n      },\n      end: {\n        column: 151,\n        line: 2\n      },\n      message: 'I have a message'\n    }], {\n      useColor: false,\n      terminalWidth: 25\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 4);\n    assert.equal(lines[0], '> 1 | hello world hello w');\n    assert.equal(lines[1], '>   |  ^^^^^^^^^^^^^^^^^^');\n    assert.equal(lines[2], '> 2 | ew line new line ne');\n    assert.equal(lines[3], '>   | ^^^^^^ I have a message');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"Should pad properly, T-650","suites":["codeframe"],"updatePoint":{"line":616,"column":32,"index":15746},"line":616,"code":"  it('Should pad properly, T-650', () => {\n    let fileContent = readFileSync(joinPath(__dirname, './fixtures/a.js'), 'utf8');\n    let codeframeString = codeframe(fileContent, [{\n      start: {\n        line: 8,\n        column: 10\n      },\n      end: {\n        line: 8,\n        column: 48\n      }\n    }], {\n      useColor: false,\n      syntaxHighlighting: false,\n      language: 'js',\n      terminalWidth: 100\n    });\n    let lines = codeframeString.split(LINE_END);\n    assert.equal(lines.length, 5);\n    assert.equal(lines[0], `   7 | import Tooltip from '../tooltip';`);\n    assert.equal(lines[1], `>  8 | import VisuallyHidden from '../visually-hidden';`);\n    assert.equal(lines[2], '>    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^');\n    assert.equal(lines[3], '   9 | ');\n    assert.equal(lines[4], '  10 | /**');\n  });","file":"codeframe.test.js","skipped":false,"dir":"packages/core/codeframe/test"},{"name":"initialization should create one root node with edges to entry_specifier nodes for each entry","suites":["AssetGraph"],"updatePoint":{"line":24,"column":99,"index":859},"line":24,"code":"  it('initialization should create one root node with edges to entry_specifier nodes for each entry', () => {\n    let graph = new AssetGraph();\n    graph.setRootConnections({\n      entries: [toProjectPath('/path/to/index1'), toProjectPath('/path/to/index2')]\n    });\n    assert(graph.hasNode(nullthrows(graph.rootNodeId)));\n    assert(graph.hasContentKey('entry_specifier:path/to/index1'));\n    assert(graph.hasContentKey('entry_specifier:path/to/index2'));\n  });","file":"AssetGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolveEntry should connect an entry_specifier node to entry_file nodes","suites":["AssetGraph"],"updatePoint":{"line":33,"column":77,"index":1301},"line":33,"code":"  it('resolveEntry should connect an entry_specifier node to entry_file nodes', () => {\n    let graph = new AssetGraph();\n    graph.setRootConnections({\n      entries: [toProjectPath('/path/to/index1'), toProjectPath('/path/to/index2')]\n    });\n    graph.resolveEntry(toProjectPath('/path/to/index1'), [{\n      filePath: toProjectPath('/path/to/index1/src/main.js'),\n      packagePath: toProjectPath('/path/to/index1')\n    }], '123');\n    assert(graph.hasContentKey(nodeFromEntryFile({\n      filePath: toProjectPath('/path/to/index1/src/main.js'),\n      packagePath: toProjectPath('/path/to/index1')\n    }).id));\n    assert(graph.hasEdge(graph.getNodeIdByContentKey('entry_specifier:path/to/index1'), graph.getNodeIdByContentKey(nodeFromEntryFile({\n      filePath: toProjectPath('/path/to/index1/src/main.js'),\n      packagePath: toProjectPath('/path/to/index1')\n    }).id)));\n  });","file":"AssetGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolveTargets should connect an entry_file node to dependencies for each target","suites":["AssetGraph"],"updatePoint":{"line":51,"column":86,"index":2193},"line":51,"code":"  it('resolveTargets should connect an entry_file node to dependencies for each target', () => {\n    let graph = new AssetGraph();\n    graph.setRootConnections({\n      entries: [toProjectPath('/path/to/index1'), toProjectPath('/path/to/index2')]\n    });\n    graph.resolveEntry(toProjectPath('/path/to/index1'), [{\n      filePath: toProjectPath('/path/to/index1/src/main.js'),\n      packagePath: toProjectPath('/path/to/index1')\n    }], '1');\n    graph.resolveEntry(toProjectPath('/path/to/index2'), [{\n      filePath: toProjectPath('/path/to/index2/src/main.js'),\n      packagePath: toProjectPath('/path/to/index2')\n    }], '2');\n    graph.resolveTargets({\n      filePath: toProjectPath('/path/to/index1/src/main.js'),\n      packagePath: toProjectPath('/path/to/index1')\n    }, DEFAULT_TARGETS, '3');\n    graph.resolveTargets({\n      filePath: toProjectPath('/path/to/index2/src/main.js'),\n      packagePath: toProjectPath('/path/to/index2')\n    }, DEFAULT_TARGETS, '4');\n    assert(graph.hasContentKey(createDependency({\n      specifier: 'path/to/index1/src/main.js',\n      specifierType: 'esm',\n      target: DEFAULT_TARGETS[0],\n      env: DEFAULT_ENV\n    }).id));\n    assert(graph.hasContentKey(createDependency({\n      specifier: 'path/to/index2/src/main.js',\n      specifierType: 'esm',\n      target: DEFAULT_TARGETS[0],\n      env: DEFAULT_ENV\n    }).id));\n    assert.deepEqual(Array.from(graph.getAllEdges()), [{\n      from: graph.rootNodeId,\n      to: graph.getNodeIdByContentKey('entry_specifier:path/to/index1'),\n      type: 1\n    }, {\n      from: graph.rootNodeId,\n      to: graph.getNodeIdByContentKey('entry_specifier:path/to/index2'),\n      type: 1\n    }, {\n      from: graph.getNodeIdByContentKey('entry_specifier:path/to/index1'),\n      to: graph.getNodeIdByContentKey(nodeFromEntryFile({\n        filePath: toProjectPath('/path/to/index1/src/main.js'),\n        packagePath: toProjectPath('/path/to/index1')\n      }).id),\n      type: 1\n    }, {\n      from: graph.getNodeIdByContentKey('entry_specifier:path/to/index2'),\n      to: graph.getNodeIdByContentKey(nodeFromEntryFile({\n        filePath: toProjectPath('/path/to/index2/src/main.js'),\n        packagePath: toProjectPath('/path/to/index2')\n      }).id),\n      type: 1\n    }, {\n      from: graph.getNodeIdByContentKey(nodeFromEntryFile({\n        filePath: toProjectPath('/path/to/index1/src/main.js'),\n        packagePath: toProjectPath('/path/to/index1')\n      }).id),\n      to: graph.getNodeIdByContentKey(createDependency({\n        specifier: 'path/to/index1/src/main.js',\n        specifierType: 'esm',\n        target: DEFAULT_TARGETS[0],\n        env: DEFAULT_ENV\n      }).id),\n      type: 1\n    }, {\n      from: graph.getNodeIdByContentKey(nodeFromEntryFile({\n        filePath: toProjectPath('/path/to/index2/src/main.js'),\n        packagePath: toProjectPath('/path/to/index2')\n      }).id),\n      to: graph.getNodeIdByContentKey(createDependency({\n        specifier: 'path/to/index2/src/main.js',\n        specifierType: 'esm',\n        target: DEFAULT_TARGETS[0],\n        env: DEFAULT_ENV\n      }).id),\n      type: 1\n    }]);\n  });","file":"AssetGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolveDependency should update the file a dependency is connected to","suites":["AssetGraph"],"updatePoint":{"line":132,"column":75,"index":5287},"line":132,"code":"  it('resolveDependency should update the file a dependency is connected to', () => {\n    let graph = new AssetGraph();\n    graph.setRootConnections({\n      targets: DEFAULT_TARGETS,\n      entries: [toProjectPath('/path/to/index')]\n    });\n    graph.resolveEntry(toProjectPath('/path/to/index'), [{\n      filePath: toProjectPath('/path/to/index/src/main.js'),\n      packagePath: toProjectPath('/path/to/index')\n    }], '1');\n    graph.resolveTargets({\n      filePath: toProjectPath('/path/to/index/src/main.js'),\n      packagePath: toProjectPath('/path/to/index')\n    }, DEFAULT_TARGETS, '2');\n    let dep = createDependency({\n      specifier: 'path/to/index/src/main.js',\n      specifierType: 'esm',\n      target: DEFAULT_TARGETS[0],\n      env: DEFAULT_ENV\n    });\n    let req = {\n      filePath: toProjectPath('/index.js'),\n      env: DEFAULT_ENV\n    };\n    graph.resolveDependency(dep, req, '3');\n    let assetGroupNodeId = graph.getNodeIdByContentKey(nodeFromAssetGroup(req).id);\n    let dependencyNodeId = graph.getNodeIdByContentKey(dep.id);\n    assert(graph.nodes.has(assetGroupNodeId));\n    assert(graph.hasEdge(dependencyNodeId, assetGroupNodeId));\n    let req2 = {\n      filePath: toProjectPath('/index.jsx'),\n      env: DEFAULT_ENV\n    };\n    graph.resolveDependency(dep, req2, '4');\n    let assetGroupNodeId2 = graph.getNodeIdByContentKey(nodeFromAssetGroup(req2).id);\n    assert(!graph.nodes.has(assetGroupNodeId));\n    assert(graph.nodes.has(assetGroupNodeId2));\n    assert(graph.hasEdge(dependencyNodeId, assetGroupNodeId2));\n    assert(!graph.hasEdge(dependencyNodeId, assetGroupNodeId));\n    graph.resolveDependency(dep, req2, '5');\n    assert(graph.nodes.has(assetGroupNodeId2));\n    assert(graph.hasEdge(dependencyNodeId, assetGroupNodeId2));\n  });","file":"AssetGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolveAssetGroup should update the asset and dep nodes a file is connected to","suites":["AssetGraph"],"updatePoint":{"line":175,"column":84,"index":7064},"line":175,"code":"  it('resolveAssetGroup should update the asset and dep nodes a file is connected to', () => {\n    let graph = new AssetGraph();\n    graph.setRootConnections({\n      targets: DEFAULT_TARGETS,\n      entries: [toProjectPath('/path/to/index')]\n    });\n    graph.resolveEntry(toProjectPath('/path/to/index'), [{\n      filePath: toProjectPath('/path/to/index/src/main.js'),\n      packagePath: toProjectPath('/path/to/index')\n    }], '1');\n    graph.resolveTargets({\n      filePath: toProjectPath('/path/to/index/src/main.js'),\n      packagePath: toProjectPath('/path/to/index')\n    }, DEFAULT_TARGETS, '2');\n    let dep = createDependency({\n      specifier: 'path/to/index/src/main.js',\n      specifierType: 'esm',\n      target: DEFAULT_TARGETS[0],\n      env: DEFAULT_ENV,\n      sourcePath: ''\n    });\n    let sourcePath = '/index.js';\n    let filePath = toProjectPath(sourcePath);\n    let req = {\n      filePath,\n      env: DEFAULT_ENV\n    };\n    graph.resolveDependency(dep, req, '3');\n    let assets = [createAsset({\n      id: '1',\n      filePath,\n      type: 'js',\n      isSource: true,\n      hash: '#1',\n      stats,\n      dependencies: new Map([['utils', createDependency({\n        specifier: './utils',\n        specifierType: 'esm',\n        env: DEFAULT_ENV,\n        sourcePath\n      })]]),\n      env: DEFAULT_ENV\n    }), createAsset({\n      id: '2',\n      filePath,\n      type: 'js',\n      isSource: true,\n      hash: '#2',\n      stats,\n      dependencies: new Map([['styles', createDependency({\n        specifier: './styles',\n        specifierType: 'esm',\n        env: DEFAULT_ENV,\n        sourcePath\n      })]]),\n      env: DEFAULT_ENV\n    }), createAsset({\n      id: '3',\n      filePath,\n      type: 'js',\n      isSource: true,\n      hash: '#3',\n      dependencies: new Map(),\n      env: DEFAULT_ENV,\n      stats\n    })];\n    graph.resolveAssetGroup(req, assets, '4');\n    let nodeId1 = graph.getNodeIdByContentKey('1');\n    let nodeId2 = graph.getNodeIdByContentKey('2');\n    let nodeId3 = graph.getNodeIdByContentKey('3');\n    let assetGroupNode = graph.getNodeIdByContentKey(nodeFromAssetGroup(req).id);\n    let dependencyNodeId1 = graph.getNodeIdByContentKey([...assets[0].dependencies.values()][0].id);\n    let dependencyNodeId2 = graph.getNodeIdByContentKey([...assets[1].dependencies.values()][0].id);\n    assert(graph.nodes.has(nodeId1));\n    assert(graph.nodes.has(nodeId2));\n    assert(graph.nodes.has(nodeId3));\n    assert(graph.nodes.has(dependencyNodeId1));\n    assert(graph.nodes.has(dependencyNodeId2));\n    assert(graph.hasEdge(assetGroupNode, nodeId1));\n    assert(graph.hasEdge(assetGroupNode, nodeId2));\n    assert(graph.hasEdge(assetGroupNode, nodeId3));\n    assert(graph.hasEdge(nodeId1, dependencyNodeId1));\n    assert(graph.hasEdge(nodeId2, dependencyNodeId2));\n    let assets2 = [createAsset({\n      id: '1',\n      filePath,\n      type: 'js',\n      isSource: true,\n      hash: '#1',\n      stats,\n      dependencies: new Map([['utils', createDependency({\n        specifier: './utils',\n        specifierType: 'esm',\n        env: DEFAULT_ENV,\n        sourcePath\n      })]]),\n      env: DEFAULT_ENV\n    }), createAsset({\n      id: '2',\n      filePath,\n      type: 'js',\n      isSource: true,\n      hash: '#2',\n      stats,\n      dependencies: new Map(),\n      env: DEFAULT_ENV\n    })];\n    graph.resolveAssetGroup(req, assets2, '5');\n    assert(graph.nodes.has(nodeId1));\n    assert(graph.nodes.has(nodeId2));\n    assert(!graph.nodes.has(nodeId3));\n    assert(graph.nodes.has(dependencyNodeId1));\n    assert(!graph.nodes.has(dependencyNodeId2));\n    assert(graph.hasEdge(assetGroupNode, nodeId1));\n    assert(graph.hasEdge(assetGroupNode, nodeId2));\n    assert(!graph.hasEdge(assetGroupNode, nodeId3));\n    assert(graph.hasEdge(nodeId1, dependencyNodeId1));\n    assert(!graph.hasEdge(nodeId2, dependencyNodeId2));\n  });","file":"AssetGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolveAssetGroup should handle dependent assets in asset groups","suites":["AssetGraph"],"updatePoint":{"line":298,"column":70,"index":11164},"line":298,"code":"  it('resolveAssetGroup should handle dependent assets in asset groups', () => {\n    let graph = new AssetGraph();\n    graph.setRootConnections({\n      targets: DEFAULT_TARGETS,\n      entries: [toProjectPath('/index')]\n    });\n    graph.resolveEntry(toProjectPath('/index'), [{\n      filePath: toProjectPath('/path/to/index/src/main.js'),\n      packagePath: toProjectPath('/path/to/index')\n    }], '1');\n    graph.resolveTargets({\n      filePath: toProjectPath('/path/to/index/src/main.js'),\n      packagePath: toProjectPath('/path/to/index')\n    }, DEFAULT_TARGETS, '2');\n    let dep = createDependency({\n      specifier: 'path/to/index/src/main.js',\n      specifierType: 'esm',\n      env: DEFAULT_ENV,\n      target: DEFAULT_TARGETS[0]\n    });\n    let sourcePath = '/index.js';\n    let filePath = toProjectPath(sourcePath);\n    let req = {\n      filePath,\n      env: DEFAULT_ENV\n    };\n    graph.resolveDependency(dep, req, '123');\n    let dep1 = createDependency({\n      specifier: 'dependent-asset-1',\n      specifierType: 'esm',\n      env: DEFAULT_ENV,\n      sourcePath\n    });\n    let dep2 = createDependency({\n      specifier: 'dependent-asset-2',\n      specifierType: 'esm',\n      env: DEFAULT_ENV,\n      sourcePath\n    });\n    let assets = [createAsset({\n      id: '1',\n      filePath,\n      type: 'js',\n      isSource: true,\n      hash: '#1',\n      stats,\n      dependencies: new Map([['dep1', dep1]]),\n      env: DEFAULT_ENV\n    }), createAsset({\n      id: '2',\n      uniqueKey: 'dependent-asset-1',\n      filePath,\n      type: 'js',\n      isSource: true,\n      hash: '#1',\n      stats,\n      dependencies: new Map([['dep2', dep2]]),\n      env: DEFAULT_ENV\n    }), createAsset({\n      id: '3',\n      uniqueKey: 'dependent-asset-2',\n      filePath,\n      type: 'js',\n      isSource: true,\n      hash: '#1',\n      stats,\n      env: DEFAULT_ENV\n    })];\n    graph.resolveAssetGroup(req, assets, '3');\n    let nodeId1 = graph.getNodeIdByContentKey('1');\n    let nodeId2 = graph.getNodeIdByContentKey('2');\n    let nodeId3 = graph.getNodeIdByContentKey('3');\n    let assetGroupNodeId = graph.getNodeIdByContentKey(nodeFromAssetGroup(req).id);\n    let depNodeId1 = graph.getNodeIdByContentKey(nodeFromDep(dep1).id);\n    let depNodeId2 = graph.getNodeIdByContentKey(nodeFromDep(dep2).id);\n    assert(nodeId1);\n    assert(nodeId2);\n    assert(nodeId3);\n    assert(graph.hasEdge(assetGroupNodeId, nodeId1));\n    assert(!graph.hasEdge(assetGroupNodeId, nodeId2));\n    assert(!graph.hasEdge(assetGroupNodeId, nodeId3));\n    assert(graph.hasEdge(nodeId1, depNodeId1));\n    assert(graph.hasEdge(depNodeId1, nodeId2));\n    assert(graph.hasEdge(nodeId2, depNodeId2));\n    assert(graph.hasEdge(depNodeId2, nodeId3));\n  });","file":"AssetGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should support marking and unmarking all parents with hasDeferred","suites":["AssetGraph"],"updatePoint":{"line":384,"column":71,"index":13882},"line":384,"code":"  it('should support marking and unmarking all parents with hasDeferred', () => {\n    let graph = new AssetGraph();\n\n    // index\n    let indexAssetGroup = {\n      filePath: toProjectPath('/index.js'),\n      env: DEFAULT_ENV\n    };\n    graph.setRootConnections({\n      assetGroups: [indexAssetGroup]\n    });\n    let indexFooDep = createDependency({\n      specifier: './foo',\n      specifierType: 'esm',\n      env: DEFAULT_ENV,\n      sourcePath: '/index.js'\n    });\n    let indexBarDep = createDependency({\n      specifier: './bar',\n      specifierType: 'esm',\n      env: DEFAULT_ENV,\n      sourcePath: '/index.js'\n    });\n    let indexAsset = createAsset({\n      id: 'assetIndex',\n      filePath: toProjectPath('/index.js'),\n      type: 'js',\n      isSource: true,\n      hash: '#4',\n      stats,\n      dependencies: new Map([['./foo', indexFooDep], ['./bar', indexBarDep]]),\n      env: DEFAULT_ENV\n    });\n    graph.resolveAssetGroup(indexAssetGroup, [indexAsset], '0');\n\n    // index imports foo\n    let fooAssetGroup = {\n      filePath: toProjectPath('/foo.js'),\n      env: DEFAULT_ENV\n    };\n    graph.resolveDependency(indexFooDep, fooAssetGroup, '0');\n    let fooAssetGroupNode = nodeFromAssetGroup(fooAssetGroup);\n    let fooUtilsDep = createDependency({\n      specifier: './utils',\n      specifierType: 'esm',\n      env: DEFAULT_ENV,\n      sourcePath: '/foo.js'\n    });\n    let fooUtilsDepNode = nodeFromDep(fooUtilsDep);\n    let fooAsset = createAsset({\n      id: 'assetFoo',\n      filePath: toProjectPath('/foo.js'),\n      type: 'js',\n      isSource: true,\n      hash: '#1',\n      stats,\n      dependencies: new Map([['./utils', fooUtilsDep]]),\n      env: DEFAULT_ENV\n    });\n    let fooAssetNode = nodeFromAsset(fooAsset);\n    graph.resolveAssetGroup(fooAssetGroup, [fooAsset], '0');\n    let utilsAssetGroup = {\n      filePath: toProjectPath('/utils.js'),\n      env: DEFAULT_ENV\n    };\n    let utilsAssetGroupNode = nodeFromAssetGroup(utilsAssetGroup);\n    graph.resolveDependency(fooUtilsDep, utilsAssetGroup, '0');\n\n    // foo's dependency is deferred\n    graph.markParentsWithHasDeferred(graph.getNodeIdByContentKey(fooUtilsDepNode.id));\n    let node = nullthrows(graph.getNodeByContentKey(fooAssetNode.id));\n    invariant(node.type === 'asset');\n    assert(node.hasDeferred);\n    node = nullthrows(graph.getNodeByContentKey(fooAssetGroupNode.id));\n    invariant(node.type === 'asset_group');\n    assert(node.hasDeferred);\n\n    // index also imports bar\n    let barAssetGroup = {\n      filePath: toProjectPath('/bar.js'),\n      env: DEFAULT_ENV\n    };\n    graph.resolveDependency(indexBarDep, barAssetGroup, '0');\n    let barAssetGroupNode = nodeFromAssetGroup(barAssetGroup);\n    let barUtilsDep = createDependency({\n      specifier: './utils',\n      specifierType: 'esm',\n      env: DEFAULT_ENV,\n      sourcePath: '/bar.js'\n    });\n    let barAsset = createAsset({\n      id: 'assetBar',\n      filePath: toProjectPath('/bar.js'),\n      type: 'js',\n      isSource: true,\n      hash: '#2',\n      stats,\n      dependencies: new Map([['./utils', barUtilsDep]]),\n      env: DEFAULT_ENV\n    });\n    let barAssetNode = nodeFromAsset(barAsset);\n    graph.resolveAssetGroup(barAssetGroup, [barAsset], '3');\n    graph.resolveDependency(barUtilsDep, utilsAssetGroup, '4');\n\n    // bar undeferres utils\n    graph.unmarkParentsWithHasDeferred(graph.getNodeIdByContentKey(utilsAssetGroupNode.id));\n    node = nullthrows(graph.getNodeByContentKey(fooUtilsDep.id));\n    invariant(node.type === 'dependency');\n    assert(!node.hasDeferred);\n    node = nullthrows(graph.getNodeByContentKey(fooAssetNode.id));\n    invariant(node.type === 'asset');\n    assert(!node.hasDeferred);\n    node = nullthrows(graph.getNodeByContentKey(fooAssetGroupNode.id));\n    invariant(node.type === 'asset_group');\n    assert(!node.hasDeferred);\n    node = nullthrows(graph.getNodeByContentKey(barUtilsDep.id));\n    invariant(node.type === 'dependency');\n    assert(!node.hasDeferred);\n    node = nullthrows(graph.getNodeByContentKey(barAssetNode.id));\n    invariant(node.type === 'asset');\n    assert(!node.hasDeferred);\n    node = nullthrows(graph.getNodeByContentKey(barAssetGroupNode.id));\n    invariant(node.type === 'asset_group');\n    assert(!node.hasDeferred);\n  });","file":"AssetGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"assigns publicIds to assets","suites":["BundleGraph"],"updatePoint":{"line":19,"column":33,"index":700},"line":19,"code":"  it('assigns publicIds to assets', () => {\n    let bundleGraph = BundleGraph.fromAssetGraph(createMockAssetGraph([id1, id2]));\n    assert.deepEqual(getAssets(bundleGraph).map(a => bundleGraph.getAssetPublicId(a)), ['296TI', '4DGUq']);\n  });","file":"BundleGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"uses a longer publicId if there is a collision","suites":["BundleGraph"],"updatePoint":{"line":23,"column":52,"index":961},"line":23,"code":"  it('uses a longer publicId if there is a collision', () => {\n    let bundleGraph = BundleGraph.fromAssetGraph(createMockAssetGraph([id1, id1.slice(0, 16) + '7' + id1.slice(17)]));\n    assert.deepEqual(getAssets(bundleGraph).map(a => bundleGraph.getAssetPublicId(a)), ['296TI', '296TII']);\n  });","file":"BundleGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects missing source in package.json","suites":["EntryResolver"],"updatePoint":{"line":23,"column":44,"index":1019},"line":23,"code":"  it('rejects missing source in package.json', async function () {\n    this.timeout(10000);\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => entryResolver.resolveEntry(INVALID_SOURCE_MISSING_FIXTURE_PATH), {\n      diagnostics: [{\n        origin: '@parcel/core',\n        message: md`${path.join(path.relative(fs.cwd(), INVALID_SOURCE_MISSING_FIXTURE_PATH), 'missing.js')} does not exist.`,\n        codeFrames: [{\n          filePath: path.join(INVALID_SOURCE_MISSING_FIXTURE_PATH, 'package.json'),\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 4,\n              column: 13\n            },\n            end: {\n              line: 4,\n              column: 24\n            }\n          }]\n        }],\n        hints: []\n      }]\n    });\n  });","file":"EntryRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects non-file source in package.json","suites":["EntryResolver"],"updatePoint":{"line":48,"column":45,"index":1835},"line":48,"code":"  it('rejects non-file source in package.json', async function () {\n    this.timeout(10000);\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => entryResolver.resolveEntry(INVALID_SOURCE_NOT_FILE_FIXTURE_PATH), {\n      diagnostics: [{\n        origin: '@parcel/core',\n        message: md`${path.join(path.relative(fs.cwd(), INVALID_SOURCE_NOT_FILE_FIXTURE_PATH), 'src')} is not a file.`,\n        codeFrames: [{\n          filePath: path.join(INVALID_SOURCE_NOT_FILE_FIXTURE_PATH, 'package.json'),\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 4,\n              column: 13\n            },\n            end: {\n              line: 4,\n              column: 17\n            }\n          }]\n        }]\n      }]\n    });\n  });","file":"EntryRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects missing target source in package.json","suites":["EntryResolver"],"updatePoint":{"line":72,"column":51,"index":2633},"line":72,"code":"  it('rejects missing target source in package.json', async function () {\n    this.timeout(10000);\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => entryResolver.resolveEntry(INVALID_TARGET_SOURCE_MISSING_FIXTURE_PATH), {\n      diagnostics: [{\n        origin: '@parcel/core',\n        message: md`${path.join(path.relative(fs.cwd(), INVALID_TARGET_SOURCE_MISSING_FIXTURE_PATH), 'missing.js')} does not exist.`,\n        codeFrames: [{\n          filePath: path.join(INVALID_TARGET_SOURCE_MISSING_FIXTURE_PATH, 'package.json'),\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 6,\n              column: 17\n            },\n            end: {\n              line: 6,\n              column: 28\n            }\n          }]\n        }],\n        hints: []\n      }]\n    });\n  });","file":"EntryRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects non-file target source in package.json","suites":["EntryResolver"],"updatePoint":{"line":97,"column":52,"index":3477},"line":97,"code":"  it('rejects non-file target source in package.json', async function () {\n    this.timeout(10000);\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => entryResolver.resolveEntry(INVALID_TARGET_SOURCE_NOT_FILE_FIXTURE_PATH), {\n      diagnostics: [{\n        origin: '@parcel/core',\n        message: md`${path.join(path.relative(fs.cwd(), INVALID_TARGET_SOURCE_NOT_FILE_FIXTURE_PATH), 'src')} is not a file.`,\n        codeFrames: [{\n          filePath: path.join(INVALID_TARGET_SOURCE_NOT_FILE_FIXTURE_PATH, 'package.json'),\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 6,\n              column: 17\n            },\n            end: {\n              line: 6,\n              column: 21\n            }\n          }]\n        }]\n      }]\n    });\n  });","file":"EntryRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"assigns a default environment with nothing passed","suites":["Environment"],"updatePoint":{"line":6,"column":55,"index":175},"line":6,"code":"  it('assigns a default environment with nothing passed', () => {\n    assert.deepEqual(createEnvironment(), {\n      id: 'c242f987e3544367',\n      context: 'browser',\n      engines: {\n        browsers: ['> 0.25%']\n      },\n      includeNodeModules: true,\n      outputFormat: 'global',\n      isLibrary: false,\n      shouldOptimize: false,\n      shouldScopeHoist: false,\n      sourceMap: undefined,\n      loc: undefined,\n      sourceType: 'module'\n    });\n  });","file":"Environment.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"assigns a node context if a node engine is given","suites":["Environment"],"updatePoint":{"line":23,"column":54,"index":633},"line":23,"code":"  it('assigns a node context if a node engine is given', () => {\n    assert.deepEqual(createEnvironment({\n      engines: {\n        node: '>= 10.0.0'\n      }\n    }), {\n      id: '69e0ab7220ee8f7a',\n      context: 'node',\n      engines: {\n        node: '>= 10.0.0'\n      },\n      includeNodeModules: false,\n      outputFormat: 'commonjs',\n      isLibrary: false,\n      shouldOptimize: false,\n      shouldScopeHoist: false,\n      sourceMap: undefined,\n      loc: undefined,\n      sourceType: 'module'\n    });\n  });","file":"Environment.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"assigns a browser context if browser engines are given","suites":["Environment"],"updatePoint":{"line":44,"column":60,"index":1151},"line":44,"code":"  it('assigns a browser context if browser engines are given', () => {\n    assert.deepEqual(createEnvironment({\n      engines: {\n        browsers: ['last 1 version']\n      }\n    }), {\n      id: '4b5c9005af8c5b19',\n      context: 'browser',\n      engines: {\n        browsers: ['last 1 version']\n      },\n      includeNodeModules: true,\n      outputFormat: 'global',\n      isLibrary: false,\n      shouldOptimize: false,\n      shouldScopeHoist: false,\n      sourceMap: undefined,\n      loc: undefined,\n      sourceType: 'module'\n    });\n  });","file":"Environment.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"assigns default engines for node","suites":["Environment"],"updatePoint":{"line":65,"column":38,"index":1669},"line":65,"code":"  it('assigns default engines for node', () => {\n    assert.deepEqual(createEnvironment({\n      context: 'node'\n    }), {\n      id: 'f7c9644283a8698f',\n      context: 'node',\n      engines: {\n        node: '>= 8.0.0'\n      },\n      includeNodeModules: false,\n      outputFormat: 'commonjs',\n      isLibrary: false,\n      shouldOptimize: false,\n      shouldScopeHoist: false,\n      sourceMap: undefined,\n      loc: undefined,\n      sourceType: 'module'\n    });\n  });","file":"Environment.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"assigns default engines for browsers","suites":["Environment"],"updatePoint":{"line":84,"column":42,"index":2139},"line":84,"code":"  it('assigns default engines for browsers', () => {\n    assert.deepEqual(createEnvironment({\n      context: 'browser'\n    }), {\n      id: 'c242f987e3544367',\n      context: 'browser',\n      engines: {\n        browsers: ['> 0.25%']\n      },\n      includeNodeModules: true,\n      outputFormat: 'global',\n      isLibrary: false,\n      shouldOptimize: false,\n      shouldScopeHoist: false,\n      sourceMap: undefined,\n      loc: undefined,\n      sourceType: 'module'\n    });\n  });","file":"Environment.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"only includes connected files once per filePath","suites":["InternalAsset"],"updatePoint":{"line":17,"column":53,"index":501},"line":17,"code":"  it('only includes connected files once per filePath', () => {\n    let asset = new UncommittedAsset({\n      value: createAsset({\n        filePath: toProjectPath('/', '/foo/asset.js'),\n        env: createEnvironment(),\n        stats,\n        type: 'js',\n        isSource: true\n      }),\n      options: DEFAULT_OPTIONS\n    });\n    asset.invalidateOnFileChange(toProjectPath('/', '/foo/file'));\n    asset.invalidateOnFileChange(toProjectPath('/', '/foo/file'));\n    assert.deepEqual(asset.getInvalidations(), [{\n      type: 'file',\n      filePath: 'foo/file'\n    }]);\n  });","file":"InternalAsset.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"only includes dependencies once per id","suites":["InternalAsset"],"updatePoint":{"line":35,"column":44,"index":1064},"line":35,"code":"  it('only includes dependencies once per id', () => {\n    let asset = new UncommittedAsset({\n      value: createAsset({\n        filePath: toProjectPath('/', '/foo/asset.js'),\n        env: createEnvironment(),\n        stats,\n        type: 'js',\n        isSource: true\n      }),\n      options: DEFAULT_OPTIONS\n    });\n    asset.addDependency({\n      specifier: './foo',\n      specifierType: 'esm'\n    });\n    asset.addDependency({\n      specifier: './foo',\n      specifierType: 'esm'\n    });\n    let dependencies = asset.getDependencies();\n    assert(dependencies.length === 1);\n    assert(dependencies[0].specifier === './foo');\n  });","file":"InternalAsset.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"includes different dependencies if their id differs","suites":["InternalAsset"],"updatePoint":{"line":58,"column":57,"index":1712},"line":58,"code":"  it('includes different dependencies if their id differs', () => {\n    let asset = new UncommittedAsset({\n      value: createAsset({\n        filePath: toProjectPath('/', '/foo/asset.js'),\n        env: createEnvironment(),\n        stats,\n        type: 'js',\n        isSource: true\n      }),\n      options: DEFAULT_OPTIONS\n    });\n    asset.addDependency({\n      specifier: './foo',\n      specifierType: 'esm'\n    });\n    asset.addDependency({\n      specifier: './foo',\n      specifierType: 'esm',\n      env: {\n        context: 'web-worker',\n        engines: {}\n      }\n    });\n    let dependencies = asset.getDependencies();\n    assert(dependencies.length === 2);\n  });","file":"InternalAsset.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"does not initialize when passed an ending farm","suites":["Parcel"],"updatePoint":{"line":16,"column":52,"index":444},"line":16,"code":"  it('does not initialize when passed an ending farm', async () => {\n    workerFarm.ending = true;\n    let parcel = createParcel({\n      workerFarm\n    });\n\n    // $FlowFixMe\n    await assert.rejects(() => parcel.run(), {\n      name: 'Error',\n      message: 'Supplied WorkerFarm is ending'\n    });\n    workerFarm.ending = false;\n  });","file":"Parcel.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"ends any WorkerFarm it creates","suites":["Parcel","parcel.end()"],"updatePoint":{"line":37,"column":38,"index":956},"line":37,"code":"    it('ends any WorkerFarm it creates', async () => {\n      let parcel = createParcel();\n      await parcel.run();\n      assert.equal(endSpy.callCount, 1);\n    });","file":"Parcel.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"runs and constructs another farm for subsequent builds","suites":["Parcel","parcel.end()"],"updatePoint":{"line":42,"column":62,"index":1145},"line":42,"code":"    it('runs and constructs another farm for subsequent builds', async () => {\n      let parcel = createParcel();\n      await parcel.run();\n      await parcel.run();\n      assert.equal(endSpy.callCount, 2);\n    });","file":"Parcel.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"does not end passed WorkerFarms","suites":["Parcel","parcel.end()"],"updatePoint":{"line":48,"column":39,"index":1337},"line":48,"code":"    it('does not end passed WorkerFarms', async () => {\n      let parcel = createParcel({\n        workerFarm\n      });\n      await parcel.run();\n      assert.equal(endSpy.callCount, 0);\n      await workerFarm.end();\n    });","file":"Parcel.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"removes shared references it creates","suites":["Parcel","parcel.end()"],"updatePoint":{"line":56,"column":44,"index":1566},"line":56,"code":"    it('removes shared references it creates', async () => {\n      let parcel = createParcel({\n        workerFarm\n      });\n      await parcel.run();\n      assert.equal(workerFarm.sharedReferences.size, 0);\n      assert.equal(workerFarm.sharedReferencesByValue.size, 0);\n      await workerFarm.end();\n    });","file":"Parcel.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return null array if no glob matches","suites":["ParcelConfig","matchGlobMap"],"updatePoint":{"line":31,"column":51,"index":1012},"line":31,"code":"    it('should return null array if no glob matches', () => {\n      let result = config.matchGlobMap(toProjectPath('/', '/foo.wasm'), config.packagers);\n      assert.deepEqual(result, null);\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return a matching pipeline","suites":["ParcelConfig","matchGlobMap"],"updatePoint":{"line":35,"column":41,"index":1201},"line":35,"code":"    it('should return a matching pipeline', () => {\n      let result = config.matchGlobMap(toProjectPath('/', '/foo.js'), config.packagers);\n      assert.deepEqual(result, {\n        packageName: 'parcel-packager-js',\n        resolveFrom: PARCELRC_PATH,\n        keyPath: '/packagers/*.js'\n      });\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return an empty array if no pipeline matches","suites":["ParcelConfig","matchGlobMapPipelines"],"updatePoint":{"line":61,"column":59,"index":2058},"line":61,"code":"    it('should return an empty array if no pipeline matches', () => {\n      let pipeline = config.matchGlobMapPipelines(toProjectPath('/', '/foo.css'), config.transformers);\n      assert.deepEqual(pipeline, []);\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return a matching pipeline","suites":["ParcelConfig","matchGlobMapPipelines"],"updatePoint":{"line":65,"column":41,"index":2260},"line":65,"code":"    it('should return a matching pipeline', () => {\n      let pipeline = config.matchGlobMapPipelines(toProjectPath('/', '/foo.js'), config.transformers);\n      assert.deepEqual(pipeline, [{\n        packageName: 'parcel-transform-js',\n        resolveFrom: PARCELRC_PATH,\n        keyPath: '/transformers/*.{js,jsx}/0'\n      }]);\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should merge pipelines with spread elements","suites":["ParcelConfig","matchGlobMapPipelines"],"updatePoint":{"line":73,"column":51,"index":2606},"line":73,"code":"    it('should merge pipelines with spread elements', () => {\n      let pipeline = config.matchGlobMapPipelines(toProjectPath('/', '/foo.jsx'), config.transformers);\n      assert.deepEqual(pipeline, [{\n        packageName: 'parcel-transform-jsx',\n        resolveFrom: PARCELRC_PATH,\n        keyPath: '/transformers/*.jsx/0'\n      }, {\n        packageName: 'parcel-transform-js',\n        resolveFrom: PARCELRC_PATH,\n        keyPath: '/transformers/*.{js,jsx}/0'\n      }]);\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should warn if a plugin needs to specify an engines.parcel field in package.json","suites":["ParcelConfig","loadPlugin"],"updatePoint":{"line":87,"column":88,"index":3162},"line":87,"code":"    it('should warn if a plugin needs to specify an engines.parcel field in package.json', async () => {\n      let projectRoot = path.join(__dirname, 'fixtures', 'plugins');\n      let configFilePath = toProjectPath(projectRoot, path.join(__dirname, 'fixtures', 'plugins', '.parcelrc'));\n      let config = new ParcelConfig({\n        filePath: configFilePath,\n        bundler: undefined,\n        transformers: {\n          '*.js': [{\n            packageName: 'parcel-transformer-no-engines',\n            resolveFrom: configFilePath,\n            keyPath: '/transformers/*.js/0'\n          }]\n        }\n      }, {\n        ...DEFAULT_OPTIONS,\n        projectRoot\n      });\n      let warnStub = sinon.stub(logger, 'warn');\n      let {\n        plugin\n      } = await config.loadPlugin({\n        packageName: 'parcel-transformer-no-engines',\n        resolveFrom: configFilePath,\n        keyPath: '/transformers/*.js/0'\n      });\n      assert(plugin);\n      assert.equal(typeof plugin.transform, 'function');\n      assert(warnStub.calledOnce);\n      assert.deepEqual(warnStub.getCall(0).args[0], {\n        origin: '@parcel/core',\n        message: 'The plugin \"parcel-transformer-no-engines\" needs to specify a `package.json#engines.parcel` field with the supported Parcel version range.'\n      });\n      warnStub.restore();\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should error if a plugin specifies an invalid engines.parcel field in package.json","suites":["ParcelConfig","loadPlugin"],"updatePoint":{"line":121,"column":90,"index":4486},"line":121,"code":"    it('should error if a plugin specifies an invalid engines.parcel field in package.json', async () => {\n      let projectRoot = path.join(__dirname, 'fixtures', 'plugins');\n      let configFilePath = toProjectPath(projectRoot, path.join(__dirname, 'fixtures', 'plugins', '.parcelrc'));\n      let config = new ParcelConfig({\n        filePath: configFilePath,\n        bundler: undefined,\n        transformers: {\n          '*.js': [{\n            packageName: 'parcel-transformer-not-found',\n            resolveFrom: configFilePath,\n            keyPath: '/transformers/*.js/0'\n          }]\n        }\n      }, {\n        ...DEFAULT_OPTIONS,\n        projectRoot\n      });\n      // $FlowFixMe[untyped-import]\n      let parcelVersion = require('../package.json').version;\n      let pkgJSON = path.join(__dirname, 'fixtures', 'plugins', 'node_modules', 'parcel-transformer-bad-engines', 'package.json');\n      let code = inputFS.readFileSync(pkgJSON, 'utf8');\n\n      // $FlowFixMe\n      await assert.rejects(() => config.loadPlugin({\n        packageName: 'parcel-transformer-bad-engines',\n        resolveFrom: configFilePath,\n        keyPath: '/transformers/*.js/0'\n      }), {\n        name: 'Error',\n        diagnostics: [{\n          message: `The plugin \"parcel-transformer-bad-engines\" is not compatible with the current version of Parcel. Requires \"5.x\" but the current version is \"${parcelVersion}\".`,\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: pkgJSON,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              start: {\n                line: 5,\n                column: 5\n              },\n              end: {\n                line: 5,\n                column: 19\n              },\n              message: undefined\n            }]\n          }]\n        }]\n      });\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should error with a codeframe if a plugin is not resolved","suites":["ParcelConfig","loadPlugin"],"updatePoint":{"line":172,"column":65,"index":6302},"line":172,"code":"    it('should error with a codeframe if a plugin is not resolved', async () => {\n      let configFilePath = path.join(__dirname, 'fixtures', 'config-plugin-not-found', '.parcelrc');\n      let code = await DEFAULT_OPTIONS.inputFS.readFile(configFilePath, 'utf8');\n      let {\n        config\n      } = await parseAndProcessConfig(configFilePath, code, DEFAULT_OPTIONS);\n      let parcelConfig = new ParcelConfig(config, DEFAULT_OPTIONS);\n\n      // $FlowFixMe\n      await assert.rejects(() => parcelConfig.getTransformers('test.js'), {\n        name: 'Error',\n        diagnostics: [{\n          message: 'Cannot find Parcel plugin \"@parcel/transformer-jj\"',\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: configFilePath,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              start: {\n                line: 4,\n                column: 14\n              },\n              end: {\n                line: 4,\n                column: 37\n              },\n              message: `Cannot find module \"@parcel/transformer-jj\", did you mean \"@parcel/transformer-js\"?`\n            }]\n          }]\n        }]\n      });\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should error when using a reserved pipeline name \"node:*\"","suites":["ParcelConfig","loadPlugin"],"updatePoint":{"line":205,"column":65,"index":7481},"line":205,"code":"    it('should error when using a reserved pipeline name \"node:*\"', async () => {\n      let configFilePath = path.join(__dirname, 'fixtures', 'config-node-pipeline', '.parcelrc');\n      let code = await DEFAULT_OPTIONS.inputFS.readFile(configFilePath, 'utf8');\n\n      // $FlowFixMe\n      await assert.rejects(() => parseAndProcessConfig(configFilePath, code, DEFAULT_OPTIONS), {\n        name: 'Error',\n        diagnostics: [{\n          message: \"Named pipeline 'node:' is reserved.\",\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: configFilePath,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              message: undefined,\n              start: {\n                line: 4,\n                column: 5\n              },\n              end: {\n                line: 4,\n                column: 15\n              }\n            }]\n          }],\n          documentationURL: 'https://parceljs.org/features/dependency-resolution/#url-schemes'\n        }]\n      });\n    });","file":"ParcelConfig.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should error on an invalid official package","suites":["ParcelConfigRequest","validatePackageName"],"updatePoint":{"line":12,"column":51,"index":640},"line":12,"code":"    it('should error on an invalid official package', () => {\n      assert.throws(() => {\n        validatePackageName('@parcel/foo-bar', 'transform', 'transformers');\n      }, /Official parcel transform packages must be named according to \"@parcel\\/transform-{name}\"/);\n      assert.throws(() => {\n        validatePackageName('@parcel/transformer', 'transform', 'transformers');\n      }, /Official parcel transform packages must be named according to \"@parcel\\/transform-{name}\"/);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should succeed on a valid official package","suites":["ParcelConfigRequest","validatePackageName"],"updatePoint":{"line":20,"column":50,"index":1129},"line":20,"code":"    it('should succeed on a valid official package', () => {\n      validatePackageName('@parcel/transform-bar', 'transform', 'transformers');\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should error on an invalid community package","suites":["ParcelConfigRequest","validatePackageName"],"updatePoint":{"line":23,"column":52,"index":1281},"line":23,"code":"    it('should error on an invalid community package', () => {\n      assert.throws(() => {\n        validatePackageName('foo-bar', 'transform', 'transformers');\n      }, /Parcel transform packages must be named according to \"parcel-transform-{name}\"/);\n      assert.throws(() => {\n        validatePackageName('parcel-foo-bar', 'transform', 'transformers');\n      }, /Parcel transform packages must be named according to \"parcel-transform-{name}\"/);\n      assert.throws(() => {\n        validatePackageName('parcel-transform', 'transform', 'transformers');\n      }, /Parcel transform packages must be named according to \"parcel-transform-{name}\"/);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should succeed on a valid community package","suites":["ParcelConfigRequest","validatePackageName"],"updatePoint":{"line":34,"column":51,"index":1934},"line":34,"code":"    it('should succeed on a valid community package', () => {\n      validatePackageName('parcel-transform-bar', 'transform', 'transformers');\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should error on an invalid scoped package","suites":["ParcelConfigRequest","validatePackageName"],"updatePoint":{"line":37,"column":49,"index":2082},"line":37,"code":"    it('should error on an invalid scoped package', () => {\n      assert.throws(() => {\n        validatePackageName('@test/foo-bar', 'transform', 'transformers');\n      }, /Scoped parcel transform packages must be named according to \"@test\\/parcel-transform\\[-{name}\\]\"/);\n      assert.throws(() => {\n        validatePackageName('@test/parcel-foo-bar', 'transform', 'transformers');\n      }, /Scoped parcel transform packages must be named according to \"@test\\/parcel-transform\\[-{name}\\]\"/);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should succeed on a valid scoped package","suites":["ParcelConfigRequest","validatePackageName"],"updatePoint":{"line":45,"column":48,"index":2582},"line":45,"code":"    it('should succeed on a valid scoped package', () => {\n      validatePackageName('@test/parcel-transform-bar', 'transform', 'transformers');\n      validatePackageName('@test/parcel-transform', 'transform', 'transformers');\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should throw on invalid config","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":51,"column":38,"index":2854},"line":51,"code":"    it('should throw on invalid config', () => {\n      assert.throws(() => {\n        validateConfigFile({\n          filePath: '.parcelrc',\n          extends: 'parcel-config-foo',\n          transformers: {\n            '*.js': ['parcel-invalid-plugin']\n          }\n        }, '.parcelrc');\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should require pipeline to be an array","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":62,"column":46,"index":3168},"line":62,"code":"    it('should require pipeline to be an array', () => {\n      assert.throws(() => {\n        validateConfigFile(\n        // $FlowExpectedError[incompatible-call]\n        {\n          filePath: '.parcelrc',\n          resolvers: '123'\n        }, '.parcelrc');\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should require pipeline elements to be strings","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":72,"column":54,"index":3451},"line":72,"code":"    it('should require pipeline elements to be strings', () => {\n      assert.throws(() => {\n        validateConfigFile({\n          filePath: '.parcelrc',\n          // $FlowExpectedError[incompatible-call]\n          resolvers: [1, '123', 5]\n        }, '.parcelrc');\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should require package names to be valid","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":81,"column":48,"index":3729},"line":81,"code":"    it('should require package names to be valid', () => {\n      assert.throws(() => {\n        validateConfigFile({\n          filePath: '.parcelrc',\n          resolvers: ['parcel-foo-bar']\n        }, '.parcelrc');\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should succeed with an array of valid package names","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":89,"column":59,"index":3972},"line":89,"code":"    it('should succeed with an array of valid package names', () => {\n      validateConfigFile({\n        filePath: '.parcelrc',\n        resolvers: ['parcel-resolver-test']\n      }, '.parcelrc');\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should support spread elements","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":95,"column":38,"index":4154},"line":95,"code":"    it('should support spread elements', () => {\n      validateConfigFile({\n        filePath: '.parcelrc',\n        resolvers: ['parcel-resolver-test', '...']\n      }, '.parcelrc');\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should require glob map to be an object","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":101,"column":47,"index":4352},"line":101,"code":"    it('should require glob map to be an object', () => {\n      assert.throws(() => {\n        validateConfigFile({\n          filePath: '.parcelrc',\n          // $FlowExpectedError[incompatible-call]\n          transformers: ['parcel-transformer-test', '...']\n        }, '.parcelrc');\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should trigger the validator function for each key","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":110,"column":58,"index":4664},"line":110,"code":"    it('should trigger the validator function for each key', () => {\n      assert.throws(() => {\n        validateConfigFile({\n          filePath: '.parcelrc',\n          transformers: {\n            'types:*.{ts,tsx}': ['@parcel/transformer-typescript-types'],\n            'bundle-text:*': ['-inline-string', '...']\n          }\n        }, '.parcelrc');\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should require extends to be a string or array of strings","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":121,"column":65,"index":5040},"line":121,"code":"    it('should require extends to be a string or array of strings', () => {\n      assert.throws(() => {\n        validateConfigFile(\n        // $FlowExpectedError[incompatible-call]\n        {\n          filePath: '.parcelrc',\n          extends: 2\n        }, '.parcelrc');\n      });\n      assert.throws(() => {\n        validateConfigFile({\n          filePath: '.parcelrc',\n          // $FlowExpectedError[incompatible-call]\n          extends: [2, 7]\n        }, '.parcelrc');\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should support relative paths","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":138,"column":37,"index":5502},"line":138,"code":"    it('should support relative paths', () => {\n      validateConfigFile({\n        filePath: '.parcelrc',\n        extends: './foo'\n      }, '.parcelrc');\n      validateConfigFile({\n        filePath: '.parcelrc',\n        extends: ['./foo', './bar']\n      }, '.parcelrc');\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should validate package names","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":148,"column":37,"index":5781},"line":148,"code":"    it('should validate package names', () => {\n      assert.throws(() => {\n        validateConfigFile({\n          filePath: '.parcelrc',\n          extends: 'foo'\n        }, '.parcelrc');\n      });\n      assert.throws(() => {\n        validateConfigFile({\n          filePath: '.parcelrc',\n          extends: ['foo', 'bar']\n        }, '.parcelrc');\n      });\n      validateConfigFile({\n        filePath: '.parcelrc',\n        extends: 'parcel-config-foo'\n      }, '.parcelrc');\n      validateConfigFile({\n        filePath: '.parcelrc',\n        extends: ['parcel-config-foo', 'parcel-config-bar']\n      }, '.parcelrc');\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should throw for invalid top level keys","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":170,"column":47,"index":6415},"line":170,"code":"    it('should throw for invalid top level keys', () => {\n      assert.throws(() => {\n        validateConfigFile(\n        // $FlowExpectedError\n        {\n          extends: '@parcel/config-default',\n          '@parcel/transformer-js': {\n            inlineEnvironment: false\n          }\n        }, '.parcelrc');\n      }, e => {\n        assert.strictEqual(e.diagnostics[0].codeFrames[0].codeHighlights[0].message, `Did you mean \"transformers\"?`);\n        return true;\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should succeed on valid config","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":185,"column":38,"index":6890},"line":185,"code":"    it('should succeed on valid config', () => {\n      validateConfigFile({\n        filePath: '.parcelrc',\n        extends: 'parcel-config-foo',\n        transformers: {\n          '*.js': ['parcel-transformer-foo']\n        }\n      }, '.parcelrc');\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should throw error on empty config file","suites":["ParcelConfigRequest","validateConfigFile"],"updatePoint":{"line":194,"column":47,"index":7154},"line":194,"code":"    it('should throw error on empty config file', () => {\n      assert.throws(() => {\n        validateConfigFile({}, '.parcelrc');\n      }, /.parcelrc can't be empty/);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return an empty array if base and extension are null","suites":["ParcelConfigRequest","mergePipelines"],"updatePoint":{"line":201,"column":67,"index":7394},"line":201,"code":"    it('should return an empty array if base and extension are null', () => {\n      assert.deepEqual(mergePipelines(null, null), []);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return base if extension is null","suites":["ParcelConfigRequest","mergePipelines"],"updatePoint":{"line":204,"column":47,"index":7516},"line":204,"code":"    it('should return base if extension is null', () => {\n      assert.deepEqual(mergePipelines([{\n        packageName: 'parcel-transform-foo',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/0'\n      }], null), [{\n        packageName: 'parcel-transform-foo',\n        resolveFrom: '.parcelrc',\n        keyPath: '/transformers/*.js/0'\n      }]);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return extension if base is null","suites":["ParcelConfigRequest","mergePipelines"],"updatePoint":{"line":215,"column":47,"index":7913},"line":215,"code":"    it('should return extension if base is null', () => {\n      assert.deepEqual(mergePipelines(null, [{\n        packageName: 'parcel-transform-bar',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/0'\n      }]), [{\n        packageName: 'parcel-transform-bar',\n        resolveFrom: '.parcelrc',\n        keyPath: '/transformers/*.js/0'\n      }]);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return extension if there are no spread elements","suites":["ParcelConfigRequest","mergePipelines"],"updatePoint":{"line":226,"column":63,"index":8326},"line":226,"code":"    it('should return extension if there are no spread elements', () => {\n      assert.deepEqual(mergePipelines([{\n        packageName: 'parcel-transform-foo',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/0'\n      }], [{\n        packageName: 'parcel-transform-bar',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/0'\n      }]), [{\n        packageName: 'parcel-transform-bar',\n        resolveFrom: '.parcelrc',\n        keyPath: '/transformers/*.js/0'\n      }]);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return merge base into extension if there are spread elements","suites":["ParcelConfigRequest","mergePipelines"],"updatePoint":{"line":241,"column":76,"index":8899},"line":241,"code":"    it('should return merge base into extension if there are spread elements', () => {\n      assert.deepEqual(mergePipelines([{\n        packageName: 'parcel-transform-foo',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/0'\n      }], [{\n        packageName: 'parcel-transform-bar',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/0'\n      }, '...', {\n        packageName: 'parcel-transform-baz',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/2'\n      }]), [{\n        packageName: 'parcel-transform-bar',\n        resolveFrom: '.parcelrc',\n        keyPath: '/transformers/*.js/0'\n      }, {\n        packageName: 'parcel-transform-foo',\n        resolveFrom: '.parcelrc',\n        keyPath: '/transformers/*.js/0'\n      }, {\n        packageName: 'parcel-transform-baz',\n        resolveFrom: '.parcelrc',\n        keyPath: '/transformers/*.js/2'\n      }]);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should throw if more than one spread element is in a pipeline","suites":["ParcelConfigRequest","mergePipelines"],"updatePoint":{"line":268,"column":69,"index":9883},"line":268,"code":"    it('should throw if more than one spread element is in a pipeline', () => {\n      assert.throws(() => {\n        mergePipelines([{\n          packageName: 'parcel-transform-foo',\n          resolveFrom: toProjectPath('/', '/.parcelrc'),\n          keyPath: '/transformers/*.js/0'\n        }], [{\n          packageName: 'parcel-transform-bar',\n          resolveFrom: toProjectPath('/', '/.parcelrc'),\n          keyPath: '/transformers/*.js/0'\n        }, '...', {\n          packageName: 'parcel-transform-baz',\n          resolveFrom: toProjectPath('/', '/.parcelrc'),\n          keyPath: '/transformers/*.js/2'\n        }, '...']);\n      }, /Only one spread element can be included in a config pipeline/);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should remove spread element even without a base map","suites":["ParcelConfigRequest","mergePipelines"],"updatePoint":{"line":285,"column":60,"index":10583},"line":285,"code":"    it('should remove spread element even without a base map', () => {\n      assert.deepEqual(mergePipelines(null, [{\n        packageName: 'parcel-transform-bar',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/0'\n      }, '...', {\n        packageName: 'parcel-transform-baz',\n        resolveFrom: toProjectPath('/', '/.parcelrc'),\n        keyPath: '/transformers/*.js/2'\n      }]), [{\n        packageName: 'parcel-transform-bar',\n        resolveFrom: '.parcelrc',\n        keyPath: '/transformers/*.js/0'\n      }, {\n        packageName: 'parcel-transform-baz',\n        resolveFrom: '.parcelrc',\n        keyPath: '/transformers/*.js/2'\n      }]);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should throw if more than one spread element is in a pipeline even without a base map","suites":["ParcelConfigRequest","mergePipelines"],"updatePoint":{"line":304,"column":93,"index":11314},"line":304,"code":"    it('should throw if more than one spread element is in a pipeline even without a base map', () => {\n      assert.throws(() => {\n        mergePipelines(null, [{\n          packageName: 'parcel-transform-bar',\n          resolveFrom: toProjectPath('/', '/.parcelrc'),\n          keyPath: '/transformers/*.js/0'\n        }, '...', {\n          packageName: 'parcel-transform-baz',\n          resolveFrom: toProjectPath('/', '/.parcelrc'),\n          keyPath: '/transformers/*.js/2'\n        }, '...']);\n      }, /Only one spread element can be included in a config pipeline/);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return an empty object if base and extension are null","suites":["ParcelConfigRequest","mergeMaps"],"updatePoint":{"line":319,"column":68,"index":11905},"line":319,"code":"    it('should return an empty object if base and extension are null', () => {\n      assert.deepEqual(mergeMaps(null, null), {});\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return base if extension is null","suites":["ParcelConfigRequest","mergeMaps"],"updatePoint":{"line":322,"column":47,"index":12022},"line":322,"code":"    it('should return base if extension is null', () => {\n      assert.deepEqual(mergeMaps({\n        '*.js': 'foo'\n      }, null), {\n        '*.js': 'foo'\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return extension if base is null","suites":["ParcelConfigRequest","mergeMaps"],"updatePoint":{"line":329,"column":47,"index":12195},"line":329,"code":"    it('should return extension if base is null', () => {\n      assert.deepEqual(mergeMaps(null, {\n        '*.js': 'foo'\n      }), {\n        '*.js': 'foo'\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should merge the objects","suites":["ParcelConfigRequest","mergeMaps"],"updatePoint":{"line":336,"column":32,"index":12353},"line":336,"code":"    it('should merge the objects', () => {\n      assert.deepEqual(mergeMaps({\n        '*.css': 'css',\n        '*.js': 'base-js'\n      }, {\n        '*.js': 'ext-js'\n      }), {\n        '*.js': 'ext-js',\n        '*.css': 'css'\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should ensure that extension properties have a higher precedence than base properties","suites":["ParcelConfigRequest","mergeMaps"],"updatePoint":{"line":347,"column":93,"index":12657},"line":347,"code":"    it('should ensure that extension properties have a higher precedence than base properties', () => {\n      let merged = mergeMaps({\n        '*.{js,jsx}': 'base-js'\n      }, {\n        '*.js': 'ext-js'\n      });\n      assert.deepEqual(merged, {\n        '*.js': 'ext-js',\n        '*.{js,jsx}': 'base-js'\n      });\n      assert.deepEqual(Object.keys(merged), ['*.js', '*.{js,jsx}']);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should call a merger function if provided","suites":["ParcelConfigRequest","mergeMaps"],"updatePoint":{"line":359,"column":49,"index":13004},"line":359,"code":"    it('should call a merger function if provided', () => {\n      let merger = (a, b) => [a, b];\n      assert.deepEqual(mergeMaps({\n        '*.js': 'base-js'\n      }, {\n        '*.js': 'ext-js'\n      }, merger), {\n        '*.js': ['base-js', 'ext-js']\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should merge configs","suites":["ParcelConfigRequest","mergeConfigs"],"updatePoint":{"line":371,"column":28,"index":13294},"line":371,"code":"    it('should merge configs', () => {\n      let base = new ParcelConfig({\n        filePath: toProjectPath('/', '/.parcelrc'),\n        resolvers: [{\n          packageName: 'parcel-resolver-base',\n          resolveFrom: toProjectPath('/', '/.parcelrc'),\n          keyPath: '/resolvers/0'\n        }],\n        transformers: {\n          '*.js': [{\n            packageName: 'parcel-transform-base',\n            resolveFrom: toProjectPath('/', '/.parcelrc'),\n            keyPath: '/transformers/*.js/0'\n          }],\n          '*.css': [{\n            packageName: 'parcel-transform-css',\n            resolveFrom: toProjectPath('/', '/.parcelrc'),\n            keyPath: '/transformers/*.css/0'\n          }]\n        },\n        bundler: {\n          packageName: 'parcel-bundler-base',\n          resolveFrom: toProjectPath('/', '/.parcelrc'),\n          keyPath: '/bundler'\n        }\n      }, DEFAULT_OPTIONS);\n      let ext = {\n        filePath: '.parcelrc',\n        resolvers: [{\n          packageName: 'parcel-resolver-ext',\n          resolveFrom: '.parcelrc',\n          keyPath: '/resolvers/0'\n        }, '...'],\n        transformers: {\n          '*.js': [{\n            packageName: 'parcel-transform-ext',\n            resolveFrom: '.parcelrc',\n            keyPath: '/transformers/*.js/0'\n          }, '...']\n        }\n      };\n      let merged = {\n        filePath: '.parcelrc',\n        resolvers: [{\n          packageName: 'parcel-resolver-ext',\n          resolveFrom: '.parcelrc',\n          keyPath: '/resolvers/0'\n        }, {\n          packageName: 'parcel-resolver-base',\n          resolveFrom: '.parcelrc',\n          keyPath: '/resolvers/0'\n        }],\n        transformers: {\n          '*.js': [{\n            packageName: 'parcel-transform-ext',\n            resolveFrom: '.parcelrc',\n            keyPath: '/transformers/*.js/0'\n          }, {\n            packageName: 'parcel-transform-base',\n            resolveFrom: '.parcelrc',\n            keyPath: '/transformers/*.js/0'\n          }],\n          '*.css': [{\n            packageName: 'parcel-transform-css',\n            resolveFrom: '.parcelrc',\n            keyPath: '/transformers/*.css/0'\n          }]\n        },\n        bundler: {\n          packageName: 'parcel-bundler-base',\n          resolveFrom: '.parcelrc',\n          keyPath: '/bundler'\n        },\n        runtimes: [],\n        namers: [],\n        optimizers: {},\n        compressors: {},\n        packagers: {},\n        reporters: [],\n        validators: {}\n      };\n\n      // $FlowFixMe\n      assert.deepEqual(mergeConfigs(base, ext), merged);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should resolve a relative path","suites":["ParcelConfigRequest","resolveExtends"],"updatePoint":{"line":458,"column":38,"index":15911},"line":458,"code":"    it('should resolve a relative path', async () => {\n      let resolved = await resolveExtends('../.parcelrc', path.join(__dirname, 'fixtures', 'config', 'subfolder', '.parcelrc'), '/extends', DEFAULT_OPTIONS);\n      assert.equal(resolved, path.join(__dirname, 'fixtures', 'config', '.parcelrc'));\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should resolve a package name","suites":["ParcelConfigRequest","resolveExtends"],"updatePoint":{"line":462,"column":37,"index":16218},"line":462,"code":"    it('should resolve a package name', async () => {\n      let resolved = await resolveExtends('@parcel/config-default', path.join(__dirname, 'fixtures', 'config', 'subfolder', '.parcelrc'), '/extends', DEFAULT_OPTIONS);\n      assert.equal(resolved, require.resolve('@parcel/config-default'));\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should load and merge configs","suites":["ParcelConfigRequest","parseAndProcessConfig"],"updatePoint":{"line":468,"column":37,"index":16571},"line":468,"code":"    it('should load and merge configs', async () => {\n      let defaultConfigPath = require.resolve('@parcel/config-default');\n      let defaultConfig = await processConfig({\n        ...require('@parcel/config-default'),\n        filePath: defaultConfigPath\n      }, DEFAULT_OPTIONS);\n      let configFilePath = path.join(__dirname, 'fixtures', 'config', '.parcelrc');\n      let subConfigFilePath = path.join(__dirname, 'fixtures', 'config', 'subfolder', '.parcelrc');\n      let {\n        config\n      } = await parseAndProcessConfig(subConfigFilePath, DEFAULT_OPTIONS.inputFS.readFileSync(subConfigFilePath, 'utf8'), DEFAULT_OPTIONS);\n      let transformers = nullthrows(config.transformers);\n      assert.deepEqual(transformers['*.js'], [{\n        packageName: 'parcel-transformer-sub',\n        resolveFrom: relative(subConfigFilePath),\n        keyPath: '/transformers/*.js/0'\n      }, {\n        packageName: 'parcel-transformer-base',\n        resolveFrom: relative(configFilePath),\n        keyPath: '/transformers/*.js/0'\n      }, '...']);\n      assert(Object.keys(transformers).length > 1);\n      assert.deepEqual(config.resolvers, defaultConfig.resolvers);\n      assert.deepEqual(config.bundler, defaultConfig.bundler);\n      assert.deepEqual(config.namers, defaultConfig.namers || []);\n      assert.deepEqual(config.packagers, defaultConfig.packagers || {});\n      assert.deepEqual(config.optimizers, defaultConfig.optimizers || {});\n      assert.deepEqual(config.reporters, defaultConfig.reporters || []);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should emit a codeframe.codeHighlights when a malformed .parcelrc was found","suites":["ParcelConfigRequest","parseAndProcessConfig"],"updatePoint":{"line":497,"column":83,"index":18137},"line":497,"code":"    it('should emit a codeframe.codeHighlights when a malformed .parcelrc was found', async () => {\n      let configFilePath = path.join(__dirname, 'fixtures', 'config-malformed', '.parcelrc');\n      let code = await DEFAULT_OPTIONS.inputFS.readFile(configFilePath, 'utf8');\n      let pos = {\n        line: 2,\n        column: 14\n      };\n\n      // $FlowFixMe[prop-missing]\n      await assert.rejects(() => parseAndProcessConfig(configFilePath, code, DEFAULT_OPTIONS), {\n        name: 'Error',\n        diagnostics: [{\n          message: 'Failed to parse .parcelrc',\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: configFilePath,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              message: \"JSON5: invalid character 'b' at 2:14\",\n              start: pos,\n              end: pos\n            }]\n          }]\n        }]\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should emit a codeframe when an extended parcel config file is not found","suites":["ParcelConfigRequest","parseAndProcessConfig"],"updatePoint":{"line":524,"column":80,"index":19045},"line":524,"code":"    it('should emit a codeframe when an extended parcel config file is not found', async () => {\n      let configFilePath = path.join(__dirname, 'fixtures', 'config-extends-not-found', '.parcelrc');\n      let code = await DEFAULT_OPTIONS.inputFS.readFile(configFilePath, 'utf8');\n\n      // $FlowFixMe[prop-missing]\n      await assert.rejects(() => parseAndProcessConfig(configFilePath, code, DEFAULT_OPTIONS), {\n        name: 'Error',\n        diagnostics: [{\n          message: 'Cannot find extended parcel config',\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: configFilePath,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              message: '\"./.parclrc-node-modules\" does not exist, did you mean \"./.parcelrc-node-modules\"?',\n              start: {\n                line: 2,\n                column: 14\n              },\n              end: {\n                line: 2,\n                column: 38\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should emit a codeframe when an extended parcel config file is not found in JSON5","suites":["ParcelConfigRequest","parseAndProcessConfig"],"updatePoint":{"line":553,"column":89,"index":20094},"line":553,"code":"    it('should emit a codeframe when an extended parcel config file is not found in JSON5', async () => {\n      let configFilePath = path.join(__dirname, 'fixtures', 'config-extends-not-found', '.parcelrc-json5');\n      let code = await DEFAULT_OPTIONS.inputFS.readFile(configFilePath, 'utf8');\n\n      // $FlowFixMe[prop-missing]\n      await assert.rejects(() => parseAndProcessConfig(configFilePath, code, DEFAULT_OPTIONS), {\n        name: 'Error',\n        diagnostics: [{\n          message: 'Cannot find extended parcel config',\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: configFilePath,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              message: '\"./.parclrc-node-modules\" does not exist, did you mean \"./.parcelrc-node-modules\"?',\n              start: {\n                line: 2,\n                column: 12\n              },\n              end: {\n                line: 2,\n                column: 36\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should emit a codeframe when an extended parcel config node module is not found","suites":["ParcelConfigRequest","parseAndProcessConfig"],"updatePoint":{"line":582,"column":87,"index":21147},"line":582,"code":"    it('should emit a codeframe when an extended parcel config node module is not found', async () => {\n      let configFilePath = path.join(__dirname, 'fixtures', 'config-extends-not-found', '.parcelrc-node-modules');\n      let code = await DEFAULT_OPTIONS.inputFS.readFile(configFilePath, 'utf8');\n\n      // $FlowFixMe[prop-missing]\n      await assert.rejects(() => parseAndProcessConfig(configFilePath, code, DEFAULT_OPTIONS), {\n        name: 'Error',\n        diagnostics: [{\n          message: 'Cannot find extended parcel config',\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: configFilePath,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              message: 'Cannot find module \"@parcel/config-deflt\", did you mean \"@parcel/config-default\"?',\n              start: {\n                line: 2,\n                column: 14\n              },\n              end: {\n                line: 2,\n                column: 35\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should emit multiple codeframes when multiple extended configs are not found","suites":["ParcelConfigRequest","parseAndProcessConfig"],"updatePoint":{"line":611,"column":84,"index":22203},"line":611,"code":"    it('should emit multiple codeframes when multiple extended configs are not found', async () => {\n      let configFilePath = path.join(__dirname, 'fixtures', 'config-extends-not-found', '.parcelrc-multiple');\n      let code = await DEFAULT_OPTIONS.inputFS.readFile(configFilePath, 'utf8');\n\n      // $FlowFixMe[prop-missing]\n      await assert.rejects(() => parseAndProcessConfig(configFilePath, code, DEFAULT_OPTIONS), {\n        name: 'Error',\n        diagnostics: [{\n          message: 'Cannot find extended parcel config',\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: configFilePath,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              message: 'Cannot find module \"@parcel/config-deflt\", did you mean \"@parcel/config-default\"?',\n              start: {\n                line: 2,\n                column: 15\n              },\n              end: {\n                line: 2,\n                column: 36\n              }\n            }]\n          }]\n        }, {\n          message: 'Cannot find extended parcel config',\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: configFilePath,\n            language: 'json5',\n            code,\n            codeHighlights: [{\n              message: '\"./.parclrc\" does not exist, did you mean \"./.parcelrc\"?',\n              start: {\n                line: 2,\n                column: 39\n              },\n              end: {\n                line: 2,\n                column: 50\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return null if there is no .parcelrc file found","suites":["ParcelConfigRequest","resolve"],"updatePoint":{"line":661,"column":62,"index":23808},"line":661,"code":"    it('should return null if there is no .parcelrc file found', async () => {\n      let resolved = await resolveParcelConfig(DEFAULT_OPTIONS);\n      assert.equal(resolved, null);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should resolve a config if a .parcelrc file is found","suites":["ParcelConfigRequest","resolve"],"updatePoint":{"line":665,"column":60,"index":23994},"line":665,"code":"    it('should resolve a config if a .parcelrc file is found', async () => {\n      let resolved = await resolveParcelConfig({\n        ...DEFAULT_OPTIONS,\n        projectRoot: path.join(__dirname, 'fixtures', 'config', 'subfolder')\n      });\n      assert(resolved !== null);\n    });","file":"ParcelConfigRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"returns the same public Asset given an internal asset","suites":["Public Asset"],"updatePoint":{"line":30,"column":59,"index":893},"line":30,"code":"  it('returns the same public Asset given an internal asset', () => {\n    assert.equal(new Asset(internalAsset), new Asset(internalAsset));\n  });","file":"PublicAsset.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"returns the same public MutableAsset given an internal asset","suites":["Public Asset"],"updatePoint":{"line":33,"column":66,"index":1046},"line":33,"code":"  it('returns the same public MutableAsset given an internal asset', () => {\n    assert.equal(new MutableAsset(internalAsset), new MutableAsset(internalAsset));\n  });","file":"PublicAsset.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"returns the same public Bundle given an internal bundle","suites":["Public Bundle"],"updatePoint":{"line":44,"column":61,"index":1234},"line":44,"code":"  it('returns the same public Bundle given an internal bundle', () => {\n    assert.equal(Bundle.get(internalBundle, bundleGraph, DEFAULT_OPTIONS), Bundle.get(internalBundle, bundleGraph, DEFAULT_OPTIONS));\n  });","file":"PublicBundle.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"returns the same public NamedBundle given an internal bundle","suites":["Public Bundle"],"updatePoint":{"line":47,"column":66,"index":1451},"line":47,"code":"  it('returns the same public NamedBundle given an internal bundle', () => {\n    assert.equal(NamedBundle.get(internalBundle, bundleGraph, DEFAULT_OPTIONS), NamedBundle.get(internalBundle, bundleGraph, DEFAULT_OPTIONS));\n  });","file":"PublicBundle.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"returns the same public PackagedBundle given an internal bundle","suites":["Public Bundle"],"updatePoint":{"line":50,"column":69,"index":1681},"line":50,"code":"  it('returns the same public PackagedBundle given an internal bundle', () => {\n    assert.equal(PackagedBundle.get(internalBundle, bundleGraph, DEFAULT_OPTIONS), PackagedBundle.get(internalBundle, bundleGraph, DEFAULT_OPTIONS));\n  });","file":"PublicBundle.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"returns the same public Dependency given an internal dependency","suites":["Public Dependency"],"updatePoint":{"line":9,"column":69,"index":348},"line":9,"code":"  it('returns the same public Dependency given an internal dependency', () => {\n    let internalDependency = createDependency('/', {\n      specifier: 'foo',\n      specifierType: 'esm',\n      env: createEnvironment({})\n    });\n    assert.equal(new Dependency(internalDependency, DEFAULT_OPTIONS), new Dependency(internalDependency, DEFAULT_OPTIONS));\n  });","file":"PublicDependency.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"has correct support data for ChromeAndroid","suites":["Public Environment"],"updatePoint":{"line":8,"column":48,"index":282},"line":8,"code":"  it('has correct support data for ChromeAndroid', () => {\n    let env = new PublicEnvironment(createEnvironment({\n      context: 'browser',\n      engines: {\n        browsers: ['last 1 Chrome version', 'last 1 ChromeAndroid version']\n      },\n      outputFormat: 'esmodule'\n    }), DEFAULT_OPTIONS);\n    assert(env.supports('esmodules'));\n    assert(env.supports('dynamic-import'));\n    assert(env.supports('worker-module'));\n    assert(env.supports('import-meta-url'));\n    assert(env.supports('arrow-functions'));\n  });","file":"PublicEnvironment.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"creates publicIds for bundles","suites":["PublicMutableBundleGraph"],"updatePoint":{"line":22,"column":35,"index":876},"line":22,"code":"  it('creates publicIds for bundles', () => {\n    let internalBundleGraph = InternalBundleGraph.fromAssetGraph(createMockAssetGraph());\n    let mutableBundleGraph = new MutableBundleGraph(internalBundleGraph, DEFAULT_OPTIONS);\n    mutableBundleGraph.traverse(node => {\n      if (node.type === 'dependency' && mutableBundleGraph.getResolvedAsset(node.value)) {\n        let target = nullthrows(node.value.target);\n        let group = mutableBundleGraph.createBundleGroup(node.value, target);\n        let resolved = mutableBundleGraph.getResolvedAsset(node.value);\n        if (resolved != null) {\n          mutableBundleGraph.addBundleToBundleGroup(mutableBundleGraph.createBundle({\n            entryAsset: resolved,\n            target\n          }), group);\n        }\n      }\n    });\n    assert.deepEqual(internalBundleGraph.getBundles().map(b => b.publicId), ['8LVYC', 'd7Pd5']);\n  });","file":"PublicMutableBundleGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"is safe to add a bundle to a bundleGroup multiple times","suites":["PublicMutableBundleGraph"],"updatePoint":{"line":40,"column":61,"index":1786},"line":40,"code":"  it('is safe to add a bundle to a bundleGroup multiple times', () => {\n    let internalBundleGraph = InternalBundleGraph.fromAssetGraph(createMockAssetGraph());\n    let mutableBundleGraph = new MutableBundleGraph(internalBundleGraph, DEFAULT_OPTIONS);\n    let dependency;\n    mutableBundleGraph.traverse((node, _, actions) => {\n      if (node.type === 'dependency') {\n        dependency = node.value;\n        actions.stop();\n      }\n    });\n    invariant(dependency != null);\n    let target = nullthrows(dependency.target);\n    let bundleGroup = mutableBundleGraph.createBundleGroup(dependency, target);\n    let bundle = mutableBundleGraph.createBundle({\n      entryAsset: nullthrows(mutableBundleGraph.getResolvedAsset(dependency)),\n      target\n    });\n    mutableBundleGraph.addBundleToBundleGroup(bundle, bundleGroup);\n    mutableBundleGraph.addBundleToBundleGroup(bundle, bundleGroup);\n  });","file":"PublicMutableBundleGraph.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should not run requests that have not been invalidated","suites":["RequestTracker"],"updatePoint":{"line":15,"column":60,"index":530},"line":15,"code":"  it('should not run requests that have not been invalidated', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: () => {},\n      input: null\n    });\n    let called = false;\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: () => {\n        called = true;\n      },\n      input: null\n    });\n    assert(called === false);\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should rerun requests that have been invalidated","suites":["RequestTracker"],"updatePoint":{"line":37,"column":54,"index":1010},"line":37,"code":"  it('should rerun requests that have been invalidated', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: () => {},\n      input: null\n    });\n    tracker.graph.invalidateNode(tracker.graph.getNodeIdByContentKey('abc'), INITIAL_BUILD);\n    let called = false;\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: () => {\n        called = true;\n      },\n      input: null\n    });\n    assert(called === true);\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should invalidate requests with invalidated subrequests","suites":["RequestTracker"],"updatePoint":{"line":60,"column":61,"index":1589},"line":60,"code":"  it('should invalidate requests with invalidated subrequests', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async ({\n        api\n      }) => {\n        await api.runRequest({\n          id: 'xyz',\n          type: 'mock_request',\n          run: () => {},\n          input: null\n        });\n      },\n      input: null\n    });\n    tracker.graph.invalidateNode(tracker.graph.getNodeIdByContentKey('xyz'), INITIAL_BUILD);\n    assert(tracker.getInvalidRequests().map(req => req.id).includes('abc'));\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should invalidate requests that failed","suites":["RequestTracker"],"updatePoint":{"line":83,"column":44,"index":2199},"line":83,"code":"  it('should invalidate requests that failed', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async () => {\n        await Promise.resolve();\n        throw new Error('woops');\n      },\n      input: null\n    }).then(null, () => {\n      /* do nothing */\n    });\n    assert(tracker.getInvalidRequests().map(req => req.id).includes('abc'));\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should remove subrequests that are no longer called within a request","suites":["RequestTracker"],"updatePoint":{"line":101,"column":74,"index":2698},"line":101,"code":"  it('should remove subrequests that are no longer called within a request', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async ({\n        api\n      }) => {\n        await api.runRequest({\n          id: 'xyz',\n          type: 'mock_request',\n          run: () => {},\n          input: null\n        });\n      },\n      input: null\n    });\n    let nodeId = nullthrows(tracker.graph.getNodeIdByContentKey('abc'));\n    tracker.graph.invalidateNode(nodeId, INITIAL_BUILD);\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async ({\n        api\n      }) => {\n        await api.runRequest({\n          id: '123',\n          type: 'mock_request',\n          run: () => {},\n          input: null\n        });\n      },\n      input: null\n    });\n    assert(!tracker.graph.hasContentKey('xyz'));\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should return a cached result if it was stored","suites":["RequestTracker"],"updatePoint":{"line":140,"column":52,"index":3625},"line":140,"code":"  it('should return a cached result if it was stored', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async ({\n        api\n      }) => {\n        let result = await Promise.resolve('hello');\n        api.storeResult(result);\n      },\n      input: null\n    });\n    let result = await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async () => {},\n      input: null\n    });\n    assert(result === 'hello');\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should reject all in progress requests when the abort controller aborts","suites":["RequestTracker"],"updatePoint":{"line":164,"column":77,"index":4215},"line":164,"code":"  it('should reject all in progress requests when the abort controller aborts', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    let p = tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async () => {\n        await Promise.resolve('hello');\n      },\n      input: null\n    }).then(null, () => {\n      /* do nothing */\n    });\n    // $FlowFixMe\n    tracker.setSignal({\n      aborted: true\n    });\n    await p;\n    assert(tracker.getInvalidRequests().map(req => req.id).includes('abc'));\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should not requeue requests if the previous request is still running","suites":["RequestTracker"],"updatePoint":{"line":186,"column":74,"index":4772},"line":186,"code":"  it('should not requeue requests if the previous request is still running', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    let lockA = makeDeferredWithPromise();\n    let lockB = makeDeferredWithPromise();\n    let requestA = tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async ({\n        api\n      }) => {\n        await lockA.promise;\n        api.storeResult('a');\n        return 'a';\n      },\n      input: null\n    });\n    let calledB = false;\n    let requestB = tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async ({\n        api\n      }) => {\n        calledB = true;\n        await lockB.promise;\n        api.storeResult('b');\n        return 'b';\n      },\n      input: null\n    });\n    lockA.deferred.resolve();\n    lockB.deferred.resolve();\n    let resultA = await requestA;\n    let resultB = await requestB;\n    assert.strictEqual(resultA, 'a');\n    assert.strictEqual(resultB, 'a');\n    assert.strictEqual(calledB, false);\n    let cachedResult = await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: () => {},\n      input: null\n    });\n    assert.strictEqual(cachedResult, 'a');\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should requeue requests if the previous request is still running but failed","suites":["RequestTracker"],"updatePoint":{"line":234,"column":81,"index":6003},"line":234,"code":"  it('should requeue requests if the previous request is still running but failed', async () => {\n    let tracker = new RequestTracker({\n      farm,\n      options\n    });\n    let lockA = makeDeferredWithPromise();\n    let lockB = makeDeferredWithPromise();\n    let requestA = tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async () => {\n        await lockA.promise;\n        throw new Error('whoops');\n      },\n      input: null\n    }).catch(() => {\n      // ignore\n    });\n    let requestB = tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: async ({\n        api\n      }) => {\n        await lockB.promise;\n        api.storeResult('b');\n      },\n      input: null\n    });\n    lockA.deferred.resolve();\n    lockB.deferred.resolve();\n    await requestA;\n    await requestB;\n    let called = false;\n    let cachedResult = await tracker.runRequest({\n      id: 'abc',\n      type: 'mock_request',\n      run: () => {\n        called = true;\n      },\n      input: null\n    });\n    assert.strictEqual(cachedResult, 'b');\n    assert.strictEqual(called, false);\n  });","file":"RequestTracker.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a basic object","suites":["serializer"],"updatePoint":{"line":6,"column":37,"index":242},"line":6,"code":"  it('should serialize a basic object', () => {\n    let serialized = serialize({\n      foo: 2,\n      bar: 3\n    });\n    assert(Buffer.isBuffer(serialized));\n    let deserialized = deserialize(serialized);\n    assert.equal(typeof deserialized, 'object');\n    assert.deepEqual(deserialized, {\n      foo: 2,\n      bar: 3\n    });\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize an object with multiple references","suites":["serializer"],"updatePoint":{"line":19,"column":57,"index":594},"line":19,"code":"  it('should serialize an object with multiple references', () => {\n    let a = {\n      foo: 2\n    };\n    let b = {\n      bar: a,\n      baz: a\n    };\n    let res = deserialize(serialize(b));\n    assert.deepEqual(res, b);\n    assert.equal(res.bar, res.baz);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a cyclic object","suites":["serializer"],"updatePoint":{"line":31,"column":38,"index":838},"line":31,"code":"  it('should serialize a cyclic object', () => {\n    let a = {\n      foo: 2,\n      bar: {}\n    };\n    a.bar = a;\n    let res = deserialize(serialize(a));\n    assert.deepEqual(res, a);\n    assert.equal(res.bar, res);\n    assert.equal(a.bar, a);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a Map","suites":["serializer"],"updatePoint":{"line":42,"column":28,"index":1078},"line":42,"code":"  it('should serialize a Map', () => {\n    let a = new Map([[2, 3]]);\n    let res = deserialize(serialize(a));\n    assert(res instanceof Map);\n    assert.equal(res.get(2), 3);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a Set","suites":["serializer"],"updatePoint":{"line":48,"column":28,"index":1260},"line":48,"code":"  it('should serialize a Set', () => {\n    let a = new Set([2, 3]);\n    let res = deserialize(serialize(a));\n    assert(res instanceof Set);\n    assert(res.has(2));\n    assert(res.has(3));\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a class","suites":["serializer"],"updatePoint":{"line":55,"column":30,"index":1457},"line":55,"code":"  it('should serialize a class', () => {\n    class Test {\n      constructor(x) {\n        this.x = x;\n      }\n    }\n    registerSerializableClass('Test', Test);\n    let x = new Test(2);\n    let res = deserialize(serialize(x));\n    assert(res instanceof Test);\n    assert.equal(res.x, x.x);\n    unregisterSerializableClass('Test', Test);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a class with a custom serialize method","suites":["serializer"],"updatePoint":{"line":68,"column":61,"index":1830},"line":68,"code":"  it('should serialize a class with a custom serialize method', () => {\n    class Test {\n      constructor(x) {\n        this.x = x;\n      }\n      serialize() {\n        return {\n          x: this.x,\n          serialized: true\n        };\n      }\n    }\n    registerSerializableClass('Test', Test);\n    let x = new Test(2);\n    let res = deserialize(serialize(x));\n    assert(res instanceof Test);\n    assert.equal(res.x, x.x);\n    assert.equal(res.serialized, true);\n    unregisterSerializableClass('Test', Test);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a class with a custom deserialize method","suites":["serializer"],"updatePoint":{"line":88,"column":63,"index":2349},"line":88,"code":"  it('should serialize a class with a custom deserialize method', () => {\n    class Test {\n      constructor(x) {\n        this.x = x;\n      }\n      static deserialize(x) {\n        return {\n          deserialized: true,\n          value: x\n        };\n      }\n    }\n    registerSerializableClass('Test', Test);\n    let x = new Test(2);\n    let res = deserialize(serialize(x));\n    assert(!(res instanceof Test));\n    assert.equal(res.value.x, x.x);\n    assert.equal(res.deserialized, true);\n    unregisterSerializableClass('Test', Test);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a class recursively","suites":["serializer"],"updatePoint":{"line":108,"column":42,"index":2869},"line":108,"code":"  it('should serialize a class recursively', () => {\n    class Foo {\n      constructor(x) {\n        this.x = x;\n      }\n    }\n    class Bar {\n      constructor(foo) {\n        this.foo = foo;\n      }\n    }\n    registerSerializableClass('Foo', Foo);\n    registerSerializableClass('Bar', Bar);\n    let x = new Bar(new Foo(2));\n    let res = deserialize(serialize(x));\n    assert(res instanceof Bar);\n    assert(res.foo instanceof Foo);\n    assert.equal(res.foo.x, 2);\n    unregisterSerializableClass('Foo', Foo);\n    unregisterSerializableClass('Bar', Bar);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a cyclic class","suites":["serializer"],"updatePoint":{"line":129,"column":37,"index":3425},"line":129,"code":"  it('should serialize a cyclic class', () => {\n    class Foo {\n      constructor(x) {\n        this.x = x;\n      }\n    }\n    registerSerializableClass('Foo', Foo);\n    let x = new Foo();\n    x.x = x;\n    let res = deserialize(serialize(x));\n    assert(res instanceof Foo);\n    assert(res.x instanceof Foo);\n    assert.equal(res.x, res);\n    assert.equal(x.x, x);\n    unregisterSerializableClass('Foo', Foo);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should copy on write","suites":["serializer"],"updatePoint":{"line":145,"column":26,"index":3828},"line":145,"code":"  it('should copy on write', () => {\n    class Foo {\n      constructor(x) {\n        this.x = x;\n      }\n    }\n    registerSerializableClass('Foo', Foo);\n    let x = {\n      y: {\n        foo: new Foo(2)\n      }\n    };\n    let res = deserialize(serialize(x));\n    assert(res.y.foo instanceof Foo);\n    assert(x.y.foo instanceof Foo);\n    unregisterSerializableClass('Foo', Foo);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a cyclic class and copy on write","suites":["serializer"],"updatePoint":{"line":162,"column":55,"index":4240},"line":162,"code":"  it('should serialize a cyclic class and copy on write', () => {\n    class Foo {\n      constructor(x) {\n        this.x = x;\n      }\n    }\n    registerSerializableClass('Foo', Foo);\n    let x = new Foo();\n    x.x = x;\n    let y = {\n      x: {\n        y: x\n      }\n    };\n    let res = deserialize(serialize(y));\n    assert(res.x.y instanceof Foo);\n    assert(res.x.y.x instanceof Foo);\n    assert(y.x.y instanceof Foo);\n    assert(y.x.y.x instanceof Foo);\n    assert.equal(res.x.y.x, res.x.y);\n    assert.equal(x.x, x);\n    unregisterSerializableClass('Foo', Foo);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a class inside a Map","suites":["serializer"],"updatePoint":{"line":185,"column":43,"index":4799},"line":185,"code":"  it('should serialize a class inside a Map', () => {\n    class Test {\n      constructor(x) {\n        this.x = x;\n      }\n    }\n    registerSerializableClass('Test', Test);\n    let x = new Map([[2, new Test(2)]]);\n    let res = deserialize(serialize(x));\n    assert(res instanceof Map);\n    assert(res.get(2) instanceof Test);\n    unregisterSerializableClass('Test', Test);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should serialize a class inside a Set","suites":["serializer"],"updatePoint":{"line":198,"column":43,"index":5179},"line":198,"code":"  it('should serialize a class inside a Set', () => {\n    class Test {\n      constructor(x) {\n        this.x = x;\n      }\n    }\n    registerSerializableClass('Test', Test);\n    let x = new Set([new Test(2)]);\n    let res = deserialize(serialize(x));\n    assert(res instanceof Set);\n    assert(res.values().next().value instanceof Test);\n    unregisterSerializableClass('Test', Test);\n  });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should not recursively serialize raw values","suites":["serializer","raw values"],"updatePoint":{"line":237,"column":51,"index":6180},"line":237,"code":"    it('should not recursively serialize raw values', () => {\n      let res = deserialize(serialize(new Outer(new Inner(42))));\n      assert(res instanceof Outer);\n      assert(!(res.inner instanceof Inner));\n      assert.equal(res.inner.x, 42);\n    });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should not recursively deserialize raw values","suites":["serializer","raw values"],"updatePoint":{"line":243,"column":53,"index":6436},"line":243,"code":"    it('should not recursively deserialize raw values', () => {\n      deserialize(serialize(new Outer(new Inner(42))));\n      assert(Inner.deserialize.notCalled);\n    });","file":"serializer.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolves exactly specified targets","suites":["TargetResolver"],"updatePoint":{"line":63,"column":40,"index":2223},"line":63,"code":"  it('resolves exactly specified targets', async () => {\n    let targetResolver = new TargetResolver(api, {\n      ...DEFAULT_OPTIONS,\n      targets: {\n        customA: {\n          context: 'browser',\n          distDir: 'customA'\n        },\n        customB: {\n          distDir: 'customB',\n          distEntry: 'b.js',\n          engines: {\n            node: '>= 8.0.0'\n          }\n        }\n      }\n    });\n    assert.deepEqual(await targetResolver.resolve(COMMON_TARGETS_FIXTURE_PATH), [{\n      name: 'customA',\n      publicUrl: '/',\n      distDir: normalizeSeparators(path.resolve('customA')),\n      env: {\n        id: '1d40417b63734b32',\n        context: 'browser',\n        includeNodeModules: true,\n        engines: {\n          browsers: ['> 0.25%']\n        },\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      }\n    }, {\n      name: 'customB',\n      publicUrl: '/',\n      distEntry: 'b.js',\n      distDir: normalizeSeparators(path.resolve('customB')),\n      env: {\n        id: '928f0d1c941b2e57',\n        context: 'node',\n        includeNodeModules: false,\n        engines: {\n          node: '>= 8.0.0'\n        },\n        outputFormat: 'commonjs',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolves common targets from package.json","suites":["TargetResolver"],"updatePoint":{"line":121,"column":47,"index":3725},"line":121,"code":"  it('resolves common targets from package.json', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    assert.deepEqual(await targetResolver.resolve(COMMON_TARGETS_FIXTURE_PATH), [{\n      name: 'main',\n      distDir: 'fixtures/common-targets/dist/main',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: 'b552bd32da37fa8b',\n        context: 'node',\n        engines: {\n          node: '>= 8.0.0'\n        },\n        includeNodeModules: false,\n        outputFormat: 'commonjs',\n        isLibrary: true,\n        shouldOptimize: false,\n        shouldScopeHoist: true,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(COMMON_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 11,\n          line: 2\n        },\n        end: {\n          column: 30,\n          line: 2\n        }\n      }\n    }, {\n      name: 'module',\n      distDir: 'fixtures/common-targets/dist/module',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: '8804e4eb97e2703e',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 version']\n        },\n        includeNodeModules: false,\n        outputFormat: 'esmodule',\n        isLibrary: true,\n        shouldOptimize: false,\n        shouldScopeHoist: true,\n        sourceMap: {\n          inlineSources: true\n        },\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(COMMON_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 13,\n          line: 3\n        },\n        end: {\n          column: 34,\n          line: 3\n        }\n      }\n    }, {\n      name: 'browser',\n      distDir: 'fixtures/common-targets/dist/browser',\n      distEntry: 'index.js',\n      publicUrl: '/assets',\n      env: {\n        id: 'a7ed3e73c53f1923',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 version']\n        },\n        includeNodeModules: false,\n        outputFormat: 'commonjs',\n        isLibrary: true,\n        shouldOptimize: false,\n        shouldScopeHoist: true,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(COMMON_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 14,\n          line: 4\n        },\n        end: {\n          column: 36,\n          line: 4\n        }\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"allows ignoring common targets from package.json","suites":["TargetResolver"],"updatePoint":{"line":220,"column":54,"index":6254},"line":220,"code":"  it('allows ignoring common targets from package.json', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    assert.deepEqual(await targetResolver.resolve(COMMON_TARGETS_IGNORE_FIXTURE_PATH), [{\n      name: 'app',\n      distDir: relative(path.join(COMMON_TARGETS_IGNORE_FIXTURE_PATH, 'dist')),\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: 'f7c9644283a8698f',\n        context: 'node',\n        engines: {\n          node: '>= 8.0.0'\n        },\n        includeNodeModules: false,\n        outputFormat: 'commonjs',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: undefined,\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(COMMON_TARGETS_IGNORE_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 10,\n          line: 3\n        },\n        end: {\n          column: 24,\n          line: 3\n        }\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolves custom targets from package.json","suites":["TargetResolver"],"updatePoint":{"line":255,"column":47,"index":7263},"line":255,"code":"  it('resolves custom targets from package.json', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    assert.deepEqual(await targetResolver.resolve(CUSTOM_TARGETS_FIXTURE_PATH), [{\n      name: 'main',\n      distDir: 'fixtures/custom-targets/dist/main',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: 'b552bd32da37fa8b',\n        context: 'node',\n        engines: {\n          node: '>= 8.0.0'\n        },\n        includeNodeModules: false,\n        outputFormat: 'commonjs',\n        isLibrary: true,\n        shouldOptimize: false,\n        shouldScopeHoist: true,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(CUSTOM_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 11,\n          line: 2\n        },\n        end: {\n          column: 30,\n          line: 2\n        }\n      }\n    }, {\n      name: 'browserModern',\n      distDir: 'fixtures/custom-targets/dist/browserModern',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: '1f28e9ceaf633d83',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 version']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(CUSTOM_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 20,\n          line: 3\n        },\n        end: {\n          column: 48,\n          line: 3\n        }\n      }\n    }, {\n      name: 'browserLegacy',\n      distDir: 'fixtures/custom-targets/dist/browserLegacy',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: '767bf6e6b675c4f3',\n        context: 'browser',\n        engines: {\n          browsers: ['ie11']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(CUSTOM_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 20,\n          line: 4\n        },\n        end: {\n          column: 48,\n          line: 4\n        }\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should not optimize libraries by default","suites":["TargetResolver"],"updatePoint":{"line":352,"column":46,"index":9753},"line":352,"code":"  it('should not optimize libraries by default', async () => {\n    let targetResolver = new TargetResolver(api, {\n      ...DEFAULT_OPTIONS,\n      mode: 'production',\n      defaultTargetOptions: {\n        ...DEFAULT_OPTIONS.defaultTargetOptions,\n        shouldOptimize: true\n      }\n    });\n    assert.deepEqual(await targetResolver.resolve(CUSTOM_TARGETS_FIXTURE_PATH), [{\n      name: 'main',\n      distDir: 'fixtures/custom-targets/dist/main',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: 'b552bd32da37fa8b',\n        context: 'node',\n        engines: {\n          node: '>= 8.0.0'\n        },\n        includeNodeModules: false,\n        outputFormat: 'commonjs',\n        isLibrary: true,\n        shouldOptimize: false,\n        shouldScopeHoist: true,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(CUSTOM_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 11,\n          line: 2\n        },\n        end: {\n          column: 30,\n          line: 2\n        }\n      }\n    }, {\n      name: 'browserModern',\n      distDir: 'fixtures/custom-targets/dist/browserModern',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: 'ed7c0e65adee71c9',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 version']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: true,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(CUSTOM_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 20,\n          line: 3\n        },\n        end: {\n          column: 48,\n          line: 3\n        }\n      }\n    }, {\n      name: 'browserLegacy',\n      distDir: 'fixtures/custom-targets/dist/browserLegacy',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: 'f7692543e59e4c0a',\n        context: 'browser',\n        engines: {\n          browsers: ['ie11']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: true,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(CUSTOM_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 20,\n          line: 4\n        },\n        end: {\n          column: 48,\n          line: 4\n        }\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolves explicit distDir for custom targets from package.json","suites":["TargetResolver"],"updatePoint":{"line":456,"column":68,"index":12423},"line":456,"code":"  it('resolves explicit distDir for custom targets from package.json', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    assert.deepEqual(await targetResolver.resolve(CUSTOM_TARGETS_DISTDIR_FIXTURE_PATH), [{\n      name: 'app',\n      distDir: 'fixtures/custom-targets-distdir/www',\n      distEntry: undefined,\n      publicUrl: 'www',\n      env: {\n        id: 'ddb6ac7c9a3a9178',\n        context: 'browser',\n        engines: {\n          browsers: '> 0.25%'\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: undefined\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"skips targets with custom entry source for default entry","suites":["TargetResolver"],"updatePoint":{"line":481,"column":62,"index":13195},"line":481,"code":"  it('skips targets with custom entry source for default entry', async () => {\n    let targetResolver = new TargetResolver(api, {\n      ...DEFAULT_OPTIONS,\n      targets: {\n        customA: {\n          context: 'browser',\n          distDir: 'customA',\n          source: 'customA/index.js'\n        },\n        customB: {\n          distDir: 'customB'\n        }\n      }\n    });\n    assert.deepEqual(await targetResolver.resolve(COMMON_TARGETS_FIXTURE_PATH), [{\n      name: 'customB',\n      distDir: normalizeSeparators(path.resolve('customB')),\n      publicUrl: '/',\n      env: {\n        id: '1d40417b63734b32',\n        context: 'browser',\n        engines: {\n          browsers: ['> 0.25%']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"skips other targets with custom entry","suites":["TargetResolver"],"updatePoint":{"line":516,"column":43,"index":14129},"line":516,"code":"  it('skips other targets with custom entry', async () => {\n    let targetResolver = new TargetResolver(api, {\n      ...DEFAULT_OPTIONS,\n      targets: {\n        customA: {\n          context: 'browser',\n          distDir: 'customA',\n          source: 'customA/index.js'\n        },\n        customB: {\n          distDir: 'customB'\n        }\n      }\n    });\n    assert.deepEqual(await targetResolver.resolve(COMMON_TARGETS_FIXTURE_PATH, 'customA'), [{\n      name: 'customA',\n      distDir: normalizeSeparators(path.resolve('customA')),\n      publicUrl: '/',\n      env: {\n        id: '1d40417b63734b32',\n        context: 'browser',\n        engines: {\n          browsers: ['> 0.25%']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      source: 'customA/index.js'\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolves main target with context from package.json","suites":["TargetResolver"],"updatePoint":{"line":552,"column":57,"index":15122},"line":552,"code":"  it('resolves main target with context from package.json', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    assert.deepEqual(await targetResolver.resolve(CONTEXT_FIXTURE_PATH), [{\n      name: 'main',\n      distDir: 'fixtures/context/dist/main',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: '6aafdb9eaa4a3812',\n        context: 'node',\n        engines: {\n          browsers: ['last 1 Chrome version', 'last 1 Safari version', 'last 1 Firefox version', 'last 1 Edge version']\n        },\n        includeNodeModules: false,\n        isLibrary: true,\n        outputFormat: 'commonjs',\n        shouldOptimize: false,\n        shouldScopeHoist: true,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(CONTEXT_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 11,\n          line: 2\n        },\n        end: {\n          column: 30,\n          line: 2\n        }\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"errors when the main target contains a non-js extension","suites":["TargetResolver"],"updatePoint":{"line":587,"column":61,"index":16167},"line":587,"code":"  it('errors when the main target contains a non-js extension', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/application-targets');\n    let code = await fs.readFile(path.join(fixture, 'package.json'), 'utf8');\n\n    // $FlowFixMe\n    await assert.rejects(() => targetResolver.resolve(fixture), {\n      diagnostics: [{\n        message: 'Unexpected output file type .html in target \"main\"',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(fixture, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            end: {\n              column: 27,\n              line: 2\n            },\n            message: 'File extension must be .js, .mjs, or .cjs',\n            start: {\n              column: 11,\n              line: 2\n            }\n          }]\n        }],\n        hints: ['The \"main\" field is meant for libraries. If you meant to output a .html file, either remove the \"main\" field or choose a different target name.'],\n        documentationURL: 'https://parceljs.org/features/targets/#library-targets'\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"errors when the main target uses the global output format","suites":["TargetResolver"],"updatePoint":{"line":618,"column":63,"index":17352},"line":618,"code":"  it('errors when the main target uses the global output format', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/main-global');\n    let code = await fs.readFile(path.join(fixture, 'package.json'), 'utf8');\n\n    // $FlowFixMe\n    await assert.rejects(() => targetResolver.resolve(fixture), {\n      diagnostics: [{\n        message: 'The \"global\" output format is not supported in the \"main\" target.',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(fixture, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            message: undefined,\n            end: {\n              column: 30,\n              line: 5\n            },\n            start: {\n              column: 23,\n              line: 5\n            }\n          }]\n        }],\n        hints: ['The \"main\" field is meant for libraries. The outputFormat must be either \"commonjs\" or \"esmodule\". Either change or remove the declared outputFormat.'],\n        documentationURL: 'https://parceljs.org/features/targets/#library-targets'\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"errors when the main target uses the esmodule output format without a .mjs extension or \"type\": \"module\" field","suites":["TargetResolver"],"updatePoint":{"line":649,"column":116,"index":18569},"line":649,"code":"  it('errors when the main target uses the esmodule output format without a .mjs extension or \"type\": \"module\" field', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/main-mjs');\n    let code = await fs.readFile(path.join(fixture, 'package.json'), 'utf8');\n\n    // $FlowFixMe\n    await assert.rejects(() => targetResolver.resolve(fixture), {\n      diagnostics: [{\n        message: 'Output format \"esmodule\" cannot be used in the \"main\" target without a .mjs extension or \"type\": \"module\" field.',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(fixture, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            message: 'Declared output format defined here',\n            end: {\n              column: 32,\n              line: 5\n            },\n            start: {\n              column: 23,\n              line: 5\n            }\n          }, {\n            message: 'Inferred output format defined here',\n            end: {\n              column: 25,\n              line: 2\n            },\n            start: {\n              column: 11,\n              line: 2\n            }\n          }]\n        }],\n        hints: ['Either change the output file extension to .mjs, add \"type\": \"module\" to package.json, or remove the declared outputFormat.'],\n        documentationURL: 'https://parceljs.org/features/targets/#library-targets'\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"errors when the inferred output format does not match the declared one in common targets","suites":["TargetResolver"],"updatePoint":{"line":690,"column":94,"index":20050},"line":690,"code":"  it('errors when the inferred output format does not match the declared one in common targets', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/main-format-mismatch');\n    let code = await fs.readFile(path.join(fixture, 'package.json'), 'utf8');\n\n    // $FlowFixMe\n    await assert.rejects(() => targetResolver.resolve(fixture), {\n      diagnostics: [{\n        message: 'Declared output format \"esmodule\" does not match expected output format \"commonjs\".',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(fixture, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            message: 'Declared output format defined here',\n            end: {\n              column: 32,\n              line: 5\n            },\n            start: {\n              column: 23,\n              line: 5\n            }\n          }, {\n            message: 'Inferred output format defined here',\n            end: {\n              column: 26,\n              line: 2\n            },\n            start: {\n              column: 11,\n              line: 2\n            }\n          }]\n        }],\n        hints: ['Either remove the target\\'s declared \"outputFormat\" or change the extension to .mjs or .js.'],\n        documentationURL: 'https://parceljs.org/features/targets/#library-targets'\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"errors when the inferred output format does not match the declared one in custom targets","suites":["TargetResolver"],"updatePoint":{"line":731,"column":94,"index":21482},"line":731,"code":"  it('errors when the inferred output format does not match the declared one in custom targets', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/custom-format-mismatch');\n    let code = await fs.readFile(path.join(fixture, 'package.json'), 'utf8');\n\n    // $FlowFixMe\n    await assert.rejects(() => targetResolver.resolve(fixture), {\n      diagnostics: [{\n        message: 'Declared output format \"commonjs\" does not match expected output format \"esmodule\".',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(fixture, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            message: 'Declared output format defined here',\n            end: {\n              column: 32,\n              line: 5\n            },\n            start: {\n              column: 23,\n              line: 5\n            }\n          }, {\n            message: 'Inferred output format defined here',\n            end: {\n              column: 26,\n              line: 2\n            },\n            start: {\n              column: 11,\n              line: 2\n            }\n          }]\n        }],\n        hints: ['Either remove the target\\'s declared \"outputFormat\" or change the extension to .cjs or .js.'],\n        documentationURL: 'https://parceljs.org/features/targets/#library-targets'\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"errors when a common library target turns scope hoisting off","suites":["TargetResolver"],"updatePoint":{"line":772,"column":66,"index":22888},"line":772,"code":"  it('errors when a common library target turns scope hoisting off', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/library-scopehoist');\n    let code = await fs.readFile(path.join(fixture, 'package.json'), 'utf8');\n\n    // $FlowFixMe\n    await assert.rejects(() => targetResolver.resolve(fixture), {\n      diagnostics: [{\n        message: 'Scope hoisting cannot be disabled for library targets.',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(fixture, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            message: undefined,\n            end: {\n              column: 25,\n              line: 5\n            },\n            start: {\n              column: 21,\n              line: 5\n            }\n          }]\n        }],\n        hints: ['The \"main\" target is meant for libraries. Either remove the \"scopeHoist\" option, or use a different target name.'],\n        documentationURL: 'https://parceljs.org/features/targets/#library-targets'\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"errors when a custom library target turns scope hoisting off","suites":["TargetResolver"],"updatePoint":{"line":803,"column":66,"index":24014},"line":803,"code":"  it('errors when a custom library target turns scope hoisting off', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/library-custom-scopehoist');\n    let code = await fs.readFile(path.join(fixture, 'package.json'), 'utf8');\n\n    // $FlowFixMe\n    await assert.rejects(() => targetResolver.resolve(fixture), {\n      diagnostics: [{\n        message: 'Scope hoisting cannot be disabled for library targets.',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(fixture, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            message: undefined,\n            end: {\n              column: 25,\n              line: 6\n            },\n            start: {\n              column: 21,\n              line: 6\n            }\n          }, {\n            message: undefined,\n            end: {\n              column: 23,\n              line: 5\n            },\n            start: {\n              column: 20,\n              line: 5\n            }\n          }]\n        }],\n        hints: ['Either remove the \"scopeHoist\" or \"isLibrary\" option.'],\n        documentationURL: 'https://parceljs.org/features/targets/#library-targets'\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should infer output format for custom targets by extension","suites":["TargetResolver"],"updatePoint":{"line":844,"column":64,"index":25298},"line":844,"code":"  it('should infer output format for custom targets by extension', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/custom-format-infer-ext');\n    assert.deepEqual(await targetResolver.resolve(fixture), [{\n      name: 'test',\n      distDir: relative(path.join(fixture, 'dist')),\n      distEntry: 'index.mjs',\n      publicUrl: '/',\n      env: {\n        id: '439701173a9199ea',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 Chrome version', 'last 1 Safari version', 'last 1 Firefox version', 'last 1 Edge version']\n        },\n        includeNodeModules: true,\n        outputFormat: 'esmodule',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(fixture, 'package.json')),\n        start: {\n          column: 11,\n          line: 2\n        },\n        end: {\n          column: 26,\n          line: 2\n        }\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"should infer output format for custom targets by \"type\": \"module\" field","suites":["TargetResolver"],"updatePoint":{"line":880,"column":77,"index":26422},"line":880,"code":"  it('should infer output format for custom targets by \"type\": \"module\" field', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let fixture = path.join(__dirname, 'fixtures/custom-format-infer-type');\n    assert.deepEqual(await targetResolver.resolve(fixture), [{\n      name: 'test',\n      distDir: relative(path.join(fixture, 'dist')),\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: '439701173a9199ea',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 Chrome version', 'last 1 Safari version', 'last 1 Firefox version', 'last 1 Edge version']\n        },\n        includeNodeModules: true,\n        outputFormat: 'esmodule',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(fixture, 'package.json')),\n        start: {\n          column: 11,\n          line: 3\n        },\n        end: {\n          column: 25,\n          line: 3\n        }\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"resolves a subset of package.json targets when given a list of names","suites":["TargetResolver"],"updatePoint":{"line":916,"column":74,"index":27543},"line":916,"code":"  it('resolves a subset of package.json targets when given a list of names', async () => {\n    let targetResolver = new TargetResolver(api, {\n      ...DEFAULT_OPTIONS,\n      targets: ['main', 'browser']\n    });\n    assert.deepEqual(await targetResolver.resolve(COMMON_TARGETS_FIXTURE_PATH), [{\n      name: 'main',\n      distDir: 'fixtures/common-targets/dist/main',\n      distEntry: 'index.js',\n      publicUrl: '/',\n      env: {\n        id: 'b552bd32da37fa8b',\n        context: 'node',\n        engines: {\n          node: '>= 8.0.0'\n        },\n        includeNodeModules: false,\n        outputFormat: 'commonjs',\n        isLibrary: true,\n        shouldOptimize: false,\n        shouldScopeHoist: true,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(COMMON_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 11,\n          line: 2\n        },\n        end: {\n          column: 30,\n          line: 2\n        }\n      }\n    }, {\n      name: 'browser',\n      distDir: 'fixtures/common-targets/dist/browser',\n      distEntry: 'index.js',\n      publicUrl: '/assets',\n      env: {\n        id: 'a7ed3e73c53f1923',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 version']\n        },\n        includeNodeModules: false,\n        outputFormat: 'commonjs',\n        isLibrary: true,\n        shouldOptimize: false,\n        shouldScopeHoist: true,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: {\n        filePath: relative(path.join(COMMON_TARGETS_FIXTURE_PATH, 'package.json')),\n        start: {\n          column: 14,\n          line: 4\n        },\n        end: {\n          column: 36,\n          line: 4\n        }\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"generates a default target in serve mode","suites":["TargetResolver"],"updatePoint":{"line":985,"column":46,"index":29320},"line":985,"code":"  it('generates a default target in serve mode', async () => {\n    let serveDistDir = path.join(DEFAULT_OPTIONS.cacheDir, 'dist');\n    let targetResolver = new TargetResolver(api, {\n      ...DEFAULT_OPTIONS,\n      serveOptions: {\n        distDir: serveDistDir,\n        port: 1234\n      }\n    });\n    assert.deepEqual(await targetResolver.resolve(COMMON_TARGETS_FIXTURE_PATH), [{\n      name: 'default',\n      distDir: '.parcel-cache/dist',\n      publicUrl: '/',\n      env: {\n        id: 'd6ea1d42532a7575',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 Chrome version', 'last 1 Safari version', 'last 1 Firefox version', 'last 1 Edge version']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"generates the correct distDir with no explicit targets","suites":["TargetResolver"],"updatePoint":{"line":1015,"column":60,"index":30273},"line":1015,"code":"  it('generates the correct distDir with no explicit targets', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    assert.deepEqual(await targetResolver.resolve(DEFAULT_DISTPATH_FIXTURE_PATHS.none), [{\n      name: 'default',\n      distDir: relative(path.join(DEFAULT_DISTPATH_FIXTURE_PATHS.none, 'dist')),\n      publicUrl: '/',\n      env: {\n        id: 'a9c07d094d038c73',\n        context: 'browser',\n        engines: {\n          browsers: ['Chrome 80']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      }\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"generates the correct distDir with one explicit target","suites":["TargetResolver"],"updatePoint":{"line":1038,"column":60,"index":31026},"line":1038,"code":"  it('generates the correct distDir with one explicit target', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    assert.deepEqual(await targetResolver.resolve(DEFAULT_DISTPATH_FIXTURE_PATHS.one), [{\n      name: 'browserModern',\n      distDir: relative(path.join(DEFAULT_DISTPATH_FIXTURE_PATHS.one, 'dist')),\n      distEntry: undefined,\n      publicUrl: '/',\n      env: {\n        id: 'a9c07d094d038c73',\n        context: 'browser',\n        engines: {\n          browsers: ['Chrome 80']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: undefined\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"generates the correct distDirs with two explicit targets","suites":["TargetResolver"],"updatePoint":{"line":1063,"column":62,"index":31835},"line":1063,"code":"  it('generates the correct distDirs with two explicit targets', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    assert.deepEqual(await targetResolver.resolve(DEFAULT_DISTPATH_FIXTURE_PATHS.two), [{\n      name: 'browserModern',\n      distDir: relative(path.join(DEFAULT_DISTPATH_FIXTURE_PATHS.two, 'dist', 'browserModern')),\n      distEntry: undefined,\n      publicUrl: '/',\n      env: {\n        id: '1f28e9ceaf633d83',\n        context: 'browser',\n        engines: {\n          browsers: ['last 1 version']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: undefined\n    }, {\n      name: 'browserLegacy',\n      distDir: relative(path.join(DEFAULT_DISTPATH_FIXTURE_PATHS.two, 'dist', 'browserLegacy')),\n      distEntry: undefined,\n      publicUrl: '/',\n      env: {\n        id: '824e113c03cab3c8',\n        context: 'browser',\n        engines: {\n          browsers: ['IE 11']\n        },\n        includeNodeModules: true,\n        outputFormat: 'global',\n        isLibrary: false,\n        shouldOptimize: false,\n        shouldScopeHoist: false,\n        sourceMap: {},\n        loc: undefined,\n        sourceType: 'module'\n      },\n      loc: undefined\n    }]);\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects invalid or unknown fields","suites":["TargetResolver"],"updatePoint":{"line":1109,"column":39,"index":33223},"line":1109,"code":"  it('rejects invalid or unknown fields', async () => {\n    let code = '{\\n' + '\\t\"targets\": {\\n' + '\\t\\t\"main\": {\\n' + '\\t\\t\\t\"includeNodeModules\": [\\n' + '\\t\\t\\t\\t\"react\",\\n' + '\\t\\t\\t\\ttrue\\n' + '\\t\\t\\t],\\n' + '\\t\\t\\t\"context\": \"nodes\",\\n' + '\\t\\t\\t\"outputFormat\": \"module\",\\n' + '\\t\\t\\t\"sourceMap\": {\\n' + '\\t\\t\\t\\t\"sourceRoot\": \"asd\",\\n' + '\\t\\t\\t\\t\"inline\": \"false\",\\n' + '\\t\\t\\t\\t\"verbose\": true\\n' + '\\t\\t\\t},\\n' + '\\t\\t\\t\"engines\": {\\n' + '\\t\\t\\t\\t\"node\": \"12\",\\n' + '\\t\\t\\t\\t\"browser\": \"Chrome 70\"\\n' + '\\t\\t\\t}\\n' + '\\t\\t}\\n' + '\\t}\\n' + '}';\n    let targetResolver = new TargetResolver(api, {\n      ...DEFAULT_OPTIONS,\n      ...JSON.parse(code)\n    });\n\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => targetResolver.resolve(COMMON_TARGETS_FIXTURE_PATH), {\n      message: 'Invalid target descriptor for target \"main\"',\n      diagnostics: [{\n        message: 'Invalid target descriptor for target \"main\"',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: undefined,\n          language: 'json',\n          code,\n          codeHighlights: [{\n            start: {\n              line: 6,\n              column: 5\n            },\n            end: {\n              line: 6,\n              column: 8\n            },\n            message: 'Expected a wildcard or filepath'\n          }, {\n            start: {\n              line: 8,\n              column: 15\n            },\n            end: {\n              line: 8,\n              column: 21\n            },\n            message: 'Did you mean \"node\"?'\n          }, {\n            start: {\n              line: 9,\n              column: 20\n            },\n            end: {\n              line: 9,\n              column: 27\n            },\n            message: 'Did you mean \"esmodule\"?'\n          }, {\n            start: {\n              line: 12,\n              column: 15\n            },\n            end: {\n              line: 12,\n              column: 21\n            },\n            message: 'Expected type boolean'\n          }, {\n            start: {\n              line: 13,\n              column: 5\n            },\n            end: {\n              line: 13,\n              column: 13\n            },\n            message: 'Possible values: \"inlineSources\"'\n          }, {\n            start: {\n              line: 17,\n              column: 5\n            },\n            end: {\n              line: 17,\n              column: 13\n            },\n            message: 'Did you mean \"browsers\"?'\n          }]\n        }]\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects invalid or unknown fields in package.json","suites":["TargetResolver"],"updatePoint":{"line":1191,"column":55,"index":35759},"line":1191,"code":"  it('rejects invalid or unknown fields in package.json', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let code = await fs.readFileSync(path.join(INVALID_TARGETS_FIXTURE_PATH, 'package.json'), 'utf8');\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => targetResolver.resolve(INVALID_TARGETS_FIXTURE_PATH), {\n      diagnostics: [{\n        message: 'Invalid target descriptor for target \"module\"',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(INVALID_TARGETS_FIXTURE_PATH, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            start: {\n              line: 9,\n              column: 29\n            },\n            end: {\n              line: 9,\n              column: 35\n            },\n            message: 'Expected type boolean'\n          }, {\n            start: {\n              line: 11,\n              column: 7\n            },\n            end: {\n              line: 11,\n              column: 17\n            },\n            message: 'Did you mean \"publicUrl\"?'\n          }]\n        }]\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects invalid engines in package.json","suites":["TargetResolver"],"updatePoint":{"line":1228,"column":45,"index":36905},"line":1228,"code":"  it('rejects invalid engines in package.json', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let code = await fs.readFileSync(path.join(INVALID_ENGINES_FIXTURE_PATH, 'package.json'), 'utf8');\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => targetResolver.resolve(INVALID_ENGINES_FIXTURE_PATH), {\n      diagnostics: [{\n        message: 'Invalid engines in package.json',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(INVALID_ENGINES_FIXTURE_PATH, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            end: {\n              column: 13,\n              line: 8\n            },\n            message: 'Did you mean \"browsers\"?',\n            start: {\n              column: 5,\n              line: 8\n            }\n          }, {\n            end: {\n              column: 5,\n              line: 7\n            },\n            message: 'Expected type string',\n            start: {\n              column: 13,\n              line: 5\n            }\n          }]\n        }]\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects target distpath in package.json","suites":["TargetResolver"],"updatePoint":{"line":1265,"column":45,"index":38032},"line":1265,"code":"  it('rejects target distpath in package.json', async () => {\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let code = await fs.readFileSync(path.join(INVALID_DISTPATH_FIXTURE_PATH, 'package.json'), 'utf8');\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => targetResolver.resolve(INVALID_DISTPATH_FIXTURE_PATH), {\n      diagnostics: [{\n        message: 'Invalid distPath for target \"legacy\"',\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(INVALID_DISTPATH_FIXTURE_PATH, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            end: {\n              column: 13,\n              line: 2\n            },\n            message: 'Expected type string',\n            start: {\n              column: 13,\n              line: 2\n            }\n          }]\n        }]\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"rejects duplicate target paths","suites":["TargetResolver"],"updatePoint":{"line":1292,"column":36,"index":38931},"line":1292,"code":"  it('rejects duplicate target paths', async () => {\n    let fixture = path.join(__dirname, 'fixtures/duplicate-targets');\n    let targetResolver = new TargetResolver(api, DEFAULT_OPTIONS);\n    let code = await fs.readFileSync(path.join(fixture, 'package.json'), 'utf8');\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => targetResolver.resolve(fixture), {\n      diagnostics: [{\n        message: md`Multiple targets have the same destination path \"${path.normalize('dist/index.js')}\"`,\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: path.join(fixture, 'package.json'),\n          language: 'json',\n          code,\n          codeHighlights: [{\n            end: {\n              column: 25,\n              line: 2\n            },\n            message: undefined,\n            start: {\n              column: 11,\n              line: 2\n            }\n          }, {\n            end: {\n              column: 27,\n              line: 3\n            },\n            message: undefined,\n            start: {\n              column: 13,\n              line: 3\n            }\n          }]\n        }],\n        hints: ['Try removing the duplicate targets, or changing the destination paths.']\n      }]\n    });\n  });","file":"TargetRequest.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"only accepts 32-character hexadecimal strings","suites":["getPublicId"],"updatePoint":{"line":8,"column":51,"index":252},"line":8,"code":"  it('only accepts 32-character hexadecimal strings', () => {\n    assert.throws(() => {\n      getPublicId('abc', () => false);\n    });\n    let notHexadecimal = 'abcdefghiklmnopqrstuvwxyz1234567';\n    assert.equal(notHexadecimal.length, 32);\n    assert.throws(() => {\n      getPublicId(notHexadecimal, () => false);\n    });\n  });","file":"utils.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"if no collisions, returns the first 5 base62 characters of value represented by the input","suites":["getPublicId"],"updatePoint":{"line":18,"column":95,"index":625},"line":18,"code":"  it('if no collisions, returns the first 5 base62 characters of value represented by the input', () => {\n    assert.equal(getPublicId(id, () => false), fullPublicId.slice(0, 5));\n  });","file":"utils.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"uses more characters if there is a collision","suites":["getPublicId"],"updatePoint":{"line":21,"column":50,"index":766},"line":21,"code":"  it('uses more characters if there is a collision', () => {\n    assert.equal(getPublicId(id, publicId => [fullPublicId.slice(0, 5), fullPublicId.slice(0, 6)].includes(publicId)), fullPublicId.slice(0, 7));\n  });","file":"utils.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"fails if all characters collide","suites":["getPublicId"],"updatePoint":{"line":24,"column":37,"index":966},"line":24,"code":"  it('fails if all characters collide', () => {\n    assert.throws(() => {\n      getPublicId(id, () => true);\n    });\n  });","file":"utils.test.js","skipped":false,"dir":"packages/core/core/test"},{"name":"returns an escaped string 01","suites":["escapeMarkdown"],"updatePoint":{"line":5,"column":34,"index":156},"line":5,"code":"  it('returns an escaped string 01', () => {\n    assert.strictEqual('\\\\*test\\\\*', escapeMarkdown('*test*'));\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"returns an escaped string 02","suites":["escapeMarkdown"],"updatePoint":{"line":8,"column":34,"index":271},"line":8,"code":"  it('returns an escaped string 02', () => {\n    assert.strictEqual('\\\\_test\\\\_', escapeMarkdown('_test_'));\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"returns an escaped string 03","suites":["escapeMarkdown"],"updatePoint":{"line":11,"column":34,"index":386},"line":11,"code":"  it('returns an escaped string 03', () => {\n    assert.strictEqual('\\\\~test\\\\~', escapeMarkdown('~test~'));\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"returns an escaped string 04","suites":["escapeMarkdown"],"updatePoint":{"line":14,"column":34,"index":501},"line":14,"code":"  it('returns an escaped string 04', () => {\n    assert.strictEqual('\\\\*\\\\_\\\\~test\\\\~\\\\_\\\\*', escapeMarkdown('*_~test~_*'));\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"returns an escaped string with backslash 01","suites":["escapeMarkdown"],"updatePoint":{"line":17,"column":49,"index":647},"line":17,"code":"  it('returns an escaped string with backslash 01', () => {\n    assert.strictEqual('\\\\\\\\test\\\\\\\\', escapeMarkdown('\\\\test\\\\'));\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"returns an escaped string with backslash 02","suites":["escapeMarkdown"],"updatePoint":{"line":20,"column":49,"index":781},"line":20,"code":"  it('returns an escaped string with backslash 02', () => {\n    assert.strictEqual('\\\\\\\\\\\\*test\\\\*\\\\\\\\', escapeMarkdown('\\\\*test*\\\\'));\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"bold placeholder","suites":["md tagged template literal"],"updatePoint":{"line":25,"column":22,"index":947},"line":25,"code":"  it('bold placeholder', () => {\n    assert.strictEqual('*Test*: **\\\\_abc\\\\_**', md`*Test*: ${md.bold('_abc_')}`);\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"italic placeholder","suites":["md tagged template literal"],"updatePoint":{"line":28,"column":24,"index":1070},"line":28,"code":"  it('italic placeholder', () => {\n    assert.strictEqual('*Test*: _\\\\_abc\\\\__', md`*Test*: ${md.italic('_abc_')}`);\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"underline placeholder","suites":["md tagged template literal"],"updatePoint":{"line":31,"column":27,"index":1196},"line":31,"code":"  it('underline placeholder', () => {\n    assert.strictEqual('*Test*: __\\\\_abc\\\\___', md`*Test*: ${md.underline('_abc_')}`);\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"strikethrough placeholder","suites":["md tagged template literal"],"updatePoint":{"line":34,"column":31,"index":1331},"line":34,"code":"  it('strikethrough placeholder', () => {\n    assert.strictEqual('*Test*: ~~\\\\_abc\\\\_~~', md`*Test*: ${md.strikethrough('_abc_')}`);\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"escapes only placeholders","suites":["md tagged template literal"],"updatePoint":{"line":37,"column":31,"index":1470},"line":37,"code":"  it('escapes only placeholders', () => {\n    assert.strictEqual('*Test*: \\\\_abc\\\\_', md`*Test*: ${'_abc_'}`);\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"behaves like native template literal","suites":["md tagged template literal"],"updatePoint":{"line":40,"column":42,"index":1598},"line":40,"code":"  it('behaves like native template literal', () => {\n    let v = {\n      toString() {\n        return 'a';\n      },\n      // $FlowFixMe[invalid-computed-prop]\n      [Symbol.toPrimitive]() {\n        return 'b';\n      }\n    };\n    assert.strictEqual('Test: b', md`Test: ${v}`);\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"supports null and undefined","suites":["md tagged template literal"],"updatePoint":{"line":52,"column":33,"index":1870},"line":52,"code":"  it('supports null and undefined', () => {\n    assert.strictEqual('Test: undefined null', md`Test: ${undefined} ${null}`);\n  });","file":"markdown.test.js","skipped":false,"dir":"packages/core/diagnostic/test"},{"name":"constructor should initialize an empty graph","suites":["AdjacencyList"],"updatePoint":{"line":9,"column":50,"index":303},"line":9,"code":"  it('constructor should initialize an empty graph', () => {\n    let stats = new AdjacencyList().stats;\n    assert(stats.nodes === 0);\n    assert(stats.edges === 0);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addNode should add a node to the graph","suites":["AdjacencyList"],"updatePoint":{"line":14,"column":44,"index":469},"line":14,"code":"  it('addNode should add a node to the graph', () => {\n    let graph = new AdjacencyList();\n    let id = graph.addNode();\n    assert.equal(id, 0);\n    assert.equal(graph.stats.nodes, 1);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addNode should resize nodes array when necessary","suites":["AdjacencyList"],"updatePoint":{"line":20,"column":54,"index":672},"line":20,"code":"  it('addNode should resize nodes array when necessary', () => {\n    let graph = new AdjacencyList();\n    let size = graph.serialize().nodes.byteLength;\n    let a = graph.addNode();\n    let b = graph.addNode();\n    assert(size < (size = graph.serialize().nodes.byteLength));\n    graph.addEdge(a, b, 1);\n    graph.addEdge(a, b, 2);\n    graph.addEdge(a, b, 3);\n    graph.addEdge(a, b, 4);\n    assert(size < graph.serialize().nodes.byteLength);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"removeEdge should remove an edge from the graph","suites":["AdjacencyList"],"updatePoint":{"line":32,"column":53,"index":1119},"line":32,"code":"  it('removeEdge should remove an edge from the graph', () => {\n    let graph = new AdjacencyList();\n    let node0 = graph.addNode();\n    let node1 = graph.addNode();\n    let node2 = graph.addNode();\n    let node3 = graph.addNode();\n    let node4 = graph.addNode();\n    let node5 = graph.addNode();\n    let node6 = graph.addNode();\n    graph.addEdge(node0, node1);\n    graph.addEdge(node2, node1);\n    // this will get removed\n    graph.addEdge(node3, node1);\n    graph.addEdge(node4, node1);\n    graph.addEdge(node5, node1);\n    graph.addEdge(node6, node1);\n    assert.deepEqual(graph.getNodeIdsConnectedTo(node1), [0, 2, 3, 4, 5, 6]);\n    graph.removeEdge(node3, node1);\n    assert.deepEqual(graph.getNodeIdsConnectedTo(node1), [0, 2, 4, 5, 6]);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"getNodeIdsConnectedTo and getNodeIdsConnectedFrom should remove duplicate values","suites":["AdjacencyList"],"updatePoint":{"line":52,"column":86,"index":1906},"line":52,"code":"  it('getNodeIdsConnectedTo and getNodeIdsConnectedFrom should remove duplicate values', () => {\n    let graph = new AdjacencyList();\n    let a = graph.addNode();\n    let b = graph.addNode();\n    let c = graph.addNode();\n    graph.addEdge(a, b);\n    graph.addEdge(a, c);\n    graph.addEdge(a, b, 2);\n    assert.deepEqual(graph.getNodeIdsConnectedFrom(a, -1), [b, c]);\n    assert.deepEqual(graph.getNodeIdsConnectedTo(b, -1), [a]);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"removeEdge should remove an edge of a specific type from the graph","suites":["AdjacencyList"],"updatePoint":{"line":63,"column":72,"index":2328},"line":63,"code":"  it('removeEdge should remove an edge of a specific type from the graph', () => {\n    let graph = new AdjacencyList();\n    let a = graph.addNode();\n    let b = graph.addNode();\n    let c = graph.addNode();\n    let d = graph.addNode();\n    graph.addEdge(a, b);\n    graph.addEdge(a, b, 2);\n    graph.addEdge(a, b, 3);\n    graph.addEdge(a, c);\n    graph.addEdge(a, d, 3);\n    assert.equal(graph.stats.edges, 5);\n    assert.ok(graph.hasEdge(a, b));\n    assert.ok(graph.hasEdge(a, b, 2));\n    assert.ok(graph.hasEdge(a, b, 3));\n    assert.ok(graph.hasEdge(a, c));\n    assert.ok(graph.hasEdge(a, d, 3));\n    assert.deepEqual(Array.from(graph.getAllEdges()), [{\n      from: a,\n      to: b,\n      type: 1\n    }, {\n      from: a,\n      to: b,\n      type: 2\n    }, {\n      from: a,\n      to: b,\n      type: 3\n    }, {\n      from: a,\n      to: c,\n      type: 1\n    }, {\n      from: a,\n      to: d,\n      type: 3\n    }]);\n    graph.removeEdge(a, b, 2);\n    assert.equal(graph.stats.edges, 4);\n    assert.ok(graph.hasEdge(a, b));\n    assert.equal(graph.hasEdge(a, b, 2), false);\n    assert.ok(graph.hasEdge(a, b, 3));\n    assert.ok(graph.hasEdge(a, c));\n    assert.ok(graph.hasEdge(a, d, 3));\n    assert.deepEqual(Array.from(graph.getAllEdges()), [{\n      from: a,\n      to: b,\n      type: 1\n    }, {\n      from: a,\n      to: b,\n      type: 3\n    }, {\n      from: a,\n      to: c,\n      type: 1\n    }, {\n      from: a,\n      to: d,\n      type: 3\n    }]);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should add an edge to the graph","suites":["AdjacencyList"],"updatePoint":{"line":126,"column":45,"index":3749},"line":126,"code":"  it('addEdge should add an edge to the graph', () => {\n    let graph = new AdjacencyList();\n    let a = graph.addNode();\n    let b = graph.addNode();\n    graph.addEdge(a, b);\n    assert.equal(graph.stats.nodes, 2);\n    assert.equal(graph.stats.edges, 1);\n    assert.ok(graph.hasEdge(a, b));\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should add multiple edges from a node in order","suites":["AdjacencyList"],"updatePoint":{"line":135,"column":60,"index":4062},"line":135,"code":"  it('addEdge should add multiple edges from a node in order', () => {\n    let graph = new AdjacencyList();\n    let a = graph.addNode();\n    let b = graph.addNode();\n    let c = graph.addNode();\n    let d = graph.addNode();\n    graph.addEdge(a, b);\n    graph.addEdge(a, d);\n    graph.addEdge(a, c);\n    assert.deepEqual(graph.getNodeIdsConnectedFrom(a), [b, d, c]);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should add multiple edges to a node in order","suites":["AdjacencyList"],"updatePoint":{"line":146,"column":58,"index":4432},"line":146,"code":"  it('addEdge should add multiple edges to a node in order', () => {\n    let graph = new AdjacencyList();\n    let a = graph.addNode();\n    let b = graph.addNode();\n    let c = graph.addNode();\n    let d = graph.addNode();\n    graph.addEdge(a, b);\n    graph.addEdge(d, b);\n    graph.addEdge(a, d);\n    graph.addEdge(c, b);\n    assert.deepEqual(graph.getNodeIdsConnectedTo(b), [a, d, c]);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should add multiple edges of different types in order","suites":["AdjacencyList"],"updatePoint":{"line":158,"column":67,"index":4834},"line":158,"code":"  it('addEdge should add multiple edges of different types in order', () => {\n    let graph = new AdjacencyList();\n    let a = graph.addNode();\n    let b = graph.addNode();\n    graph.addEdge(a, b);\n    graph.addEdge(a, b, 1);\n    graph.addEdge(a, b, 4);\n    graph.addEdge(a, b, 3);\n    assert.deepEqual(graph.getNodeIdsConnectedFrom(a), [b]);\n    assert.deepEqual(Array.from(graph.getAllEdges()), [{\n      from: a,\n      to: b,\n      type: 1\n    }, {\n      from: a,\n      to: b,\n      type: 4\n    }, {\n      from: a,\n      to: b,\n      type: 3\n    }]);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should return false if an edge is already added","suites":["AdjacencyList"],"updatePoint":{"line":181,"column":61,"index":5387},"line":181,"code":"  it('addEdge should return false if an edge is already added', () => {\n    let graph = new AdjacencyList();\n    let a = graph.addNode();\n    let b = graph.addNode();\n    assert.equal(graph.addEdge(a, b), true);\n    assert.equal(graph.addEdge(a, b), false);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should resize edges array when necessary","suites":["AdjacencyList"],"updatePoint":{"line":188,"column":54,"index":5644},"line":188,"code":"  it('addEdge should resize edges array when necessary', () => {\n    let graph = new AdjacencyList();\n    let size = graph.serialize().edges.byteLength;\n    let a = graph.addNode();\n    let b = graph.addNode();\n    graph.addEdge(a, b, 1);\n    graph.addEdge(a, b, 2);\n    graph.addEdge(a, b, 3);\n    assert(size < graph.serialize().edges.byteLength);\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should error when a node has not been added to the graph","suites":["AdjacencyList"],"updatePoint":{"line":198,"column":70,"index":6016},"line":198,"code":"  it('addEdge should error when a node has not been added to the graph', () => {\n    let graph = new AdjacencyList();\n    assert.throws(() => graph.addEdge(toNodeId(0), toNodeId(1)));\n    graph.addNode();\n    assert.throws(() => graph.addEdge(toNodeId(0), toNodeId(1)));\n    graph.addNode();\n    assert.doesNotThrow(() => graph.addEdge(toNodeId(0), toNodeId(1)));\n    assert.throws(() => graph.addEdge(toNodeId(0), toNodeId(2)));\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should error when an unsupported edge type is provided","suites":["AdjacencyList"],"updatePoint":{"line":207,"column":68,"index":6450},"line":207,"code":"  it('addEdge should error when an unsupported edge type is provided', () => {\n    let graph = new AdjacencyList();\n    let a = graph.addNode();\n    let b = graph.addNode();\n    assert.throws(() => graph.addEdge(a, b, 0));\n    assert.throws(() => graph.addEdge(a, b, -1));\n    assert.doesNotThrow(() => graph.addEdge(a, b, 1));\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should not replace a deleted edge if the edge was already added","suites":["AdjacencyList"],"updatePoint":{"line":215,"column":77,"index":6793},"line":215,"code":"  it('addEdge should not replace a deleted edge if the edge was already added', () => {\n    // Mock hash fn to generate collisions\n    // $FlowFixMe[prop-missing]\n    let originalHash = AdjacencyList.prototype.hash;\n    // $FlowFixMe[prop-missing]\n    AdjacencyList.prototype.hash = () => 1;\n    let graph = new AdjacencyList();\n    let n0 = graph.addNode();\n    let n1 = graph.addNode();\n    let n2 = graph.addNode();\n    graph.addEdge(n0, n1, 1);\n    graph.addEdge(n1, n2, 1);\n    graph.removeEdge(n1, n2, 1);\n    assert(graph.addEdge(n0, n1, 1) === false);\n    assert(graph.stats.edges === 1);\n\n    // $FlowFixMe[prop-missing]\n    AdjacencyList.prototype.hash = originalHash;\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should replace a deleted edge","suites":["AdjacencyList"],"updatePoint":{"line":234,"column":43,"index":7444},"line":234,"code":"  it('addEdge should replace a deleted edge', () => {\n    // Mock hash fn to generate collisions\n    // $FlowFixMe[prop-missing]\n    let originalHash = AdjacencyList.prototype.hash;\n    // $FlowFixMe[prop-missing]\n    AdjacencyList.prototype.hash = () => 1;\n    let graph = new AdjacencyList();\n    let n0 = graph.addNode();\n    let n1 = graph.addNode();\n    graph.addEdge(n0, n1, 2);\n    graph.removeEdge(n0, n1, 2);\n    assert(graph.addEdge(n0, n1, 2));\n    assert(graph.stats.edges === 1);\n    assert(graph.stats.deleted === 1);\n    // Resize to reclaim deleted edge space.\n    graph.resizeEdges(4);\n    assert(graph.stats.edges === 1);\n    assert(graph.stats.deleted === 0);\n\n    // $FlowFixMe[prop-missing]\n    AdjacencyList.prototype.hash = originalHash;\n  });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"should share the underlying data across worker threads","suites":["AdjacencyList","deserialize"],"updatePoint":{"line":258,"column":62,"index":8295},"line":258,"code":"    it('should share the underlying data across worker threads', async () => {\n      let graph = new AdjacencyList();\n      let n0 = graph.addNode();\n      let n1 = graph.addNode();\n      graph.addEdge(n0, n1, 1);\n      graph.addEdge(n0, n1, 2);\n      let worker = new Worker(path.join(__dirname, 'integration/adjacency-list-shared-array.js'));\n      let originalSerialized = graph.serialize();\n      let originalNodes = [...originalSerialized.nodes];\n      let originalEdges = [...originalSerialized.edges];\n      let work = new Promise(resolve => worker.on('message', resolve));\n      worker.postMessage(originalSerialized);\n      let received = AdjacencyList.deserialize(await work);\n      await worker.terminate();\n      assert.deepEqual(received.serialize().nodes, graph.serialize().nodes);\n      assert.deepEqual(received.serialize().edges, graph.serialize().edges);\n      originalNodes.forEach((v, i) => {\n        if (i < NodeTypeMap.HEADER_SIZE) {\n          assert.equal(v, received.serialize().nodes[i]);\n          assert.equal(v, graph.serialize().nodes[i]);\n        } else {\n          assert.equal(v * 2, received.serialize().nodes[i]);\n          assert.equal(v * 2, graph.serialize().nodes[i]);\n        }\n      });\n      originalEdges.forEach((v, i) => {\n        if (i < EdgeTypeMap.HEADER_SIZE) {\n          assert.equal(v, received.serialize().edges[i]);\n          assert.equal(v, graph.serialize().edges[i]);\n        } else {\n          assert.equal(v * 2, received.serialize().edges[i]);\n          assert.equal(v * 2, graph.serialize().edges[i]);\n        }\n      });\n    });","file":"AdjacencyList.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"should addNodeByContentKey if no node exists with the content key","suites":["ContentGraph"],"updatePoint":{"line":6,"column":71,"index":184},"line":6,"code":"  it('should addNodeByContentKey if no node exists with the content key', () => {\n    let graph = new ContentGraph();\n    const node = {};\n    const nodeId1 = graph.addNodeByContentKey('contentKey', node);\n    assert.deepEqual(graph.getNode(nodeId1), node);\n    assert(graph.hasContentKey('contentKey'));\n    assert.deepEqual(graph.getNodeByContentKey('contentKey'), node);\n  });","file":"ContentGraph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"should throw if a node with the content key already exists","suites":["ContentGraph"],"updatePoint":{"line":14,"column":64,"index":557},"line":14,"code":"  it('should throw if a node with the content key already exists', () => {\n    let graph = new ContentGraph();\n    graph.addNodeByContentKey('contentKey', {});\n    assert.throws(() => {\n      graph.addNodeByContentKey('contentKey', {});\n    }, /already has content key/);\n  });","file":"ContentGraph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"should remove the content key from graph when node is removed","suites":["ContentGraph"],"updatePoint":{"line":21,"column":67,"index":838},"line":21,"code":"  it('should remove the content key from graph when node is removed', () => {\n    let graph = new ContentGraph();\n    const node1 = {};\n    const nodeId1 = graph.addNodeByContentKey('contentKey', node1);\n    assert.equal(graph.getNode(nodeId1), node1);\n    assert(graph.hasContentKey('contentKey'));\n    graph.removeNode(nodeId1);\n    assert(!graph.hasContentKey('contentKey'));\n  });","file":"ContentGraph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"constructor should initialize an empty graph","suites":["Graph"],"updatePoint":{"line":8,"column":50,"index":210},"line":8,"code":"  it('constructor should initialize an empty graph', () => {\n    let graph = new Graph();\n    assert.deepEqual(graph.nodes, new Map());\n    assert.deepEqual([...graph.getAllEdges()], []);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addNode should add a node to the graph","suites":["Graph"],"updatePoint":{"line":13,"column":44,"index":398},"line":13,"code":"  it('addNode should add a node to the graph', () => {\n    let graph = new Graph();\n    let node = {};\n    let id = graph.addNode(node);\n    assert.equal(graph.nodes.get(id), node);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"errors when traversing a graph with no root","suites":["Graph"],"updatePoint":{"line":19,"column":49,"index":591},"line":19,"code":"  it('errors when traversing a graph with no root', () => {\n    let graph = new Graph();\n    assert.throws(() => {\n      graph.traverse(() => {});\n    }, /A start node is required to traverse/);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"errors when traversing a graph with a startNode that doesn't belong","suites":["Graph"],"updatePoint":{"line":25,"column":73,"index":816},"line":25,"code":"  it(\"errors when traversing a graph with a startNode that doesn't belong\", () => {\n    let graph = new Graph();\n    assert.throws(() => {\n      graph.traverse(() => {}, toNodeId(-1));\n    }, /Does not have node/);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"errors if replaceNodeIdsConnectedTo is called with a node that doesn't belong","suites":["Graph"],"updatePoint":{"line":31,"column":83,"index":1047},"line":31,"code":"  it(\"errors if replaceNodeIdsConnectedTo is called with a node that doesn't belong\", () => {\n    let graph = new Graph();\n    assert.throws(() => {\n      graph.replaceNodeIdsConnectedTo(toNodeId(-1), []);\n    }, /Does not have node/);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"errors when adding an edge to a node that doesn't exist","suites":["Graph"],"updatePoint":{"line":37,"column":61,"index":1267},"line":37,"code":"  it(\"errors when adding an edge to a node that doesn't exist\", () => {\n    let graph = new Graph();\n    let node = graph.addNode({});\n    assert.throws(() => {\n      graph.addEdge(node, toNodeId(-1));\n    }, /\"to\" node '-1' not found/);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"errors when adding an edge from a node that doesn't exist","suites":["Graph"],"updatePoint":{"line":44,"column":63,"index":1513},"line":44,"code":"  it(\"errors when adding an edge from a node that doesn't exist\", () => {\n    let graph = new Graph();\n    let node = graph.addNode({});\n    assert.throws(() => {\n      graph.addEdge(toNodeId(-1), node);\n    }, /\"from\" node '-1' not found/);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"hasNode should return a boolean based on whether the node exists in the graph","suites":["Graph"],"updatePoint":{"line":51,"column":83,"index":1781},"line":51,"code":"  it('hasNode should return a boolean based on whether the node exists in the graph', () => {\n    let graph = new Graph();\n    let node = graph.addNode({});\n    assert(graph.hasNode(node));\n    assert(!graph.hasNode(toNodeId(-1)));\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"addEdge should add an edge to the graph","suites":["Graph"],"updatePoint":{"line":57,"column":45,"index":1981},"line":57,"code":"  it('addEdge should add an edge to the graph', () => {\n    let graph = new Graph();\n    let nodeA = graph.addNode('a');\n    let nodeB = graph.addNode('b');\n    graph.addEdge(nodeA, nodeB);\n    assert(graph.hasEdge(nodeA, nodeB));\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"isOrphanedNode should return true or false if the node is orphaned or not","suites":["Graph"],"updatePoint":{"line":64,"column":79,"index":2252},"line":64,"code":"  it('isOrphanedNode should return true or false if the node is orphaned or not', () => {\n    let graph = new Graph();\n    let rootNode = graph.addNode('root');\n    graph.setRootNodeId(rootNode);\n    let nodeA = graph.addNode('a');\n    let nodeB = graph.addNode('b');\n    let nodeC = graph.addNode('c');\n    graph.addEdge(rootNode, nodeB);\n    graph.addEdge(nodeB, nodeC, 1);\n    assert(graph.isOrphanedNode(nodeA));\n    assert(!graph.isOrphanedNode(nodeB));\n    assert(!graph.isOrphanedNode(nodeC));\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"removeEdge should prune the graph at that edge","suites":["Graph"],"updatePoint":{"line":77,"column":52,"index":2732},"line":77,"code":"  it('removeEdge should prune the graph at that edge', () => {\n    //         a\n    //        / \\\n    //       b - d\n    //      /\n    //     c\n    let graph = new Graph();\n    let nodeA = graph.addNode('a');\n    graph.setRootNodeId(nodeA);\n    let nodeB = graph.addNode('b');\n    let nodeC = graph.addNode('c');\n    let nodeD = graph.addNode('d');\n    graph.addEdge(nodeA, nodeB);\n    graph.addEdge(nodeA, nodeD);\n    graph.addEdge(nodeB, nodeC);\n    graph.addEdge(nodeB, nodeD);\n    graph.removeEdge(nodeA, nodeB);\n    assert(graph.nodes.has(nodeA));\n    assert(graph.nodes.has(nodeD));\n    assert(!graph.nodes.has(nodeB));\n    assert(!graph.nodes.has(nodeC));\n    assert.deepEqual([...graph.getAllEdges()], [{\n      from: nodeA,\n      to: nodeD,\n      type: 1\n    }]);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"removing a node recursively deletes orphaned nodes","suites":["Graph"],"updatePoint":{"line":104,"column":56,"index":3514},"line":104,"code":"  it('removing a node recursively deletes orphaned nodes', () => {\n    // before:\n    //       a\n    //      / \\\n    //     b   c\n    //    / \\    \\\n    //   d   e    f\n    //  /\n    // g\n    //\n\n    // after:\n    //      a\n    //       \\\n    //        c\n    //         \\\n    //          f\n\n    let graph = new Graph();\n    let nodeA = graph.addNode('a');\n    graph.setRootNodeId(nodeA);\n    let nodeB = graph.addNode('b');\n    let nodeC = graph.addNode('c');\n    let nodeD = graph.addNode('d');\n    let nodeE = graph.addNode('e');\n    let nodeF = graph.addNode('f');\n    let nodeG = graph.addNode('g');\n    graph.addEdge(nodeA, nodeB);\n    graph.addEdge(nodeA, nodeC);\n    graph.addEdge(nodeB, nodeD);\n    graph.addEdge(nodeB, nodeE);\n    graph.addEdge(nodeC, nodeF);\n    graph.addEdge(nodeD, nodeG);\n    graph.removeNode(nodeB);\n    assert.deepEqual([...graph.nodes.keys()], [nodeA, nodeC, nodeF]);\n    assert.deepEqual(Array.from(graph.getAllEdges()), [{\n      from: nodeA,\n      to: nodeC,\n      type: 1\n    }, {\n      from: nodeC,\n      to: nodeF,\n      type: 1\n    }]);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"removing a node recursively deletes orphaned nodes if there is no path to the root","suites":["Graph"],"updatePoint":{"line":149,"column":88,"index":4628},"line":149,"code":"  it('removing a node recursively deletes orphaned nodes if there is no path to the root', () => {\n    // before:\n    //       a\n    //      / \\\n    //     b   c\n    //    / \\    \\\n    // |-d   e    f\n    // |/\n    // g\n    //\n\n    // after:\n    //      a\n    //       \\\n    //        c\n    //         \\\n    //          f\n\n    let graph = new Graph();\n    let nodeA = graph.addNode('a');\n    let nodeB = graph.addNode('b');\n    let nodeC = graph.addNode('c');\n    let nodeD = graph.addNode('d');\n    let nodeE = graph.addNode('e');\n    let nodeF = graph.addNode('f');\n    let nodeG = graph.addNode('g');\n    graph.setRootNodeId(nodeA);\n    graph.addEdge(nodeA, nodeB);\n    graph.addEdge(nodeA, nodeC);\n    graph.addEdge(nodeB, nodeD);\n    graph.addEdge(nodeG, nodeD);\n    graph.addEdge(nodeB, nodeE);\n    graph.addEdge(nodeC, nodeF);\n    graph.addEdge(nodeD, nodeG);\n    graph.removeNode(nodeB);\n    assert.deepEqual([...graph.nodes.keys()], [nodeA, nodeC, nodeF]);\n    assert.deepEqual(Array.from(graph.getAllEdges()), [{\n      from: nodeA,\n      to: nodeC,\n      type: 1\n    }, {\n      from: nodeC,\n      to: nodeF,\n      type: 1\n    }]);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"removing an edge to a node that cycles does not remove it if there is a path to the root","suites":["Graph"],"updatePoint":{"line":195,"column":94,"index":5781},"line":195,"code":"  it('removing an edge to a node that cycles does not remove it if there is a path to the root', () => {\n    //        a\n    //        |\n    //        b <----\n    //       / \\    |\n    //      c   d   |\n    //       \\ /    |\n    //        e -----\n    let graph = new Graph();\n    let nodeA = graph.addNode('a');\n    let nodeB = graph.addNode('b');\n    let nodeC = graph.addNode('c');\n    let nodeD = graph.addNode('d');\n    let nodeE = graph.addNode('e');\n    graph.setRootNodeId(nodeA);\n    graph.addEdge(nodeA, nodeB);\n    graph.addEdge(nodeB, nodeC);\n    graph.addEdge(nodeB, nodeD);\n    graph.addEdge(nodeC, nodeE);\n    graph.addEdge(nodeD, nodeE);\n    graph.addEdge(nodeE, nodeB);\n    const getNodeIds = () => [...graph.nodes.keys()];\n    let nodesBefore = getNodeIds();\n    graph.removeEdge(nodeC, nodeE);\n    assert.deepEqual(nodesBefore, getNodeIds());\n    assert.deepEqual(Array.from(graph.getAllEdges()), [{\n      from: nodeA,\n      to: nodeB,\n      type: 1\n    }, {\n      from: nodeB,\n      to: nodeC,\n      type: 1\n    }, {\n      from: nodeB,\n      to: nodeD,\n      type: 1\n    }, {\n      from: nodeD,\n      to: nodeE,\n      type: 1\n    }, {\n      from: nodeE,\n      to: nodeB,\n      type: 1\n    }]);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"removing a node with only one inbound edge does not cause it to be removed as an orphan","suites":["Graph"],"updatePoint":{"line":242,"column":93,"index":6999},"line":242,"code":"  it('removing a node with only one inbound edge does not cause it to be removed as an orphan', () => {\n    let graph = new Graph();\n    let nodeA = graph.addNode('a');\n    let nodeB = graph.addNode('b');\n    graph.setRootNodeId(nodeA);\n    graph.addEdge(nodeA, nodeB);\n    let spy = sinon.spy(graph, 'removeNode');\n    try {\n      graph.removeNode(nodeB);\n      assert(spy.calledOnceWithExactly(nodeB));\n    } finally {\n      spy.restore();\n    }\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"replaceNodeIdsConnectedTo should update a node's downstream nodes","suites":["Graph"],"updatePoint":{"line":256,"column":71,"index":7431},"line":256,"code":"  it(\"replaceNodeIdsConnectedTo should update a node's downstream nodes\", () => {\n    let graph = new Graph();\n    let nodeA = graph.addNode('a');\n    graph.setRootNodeId(nodeA);\n    let nodeB = graph.addNode('b');\n    let nodeC = graph.addNode('c');\n    graph.addEdge(nodeA, nodeB);\n    graph.addEdge(nodeA, nodeC);\n    let nodeD = graph.addNode('d');\n    graph.replaceNodeIdsConnectedTo(nodeA, [nodeB, nodeD]);\n    assert(graph.hasNode(nodeA));\n    assert(graph.hasNode(nodeB));\n    assert(!graph.hasNode(nodeC));\n    assert(graph.hasNode(nodeD));\n    assert.deepEqual(Array.from(graph.getAllEdges()), [{\n      from: nodeA,\n      to: nodeB,\n      type: 1\n    }, {\n      from: nodeA,\n      to: nodeD,\n      type: 1\n    }]);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"traverses along edge types if a filter is given","suites":["Graph"],"updatePoint":{"line":280,"column":53,"index":8144},"line":280,"code":"  it('traverses along edge types if a filter is given', () => {\n    let graph = new Graph();\n    let nodeA = graph.addNode('a');\n    let nodeB = graph.addNode('b');\n    let nodeC = graph.addNode('c');\n    let nodeD = graph.addNode('d');\n    graph.addEdge(nodeA, nodeB, 2);\n    graph.addEdge(nodeA, nodeD);\n    graph.addEdge(nodeB, nodeC);\n    graph.addEdge(nodeB, nodeD, 2);\n    graph.setRootNodeId(nodeA);\n    let visited = [];\n    graph.traverse(nodeId => {\n      visited.push(nodeId);\n    }, null,\n    // use root as startNode\n    2);\n    assert.deepEqual(visited, [nodeA, nodeB, nodeD]);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"correctly removes non-tree subgraphs","suites":["Graph"],"updatePoint":{"line":299,"column":42,"index":8731},"line":299,"code":"  it('correctly removes non-tree subgraphs', () => {\n    let graph = new Graph();\n    let nodeRoot = graph.addNode('root');\n    let node1 = graph.addNode('1');\n    let node2 = graph.addNode('2');\n    let node3 = graph.addNode('3');\n    graph.addEdge(nodeRoot, node1);\n    graph.addEdge(node1, node2);\n    graph.addEdge(node1, node3);\n    graph.addEdge(node2, node3);\n    graph.setRootNodeId(nodeRoot);\n    graph.removeNode(node1);\n    assert.strictEqual(graph.nodes.size, 1);\n    assert.deepStrictEqual(Array.from(graph.getAllEdges()), []);\n  });","file":"Graph.test.js","skipped":false,"dir":"packages/core/graph/test"},{"name":"should respect distEntry","suites":["JS API"],"updatePoint":{"line":6,"column":30,"index":198},"line":6,"code":"  it('should respect distEntry', async function () {\n    const NAME = 'custom-name.js';\n    let b = await bundle(path.join(__dirname, '/integration/js-comment/index.js'), {\n      targets: {\n        default: {\n          distDir,\n          distEntry: NAME\n        }\n      }\n    });\n    assertBundles(b, [{\n      name: NAME,\n      type: 'js',\n      assets: ['index.js']\n    }]);\n    assert(await outputFS.exists(path.join(distDir, NAME)));\n  });","file":"api.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should run additional reports from the options","suites":["JS API"],"updatePoint":{"line":23,"column":52,"index":663},"line":23,"code":"  it('should run additional reports from the options', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/js-comment/index.js'), {\n      additionalReporters: [{\n        packageName: '@parcel/reporter-bundle-buddy',\n        resolveFrom: __dirname\n      }]\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.js']\n    }]);\n    assert(await outputFS.exists(path.join(distDir, 'bundle-buddy.json')));\n  });","file":"api.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should auto install @babel/core v7","suites":["babel"],"line":27,"code":"  it.skip('should auto install @babel/core v7', async function () {","file":"babel.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should auto install babel plugins","suites":["babel"],"line":38,"code":"  it.skip('should auto install babel plugins', async function () {","file":"babel.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling with babel using .babelrc config","suites":["babel"],"updatePoint":{"line":50,"column":63,"index":2369},"line":50,"code":"  it('should support compiling with babel using .babelrc config', async function () {\n    await bundle(path.join(__dirname, '/integration/babelrc-custom/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!file.includes('REPLACE_ME'));\n    assert(file.includes('hello there'));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling with babel using babel.config.json config without warnings","suites":["babel"],"updatePoint":{"line":56,"column":89,"index":2731},"line":56,"code":"  it('should support compiling with babel using babel.config.json config without warnings', async function () {\n    let messages = [];\n    let loggerDisposable = Logger.onLog(message => {\n      messages.push(message);\n    });\n    await bundle(path.join(__dirname, '/integration/babel-config-json-custom/index.js'), {\n      logLevel: 'verbose'\n    });\n    loggerDisposable.dispose();\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!file.includes('REPLACE_ME'));\n    assert(file.includes('hello there'));\n    assert.deepEqual(messages, []);\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling with babel using browserslist for different environments","suites":["babel"],"line":70,"code":"  it.skip('should support compiling with babel using browserslist for different environments', async function () {","file":"babel.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should compile node_modules with browserslist to app target","suites":["babel"],"line":95,"code":"  it.skip('should compile node_modules with browserslist to app target', async function () {","file":"babel.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should strip away flow types","suites":["babel"],"updatePoint":{"line":101,"column":34,"index":4959},"line":101,"code":"  it('should strip away flow types', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/babel-strip-flow-types/index.js'));\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 'hello world');\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!file.includes('OptionsType'));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling with babel using babel.config.js config","suites":["babel"],"updatePoint":{"line":109,"column":70,"index":5396},"line":109,"code":"  it('should support compiling with babel using babel.config.js config', async function () {\n    await bundle(path.join(__dirname, '/integration/babel-config-js/src/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!file.includes('REPLACE_ME'));\n    assert(file.match(/return \\d+;/));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling with babel using babel.config.js config with a require in it","suites":["babel"],"updatePoint":{"line":115,"column":91,"index":5762},"line":115,"code":"  it('should support compiling with babel using babel.config.js config with a require in it', async function () {\n    await bundle(path.join(__dirname, '/integration/babel-config-js-require/src/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!file.includes('REPLACE_ME'));\n    assert(file.match(/return \\d+;/));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support multitarget builds using a custom babel config with @parcel/babel-preset-env","suites":["babel"],"updatePoint":{"line":121,"column":97,"index":6142},"line":121,"code":"  it('should support multitarget builds using a custom babel config with @parcel/babel-preset-env', async function () {\n    let fixtureDir = path.join(__dirname, '/integration/babel-config-js-multitarget');\n    await bundle(path.join(fixtureDir, 'src/index.js'));\n    let [modern, legacy] = await Promise.all([outputFS.readFile(path.join(fixtureDir, 'dist/modern/index.js'), 'utf8'), outputFS.readFile(path.join(fixtureDir, 'dist/legacy/index.js'), 'utf8')]);\n    assert(modern.includes('class Foo'));\n    assert(modern.includes('this.x ** 2'));\n    assert(!legacy.includes('class Foo'));\n    assert(!legacy.includes('this.x ** 2'));\n    await outputFS.rimraf(path.join(fixtureDir, 'dist'));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support multitarget builds using a custom babel config with @parcel/babel-plugin-transform-runtime","suites":["babel"],"updatePoint":{"line":131,"column":111,"index":6854},"line":131,"code":"  it('should support multitarget builds using a custom babel config with @parcel/babel-plugin-transform-runtime', async function () {\n    let fixtureDir = path.join(__dirname, '/integration/babel-config-js-multitarget-transform-runtime');\n    await bundle(path.join(fixtureDir, 'src/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    let [main, esmodule] = await Promise.all([outputFS.readFile(path.join(fixtureDir, 'dist/main.js'), 'utf8'), outputFS.readFile(path.join(fixtureDir, 'dist/module.js'), 'utf8')]);\n    assert(main.includes('\"@babel/runtime/helpers/objectSpread2\"'));\n    assert(esmodule.includes('\"@babel/runtime/helpers/esm/objectSpread2\"'));\n    await outputFS.rimraf(path.join(fixtureDir, 'dist'));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support building with custom babel config when running parcel globally","suites":["babel"],"updatePoint":{"line":144,"column":83,"index":7617},"line":144,"code":"  it('should support building with custom babel config when running parcel globally', async function () {\n    let tmpDir = tempy.directory();\n    let distDir = path.join(tmpDir, 'dist');\n    await fs.ncp(path.join(__dirname, '/integration/babelrc-custom'), path.join(tmpDir, '/input'));\n    await bundle(path.join(tmpDir, '/input/index.js'), {\n      targets: {\n        modern: {\n          engines: {\n            node: '^4.0.0'\n          },\n          distDir\n        }\n      },\n      shouldAutoInstall: true\n    });\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!file.includes('REPLACE_ME'));\n    assert(file.includes('hello there'));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support merging .babelrc and babel.config.json in a monorepo","suites":["babel"],"updatePoint":{"line":163,"column":73,"index":8292},"line":163,"code":"  it('should support merging .babelrc and babel.config.json in a monorepo', async function () {\n    await bundle(path.join(__dirname, '/integration/babel-config-monorepo/packages/pkg-a/src/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!file.includes('REPLACE_ME'));\n    assert(file.includes('string from a plugin in babel.config.json'));\n    assert(!file.includes('ANOTHER_THING_TO_REPLACE'));\n    assert(file.includes('string from a plugin in .babelrc'));\n    assert(file.includes('SOMETHING ELSE'));\n    assert(!file.includes('string from a plugin from a different sub-package'));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should prefer BABEL_ENV to NODE_ENV","suites":["babel","Babel envName"],"updatePoint":{"line":174,"column":43,"index":8945},"line":174,"code":"    it('should prefer BABEL_ENV to NODE_ENV', async () => {\n      await bundle(path.join(__dirname, '/integration/babel-env-name/index.js'), {\n        targets: {\n          main: {\n            distDir,\n            engines: {\n              browsers: ['ie 11']\n            }\n          }\n        },\n        env: {\n          BABEL_ENV: 'production',\n          NODE_ENV: 'development'\n        }\n      });\n      let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(!file.includes('class Foo'));\n    });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when BABEL_ENV changes","suites":["babel","Babel envName"],"updatePoint":{"line":192,"column":48,"index":9482},"line":192,"code":"    it('should invalidate when BABEL_ENV changes', async () => {\n      await bundle(path.join(__dirname, '/integration/babel-env-name/index.js'), {\n        targets: {\n          main: {\n            distDir,\n            engines: {}\n          }\n        },\n        shouldDisableCache: false\n      });\n      let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(file.includes('class Foo'));\n      await bundle(path.join(__dirname, '/integration/babel-env-name/index.js'), {\n        shouldDisableCache: false,\n        env: {\n          BABEL_ENV: 'production'\n        }\n      });\n      file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(!file.includes('class Foo'));\n    });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when NODE_ENV changes from BABEL_ENV","suites":["babel","Babel envName"],"updatePoint":{"line":213,"column":62,"index":10233},"line":213,"code":"    it('should invalidate when NODE_ENV changes from BABEL_ENV', async () => {\n      await bundle(path.join(__dirname, '/integration/babel-env-name/index.js'), {\n        targets: {\n          main: {\n            distDir,\n            engines: {}\n          }\n        },\n        shouldDisableCache: false,\n        env: {\n          NODE_ENV: 'production'\n        }\n      });\n      let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(!file.includes('class Foo'));\n      await bundle(path.join(__dirname, '/integration/babel-env-name/index.js'), {\n        targets: {\n          main: {\n            distDir,\n            engines: {}\n          }\n        },\n        shouldDisableCache: false,\n        env: {\n          BABEL_ENV: 'development'\n        }\n      });\n      file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(file.includes('class Foo'));\n    });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should be \"production\" if Parcel is run in production mode","suites":["babel","Babel envName"],"updatePoint":{"line":243,"column":66,"index":11153},"line":243,"code":"    it('should be \"production\" if Parcel is run in production mode', async () => {\n      await bundle(path.join(__dirname, '/integration/babel-env-name/index.js'), {\n        targets: {\n          main: {\n            distDir,\n            engines: {\n              browsers: ['ie 11']\n            }\n          }\n        },\n        mode: 'production'\n      });\n      let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(!file.includes('class Foo'));\n    });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should rebuild when .babelrc changes","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":270,"column":44,"index":11890},"line":270,"code":"    it('should rebuild when .babelrc changes', async function () {\n      if (process.platform !== 'linux') {\n        // This test is flaky outside of Linux. Skip it for now.\n        return;\n      }\n      let inputDir = tempy.directory();\n      let differentPath = path.join(inputDir, 'differentConfig');\n      let configPath = path.join(inputDir, '.babelrc');\n      await fs.ncp(path.join(__dirname, 'integration/babelrc-custom'), inputDir);\n      let b = bundler(path.join(inputDir, 'index.js'), {\n        outputFS: fs,\n        shouldAutoInstall: true\n      });\n      subscription = await b.watch();\n      await getNextBuild(b);\n      let distFile = await fs.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(distFile.includes('hello there'));\n      await fs.copyFile(differentPath, configPath);\n      await new Promise(resolve => setTimeout(resolve, 100));\n      // On Windows only, `fs.utimes` arguments must be instances of `Date`,\n      // otherwise it fails. For Mac instances on Azure CI, using a Date instance\n      // does not update the utime correctly, so for all other platforms, use a\n      // number.\n      // https://github.com/nodejs/node/issues/5561\n      let now = os.platform() === 'win32' ? new Date() : Date.now();\n      // fs.copyFile does not reliably update mtime, which babel uses to invalidate cached file contents\n      await fs.utimes(configPath, now, now);\n      await getNextBuild(b);\n      distFile = await fs.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(!distFile.includes('hello there'));\n      assert(distFile.includes('something different'));\n    });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate babel.config.js across runs","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":302,"column":53,"index":13516},"line":302,"code":"    it('should invalidate babel.config.js across runs', async function () {\n      let dateRe = /return (\\d+);/;\n      let fixtureDir = path.join(__dirname, '/integration/babel-config-js');\n      let distDir = path.resolve(fixtureDir, './dist');\n      let cacheDir = path.resolve(fixtureDir, '.parcel-cache');\n      await fs.rimraf(distDir);\n      await fs.rimraf(cacheDir);\n      await fs.rimraf(path.resolve(fixtureDir, './node_modules/.cache'));\n      let build = () => spawnSync('node', [parcelCli, 'build', 'src/index.js', '--no-optimize', '--no-scope-hoist'], {\n        cwd: fixtureDir,\n        env: {\n          ...process.env,\n          PARCEL_WORKERS: '0'\n        }\n      });\n      build();\n      let file = await fs.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(!file.includes('REPLACE_ME'));\n      let firstMatch = file.match(dateRe);\n      assert(firstMatch != null);\n      let firstDatestamp = firstMatch[1];\n      build();\n      file = await fs.readFile(path.join(distDir, 'index.js'), 'utf8');\n      let secondMatch = file.match(dateRe);\n      assert(secondMatch != null);\n      let secondDatestamp = secondMatch[1];\n      assert.notEqual(firstDatestamp, secondDatestamp);\n    });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when babel plugins are upgraded across runs","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":330,"column":69,"index":14743},"line":330,"code":"    it('should invalidate when babel plugins are upgraded across runs', async function () {\n      let fixtureDir = path.join(__dirname, '/integration/babel-plugin-upgrade');\n      await fs.ncp(path.join(fixtureDir), inputDir);\n      await fs.rimraf(path.join(__dirname, '.parcel-cache'));\n      let build = () => spawnSync('node', [parcelCli, 'build', 'index.js', '--no-optimize', '--no-scope-hoist'], {\n        cwd: inputDir,\n        env: {\n          ...process.env,\n          PARCEL_WORKERS: '0'\n        }\n      });\n      build();\n      let file = await fs.readFile(path.join(inputDir, 'dist', 'index.js'), 'utf8');\n      assert(!file.includes('REPLACE_ME'));\n      assert(file.includes('hello there'));\n      await fs.writeFile(path.join(inputDir, 'node_modules/babel-plugin-dummy/message.js'), 'module.exports = \"something different\"');\n      await fs.writeFile(path.join(inputDir, 'node_modules/babel-plugin-dummy/package.json'), JSON.stringify({\n        name: 'babel-plugin-dummy',\n        version: '1.1.0'\n      }));\n      await fs.writeFile(path.join(inputDir, 'yarn.lock'), '# yarn.lock has been updated');\n      build();\n      file = await fs.readFile(path.join(inputDir, 'dist', 'index.js'), 'utf8');\n      assert(!file.includes('REPLACE_ME'));\n      assert(!file.includes('hello there'));\n      assert(file.includes('something different'));\n    });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should enable shippedProposals with @parcel/babel-preset-env in custom babelrc","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":358,"column":84,"index":16125},"line":358,"code":"  it('should enable shippedProposals with @parcel/babel-preset-env in custom babelrc', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/babel-preset-env-shippedProposals/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!file.includes('#priv'));\n    let output = await run(b);\n    assert.strictEqual(typeof output, 'object');\n    assert.strictEqual(output.default, 123);\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile with custom babel plugin plus default transforms","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":366,"column":69,"index":16568},"line":366,"code":"  it('should compile with custom babel plugin plus default transforms', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/babel-custom/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!file.includes('class Test'));\n    assert(!file.includes('REPLACE_ME'));\n    assert(!file.includes('#private'));\n    let output = await run(b);\n    assert.strictEqual(typeof output, 'object');\n    assert.strictEqual(output.default, 'hello');\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile with custom babel plugin and jsx","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":376,"column":53,"index":17065},"line":376,"code":"  it('should compile with custom babel plugin and jsx', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/babel-custom/jsx.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!file.includes('REPLACE_ME'));\n    assert(file.includes('React.createElement'));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile with custom babel plugin and typescript","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":382,"column":60,"index":17406},"line":382,"code":"  it('should compile with custom babel plugin and typescript', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/babel-custom/ts.ts'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!file.includes('class Test'));\n    assert(!file.includes('REPLACE_ME'));\n    assert(!file.includes('#private'));\n    assert(!file.includes('interface'));\n    let output = await run(b);\n    assert.strictEqual(typeof output, 'object');\n    assert.strictEqual(output.default, 'hello');\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile with custom babel plugin and tsx","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":393,"column":53,"index":17941},"line":393,"code":"  it('should compile with custom babel plugin and tsx', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/babel-custom/tsx.tsx'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!file.includes('REPLACE_ME'));\n    assert(!file.includes('interface'));\n    assert(file.includes('React.createElement'));\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should warn when a babel config contains only redundant plugins","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":400,"column":69,"index":18333},"line":400,"code":"  it('should warn when a babel config contains only redundant plugins', async function () {\n    let messages = [];\n    let loggerDisposable = Logger.onLog(message => {\n      messages.push(message);\n    });\n    let filePath = path.join(__dirname, '/integration/babel-warn-all/index.js');\n    await bundle(filePath);\n    loggerDisposable.dispose();\n    let babelrcPath = path.resolve(path.dirname(filePath), '.babelrc');\n    assert.deepEqual(messages, [{\n      type: 'log',\n      level: 'warn',\n      diagnostics: [{\n        origin: '@parcel/transformer-babel',\n        message: md`Parcel includes transpilation by default. Babel config __${path.relative(process.cwd(), babelrcPath)}__ contains only redundant presets. Deleting it may significantly improve build performance.`,\n        codeFrames: [{\n          filePath: babelrcPath,\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 2,\n              column: 15\n            },\n            end: {\n              line: 2,\n              column: 33\n            }\n          }]\n        }],\n        hints: [md`Delete __${path.relative(process.cwd(), babelrcPath)}__`],\n        documentationURL: 'https://parceljs.org/languages/javascript/#default-presets'\n      }, {\n        origin: '@parcel/transformer-babel',\n        message: \"@babel/preset-env does not support Parcel's targets, which will likely result in unnecessary transpilation and larger bundle sizes.\",\n        codeFrames: [{\n          filePath: path.resolve(path.dirname(filePath), '.babelrc'),\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 2,\n              column: 15\n            },\n            end: {\n              line: 2,\n              column: 33\n            }\n          }]\n        }],\n        hints: [\"Either remove __@babel/preset-env__ to use Parcel's builtin transpilation, or replace with __@parcel/babel-preset-env__\"],\n        documentationURL: 'https://parceljs.org/languages/javascript/#custom-plugins'\n      }]\n    }]);\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should warn when a babel config contains redundant plugins","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":453,"column":64,"index":20378},"line":453,"code":"  it('should warn when a babel config contains redundant plugins', async function () {\n    let messages = [];\n    let loggerDisposable = Logger.onLog(message => {\n      messages.push(message);\n    });\n    let filePath = path.join(__dirname, '/integration/babel-warn-some/index.js');\n    await bundle(filePath);\n    loggerDisposable.dispose();\n    let babelrcPath = path.resolve(path.dirname(filePath), '.babelrc');\n    assert.deepEqual(messages, [{\n      type: 'log',\n      level: 'warn',\n      diagnostics: [{\n        origin: '@parcel/transformer-babel',\n        message: md`Parcel includes transpilation by default. Babel config __${path.relative(process.cwd(), babelrcPath)}__ includes the following redundant presets: __@parcel/babel-preset-env__. Removing these may improve build performance.`,\n        codeFrames: [{\n          filePath: babelrcPath,\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 2,\n              column: 15\n            },\n            end: {\n              line: 2,\n              column: 40\n            }\n          }]\n        }],\n        hints: [md`Remove the above presets from __${path.relative(process.cwd(), babelrcPath)}__`],\n        documentationURL: 'https://parceljs.org/languages/javascript/#default-presets'\n      }]\n    }]);\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should warn when a JSON5 babel config contains redundant plugins","suites":["babel","tests needing the real filesystem"],"updatePoint":{"line":487,"column":70,"index":21703},"line":487,"code":"  it('should warn when a JSON5 babel config contains redundant plugins', async function () {\n    let messages = [];\n    let loggerDisposable = Logger.onLog(message => {\n      messages.push(message);\n    });\n    let filePath = path.join(__dirname, '/integration/babel-warn-some-json5/index.js');\n    await bundle(filePath);\n    loggerDisposable.dispose();\n    let babelrcPath = path.resolve(path.dirname(filePath), '.babelrc');\n    assert.deepEqual(messages, [{\n      type: 'log',\n      level: 'warn',\n      diagnostics: [{\n        origin: '@parcel/transformer-babel',\n        message: md`Parcel includes transpilation by default. Babel config __${path.relative(process.cwd(), babelrcPath)}__ includes the following redundant presets: __@parcel/babel-preset-env__. Removing these may improve build performance.`,\n        codeFrames: [{\n          filePath: babelrcPath,\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 2,\n              column: 13\n            },\n            end: {\n              line: 2,\n              column: 38\n            }\n          }]\n        }],\n        hints: [md`Remove the above presets from __${path.relative(process.cwd(), babelrcPath)}__`],\n        documentationURL: 'https://parceljs.org/languages/javascript/#default-presets'\n      }]\n    }]);\n  });","file":"babel.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline compiled content as a blob url with `blob-url:*` imports","suites":["blob urls"],"updatePoint":{"line":18,"column":76,"index":451},"line":18,"code":"  it('should inline compiled content as a blob url with `blob-url:*` imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/blob-url/index.js'));\n    class Worker {\n      constructor(src) {\n        created.push(src);\n      }\n      postMessage() {}\n    }\n    let created = [];\n    await run(b, {\n      Worker,\n      Blob,\n      URL\n    });\n    assert.equal(created.length, 1);\n    assert(created[0].startsWith('data:application/javascript,'));\n    let bundleContent = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(bundleContent.includes('new Worker(require('));\n    assert(bundleContent.includes('module.exports = URL.createObjectURL(new Blob([\"// modules are defined as an array\\\\n'));\n    assert(bundleContent.includes('self.postMessage(\\\\\"this should appear in the bundle\\\\\\\\n\\\\\")'));\n  });","file":"blob-url.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline minified content as a blob url with `blob-url:*` imports","suites":["blob urls"],"updatePoint":{"line":39,"column":76,"index":1303},"line":39,"code":"  it('should inline minified content as a blob url with `blob-url:*` imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/blob-url/index.js'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    class Worker {\n      constructor(src) {\n        created.push(src);\n      }\n      postMessage() {}\n    }\n    let created = [];\n    await run(b, {\n      Worker,\n      Blob,\n      URL\n    });\n    assert.equal(created.length, 1);\n    assert(created[0].startsWith('data:application/javascript,'));\n    let bundleContent = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(bundleContent.includes('new Worker('));\n    assert(bundleContent.includes(\".exports=URL.createObjectURL(new Blob(['!function(\"));\n    assert(bundleContent.includes('self.postMessage(\"this should appear in the bundle\\\\\\\\n\")'));\n  });","file":"blob-url.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can traverse assets across bundles and contexts","suites":["BundleGraph"],"updatePoint":{"line":7,"column":53,"index":187},"line":7,"code":"  it('can traverse assets across bundles and contexts', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/worker-shared/index.js'));\n    let assets = [];\n    b.traverse(node => {\n      if (node.type === 'asset') {\n        assets.push({\n          type: node.type,\n          value: path.basename(node.value.filePath.replace(/runtime-[0-9a-f]*/g, 'runtime'))\n        });\n      }\n    });\n    assert.deepEqual(assets, [{\n      type: 'asset',\n      value: 'index.js'\n    }, {\n      type: 'asset',\n      value: 'lodash.js'\n    }, {\n      type: 'asset',\n      value: 'worker-a.js'\n    }, {\n      type: 'asset',\n      value: 'lodash.js'\n    }, {\n      type: 'asset',\n      value: 'worker-b.js'\n    }, {\n      type: 'asset',\n      value: 'esmodule-helpers.js'\n    }, {\n      type: 'asset',\n      value: 'runtime.js'\n    }, {\n      type: 'asset',\n      value: 'get-worker-url.js'\n    }, {\n      type: 'asset',\n      value: 'bundle-url.js'\n    }, {\n      type: 'asset',\n      value: 'runtime.js'\n    }, {\n      type: 'asset',\n      value: 'get-worker-url.js'\n    }, {\n      type: 'asset',\n      value: 'bundle-url.js'\n    }, {\n      type: 'asset',\n      value: 'esmodule-helpers.js'\n    }]);\n  });","file":"BundleGraph.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove reused bundle (over shared bundles based on size) if the bundlegroup hit the parallel request limit","suites":["bundler"],"updatePoint":{"line":5,"column":119,"index":279},"line":5,"code":"  it('should remove reused bundle (over shared bundles based on size) if the bundlegroup hit the parallel request limit', async function () {\n    if (process.env.PARCEL_TEST_EXPERIMENTAL_BUNDLER) {\n      let b = await bundle(path.join(__dirname, 'integration/shared-bundle-reused-bundle-remove-reuse/index.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldScopeHoist: false\n        }\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'css-loader.js', 'esmodule-helpers.js', 'js-loader.js', 'bundle-manifest.js']\n      }, {\n        assets: ['bar.js', 'foo.js', 'a.js', 'b.js']\n      }, {\n        assets: ['buzz.js']\n      }, {\n        assets: ['c.js']\n      }, {\n        assets: ['a.js', 'b.js', 'foo.js']\n      }, {\n        assets: ['styles.css']\n      }, {\n        assets: ['local.html']\n      }]);\n    }\n  });","file":"bundler.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove shared bundle (over reused bundles based on size) if the bundlegroup hit the parallel request limit","suites":["bundler"],"updatePoint":{"line":33,"column":119,"index":1301},"line":33,"code":"  it('should remove shared bundle (over reused bundles based on size) if the bundlegroup hit the parallel request limit', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/shared-bundle-reused-bundle-remove-shared/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'css-loader.js', 'esmodule-helpers.js', 'js-loader.js', 'bundle-manifest.js']\n    }, {\n      assets: ['bar.js', 'c.js']\n    }, {\n      // A consequence of our shared bundle 'c'  being removed for the bundleGroup bar\n      // is that it must also be removed for buzz, even though the buzz bundleGroup does not\n      // hit the parallel request limit. This is because the shared bundle is no longer sharing\n      // it is only attached to one bundle and thus should be removed.\n      assets: ['buzz.js', 'c.js']\n    }, {\n      assets: ['a.js', 'b.js', 'foo.js']\n    }, {\n      assets: ['styles.css']\n    }, {\n      assets: ['local.html']\n    }]);\n  });","file":"bundler.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not remove shared bundle from graph if one bundlegroup hits the parallel request limit, and at least 2 other bundleGroups that need it do not","suites":["bundler"],"updatePoint":{"line":59,"column":154,"index":2458},"line":59,"code":"  it('should not remove shared bundle from graph if one bundlegroup hits the parallel request limit, and at least 2 other bundleGroups that need it do not', async function () {\n    //The shared bundle should only be 'put back' for the bundlegroups which hit the parallel request limit\n    // But if there are at least two other bundlegroups using this shared bundle that do not hit the max limit\n    // the shared bundle should not be removed from the graph\n    let b = await bundle(path.join(__dirname, 'integration/shared-bundle-remove-from-one-group-only/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'css-loader.js', 'esmodule-helpers.js', 'js-loader.js', 'bundle-manifest.js']\n    }, {\n      assets: ['bar.js', 'c.js'] // shared bundle merged back\n    }, {\n      assets: ['buzz.js']\n    }, {\n      assets: ['c.js'] // shared bundle\n    }, {\n      assets: ['foo.js']\n    }, {\n      assets: ['styles.css']\n    }, {\n      assets: ['local.html']\n    }]);\n  });","file":"bundler.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not remove shared bundle from graph if its parent (a reused bundle) is removed by parallel request limit","suites":["bundler"],"updatePoint":{"line":86,"column":117,"index":3565},"line":86,"code":"  it('should not remove shared bundle from graph if its parent (a reused bundle) is removed by parallel request limit', async function () {\n    //The shared bundle should only be 'put back' for the bundlegroups which hit the parallel request limit\n    // But if there are at least two other bundlegroups using this shared bundle that do not hit the max limit\n    // the shared bundle should not be removed from the graph\n    if (process.env.PARCEL_TEST_EXPERIMENTAL_BUNDLER) {\n      let b = await bundle(path.join(__dirname, 'integration/shared-bundle-between-reused-bundle-removal/index.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldScopeHoist: false\n        }\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'css-loader.js', 'esmodule-helpers.js', 'js-loader.js', 'bundle-manifest.js']\n      }, {\n        assets: ['bar.js', 'foo.js', 'a.js', 'b.js'] // shared bundle merged back\n      }, {\n        assets: ['buzz.js']\n      }, {\n        assets: ['c.js'] // shared bundle\n      }, {\n        assets: ['foo.js', 'a.js', 'b.js']\n      }, {\n        assets: ['styles.css']\n      }, {\n        assets: ['local.html']\n      }]);\n      assert(b.getReferencedBundles(b.getBundlesWithAsset(findAsset(b, 'bar.js'))[0]).includes(b.getBundlesWithAsset(findAsset(b, 'c.js'))[0]));\n    }\n  });","file":"bundler.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating a JS file","suites":["cache"],"updatePoint":{"line":65,"column":39,"index":2425},"line":65,"code":"  it('should support updating a JS file', async function () {\n    let b = await testCache(async b => {\n      assert.equal(await run(b.bundleGraph), 4);\n      await overlayFS.writeFile(path.join(inputDir, 'src/nested/test.js'), 'export default 4');\n    });\n    assert.equal(await run(b.bundleGraph), 6);\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a dependency","suites":["cache"],"updatePoint":{"line":72,"column":40,"index":2735},"line":72,"code":"  it('should support adding a dependency', async function () {\n    let b = await testCache(async b => {\n      assert.equal(await run(b.bundleGraph), 4);\n      await overlayFS.writeFile(path.join(inputDir, 'src/nested/foo.js'), 'export default 6');\n      await overlayFS.writeFile(path.join(inputDir, 'src/nested/test.js'), 'export {default} from \"./foo\";');\n    });\n    assert.equal(await run(b.bundleGraph), 8);\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a dependency which changes the referenced bundles of a parent bundle","suites":["cache"],"updatePoint":{"line":80,"column":96,"index":3210},"line":80,"code":"  it('should support adding a dependency which changes the referenced bundles of a parent bundle', async function () {\n    async function exec(bundleGraph, bundle) {\n      let calls = [];\n      await runSingleBundle(bundleGraph, nullthrows(bundle), {\n        call(v) {\n          calls.push(v);\n        }\n      });\n      return calls;\n    }\n    let b = await testCache({\n      entries: ['a.html', 'b.html'],\n      mode: 'production',\n      update: async b => {\n        let html = b.bundleGraph.getBundles().filter(b => b.type === 'html');\n        assert.deepEqual(await exec(b.bundleGraph, html[0]), ['a']);\n        assert.deepEqual(await exec(b.bundleGraph, html[1]), ['b']);\n        await overlayFS.writeFile(path.join(inputDir, 'a.js'), 'import \"./c.js\"; call(\"a\");');\n        await overlayFS.writeFile(path.join(inputDir, 'b.js'), 'import \"./c.js\"; call(\"b\");');\n      }\n    }, 'cache-add-dep-referenced');\n    let html = b.bundleGraph.getBundles().filter(b => b.type === 'html');\n    assert.deepEqual(await exec(b.bundleGraph, html[0]), ['c', 'a']);\n    assert.deepEqual(await exec(b.bundleGraph, html[1]), ['c', 'b']);\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when deleting a file","suites":["cache"],"updatePoint":{"line":105,"column":39,"index":4283},"line":105,"code":"  it('should error when deleting a file', async function () {\n    // $FlowFixMe\n    await assert.rejects(async () => {\n      await testCache(async () => {\n        await overlayFS.unlink(path.join(inputDir, 'src/nested/test.js'));\n      });\n    }, {\n      message: \"Failed to resolve './nested/test' from './src/index.js'\"\n    });\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when starting parcel from a broken state with no changes","suites":["cache"],"updatePoint":{"line":115,"column":75,"index":4655},"line":115,"code":"  it('should error when starting parcel from a broken state with no changes', async function () {\n    // $FlowFixMe\n    await assert.rejects(async () => {\n      await testCache(async () => {\n        await overlayFS.unlink(path.join(inputDir, 'src/nested/test.js'));\n      });\n    });\n\n    // Do a third build from a failed state with no changes\n    // $FlowFixMe\n    await assert.rejects(async () => {\n      await runBundle();\n    }, {\n      message: \"Failed to resolve './nested/test' from './src/index.js'\"\n    });\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a ","suites":["cache","babel"],"updatePoint":{"line":182,"column":43,"index":6676},"line":182,"code":"        it(`should support adding a ${name}`, async function () {\n          let b = await testCache({\n            // Babel's config loader only works with the node filesystem\n            inputFS,\n            outputFS: inputFS,\n            async setup() {\n              await inputFS.mkdirp(inputDir);\n              await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n            },\n            async update(b) {\n              assert.equal(await run(b.bundleGraph), 4);\n              let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n              assert(contents.includes('class Test'), 'class should not be transpiled');\n              await inputFS.writeFile(path.join(inputDir, name), formatter({\n                presets: ['@babel/preset-env']\n              }));\n              await sleep(100);\n            }\n          });\n          assert.equal(await run(b.bundleGraph), 4);\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('class Test'), 'class should be transpiled');\n        });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating a ","suites":["cache","babel"],"updatePoint":{"line":205,"column":45,"index":7809},"line":205,"code":"        it(`should support updating a ${name}`, async function () {\n          let b = await testCache({\n            // Babel's config loader only works with the node filesystem\n            inputFS,\n            outputFS: inputFS,\n            async setup() {\n              await inputFS.mkdirp(inputDir);\n              await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n              await inputFS.writeFile(path.join(inputDir, name), formatter({\n                presets: [['@babel/preset-env', {\n                  targets: {\n                    esmodules: true\n                  }\n                }]]\n              }));\n            },\n            async update(b) {\n              let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n              assert(contents.includes('class Test'), 'class should not be transpiled');\n              await inputFS.writeFile(path.join(inputDir, name), formatter({\n                presets: ['@babel/preset-env']\n              }));\n              await sleep(100);\n            }\n          });\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('class Test'), 'class should be transpiled');\n        });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deleting a ","suites":["cache","babel"],"updatePoint":{"line":233,"column":45,"index":9083},"line":233,"code":"        it(`should support deleting a ${name}`, async function () {\n          let b = await testCache({\n            // Babel's config loader only works with the node filesystem\n            inputFS,\n            outputFS: inputFS,\n            async setup() {\n              await inputFS.mkdirp(inputDir);\n              await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n              await inputFS.writeFile(path.join(inputDir, name), formatter({\n                presets: ['@babel/preset-env']\n              }));\n            },\n            async update(b) {\n              let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n              assert(!contents.includes('class Test'), 'class should be transpiled');\n              await inputFS.unlink(path.join(inputDir, name));\n              await sleep(100);\n            }\n          });\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('class Test'), 'class should not be transpiled');\n        });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating an extended ","suites":["cache","babel"],"updatePoint":{"line":255,"column":55,"index":10179},"line":255,"code":"        it(`should support updating an extended ${name}`, async function () {\n          let extendedName = '.babelrc-extended' + path.extname(name);\n          let b = await testCache({\n            // Babel's config loader only works with the node filesystem\n            inputFS,\n            outputFS: inputFS,\n            async setup() {\n              await inputFS.mkdirp(inputDir);\n              await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n              await inputFS.writeFile(path.join(inputDir, extendedName), formatter({\n                presets: [['@babel/preset-env', {\n                  targets: {\n                    esmodules: true\n                  }\n                }]]\n              }));\n              await inputFS.writeFile(path.join(inputDir, name), formatter({\n                extends: `./${extendedName}`\n              }));\n            },\n            async update(b) {\n              let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n              assert(contents.includes('class Test'), 'class should not be transpiled');\n              await inputFS.writeFile(path.join(inputDir, extendedName), formatter({\n                presets: ['@babel/preset-env']\n              }));\n              await sleep(100);\n            }\n          });\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('class Test'), 'class should be transpiled');\n        });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a nested ","suites":["cache","babel"],"updatePoint":{"line":288,"column":52,"index":11711},"line":288,"code":"          it(`should support adding a nested ${name}`, async function () {\n            let b = await testCache({\n              // Babel's config loader only works with the node filesystem\n              inputFS,\n              outputFS: inputFS,\n              async setup() {\n                await inputFS.mkdirp(inputDir);\n                await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n              },\n              async update(b) {\n                assert.equal(await run(b.bundleGraph), 4);\n                let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n                assert(contents.includes('class Test'), 'class should not be transpiled');\n                assert(contents.includes('class Result'), 'class should not be transpiled');\n                await inputFS.writeFile(path.join(inputDir, `src/nested/${name}`), formatter({\n                  presets: ['@babel/preset-env']\n                }));\n                await sleep(100);\n              }\n            });\n            assert.equal(await run(b.bundleGraph), 4);\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(!contents.includes('class Test'), 'class should be transpiled');\n            assert(contents.includes('class Result'), 'class should not be transpiled');\n          });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating a nested ","suites":["cache","babel"],"updatePoint":{"line":313,"column":54,"index":13095},"line":313,"code":"          it(`should support updating a nested ${name}`, async function () {\n            let b = await testCache({\n              // Babel's config loader only works with the node filesystem\n              inputFS,\n              outputFS: inputFS,\n              async setup() {\n                await inputFS.mkdirp(inputDir);\n                await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n                await inputFS.writeFile(path.join(inputDir, `src/nested/${name}`), formatter({\n                  presets: [['@babel/preset-env', {\n                    targets: {\n                      esmodules: true\n                    }\n                  }]]\n                }));\n              },\n              async update(b) {\n                let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n                assert(contents.includes('class Test'), 'class should not be transpiled');\n                assert(contents.includes('class Result'), 'class should not be transpiled');\n                await inputFS.writeFile(path.join(inputDir, `src/nested/${name}`), formatter({\n                  presets: ['@babel/preset-env']\n                }));\n                await sleep(100);\n              }\n            });\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(!contents.includes('class Test'), 'class should be transpiled');\n            assert(contents.includes('class Result'), 'class should not be transpiled');\n          });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deleting a nested ","suites":["cache","babel"],"updatePoint":{"line":343,"column":54,"index":14646},"line":343,"code":"          it(`should support deleting a nested ${name}`, async function () {\n            let b = await testCache({\n              // Babel's config loader only works with the node filesystem\n              inputFS,\n              outputFS: inputFS,\n              async setup() {\n                await inputFS.mkdirp(inputDir);\n                await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n                await inputFS.writeFile(path.join(inputDir, `src/nested/${name}`), formatter({\n                  presets: ['@babel/preset-env']\n                }));\n              },\n              async update(b) {\n                let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n                assert(!contents.includes('class Test'), 'class should be transpiled');\n                assert(contents.includes('class Result'), 'class should not be transpiled');\n                await inputFS.unlink(path.join(inputDir, `src/nested/${name}`));\n                await sleep(100);\n              }\n            });\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(contents.includes('class Test'), 'class should not be transpiled');\n            assert(contents.includes('class Result'), 'class should not be transpiled');\n          });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a .babelignore","suites":["cache","babel",".babelignore"],"updatePoint":{"line":371,"column":46,"index":16058},"line":371,"code":"      it('should support adding a .babelignore', async function () {\n        let b = await testCache({\n          // Babel's config loader only works with the node filesystem\n          inputFS,\n          outputFS: inputFS,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n            await inputFS.writeFile(path.join(inputDir, '.babelrc'), JSON.stringify({\n              presets: ['@babel/preset-env']\n            }));\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(!contents.includes('class Test'), 'class should be transpiled');\n            assert(!contents.includes('class Result'), 'class should be transpiled');\n            await inputFS.writeFile(path.join(inputDir, '.babelignore'), 'src/nested');\n            await sleep(100);\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(contents.includes('class Test'), 'class should not be transpiled');\n        assert(!contents.includes('class Result'), 'class should be transpiled');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating a .babelignore","suites":["cache","babel",".babelignore"],"updatePoint":{"line":395,"column":48,"index":17311},"line":395,"code":"      it('should support updating a .babelignore', async function () {\n        let b = await testCache({\n          // Babel's config loader only works with the node filesystem\n          inputFS,\n          outputFS: inputFS,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n            await inputFS.writeFile(path.join(inputDir, '.babelrc'), JSON.stringify({\n              presets: ['@babel/preset-env']\n            }));\n            await inputFS.writeFile(path.join(inputDir, '.babelignore'), 'src/nested');\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(contents.includes('class Test'), 'class should not be transpiled');\n            assert(!contents.includes('class Result'), 'class should be transpiled');\n            await inputFS.writeFile(path.join(inputDir, '.babelignore'), 'src');\n            await sleep(100);\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(contents.includes('class Test'), 'class should not be transpiled');\n        assert(contents.includes('class Result'), 'class should not be transpiled');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deleting a .babelignore","suites":["cache","babel",".babelignore"],"updatePoint":{"line":420,"column":48,"index":18651},"line":420,"code":"      it('should support deleting a .babelignore', async function () {\n        let b = await testCache({\n          // Babel's config loader only works with the node filesystem\n          inputFS,\n          outputFS: inputFS,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n            await inputFS.writeFile(path.join(inputDir, '.babelrc'), JSON.stringify({\n              presets: ['@babel/preset-env']\n            }));\n            await inputFS.writeFile(path.join(inputDir, '.babelignore'), 'src/nested');\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(contents.includes('class Test'), 'class should not be transpiled');\n            assert(!contents.includes('class Result'), 'class should be transpiled');\n            await inputFS.unlink(path.join(inputDir, '.babelignore'));\n            await sleep(100);\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(!contents.includes('class Test'), 'class should be transpiled');\n        assert(!contents.includes('class Result'), 'class should be transpiled');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when plugins are updated","suites":["cache","babel","plugins"],"updatePoint":{"line":447,"column":52,"index":20025},"line":447,"code":"      it('should invalidate when plugins are updated', async function () {\n        let b = await testCache({\n          // Babel's config loader only works with the node filesystem\n          inputFS,\n          outputFS: inputFS,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n            await inputFS.mkdirp(path.join(inputDir, 'node_modules/babel-plugin-dummy'));\n            await inputFS.writeFile(path.join(inputDir, '/node_modules/babel-plugin-dummy/package.json'), JSON.stringify({\n              name: 'babel-plugin-dummy',\n              version: '1.0.0'\n            }));\n            await inputFS.copyFile(path.join(__dirname, '/integration/babelrc-custom/babel-plugin-dummy.js'), path.join(inputDir, '/node_modules/babel-plugin-dummy/index.js'));\n            await inputFS.writeFile(path.join(inputDir, '.babelrc'), JSON.stringify({\n              plugins: ['babel-plugin-dummy']\n            }));\n            await inputFS.writeFile(path.join(inputDir, 'src/index.js'), 'console.log(\"REPLACE_ME\")');\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(contents.includes('hello there'), 'string should be replaced');\n            let plugin = path.join(inputDir, 'node_modules/babel-plugin-dummy/index.js');\n            let source = await inputFS.readFile(plugin, 'utf8');\n            await inputFS.writeFile(plugin, source.replace('hello there', 'replaced'));\n            await sleep(100);\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(contents.includes('replaced'), 'string should be replaced');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when there are relative plugins","suites":["cache","babel","plugins"],"updatePoint":{"line":478,"column":59,"index":21852},"line":478,"code":"      it('should invalidate when there are relative plugins', async function () {\n        let b = await testCache({\n          // Babel's config loader only works with the node filesystem\n          inputFS,\n          outputFS: inputFS,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n            await inputFS.copyFile(path.join(__dirname, '/integration/babelrc-custom/babel-plugin-dummy.js'), path.join(inputDir, 'babel-plugin-dummy.js'));\n            await inputFS.writeFile(path.join(inputDir, '.babelrc'), JSON.stringify({\n              plugins: ['./babel-plugin-dummy']\n            }));\n            await inputFS.writeFile(path.join(inputDir, 'src/index.js'), 'console.log(\"REPLACE_ME\")');\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(contents.includes('hello there'), 'string should be replaced');\n            let plugin = path.join(inputDir, 'babel-plugin-dummy.js');\n            let source = await inputFS.readFile(plugin, 'utf8');\n            await inputFS.writeFile(plugin, source.replace('hello there', 'replaced'));\n            await sleep(100);\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(contents.includes('replaced'), 'string should be replaced');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when there are symlinked plugins","suites":["cache","babel","plugins"],"updatePoint":{"line":504,"column":60,"index":23340},"line":504,"code":"      it('should invalidate when there are symlinked plugins', async function () {\n        // Symlinks don't work consistently on windows. Skip this test.\n        if (process.platform === 'win32') {\n          this.skip();\n          return;\n        }\n        let b = await testCache({\n          // Babel's config loader only works with the node filesystem\n          inputFS,\n          outputFS: inputFS,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n            await inputFS.mkdirp(path.join(inputDir, 'packages/babel-plugin-dummy'));\n            await inputFS.mkdirp(path.join(inputDir, 'node_modules'));\n            fs.symlinkSync(path.join(inputDir, 'packages/babel-plugin-dummy'), path.join(inputDir, 'node_modules/babel-plugin-dummy'));\n            await inputFS.writeFile(path.join(inputDir, 'packages/babel-plugin-dummy/package.json'), JSON.stringify({\n              name: 'babel-plugin-dummy',\n              version: '1.0.0'\n            }));\n            await inputFS.copyFile(path.join(__dirname, '/integration/babelrc-custom/babel-plugin-dummy.js'), path.join(inputDir, 'packages/babel-plugin-dummy/index.js'));\n            await inputFS.writeFile(path.join(inputDir, '.babelrc'), JSON.stringify({\n              plugins: ['babel-plugin-dummy']\n            }));\n            await inputFS.writeFile(path.join(inputDir, 'src/index.js'), 'console.log(\"REPLACE_ME\")');\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(contents.includes('hello there'), 'string should be replaced');\n            let plugin = path.join(inputDir, 'packages/babel-plugin-dummy/index.js');\n            let source = await inputFS.readFile(plugin, 'utf8');\n            await inputFS.writeFile(plugin, source.replace('hello there', 'replaced'));\n            await sleep(100);\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(contents.includes('replaced'), 'string should be replaced');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a .parcelrc","suites":["cache","parcel config"],"updatePoint":{"line":545,"column":41,"index":25561},"line":545,"code":"    it('should support adding a .parcelrc', async function () {\n      let b = await testCache(async b => {\n        assert.equal(await run(b.bundleGraph), 4);\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(!contents.includes('TRANSFORMED CODE'));\n        await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n          extends: '@parcel/config-default',\n          transformers: {\n            '*.js': ['parcel-transformer-mock']\n          }\n        }));\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('TRANSFORMED CODE'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating a .parcelrc","suites":["cache","parcel config"],"updatePoint":{"line":560,"column":43,"index":26269},"line":560,"code":"    it('should support updating a .parcelrc', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('TRANSFORMED CODE'));\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default'\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('TRANSFORMED CODE'));\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating an extended .parcelrc","suites":["cache","parcel config"],"updatePoint":{"line":582,"column":53,"index":27209},"line":582,"code":"    it('should support updating an extended .parcelrc', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc-extended'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: './.parcelrc-extended'\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('TRANSFORMED CODE'));\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc-extended'), JSON.stringify({\n            extends: '@parcel/config-default'\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('TRANSFORMED CODE'));\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when deleting an extended parcelrc","suites":["cache","parcel config"],"updatePoint":{"line":607,"column":55,"index":28315},"line":607,"code":"    it('should error when deleting an extended parcelrc', async function () {\n      // $FlowFixMe\n      await assert.rejects(async () => {\n        await testCache({\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, '.parcelrc-extended'), JSON.stringify({\n              extends: '@parcel/config-default',\n              transformers: {\n                '*.js': ['parcel-transformer-mock']\n              }\n            }));\n            await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n              extends: './.parcelrc-extended'\n            }));\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(contents.includes('TRANSFORMED CODE'));\n            await overlayFS.unlink(path.join(inputDir, '.parcelrc-extended'));\n          }\n        });\n      }, {\n        message: 'Cannot find extended parcel config'\n      });\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deleting a .parcelrc","suites":["cache","parcel config"],"updatePoint":{"line":632,"column":43,"index":29295},"line":632,"code":"    it('should support deleting a .parcelrc', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('TRANSFORMED CODE'));\n          await overlayFS.unlink(path.join(inputDir, '.parcelrc'));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('TRANSFORMED CODE'));\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when included files changes","suites":["cache","transformations"],"updatePoint":{"line":654,"column":53,"index":30205},"line":654,"code":"    it('should invalidate when included files changes', async function () {\n      let b = await testCache({\n        // TODO: update when the fs transform supports the MemoryFS\n        inputFS,\n        outputFS: inputFS,\n        async setup() {\n          await inputFS.mkdirp(inputDir);\n          await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n          await inputFS.writeFile(path.join(inputDir, 'src/test.txt'), 'hi');\n          await inputFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"fs\").readFileSync(__dirname + \"/test.txt\", \"utf8\")');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 'hi');\n          await inputFS.writeFile(path.join(inputDir, 'src/test.txt'), 'updated');\n          await sleep(100);\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not invalidate when a set environment variable does not change","suites":["cache","transformations"],"updatePoint":{"line":673,"column":77,"index":31117},"line":673,"code":"    it('should not invalidate when a set environment variable does not change', async () => {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.env'), 'TEST=hi');\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = process.env.TEST');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 'hi');\n          await overlayFS.writeFile(path.join(inputDir, '.env'), 'TEST=hi');\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 'hi');\n      assert.equal(b.changedAssets.size, 0);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not invalidate when an environment variable remains unset","suites":["cache","transformations"],"updatePoint":{"line":687,"column":72,"index":31745},"line":687,"code":"    it('should not invalidate when an environment variable remains unset', async () => {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = process.env.TEST');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), undefined);\n        }\n      });\n      assert.equal(await run(b.bundleGraph), undefined);\n      assert.equal(b.changedAssets.size, 0);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when an environment variable becomes set","suites":["cache","transformations"],"updatePoint":{"line":699,"column":66,"index":32223},"line":699,"code":"    it('should invalidate when an environment variable becomes set', async () => {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = process.env.TEST');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), undefined);\n          await overlayFS.writeFile(path.join(inputDir, '.env'), 'TEST=hi');\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 'hi');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when an environment variable becomes unset","suites":["cache","transformations"],"updatePoint":{"line":711,"column":68,"index":32730},"line":711,"code":"    it('should invalidate when an environment variable becomes unset', async () => {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = process.env.TEST');\n          await overlayFS.writeFile(path.join(inputDir, '.env'), 'TEST=hi');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 'hi');\n          await overlayFS.writeFile(path.join(inputDir, '.env'), '');\n        }\n      });\n      assert.equal(await run(b.bundleGraph), undefined);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when environment variables change","suites":["cache","transformations"],"updatePoint":{"line":724,"column":59,"index":33298},"line":724,"code":"    it('should invalidate when environment variables change', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.env'), 'TEST=hi');\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = process.env.TEST');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 'hi');\n          await overlayFS.writeFile(path.join(inputDir, '.env'), 'TEST=updated');\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding an entry that matches a glob","suites":["cache","entries"],"updatePoint":{"line":739,"column":58,"index":33925},"line":739,"code":"    it('should support adding an entry that matches a glob', async function () {\n      let b = await testCache({\n        entries: ['src/entries/*.js'],\n        async update(b) {\n          assertBundles(b.bundleGraph, [{\n            name: 'a.js',\n            assets: ['a.js', 'esmodule-helpers.js']\n          }, {\n            name: 'b.js',\n            assets: ['b.js', 'esmodule-helpers.js']\n          }]);\n          await overlayFS.writeFile(path.join(inputDir, 'src/entries/c.js'), 'export let c = \"c\";');\n        }\n      });\n      assertBundles(b.bundleGraph, [{\n        name: 'a.js',\n        assets: ['a.js', 'esmodule-helpers.js']\n      }, {\n        name: 'b.js',\n        assets: ['b.js', 'esmodule-helpers.js']\n      }, {\n        name: 'c.js',\n        assets: ['c.js', 'esmodule-helpers.js']\n      }]);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deleting an entry that matches a glob","suites":["cache","entries"],"updatePoint":{"line":764,"column":60,"index":34743},"line":764,"code":"    it('should support deleting an entry that matches a glob', async function () {\n      let b = await testCache({\n        entries: ['src/entries/*.js'],\n        async update(b) {\n          assertBundles(b.bundleGraph, [{\n            name: 'a.js',\n            assets: ['a.js', 'esmodule-helpers.js']\n          }, {\n            name: 'b.js',\n            assets: ['b.js', 'esmodule-helpers.js']\n          }]);\n          await overlayFS.unlink(path.join(inputDir, 'src/entries/b.js'));\n        }\n      });\n      assertBundles(b.bundleGraph, [{\n        name: 'a.js',\n        assets: ['a.js', 'esmodule-helpers.js']\n      }]);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when deleting a file entry","suites":["cache","entries"],"updatePoint":{"line":783,"column":47,"index":35360},"line":783,"code":"    it('should error when deleting a file entry', async function () {\n      // $FlowFixMe\n      await assert.rejects(async () => {\n        await testCache(async () => {\n          await overlayFS.unlink(path.join(inputDir, 'src/index.js'));\n        });\n      }, {\n        message: md`Entry ${path.join(inputDir, 'src/index.js')} does not exist`\n      });\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should recover from errors when adding a missing entry","suites":["cache","entries"],"updatePoint":{"line":793,"column":62,"index":35737},"line":793,"code":"    it('should recover from errors when adding a missing entry', async function () {\n      // $FlowFixMe\n      await assert.rejects(async () => {\n        await testCache(async () => {\n          await overlayFS.unlink(path.join(inputDir, 'src/index.js'));\n        });\n      }, {\n        message: md`Entry ${path.join(inputDir, 'src/index.js')} does not exist`\n      });\n      await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = \"hi\"');\n      let b = await runBundle();\n      assert.equal(await run(b.bundleGraph), 'hi');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a target config","suites":["cache","target config"],"updatePoint":{"line":808,"column":45,"index":36325},"line":808,"code":"    it('should support adding a target config', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('export '), 'should not include export');\n          let pkgFile = path.join(inputDir, 'package.json');\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              esmodule: {\n                outputFormat: 'esmodule',\n                isLibrary: true\n              }\n            }\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('export '), 'should include export');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a second target","suites":["cache","target config"],"updatePoint":{"line":832,"column":45,"index":37274},"line":832,"code":"    it('should support adding a second target', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                engines: {\n                  browsers: 'last 1 Chrome version'\n                }\n              }\n            }\n          }));\n        },\n        async update(b) {\n          assertBundles(b.bundleGraph, [{\n            name: 'index.js',\n            assets: ['index.js', 'test.js', 'foo.js']\n          }]);\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                engines: {\n                  browsers: 'last 1 Chrome version'\n                }\n              },\n              legacy: {\n                engines: {\n                  browsers: 'IE 11'\n                }\n              }\n            }\n          }));\n        }\n      });\n      assertBundles(b.bundleGraph, [{\n        name: 'index.js',\n        assets: ['index.js', 'test.js', 'foo.js']\n      }, {\n        name: 'index.js',\n        assets: ['index.js', 'test.js', 'foo.js']\n      }]);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support changing target output location","suites":["cache","target config"],"updatePoint":{"line":882,"column":54,"index":38756},"line":882,"code":"    it('should support changing target output location', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            modern: 'modern/index.js',\n            legacy: 'legacy/index.js',\n            targets: {\n              modern: {\n                engines: {\n                  browsers: 'last 1 Chrome version'\n                }\n              },\n              legacy: {\n                engines: {\n                  browsers: 'IE 11'\n                }\n              }\n            }\n          }));\n        },\n        async update() {\n          assert(await overlayFS.exists(path.join(inputDir, 'modern/index.js')));\n          assert(await overlayFS.exists(path.join(inputDir, 'legacy/index.js')));\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            modern: 'dist/modern/index.js',\n            legacy: 'dist/legacy/index.js',\n            targets: {\n              modern: {\n                engines: {\n                  browsers: 'last 1 Chrome version'\n                }\n              },\n              legacy: {\n                engines: {\n                  browsers: 'IE 11'\n                }\n              }\n            }\n          }));\n        }\n      });\n      assert(await overlayFS.exists(path.join(inputDir, 'dist/modern/index.js')));\n      assert(await overlayFS.exists(path.join(inputDir, 'dist/legacy/index.js')));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating target config options","suites":["cache","target config"],"updatePoint":{"line":934,"column":53,"index":40493},"line":934,"code":"    it('should support updating target config options', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              esmodule: {\n                outputFormat: 'esmodule',\n                isLibrary: true\n              }\n            }\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('export '), 'should include export');\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              esmodule: {\n                outputFormat: 'commonjs'\n              }\n            }\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('module.exports ='), 'should include module.exports =');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deleting a target","suites":["cache","target config"],"updatePoint":{"line":969,"column":40,"index":41766},"line":969,"code":"    it('should support deleting a target', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                engines: {\n                  browsers: 'last 1 Chrome version'\n                }\n              },\n              legacy: {\n                engines: {\n                  browsers: 'IE 11'\n                }\n              }\n            }\n          }));\n        },\n        async update(b) {\n          assertBundles(b.bundleGraph, [{\n            name: 'index.js',\n            assets: ['index.js', 'test.js', 'foo.js']\n          }, {\n            name: 'index.js',\n            assets: ['index.js', 'test.js', 'foo.js']\n          }]);\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                engines: {\n                  browsers: 'last 1 Chrome version'\n                }\n              }\n            }\n          }));\n        }\n      });\n      assertBundles(b.bundleGraph, [{\n        name: 'index.js',\n        assets: ['index.js', 'test.js', 'foo.js']\n      }]);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deleting all targets","suites":["cache","target config"],"updatePoint":{"line":1019,"column":43,"index":43249},"line":1019,"code":"    it('should support deleting all targets', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                outputFormat: 'esmodule',\n                isLibrary: true\n              },\n              legacy: {\n                outputFormat: 'commonjs'\n              }\n            }\n          }));\n        },\n        async update(b) {\n          assertBundles(b.bundleGraph, [{\n            name: 'index.js',\n            assets: ['index.js', 'test.js', 'foo.js']\n          }, {\n            name: 'index.js',\n            assets: ['index.js', 'test.js', 'foo.js']\n          }]);\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('export '), 'should include export');\n          contents = await overlayFS.readFile(b.bundleGraph.getBundles()[1].filePath, 'utf8');\n          assert(contents.includes('module.exports ='), 'should include module.exports');\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: undefined\n          }));\n        }\n      });\n      assertBundles(b.bundleGraph, [{\n        name: 'index.js',\n        assets: ['index.js', 'test.js', 'foo.js']\n      }]);\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('export '), 'should not include export');\n      assert(!contents.includes('module.exports ='), 'should not include module.exports');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when sourcemap options change","suites":["cache","target config"],"updatePoint":{"line":1067,"column":51,"index":45151},"line":1067,"code":"    it('should update when sourcemap options change', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                sourceMap: true\n              }\n            }\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('sourceMappingURL=index.js.map'), 'should include sourceMappingURL');\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                sourceMap: {\n                  inline: true\n                }\n              }\n            }\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('sourceMappingURL=data:application/json'), 'should include inline sourceMappingURL');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when publicUrl changes","suites":["cache","target config"],"updatePoint":{"line":1103,"column":44,"index":46480},"line":1103,"code":"    it('should update when publicUrl changes', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      let b = await testCache({\n        entries: ['src/index.html'],\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                publicUrl: 'http://example.com/'\n              }\n            }\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('<script type=\"module\" src=\"http://example.com'), 'should include example.com');\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                publicUrl: 'http://mygreatwebsite.com/'\n              }\n            }\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('<script type=\"module\" src=\"http://mygreatwebsite.com'), 'should include example.com');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when a package.json is created","suites":["cache","target config"],"updatePoint":{"line":1138,"column":52,"index":47862},"line":1138,"code":"    it('should update when a package.json is created', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      let pkg;\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.unlink(pkgFile);\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('export '), 'does not include export');\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                outputFormat: 'esmodule',\n                isLibrary: true\n              }\n            }\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('export '), 'should include export');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when a package.json is deleted","suites":["cache","target config"],"updatePoint":{"line":1166,"column":52,"index":48899},"line":1166,"code":"    it('should update when a package.json is deleted', async function () {\n      let pkgFile = path.join(inputDir, 'package.json');\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        async setup() {\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                outputFormat: 'esmodule',\n                isLibrary: true\n              }\n            }\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('export '), 'should include export');\n          await overlayFS.unlink(pkgFile);\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('export '), 'does not include export');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when a browserslist file is added","suites":["cache","target config","browserslist"],"updatePoint":{"line":1194,"column":57,"index":49973},"line":1194,"code":"      it('should update when a browserslist file is added', async function () {\n        let b = await testCache({\n          defaultTargetOptions: {\n            shouldScopeHoist: true\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should include class');\n            await overlayFS.writeFile(path.join(inputDir, 'browserslist'), 'IE >= 11');\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(!/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'does not include class');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when a .browserslistrc file is added","suites":["cache","target config","browserslist"],"updatePoint":{"line":1208,"column":60,"index":50701},"line":1208,"code":"      it('should update when a .browserslistrc file is added', async function () {\n        let b = await testCache({\n          defaultTargetOptions: {\n            shouldScopeHoist: true\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should include class');\n            await overlayFS.writeFile(path.join(inputDir, '.browserslistrc'), 'IE >= 11');\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(!/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'does not include class');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when a browserslist is updated","suites":["cache","target config","browserslist"],"updatePoint":{"line":1222,"column":54,"index":51426},"line":1222,"code":"      it('should update when a browserslist is updated', async function () {\n        let b = await testCache({\n          defaultTargetOptions: {\n            shouldScopeHoist: true\n          },\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, 'browserslist'), 'IE >= 11');\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(!/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'does not include class');\n            await overlayFS.writeFile(path.join(inputDir, 'browserslist'), 'last 1 Chrome version');\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should include class');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when a browserslist is deleted","suites":["cache","target config","browserslist"],"updatePoint":{"line":1239,"column":54,"index":52288},"line":1239,"code":"      it('should update when a browserslist is deleted', async function () {\n        let b = await testCache({\n          defaultTargetOptions: {\n            shouldScopeHoist: true\n          },\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, 'browserslist'), 'IE >= 11');\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(!/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'does not include class');\n            await overlayFS.unlink(path.join(inputDir, 'browserslist'));\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should include class');\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when BROWSERSLIST_ENV changes","suites":["cache","target config","browserslist"],"updatePoint":{"line":1256,"column":53,"index":53121},"line":1256,"code":"      it('should update when BROWSERSLIST_ENV changes', async function () {\n        let b = await testCache({\n          defaultTargetOptions: {\n            shouldScopeHoist: true\n          },\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, 'browserslist'), `\n            [production]\n            IE >= 11\n\n            [development]\n            last 1 Chrome version\n            `);\n            process.env.BROWSERSLIST_ENV = 'production';\n          },\n          async update(b) {\n            // \"production\" is the default environment for browserslist\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(!/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'does not include class');\n            process.env.BROWSERSLIST_ENV = 'development';\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should include class');\n        delete process.env.BROWSERSLIST_ENV;\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when NODE_ENV changes","suites":["cache","target config","browserslist"],"updatePoint":{"line":1282,"column":45,"index":54217},"line":1282,"code":"      it('should update when NODE_ENV changes', async function () {\n        let env = process.env.NODE_ENV;\n        let b = await testCache({\n          defaultTargetOptions: {\n            shouldScopeHoist: true\n          },\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, 'browserslist'), `\n            [production]\n            IE >= 11\n\n            [development]\n            last 1 Chrome version\n            `);\n            process.env.NODE_ENV = 'production';\n          },\n          async update(b) {\n            // \"production\" is the default environment for browserslist\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(!/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'does not include class');\n            process.env.NODE_ENV = 'development';\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should include class');\n        process.env.NODE_ENV = env;\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when publicUrl changes","suites":["cache","options"],"updatePoint":{"line":1312,"column":44,"index":55377},"line":1312,"code":"    it('should update when publicUrl changes', async function () {\n      let b = await testCache({\n        entries: ['src/index.html'],\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          publicUrl: 'http://example.com/'\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('<script type=\"module\" src=\"http://example.com'), 'should include example.com');\n          return {\n            defaultTargetOptions: {\n              publicUrl: 'http://mygreatwebsite.com/'\n            }\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('<script type=\"module\" src=\"http://mygreatwebsite.com'), 'should include example.com');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when minify changes","suites":["cache","options"],"updatePoint":{"line":1332,"column":41,"index":56249},"line":1332,"code":"    it('should update when minify changes', async function () {\n      let b = await testCache({\n        entries: ['src/index.html'],\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          shouldOptimize: false\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[1].filePath, 'utf8');\n          assert(contents.includes('Test'), 'should include Test');\n          return {\n            defaultTargetOptions: {\n              shouldScopeHoist: true,\n              shouldOptimize: true\n            }\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[1].filePath, 'utf8');\n      assert(!contents.includes('Test'), 'should not include Test');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when scopeHoist changes","suites":["cache","options"],"updatePoint":{"line":1353,"column":45,"index":57035},"line":1353,"code":"    it('should update when scopeHoist changes', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: false\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('parcelRequire'), 'should include parcelRequire');\n          return {\n            defaultTargetOptions: {\n              shouldScopeHoist: true\n            }\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('parcelRequire'), 'should not include Test');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when sourceMaps changes","suites":["cache","options"],"updatePoint":{"line":1371,"column":45,"index":57743},"line":1371,"code":"    it('should update when sourceMaps changes', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          sourceMaps: false\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('sourceMappingURL=index.js.map'), 'should not include sourceMappingURL');\n          return {\n            defaultTargetOptions: {\n              sourceMaps: true\n            }\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('sourceMappingURL=index.js.map'), 'should include sourceMappingURL');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when distDir changes","suites":["cache","options"],"updatePoint":{"line":1389,"column":42,"index":58483},"line":1389,"code":"    it('should update when distDir changes', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        update(b) {\n          assert(/dist[/\\\\]index.js$/.test(b.bundleGraph.getBundles()[0].filePath), 'should end with dist/index.js');\n          return {\n            defaultTargetOptions: {\n              distDir: path.join(__dirname, 'integration/cache/dist/test')\n            }\n          };\n        }\n      });\n      assert(/dist[/\\\\]test[/\\\\]index.js$/.test(b.bundleGraph.getBundles()[0].filePath), 'should end with dist/test/index.js');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when targets changes","suites":["cache","options"],"updatePoint":{"line":1405,"column":42,"index":59107},"line":1405,"code":"    it('should update when targets changes', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        targets: ['legacy'],\n        async setup() {\n          let pkgFile = path.join(inputDir, 'package.json');\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            targets: {\n              modern: {\n                engines: {\n                  browsers: 'last 1 Chrome version'\n                }\n              },\n              legacy: {\n                engines: {\n                  browsers: 'IE 11'\n                }\n              }\n            }\n          }));\n        },\n        async update(b) {\n          assertBundles(b.bundleGraph, [{\n            name: 'index.js',\n            assets: ['index.js', 'test.js', 'foo.js']\n          }]);\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should not include class');\n          return {\n            targets: ['modern']\n          };\n        }\n      });\n      assertBundles(b.bundleGraph, [{\n        name: 'index.js',\n        assets: ['index.js', 'test.js', 'foo.js']\n      }]);\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should include class');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when defaultEngines changes","suites":["cache","options"],"updatePoint":{"line":1449,"column":49,"index":60629},"line":1449,"code":"    it('should update when defaultEngines changes', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          engines: {\n            browsers: 'last 1 Chrome version'\n          }\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should include class');\n          return {\n            defaultTargetOptions: {\n              shouldScopeHoist: true,\n              engines: {\n                browsers: 'IE 11'\n              }\n            }\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!/class \\$[a-f0-9]+\\$var\\$Test/.test(contents), 'should not include class');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when shouldContentHash changes","suites":["cache","options"],"updatePoint":{"line":1473,"column":52,"index":61514},"line":1473,"code":"    it('should update when shouldContentHash changes', async function () {\n      let b = await testCache({\n        entries: ['src/index.html'],\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        shouldContentHash: true,\n        update(b) {\n          let bundle = b.bundleGraph.getBundles()[1];\n          assert(!bundle.filePath.includes(bundle.id.slice(-8)));\n          return {\n            shouldContentHash: false\n          };\n        }\n      });\n      let bundle = b.bundleGraph.getBundles()[1];\n      assert(bundle.filePath.includes(bundle.id.slice(-8)));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when hmr options change","suites":["cache","options"],"updatePoint":{"line":1491,"column":45,"index":62108},"line":1491,"code":"    it('should update when hmr options change', async function () {\n      let b = await testCache({\n        hmrOptions: {\n          host: 'localhost',\n          port: 4321\n        },\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              // Remove react-refresh transformer so we test whether the runtime updates\n              '*.js': ['@parcel/transformer-js']\n            }\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('HMR_HOST = \"localhost\"'), 'should include HMR_HOST = \"localhost\"');\n          assert(contents.includes('HMR_PORT = 4321'), 'should include HMR_PORT = 4321');\n          return {\n            hmrOptions: {\n              host: 'example.com',\n              port: 5678\n            }\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('HMR_HOST = \"example.com\"'), 'should include HMR_HOST = \"example.com\"');\n      assert(contents.includes('HMR_PORT = 5678'), 'should include HMR_PORT = 5678');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate react refresh hot options change","suites":["cache","options"],"updatePoint":{"line":1522,"column":58,"index":63432},"line":1522,"code":"    it('should invalidate react refresh hot options change', async function () {\n      let b = await testCache({\n        async setup() {\n          let pkgFile = path.join(inputDir, 'package.json');\n          let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n          await overlayFS.writeFile(pkgFile, JSON.stringify({\n            ...pkg,\n            dependencies: {\n              react: '*'\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), `import React from 'react';\n\n            export function Component() {\n              return <h1>Hello world</h1>;\n            }`);\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('getRefreshBoundarySignature'), 'should not include getRefreshBoundarySignature');\n          return {\n            hmrOptions: {\n              host: 'example.com',\n              port: 5678\n            }\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('getRefreshBoundarySignature'), 'should include getRefreshBoundarySignature');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when the config option changes","suites":["cache","options"],"updatePoint":{"line":1553,"column":52,"index":64679},"line":1553,"code":"    it('should update when the config option changes', async function () {\n      let b = await testCache({\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('TRANSFORMED CODE'));\n          await overlayFS.writeFile(path.join(inputDir, 'some-config'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n          return {\n            config: path.join(inputDir, 'some-config')\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('TRANSFORMED CODE'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update when the defaultConfig option changes","suites":["cache","options"],"updatePoint":{"line":1572,"column":59,"index":65482},"line":1572,"code":"    it('should update when the defaultConfig option changes', async function () {\n      let b = await testCache({\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('TRANSFORMED CODE'));\n          await overlayFS.writeFile(path.join(inputDir, 'some-config'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n          return {\n            defaultConfig: path.join(inputDir, 'some-config')\n          };\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('TRANSFORMED CODE'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update env browserslist in package.json when mode changes","suites":["cache","options"],"updatePoint":{"line":1591,"column":72,"index":66305},"line":1591,"code":"    it('should update env browserslist in package.json when mode changes', async function () {\n      let env = process.env.NODE_ENV;\n      delete process.env.NODE_ENV;\n      try {\n        let b = await testCache({\n          defaultTargetOptions: {\n            shouldScopeHoist: false,\n            shouldOptimize: false\n          },\n          mode: 'development',\n          async setup() {\n            let pkg = JSON.parse(await overlayFS.readFile(path.join(inputDir, 'package.json'), 'utf8'));\n            pkg.browserslist = {\n              production: ['ie 11'],\n              development: ['Chrome 80']\n            };\n            await overlayFS.writeFile(path.join(inputDir, 'package.json'), JSON.stringify(pkg, null, 2));\n          },\n          async update(b) {\n            let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(/class Test/.test(contents), 'should include class');\n            return {\n              mode: 'production'\n            };\n          }\n        });\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(!/class Test/.test(contents), 'does not include class');\n      } finally {\n        process.env.NODE_ENV = env;\n      }\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating a package.json#main field","suites":["cache","resolver"],"updatePoint":{"line":1625,"column":57,"index":67606},"line":1625,"code":"    it('should support updating a package.json#main field', async function () {\n      let b = await testCache(async b => {\n        assert.equal(await run(b.bundleGraph), 4);\n        await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/test.js'), 'module.exports = 4;');\n        await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/package.json'), JSON.stringify({\n          main: 'test.js'\n        }));\n      });\n      assert.equal(await run(b.bundleGraph), 8);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding an alias","suites":["cache","resolver"],"updatePoint":{"line":1635,"column":38,"index":68079},"line":1635,"code":"    it('should support adding an alias', async function () {\n      let b = await testCache(async b => {\n        assert.equal(await run(b.bundleGraph), 4);\n        await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/test.js'), 'module.exports = 4;');\n        await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/package.json'), JSON.stringify({\n          main: 'foo.js',\n          alias: {\n            './foo.js': './test.js'\n          }\n        }));\n      });\n      assert.equal(await run(b.bundleGraph), 8);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating an alias","suites":["cache","resolver"],"updatePoint":{"line":1648,"column":40,"index":68621},"line":1648,"code":"    it('should support updating an alias', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/test.js'), 'module.exports = 4;');\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/package.json'), JSON.stringify({\n            main: 'foo.js',\n            alias: {\n              './foo.js': './test.js'\n            }\n          }));\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 8);\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/baz.js'), 'module.exports = 6;');\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/package.json'), JSON.stringify({\n            main: 'foo.js',\n            alias: {\n              './foo.js': './baz.js'\n            }\n          }));\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 12);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deleting an alias","suites":["cache","resolver"],"updatePoint":{"line":1672,"column":40,"index":69570},"line":1672,"code":"    it('should support deleting an alias', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/test.js'), 'module.exports = 4;');\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/package.json'), JSON.stringify({\n            main: 'foo.js',\n            alias: {\n              './foo.js': './test.js'\n            }\n          }));\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 8);\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/package.json'), JSON.stringify({\n            main: 'foo.js'\n          }));\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding an alias in a closer package.json","suites":["cache","resolver"],"updatePoint":{"line":1692,"column":63,"index":70360},"line":1692,"code":"    it('should support adding an alias in a closer package.json', async function () {\n      let b = await testCache(async b => {\n        assert.equal(await run(b.bundleGraph), 4);\n        await overlayFS.writeFile(path.join(inputDir, 'src/nested/foo.js'), 'module.exports = 4;');\n        await overlayFS.writeFile(path.join(inputDir, 'src/nested/package.json'), JSON.stringify({\n          alias: {\n            './test.js': './foo.js'\n          }\n        }));\n      });\n      assert.equal(await run(b.bundleGraph), 6);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a file with a higher priority extension","suites":["cache","resolver"],"updatePoint":{"line":1704,"column":69,"index":70892},"line":1704,"code":"    it('should support adding a file with a higher priority extension', async function () {\n      let b = await testCache({\n        async setup() {\n          // Start out pointing to a .ts file from a .js file\n          let contents = await overlayFS.readFile(path.join(inputDir, 'src/index.js'), 'utf8');\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), contents.replace('nested/test', 'nested/foo'));\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/foo.ts'), 'module.exports = 4;');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 6);\n\n          // Adding a .js file should be higher priority\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/foo.js'), 'module.exports = 2;');\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support renaming a file to a different extension","suites":["cache","resolver"],"updatePoint":{"line":1721,"column":63,"index":71742},"line":1721,"code":"    it('should support renaming a file to a different extension', async function () {\n      let b = await testCache({\n        async setup() {\n          // Start out pointing to a .js file\n          let contents = await overlayFS.readFile(path.join(inputDir, 'src/index.js'), 'utf8');\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), contents.replace('nested/test', 'nested/foo'));\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/foo.js'), 'module.exports = 4;');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 6);\n\n          // Rename to .ts\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/foo.ts'), 'module.exports = 2;');\n          await overlayFS.unlink(path.join(inputDir, 'src/nested/foo.js'));\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve to a file over a directory with an index.js","suites":["cache","resolver"],"updatePoint":{"line":1739,"column":66,"index":72625},"line":1739,"code":"    it('should resolve to a file over a directory with an index.js', async function () {\n      let b = await testCache({\n        async setup() {\n          let contents = await overlayFS.readFile(path.join(inputDir, 'src/index.js'), 'utf8');\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), contents.replace('nested/test', 'nested'));\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/index.js'), 'module.exports = 4;');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 6);\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested.js'), 'module.exports = 2;');\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve to package.json#main over an index.js","suites":["cache","resolver"],"updatePoint":{"line":1753,"column":60,"index":73346},"line":1753,"code":"    it('should resolve to package.json#main over an index.js', async function () {\n      let b = await testCache({\n        async setup() {\n          let contents = await overlayFS.readFile(path.join(inputDir, 'src/index.js'), 'utf8');\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), contents.replace('nested/test', 'nested'));\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/index.js'), 'module.exports = 4;');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 6);\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/package.json'), JSON.stringify({\n            main: 'test.js'\n          }));\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should recover from errors when adding a missing dependency","suites":["cache","resolver"],"updatePoint":{"line":1769,"column":67,"index":74120},"line":1769,"code":"    it('should recover from errors when adding a missing dependency', async function () {\n      // $FlowFixMe\n      await assert.rejects(async () => {\n        await testCache({\n          async setup() {\n            await overlayFS.unlink(path.join(inputDir, 'src/nested/test.js'));\n          },\n          async update() {}\n        });\n      }, {\n        message: \"Failed to resolve './nested/test' from './src/index.js'\"\n      });\n      await overlayFS.writeFile(path.join(inputDir, 'src/nested/test.js'), 'module.exports = 4;');\n      let b = await runBundle();\n      assert.equal(await run(b.bundleGraph), 6);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should recover from a missing package.json#main","suites":["cache","resolver"],"updatePoint":{"line":1785,"column":55,"index":74728},"line":1785,"code":"    it('should recover from a missing package.json#main', async function () {\n      let b = await testCache({\n        async setup() {\n          let contents = await overlayFS.readFile(path.join(inputDir, 'src/index.js'), 'utf8');\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), contents.replace('nested/test', 'nested'));\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/package.json'), JSON.stringify({\n            main: 'tmp.js'\n          }));\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/index.js'), 'module.exports = 4;');\n        },\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 6);\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/tmp.js'), 'module.exports = 8;');\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 10);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should recover from an invalid package.json","suites":["cache","resolver"],"updatePoint":{"line":1802,"column":51,"index":75588},"line":1802,"code":"    it('should recover from an invalid package.json', async function () {\n      // $FlowFixMe\n      await assert.rejects(async () => {\n        await testCache({\n          async setup() {\n            let contents = await overlayFS.readFile(path.join(inputDir, 'src/index.js'), 'utf8');\n            await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), contents.replace('nested/test', 'nested'));\n            await overlayFS.writeFile(path.join(inputDir, 'src/nested/package.json'), 'invalid');\n            await overlayFS.writeFile(path.join(inputDir, 'src/nested/index.js'), 'module.exports = 10;');\n          },\n          async update() {}\n        });\n      });\n      await overlayFS.writeFile(path.join(inputDir, 'src/nested/package.json'), JSON.stringify({\n        main: 'test.js'\n      }));\n      let b = await runBundle();\n      assert.equal(await run(b.bundleGraph), 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a deeper node_modules folder","suites":["cache","resolver"],"updatePoint":{"line":1821,"column":58,"index":76489},"line":1821,"code":"    it('should support adding a deeper node_modules folder', async function () {\n      let b = await testCache({\n        async update(b) {\n          assert.equal(await run(b.bundleGraph), 4);\n          await overlayFS.mkdirp(path.join(inputDir, 'src/nested/node_modules/foo'));\n          await overlayFS.writeFile(path.join(inputDir, 'src/nested/node_modules/foo/index.js'), 'module.exports = 4;');\n        }\n      });\n      assert.equal(await run(b.bundleGraph), 6);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when the .pnp.js file changes","suites":["cache","resolver","pnp"],"updatePoint":{"line":1832,"column":57,"index":76998},"line":1832,"code":"      it('should invalidate when the .pnp.js file changes', async function () {\n        let Module = require('module');\n        let origPnpVersion = process.versions.pnp;\n        // $FlowFixMe[prop-missing]\n        let origModuleResolveFilename = Module._resolveFilename;\n        try {\n          let b = await testCache({\n            entries: ['index.js'],\n            inputFS,\n            async setup() {\n              await inputFS.mkdirp(inputDir);\n              await inputFS.ncp(path.join(__dirname, '/integration/pnp-require'), inputDir);\n\n              // $FlowFixMe[incompatible-type]\n              process.versions.pnp = 42;\n\n              // $FlowFixMe[prop-missing]\n              Module.findPnpApi = () =>\n              // $FlowFixMe\n              require(path.join(inputDir, '.pnp.js'));\n              await inputFS.mkdirp(path.join(inputDir, 'pnp/testmodule2'));\n              await inputFS.writeFile(path.join(inputDir, 'pnp/testmodule2/index.js'), 'exports.a = 4;');\n            },\n            async update(b) {\n              let output = await run(b.bundleGraph);\n              assert.equal(output(), 3);\n              let pnp = await inputFS.readFile(path.join(inputDir, '.pnp.js'), 'utf8');\n              await inputFS.writeFile(path.join(inputDir, '.pnp.js'), pnp.replace(\"'pnp', 'testmodule'\", \"'pnp', 'testmodule2'\"));\n              delete require.cache[path.join(inputDir, '.pnp.js')];\n              await sleep(100);\n            }\n          }, 'pnp-require');\n          let output = await run(b.bundleGraph);\n          assert.equal(output(), 6);\n        } finally {\n          // $FlowFixMe[incompatible-type]\n          process.versions.pnp = origPnpVersion;\n          // $FlowFixMe[prop-missing]\n          Module._resolveFilename = origModuleResolveFilename;\n        }\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support resolver inside stylus file","suites":["cache","resolver","stylus"],"updatePoint":{"line":1875,"column":52,"index":78840},"line":1875,"code":"      it('should support resolver inside stylus file', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, 'index.styl'), `\n            @import \"./b\";\n            .a\n              background: red\n            `);\n            await overlayFS.mkdirp(path.join(inputDir, 'b'));\n            await overlayFS.writeFile(path.join(inputDir, 'b/index.styl'), `\n            .b\n              background: blue\n            `);\n          },\n          async update(b) {\n            let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n            assert(css.includes('.a {'));\n            assert(css.includes('.b {'));\n            assert(!css.includes('.c {'));\n            await overlayFS.writeFile(path.join(inputDir, 'b.styl'), `\n            .c\n              background: blue\n            `);\n          }\n        }, 'stylus');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(css.includes('.a {'));\n        assert(!css.includes('.b {'));\n        assert(css.includes('.c {'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support stylus default resolver","suites":["cache","resolver","stylus"],"updatePoint":{"line":1906,"column":48,"index":80068},"line":1906,"code":"      it('should support stylus default resolver', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, '.stylusrc'), JSON.stringify({\n              paths: ['deps']\n            }));\n          },\n          async update(b) {\n            let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n            assert(css.includes('.a {'));\n            assert(!css.includes('.b {'));\n            await overlayFS.writeFile(path.join(inputDir, 'a.styl'), `\n            .b\n              background: blue\n            `);\n          }\n        }, 'stylus-deps');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(!css.includes('.a {'));\n        assert(css.includes('.b {'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support glob imports in stylus files","suites":["cache","resolver","stylus"],"updatePoint":{"line":1928,"column":53,"index":80998},"line":1928,"code":"      it('should support glob imports in stylus files', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          async update(b) {\n            let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n            assert(css.includes('.index'));\n            assert(css.includes('.main'));\n            assert(css.includes('.foo'));\n            assert(css.includes('.bar'));\n            await overlayFS.writeFile(path.join(inputDir, 'subdir/test.styl'), `\n            .test\n              background: blue\n            `);\n            await overlayFS.writeFile(path.join(inputDir, 'subdir/foo/test.styl'), `\n            .foo-test\n              background: blue\n            `);\n          }\n        }, 'stylus-glob-import');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(css.includes('.index'));\n        assert(css.includes('.main'));\n        assert(css.includes('.foo'));\n        assert(css.includes('.bar'));\n        assert(css.includes('.test'));\n        assert(css.includes('.foo-test'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support glob imports under stylus paths","suites":["cache","resolver","stylus"],"updatePoint":{"line":1955,"column":56,"index":82176},"line":1955,"code":"      it('should support glob imports under stylus paths', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, '.stylusrc'), JSON.stringify({\n              paths: ['subdir']\n            }));\n            await overlayFS.writeFile(path.join(inputDir, 'index.styl'), `\n            @require 'foo/*'\n\n            .index\n              color: red\n            `);\n          },\n          async update(b) {\n            let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n            assert(css.includes('.index'));\n            assert(!css.includes('.main'));\n            assert(css.includes('.foo'));\n            assert(!css.includes('.bar'));\n            await overlayFS.writeFile(path.join(inputDir, 'subdir/test.styl'), `\n            .test\n              background: blue\n            `);\n            await overlayFS.writeFile(path.join(inputDir, 'subdir/foo/test.styl'), `\n            .foo-test\n              background: blue\n            `);\n          }\n        }, 'stylus-glob-import');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(css.includes('.index'));\n        assert(!css.includes('.main'));\n        assert(css.includes('.foo'));\n        assert(!css.includes('.bar'));\n        assert(!css.includes('.test'));\n        assert(css.includes('.foo-test'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding higher priority less include paths","suites":["cache","resolver","less"],"updatePoint":{"line":1995,"column":66,"index":83754},"line":1995,"code":"      it('should support adding higher priority less include paths', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, '.lessrc'), JSON.stringify({\n              paths: ['include-path', 'node_modules/library']\n            }));\n          },\n          async update(b) {\n            let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n            assert(css.includes('.a'));\n            assert(css.includes('.b'));\n            await overlayFS.writeFile(path.join(inputDir, 'a.less'), `.c {\n                  background: blue\n                }`);\n            await overlayFS.writeFile(path.join(inputDir, 'include-path/b.less'), `.d {\n                  background: blue\n                }`);\n          }\n        }, 'less-include-paths');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(!css.includes('.a'));\n        assert(!css.includes('.b'));\n        assert(css.includes('.c'));\n        assert(css.includes('.d'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should recover from missing import errors","suites":["cache","resolver","less"],"updatePoint":{"line":2021,"column":51,"index":84925},"line":2021,"code":"      it('should recover from missing import errors', async function () {\n        // $FlowFixMe\n        await assert.rejects(async () => {\n          await testCache({\n            entries: ['index.js'],\n            async setup() {\n              await overlayFS.writeFile(path.join(inputDir, '.lessrc'), JSON.stringify({\n                paths: ['include-path', 'node_modules/library']\n              }));\n              await overlayFS.writeFile(path.join(inputDir, 'yarn.lock'), '');\n              await overlayFS.unlink(path.join(inputDir, 'include-path/a.less'));\n            },\n            async update() {}\n          }, 'less-include-paths');\n        }, {\n          message: \"Failed to resolve 'a.less' from './index.less'\"\n        });\n        await overlayFS.writeFile(path.join(inputDir, 'include-path/a.less'), `.d {\n            background: blue\n          }`);\n        let b = await runBundle('index.js');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(css.includes('.d'));\n        assert(css.includes('.b'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding higher priority sass include paths","suites":["cache","resolver","sass"],"updatePoint":{"line":2048,"column":66,"index":86093},"line":2048,"code":"      it('should support adding higher priority sass include paths', async function () {\n        let b = await testCache({\n          entries: ['index.sass'],\n          async setup() {\n            await overlayFS.writeFile(path.join(inputDir, '.sassrc'), JSON.stringify({\n              includePaths: ['include-path']\n            }));\n          },\n          async update(b) {\n            let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n            assert(css.includes('.included'));\n            await overlayFS.writeFile(path.join(inputDir, 'style.sass'), `.test\n                  background: blue\n                `);\n          }\n        }, 'sass-include-paths-import');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(!css.includes('.included'));\n        assert(css.includes('.test'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should the SASS_PATH environment variable","suites":["cache","resolver","sass"],"updatePoint":{"line":2068,"column":51,"index":87020},"line":2068,"code":"      it('should the SASS_PATH environment variable', async function () {\n        let b = await testCache({\n          entries: ['index.sass'],\n          env: {\n            SASS_PATH: 'include-path'\n          },\n          async setup() {\n            await overlayFS.mkdirp(path.join(inputDir, 'include2'));\n            await overlayFS.writeFile(path.join(inputDir, 'include2/style.sass'), `.test\n                  background: blue\n                `);\n          },\n          async update(b) {\n            let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n            assert(css.includes('.included'));\n            return {\n              env: {\n                SASS_PATH: 'include2'\n              }\n            };\n          }\n        }, 'sass-include-paths-import');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(!css.includes('.included'));\n        assert(css.includes('.test'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should recover from missing import errors","suites":["cache","resolver","sass"],"updatePoint":{"line":2094,"column":51,"index":88055},"line":2094,"code":"      it('should recover from missing import errors', async function () {\n        // $FlowFixMe\n        await assert.rejects(async () => {\n          await testCache({\n            entries: ['index.sass'],\n            async setup() {\n              await overlayFS.writeFile(path.join(inputDir, '.sassrc'), JSON.stringify({\n                includePaths: ['include-path']\n              }));\n              await overlayFS.writeFile(path.join(inputDir, 'yarn.lock'), '');\n              await overlayFS.unlink(path.join(inputDir, 'include-path/style.sass'));\n            },\n            async update() {}\n          }, 'sass-include-paths-import');\n        });\n        await overlayFS.writeFile(path.join(inputDir, 'include-path/style.sass'), `.d\n            background: blue\n          `);\n        let b = await runBundle('index.sass');\n        let css = await overlayFS.readFile(b.bundleGraph.getBundles().find(b => b.type === 'css')?.filePath, 'utf8');\n        assert(css.includes('.d'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when updating a parcel transformer plugin","suites":["cache","dev deps"],"updatePoint":{"line":2119,"column":67,"index":89114},"line":2119,"code":"    it('should invalidate when updating a parcel transformer plugin', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n        },\n        async update(b) {\n          let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(output.includes('TRANSFORMED CODE'));\n          let transformerDir = path.join(inputDir, 'node_modules', 'parcel-transformer-mock');\n          await overlayFS.writeFile(path.join(transformerDir, 'constants.js'), 'exports.message = \"UPDATED\"');\n        }\n      });\n      let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(output.includes('UPDATED'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when updating a file required via options.packageManager.require","suites":["cache","dev deps"],"updatePoint":{"line":2139,"column":90,"index":90082},"line":2139,"code":"    it('should invalidate when updating a file required via options.packageManager.require', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n          let transformer = path.join(inputDir, 'node_modules', 'parcel-transformer-mock', 'index.js');\n          let contents = await overlayFS.readFile(transformer, 'utf8');\n          await overlayFS.writeFile(transformer, contents.replace('transform({asset}) {', 'async transform({asset, options}) {').replace(\"const {message} = require('./constants');\", \"const message = 'FOO: ' + await options.packageManager.require('foo', asset.filePath);\"));\n        },\n        async update(b) {\n          let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(output.includes('FOO: 2'));\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules', 'foo', 'foo.js'), 'module.exports = 3;');\n        }\n      });\n      let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(output.includes('FOO: 3'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve to package.json#main over an index.js","suites":["cache","dev deps"],"updatePoint":{"line":2161,"column":60,"index":91367},"line":2161,"code":"    it('should resolve to package.json#main over an index.js', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n        },\n        async update(b) {\n          let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(output.includes('TRANSFORMED CODE'));\n          let transformerDir = path.join(inputDir, 'node_modules', 'parcel-transformer-mock');\n          await overlayFS.writeFile(path.join(transformerDir, 'MockTransformer.js'), `\n            const Transformer = require('@parcel/plugin').Transformer;\n            module.exports = new Transformer({\n              transform({asset}) {\n                return [\n                  {\n                    type: 'js',\n                    content: 'UPDATED',\n                  },\n                ];\n              }\n            });\n            `);\n          await overlayFS.writeFile(path.join(transformerDir, 'package.json'), JSON.stringify({\n            main: 'MockTransformer.js'\n          }));\n        }\n      });\n      let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(output.includes('UPDATED'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve to a file over a directory with an index.js","suites":["cache","dev deps"],"updatePoint":{"line":2196,"column":66,"index":92795},"line":2196,"code":"    it('should resolve to a file over a directory with an index.js', async function () {\n      let transformerDir = path.join(inputDir, 'node_modules', 'parcel-transformer-mock');\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            transformers: {\n              '*.js': ['parcel-transformer-mock']\n            }\n          }));\n          await overlayFS.unlink(path.join(transformerDir, 'constants.js'));\n          await overlayFS.mkdirp(path.join(transformerDir, 'constants'));\n          await overlayFS.writeFile(path.join(transformerDir, 'constants', 'index.js'), 'exports.message = \"TRANSFORMED\"');\n        },\n        async update(b) {\n          let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(output.includes('TRANSFORMED'));\n          await overlayFS.writeFile(path.join(transformerDir, 'constants.js'), 'exports.message = \"UPDATED\"');\n        }\n      });\n      let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(output.includes('UPDATED'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding a deeper node_modules folder","suites":["cache","dev deps"],"updatePoint":{"line":2219,"column":58,"index":93997},"line":2219,"code":"    it('should support adding a deeper node_modules folder', async function () {});","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support yarn pnp","suites":["cache","dev deps"],"updatePoint":{"line":2220,"column":31,"index":94054},"line":2220,"code":"    it('should support yarn pnp', async function () {\n      let Module = require('module');\n      // $FlowFixMe[incompatible-type]\n      let origPnpVersion = process.versions.pnp;\n      // $FlowFixMe[prop-missing]\n      let origModuleResolveFilename = Module._resolveFilename;\n\n      // We must create a worker farm that only uses a single thread because our process.versions.pnp\n      // mock won't be available in the workers of the existing farm.\n      let workerFarm = createWorkerFarm({\n        maxConcurrentWorkers: 0\n      });\n      try {\n        let b = await testCache({\n          inputFS,\n          outputFS: inputFS,\n          workerFarm,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n\n            // $FlowFixMe\n            process.versions.pnp = 42;\n            fs.renameSync(path.join(inputDir, 'node_modules'), path.join(inputDir, 'pnp'));\n            await inputFS.ncp(path.join(inputDir, 'pnp'), path.join(inputDir, 'pnp2'));\n            await inputFS.writeFile(path.join(inputDir, 'pnp', 'parcel-transformer-mock', 'index.js'), `\n                const Transformer = require('@parcel/plugin').Transformer;\n                module.exports = new Transformer({\n                  transform({asset}) {\n                    return [\n                      {\n                        type: 'js',\n                        content: 'TRANSFORMED CODE',\n                      },\n                    ];\n                  }\n                });\n                `);\n            await inputFS.writeFile(path.join(inputDir, 'pnp2', 'parcel-transformer-mock', 'index.js'), `\n                const Transformer = require('@parcel/plugin').Transformer;\n                module.exports = new Transformer({\n                  transform({asset}) {\n                    return [\n                      {\n                        type: 'js',\n                        content: 'UPDATED',\n                      },\n                    ];\n                  }\n                });\n                `);\n            await inputFS.writeFile(path.join(inputDir, '.pnp.js'), `\n                const path = require('path');\n                const resolve = request => {\n                  if (request === 'parcel-transformer-mock' || request === 'foo') {\n                    return path.join(__dirname, 'pnp', request);\n                  } else if (request === 'pnpapi') {\n                    return __filename;\n                  } else {\n                    return require.resolve(request);\n                  }\n                };\n\n                module.exports = {resolveToUnqualified: resolve, resolveRequest: resolve};\n                `);\n\n            // $FlowFixMe[prop-missing]\n            Module.findPnpApi = () =>\n            // $FlowFixMe\n            require(path.join(inputDir, '.pnp.js'));\n            await inputFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n              extends: '@parcel/config-default',\n              transformers: {\n                '*.js': ['parcel-transformer-mock']\n              }\n            }));\n          },\n          async update(b) {\n            let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(output.includes('TRANSFORMED CODE'));\n            await inputFS.writeFile(path.join(inputDir, '.pnp.js'), `\n                const path = require('path');\n                const resolve = request => {\n                  if (request === 'parcel-transformer-mock' || request === 'foo') {\n                    return path.join(__dirname, 'pnp2', request);\n                  } else if (request === 'pnpapi') {\n                    return __filename;\n                  } else {\n                    return require.resolve(request);\n                  }\n                };\n\n                module.exports = {resolveToUnqualified: resolve, resolveRequest: resolve};\n                `);\n            delete require.cache[path.join(inputDir, '.pnp.js')];\n            await sleep(100);\n          }\n        });\n        let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(output.includes('UPDATED'));\n      } finally {\n        process.versions.pnp = origPnpVersion;\n        // $FlowFixMe[prop-missing]\n        Module._resolveFilename = origModuleResolveFilename;\n        await workerFarm.end();\n      }\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a postcss plugin changes","suites":["cache","dev deps","postcss"],"updatePoint":{"line":2328,"column":57,"index":98543},"line":2328,"code":"      it('should invalidate when a postcss plugin changes', async function () {\n        let b = await testCache({\n          entries: ['index.css'],\n          async setup() {\n            await overlayFS.mkdirp(path.join(inputDir, 'node_modules'));\n            await ncp(path.join(path.join(__dirname, 'integration', 'postcss-autoinstall', 'postcss-test')), path.join(inputDir, 'node_modules', 'postcss-test'));\n          },\n          async update(b) {\n            let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(output.includes('background: green'));\n            let plugin = path.join(inputDir, 'node_modules', 'postcss-test', 'index.js');\n            let pluginContents = await overlayFS.readFile(plugin, 'utf8');\n            await overlayFS.writeFile(plugin, pluginContents.replace('green', 'red'));\n          }\n        }, 'postcss-autoinstall/npm');\n        let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(output.includes('background: red'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a JS postcss config changes","suites":["cache","dev deps","postcss"],"updatePoint":{"line":2346,"column":60,"index":99614},"line":2346,"code":"      it('should invalidate when a JS postcss config changes', async function () {\n        let b = await testCache({\n          entries: ['style.css'],\n          inputFS,\n          outputFS: inputFS,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/postcss-js-config-7'), inputDir);\n          },\n          async update(b) {\n            let output = await inputFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(output.includes('background-color: red;'));\n            let config = path.join(inputDir, 'postcss.config.js');\n            let configContents = await inputFS.readFile(config, 'utf8');\n            await inputFS.writeFile(config, configContents.replace('red', 'green'));\n            await sleep(100);\n          }\n        }, 'postcss-js-config-7');\n        let output = await inputFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(output.includes('background-color: green'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a JSON postcss config changes","suites":["cache","dev deps","postcss"],"updatePoint":{"line":2367,"column":62,"index":100650},"line":2367,"code":"      it('should invalidate when a JSON postcss config changes', async function () {\n        let b = await testCache({\n          entries: ['nested/index.css'],\n          async update(b) {\n            let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(output.includes('background-color: green;'));\n            let configContents = await overlayFS.readFile(path.join(inputDir, '.postcssrc'), 'utf8');\n            await overlayFS.writeFile(path.join(inputDir, '.postcssrc'), configContents.replace('green', 'red'));\n          }\n        }, 'postcss-import');\n        let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(output.includes('background-color: red'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a closer postcss config is added","suites":["cache","dev deps","postcss"],"updatePoint":{"line":2380,"column":65,"index":101426},"line":2380,"code":"      it('should invalidate when a closer postcss config is added', async function () {\n        let b = await testCache({\n          entries: ['nested/index.css'],\n          async update(b) {\n            let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(output.includes('background-color: green;'));\n            let configContents = await overlayFS.readFile(path.join(inputDir, '.postcssrc'), 'utf8');\n            await overlayFS.writeFile(path.join(inputDir, 'nested', '.postcssrc'), configContents.replace('green', 'red'));\n          }\n        }, 'postcss-import');\n        let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(output.includes('background-color: red'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a posthtml plugin changes","suites":["cache","dev deps","posthtml"],"updatePoint":{"line":2395,"column":58,"index":102252},"line":2395,"code":"      it('should invalidate when a posthtml plugin changes', async function () {\n        let b = await testCache({\n          entries: ['index.html'],\n          async setup() {\n            await overlayFS.mkdirp(path.join(inputDir, 'node_modules'));\n            await ncp(path.join(path.join(__dirname, 'integration', 'posthtml-autoinstall', 'posthtml-test')), path.join(inputDir, 'node_modules', 'posthtml-test'));\n          },\n          async update(b) {\n            let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(output.includes('<span id=\"test\">Test</span>'));\n            let plugin = path.join(inputDir, 'node_modules', 'posthtml-test', 'index.js');\n            let pluginContents = await overlayFS.readFile(plugin, 'utf8');\n            await overlayFS.writeFile(plugin, pluginContents.replace('span', 'section'));\n          }\n        }, 'posthtml-autoinstall');\n        let output = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(output.includes('<section id=\"test\">Test</section>'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a JS postcss config changes","suites":["cache","dev deps","posthtml"],"updatePoint":{"line":2413,"column":60,"index":103356},"line":2413,"code":"      it('should invalidate when a JS postcss config changes', async function () {\n        let b = await testCache({\n          entries: ['index.html'],\n          inputFS,\n          outputFS: inputFS,\n          async setup() {\n            await inputFS.mkdirp(inputDir);\n            await inputFS.ncp(path.join(__dirname, '/integration/posthtml'), inputDir);\n            await inputFS.mkdirp(path.join(inputDir, 'include'));\n            await inputFS.writeFile(path.join(inputDir, 'include', 'other.html'), '<h1>Another great page</h1>');\n          },\n          async update(b) {\n            let output = await inputFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n            assert(output.includes('<h1>Other page</h1>'));\n            let config = path.join(inputDir, '.posthtmlrc.js');\n            let configContents = await inputFS.readFile(config, 'utf8');\n            await inputFS.writeFile(config, configContents.replace('__dirname', '__dirname + \"/include\"'));\n            await sleep(100);\n          }\n        }, 'posthtml');\n        let output = await inputFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(output.includes('<h1>Another great page</h1>'));\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when switching to a different bundler plugin","suites":["cache","bundling"],"updatePoint":{"line":2439,"column":70,"index":104631},"line":2439,"code":"    it('should invalidate when switching to a different bundler plugin', async function () {\n      let b = await testCache({\n        async update(b) {\n          assert.equal(b.bundleGraph.getBundles().length, 1);\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            bundler: 'parcel-bundler-test'\n          }));\n        }\n      });\n      assert.equal(b.bundleGraph.getBundles().length, 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a bundler plugin is updated","suites":["cache","bundling"],"updatePoint":{"line":2451,"column":58,"index":105110},"line":2451,"code":"    it('should invalidate when a bundler plugin is updated', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            bundler: 'parcel-bundler-test'\n          }));\n        },\n        async update(b) {\n          assert.equal(b.bundleGraph.getBundles().length, 4);\n          assert.equal(b.bundleGraph.getBundles()[0].name, 'index.js');\n          let bundler = path.join(inputDir, 'node_modules', 'parcel-bundler-test', 'index.js');\n          await overlayFS.writeFile(bundler, (await overlayFS.readFile(bundler, 'utf8')).replace('Boolean(dependency.isEntry)', 'false'));\n        }\n      });\n      assert.equal(b.bundleGraph.getBundles().length, 4);\n      assert(b.bundleGraph.getBundles()[0].name.includes('HASH_REF'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when adding a namer plugin","suites":["cache","bundling"],"updatePoint":{"line":2469,"column":52,"index":105996},"line":2469,"code":"    it('should invalidate when adding a namer plugin', async function () {\n      let b = await testCache({\n        async update(b) {\n          let bundles = b.bundleGraph.getBundles().map(b => b.name);\n          assert.deepEqual(bundles, ['index.js']);\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            namers: ['parcel-namer-test']\n          }));\n        }\n      });\n      let bundles = b.bundleGraph.getBundles();\n      assert.deepEqual(bundles.map(b => b.name), bundles.map(b => `${b.id}.${b.type}`));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a namer plugin is updated","suites":["cache","bundling"],"updatePoint":{"line":2483,"column":56,"index":106609},"line":2483,"code":"    it('should invalidate when a namer plugin is updated', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            namers: ['parcel-namer-test']\n          }));\n        },\n        async update(b) {\n          let bundles = b.bundleGraph.getBundles();\n          assert.deepEqual(bundles.map(b => b.name), bundles.map(b => `${b.id}.${b.type}`));\n          let namer = path.join(inputDir, 'node_modules', 'parcel-namer-test', 'index.js');\n          await overlayFS.writeFile(namer, (await overlayFS.readFile(namer, 'utf8')).replace('bundle.id', 'bundle.id.slice(-8)'));\n        }\n      });\n      let bundles = b.bundleGraph.getBundles();\n      assert.deepEqual(bundles.map(b => b.name), bundles.map(b => `${b.id.slice(-8)}.${b.type}`));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when adding a runtime plugin","suites":["cache","bundling"],"updatePoint":{"line":2501,"column":54,"index":107513},"line":2501,"code":"    it('should invalidate when adding a runtime plugin', async function () {\n      let b = await testCache({\n        async update(b) {\n          let res = await run(b.bundleGraph, null, {\n            require: false\n          });\n          assert.equal(res.runtime_test, undefined);\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            runtimes: ['parcel-runtime-test']\n          }));\n        }\n      });\n      let res = await run(b.bundleGraph, null, {\n        require: false\n      });\n      assert.equal(res.runtime_test, true);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a runtime is updated","suites":["cache","bundling"],"updatePoint":{"line":2519,"column":51,"index":108141},"line":2519,"code":"    it('should invalidate when a runtime is updated', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            runtimes: ['parcel-runtime-test']\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph, null, {\n            require: false\n          });\n          assert.equal(res.runtime_test, true);\n          assert.equal(res.test_runtime, undefined);\n          let namer = path.join(inputDir, 'node_modules', 'parcel-runtime-test', 'index.js');\n          await overlayFS.writeFile(namer, (await overlayFS.readFile(namer, 'utf8')).replace('runtime_test', 'test_runtime'));\n        }\n      });\n      let res = await run(b.bundleGraph, null, {\n        require: false\n      });\n      assert.equal(res.runtime_test, undefined);\n      assert.equal(res.test_runtime, true);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding bundler config","suites":["cache","bundling","bundler config"],"updatePoint":{"line":2544,"column":46,"index":109162},"line":2544,"code":"      it('should support adding bundler config', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          mode: 'production',\n          async setup() {\n            let pkgFile = path.join(inputDir, 'package.json');\n            let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n            await overlayFS.writeFile(pkgFile, JSON.stringify({\n              ...pkg,\n              '@parcel/bundler-default': undefined\n            }));\n          },\n          async update(b) {\n            assertBundles(b.bundleGraph, [{\n              assets: ['a.js']\n            }, {\n              assets: ['b.js']\n            }, {\n              name: 'index.js',\n              assets: ['index.js', 'c.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'bundle-manifest.js']\n            }, {\n              assets: ['common.js', 'lodash.js']\n            }]);\n            let pkgFile = path.join(inputDir, 'package.json');\n            let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n            await overlayFS.writeFile(pkgFile, JSON.stringify({\n              ...pkg,\n              '@parcel/bundler-default': {\n                minBundleSize: 9000000\n              }\n            }));\n          }\n        }, 'dynamic-common-large');\n        assertBundles(b.bundleGraph, [{\n          assets: ['a.js', 'common.js', 'lodash.js']\n        }, {\n          assets: ['b.js', 'common.js', 'lodash.js']\n        }, {\n          name: 'index.js',\n          assets: ['index.js', 'c.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'bundle-manifest.js']\n        }]);\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding bundler config for parallel request limits","suites":["cache","bundling","bundler config"],"updatePoint":{"line":2586,"column":74,"index":110796},"line":2586,"code":"      it('should support adding bundler config for parallel request limits', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          mode: 'production',\n          async setup() {\n            let pkgFile = path.join(inputDir, 'package.json');\n            let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n            await overlayFS.writeFile(pkgFile, JSON.stringify({\n              ...pkg,\n              '@parcel/bundler-default': undefined\n            }));\n          },\n          async update(b) {\n            assert.deepEqual(b.bundleGraph.getBundles().length, 7);\n            let pkgFile = path.join(inputDir, 'package.json');\n            let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n            await overlayFS.writeFile(pkgFile, JSON.stringify({\n              ...pkg,\n              '@parcel/bundler-default': {\n                maxParallelRequests: 0\n              }\n            }));\n          }\n        }, 'large-bundlegroup');\n        assert.deepEqual(b.bundleGraph.getBundles().length, 5);\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating bundler config","suites":["cache","bundling","bundler config"],"updatePoint":{"line":2612,"column":48,"index":111837},"line":2612,"code":"      it('should support updating bundler config', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          mode: 'production',\n          async setup() {\n            let pkgFile = path.join(inputDir, 'package.json');\n            let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n            await overlayFS.writeFile(pkgFile, JSON.stringify({\n              ...pkg,\n              '@parcel/bundler-default': {\n                minBundleSize: 8000\n              }\n            }));\n          },\n          async update(b) {\n            assertBundles(b.bundleGraph, [{\n              assets: ['a.js']\n            }, {\n              assets: ['b.js']\n            }, {\n              name: 'index.js',\n              assets: ['index.js', 'c.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'bundle-manifest.js']\n            }, {\n              assets: ['common.js', 'lodash.js']\n            }]);\n            let pkgFile = path.join(inputDir, 'package.json');\n            let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n            await overlayFS.writeFile(pkgFile, JSON.stringify({\n              ...pkg,\n              '@parcel/bundler-default': {\n                minBundleSize: 9000000\n              }\n            }));\n          }\n        }, 'dynamic-common-large');\n        assertBundles(b.bundleGraph, [{\n          assets: ['a.js', 'common.js', 'lodash.js']\n        }, {\n          assets: ['b.js', 'common.js', 'lodash.js']\n        }, {\n          name: 'index.js',\n          assets: ['index.js', 'c.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'bundle-manifest.js']\n        }]);\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support removing bundler config","suites":["cache","bundling","bundler config"],"updatePoint":{"line":2656,"column":48,"index":113489},"line":2656,"code":"      it('should support removing bundler config', async function () {\n        let b = await testCache({\n          entries: ['index.js'],\n          mode: 'production',\n          async setup() {\n            let pkgFile = path.join(inputDir, 'package.json');\n            let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n            await overlayFS.writeFile(pkgFile, JSON.stringify({\n              ...pkg,\n              '@parcel/bundler-default': {\n                minBundleSize: 9000000\n              }\n            }));\n          },\n          async update(b) {\n            assertBundles(b.bundleGraph, [{\n              assets: ['a.js', 'common.js', 'lodash.js']\n            }, {\n              assets: ['b.js', 'common.js', 'lodash.js']\n            }, {\n              name: 'index.js',\n              assets: ['index.js', 'c.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'bundle-manifest.js']\n            }]);\n            let pkgFile = path.join(inputDir, 'package.json');\n            let pkg = JSON.parse(await overlayFS.readFile(pkgFile));\n            await overlayFS.writeFile(pkgFile, JSON.stringify({\n              ...pkg,\n              '@parcel/bundler-default': undefined\n            }));\n          }\n        }, 'dynamic-common-large');\n        assertBundles(b.bundleGraph, [{\n          assets: ['a.js']\n        }, {\n          assets: ['b.js']\n        }, {\n          name: 'index.js',\n          assets: ['index.js', 'c.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'bundle-manifest.js']\n        }, {\n          assets: ['common.js', 'lodash.js']\n        }]);\n      });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when switching to a different packager plugin","suites":["cache","packaging"],"updatePoint":{"line":2701,"column":71,"index":115164},"line":2701,"code":"    it('should invalidate when switching to a different packager plugin', async function () {\n      let b = await testCache({\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.notEqual(res, 'packaged');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.js': 'parcel-packager-test'\n            }\n          }));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'packaged');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a packager is updated","suites":["cache","packaging"],"updatePoint":{"line":2717,"column":52,"index":115823},"line":2717,"code":"    it('should invalidate when a packager is updated', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.js': 'parcel-packager-test'\n            }\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'packaged');\n          let packager = path.join(inputDir, 'node_modules', 'parcel-packager-test', 'index.js');\n          await overlayFS.writeFile(packager, (await overlayFS.readFile(packager, 'utf8')).replace('packaged', 'updated'));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when adding packager config","suites":["cache","packaging"],"updatePoint":{"line":2737,"column":53,"index":116736},"line":2737,"code":"    it('should invalidate when adding packager config', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.js': 'parcel-packager-test'\n            }\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'packaged');\n          await overlayFS.writeFile(path.join(inputDir, '.packagerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'test');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when updating packager config","suites":["cache","packaging"],"updatePoint":{"line":2758,"column":55,"index":117556},"line":2758,"code":"    it('should invalidate when updating packager config', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.js': 'parcel-packager-test'\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.packagerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.packagerrc'), JSON.stringify({\n            value: 'updated'\n          }));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when removing packager config","suites":["cache","packaging"],"updatePoint":{"line":2782,"column":55,"index":118508},"line":2782,"code":"    it('should invalidate when removing packager config', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.js': 'parcel-packager-test'\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.packagerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'test');\n          await overlayFS.unlink(path.join(inputDir, '.packagerrc'));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'packaged');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when adding an optimizer plugin","suites":["cache","packaging"],"updatePoint":{"line":2804,"column":57,"index":119400},"line":2804,"code":"    it('should invalidate when adding an optimizer plugin', async function () {\n      let b = await testCache({\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.notEqual(res, 'optimized');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.js': ['parcel-optimizer-test']\n            }\n          }));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'optimized');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when removing an optimizer plugin","suites":["cache","packaging"],"updatePoint":{"line":2820,"column":59,"index":120072},"line":2820,"code":"    it('should invalidate when removing an optimizer plugin', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.js': ['parcel-optimizer-test']\n            }\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'optimized');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.js': []\n            }\n          }));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.notEqual(res, 'optimized');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when an optimizer is updated","suites":["cache","packaging"],"updatePoint":{"line":2844,"column":54,"index":120988},"line":2844,"code":"    it('should invalidate when an optimizer is updated', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.js': ['parcel-optimizer-test']\n            }\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'optimized');\n          let optimizer = path.join(inputDir, 'node_modules', 'parcel-optimizer-test', 'index.js');\n          await overlayFS.writeFile(optimizer, (await overlayFS.readFile(optimizer, 'utf8')).replace('optimized', 'updated'));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when adding optimizer config","suites":["cache","packaging"],"updatePoint":{"line":2864,"column":54,"index":121912},"line":2864,"code":"    it('should invalidate when adding optimizer config', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.js': ['parcel-optimizer-test']\n            }\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'optimized');\n          await overlayFS.writeFile(path.join(inputDir, '.optimizerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'test');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when updating packager config","suites":["cache","packaging"],"updatePoint":{"line":2885,"column":55,"index":122738},"line":2885,"code":"    it('should invalidate when updating packager config', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.js': ['parcel-optimizer-test']\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.optimizerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.optimizerrc'), JSON.stringify({\n            value: 'updated'\n          }));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when removing packager config","suites":["cache","packaging"],"updatePoint":{"line":2909,"column":55,"index":123696},"line":2909,"code":"    it('should invalidate when removing packager config', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.js': ['parcel-optimizer-test']\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.optimizerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        },\n        async update(b) {\n          let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert.equal(res, 'test');\n          await overlayFS.unlink(path.join(inputDir, '.optimizerrc'));\n        }\n      });\n      let res = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.equal(res, 'optimized');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when an asset content changes","suites":["cache","packaging"],"updatePoint":{"line":2931,"column":55,"index":124593},"line":2931,"code":"    it('should invalidate when an asset content changes', async function () {\n      let b = await testCache({\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 4);\n          await overlayFS.writeFile(path.join(inputDir, 'node_modules/foo/foo.js'), 'module.exports = 3');\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 6);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when an inline bundle changes","suites":["cache","packaging"],"updatePoint":{"line":2942,"column":55,"index":125012},"line":2942,"code":"    it('should invalidate when an inline bundle changes', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./entries/a.js\");');\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert(res.includes(`let a = \"a\"`));\n          await overlayFS.writeFile(path.join(inputDir, 'src/entries/a.js'), `export let a = \"b\";`);\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert(res.includes(`let a = \"b\"`));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when switching to a different packager for an inline bundle","suites":["cache","packaging"],"updatePoint":{"line":2956,"column":85,"index":125653},"line":2956,"code":"    it('should invalidate when switching to a different packager for an inline bundle', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.notEqual(res, 'packaged');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.txt': 'parcel-packager-test'\n            }\n          }));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'packaged');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a packager for an inline bundle is updated","suites":["cache","packaging"],"updatePoint":{"line":2976,"column":73,"index":126484},"line":2976,"code":"    it('should invalidate when a packager for an inline bundle is updated', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.txt': 'parcel-packager-test'\n            }\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 'packaged');\n          let packager = path.join(inputDir, 'node_modules', 'parcel-packager-test', 'index.js');\n          await overlayFS.writeFile(packager, (await overlayFS.readFile(packager, 'utf8')).replace('packaged', 'updated'));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when adding packager config for an inline bundle","suites":["cache","packaging"],"updatePoint":{"line":2998,"column":74,"index":127534},"line":2998,"code":"    it('should invalidate when adding packager config for an inline bundle', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.txt': 'parcel-packager-test'\n            }\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 'packaged');\n          await overlayFS.writeFile(path.join(inputDir, '.packagerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'test');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when updating packager config for an inline bundle","suites":["cache","packaging"],"updatePoint":{"line":3021,"column":76,"index":128491},"line":3021,"code":"    it('should invalidate when updating packager config for an inline bundle', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.txt': 'parcel-packager-test'\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.packagerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.packagerrc'), JSON.stringify({\n            value: 'updated'\n          }));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when removing packager config for an inline bundle","suites":["cache","packaging"],"updatePoint":{"line":3047,"column":76,"index":129580},"line":3047,"code":"    it('should invalidate when removing packager config for an inline bundle', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            packagers: {\n              '*.txt': 'parcel-packager-test'\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.packagerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 'test');\n          await overlayFS.unlink(path.join(inputDir, '.packagerrc'));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'packaged');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when adding an optimizer for an inline bundle","suites":["cache","packaging"],"updatePoint":{"line":3071,"column":71,"index":130602},"line":3071,"code":"    it('should invalidate when adding an optimizer for an inline bundle', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.notEqual(res, 'packaged');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.txt': ['parcel-optimizer-test']\n            }\n          }));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'optimized');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when an optimizer for an inline bundle is updated","suites":["cache","packaging"],"updatePoint":{"line":3091,"column":75,"index":131440},"line":3091,"code":"    it('should invalidate when an optimizer for an inline bundle is updated', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.txt': ['parcel-optimizer-test']\n            }\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 'optimized');\n          let optimizer = path.join(inputDir, 'node_modules', 'parcel-optimizer-test', 'index.js');\n          await overlayFS.writeFile(optimizer, (await overlayFS.readFile(optimizer, 'utf8')).replace('optimized', 'updated'));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when adding optimizer config for an inline bundle","suites":["cache","packaging"],"updatePoint":{"line":3113,"column":75,"index":132501},"line":3113,"code":"    it('should invalidate when adding optimizer config for an inline bundle', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.txt': ['parcel-optimizer-test']\n            }\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 'optimized');\n          await overlayFS.writeFile(path.join(inputDir, '.optimizerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'test');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when updating optimizer config for an inline bundle","suites":["cache","packaging"],"updatePoint":{"line":3136,"column":77,"index":133465},"line":3136,"code":"    it('should invalidate when updating optimizer config for an inline bundle', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.txt': ['parcel-optimizer-test']\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.optimizerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.optimizerrc'), JSON.stringify({\n            value: 'updated'\n          }));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'updated');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when removing optimizer config for an inline bundle","suites":["cache","packaging"],"updatePoint":{"line":3162,"column":77,"index":134561},"line":3162,"code":"    it('should invalidate when removing optimizer config for an inline bundle', async function () {\n      let b = await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, 'src/index.js'), 'module.exports = require(\"bundle-text:./test.txt\");');\n          await overlayFS.writeFile(path.join(inputDir, 'src/test.txt'), 'test');\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            optimizers: {\n              '*.txt': ['parcel-optimizer-test']\n            }\n          }));\n          await overlayFS.writeFile(path.join(inputDir, '.optimizerrc'), JSON.stringify({\n            value: 'test'\n          }));\n        },\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 'test');\n          await overlayFS.unlink(path.join(inputDir, '.optimizerrc'));\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 'optimized');\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when deleting a dist file","suites":["cache","packaging"],"updatePoint":{"line":3186,"column":51,"index":135570},"line":3186,"code":"    it('should invalidate when deleting a dist file', async function () {\n      let b = await testCache({\n        async update(b) {\n          assert(await overlayFS.exists(path.join(distDir, 'index.js')));\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 4);\n          await overlayFS.unlink(path.join(distDir, 'index.js'));\n        }\n      });\n      assert(await overlayFS.exists(path.join(distDir, 'index.js')));\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when deleting a source map","suites":["cache","packaging"],"updatePoint":{"line":3199,"column":52,"index":136089},"line":3199,"code":"    it('should invalidate when deleting a source map', async function () {\n      await testCache({\n        async update() {\n          assert(await overlayFS.exists(path.join(distDir, 'index.js.map')));\n          await overlayFS.unlink(path.join(distDir, 'index.js.map'));\n        }\n      });\n      assert(await overlayFS.exists(path.join(distDir, 'index.js.map')));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when the dist directory","suites":["cache","packaging"],"updatePoint":{"line":3208,"column":49,"index":136460},"line":3208,"code":"    it('should invalidate when the dist directory', async function () {\n      await testCache({\n        async update() {\n          assert(await overlayFS.exists(path.join(distDir, 'index.js')));\n          assert(await overlayFS.exists(path.join(distDir, 'index.js.map')));\n          await overlayFS.rimraf(distDir);\n        }\n      });\n      assert(await overlayFS.exists(path.join(distDir, 'index.js')));\n      assert(await overlayFS.exists(path.join(distDir, 'index.js.map')));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should hit the cache when there are no changes","suites":["cache","packaging"],"updatePoint":{"line":3219,"column":54,"index":136953},"line":3219,"code":"    it('should hit the cache when there are no changes', async function () {\n      let b = await testCache({\n        async update(b) {\n          let res = await run(b.bundleGraph);\n          assert.equal(res, 4);\n        }\n      });\n      let res = await run(b.bundleGraph);\n      assert.equal(res, 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when a terser config is modified","suites":["cache","packaging"],"updatePoint":{"line":3229,"column":58,"index":137268},"line":3229,"code":"    it('should invalidate when a terser config is modified', async function () {\n      let b = await testCache({\n        mode: 'production',\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.terserrc'), JSON.stringify({\n            mangle: false\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('$parcel$interopDefault'));\n          await overlayFS.writeFile(path.join(inputDir, '.terserrc'), JSON.stringify({\n            mangle: true\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('$parcel$interopDefault'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when an htmlnano config is modified","suites":["cache","packaging"],"updatePoint":{"line":3248,"column":61,"index":138073},"line":3248,"code":"    it('should invalidate when an htmlnano config is modified', async function () {\n      let b = await testCache({\n        mode: 'production',\n        entries: ['src/index.html'],\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.htmlnanorc.json'), JSON.stringify({\n            removeAttributeQuotes: true\n          }));\n        },\n        async update(b) {\n          let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n          assert(contents.includes('type=module'));\n          await overlayFS.writeFile(path.join(inputDir, '.htmlnanorc.json'), JSON.stringify({\n            removeAttributeQuotes: false\n          }));\n        }\n      });\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('type=\"module\"'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invaldate when adding a compressor plugin","suites":["cache","compression"],"updatePoint":{"line":3270,"column":56,"index":138979},"line":3270,"code":"    it('should invaldate when adding a compressor plugin', async function () {\n      await testCache({\n        async update() {\n          let files = await outputFS.readdir(distDir);\n          assert.deepEqual(files.sort(), ['index.js', 'index.js.map']);\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            compressors: {\n              '*.js': ['...', '@parcel/compressor-gzip']\n            }\n          }));\n        },\n        mode: 'production'\n      });\n      let files = await outputFS.readdir(distDir);\n      assert.deepEqual(files.sort(), ['index.js', 'index.js.gz', 'index.js.map']);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate when updating a compressor plugin","suites":["cache","compression"],"updatePoint":{"line":3287,"column":59,"index":139674},"line":3287,"code":"    it('should invalidate when updating a compressor plugin', async function () {\n      await testCache({\n        async setup() {\n          await overlayFS.writeFile(path.join(inputDir, '.parcelrc'), JSON.stringify({\n            extends: '@parcel/config-default',\n            compressors: {\n              '*.js': ['...', 'parcel-compressor-test']\n            }\n          }));\n        },\n        async update() {\n          let files = await outputFS.readdir(distDir);\n          assert.deepEqual(files.sort(), ['index.js', 'index.js.abc', 'index.js.map']);\n          let compressor = path.join(inputDir, 'node_modules', 'parcel-compressor-test', 'index.js');\n          await overlayFS.writeFile(compressor, (await overlayFS.readFile(compressor, 'utf8')).replace('abc', 'def'));\n        }\n      });\n      let files = await outputFS.readdir(distDir);\n      assert.deepEqual(files.sort(), ['index.js', 'index.js.abc', 'index.js.def', 'index.js.map']);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding sideEffects config","suites":["cache","scope hoisting"],"updatePoint":{"line":3309,"column":48,"index":140667},"line":3309,"code":"    it('should support adding sideEffects config', function () {});","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating sideEffects config","suites":["cache","scope hoisting"],"updatePoint":{"line":3310,"column":50,"index":140737},"line":3310,"code":"    it('should support updating sideEffects config', function () {});","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support removing sideEffects config","suites":["cache","scope hoisting"],"updatePoint":{"line":3311,"column":50,"index":140807},"line":3311,"code":"    it('should support removing sideEffects config', function () {});","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should wrap modules when they become conditional","suites":["cache","scope hoisting"],"updatePoint":{"line":3312,"column":56,"index":140883},"line":3312,"code":"    it('should wrap modules when they become conditional', async function () {\n      let b = await testCache({\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        },\n        entries: ['a.js'],\n        async setup() {\n          let contents = await overlayFS.readFile(path.join(inputDir, 'a.js'), 'utf8');\n          await overlayFS.writeFile(path.join(inputDir, 'a.js'), contents.replace(/if \\(b\\) \\{((?:.|\\n)+)\\}/, '$1'));\n        },\n        async update(b) {\n          let out = [];\n          await run(b.bundleGraph, {\n            b: false,\n            output(o) {\n              out.push(o);\n            }\n          });\n          assert.deepEqual(out, ['a', 'b', 'c', 'd']);\n          let contents = await overlayFS.readFile(path.join(__dirname, 'integration/scope-hoisting/commonjs/require-conditional/a.js'), 'utf8');\n          await overlayFS.writeFile(path.join(inputDir, 'a.js'), contents);\n        }\n      }, 'scope-hoisting/commonjs/require-conditional');\n      let out = [];\n      await run(b.bundleGraph, {\n        b: false,\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, ['a', 'd']);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support updating files added by runtimes","suites":["cache","runtime"],"updatePoint":{"line":3346,"column":55,"index":142087},"line":3346,"code":"    it('should support updating files added by runtimes', async function () {\n      let b = await testCache(async b => {\n        let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n        assert(contents.includes('INITIAL CODE'));\n        await overlayFS.writeFile(path.join(inputDir, 'dynamic-runtime.js'), \"module.exports = 'UPDATED CODE'\");\n      }, 'runtime-update');\n      let contents = await overlayFS.readFile(b.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('UPDATED CODE'));\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should create additional assets if multiple query parameter combinations are used","suites":["cache","Query Parameters"],"updatePoint":{"line":3357,"column":89,"index":142728},"line":3357,"code":"    it('Should create additional assets if multiple query parameter combinations are used', async function () {\n      let b = await testCache({\n        entries: ['reformat.html'],\n        update: async b => {\n          let bundles = b.bundleGraph.getBundles();\n          let contents = await overlayFS.readFile(bundles[0].filePath, 'utf8');\n          assert(contents.includes('.webp\" alt=\"test image\">'));\n          assert.equal(bundles.length, 2);\n          await overlayFS.writeFile(path.join(inputDir, 'reformat.html'), `<picture>\n              <source src=\"url:./image.jpg?as=webp&width=400\" type=\"image/webp\" />\n              <source src=\"url:./image.jpg?as=jpg&width=400\" type=\"image/jpeg\" />\n              <img src=\"url:./image.jpg?as=jpg&width=800\" alt=\"test image\" />\n            </picture>`);\n        }\n      }, 'image');\n      let bundles = b.bundleGraph.getBundles();\n      let contents = await overlayFS.readFile(bundles[0].filePath, 'utf8');\n      assert(contents.includes('.webp\" type=\"image/webp\">'));\n      assert(contents.includes('.jpeg\" type=\"image/jpeg\">'));\n      assert(contents.includes('.jpeg\" alt=\"test image\">'));\n      assert.equal(bundles.length, 4);\n    });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly read additional child assets from cache","suites":["cache","Query Parameters"],"updatePoint":{"line":3380,"column":62,"index":143895},"line":3380,"code":"  it('should correctly read additional child assets from cache', async function () {\n    await ncp(path.join(__dirname, '/integration/postcss-modules-cjs'), path.join(inputDir));\n    let entries = 'index.js';\n    let b = await runBundle(entries, {\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    let result1 = (await run(b.bundleGraph))();\n    b = await runBundle(entries, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    let result2 = (await run(b.bundleGraph))();\n    b = await runBundle(entries, {\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    let result3 = (await run(b.bundleGraph))();\n    assert(typeof result1 === 'string' && result1.includes('foo'));\n    assert.strictEqual(result1, result2);\n    assert.strictEqual(result1, result3);\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly read additional child assets from cache 2","suites":["cache","Query Parameters"],"updatePoint":{"line":3405,"column":64,"index":144744},"line":3405,"code":"  it('should correctly read additional child assets from cache 2', async function () {\n    await ncp(path.join(__dirname, '/integration/postcss-modules-cjs'), path.join(inputDir));\n    let entries = 'index.js';\n    await overlayFS.writeFile(path.join(inputDir, 'foo.module.css'), `.foo {\n  color: red;\n}`);\n    let b = await runBundle(entries);\n    let result1 = (await run(b.bundleGraph))();\n    await overlayFS.writeFile(path.join(inputDir, 'foo.module.css'), `.foo {\n  color: blue;\n}`);\n    b = await runBundle(entries);\n    let result2 = (await run(b.bundleGraph))();\n    await overlayFS.writeFile(path.join(inputDir, 'foo.module.css'), `.foo {\n  color: red;\n}`);\n    b = await runBundle(entries);\n    let result3 = (await run(b.bundleGraph))();\n    assert(typeof result1 === 'string' && result1.includes('foo'));\n    assert.strictEqual(result1, result2);\n    assert.strictEqual(result1, result3);\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly reuse intermediate pipeline results when transforming","suites":["cache","Query Parameters"],"updatePoint":{"line":3427,"column":76,"index":145664},"line":3427,"code":"  it('should correctly reuse intermediate pipeline results when transforming', async function () {\n    await ncp(path.join(__dirname, '/integration/json'), path.join(inputDir));\n    let entry = path.join(inputDir, 'index.js');\n    let original = await overlayFS.readFile(entry, 'utf8');\n    let b = await runBundle(entry);\n    let result1 = (await run(b.bundleGraph))();\n    await overlayFS.writeFile(entry, 'module.exports = function(){ return 10; }');\n    b = await runBundle(entry);\n    let result2 = (await run(b.bundleGraph))();\n    await overlayFS.writeFile(entry, original);\n    b = await runBundle(entry);\n    let result3 = (await run(b.bundleGraph))();\n    assert.strictEqual(result1, 3);\n    assert.strictEqual(result2, 10);\n    assert.strictEqual(result3, 3);\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"properly watches included files even after resaving them without changes","suites":["cache","Query Parameters"],"updatePoint":{"line":3443,"column":78,"index":146443},"line":3443,"code":"  it('properly watches included files even after resaving them without changes', async function () {\n    this.timeout(15000);\n    let subscription;\n    let fixture = path.join(__dirname, '/integration/included-file');\n    try {\n      let b = bundler(path.join(fixture, 'index.txt'), {\n        inputFS: overlayFS,\n        shouldDisableCache: false\n      });\n      await overlayFS.mkdirp(fixture);\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'a');\n      subscription = await b.watch();\n      let event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output1 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output1, 'a');\n\n      // Change included file\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'b');\n      event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output2 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output2, 'b');\n\n      // Rewrite included file without change\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'b');\n      event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output3 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output3, 'b');\n\n      // Change included file\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'c');\n      event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output4 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output4, 'c');\n    } finally {\n      if (subscription) {\n        await subscription.unsubscribe();\n        subscription = null;\n      }\n    }\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"properly handles included files even after when changing back to a cached state","suites":["cache","Query Parameters"],"updatePoint":{"line":3487,"column":85,"index":148318},"line":3487,"code":"  it('properly handles included files even after when changing back to a cached state', async function () {\n    this.timeout(15000);\n    let subscription;\n    let fixture = path.join(__dirname, '/integration/included-file');\n    try {\n      let b = bundler(path.join(fixture, 'index.txt'), {\n        inputFS: overlayFS,\n        shouldDisableCache: false\n      });\n      await overlayFS.mkdirp(fixture);\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'a');\n      subscription = await b.watch();\n      let event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output1 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output1, 'a');\n\n      // Change included file\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'b');\n      event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output2 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output2, 'b');\n\n      // Change included file back\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'a');\n      event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output3 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output3, 'a');\n    } finally {\n      if (subscription) {\n        await subscription.unsubscribe();\n        subscription = null;\n      }\n    }\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"properly watches included files after a transformer error","suites":["cache","Query Parameters"],"updatePoint":{"line":3524,"column":63,"index":149832},"line":3524,"code":"  it('properly watches included files after a transformer error', async function () {\n    this.timeout(15000);\n    let subscription;\n    let fixture = path.join(__dirname, '/integration/included-file');\n    try {\n      let b = bundler(path.join(fixture, 'index.txt'), {\n        inputFS: overlayFS,\n        shouldDisableCache: false\n      });\n      await overlayFS.mkdirp(fixture);\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'a');\n      subscription = await b.watch();\n      let event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output1 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output1, 'a');\n\n      // Change included file\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'ERROR');\n      event = await getNextBuild(b);\n      invariant(event.type === 'buildFailure');\n      assert.strictEqual(event.diagnostics[0].message, 'Custom error');\n\n      // Clear transformer error\n      await overlayFS.writeFile(path.join(fixture, 'included.txt'), 'b');\n      event = await getNextBuild(b);\n      invariant(event.type === 'buildSuccess');\n      let output3 = await overlayFS.readFile(event.bundleGraph.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(output3, 'b');\n    } finally {\n      if (subscription) {\n        await subscription.unsubscribe();\n        subscription = null;\n      }\n    }\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support moving the project root","suites":["cache","Query Parameters"],"updatePoint":{"line":3560,"column":44,"index":151263},"line":3560,"code":"  it('should support moving the project root', async function () {\n    // This test relies on the real filesystem because the memory fs doesn't support renames.\n    // But renameSync is broken on windows in CI with EPERM errors. Just skip this test for now.\n    if (process.platform === 'win32') {\n      return;\n    }\n    let b = await testCache({\n      inputFS,\n      outputFS: inputFS,\n      async setup() {\n        await inputFS.mkdirp(inputDir);\n        await inputFS.ncp(path.join(__dirname, '/integration/cache'), inputDir);\n      },\n      update: async b => {\n        assert.equal(await run(b.bundleGraph), 4);\n        await inputFS.writeFile(path.join(inputDir, 'src/nested/test.js'), 'export default 4');\n        fs.renameSync(inputDir, inputDir += '_2');\n        await sleep(100);\n      }\n    });\n    assert.equal(await run(b.bundleGraph), 6);\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports multiple empty JS assets","suites":["cache","Query Parameters"],"updatePoint":{"line":3582,"column":39,"index":152118},"line":3582,"code":"  it('supports multiple empty JS assets', async function () {\n    // Try to store multiple empty assets using LMDB\n    let build = await runBundle(path.join(__dirname, 'integration/multiple-empty-js-assets/index.js'), {\n      inputFS,\n      outputFS: inputFS\n    });\n    let a = nullthrows(findAsset(build.bundleGraph, 'a.js'));\n    let b = nullthrows(findAsset(build.bundleGraph, 'a.js'));\n    assert.strictEqual((await a.getBuffer()).length, 0);\n    assert.strictEqual((await b.getBuffer()).length, 0);\n    let res = await run(build.bundleGraph);\n    assert.deepEqual(res, {\n      default: 'foo'\n    });\n  });","file":"cache.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not compress output with gzip and brotli in development","suites":["compressors"],"updatePoint":{"line":6,"column":68,"index":250},"line":6,"code":"  it('should not compress output with gzip and brotli in development', async function () {\n    await bundle(path.join(__dirname, 'integration/compressors/index.js'));\n    let output = await outputFS.readdir(distDir);\n    assert.deepEqual(output.sort(), ['index.js', 'index.js.map']);\n  });","file":"compressors.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compress output with gzip and brotli","suites":["compressors"],"updatePoint":{"line":11,"column":49,"index":521},"line":11,"code":"  it('should compress output with gzip and brotli', async function () {\n    await bundle(path.join(__dirname, 'integration/compressors/index.js'), {\n      mode: 'production'\n    });\n    let output = await outputFS.readdir(distDir);\n    assert.deepEqual(output.sort(), ['index.js', 'index.js.br', 'index.js.gz', 'index.js.map', 'index.js.map.br', 'index.js.map.gz']);\n    let raw = await outputFS.readFile(path.join(distDir, 'index.js'));\n    let gz = await outputFS.readFile(path.join(distDir, 'index.js.gz'));\n    let br = await outputFS.readFile(path.join(distDir, 'index.js.br'));\n    assert(zlib.gunzipSync(gz).equals(raw));\n    assert(zlib.brotliDecompressSync(br).equals(raw));\n  });","file":"compressors.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should be able to disable raw output","suites":["compressors"],"updatePoint":{"line":23,"column":42,"index":1204},"line":23,"code":"  it('should be able to disable raw output', async function () {\n    await bundle(path.join(__dirname, 'integration/compressors-disable-default/index.js'), {\n      mode: 'production'\n    });\n    let output = await outputFS.readdir(distDir);\n    assert.deepEqual(output.sort(), ['index.js.br', 'index.js.map.br']);\n  });","file":"compressors.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should merge incomplete config packages","suites":["config merging"],"updatePoint":{"line":5,"column":45,"index":201},"line":5,"code":"  it('should merge incomplete config packages', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/config-merging/index.js'));\n    let content = (await outputFS.readFile(path.join(__dirname, '/integration/config-merging/dist/index.js'))).toString();\n    assert(content.includes('runtime injected'));\n    assert.equal((await run(b)).default, 'Hello world!');\n  });","file":"config-merging.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update content hash when content changes","suites":["content hashing"],"updatePoint":{"line":18,"column":53,"index":532},"line":18,"code":"  it('should update content hash when content changes', async function () {\n    await ncp(path.join(__dirname, '/integration/html-css'), path.join(__dirname, '/input'));\n    let bundleHtml = () => bundle(path.join(__dirname, '/input/index.html'));\n    await bundleHtml();\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    let filename = html.match(/<link rel=\"stylesheet\" href=\"[/\\\\]{1}(index\\.[a-f0-9]+\\.css)\">/)[1];\n    assert(await outputFS.exists(path.join(distDir, filename)));\n    await outputFS.writeFile(path.join(__dirname, '/input/index.css'), 'body { background: green }');\n    await bundleHtml();\n    html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    let newFilename = html.match(/<link rel=\"stylesheet\" href=\"[/\\\\]{1}(index\\.[a-f0-9]+\\.css)\">/)[1];\n    assert(await outputFS.exists(path.join(distDir, newFilename)));\n    assert.notEqual(filename, newFilename);\n  });","file":"contentHashing.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update content hash when raw asset changes","suites":["content hashing"],"updatePoint":{"line":32,"column":55,"index":1478},"line":32,"code":"  it('should update content hash when raw asset changes', async function () {\n    await ncp(path.join(__dirname, '/integration/import-raw'), path.join(__dirname, '/input'));\n    let bundleJs = () => bundle(path.join(__dirname, '/input/index.js'));\n    await bundleJs();\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    let filename = js.match(/(test\\.[0-9a-f]+\\.txt)/)[1];\n    assert(await outputFS.exists(path.join(distDir, filename)));\n    await outputFS.writeFile(path.join(__dirname, '/input/test.txt'), 'hello world');\n    await bundleJs();\n    js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    let newFilename = js.match(/(test\\.[0-9a-f]+\\.txt)/)[1];\n    assert(await outputFS.exists(path.join(distDir, newFilename)));\n    assert.notEqual(filename, newFilename);\n  });","file":"contentHashing.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should consider bundles with identical contents coming from different filepaths unique","suites":["content hashing"],"updatePoint":{"line":46,"column":92,"index":2347},"line":46,"code":"  it('should consider bundles with identical contents coming from different filepaths unique', async () => {\n    await _bundle(path.join(__dirname, 'integration/same-contents-different-filepaths/index.js'));\n  });","file":"contentHashing.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate the same hash for the same distDir inside separate projects","suites":["content hashing"],"updatePoint":{"line":49,"column":81,"index":2550},"line":49,"code":"  it('should generate the same hash for the same distDir inside separate projects', async () => {\n    let a = await _bundle(path.join(__dirname, 'integration/hash-distDir/a/index.html'), {\n      sourceMaps: true\n    });\n    let b = await _bundle(path.join(__dirname, 'integration/hash-distDir/b/index.html'), {\n      sourceMaps: true\n    });\n    let aBundles = a.getBundles();\n    let bBundles = b.getBundles();\n    assert.equal(aBundles.length, 2);\n    assert.equal(bBundles.length, 2);\n    let aJS = aBundles.find(bundle => bundle.type === 'js');\n    let bJS = bBundles.find(bundle => bundle.type === 'js');\n    assert(/index\\.[a-f0-9]*\\.js/.test(path.basename(aJS.filePath)));\n    assert.equal(aJS.name, bJS.name);\n  });","file":"contentHashing.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming css modules (require)","suites":["css modules"],"updatePoint":{"line":6,"column":55,"index":268},"line":6,"code":"  it('should support transforming css modules (require)', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-modules-cjs/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'foo.module.css']\n    }, {\n      name: 'index.css',\n      assets: ['index.css', 'foo.module.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let value = output();\n    assert(/[_0-9a-zA-Z]+_foo/.test(value));\n    let cssClass = value.match(/([_0-9a-zA-Z]+_foo)/)[1];\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes(`.${cssClass}`));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming css modules (import default)","suites":["css modules"],"updatePoint":{"line":23,"column":62,"index":955},"line":23,"code":"  it('should support transforming css modules (import default)', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-modules-import-default/index.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'style.module.css']\n    }, {\n      name: 'index.css',\n      assets: ['style.module.css']\n    }]);\n    let output = await run(b);\n    assert(/[_0-9a-zA-Z]+_b-2/.test(output));\n    let css = await outputFS.readFile(b.getBundles().find(b => b.type === 'css').filePath, 'utf8');\n    let includedRules = new Set();\n    postcss.parse(css).walkRules(rule => {\n      includedRules.add(rule.selector);\n    });\n    assert(includedRules.has('.page'));\n    assert(includedRules.has(`.${output}`));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should tree shake unused css modules classes with a namespace import","suites":["css modules"],"updatePoint":{"line":44,"column":74,"index":1751},"line":44,"code":"  it('should tree shake unused css modules classes with a namespace import', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-modules-import-namespace/index.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'style.module.css']\n    }, {\n      name: 'index.css',\n      assets: ['global.css', 'style.module.css']\n    }]);\n    let js = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n    assert(!js.includes('unused'));\n    let output = await run(b);\n    assert(/[_0-9a-zA-Z]+_b-2/.test(output));\n    let css = await outputFS.readFile(b.getBundles().find(b => b.type === 'css').filePath, 'utf8');\n    let includedRules = new Set();\n    postcss.parse(css).walkRules(rule => {\n      includedRules.add(rule.selector);\n    });\n    assert.deepStrictEqual(includedRules, new Set(['body', `.${output}`, '.page']));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce correct css without symbol propagation for css modules classes with a namespace import","suites":["css modules"],"updatePoint":{"line":66,"column":107,"index":2730},"line":66,"code":"  it('should produce correct css without symbol propagation for css modules classes with a namespace import', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-modules-import-namespace/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'style.module.css']\n    }, {\n      name: 'index.css',\n      assets: ['global.css', 'style.module.css']\n    }]);\n    let {\n      output\n    } = await run(b, null, {\n      require: false\n    });\n    assert(/[_0-9a-zA-Z]+_b-2/.test(output));\n    let css = await outputFS.readFile(b.getBundles().find(b => b.type === 'css').filePath, 'utf8');\n    let includedRules = new Set();\n    postcss.parse(css).walkRules(rule => {\n      includedRules.add(rule.selector);\n    });\n    assert(includedRules.has('body'));\n    assert(includedRules.has(`.${output}`));\n    assert(includedRules.has('.page'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing css modules with a non-static namespace import","suites":["css modules"],"updatePoint":{"line":95,"column":77,"index":3705},"line":95,"code":"  it('should support importing css modules with a non-static namespace import', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-modules-import-namespace-whole/index.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'style.module.css']\n    }, {\n      name: 'index.css',\n      assets: ['global.css', 'style.module.css']\n    }]);\n    let js = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n    assert(js.includes('unused'));\n    let output = await run(b);\n    assert(/[_0-9a-zA-Z]+_b-2/.test(output['b-2']));\n    assert(/[_0-9a-zA-Z]+_unused/.test(output['unused']));\n    let css = await outputFS.readFile(b.getBundles().find(b => b.type === 'css').filePath, 'utf8');\n    let includedRules = new Set();\n    postcss.parse(css).walkRules(rule => {\n      includedRules.add(rule.selector);\n    });\n    assert.deepStrictEqual(includedRules, new Set(['body', `.${output['b-2']}`, `.${output['unused']}`, '.page']));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support css modules composes imports","suites":["css modules"],"updatePoint":{"line":118,"column":49,"index":4728},"line":118,"code":"  it('should support css modules composes imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-composes/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'composes-1.module.css', 'composes-2.module.css', 'mixins.module.css']\n    }, {\n      name: 'index.css',\n      assets: ['composes-1.module.css', 'composes-2.module.css', 'mixins.module.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let value = output();\n    const composes1Classes = value.composes1.split(' ');\n    const composes2Classes = value.composes2.split(' ');\n    assert(composes1Classes[0].endsWith('_composes1'));\n    assert(composes1Classes[1].endsWith('_test'));\n    assert(composes2Classes[0].endsWith('_composes2'));\n    assert(composes2Classes[1].endsWith('_test'));\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    let cssClass1 = value.composes1.match(/([_0-9a-zA-Z]+_composes1)/)[1];\n    assert(css.includes(`.${cssClass1}`));\n    let cssClass2 = value.composes2.match(/([_0-9a-zA-Z]+_composes2)/)[1];\n    assert(css.includes(`.${cssClass2}`));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not include css twice for composes imports","suites":["css modules"],"updatePoint":{"line":142,"column":55,"index":5917},"line":142,"code":"  it('should not include css twice for composes imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-composes/index.js'));\n    await run(b);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert.equal(css.indexOf('height: 100px;'), css.lastIndexOf('height: 100px;'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support composes imports for sass","suites":["css modules"],"updatePoint":{"line":148,"column":46,"index":6258},"line":148,"code":"  it('should support composes imports for sass', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-composes/index2.js'));\n    assertBundles(b, [{\n      name: 'index2.js',\n      assets: ['index2.js', 'composes-3.module.css', 'mixins.module.scss']\n    }, {\n      name: 'index2.css',\n      assets: ['composes-3.module.css', 'mixins.module.scss']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let value = output();\n    const composes3Classes = value.composes3.split(' ');\n    assert(composes3Classes[0].endsWith('_composes3'));\n    assert(composes3Classes[1].endsWith('_test'));\n    let css = await outputFS.readFile(path.join(distDir, 'index2.css'), 'utf8');\n    assert(css.includes('height: 200px;'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support composes imports with custom path names","suites":["css modules"],"updatePoint":{"line":166,"column":60,"index":7053},"line":166,"code":"  it('should support composes imports with custom path names', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-composes/index3.js'));\n    assertBundles(b, [{\n      name: 'index3.js',\n      assets: ['index3.js', 'composes-4.module.css', 'mixins.module.css']\n    }, {\n      name: 'index3.css',\n      assets: ['composes-4.module.css', 'mixins.module.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let value = output();\n    const composes4Classes = value.composes4.split(' ');\n    assert(composes4Classes[0].endsWith('_composes4'));\n    assert(composes4Classes[1].endsWith('_test'));\n    let css = await outputFS.readFile(path.join(distDir, 'index3.css'), 'utf8');\n    assert(css.includes('height: 100px;'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support deep nested composes imports","suites":["css modules"],"updatePoint":{"line":184,"column":49,"index":7835},"line":184,"code":"  it('should support deep nested composes imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-composes/index4.js'));\n    assertBundles(b, [{\n      name: 'index4.js',\n      assets: ['index4.js', 'composes-5.module.css', 'mixins-intermediate.module.css', 'mixins.module.css']\n    }, {\n      name: 'index4.css',\n      assets: ['composes-5.module.css', 'mixins-intermediate.module.css', 'mixins.module.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let value = output();\n    const composes5Classes = value.composes5.split(' ');\n    assert(composes5Classes[0].endsWith('_composes5'));\n    assert(composes5Classes[1].endsWith('_intermediate'));\n    assert(composes5Classes[2].endsWith('_test'));\n    let css = await outputFS.readFile(path.join(distDir, 'index4.css'), 'utf8');\n    assert(css.includes('height: 100px;'));\n    assert(css.includes('height: 300px;'));\n    assert(css.indexOf('_test') < css.indexOf('_intermediate'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support composes imports for multiple selectors","suites":["css modules"],"updatePoint":{"line":205,"column":60,"index":8864},"line":205,"code":"  it('should support composes imports for multiple selectors', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-composes/index5.js'));\n    assertBundles(b, [{\n      name: 'index5.js',\n      assets: ['index5.js', 'composes-6.module.css', 'mixins.module.css']\n    }, {\n      name: 'index5.css',\n      assets: ['composes-6.module.css', 'mixins.module.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let value = output();\n    const composes6Classes = value.composes6.split(' ');\n    assert(composes6Classes[0].endsWith('_composes6'));\n    assert(composes6Classes[1].endsWith('_test'));\n    assert(composes6Classes[2].endsWith('_test-2'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw an error when importing a missing class","suites":["css modules"],"updatePoint":{"line":222,"column":58,"index":9583},"line":222,"code":"  it('should throw an error when importing a missing class', async function () {\n    await assert.rejects(() => bundle(path.join(__dirname, '/integration/no-export-error-with-correct-filetype/src/App.jsx'), {\n      shouldDisableCache: true,\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/no-export-error-with-correct-filetype/src/App.jsx'),\n          language: 'js',\n          codeHighlights: [{\n            end: {\n              column: 45,\n              line: 7\n            },\n            start: {\n              column: 28,\n              line: 7\n            }\n          }]\n        }],\n        message: \"integration/no-export-error-with-correct-filetype/src/app.module.css does not export 'notExisting'\",\n        origin: '@parcel/core'\n      }]\n    });\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should fall back to postcss for legacy css modules","suites":["css modules"],"updatePoint":{"line":250,"column":56,"index":10498},"line":250,"code":"  it('should fall back to postcss for legacy css modules', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-modules-legacy/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'index.css',\n      assets: ['index.module.css']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('color: red'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should fall back to postcss for legacy css modules with :export","suites":["css modules"],"updatePoint":{"line":262,"column":69,"index":10981},"line":262,"code":"  it('should fall back to postcss for legacy css modules with :export', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-modules-legacy/b.js'));\n    assertBundles(b, [{\n      name: 'b.js',\n      assets: ['b.js', 'b.module.css']\n    }, {\n      name: 'b.css',\n      assets: ['b.module.css']\n    }]);\n    let res = await run(b);\n    assert.deepEqual(res, {\n      color: 'red'\n    });\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should optimize away unused @keyframes","suites":["css modules"],"updatePoint":{"line":276,"column":44,"index":11378},"line":276,"code":"  it('should optimize away unused @keyframes', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-modules-keyframes/index.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'index.css',\n      assets: ['index.module.css']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(/@keyframes _[_0-9a-zA-Z]+_test/.test(css));\n    assert(!css.includes('unused'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not double optimize css modules processed with postcss","suites":["css modules"],"updatePoint":{"line":291,"column":67,"index":11949},"line":291,"code":"  it('should not double optimize css modules processed with postcss', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-modules-optimize/index.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'index.css']\n    }, {\n      name: 'index.css',\n      assets: ['index.css']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('@keyframes test'));\n    assert(css.includes('@keyframes unused'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile css modules for multiple targets","suites":["css modules"],"updatePoint":{"line":306,"column":53,"index":12494},"line":306,"code":"  it('should compile css modules for multiple targets', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-modules-targets/index.html'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js', 'foo.module.css']\n    }, {\n      type: 'js',\n      assets: ['index.js', 'foo.module.css']\n    }, {\n      type: 'css',\n      assets: ['foo.module.css']\n    }]);\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle @import in css modules","suites":["css modules"],"updatePoint":{"line":325,"column":42,"index":13109},"line":325,"code":"  it('should handle @import in css modules', async function () {\n    let b = await bundle([path.join(__dirname, '/integration/css-modules-import/page1.html'), path.join(__dirname, '/integration/css-modules-import/page2.html')], {\n      mode: 'production'\n    });\n    let res = [];\n    await runBundle(b, b.getBundles().find(b => b.name === 'page1.html'), {\n      sideEffect: s => res.push(s)\n    });\n    assert.deepEqual(res, [['page1', '_1ZEqVW_a']]);\n    res = [];\n    await runBundle(b, b.getBundles().find(b => b.name === 'page2.html'), {\n      sideEffect: s => res.push(s)\n    });\n    assert.deepEqual(res, [['page2', '_4fY2uG_foo _1ZEqVW_foo j1UkRG_foo']]);\n    if (process.env.PARCEL_TEST_EXPERIMENTAL_BUNDLER) {\n      assertBundles(b, [{\n        name: 'page1.html',\n        assets: ['page1.html']\n      }, {\n        name: 'page2.html',\n        assets: ['page2.html']\n      }, {\n        type: 'js',\n        assets: ['page1.js', 'index.module.css', 'a.module.css', 'b.module.css']\n      }, {\n        type: 'js',\n        assets: ['page2.js', 'index.module.css', 'a.module.css', 'b.module.css']\n      }, {\n        type: 'css',\n        assets: ['a.module.css', 'b.module.css']\n      }, {\n        type: 'css',\n        assets: ['index.module.css']\n      }]);\n    } else {\n      assertBundles(b, [{\n        name: 'page1.html',\n        assets: ['page1.html']\n      }, {\n        name: 'page2.html',\n        assets: ['page2.html']\n      }, {\n        type: 'js',\n        assets: ['page1.js', 'index.module.css', 'a.module.css', 'b.module.css']\n      }, {\n        type: 'js',\n        assets: ['page2.js', 'index.module.css', 'a.module.css', 'b.module.css']\n      }, {\n        type: 'css',\n        assets: ['index.module.css', 'a.module.css', 'b.module.css']\n      }]);\n    }\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not process inline <style> elements as a CSS module","suites":["css modules"],"updatePoint":{"line":378,"column":64,"index":14907},"line":378,"code":"  it('should not process inline <style> elements as a CSS module', async function () {\n    await bundle(path.join(__dirname, '/integration/css-modules-style/index.html'));\n    let contents = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(contents.includes('.index {'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support global css modules via boolean config","suites":["css modules"],"updatePoint":{"line":383,"column":58,"index":15208},"line":383,"code":"  it('should support global css modules via boolean config', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-modules-global/a/index.js'), {\n      mode: 'production'\n    });\n    let res = await run(b);\n    assert.deepEqual(res, 'C-gzXq_foo');\n    let contents = await outputFS.readFile(b.getBundles().find(b => b.type === 'css').filePath, 'utf8');\n    assert(contents.includes('.C-gzXq_foo'));\n    assert(contents.includes('.x'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support global css modules via object config","suites":["css modules"],"updatePoint":{"line":393,"column":57,"index":15679},"line":393,"code":"  it('should support global css modules via object config', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-modules-global/b/index.js'), {\n      mode: 'production'\n    });\n    let res = await run(b);\n    assert.deepEqual(res, 'C-gzXq_foo');\n    let contents = await outputFS.readFile(b.getBundles().find(b => b.type === 'css').filePath, 'utf8');\n    assert(contents.includes('.C-gzXq_foo'));\n    assert(contents.includes('.x'));\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should optimize away unused variables when dashedIdents option is used","suites":["css modules"],"updatePoint":{"line":403,"column":76,"index":16169},"line":403,"code":"  it('should optimize away unused variables when dashedIdents option is used', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-modules-vars/index.js'), {\n      mode: 'production'\n    });\n    let contents = await outputFS.readFile(b.getBundles().find(b => b.type === 'css').filePath, 'utf8');\n    assert.equal(contents.split('\\n')[0], ':root{--wGsoEa_color:red;--wGsoEa_font:Helvetica;--wGsoEa_theme-sizes-1\\\\/12:2;--wGsoEa_from-js:purple}body{font:var(--wGsoEa_font)}._4fY2uG_foo{color:var(--wGsoEa_color);width:var(--wGsoEa_theme-sizes-1\\\\/12);height:var(--height)}');\n    let res = await run(b);\n    assert.deepEqual(res, ['_4fY2uG_foo', '--wGsoEa_from-js']);\n  });","file":"css-modules.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce two bundles when importing a CSS file","suites":["css"],"updatePoint":{"line":9,"column":58,"index":317},"line":9,"code":"  it('should produce two bundles when importing a CSS file', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/css/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'local.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.css', 'local.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bundle css dependencies in the correct, postorder traversal order","suites":["css"],"updatePoint":{"line":22,"column":78,"index":773},"line":22,"code":"  it('should bundle css dependencies in the correct, postorder traversal order', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/css-order/a.css'));\n\n    // Given a tree of css with imports:\n    //      A\n    //    /   \\\n    //   B     E\n    //  / \\\n    // C   D\n    //\n    // (A imports B (which imports C and D) and E)\n    //\n    // ...styles should be applied in the order C, D, B, E, A\n\n    assertBundles(b, [{\n      name: 'a.css',\n      assets: ['a.css', 'b.css', 'c.css', 'd.css', 'e.css']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'a.css'), 'utf8');\n    assert.ok(css.indexOf('.c {') < css.indexOf('.d {') && css.indexOf('.d {') < css.indexOf('.b {') && css.indexOf('.b {') < css.indexOf('.e {') && css.indexOf('.e {') < css.indexOf('.a {'));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support loading a CSS bundle along side dynamic imports","suites":["css"],"updatePoint":{"line":43,"column":68,"index":1569},"line":43,"code":"  it('should support loading a CSS bundle along side dynamic imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-css/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['bundle-url.js', 'cacheLoader.js', 'css-loader.js', 'index.js', 'js-loader.js']\n    }, {\n      name: /local\\.[0-9a-f]{8}\\.js/,\n      assets: ['local.js']\n    }, {\n      name: /local\\.[0-9a-f]{8}\\.css/,\n      assets: ['local.css']\n    }, {\n      name: 'index.css',\n      assets: ['index.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 3);\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing CSS from a CSS file","suites":["css"],"updatePoint":{"line":62,"column":50,"index":2204},"line":62,"code":"  it('should support importing CSS from a CSS file', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-import/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.css', 'other.css', 'local.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, '/index.css'), 'utf8');\n    assert(css.includes('.local'));\n    assert(css.includes('.other'));\n    assert(/@media print {\\s*.other/.test(css));\n    assert(css.includes('.index'));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support linking to assets with url() from CSS","suites":["css"],"updatePoint":{"line":80,"column":58,"index":2892},"line":80,"code":"  it('should support linking to assets with url() from CSS', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.css']\n    }, {\n      type: 'woff2',\n      assets: ['test.woff2']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(/url\\(\"test\\.[0-9a-f]+\\.woff2\"\\)/.test(css));\n    assert(css.includes('url(\"http://google.com\")'));\n    assert(css.includes('.index'));\n    assert(css.includes('url(\"data:image/gif;base64,quotes\")'));\n    assert(css.includes('.quotes'));\n    assert(css.includes('url(\"data:image/gif;base64,no-quote\")'));\n    assert(css.includes('.no-quote'));\n    assert(await outputFS.exists(path.join(distDir, css.match(/url\\(\"(test\\.[0-9a-f]+\\.woff2)\"\\)/)[1])));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support linking to assets with url() from CSS in production","suites":["css"],"updatePoint":{"line":105,"column":72,"index":3927},"line":105,"code":"  it('should support linking to assets with url() from CSS in production', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-url/index.js'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.css']\n    }, {\n      type: 'woff2',\n      assets: ['test.woff2']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(/url\\(test\\.[0-9a-f]+\\.woff2\\)/.test(css), 'woff ext found in css');\n    assert(css.includes('url(http://google.com)'), 'url() found');\n    assert(css.includes('.index'), '.index found');\n    assert(/url\\(\"?data:image\\/gif;base64,quotes\"?\\)/.test(css));\n    assert(css.includes('.quotes'));\n    assert(/url\\(\"?data:image\\/gif;base64,no-quote\"?\\)/.test(css));\n    assert(css.includes('.no-quote'));\n    assert(await outputFS.exists(path.join(distDir, css.match(/url\\((test\\.[0-9a-f]+\\.woff2)\\)/)[1])));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support linking to assets in parent folders with url() from CSS","suites":["css"],"updatePoint":{"line":134,"column":76,"index":5094},"line":134,"code":"  it('should support linking to assets in parent folders with url() from CSS', async function () {\n    let b = await bundle([path.join(__dirname, '/integration/css-url-relative/src/a/style1.css'), path.join(__dirname, '/integration/css-url-relative/src/b/style2.css')], {\n      defaultTargetOptions: {\n        shouldOptimize: true,\n        sourceMaps: false\n      }\n    });\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['style1.css']\n    }, {\n      type: 'css',\n      assets: ['style2.css']\n    }, {\n      type: 'png',\n      assets: ['foo.png']\n    }]);\n    let cssPath = path.join(distDir, 'a', 'style1.css');\n    let css = await outputFS.readFile(cssPath, 'utf8');\n    assert(css.includes('background-image'), 'includes `background-image`');\n    assert(/url\\([^)]*\\)/.test(css), 'includes url()');\n    assert(await outputFS.exists(path.resolve(path.dirname(cssPath), css.match(/url\\(([^)]*)\\)/)[1])), 'path specified in url() exists');\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle quote in CSS URL correctly","suites":["css"],"updatePoint":{"line":157,"column":46,"index":6020},"line":157,"code":"  it('should handle quote in CSS URL correctly', async function () {\n    await bundle(path.join(__dirname, '/integration/css-url-quote/index.css'));\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('url(\"data:image/svg+xml;utf8,with quote \\\\\" and escape \\\\\\\\\");'));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore url() with IE behavior specifiers","suites":["css"],"updatePoint":{"line":162,"column":53,"index":6354},"line":162,"code":"  it('should ignore url() with IE behavior specifiers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-url-behavior/index.css'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.css']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('url(\"#default#VML\")'));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw a diagnostic for relative url() dependencies in custom properties","suites":["css"],"updatePoint":{"line":171,"column":84,"index":6773},"line":171,"code":"  it('should throw a diagnostic for relative url() dependencies in custom properties', async function () {\n    let fixture = path.join(__dirname, 'integration/css-url-custom-property/index.css');\n    let code = await inputFS.readFileSync(fixture, 'utf8');\n    // $FlowFixMe\n    await assert.rejects(() => bundle(fixture, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: \"Ambiguous url('foo.png') in custom property. Relative paths are resolved from the location the var() is used, not where the custom property is defined. Use an absolute URL instead\",\n        origin: '@parcel/transformer-css',\n        name: 'SyntaxError',\n        stack: undefined,\n        codeFrames: [{\n          filePath: fixture,\n          code,\n          codeHighlights: [{\n            start: {\n              line: 2,\n              column: 11\n            },\n            end: {\n              line: 2,\n              column: 11\n            }\n          }]\n        }],\n        hints: ['Replace with: url(/integration/css-url-custom-property/foo.png)'],\n        documentationURL: 'https://parceljs.org/languages/css/#url()'\n      }]\n    });\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify CSS when minify is set","suites":["css"],"updatePoint":{"line":205,"column":42,"index":7941},"line":205,"code":"  it('should minify CSS when minify is set', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/cssnano/index.js'), {\n      defaultTargetOptions: {\n        shouldOptimize: true,\n        sourceMaps: false\n      }\n    });\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.local'));\n    assert(css.includes('.index'));\n    assert.equal(css.split('\\n').length, 1);\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a sourcemap when sourceMaps are used","suites":["css"],"updatePoint":{"line":220,"column":57,"index":8515},"line":220,"code":"  it('should produce a sourcemap when sourceMaps are used', async function () {\n    await bundle(path.join(__dirname, '/integration/cssnano/index.js'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.local'));\n    assert(css.includes('.index'));\n    let lines = css.trim().split('\\n');\n    assert.equal(lines.length, 2);\n    assert.equal(lines[1], '/*# sourceMappingURL=index.css.map */');\n    let map = JSON.parse(await outputFS.readFile(path.join(distDir, 'index.css.map'), 'utf8'));\n    assert.equal(map.file, 'index.css.map');\n    assert(map.sources.includes('integration/cssnano/local.css'));\n    assert(map.sources.includes('integration/cssnano/index.css'));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline data-urls for text-encoded files","suites":["css"],"updatePoint":{"line":237,"column":52,"index":9316},"line":237,"code":"  it('should inline data-urls for text-encoded files', async () => {\n    await bundle(path.join(__dirname, '/integration/data-url/text.css'), {\n      defaultTargetOptions: {\n        sourceMaps: false\n      }\n    });\n    let css = await outputFS.readFile(path.join(distDir, 'text.css'), 'utf8');\n    assert.equal(css.trim(), `.svg-img {\n  background-image: url(\"data:image/svg+xml,%3Csvg%20width%3D%22120%22%20height%3D%22120%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%20%20%3Cfilter%20id%3D%22blur-_.%21~%2a%22%3E%0A%20%20%20%20%3CfeGaussianBlur%20stdDeviation%3D%225%22%3E%3C%2FfeGaussianBlur%3E%0A%20%20%3C%2Ffilter%3E%0A%20%20%3Ccircle%20cx%3D%2260%22%20cy%3D%2260%22%20r%3D%2250%22%20fill%3D%22green%22%20filter%3D%22url%28%27%23blur-_.%21~%2a%27%29%22%3E%3C%2Fcircle%3E%0A%3C%2Fsvg%3E%0A\");\n}`);\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline data-urls for binary files","suites":["css"],"updatePoint":{"line":248,"column":46,"index":10136},"line":248,"code":"  it('should inline data-urls for binary files', async () => {\n    await bundle(path.join(__dirname, '/integration/data-url/binary.css'));\n    let css = await outputFS.readFile(path.join(distDir, 'binary.css'), 'utf8');\n    assert(css.startsWith(`.webp-img {\n  background-image: url(\"data:image/webp;base64,UklGR`));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remap locations in diagnostics using the input source map","suites":["css"],"updatePoint":{"line":254,"column":70,"index":10483},"line":254,"code":"  it('should remap locations in diagnostics using the input source map', async () => {\n    let fixture = path.join(__dirname, 'integration/diagnostic-sourcemap/index.scss');\n    let code = await inputFS.readFileSync(fixture, 'utf8');\n    // $FlowFixMe\n    await assert.rejects(() => bundle(fixture, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: \"Failed to resolve 'x.png' from './index.scss'\",\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: fixture,\n          code,\n          codeHighlights: [{\n            start: {\n              line: 5,\n              column: 3\n            },\n            end: {\n              line: 5,\n              column: 3\n            }\n          }]\n        }]\n      }, {\n        message: \"Cannot load file './x.png' in './'.\",\n        origin: '@parcel/resolver-default',\n        hints: []\n      }]\n    });\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing CSS from node_modules with the npm: scheme","suites":["css"],"updatePoint":{"line":288,"column":73,"index":11446},"line":288,"code":"  it('should support importing CSS from node_modules with the npm: scheme', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/css-node-modules/index.css'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.css', 'foo.css']\n    }]);\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support external CSS imports","suites":["css"],"updatePoint":{"line":295,"column":41,"index":11698},"line":295,"code":"  it('should support external CSS imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/css-external/a.css'));\n    assertBundles(b, [{\n      name: 'a.css',\n      assets: ['a.css', 'b.css']\n    }]);\n    let res = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(new RegExp(`@import \"http://example.com/external.css\";\n.b {\n  color: red;\n}\\n?\n.a {\n  color: green;\n}`).test(res));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support css nesting with @parcel/css","suites":["css"],"updatePoint":{"line":310,"column":49,"index":12142},"line":310,"code":"  it('should support css nesting with @parcel/css', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/css-nesting/a.css'), {\n      defaultTargetOptions: {\n        engines: {}\n      }\n    });\n    let res = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(res.includes('.foo.bar'));\n  });","file":"css.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a basic Elm bundle","suites":["elm"],"updatePoint":{"line":5,"column":39,"index":208},"line":5,"code":"  it('should produce a basic Elm bundle', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/elm/index.js'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['Main.elm', 'index.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output().Elm.Main.init, 'function');\n  });","file":"elm.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a elm bundle with debugger","suites":["elm"],"updatePoint":{"line":14,"column":47,"index":543},"line":14,"code":"  it('should produce a elm bundle with debugger', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/elm/index.js'));\n    await run(b);\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(js.includes('elm$browser$Debugger'));\n  });","file":"elm.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should apply elm-hot if HMR is enabled","suites":["elm"],"updatePoint":{"line":20,"column":44,"index":838},"line":20,"code":"  it('should apply elm-hot if HMR is enabled', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/elm/index.js'), {\n      hmrOptions: true\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['Main.elm', 'index.js']\n    }]);\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(js.includes('[elm-hot]'));\n  });","file":"elm.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove debugger in production","suites":["elm"],"updatePoint":{"line":31,"column":42,"index":1224},"line":31,"code":"  it('should remove debugger in production', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/elm/index.js'), {\n      mode: 'production'\n    });\n    await run(b);\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!js.includes('elm$browser$Debugger'));\n  });","file":"elm.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove debugger when environment variable `PARCEL_ELM_NO_DEBUG` is set to true","suites":["elm"],"updatePoint":{"line":39,"column":91,"index":1601},"line":39,"code":"  it('should remove debugger when environment variable `PARCEL_ELM_NO_DEBUG` is set to true', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/elm/index.js'), {\n      env: {\n        PARCEL_ELM_NO_DEBUG: true\n      }\n    });\n    await run(b);\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!js.includes('elm$browser$Debugger'));\n  });","file":"elm.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify Elm in production mode","suites":["elm"],"updatePoint":{"line":49,"column":42,"index":1959},"line":49,"code":"  it('should minify Elm in production mode', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/elm/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    await run(b);\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!js.includes('elm$core'));\n    assert(js.includes('Elm'));\n    assert(js.includes('init'));\n  });","file":"elm.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce correct formatting and indentation when compilation fails","suites":["elm"],"updatePoint":{"line":62,"column":78,"index":2444},"line":62,"code":"  it('should produce correct formatting and indentation when compilation fails', async function () {\n    const normalizedPath = path.normalize('test/integration/elm-compile-error/src/Main.elm');\n    await assert.rejects(() => bundle(path.join(__dirname, 'integration/elm-compile-error/index.js'), {\n      mode: 'production'\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: '\\n' + `-- TYPE MISMATCH --------------- ${normalizedPath}\\n` + '\\n' + 'The 1st argument to `text` is not what I expect:\\n' + '\\n' + '7|     Html.text 5 \"Hello, world!\"\\n' + '                 **^**\\n' + 'This argument is a number of type:\\n' + '\\n' + '    **number**\\n' + '\\n' + 'But `text` needs the 1st argument to be:\\n' + '\\n' + '    **String**\\n' + '\\n' + '__Hint__: Try using **String.fromInt** to convert it to a string?',\n        origin: '@parcel/elm-transformer',\n        stack: ''\n      }, {\n        message: '\\n' + `-- TOO MANY ARGS --------------- ${normalizedPath}\\n` + '\\n' + 'The `text` function expects 1 argument, but it got 2 instead.\\n' + '\\n' + '7|     Html.text 5 \"Hello, world!\"\\n' + '       **^^^^^^^^^**\\n' + 'Are there any missing commas? Or missing parentheses?',\n        origin: '@parcel/elm-transformer',\n        stack: ''\n      }]\n    });\n  });","file":"elm.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce extra Modules given in \"with\" query param","suites":["elm"],"updatePoint":{"line":79,"column":62,"index":3701},"line":79,"code":"  it('should produce extra Modules given in \"with\" query param', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/elm-multiple-apps/src/index.js'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['Main.elm', 'index.js', 'esmodule-helpers.js']\n    }]);\n    const output = await run(b);\n    const Elm = output.default();\n    assert.equal(typeof Elm.Main.init, 'function');\n    assert.equal(typeof Elm.MainB.init, 'function');\n    assert.equal(typeof Elm.MainC.init, 'function');\n  });","file":"elm.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling files which names in encoded URI","suites":["encodedURI"],"updatePoint":{"line":5,"column":62,"index":218},"line":5,"code":"  it('should support bundling files which names in encoded URI', async function () {\n    await bundle(path.join(__dirname, '/integration/encodedURI/index.html'));\n    let files = await outputFS.readdir(distDir);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    for (let file of files) {\n      if (file !== 'index.html') {\n        assert(html.includes(file));\n      }\n    }\n    assert(!!files.find(f => f.startsWith('日本語')));\n  });","file":"encodedURI.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw validation error with eslint errors","suites":["eslint-validator"],"updatePoint":{"line":7,"column":54,"index":284},"line":7,"code":"  it('should throw validation error with eslint errors', async function () {\n    let didThrow = false;\n    let entry = path.join(__dirname, '/integration/eslint-error/index.js');\n    try {\n      await bundle(entry, {\n        defaultConfig: config\n      });\n    } catch (e) {\n      assert.equal(e.name, 'BuildError');\n      assert(Array.isArray(e.diagnostics));\n      assert(e.diagnostics[0].codeFrames);\n      assert.equal(e.diagnostics[0].origin, '@parcel/validator-eslint');\n      assert.equal(e.diagnostics[0].message, 'ESLint found **1** __errors__ and **1** __warnings__.');\n      let codeframe = e.diagnostics[0].codeFrames[0];\n      assert(codeframe);\n      assert.equal(codeframe.filePath, entry);\n      assert.equal(codeframe.codeHighlights.length, 2);\n      codeframe.codeHighlights.sort(({\n        start: {\n          line: a\n        }\n      }, {\n        start: {\n          line: b\n        }\n      }) => a - b);\n      assert.equal(codeframe.codeHighlights[0].message, 'Unexpected console statement.');\n      assert.equal(codeframe.codeHighlights[1].message, \"'hey' is assigned a value but never used.\");\n      didThrow = true;\n    }\n    assert(didThrow);\n  });","file":"eslint-validation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw a correct codeframe for a parse error","suites":["eslint-validator"],"updatePoint":{"line":39,"column":56,"index":1457},"line":39,"code":"  it('should throw a correct codeframe for a parse error', async function () {\n    let didThrow = false;\n    let entry = path.join(__dirname, '/integration/eslint-parse-error/index.js');\n    try {\n      await bundle(entry, {\n        defaultConfig: config\n      });\n    } catch (e) {\n      assert.equal(e.name, 'BuildError');\n      assert(Array.isArray(e.diagnostics));\n      assert.equal(e.diagnostics[0].origin, '@parcel/validator-eslint');\n      assert.equal(e.diagnostics[0].message, 'ESLint found **1** __errors__ and **0** __warnings__.');\n      let codeframe = e.diagnostics[0].codeFrames[0];\n      assert(codeframe);\n      assert.equal(codeframe.filePath, entry);\n      assert.equal(codeframe.codeHighlights.length, 1);\n      assert(codeframe.codeHighlights[0].start.line != null);\n      assert(codeframe.codeHighlights[0].start.column != null);\n      assert(codeframe.codeHighlights[0].end.line != null);\n      assert(codeframe.codeHighlights[0].end.column != null);\n      assert(codeframe.codeHighlights[0].message.startsWith('Parsing error'));\n      didThrow = true;\n    }\n    assert(didThrow);\n  });","file":"eslint-validation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not inline a file if disabled via config","suites":["fs","browser environment"],"updatePoint":{"line":12,"column":55,"index":403},"line":12,"code":"    it('should not inline a file if disabled via config', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-disabled/index.js'), {\n        inputFS: overlayFS\n      });\n\n      // $FlowFixMe\n      await assert.rejects(() => run(b), /\\.readFileSync is not a function/);\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not inline a file outside of the project root","suites":["fs","browser environment"],"updatePoint":{"line":20,"column":60,"index":718},"line":20,"code":"    it('should not inline a file outside of the project root', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-outside-root/index.js'), {\n        inputFS: overlayFS\n      });\n\n      // $FlowFixMe\n      await assert.rejects(() => run(b), /\\.readFileSync is not a function/);\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file as a string","suites":["fs","browser environment"],"updatePoint":{"line":28,"column":40,"index":1017},"line":28,"code":"    it('should inline a file as a string', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs/index.js'));\n      let output = await run(b);\n      assert.equal(output, 'hello');\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file as a buffer","suites":["fs","browser environment"],"updatePoint":{"line":33,"column":40,"index":1236},"line":33,"code":"    it('should inline a file as a buffer', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-buffer/index.js'));\n      let output = await run(b);\n      invariant(typeof output === 'object' && output != null);\n      assert(output.constructor.name.includes('Buffer'));\n      assert.equal(output.length, 5);\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file with fs require alias","suites":["fs","browser environment"],"updatePoint":{"line":40,"column":50,"index":1594},"line":40,"code":"    it('should inline a file with fs require alias', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-alias/index.js'));\n      let output = await run(b);\n      assert.equal(output, 'hello');\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file with fs require inline","suites":["fs","browser environment"],"updatePoint":{"line":45,"column":51,"index":1830},"line":45,"code":"    it('should inline a file with fs require inline', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-inline/index.js'));\n      let output = await run(b);\n      assert.equal(output, 'hello');\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file with fs require assignment","suites":["fs","browser environment"],"line":50,"code":"    it.skip('should inline a file with fs require assignment', async function () {","file":"fs.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file with fs require assignment alias","suites":["fs","browser environment"],"line":55,"code":"    it.skip('should inline a file with fs require assignment alias', async function () {","file":"fs.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file with fs require destructure","suites":["fs","browser environment"],"updatePoint":{"line":60,"column":56,"index":2576},"line":60,"code":"    it('should inline a file with fs require destructure', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-destructure/index.js'));\n      let output = await run(b);\n      assert.equal(output, 'hello');\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file with fs require destructure assignment","suites":["fs","browser environment"],"line":65,"code":"    it.skip('should inline a file with fs require destructure assignment', async function () {","file":"fs.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file with fs ES6 import","suites":["fs","browser environment"],"updatePoint":{"line":70,"column":47,"index":3084},"line":70,"code":"    it('should inline a file with fs ES6 import', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-import/index.js'));\n      let output = await run(b);\n      invariant(typeof output === 'object' && output != null);\n      assert.equal(output.default, 'hello');\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a file with fs ES6 import and path.join","suites":["fs","browser environment"],"updatePoint":{"line":76,"column":61,"index":3402},"line":76,"code":"    it('should inline a file with fs ES6 import and path.join', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-import-path-join/index.js'));\n      let output = await run(b);\n      invariant(typeof output === 'object' && output != null);\n      assert.equal(output.default, 'hello');\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not evaluate fs calls when package.browser.fs is false","suites":["fs","browser environment"],"updatePoint":{"line":82,"column":69,"index":3738},"line":82,"code":"    it('should not evaluate fs calls when package.browser.fs is false', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/resolve-entries/ignore-fs.js'));\n      assertBundles(b, [{\n        name: 'ignore-fs.js',\n        // empty.js is generated by require('fs'), it gets mocked with an empty module\n        assets: ['_empty.js', 'esmodule-helpers.js', 'ignore-fs.js', 'index.js']\n      }]);\n      // $FlowFixMe[incompatible-call]\n      let output = await run(b);\n      assert.equal(typeof output.test, 'function');\n      assert.equal(output.test(), 'test-pkg-ignore-fs-ok');\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore fs calls when the filename is not evaluable","suites":["fs","browser environment"],"updatePoint":{"line":96,"column":65,"index":4402},"line":96,"code":"    it('should ignore fs calls when the filename is not evaluable', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-file-non-evaluable/index.js'));\n\n      // $FlowFixMe\n      await assert.rejects(() => run(b), /\\.readFileSync is not a function/);\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore fs calls when the filename is not evaluable after preset-env","suites":["fs","browser environment"],"updatePoint":{"line":102,"column":82,"index":4711},"line":102,"code":"    it('should ignore fs calls when the filename is not evaluable after preset-env', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-file-non-evaluable-template-env/index.js'));\n\n      // $FlowFixMe\n      await assert.rejects(() => run(b), /\\.readFileSync is not a function/);\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore fs calls when the options are not evaluable","suites":["fs","browser environment"],"updatePoint":{"line":108,"column":65,"index":5016},"line":108,"code":"    it('should ignore fs calls when the options are not evaluable', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-options-non-evaluable/index.js'));\n\n      // $FlowFixMe\n      await assert.rejects(() => run(b), /\\.readFileSync is not a function/);\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not inline a file in a node environment","suites":["fs","node environment"],"updatePoint":{"line":116,"column":54,"index":5351},"line":116,"code":"    it('should not inline a file in a node environment', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs-node/index.js'));\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js']\n      }]);\n      let contents = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(contents.includes(`require(\"fs\")`));\n      assert(contents.includes('readFileSync'));\n      await outputFS.writeFile(path.join(__dirname, '/integration/fs-node/', 'test.txt'), 'hey');\n      let output = await run(b);\n      assert.equal(output, 'hey');\n    });","file":"fs.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not inline a file in an Electron environment","suites":["fs","electron environment"],"updatePoint":{"line":131,"column":59,"index":6027},"line":131,"code":"    it('should not inline a file in an Electron environment', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/fs/index.js'), {\n        targets: ['electron']\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js']\n      }]);\n      let contents = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(contents.includes(\"require('fs')\"));\n      assert(contents.includes('readFileSync'));\n      await outputFS.writeFile(path.join(distDir, 'test.txt'), 'hey');\n      let output = await run(b);\n      assert.equal(output, 'hey');\n    });","file":"fs.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should require a glob of files","suites":["glob"],"updatePoint":{"line":7,"column":36,"index":244},"line":7,"code":"  it('should require a glob of files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glob/index.js'));\n    await assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', '*.js', 'a.js', 'b.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 3);\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should require nested directories with a glob","suites":["glob"],"updatePoint":{"line":17,"column":51,"index":629},"line":17,"code":"  it('should require nested directories with a glob', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glob-deep/index.js'));\n    await assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', '*.js', 'a.js', 'b.js', 'c.js', 'z.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 13);\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing a glob of CSS files","suites":["glob"],"updatePoint":{"line":27,"column":50,"index":1035},"line":27,"code":"  it('should support importing a glob of CSS files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glob-css/index.js'));\n    await assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['*.css', 'index.css', 'other.css', 'local.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(nullthrows(b.getBundles().find(b => b.type === 'css')).filePath, 'utf8');\n    assert(css.includes('.local'));\n    assert(css.includes('.other'));\n    assert(css.includes('.index'));\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should require a glob using a pipeline","suites":["glob"],"updatePoint":{"line":44,"column":44,"index":1704},"line":44,"code":"  it('should require a glob using a pipeline', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glob-pipeline/index.js'));\n    await assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', '*.js', 'bundle-url.js']\n    }, {\n      type: 'txt',\n      assets: ['a.txt']\n    }, {\n      type: 'txt',\n      assets: ['b.txt']\n    }]);\n    let output = await run(b);\n    assert.deepEqual(output, {\n      a: `http://localhost/${path.basename(nullthrows(b.getBundles().find(b => b.name.startsWith('a'))).filePath)}`,\n      b: `http://localhost/${path.basename(nullthrows(b.getBundles().find(b => b.name.startsWith('b'))).filePath)}`\n    });\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should import a glob with dynamic import","suites":["glob"],"updatePoint":{"line":62,"column":46,"index":2388},"line":62,"code":"  it('should import a glob with dynamic import', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glob-async/index.js'));\n    await assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', '*.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      type: 'js',\n      assets: ['a.js']\n    }, {\n      type: 'js',\n      assets: ['b.js']\n    }]);\n    let output = await run(b);\n    assert.equal(await output(), 3);\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when an unsupported asset type imports a glob","suites":["glob"],"updatePoint":{"line":77,"column":64,"index":2882},"line":77,"code":"  it('should error when an unsupported asset type imports a glob', async function () {\n    let filePath = path.join(__dirname, '/integration/glob-error/index.html');\n    // $FlowFixMe\n    await assert.rejects(() => bundle(filePath), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: \"Failed to resolve 'foo/\\\\*.js' from './index.html'\",\n        origin: '@parcel/core'\n      }, {\n        message: 'Glob imports are not supported in html files.',\n        origin: '@parcel/resolver-glob',\n        codeFrames: undefined\n      }]\n    });\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when a URL dependency imports a glob","suites":["glob"],"updatePoint":{"line":92,"column":55,"index":3429},"line":92,"code":"  it('should error when a URL dependency imports a glob', async function () {\n    let filePath = path.join(__dirname, '/integration/glob-error/index.css');\n    // $FlowFixMe\n    await assert.rejects(() => bundle(filePath), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: \"Failed to resolve 'images/\\\\*.jpg' from './index.css'\",\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath,\n          code: await inputFS.readFile(filePath, 'utf8'),\n          codeHighlights: [{\n            start: {\n              column: 19,\n              line: 2\n            },\n            end: {\n              column: 30,\n              line: 2\n            }\n          }]\n        }]\n      }, {\n        message: 'Glob imports are not supported in URL dependencies.',\n        origin: '@parcel/resolver-glob',\n        codeFrames: [{\n          codeHighlights: [{\n            start: {\n              column: 19,\n              line: 2\n            },\n            end: {\n              column: 30,\n              line: 2\n            }\n          }]\n        }]\n      }]\n    });\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should require a glob of files from a package","suites":["glob"],"updatePoint":{"line":132,"column":51,"index":4511},"line":132,"code":"  it('should require a glob of files from a package', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glob-package/index.js'));\n    await assertBundles(b, [{\n      name: 'index.js',\n      assets: ['*.js', '*.js', 'a.js', 'b.js', 'x.js', 'y.js', 'index.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 10);\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should require a glob of files from a package async","suites":["glob"],"updatePoint":{"line":142,"column":57,"index":4935},"line":142,"code":"  it('should require a glob of files from a package async', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glob-package-async/index.js'));\n    await assertBundles(b, [{\n      name: 'index.js',\n      assets: ['*.js', '*.js', 'bundle-url.js', 'cacheLoader.js', 'index.js', 'js-loader.js']\n    }, {\n      type: 'js',\n      assets: ['a.js']\n    }, {\n      type: 'js',\n      assets: ['b.js']\n    }, {\n      type: 'js',\n      assets: ['x.js']\n    }, {\n      type: 'js',\n      assets: ['y.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 10);\n  });","file":"glob.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support global alias syntax","suites":["global alias"],"updatePoint":{"line":5,"column":40,"index":184},"line":5,"code":"  it('should support global alias syntax', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/global-alias/index.js'));\n    assert.equal(await run(b, {\n      React: {\n        createElement: function () {\n          return 'ok';\n        }\n      }\n    }), 'ok');\n  });","file":"globals.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring GLSL files via glslify","suites":["glsl"],"updatePoint":{"line":6,"column":53,"index":229},"line":6,"code":"  it('should support requiring GLSL files via glslify', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glsl/index.js'));\n    let shader = fs.readFileSync(path.join(__dirname, '/integration/glsl/compiled.glsl'), 'utf8');\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.ok(output().reduce((acc, requiredShader) => {\n      return acc && normaliseNewlines(shader) === normaliseNewlines(requiredShader);\n    }, true));\n  });","file":"glsl.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly resolve relative GLSL imports","suites":["glsl"],"updatePoint":{"line":15,"column":52,"index":720},"line":15,"code":"  it('should correctly resolve relative GLSL imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/glsl-relative-import/index.js'));\n    let output = await run(b);\n    assert.strictEqual(output.trim(), `#define GLSLIFY 1\nfloat b(float p) { return p*2.0; }\n\nfloat c(float p) { return b(p)*3.0; }\n\nvarying float x;\n\nvoid main() { gl_FragColor = vec4(c(x)); }`);\n  });","file":"glsl.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring graphql files","suites":["graphql"],"updatePoint":{"line":6,"column":44,"index":232},"line":6,"code":"  it('should support requiring graphql files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/graphql/index.js'));\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.deepEqual(normalize(output()), normalize(`\n        {\n          user(id: 5) {\n            ...UserFragment\n          }\n        }\n\n        fragment UserFragment on User {\n          firstName\n          lastName\n        }\n      `));\n  });","file":"graphql.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing other graphql files from a graphql file","suites":["graphql"],"updatePoint":{"line":23,"column":70,"index":727},"line":23,"code":"  it('should support importing other graphql files from a graphql file', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/graphql-import/index.js'));\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.deepEqual(normalize(output()), normalize(`\n        {\n          user(id: 6) {\n            ...UserFragment\n            ...AnotherUserFragment\n          }\n        }\n\n        fragment UserFragment on User {\n          firstName\n          lastName\n        }\n\n        fragment AnotherUserFragment on User {\n          address\n          email\n        }\n      `));\n  });","file":"graphql.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing fragments in other graphql files by name","suites":["graphql"],"updatePoint":{"line":46,"column":71,"index":1357},"line":46,"code":"  it('should support importing fragments in other graphql files by name', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/graphql-named-import/index.js'));\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.deepEqual(normalize(output()), normalize(`\n      query MyQuery {\n        user(id: 6) {\n          ...UserFragment\n          address {\n            ...Address\n          }\n        }\n      }\n\n      fragment UserFragment on User {\n        firstName\n        lastName\n        ...AnotherUserFragment\n      }\n\n      fragment Address on Address {\n        line1\n        county\n        postalCode\n      }\n\n      fragment AnotherUserFragment on User {\n        address\n        email\n      }\n\n      fragment otherUserFragment on User {\n        friends {\n          edges {\n            nodes {\n              name\n            }\n          }\n        }\n      }\n      `));\n  });","file":"graphql.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should emit an HMR update for the file that changed","suites":["hmr","hmr server"],"updatePoint":{"line":94,"column":59,"index":2796},"line":94,"code":"    it('should emit an HMR update for the file that changed', async function () {\n      let port = await getPort();\n      let b = bundler(path.join(__dirname, '/input/index.js'), {\n        hmrOptions: {\n          port\n        },\n        inputFS: overlayFS,\n        config\n      });\n      subscription = await b.watch();\n      await getNextBuild(b);\n      ws = await openSocket('ws://localhost:' + port);\n      outputFS.writeFile(path.join(__dirname, '/input/local.js'), 'exports.a = 5;\\nexports.b = 5;');\n      let message = await nextWSMessage(nullthrows(ws));\n      assert.equal(message.type, 'update');\n\n      // Figure out why output doesn't change...\n      let localAsset = message.assets.find(asset => asset.output.includes('exports.a = 5;\\nexports.b = 5;\\n'));\n      assert(!!localAsset);\n      assert(localAsset.output.includes('//# sourceMappingURL'));\n      assert(localAsset.output.includes('//# sourceURL'));\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should emit an HMR update for all new dependencies along with the changed file","suites":["hmr","hmr server"],"updatePoint":{"line":116,"column":86,"index":3752},"line":116,"code":"    it('should emit an HMR update for all new dependencies along with the changed file', async function () {\n      let port = await getPort();\n      let b = bundler(path.join(__dirname, '/input/index.js'), {\n        hmrOptions: {\n          port\n        },\n        inputFS: overlayFS,\n        config\n      });\n      subscription = await b.watch();\n      await getNextBuild(b);\n      ws = await openSocket('ws://localhost:' + port);\n      outputFS.writeFile(path.join(__dirname, '/input/local.js'), 'require(\"fs\"); exports.a = 5; exports.b = 5;');\n      let message = await nextWSMessage(nullthrows(ws));\n      assert.equal(message.type, 'update');\n      assert.equal(message.assets.length, 2);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should emit an HMR error on bundle failure","suites":["hmr","hmr server"],"updatePoint":{"line":133,"column":50,"index":4417},"line":133,"code":"    it('should emit an HMR error on bundle failure', async function () {\n      let port = await getPort();\n      let b = bundler(path.join(__dirname, '/input/index.js'), {\n        hmrOptions: {\n          port\n        },\n        inputFS: overlayFS,\n        config\n      });\n      subscription = await b.watch();\n      await getNextBuild(b);\n      ws = await openSocket('ws://localhost:' + port);\n      outputFS.writeFile(path.join(__dirname, '/input/local.js'), 'require(\"fs\"; exports.a = 5; exports.b = 5;');\n      let message = await nextWSMessage(nullthrows(ws));\n      assert.equal(message.type, 'error');\n      assert(!!message.diagnostics, 'Should contain a diagnostics key');\n      assert(!!message.diagnostics.html, 'Should contain a html diagnostic');\n      assert(!!message.diagnostics.ansi, 'Should contain an ansi diagnostic');\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should emit an HMR error to new connections after a bundle failure","suites":["hmr","hmr server"],"updatePoint":{"line":152,"column":74,"index":5288},"line":152,"code":"    it('should emit an HMR error to new connections after a bundle failure', async function () {\n      let port = await getPort();\n      let b = bundler(path.join(__dirname, '/input/index.js'), {\n        hmrOptions: {\n          port\n        },\n        inputFS: overlayFS,\n        config\n      });\n      subscription = await b.watch();\n      await getNextBuild(b);\n      await outputFS.writeFile(path.join(__dirname, '/input/local.js'), 'require(\"fs\"; exports.a = 5; exports.b = 5;');\n      ws = await openSocket('ws://localhost:' + port);\n      let message = await nextWSMessage(ws);\n      assert.equal(message.type, 'error');\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should emit an HMR update after error has been resolved","suites":["hmr","hmr server"],"updatePoint":{"line":168,"column":63,"index":5912},"line":168,"code":"    it('should emit an HMR update after error has been resolved', async function () {\n      let port = await getPort();\n      let b = bundler(path.join(__dirname, '/input/index.js'), {\n        hmrOptions: {\n          port\n        },\n        inputFS: overlayFS,\n        config\n      });\n      subscription = await b.watch();\n      await getNextBuild(b);\n      ws = await openSocket('ws://localhost:' + port);\n      await outputFS.writeFile(path.join(__dirname, '/input/local.js'), 'require(\"fs\"; exports.a = 5; exports.b = 5;');\n      let message = await nextWSMessage(nullthrows(ws));\n      assert.equal(message.type, 'error');\n      await outputFS.writeFile(path.join(__dirname, '/input/local.js'), 'require(\"fs\"); exports.a = 5; exports.b = 5;');\n      message = await nextWSMessage(nullthrows(ws));\n      assert.equal(message.type, 'update');\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should make a secure connection","suites":["hmr","hmr server"],"updatePoint":{"line":187,"column":39,"index":6742},"line":187,"code":"    it('should make a secure connection', async function () {\n      let port = await getPort();\n      let b = bundler(path.join(__dirname, '/input/index.js'), {\n        serveOptions: {\n          https: true,\n          port,\n          host: 'localhost'\n        },\n        hmrOptions: {\n          port\n        },\n        inputFS: overlayFS,\n        config\n      });\n      subscription = await b.watch();\n      await getNextBuild(b);\n      ws = await openSocket('wss://localhost:' + port, {\n        rejectUnauthorized: false\n      });\n      await outputFS.writeFile(path.join(__dirname, '/input/local.js'), 'exports.a = 5;\\nexports.b = 5;');\n      let message = await nextWSMessage(nullthrows(ws));\n      assert.equal(message.type, 'update');\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should make a secure connection with custom certificate","suites":["hmr","hmr server"],"updatePoint":{"line":210,"column":63,"index":7514},"line":210,"code":"    it('should make a secure connection with custom certificate', async function () {\n      let port = await getPort();\n      let b = bundler(path.join(__dirname, '/input/index.js'), {\n        serveOptions: {\n          https: {\n            key: path.join(__dirname, '/integration/https/private.pem'),\n            cert: path.join(__dirname, '/integration/https/primary.crt')\n          },\n          port,\n          host: 'localhost'\n        },\n        hmrOptions: {\n          port\n        },\n        inputFS: overlayFS,\n        config\n      });\n      subscription = await b.watch();\n      await getNextBuild(b);\n      ws = await openSocket('wss://localhost:' + port, {\n        rejectUnauthorized: false\n      });\n      outputFS.writeFile(path.join(__dirname, '/input/local.js'), 'exports.a = 5;\\nexports.b = 5;');\n      let message = await nextWSMessage(nullthrows(ws));\n      assert.equal(message.type, 'update');\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should respond to requests for assets by id","suites":["hmr","hmr server"],"updatePoint":{"line":236,"column":51,"index":8423},"line":236,"code":"    it('should respond to requests for assets by id', async function () {\n      let port = await getPort();\n      let b = bundler(path.join(__dirname, '/input/index.js'), {\n        serveOptions: {\n          port\n        },\n        hmrOptions: {\n          port\n        },\n        inputFS: overlayFS,\n        config\n      });\n      subscription = await b.watch();\n      let event = await getNextBuild(b);\n      let bundleGraph = nullthrows(event.bundleGraph);\n      let asset = nullthrows(bundleGraph.getBundles()[0].getMainEntry());\n      let contents = await request('/__parcel_hmr/' + asset.id, port);\n      let publicId = nullthrows(bundleGraph).getAssetPublicId(asset);\n      assert(contents.startsWith(`parcelHotUpdate['${publicId}'] = function (require, module, exports) {`));\n      assert(contents.includes('//# sourceMappingURL'));\n      assert(contents.includes('//# sourceURL'));\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support self accepting","suites":["hmr","hmr runtime"],"updatePoint":{"line":265,"column":37,"index":9565},"line":265,"code":"    it('should support self accepting', async function () {\n      let {\n        outputs\n      } = await testHMRClient('hmr-accept-self', outputs => {\n        assert.deepStrictEqual(outputs, [['other', 1], ['local', 1], ['index', 1]]);\n        return {\n          'other.js': 'export const value = 3; output([\"other\", value]);'\n        };\n      });\n      assert.deepStrictEqual(outputs, [['other', 1], ['local', 1], ['index', 1], ['other', 3], ['local', 3]]);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bubble through parents","suites":["hmr","hmr runtime"],"updatePoint":{"line":276,"column":37,"index":10031},"line":276,"code":"    it('should bubble through parents', async function () {\n      let {\n        outputs\n      } = await testHMRClient('hmr-bubble', outputs => {\n        assert.deepStrictEqual(outputs, [['other', 1], ['local', 1], ['index', 1]]);\n        return {\n          'other.js': 'export const value = 3; output([\"other\", value]);'\n        };\n      });\n      assert.deepStrictEqual(outputs, [['other', 1], ['local', 1], ['index', 1], ['other', 3], ['local', 3], ['index', 3]]);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should call dispose callbacks","suites":["hmr","hmr runtime"],"updatePoint":{"line":287,"column":37,"index":10506},"line":287,"code":"    it('should call dispose callbacks', async function () {\n      let {\n        outputs\n      } = await testHMRClient('hmr-dispose', outputs => {\n        assert.deepStrictEqual(outputs, [['eval:other', 1, null], ['eval:local', 1, null], ['eval:index', 1, null]]);\n        return {\n          'other.js': `export const value = 3;\noutput([\"eval:other\", value, module.hot.data]);\nmodule.hot.dispose((data) => {\n  output([\"dispose:other\", value]);\n  data.value = value;\n})\n`\n        };\n      });\n\n      // Webpack:\n      // [\"eval:other\", 1, undefined]\n      // [\"eval:local\", 1, undefined]\n      // [\"eval:index\", 1, undefined]\n      // [\"dispose:index\", 1]\n      // [\"dispose:local\", 1]\n      // [\"dispose:other\", 1]\n      // [\"eval:other\", 3, {value: 1}]\n      // [\"eval:local\", 3, {value: 1}]\n      // [\"eval:index\", 3, {value: 1}]\n      assert.deepStrictEqual(outputs, [['eval:other', 1, null], ['eval:local', 1, null], ['eval:index', 1, null], ['dispose:other', 1], ['eval:other', 3, {\n        value: 1\n      }], ['dispose:local', 1], ['eval:local', 3, {\n        value: 1\n      }], ['dispose:index', 1], ['eval:index', 3, {\n        value: 1\n      }]]);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with circular dependencies","suites":["hmr","hmr runtime"],"updatePoint":{"line":321,"column":46,"index":11677},"line":321,"code":"    it('should work with circular dependencies', async function () {\n      let {\n        outputs\n      } = await testHMRClient('hmr-circular', outputs => {\n        assert.deepEqual(outputs, [3]);\n        return {\n          'local.js': \"var other = require('./index.js'); exports.a = 5; exports.b = 5;\"\n        };\n      });\n      assert.deepEqual(outputs, [3, 10]);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should reload if not accepted","suites":["hmr","hmr runtime"],"updatePoint":{"line":332,"column":37,"index":12041},"line":332,"code":"    it('should reload if not accepted', async function () {\n      let {\n        reloaded\n      } = await testHMRClient('hmr-reload', outputs => {\n        assert.deepEqual(outputs, [3]);\n        return {\n          'local.js': 'exports.a = 5; exports.b = 5;'\n        };\n      });\n      assert(reloaded);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should reload when modifying the entry","suites":["hmr","hmr runtime"],"updatePoint":{"line":343,"column":46,"index":12360},"line":343,"code":"    it('should reload when modifying the entry', async function () {\n      let {\n        reloaded\n      } = await testHMRClient('hmr-reload', outputs => {\n        assert.deepEqual(outputs, [3]);\n        return {\n          'index.js': 'output(5)'\n        };\n      });\n      assert(reloaded);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with multiple parents","suites":["hmr","hmr runtime"],"updatePoint":{"line":354,"column":41,"index":12654},"line":354,"code":"    it('should work with multiple parents', async function () {\n      let {\n        outputs\n      } = await testHMRClient('hmr-multiple-parents', outputs => {\n        assert.deepEqual(outputs, ['a: fn1 b: fn2']);\n        return {\n          'fn2.js': 'export function fn2() { return \"UPDATED\"; }'\n        };\n      });\n      assert.deepEqual(outputs, ['a: fn1 b: fn2', 'a: fn1 b: UPDATED']);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should reload if only one parent accepts","suites":["hmr","hmr runtime"],"updatePoint":{"line":365,"column":48,"index":13059},"line":365,"code":"    it('should reload if only one parent accepts', async function () {\n      let {\n        reloaded\n      } = await testHMRClient('hmr-multiple-parents-reload', outputs => {\n        assert.deepEqual(outputs, ['a: fn1', 'b: fn2']);\n        return {\n          'fn2.js': 'export function fn2() { return \"UPDATED\"; }'\n        };\n      });\n      assert(reloaded);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work across bundles","suites":["hmr","hmr runtime"],"updatePoint":{"line":376,"column":34,"index":13412},"line":376,"code":"    it('should work across bundles', async function () {\n      let {\n        reloaded\n      } = await testHMRClient('hmr-dynamic', outputs => {\n        assert.deepEqual(outputs, [3]);\n        return {\n          'local.js': 'exports.a = 5; exports.b = 5;'\n        };\n      });\n\n      // assert.deepEqual(outputs, [3, 10]);\n      assert(reloaded); // TODO: this should eventually not reload...\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with urls","suites":["hmr","hmr runtime"],"updatePoint":{"line":390,"column":29,"index":13808},"line":390,"code":"    it('should work with urls', async function () {\n      let search;\n      let {\n        outputs\n      } = await testHMRClient('hmr-url', outputs => {\n        assert.equal(outputs.length, 1);\n        let url = new URL(outputs[0]);\n        assert(/test\\.[0-9a-f]+\\.txt/, url.pathname);\n        assert(!isNaN(url.search.slice(1)));\n        search = url.search;\n        return {\n          'test.txt': 'yo'\n        };\n      });\n      assert.equal(outputs.length, 2);\n      let url = new URL(outputs[1]);\n      assert(/test\\.[0-9a-f]+\\.txt/, url.pathname);\n      assert(!isNaN(url.search.slice(1)));\n      assert.notEqual(url.search, search);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should clean up orphaned assets when deleting a dependency","suites":["hmr","hmr runtime"],"updatePoint":{"line":410,"column":66,"index":14492},"line":410,"code":"    it('should clean up orphaned assets when deleting a dependency', async function () {\n      let search;\n      let {\n        outputs\n      } = await testHMRClient('hmr-url', [outputs => {\n        assert.equal(outputs.length, 1);\n        let url = new URL(outputs[0]);\n        assert(/test\\.[0-9a-f]+\\.txt/, url.pathname);\n        assert(!isNaN(url.search.slice(1)));\n        search = url.search;\n        return {\n          'index.js': 'output(\"yo\"); module.hot.accept();'\n        };\n      }, outputs => {\n        assert.equal(outputs.length, 2);\n        assert.equal(outputs[1], 'yo');\n        return {\n          'index.js': 'output(new URL(\"test.txt\", import.meta.url)); module.hot.accept();'\n        };\n      }]);\n      assert.equal(outputs.length, 3);\n      let url = new URL(outputs[2]);\n      assert(/test\\.[0-9a-f]+\\.txt/, url.pathname);\n      assert(!isNaN(url.search.slice(1)));\n      assert.notEqual(url.search, search);\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should have correct source locations in errors","suites":["hmr","hmr runtime"],"updatePoint":{"line":436,"column":54,"index":15420},"line":436,"code":"    it('should have correct source locations in errors', async function () {\n      let {\n        outputs,\n        bundleGraph\n      } = await testHMRClient('hmr-accept-self', () => {\n        return {\n          'local.js': 'output(new Error().stack);'\n        };\n      });\n      let asset = bundleGraph.getBundles()[0].traverseAssets((asset, _, actions) => {\n        if (asset.filePath.endsWith('local.js')) {\n          actions.stop();\n          return asset;\n        }\n      });\n      let stack = outputs.pop();\n      assert(stack.includes('/__parcel_hmr/' + nullthrows(asset).id));\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update CSS link tags when a CSS asset is changed","suites":["hmr","hmr runtime"],"updatePoint":{"line":671,"column":63,"index":22413},"line":671,"code":"    it('should update CSS link tags when a CSS asset is changed', async () => {\n      let testDir = path.join(__dirname, '/input');\n      await overlayFS.rimraf(testDir);\n      await overlayFS.mkdirp(testDir);\n      await ncp(path.join(__dirname, '/integration/hmr-css'), testDir);\n      let port = await getPort();\n      let b = bundler(path.join(testDir, 'index.html'), {\n        inputFS: overlayFS,\n        outputFS: overlayFS,\n        serveOptions: {\n          https: false,\n          port,\n          host: '127.0.0.1'\n        },\n        hmrOptions: {\n          port\n        },\n        shouldContentHash: false,\n        config\n      });\n      subscription = await b.watch();\n      let bundleEvent = await getNextBuild(b);\n      assert.equal(bundleEvent.type, 'buildSuccess');\n      let window;\n      try {\n        let dom = await JSDOM.JSDOM.fromURL('http://127.0.0.1:' + port + '/index.html', {\n          runScripts: 'dangerously',\n          resources: 'usable',\n          pretendToBeVisual: true\n        });\n        let _window = window = dom.window; // For Flow\n        window.WebSocket = WebSocket;\n        await new Promise(res => dom.window.document.addEventListener('load', () => {\n          res();\n        }));\n        _window.console.clear = () => {};\n        _window.console.warn = () => {};\n        let initialHref = _window.document.querySelector('link').href;\n        await overlayFS.copyFile(path.join(testDir, 'index.2.css'), path.join(testDir, 'index.css'));\n        assert.equal((await getNextBuild(b)).type, 'buildSuccess');\n        await sleep(200);\n        let newHref = _window.document.querySelector('link').href;\n        assert.notStrictEqual(initialHref, newHref);\n      } finally {\n        if (window) {\n          window.close();\n        }\n      }\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle CSS Modules update correctly","suites":["hmr","hmr runtime"],"updatePoint":{"line":720,"column":50,"index":24185},"line":720,"code":"    it('should handle CSS Modules update correctly', async () => {\n      let testDir = path.join(__dirname, '/input');\n      await overlayFS.rimraf(testDir);\n      await overlayFS.mkdirp(testDir);\n      await ncp(path.join(__dirname, '/integration/hmr-css-modules'), testDir);\n      let port = await getPort();\n      let b = bundler(path.join(testDir, 'index.html'), {\n        inputFS: overlayFS,\n        outputFS: overlayFS,\n        serveOptions: {\n          https: false,\n          port,\n          host: '127.0.0.1'\n        },\n        hmrOptions: {\n          port\n        },\n        shouldContentHash: false,\n        config\n      });\n      subscription = await b.watch();\n      let bundleEvent = await getNextBuild(b);\n      assert.equal(bundleEvent.type, 'buildSuccess');\n      let window;\n      try {\n        let dom = await JSDOM.JSDOM.fromURL('http://127.0.0.1:' + port + '/index.html', {\n          runScripts: 'dangerously',\n          resources: 'usable',\n          pretendToBeVisual: true\n        });\n        let _window = window = dom.window; // For Flow\n        window.WebSocket = WebSocket;\n        await new Promise(res => dom.window.document.addEventListener('load', () => {\n          res();\n        }));\n        _window.console.clear = () => {};\n        _window.console.warn = () => {};\n        let initialHref = _window.document.querySelector('link').href;\n        await overlayFS.copyFile(path.join(testDir, 'index2.module.css'), path.join(testDir, 'index.module.css'));\n        assert.equal((await getNextBuild(b)).type, 'buildSuccess');\n        await sleep(200);\n        let newHref = _window.document.querySelector('link').href;\n        assert.notStrictEqual(initialHref, newHref);\n      } finally {\n        if (window) {\n          window.close();\n        }\n      }\n    });","file":"hmr.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling HTML","suites":["html"],"updatePoint":{"line":15,"column":34,"index":488},"line":15,"code":"  it('should support bundling HTML', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/html/index.html'));\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'svg',\n      assets: ['icons.svg']\n    }, {\n      type: 'css',\n      assets: ['index.css']\n    }, {\n      type: 'html',\n      assets: ['other.html']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }]);\n    let files = await outputFS.readdir(distDir);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    for (let file of files) {\n      if (file !== 'index.html' && path.extname(file) !== '.map') {\n        assert(html.includes(file));\n      }\n    }\n    assert(html.includes('#hash_link'));\n    assert(html.includes('mailto:someone@acme.com'));\n    assert(html.includes('tel:+33636757575'));\n    assert(html.includes('https://unpkg.com/parcel-bundler'));\n    let iconsBundle = b.getBundles().find(b => b.name.startsWith('icons'));\n    assert(html.includes('/' + path.basename(iconsBundle.filePath) + '#icon-code'));\n    let value = null;\n    await run(b, {\n      alert: v => value = v\n    });\n    assert.equal(value, 'Hi');\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support pkg#source array as entrypoints","suites":["html"],"updatePoint":{"line":61,"column":52,"index":1888},"line":61,"code":"  it('should support pkg#source array as entrypoints', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/html-pkg-source-array'));\n    assertBundles(b, [{\n      name: 'a.html',\n      assets: ['a.html']\n    }, {\n      name: 'b.html',\n      assets: ['b.html']\n    }]);\n    assert(await outputFS.exists(path.join(distDir, 'a.html'), 'utf8'));\n    assert(await outputFS.exists(path.join(distDir, 'b.html'), 'utf8'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should find href attr when not first","suites":["html"],"updatePoint":{"line":73,"column":42,"index":2321},"line":73,"code":"  it('should find href attr when not first', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-attr-order/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'html',\n      assets: ['other.html']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert empty script tag for HMR at the end of the body","suites":["html"],"updatePoint":{"line":83,"column":67,"index":2654},"line":83,"code":"  it('should insert empty script tag for HMR at the end of the body', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/html-no-js/index.html'), {\n      hmrOptions: {}\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(/<script src=\".+?\\.js\"><\\/script><\\/body>/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert empty script tag for HMR at the implied </body>","suites":["html"],"updatePoint":{"line":97,"column":67,"index":3163},"line":97,"code":"  it('should insert empty script tag for HMR at the implied </body>', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/html-no-js/no-body.html'), {\n      hmrOptions: {}\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['no-body.html']\n    }, {\n      name: 'no-body.html',\n      assets: ['no-body.html']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'no-body.html'), 'utf8');\n    assert(/<script src=\".+?\\.js\"><\\/script><\\/html>/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert empty script tag for HMR at the end of the file if both </body> and </html> are implied","suites":["html"],"updatePoint":{"line":111,"column":107,"index":3722},"line":111,"code":"  it('should insert empty script tag for HMR at the end of the file if both </body> and </html> are implied', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/html-no-js/no-body-or-html.html'), {\n      hmrOptions: {}\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['no-body-or-html.html']\n    }, {\n      name: 'no-body-or-html.html',\n      assets: ['no-body-or-html.html']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'no-body-or-html.html'), 'utf8');\n    assert(/<script src=\".+?\\.js\"><\\/script>$/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert empty script tag for HMR at the end of the body when having normal inline script","suites":["html"],"updatePoint":{"line":125,"column":100,"index":4307},"line":125,"code":"  it('should insert empty script tag for HMR at the end of the body when having normal inline script', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/html-inline-js/index.html'), {\n      hmrOptions: {}\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(/<script src=\".+?\\.js\"><\\/script><\\/body>/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support canonical links","suites":["html"],"updatePoint":{"line":151,"column":36,"index":5013},"line":151,"code":"  it('should support canonical links', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-canonical/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(/<link rel=\"canonical\" href=\"\\.?\\/index.html\">/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support RSS feed links","suites":["html"],"updatePoint":{"line":160,"column":35,"index":5409},"line":160,"code":"  it('should support RSS feed links', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-feed/rss.html'));\n    assertBundles(b, [{\n      name: 'rss.html',\n      assets: ['rss.html']\n    }, {\n      name: 'feed.xml',\n      assets: ['feed.xml']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support atom feed links","suites":["html"],"updatePoint":{"line":170,"column":36,"index":5701},"line":170,"code":"  it('should support atom feed links', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-feed/atom.html'));\n    assertBundles(b, [{\n      name: 'atom.html',\n      assets: ['atom.html']\n    }, {\n      name: 'feed.xml',\n      assets: ['feed.xml']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support meta tags","suites":["html"],"updatePoint":{"line":180,"column":30,"index":5990},"line":180,"code":"  it('should support meta tags', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-meta/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      name: 'logo.svg',\n      assets: ['logo.svg']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes(`<meta name=\"msapplication-config\" content=\"none\">`));\n    assert(html.includes(`<meta property=\"og:image\" content=\"/logo.svg\">`));\n    assert(html.includes(`<meta name=\"twitter:image\" content=\"https://parceljs.org/assets/logo.svg\">`));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert sibling CSS bundles for JS files in the HEAD","suites":["html"],"updatePoint":{"line":194,"column":64,"index":6660},"line":194,"code":"  it('should insert sibling CSS bundles for JS files in the HEAD', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-css/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }, {\n      type: 'css',\n      assets: ['index.css']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(/<link rel=\"stylesheet\" href=\"[/\\\\]{1}index\\.[a-f0-9]+\\.css\">/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert sibling bundles before body element if no HEAD","suites":["html"],"updatePoint":{"line":209,"column":66,"index":7206},"line":209,"code":"  it('should insert sibling bundles before body element if no HEAD', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-css-head/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }, {\n      type: 'css',\n      assets: ['index.css']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(/<html>\\s*<link rel=\"stylesheet\" href=\"[/\\\\]{1}index\\.[a-f0-9]+\\.css\">\\s*<body>/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert sibling bundles after doctype if no html","suites":["html"],"updatePoint":{"line":224,"column":60,"index":7769},"line":224,"code":"  it('should insert sibling bundles after doctype if no html', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-css-doctype/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }, {\n      type: 'css',\n      assets: ['index.css']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(/^\\s*<!DOCTYPE html>\\s*<link .*>\\s*<script .*>\\s*<\\/script>\\s*$/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert sibling JS bundles for CSS files in the HEAD","suites":["html"],"line":239,"code":"  it.skip('should insert sibling JS bundles for CSS files in the HEAD', async function () {","file":"html.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should insert sibling bundles at correct location in tree when optional elements are absent","suites":["html"],"updatePoint":{"line":256,"column":97,"index":8969},"line":256,"code":"  it('should insert sibling bundles at correct location in tree when optional elements are absent', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-css-optional-elements/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }, {\n      type: 'css',\n      assets: ['index.css']\n    }, {\n      type: 'js',\n      assets: ['other.js']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(/^<link rel=\"stylesheet\" href=\"[/\\\\]index\\.[a-f0-9]+\\.css\">\\s*<script src=\"[/\\\\]index\\.[a-f0-9]+\\.js\" defer=\"\"><\\/script>\\s*<h1>Hello/m.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should combine sibling CSS from multiple script tags into one bundle","suites":["html"],"updatePoint":{"line":274,"column":74,"index":9668},"line":274,"code":"  it('should combine sibling CSS from multiple script tags into one bundle', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-css-multi/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['a.js']\n    }, {\n      type: 'js',\n      assets: ['b.js']\n    }, {\n      type: 'css',\n      assets: ['a.css', 'b.css']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert.equal(html.match(/<link rel=\"stylesheet\" href=\"[/\\\\]{1}index\\.[a-f0-9]+?\\.css\">/g).length, 1);\n    assert.equal(html.match(/<script src=\"[/\\\\]{1}index\\.[a-f0-9]+?\\.js\" defer=\"\">/g).length, 2);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should deduplicate shared code between script tags","suites":["html"],"updatePoint":{"line":293,"column":56,"index":10378},"line":293,"code":"  it('should deduplicate shared code between script tags', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js-dedup/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['component-1.js', 'obj.js', 'esmodule-helpers.js']\n    }, {\n      type: 'js',\n      assets: ['component-2.js']\n    }]);\n    let o = [];\n    await run(b, {\n      output: v => o.push(v)\n    });\n    assert.deepEqual(o, ['component-1', 'component-2']);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify HTML in production mode","suites":["html"],"updatePoint":{"line":311,"column":43,"index":10909},"line":311,"code":"  it('should minify HTML in production mode', async function () {\n    let inputFile = path.join(__dirname, '/integration/htmlnano/index.html');\n    await bundle(inputFile, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    let inputSize = (await inputFS.stat(inputFile)).size;\n    let outputFile = path.join(distDir, 'index.html');\n    let outputSize = (await outputFS.stat(outputFile)).size;\n    assert(inputSize > outputSize);\n    let html = await outputFS.readFile(outputFile, 'utf8');\n    assert(html.includes('Other page'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with an empty html file","suites":["html"],"updatePoint":{"line":325,"column":41,"index":11473},"line":325,"code":"  it('should work with an empty html file', async function () {\n    let inputFile = path.join(__dirname, '/integration/html-empty/index.html');\n    await bundle(inputFile, {\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    let outputFile = path.join(distDir, 'index.html');\n    let html = await outputFS.readFile(outputFile, 'utf8');\n    assert.equal(html.length, 0);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with an invalid html file","suites":["html"],"updatePoint":{"line":336,"column":43,"index":11880},"line":336,"code":"  it('should work with an invalid html file', async function () {\n    let inputFile = path.join(__dirname, '/integration/html-invalid/index.html');\n    await bundle(inputFile, {\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    let outputFile = path.join(distDir, 'index.html');\n    let html = await outputFS.readFile(outputFile, 'utf8');\n    assert(html.includes('This is a paragraph'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with html that doesn't include optional closing tags","suites":["html"],"updatePoint":{"line":347,"column":70,"index":12332},"line":347,"code":"  it(\"should work with html that doesn't include optional closing tags\", async function () {\n    let inputFile = path.join(__dirname, '/integration/html-optional-closing-tags/index.html');\n    await bundle(inputFile, {\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    let outputFile = path.join(distDir, 'index.html');\n    let html = await outputFS.readFile(outputFile, 'utf8');\n    assert(html.includes('Paragraph 1'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should read .htmlnanorc.json and minify HTML in production mode","suites":["html"],"updatePoint":{"line":358,"column":69,"index":12789},"line":358,"code":"  it('should read .htmlnanorc.json and minify HTML in production mode', async function () {\n    await bundle(path.join(__dirname, '/integration/htmlnano-config/index.html'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n\n    // minifyJson\n    assert(html.includes('<script type=application/json>{\"user\":\"me\"}</script>'));\n\n    // mergeStyles\n    assert(html.includes('<style>h1{color:red}div{font-size:20px}</style>'));\n    assert(!html.includes('sourceMappingURL'));\n\n    // minifySvg is false\n    assert(html.includes('<svg version=1.1 baseprofile=full width=300 height=200 xmlns=http://www.w3.org/2000/svg><rect width=100% height=100% fill=red></rect><circle cx=150 cy=100 r=80 fill=green></circle><text x=150 y=125 font-size=60 text-anchor=middle fill=white>SVG</text></svg>'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not minify default values inside HTML in production mode","suites":["html"],"updatePoint":{"line":376,"column":69,"index":13691},"line":376,"code":"  it('should not minify default values inside HTML in production mode', async function () {\n    let inputFile = path.join(__dirname, '/integration/htmlnano-defaults-form/index.html');\n    await bundle(inputFile, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    let inputSize = (await inputFS.stat(inputFile)).size;\n    let outputFile = path.join(distDir, '/index.html');\n    let outputSize = (await outputFS.stat(outputFile)).size;\n    assert(inputSize > outputSize);\n    let html = await outputFS.readFile(outputFile, 'utf8');\n    assert(html.includes('<input type=\"text\">'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not prepend the public path to assets with remote URLs","suites":["html"],"updatePoint":{"line":390,"column":67,"index":14305},"line":390,"code":"  it('should not prepend the public path to assets with remote URLs', async function () {\n    await bundle(path.join(__dirname, '/integration/html/index.html'));\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('<script src=\"https://unpkg.com/parcel-bundler\"></script>'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not prepend the public path to hash links","suites":["html"],"updatePoint":{"line":395,"column":54,"index":14629},"line":395,"code":"  it('should not prepend the public path to hash links', async function () {\n    await bundle(path.join(__dirname, '/integration/html/index.html'));\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('<a href=\"#hash_link\">'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect virtual paths","suites":["html"],"updatePoint":{"line":400,"column":33,"index":14897},"line":400,"code":"  it('should detect virtual paths', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-virtualpath/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'html',\n      assets: ['other.html']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not update root/main file in the bundles","suites":["html"],"updatePoint":{"line":410,"column":53,"index":15217},"line":410,"code":"  it('should not update root/main file in the bundles', async function () {\n    await bundle(path.join(__dirname, '/integration/html-root/index.html'));\n    let files = await outputFS.readdir(distDir);\n    for (let file of files) {\n      if (file !== 'index.html' && file.endsWith('.html')) {\n        let html = await outputFS.readFile(path.join(distDir, file), 'utf8');\n        assert(html.includes('index.html'));\n      }\n    }\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should preserve the spacing in the HTML tags","suites":["html"],"updatePoint":{"line":420,"column":50,"index":15650},"line":420,"code":"  it('should preserve the spacing in the HTML tags', async function () {\n    await bundle(path.join(__dirname, '/integration/html/index.html'));\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(/<i>hello<\\/i> <i>world<\\/i>/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support child bundles of different types","suites":["html"],"updatePoint":{"line":425,"column":53,"index":15940},"line":425,"code":"  it('should support child bundles of different types', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/child-bundle-different-types/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['main.js', 'util.js', 'other.js']\n    }, {\n      type: 'html',\n      assets: ['other.html']\n    }, {\n      type: 'js',\n      assets: ['index.js', 'util.js', 'other.js']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support circular dependencies","suites":["html"],"line":441,"code":"  it.skip('should support circular dependencies', async function () {","file":"html.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling HTM","suites":["html"],"updatePoint":{"line":460,"column":33,"index":16900},"line":460,"code":"  it('should support bundling HTM', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/htm-extension/index.htm'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.htm'],\n      type: 'html'\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect srcset attribute","suites":["html"],"updatePoint":{"line":471,"column":36,"index":17214},"line":471,"code":"  it('should detect srcset attribute', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-srcset/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'png',\n      assets: ['200x200.png']\n    }, {\n      type: 'png',\n      assets: ['300x300.png']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect srcset attribute of source element","suites":["html"],"updatePoint":{"line":487,"column":54,"index":17646},"line":487,"code":"  it('should detect srcset attribute of source element', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-source-srcset/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'png',\n      assets: ['200x200.png']\n    }, {\n      type: 'png',\n      assets: ['300x300.png']\n    }]);\n    const html = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    const source = html.match(/<source srcset=\".*>/)[0];\n    assert(source.split(', ').length === 3);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect imagesrcset attribute","suites":["html"],"updatePoint":{"line":506,"column":41,"index":18252},"line":506,"code":"  it('should detect imagesrcset attribute', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-imagesrcset/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'png',\n      assets: ['200x200.png']\n    }, {\n      type: 'png',\n      assets: ['300x300.png']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support webmanifest","suites":["html"],"line":522,"code":"  it.skip('should support webmanifest', async function () {","file":"html.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should treat webmanifest as an entry module so it doesn't get content hashed","suites":["html"],"line":538,"code":"  it.skip(\"should treat webmanifest as an entry module so it doesn't get content hashed\", async function () {","file":"html.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should bundle svg files correctly","suites":["html"],"updatePoint":{"line":551,"column":39,"index":19704},"line":551,"code":"  it('should bundle svg files correctly', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-svg/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'svg',\n      assets: ['file.svg']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore svgs referencing local symbols via <use xlink:href=\"#\">","suites":["html"],"updatePoint":{"line":561,"column":75,"index":20035},"line":561,"code":"  it('should ignore svgs referencing local symbols via <use xlink:href=\"#\">', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-svg-local-symbol/index.html'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('<svg><symbol id=\"all\"><rect width=\"100\" height=\"100\"/></symbol></svg><svg><use xlink:href=\"#all\" href=\"#all\"/></svg>'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bundle svg files using <image xlink:href=\"\"> correctly","suites":["html"],"updatePoint":{"line":572,"column":67,"index":20581},"line":572,"code":"  it('should bundle svg files using <image xlink:href=\"\"> correctly', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-svg-image/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'svg',\n      assets: ['file.svg']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support href attribute in <image /> in HTMLTransformer's collectDependencies","suites":["html"],"updatePoint":{"line":582,"column":89,"index":20932},"line":582,"code":"  it(\"should support href attribute in <image /> in HTMLTransformer's collectDependencies\", async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-image-href-attr/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'png',\n      assets: ['100x100.png']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bundle scripts inside svg","suites":["html"],"updatePoint":{"line":594,"column":38,"index":21320},"line":594,"code":"  it('should bundle scripts inside svg', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-svg-script/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['script-a.js']\n    }, {\n      type: 'js',\n      assets: ['script-b.js']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support data attribute of object element","suites":["html"],"updatePoint":{"line":607,"column":53,"index":21695},"line":607,"code":"  it('should support data attribute of object element', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-object/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'svg',\n      assets: ['file.svg']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve assets containing spaces","suites":["html"],"updatePoint":{"line":617,"column":45,"index":21999},"line":617,"code":"  it('should resolve assets containing spaces', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-spaces/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'html',\n      assets: ['other page.html']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should process inline JS","suites":["html"],"updatePoint":{"line":627,"column":30,"index":22299},"line":627,"code":"  it('should process inline JS', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-js/index.html'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n\n    // inline bundles are not output, but are apart of the bundleGraph\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let files = await outputFS.readdir(distDir);\n    // assert that the inline js files are not output\n    assert(!files.some(filename => filename.includes('js')));\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf-8');\n    assert(!html.includes('someArgument'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should process inline styles","suites":["html"],"updatePoint":{"line":657,"column":34,"index":23204},"line":657,"code":"  it('should process inline styles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-styles/index.html'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      type: 'jpg',\n      assets: ['bg.jpg']\n    }, {\n      type: 'jpg',\n      assets: ['img.jpg']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let bundles = b.getBundles();\n    let html = await outputFS.readFile(bundles.find(bundle => bundle.type === 'html').filePath, 'utf8');\n    let urls = [...html.matchAll(/url\\(([^)]*)\\)/g)].map(m => m[1]);\n    assert.strictEqual(urls.length, 2);\n    for (let url of urls) {\n      assert(bundles.find(bundle => bundle.bundleBehavior !== 'inline' && path.basename(bundle.filePath) === url));\n    }\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should process inline element styles","suites":["html"],"updatePoint":{"line":693,"column":42,"index":24266},"line":693,"code":"  it('should process inline element styles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-styles-element/index.html'), {\n      shouldDisableCache: false\n    });\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should process inline styles using lang","suites":["html"],"updatePoint":{"line":711,"column":45,"index":24742},"line":711,"code":"  it('should process inline styles using lang', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-sass/index.html'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('<style>.index{color:#00f}</style>'));\n    assert(!html.includes('sourceMappingURL'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should process inline non-js scripts","suites":["html"],"updatePoint":{"line":728,"column":42,"index":25320},"line":728,"code":"  it('should process inline non-js scripts', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-coffeescript/index.html'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('alert(\"Hello, World!\")'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle inline css with @imports","suites":["html"],"updatePoint":{"line":744,"column":44,"index":25848},"line":744,"code":"  it('should handle inline css with @imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-css-import/index.html'));\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['index.html', 'test.css']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(!html.includes('@import'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not modify inline importmaps","suites":["html"],"updatePoint":{"line":756,"column":41,"index":26294},"line":756,"code":"  it('should not modify inline importmaps', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-importmap/index.html'), {});\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(html.includes('/node_modules/lit1.3.0/'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should expose top level declarations globally in inline <script> tags","suites":["html"],"updatePoint":{"line":765,"column":75,"index":26717},"line":765,"code":"  it('should expose top level declarations globally in inline <script> tags', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-js-script/globals.html'));\n    let logs = [];\n    let ctx = await run(b, {\n      log(bar, baz) {\n        logs.push([bar, baz]);\n      }\n    }, {\n      require: false\n    });\n    let output = ctx.output;\n    assert.equal(output.x, 2);\n    assert.equal(output.y, 'undefined');\n    assert.equal(output.z, 4);\n    assert.equal(typeof output.bar, 'function');\n    assert.equal(output.Test, 'undefined');\n    assert.equal(typeof output.Foo, 'function');\n    assert.equal(typeof output.baz, 'function');\n\n    // x is a let, so is \"global\" but not part of the global object\n    assert(!('x' in ctx));\n    assert(!('y' in ctx));\n    assert.equal(ctx.z, 4);\n    assert.equal(typeof ctx.bar, 'function');\n    assert(!('Test' in ctx));\n    assert(!('Foo' in ctx));\n    assert.equal(typeof ctx.baz, 'function');\n    assert.deepEqual(logs, [['undefined', 'function'], ['function', 'function'], ['function', 'function']]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on imports in inline scripts without type=\"module\"","suites":["html"],"updatePoint":{"line":835,"column":69,"index":29358},"line":835,"code":"  it('should error on imports in inline scripts without type=\"module\"', async function () {\n    let errored = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/html-inline-js-script/error.html'));\n    } catch (err) {\n      assert.equal(err.message, 'Browser scripts cannot have imports or exports.');\n      assert.deepEqual(err.diagnostics, [{\n        message: 'Browser scripts cannot have imports or exports.',\n        origin: '@parcel/transformer-js',\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/html-inline-js-script/error.html'),\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 5,\n              column: 7\n            },\n            end: {\n              line: 5,\n              column: 24\n            }\n          }]\n        }],\n        hints: ['Add the type=\"module\" attribute to the <script> tag.'],\n        documentationURL: 'https://parceljs.org/languages/javascript/#classic-scripts'\n      }]);\n      errored = true;\n    }\n    assert(errored);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not import swc/helpers without type=\"module\"","suites":["html"],"updatePoint":{"line":865,"column":57,"index":30406},"line":865,"code":"  it('should not import swc/helpers without type=\"module\"', async function () {\n    await bundle(path.join(__dirname, '/integration/html-js-not-import-swc-helpers-without-module/index.html'), {\n      defaultTargetOptions: {\n        engines: {\n          // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#browser_compatibility\n          browsers: ['Chrome 48']\n        }\n      }\n    });\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(!html.includes('swc/helpers'));\n    assert(html.includes('slicedToArray'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should allow imports and requires in inline <script> tags","suites":["html"],"updatePoint":{"line":878,"column":63,"index":31026},"line":878,"code":"  it('should allow imports and requires in inline <script> tags', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-js-require/index.html'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.html', 'test.js']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('console.log(\"test\")'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support protocol-relative urls","suites":["html"],"updatePoint":{"line":894,"column":43,"index":31559},"line":894,"code":"  it('should support protocol-relative urls', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-protocol-relative/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'css',\n      assets: ['index.css']\n    }]);\n    for (let bundle of b.getBundles()) {\n      let contents = await outputFS.readFile(bundle.filePath, 'utf8');\n      assert(contents.includes('//unpkg.com/xyz'));\n    }\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support inline <script type=\"module\">","suites":["html"],"updatePoint":{"line":908,"column":50,"index":32050},"line":908,"code":"  it('should support inline <script type=\"module\">', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-js-module/index.html'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('<script type=\"module\">'));\n    assert(html.includes('document.write(\"Hello world\")'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile inline <script type=\"module\"> to non-module if not all engines support esmodules","suites":["html"],"updatePoint":{"line":925,"column":101,"index":32694},"line":925,"code":"  it('should compile inline <script type=\"module\"> to non-module if not all engines support esmodules', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-js-module/index.html'), {\n      defaultTargetOptions: {\n        mode: 'production',\n        shouldScopeHoist: true,\n        engines: {\n          browsers: '>= 0.25%'\n        }\n      }\n    });\n    await assertBundles(b, [{\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(!html.includes('<script type=\"module\">'));\n    assert(html.includes('<script>'));\n    assert(html.includes('document.write(\"Hello world\")'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile a module and nomodule script when not all engines support esmodules natively","suites":["html"],"updatePoint":{"line":947,"column":97,"index":33469},"line":947,"code":"  it('should compile a module and nomodule script when not all engines support esmodules natively', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js/index.html'), {\n      defaultTargetOptions: {\n        mode: 'production',\n        shouldScopeHoist: true,\n        engines: {\n          browsers: '>= 0.25%'\n        }\n      }\n    });\n    await assertBundles(b, [{\n      type: 'js',\n      assets: ['index.js', 'other.js']\n    }, {\n      type: 'js',\n      assets: ['index.js', 'other.js']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let bundles = b.getBundles();\n    let html = await outputFS.readFile(bundles.find(b => b.type === 'html').filePath, 'utf8');\n    assert(html.includes('<script type=\"module\" src='));\n    assert(/<script src=\".*?\" nomodule/.test(html));\n    let js = await outputFS.readFile(bundles.find(b => b.type === 'js' && b.env.outputFormat === 'esmodule').filePath, 'utf8');\n    assert(/class \\$[a-f0-9]+\\$var\\$Useless \\{/.test(js));\n    js = await outputFS.readFile(bundles.find(b => b.type === 'js' && b.env.outputFormat === 'global').filePath, 'utf8');\n    assert(!/class \\$[a-f0-9]+\\$var\\$Useless \\{/.test(js));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove type=\"module\" when not scope hoisting","suites":["html"],"updatePoint":{"line":976,"column":57,"index":34639},"line":976,"code":"  it('should remove type=\"module\" when not scope hoisting', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js/index.html'));\n    await assertBundles(b, [{\n      type: 'js',\n      assets: ['esmodule-helpers.js', 'index.js', 'other.js']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(!html.includes('<script type=\"module\"'));\n    assert(html.includes('<script src='));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not add a nomodule version when all browsers support esmodules","suites":["html"],"updatePoint":{"line":989,"column":75,"index":35187},"line":989,"code":"  it('should not add a nomodule version when all browsers support esmodules', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js/index.html'), {\n      defaultTargetOptions: {\n        mode: 'production',\n        shouldScopeHoist: true,\n        engines: {\n          browsers: 'last 1 Chrome version'\n        }\n      }\n    });\n    await assertBundles(b, [{\n      type: 'js',\n      assets: ['index.js', 'other.js']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('<script type=\"module\" src='));\n    assert(!/<script src=\".*?\" nomodule/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on imports in scripts without type=\"module\"","suites":["html"],"updatePoint":{"line":1010,"column":62,"index":35894},"line":1010,"code":"  it('should error on imports in scripts without type=\"module\"', async function () {\n    let errored = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/html-js/error.html'));\n    } catch (err) {\n      assert.equal(err.message, 'Browser scripts cannot have imports or exports.');\n      assert.deepEqual(err.diagnostics, [{\n        message: 'Browser scripts cannot have imports or exports.',\n        origin: '@parcel/transformer-js',\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/html-js/index.js'),\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 29\n            }\n          }]\n        }, {\n          filePath: path.join(__dirname, '/integration/html-js/error.html'),\n          codeHighlights: [{\n            message: 'The environment was originally created here',\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 32\n            }\n          }]\n        }],\n        hints: ['Add the type=\"module\" attribute to the <script> tag.'],\n        documentationURL: 'https://parceljs.org/languages/javascript/#classic-scripts'\n      }]);\n      errored = true;\n    }\n    assert(errored);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly bundle loaders for nested dynamic imports","suites":["html"],"updatePoint":{"line":1053,"column":64,"index":37283},"line":1053,"code":"  it('should correctly bundle loaders for nested dynamic imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js-shared-dynamic-nested/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        engines: {\n          browsers: '>= 0.25%'\n        }\n      }\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'index.js', 'index.js', 'index.js', 'js-loader.js']\n    }, {\n      type: 'js',\n      assets: ['bundle-manifest.js', 'index.js', 'index.js', 'index.js']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['simpleHasher.js']\n    }, {\n      type: 'js',\n      assets: ['simpleHasher.js']\n    }]);\n    let res = await run(b, {\n      output: null\n    }, {\n      require: false\n    });\n    assert.deepEqual(await res.output, ['hasher', ['hasher', 'hasher']]);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support shared bundles between multiple inline scripts","suites":["html"],"updatePoint":{"line":1086,"column":67,"index":38270},"line":1086,"code":"  it('should support shared bundles between multiple inline scripts', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-inline-js-shared/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        shouldOptimize: false\n      }\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['lodash.js']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('<script type=\"module\" src=\"'));\n    assert(html.includes('<script type=\"module\">'));\n    assert(html.includes('.add(1, 2)'));\n    assert(html.includes('.add(2, 3)'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"inserts sibling bundles into html in the correct order (no head)","suites":["html"],"updatePoint":{"line":1113,"column":70,"index":39131},"line":1113,"code":"  it('inserts sibling bundles into html in the correct order (no head)', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js-shared/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['async.js']\n    }, {\n      type: 'js',\n      assets: ['bundle-manifest.js', 'get-worker-url.js', 'index.js', 'lodash.js']\n    }, {\n      name: 'index.html',\n      type: 'html',\n      assets: ['index.html']\n    },\n    // {\n    //   type: 'js',\n    //   assets: ['lodash.js'],\n    // },\n    {\n      type: 'js',\n      assets: ['worker.js', 'lodash.js']\n    }]);\n\n    // let lodashSibling = path.basename(\n    //   b.getBundles().find(v => v.getEntryAssets().length === 0).filePath,\n    // );\n\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    let insertedBundles = [];\n    let regex = /<script (?:type=\"[^\"]+\" )?src=\"([^\"]*)\"><\\/script>/g;\n    let match;\n    while ((match = regex.exec(html)) !== null) {\n      insertedBundles.push(path.basename(match[1]));\n    }\n    assert.equal(insertedBundles.length, 1);\n    // assert.equal(insertedBundles.length, 2);\n    // assert.equal(insertedBundles[0], lodashSibling);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"inserts sibling bundles into html in the correct order (head)","suites":["html"],"updatePoint":{"line":1156,"column":67,"index":40425},"line":1156,"code":"  it('inserts sibling bundles into html in the correct order (head)', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js-shared-head/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['async.js']\n    }, {\n      type: 'js',\n      assets: ['bundle-manifest.js', 'get-worker-url.js', 'index.js', 'lodash.js']\n    }, {\n      name: 'index.html',\n      type: 'html',\n      assets: ['index.html']\n    },\n    // {\n    //   type: 'js',\n    //   assets: ['lodash.js'],\n    // },\n    {\n      type: 'js',\n      assets: ['worker.js', 'lodash.js']\n    }]);\n\n    // let lodashSibling = path.basename(\n    //   b.getBundles().find(v => v.getEntryAssets().length === 0).filePath,\n    // );\n\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    let insertedBundles = [];\n    let regex = /<script (?:type=\"[^\"]+\" )?src=\"([^\"]*)\"><\\/script>/g;\n    let match;\n    while ((match = regex.exec(html)) !== null) {\n      insertedBundles.push(path.basename(match[1]));\n    }\n    assert.equal(insertedBundles.length, 1);\n    // assert.equal(insertedBundles.length, 2);\n    // assert.equal(insertedBundles[0], lodashSibling);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"inserts sibling bundles into html with nomodule or type=module","suites":["html"],"updatePoint":{"line":1199,"column":68,"index":41725},"line":1199,"code":"  it('inserts sibling bundles into html with nomodule or type=module', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js-shared-nomodule/*.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        shouldOptimize: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'a.html',\n      assets: ['a.html']\n    }, {\n      type: 'js',\n      assets: ['a.js']\n    }, {\n      type: 'js',\n      assets: ['a.js']\n    }, {\n      name: 'b.html',\n      assets: ['b.html']\n    }, {\n      type: 'js',\n      assets: ['b.js']\n    }, {\n      type: 'js',\n      assets: ['b.js']\n    }, {\n      type: 'js',\n      assets: ['lib.js']\n    }, {\n      type: 'js',\n      assets: ['lib.js']\n    }]);\n    for (let file of b.getBundles().filter(b => b.type === 'html').map(b => b.filePath)) {\n      let html = await outputFS.readFile(file, 'utf8');\n      let noModuleScripts = [];\n      let moduleScripts = [];\n      let regex = /<script ([^>]*)><\\/script>/g;\n      let match;\n      while ((match = regex.exec(html)) !== null) {\n        let attributes = new Map(match[1].split(' ').map(a => a.split('=')));\n        let url = attributes.get('src').replace(/\"/g, '');\n        assert(url);\n        if (attributes.get('type') === '\"module\"') {\n          assert.strictEqual(attributes.size, 2);\n          moduleScripts.push(path.basename(url));\n        } else {\n          assert.strictEqual(attributes.size, 3);\n          assert(attributes.get('nomodule'));\n          assert(attributes.get('defer'));\n          noModuleScripts.push(path.basename(url));\n        }\n      }\n      for (let scripts of [moduleScripts, noModuleScripts]) {\n        assert.strictEqual(scripts.length, 2);\n        assert(b.getBundles().find(b => b.filePath.endsWith(scripts[0])).getMainEntry() == null);\n        assert(b.getBundles().find(b => b.filePath.endsWith(scripts[1])).getMainEntry());\n      }\n    }\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should isolate async scripts","suites":["html"],"updatePoint":{"line":1259,"column":34,"index":43633},"line":1259,"code":"  it('should isolate async scripts', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-async-script/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        shouldOptimize: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      assets: ['a.js', 'c.js']\n    }, {\n      assets: ['b.js', 'c.js']\n    }]);\n    let output = [];\n    await run(b, {\n      output(o) {\n        output.push(o);\n      }\n    });\n\n    // could run in either order.\n    assert(output.sort(), ['a', 'b', 'c']);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should isolate classic scripts from nomodule scripts","suites":["html"],"updatePoint":{"line":1285,"column":58,"index":44293},"line":1285,"code":"  it('should isolate classic scripts from nomodule scripts', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-isolate-script/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        shouldOptimize: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      assets: ['a.js', 'bundle-manifest.js']\n    }, {\n      assets: ['a.js', 'bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['b.js', 'bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['c.js']\n    }, {\n      assets: ['c.js']\n    }]);\n    let output = [];\n    await run(b, {\n      output(o) {\n        output.push(o);\n      }\n    });\n\n    // could run in either order.\n    assert(output.sort(), ['a', 'b', 'c']);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support multiple entries with shared sibling bundles","suites":["html"],"updatePoint":{"line":1317,"column":65,"index":45210},"line":1317,"code":"  it('should support multiple entries with shared sibling bundles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/shared-sibling-entries/*.html'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n\n    // Different assertion for experimental bundler due to shared bundle size calculation differences\n    if (process.env.PARCEL_TEST_EXPERIMENTAL_BUNDLER) {\n      assertBundles(b, [{\n        name: 'a.html',\n        type: 'html',\n        assets: ['a.html']\n      }, {\n        name: 'b.html',\n        type: 'html',\n        assets: ['b.html']\n      }, {\n        name: 'c.html',\n        type: 'html',\n        assets: ['c.html']\n      }, {\n        type: 'js',\n        assets: ['a.html', 'shared.js']\n      }, {\n        type: 'js',\n        assets: ['b.html', 'shared.js']\n      }, {\n        type: 'js',\n        assets: ['c.html', 'shared.js']\n      }, {\n        type: 'css',\n        assets: ['other.css']\n      }, {\n        type: 'css',\n        assets: ['shared.css']\n      }]);\n    } else {\n      assertBundles(b, [{\n        name: 'a.html',\n        type: 'html',\n        assets: ['a.html']\n      }, {\n        name: 'b.html',\n        type: 'html',\n        assets: ['b.html']\n      }, {\n        name: 'c.html',\n        type: 'html',\n        assets: ['c.html']\n      }, {\n        type: 'js',\n        assets: ['a.html', 'shared.js']\n      }, {\n        type: 'js',\n        assets: ['b.html', 'shared.js']\n      }, {\n        type: 'js',\n        assets: ['c.html', 'shared.js']\n      }, {\n        type: 'css',\n        assets: ['shared.css', 'other.css']\n      }]);\n    }\n    // Both HTML files should point to the sibling CSS file\n    let html = await outputFS.readFile(path.join(distDir, 'a.html'), 'utf8');\n    assert(/<link rel=\"stylesheet\" href=\"\\/a\\.[a-z0-9]+\\.css\">/.test(html));\n    html = await outputFS.readFile(path.join(distDir, 'b.html'), 'utf8');\n    assert(/<link rel=\"stylesheet\" href=\"\\/a\\.[a-z0-9]+\\.css\">/.test(html));\n    html = await outputFS.readFile(path.join(distDir, 'c.html'), 'utf8');\n    assert(/<link rel=\"stylesheet\" href=\"\\/a\\.[a-z0-9]+\\.css\">/.test(html));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert JS sibling bundle script tags in the correct order","suites":["html"],"updatePoint":{"line":1389,"column":70,"index":47359},"line":1389,"code":"  it('should insert JS sibling bundle script tags in the correct order', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/interop-async/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        shouldOptimize: false\n      }\n    });\n    let bundles = b.getBundles();\n    assertBundles(b, [{\n      name: 'index.html',\n      type: 'html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js', 'index.js', 'index.js', 'index.js', 'client.js', 'bundle-manifest.js']\n    }, {\n      type: 'js',\n      assets: ['viewer.js']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    let insertedBundles = [];\n    let regex = /<script (?:type=\"[^\"]+\" )?src=\"([^\"]*)\"><\\/script>/g;\n    let match;\n    while ((match = regex.exec(html)) !== null) {\n      let bundle = bundles.find(b => path.basename(b.filePath) === path.basename(match[1]));\n      insertedBundles.push(bundle);\n    }\n    assert.equal(insertedBundles.length, 1);\n    let res = await run(b, {\n      output: null\n    }, {\n      require: false\n    });\n    assert.deepEqual(await res.output, ['client', 'client', 'viewer']);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not point to unrelated sibling bundles","suites":["html"],"updatePoint":{"line":1425,"column":51,"index":48589},"line":1425,"code":"  it('should not point to unrelated sibling bundles', async function () {\n    await bundle(path.join(__dirname, '/integration/shared-sibling-entries-multiple/*.html'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n\n    // a.html should point to a CSS bundle containing a.css as well as\n    // reuse the b.css bundle from b.html.\n    let html = await outputFS.readFile(path.join(distDir, 'a.html'), 'utf8');\n    assert.equal(html.match(/<link rel=\"stylesheet\" href=\"\\/\\w+\\.[a-z0-9]+\\.css\">/g).length, 2);\n\n    // a.html should reference a.js only\n    assert.equal(html.match(/a\\.[a-z0-9]+\\.js/g).length, 1);\n    assert.equal(html.match(/b\\.[a-z0-9]+\\.js/g), null);\n    let css = await outputFS.readFile(path.join(distDir, html.match(/\\/\\w+\\.[a-z0-9]+\\.css/g)[0]), 'utf8');\n    assert(css.includes('.a {'));\n    assert(!css.includes('.b {'));\n\n    // b.html should point to a CSS bundle containing only b.css\n    // It should not point to the bundle containing a.css from a.html\n    html = await outputFS.readFile(path.join(distDir, 'b.html'), 'utf8');\n    assert.equal(html.match(/<link rel=\"stylesheet\" href=\"\\/\\w+\\.[a-z0-9]+\\.css\">/g).length, 1);\n\n    // b.html should reference b.js only\n    assert.equal(html.match(/a\\.[a-z0-9]+\\.js/g), null);\n    assert.equal(html.match(/b\\.[a-z0-9]+\\.js/g).length, 1);\n    css = await outputFS.readFile(path.join(distDir, html.match(/\\/\\w+\\.[a-z0-9]+\\.css/)[0]), 'utf8');\n    assert(!css.includes('.a {'));\n    assert(css.includes('.b {'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support split bundles with many pages","suites":["html"],"updatePoint":{"line":1456,"column":50,"index":50107},"line":1456,"code":"  it('should support split bundles with many pages', async function () {\n    await bundle(path.join(__dirname, '/integration/shared-many/*.html'), {\n      mode: 'production'\n    });\n    // Forked this because size of shared bundles in default bundler is estimated including itself and children (may appear larger and don't get created)\n    if (process.env.PARCEL_TEST_EXPERIMENTAL_BUNDLER) {\n      let html = await outputFS.readFile(path.join(distDir, 'a.html'), 'utf8');\n      assert.equal(html.match(/<script/g).length, 2);\n      html = await outputFS.readFile(path.join(distDir, 'b.html'), 'utf8');\n      assert.equal(html.match(/<script/g).length, 2);\n      html = await outputFS.readFile(path.join(distDir, 'c.html'), 'utf8');\n      assert.equal(html.match(/<script/g).length, 2);\n      html = await outputFS.readFile(path.join(distDir, 'd.html'), 'utf8');\n      assert.equal(html.match(/<script/g).length, 2);\n      html = await outputFS.readFile(path.join(distDir, 'e.html'), 'utf8');\n      assert.equal(html.match(/<script/g).length, 1);\n      html = await outputFS.readFile(path.join(distDir, 'f.html'), 'utf8');\n      assert.equal(html.match(/<script/g).length, 1);\n\n      // b.html hitting the parallel request limit should not prevent g.html from being optimized\n      html = await outputFS.readFile(path.join(distDir, 'g.html'), 'utf8');\n      assert.equal(html.match(/<script/g).length, 1);\n    } else {\n      let html = await outputFS.readFile(path.join(distDir, 'a.html'), 'utf8');\n      assert.equal(html.match(/<script/g).length, 3);\n      html = await outputFS.readFile(path.join(distDir, 'b.html'), 'utf8');\n      assert.equal(html.match(/<script/g).length, 5);\n      html = await outputFS.readFile(path.join(distDir, 'c.html'), 'utf8');\n      assert.equal(html.match(/<script/g).length, 5);\n      html = await outputFS.readFile(path.join(distDir, 'd.html'), 'utf8');\n      assert.equal(html.match(/<script/g).length, 4);\n      html = await outputFS.readFile(path.join(distDir, 'e.html'), 'utf8');\n      assert.equal(html.match(/<script/g).length, 4);\n      html = await outputFS.readFile(path.join(distDir, 'f.html'), 'utf8');\n      assert.equal(html.match(/<script/g).length, 3);\n\n      // b.html hitting the parallel request limit should not prevent g.html from being optimized\n      html = await outputFS.readFile(path.join(distDir, 'g.html'), 'utf8');\n      assert.equal(html.match(/<script/g).length, 5);\n    }\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not add CSS to a worker bundle group","suites":["html"],"updatePoint":{"line":1497,"column":49,"index":52549},"line":1497,"code":"  it('should not add CSS to a worker bundle group', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/shared-sibling-worker-css/index.html'));\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['style.css']\n    }, {\n      type: 'html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['a.js', 'worker.js', 'esmodule-helpers.js']\n    }, {\n      type: 'js',\n      assets: ['a.js', 'bundle-url.js', 'esmodule-helpers.js', 'get-worker-url.js', 'index.js']\n    }]);\n    let htmlBundle = b.getBundles().find(b => b.type === 'html');\n    let htmlSiblings = b.getReferencedBundles(htmlBundle);\n    assert.equal(htmlSiblings.length, 2);\n    assert(htmlSiblings.some(b => b.type === 'js'));\n    assert(htmlSiblings.some(b => b.type === 'css'));\n    let worker = b.getChildBundles(htmlSiblings.find(b => b.type === 'js'));\n    assert.equal(worker.length, 1);\n    let workerSiblings = b.getReferencedBundles(worker[0]);\n    assert.equal(workerSiblings.length, 0);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly add sibling bundles to all using bundles","suites":["html"],"updatePoint":{"line":1522,"column":63,"index":53580},"line":1522,"code":"  it('should correctly add sibling bundles to all using bundles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/shared-sibling/*.html'));\n    assertBundles(b, [{\n      type: 'html',\n      assets: ['form.html']\n    }, {\n      type: 'js',\n      assets: ['form.js', 'a.js', 'a.module.css', 'esmodule-helpers.js']\n    }, {\n      type: 'css',\n      assets: ['a.module.css']\n    }, {\n      type: 'html',\n      assets: ['searchfield.html']\n    }, {\n      type: 'js',\n      assets: ['searchfield.js', 'a.js', 'a.module.css', 'b.js', 'esmodule-helpers.js']\n    }, {\n      type: 'html',\n      assets: ['searchfield2.html']\n    }, {\n      type: 'js',\n      assets: ['searchfield2.js', 'a.js', 'a.module.css', 'b.js', 'esmodule-helpers.js']\n    }]);\n    for (let htmlBundle of b.getBundles().filter(b => b.type === 'html')) {\n      let htmlSiblings = b.getReferencedBundles(htmlBundle, true).map(b => b.type).sort();\n      assert.deepEqual(htmlSiblings, ['css', 'js']);\n    }\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove duplicate assets from sibling bundles","suites":["html"],"updatePoint":{"line":1551,"column":57,"index":54578},"line":1551,"code":"  it('should remove duplicate assets from sibling bundles', async function () {\n    let bundleGraph = await bundle(path.join(__dirname, '/integration/shared-sibling-duplicate/*.html'), {\n      mode: 'production'\n    });\n    bundleGraph.traverseBundles(bundle => {\n      bundle.traverseAssets(asset => {\n        let bundles = bundleGraph.getBundlesWithAsset(asset);\n        assert.equal(bundles.length, 1, `asset ${asset.filePath} is duplicated`);\n      });\n    });\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support split bundles with many pages with esmodule output","suites":["html"],"updatePoint":{"line":1562,"column":71,"index":55063},"line":1562,"code":"  it('should support split bundles with many pages with esmodule output', async function () {\n    await bundle(path.join(__dirname, '/integration/shared-many-esm/*.html'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let checkHtml = async filename => {\n      // Find all scripts referenced in the HTML file\n      let html = await outputFS.readFile(path.join(distDir, filename), 'utf8');\n      let re = /<script.*?src=\"(.*?)\"/g;\n      let match;\n      let scripts = new Set();\n      while (match = re.exec(html)) {\n        scripts.add(path.join(distDir, match[1]));\n      }\n      assert(scripts.size > 0, 'no scripts found');\n\n      // Ensure that those scripts don't import anything other than what's in the HTML.\n      for (let script of scripts) {\n        let js = await outputFS.readFile(script, 'utf8');\n        let re = /import .*? from \"(.*?)\"/g;\n        let match;\n        while (match = re.exec(js)) {\n          let imported = path.join(distDir, match[1]);\n          assert(scripts.has(imported), `unknown script ${match[1]} imported in ${path.basename(script)}`);\n        }\n      }\n    };\n    for (let letter of ['a', 'b', 'c', 'd', 'e', 'f', 'g']) {\n      await checkHtml(letter + '.html');\n    }\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should include the correct paths when using multiple entries and referencing style from html and js","suites":["html"],"updatePoint":{"line":1594,"column":105,"index":56348},"line":1594,"code":"  it('should include the correct paths when using multiple entries and referencing style from html and js', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-multi-entry/*.html'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      name: 'a.html',\n      type: 'html',\n      assets: ['a.html']\n    }, {\n      name: 'b.html',\n      type: 'html',\n      assets: ['b.html']\n    }, {\n      type: 'css',\n      assets: ['style.css']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }]);\n    let firstHtmlFile = await outputFS.readFile(path.join(distDir, 'a.html'), 'utf8');\n    let secondHtmlFile = await outputFS.readFile(path.join(distDir, 'b.html'), 'utf8');\n    let bundles = b.getBundles();\n    let cssBundle = path.basename(bundles.find(bundle => bundle.filePath.endsWith('.css')).filePath);\n    let jsBundle = path.basename(bundles.find(bundle => bundle.filePath.endsWith('.js')).filePath);\n    assert(firstHtmlFile.includes(cssBundle), `a.html should include a reference to ${cssBundle}`);\n    assert(secondHtmlFile.includes(cssBundle), `b.html should include a reference to ${cssBundle}`);\n    assert(firstHtmlFile.includes(jsBundle), `a.html should include a reference to ${jsBundle}`);\n    assert(secondHtmlFile.includes(jsBundle), `b.html should include a reference to ${jsBundle}`);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate parent bundle when inline bundles change","suites":["html"],"updatePoint":{"line":1625,"column":64,"index":57702},"line":1625,"code":"  it('should invalidate parent bundle when inline bundles change', async function () {\n    // copy into memory fs\n    await ncp(path.join(__dirname, '/integration/html-inline-js-require'), path.join(__dirname, '/html-inline-js-require'));\n    let distDir = path.join(outputFS.cwd(), 'dist');\n    let b = await bundler(path.join(__dirname, '/html-inline-js-require/index.html'), {\n      inputFS: overlayFS,\n      shouldDisableCache: false,\n      defaultTargetOptions: {\n        distDir\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let html = await outputFS.readFile('/dist/index.html', 'utf8');\n    assert(html.includes(`console.log(\"test\")`));\n    await overlayFS.writeFile(path.join(__dirname, '/html-inline-js-require/test.js'), \"console.log('foo')\");\n    await getNextBuild(b);\n    html = await outputFS.readFile(path.join(distDir, '/index.html'), 'utf8');\n    assert(html.includes(`console.log(\"foo\")`));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should invalidate parent bundle when nested inline bundles change","suites":["html"],"updatePoint":{"line":1645,"column":71,"index":58662},"line":1645,"code":"  it('should invalidate parent bundle when nested inline bundles change', async function () {\n    // copy into memory fs\n    await ncp(path.join(__dirname, '/integration/html-inline-js-nested'), path.join(__dirname, '/html-inline-js-nested'));\n    let distDir = path.join(outputFS.cwd(), 'dist');\n    let b = await bundler(path.join(__dirname, '/html-inline-js-nested/index.html'), {\n      inputFS: overlayFS,\n      shouldDisableCache: false,\n      defaultTargetOptions: {\n        distDir\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let html = await outputFS.readFile('/dist/index.html', 'utf8');\n    assert(html.includes('module.exports = \"hello world\"'));\n    assert(html.includes('console.log'));\n    await overlayFS.writeFile(path.join(__dirname, '/html-inline-js-nested/test.txt'), 'foo bar');\n    await getNextBuild(b);\n    html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(!html.includes('module.exports = \"hello world\"'));\n    assert(html.includes('module.exports = \"foo bar\"'));\n    assert(html.includes('console.log'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline data-urls","suites":["html"],"updatePoint":{"line":1668,"column":29,"index":59730},"line":1668,"code":"  it('should inline data-urls', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/data-url/index.html'), {\n      defaultTargetOptions: {\n        sourceMaps: false\n      }\n    });\n    let contents = await outputFS.readFile(b.getBundles().find(b => b.type === 'html').filePath, 'utf8');\n    assert.equal(contents.trim(), `<img src=\"data:image/svg+xml,%3Csvg%20width%3D%22120%22%20height%3D%22120%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%20%20%3Cfilter%20id%3D%22blur-_.%21~%2a%22%3E%0A%20%20%20%20%3CfeGaussianBlur%20stdDeviation%3D%225%22%3E%3C%2FfeGaussianBlur%3E%0A%20%20%3C%2Ffilter%3E%0A%20%20%3Ccircle%20cx%3D%2260%22%20cy%3D%2260%22%20r%3D%2250%22%20fill%3D%22green%22%20filter%3D%22url%28%27%23blur-_.%21~%2a%27%29%22%3E%3C%2Fcircle%3E%0A%3C%2Fsvg%3E%0A\">`);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should print a diagnostic for invalid bundler options","suites":["html"],"updatePoint":{"line":1677,"column":59,"index":60576},"line":1677,"code":"  it('should print a diagnostic for invalid bundler options', async () => {\n    let dir = path.join(__dirname, 'integration/invalid-bundler-config');\n    let pkg = path.join(dir, 'package.json');\n    let code = await inputFS.readFileSync(pkg, 'utf8');\n    if (process.env.PARCEL_TEST_EXPERIMENTAL_BUNDLER) {\n      await assert.rejects(() => bundle(path.join(dir, 'index.html')), {\n        name: 'BuildError',\n        diagnostics: [{\n          message: 'Invalid config for @parcel/bundler-experimental',\n          origin: '@parcel/bundler-experimental',\n          codeFrames: [{\n            filePath: pkg,\n            language: 'json',\n            code,\n            codeHighlights: [{\n              message: 'Did you mean \"minBundleSize\", \"minBundles\"?',\n              start: {\n                column: 30,\n                line: 3\n              },\n              end: {\n                column: 45,\n                line: 3\n              }\n            }]\n          }]\n        }]\n      });\n    } else {\n      await assert.rejects(() => bundle(path.join(dir, 'index.html')), {\n        name: 'BuildError',\n        diagnostics: [{\n          message: 'Invalid config for @parcel/bundler-default',\n          origin: '@parcel/bundler-default',\n          codeFrames: [{\n            filePath: pkg,\n            language: 'json',\n            code,\n            codeHighlights: [{\n              message: 'Did you mean \"minBundleSize\", \"minBundles\"?',\n              start: {\n                column: 30,\n                line: 3\n              },\n              end: {\n                column: 45,\n                line: 3\n              }\n            }]\n          }]\n        }]\n      });\n    }\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should escape inline script tags","suites":["html"],"updatePoint":{"line":1731,"column":38,"index":62230},"line":1731,"code":"  it('should escape inline script tags', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/html-inline-escape/script.html'));\n    let output;\n    await run(b, {\n      output(o) {\n        output = o;\n      }\n    });\n    assert.deepEqual(output, {\n      a: '<script></script>',\n      b: '<!-- test',\n      c: '<SCRIPT></SCRIPT>'\n    });\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should share older JS sibling (script) assets to younger siblings","suites":["html"],"updatePoint":{"line":1745,"column":71,"index":62633},"line":1745,"code":"  it('should share older JS sibling (script) assets to younger siblings', async function () {\n    // JS script tags are siblings to a common parent, and are marked as such by parallel dependency priority\n    // Becuase of load order any older sibling (and it's assets) are loaded before any subsequent sibling\n    // Which means no younger sibling should have to reference sibling bundles for assets in them\n    let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/sibling-dependencies/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      assets: ['a.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['b.js']\n    }]);\n    let youngerSibling; // bundle containing younger sibling, b.js\n    let olderSibling; // bundle containing old sibling, a.js\n    b.traverseBundles(bundle => {\n      bundle.traverseAssets(asset => {\n        if (asset.filePath.includes('b.js')) {\n          youngerSibling = bundle;\n        } else if (asset.filePath.includes('a.js')) {\n          olderSibling = bundle;\n        }\n      });\n    });\n    assert(b.getReferencedBundles(youngerSibling).filter(b => b == olderSibling).length == 0);\n    let res = await run(b, {\n      output: null\n    }, {\n      require: false\n    });\n    assert.equal(res.output, 'a');\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should escape quotes in inline style attributes and style tags","suites":["html"],"updatePoint":{"line":1777,"column":68,"index":63947},"line":1777,"code":"  it('should escape quotes in inline style attributes and style tags', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/html-inline-escape/style.html'));\n    let output = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(output.includes(`content: &quot;hi&quot;`));\n    assert(output.includes('<\\\\/style>'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with bundle names that have colons in them","suites":["html"],"updatePoint":{"line":1783,"column":60,"index":64306},"line":1783,"code":"  it('should work with bundle names that have colons in them', async function () {\n    if (process.platform === 'win32') {\n      return;\n    }\n\n    // Windows paths cannot contain colons and will fail to git clone, so write the file here (in memory).\n    await overlayFS.mkdirp(path.join(__dirname, 'integration/url-colon'));\n    await overlayFS.writeFile(path.join(__dirname, 'integration/url-colon/a:b:c.html'), '<p>Test</p>');\n    let b = await bundle(path.join(__dirname, 'integration/url-colon/relative.html'), {\n      inputFS: overlayFS\n    });\n    assertBundles(b, [{\n      name: 'relative.html',\n      assets: ['relative.html']\n    }, {\n      name: 'a:b:c.html',\n      assets: ['a:b:c.html']\n    }]);\n    let output = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(output.includes('/a:b:c.html'));\n    b = await bundle(path.join(__dirname, 'integration/url-colon/absolute.html'), {\n      inputFS: overlayFS\n    });\n    assertBundles(b, [{\n      name: 'absolute.html',\n      assets: ['absolute.html']\n    }, {\n      name: 'a:b:c.html',\n      assets: ['a:b:c.html']\n    }]);\n    output = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(output.includes('/a:b:c.html'));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should normalize case of SVG elements and attributes when minified","suites":["html"],"updatePoint":{"line":1816,"column":72,"index":65548},"line":1816,"code":"  it('should normalize case of SVG elements and attributes when minified', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/html-svg-case/index.html'), {\n      mode: 'production'\n    });\n    let output = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(output.includes('<x-custom stddeviation=\"0.5\"'));\n    assert(output.includes('<svg role=\"img\" viewBox='));\n    assert(output.includes('<filter'));\n    assert(output.includes('<feGaussianBlur in=\"SourceGraphic\" stdDeviation='));\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw error with empty string reference to other resource","suites":["html"],"updatePoint":{"line":1826,"column":70,"index":66086},"line":1826,"code":"  it('should throw error with empty string reference to other resource', async function () {\n    await assert.rejects(() => bundle(path.join(__dirname, 'integration/html-empty-reference/index.html'), {\n      mode: 'production'\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: \"'src' should not be empty string\",\n        origin: '@parcel/transformer-html',\n        codeFrames: [{\n          filePath: path.join(__dirname, 'integration/html-empty-reference/index.html'),\n          language: 'html',\n          codeHighlights: [{\n            start: {\n              column: 1,\n              line: 1\n            },\n            end: {\n              column: 14,\n              line: 1\n            }\n          }]\n        }]\n      }, {\n        message: \"'src' should not be empty string\",\n        origin: '@parcel/transformer-html',\n        codeFrames: [{\n          filePath: path.join(__dirname, 'integration/html-empty-reference/index.html'),\n          language: 'html',\n          codeHighlights: [{\n            start: {\n              column: 1,\n              line: 2\n            },\n            end: {\n              column: 24,\n              line: 2\n            }\n          }]\n        }]\n      }, {\n        message: \"'href' should not be empty string\",\n        origin: '@parcel/transformer-html',\n        codeFrames: [{\n          filePath: path.join(__dirname, 'integration/html-empty-reference/index.html'),\n          language: 'html',\n          codeHighlights: [{\n            start: {\n              column: 1,\n              line: 3\n            },\n            end: {\n              column: 16,\n              line: 3\n            }\n          }]\n        }]\n      }]\n    });\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"extracts shared bundles that load referenced bundle roots across entries","suites":["html"],"updatePoint":{"line":1885,"column":78,"index":67787},"line":1885,"code":"  it('extracts shared bundles that load referenced bundle roots across entries', async () => {\n    let b = await bundle(['index1.html', 'index2.html'].map(entry => path.join(__dirname, 'integration/html-shared-referenced', entry)), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    await run(b);\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not skip bundleRoots if an asset is both async required and static required","suites":["html"],"updatePoint":{"line":1894,"column":88,"index":68157},"line":1894,"code":"  it('should not skip bundleRoots if an asset is both async required and static required', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/html-sync-async-asset/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    await run(b, {\n      output: null\n    }, {\n      require: false\n    });\n  });","file":"html.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should be able to resize images","suites":["image"],"updatePoint":{"line":8,"column":37,"index":285},"line":8,"code":"  it('Should be able to resize images', async () => {\n    await bundle(path.join(__dirname, '/integration/image/resized.js'));\n    let dirContent = await outputFS.readdir(distDir);\n    let imagePath = '';\n    let foundExtensions = [];\n    for (let filename of dirContent) {\n      let ext = path.extname(filename);\n      foundExtensions.push(ext);\n      if (ext === '.jpeg') {\n        imagePath = path.join(distDir, filename);\n      }\n    }\n    assert.deepStrictEqual(foundExtensions.sort(), ['.jpeg', '.js', '.map'].sort());\n    let buffer = await outputFS.readFile(imagePath);\n    let image = await sharp(buffer).metadata();\n    assert.equal(image.width, 600);\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should be able to import an image using multiple varying query parameters","suites":["image"],"updatePoint":{"line":25,"column":79,"index":995},"line":25,"code":"  it('Should be able to import an image using multiple varying query parameters', async () => {\n    await bundle(path.join(__dirname, '/integration/image-multiple-queries/index.html'));\n    let dirContent = await outputFS.readdir(distDir);\n    let foundExtensions = [];\n    for (let filename of dirContent) {\n      const foundExt = path.extname(filename);\n      if (foundExt !== '.map') {\n        foundExtensions.push(foundExt);\n      }\n    }\n    assert.deepStrictEqual(foundExtensions.sort(), ['.jpeg', '.jpeg', '.webp', '.html'].sort());\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"from JS","suites":["image","Should be able to change image format"],"updatePoint":{"line":52,"column":15,"index":2064},"line":52,"code":"    it('from JS', testCase('js'));","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"from HTML","suites":["image","Should be able to change image format"],"updatePoint":{"line":53,"column":17,"index":2101},"line":53,"code":"    it('from HTML', testCase('html'));","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"from CSS","suites":["image","Should be able to change image format"],"updatePoint":{"line":54,"column":16,"index":2139},"line":54,"code":"    it('from CSS', testCase('css'));","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"all formats","suites":["image","Should be able to change image format"],"updatePoint":{"line":55,"column":19,"index":2179},"line":55,"code":"    it('all formats', async () => {\n      let b = await bundle(path.join(__dirname, `/integration/image/reformat-all.html`));\n      let foundExtensions = new Set(b.getBundles().map(({\n        type\n      }) => type));\n      assert.deepStrictEqual(foundExtensions, new Set(['html', 'webp', 'avif', 'jpeg', 'png', 'tiff']));\n    });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should lossless optimise JPEGs","suites":["image","Should be able to change image format"],"updatePoint":{"line":63,"column":36,"index":2532},"line":63,"code":"  it('should lossless optimise JPEGs', async function () {\n    let img = path.join(__dirname, '/integration/image/image.jpg');\n    let b = await bundle(img, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    const imagePath = b.getBundles().find(b => b.type === 'jpg').filePath;\n    let input = await inputFS.readFile(img);\n    let inputRaw = await sharp(input).toFormat('raw').toBuffer();\n    let output = await outputFS.readFile(imagePath);\n    let outputRaw = await sharp(output).toFormat('raw').toBuffer();\n    assert(outputRaw.equals(inputRaw));\n    assert(output.length < input.length);\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should lossless optimise progressive JPEGs","suites":["image","Should be able to change image format"],"updatePoint":{"line":78,"column":48,"index":3173},"line":78,"code":"  it('should lossless optimise progressive JPEGs', async function () {\n    let img = path.join(__dirname, '/integration/image/banana.jpg');\n    let b = await bundle(img, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      },\n      logLevel: 'verbose'\n    });\n    const imagePath = b.getBundles().find(b => b.type === 'jpg').filePath;\n\n    // let input = await inputFS.readFile(img);\n    // let inputRaw = await sharp(input)\n    //   .toFormat('raw')\n    //   .toBuffer();\n    // Check validity of image\n    let output = await outputFS.readFile(imagePath);\n    await sharp(output).toFormat('raw').toBuffer();\n\n    // assert(outputRaw.equals(inputRaw));\n    // assert(output.length < input.length);\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should lossless optimise PNGs","suites":["image","Should be able to change image format"],"updatePoint":{"line":100,"column":35,"index":3879},"line":100,"code":"  it('should lossless optimise PNGs', async function () {\n    let img = path.join(__dirname, '/integration/image/clock.png');\n    let b = await bundle(img, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    const imagePath = b.getBundles().find(b => b.type === 'png').filePath;\n    let input = await inputFS.readFile(img);\n    let inputRaw = await sharp(input).toFormat('raw').toBuffer();\n    let output = await outputFS.readFile(imagePath);\n    let outputRaw = await sharp(output).toFormat('raw').toBuffer();\n    assert(outputRaw.equals(inputRaw));\n    assert(output.length < input.length);\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"support config files for jpeg files","suites":["image","Should be able to change image format"],"updatePoint":{"line":115,"column":41,"index":4513},"line":115,"code":"  it('support config files for jpeg files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/image-config/image.jpg'), {\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    const originalSize = 549196;\n    const imagePath = b.getBundles().find(b => b.type === 'jpeg').filePath;\n    const buffer = await outputFS.readFile(imagePath);\n    const image = await sharp(buffer).metadata();\n    assert.strictEqual(image.width, 1920);\n    assert.strictEqual(image.chromaSubsampling, '4:4:4');\n    assert(image.size < originalSize);\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"support config files for png files","suites":["image","Should be able to change image format"],"updatePoint":{"line":129,"column":40,"index":5100},"line":129,"code":"  it('support config files for png files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/image-config/clock.png'), {\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    const originalSize = 84435;\n    const imagePath = b.getBundles().find(b => b.type === 'png').filePath;\n    const buffer = await outputFS.readFile(imagePath);\n    const image = await sharp(buffer).metadata();\n    assert.strictEqual(image.width, 200);\n    assert.strictEqual(image.paletteBitDepth, 8);\n    assert(image.size < originalSize);\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should retain EXIF data","suites":["image","Should be able to change image format"],"updatePoint":{"line":143,"column":29,"index":5665},"line":143,"code":"  it('should retain EXIF data', async () => {\n    const b = await bundle(path.join(__dirname, '/integration/image-exif/resized.html'));\n    const imagePath = b.getBundles().find(b => b.type === 'jpeg').filePath;\n    const buffer = await outputFS.readFile(imagePath);\n    const image = await sharp(buffer).metadata();\n    const {\n      exif\n    } = exifReader(image.exif);\n    assert.strictEqual(exif.UserComment.toString(), 'ASCII\\u0000\\u0000\\u0000This is a comment');\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove EXIF data when optimizing","suites":["image","Should be able to change image format"],"updatePoint":{"line":153,"column":45,"index":6156},"line":153,"code":"  it('should remove EXIF data when optimizing', async () => {\n    const b = await bundle(path.join(__dirname, '/integration/image-exif/resized.html'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    const imagePath = b.getBundles().find(b => b.type === 'jpeg').filePath;\n    const buffer = await outputFS.readFile(imagePath);\n    const image = await sharp(buffer).metadata();\n    assert.strictEqual(image.exif, undefined);\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should use the EXIF orientation tag when resizing","suites":["image","Should be able to change image format"],"updatePoint":{"line":164,"column":55,"index":6628},"line":164,"code":"  it('should use the EXIF orientation tag when resizing', async () => {\n    const b = await bundle(path.join(__dirname, '/integration/image-exif/resized.html'));\n    const imagePath = b.getBundles().find(b => b.type === 'jpeg').filePath;\n    const buffer = await outputFS.readFile(imagePath);\n    const image = await sharp(buffer).metadata();\n    assert.strictEqual(image.orientation, 1);\n    assert.strictEqual(image.width, 240);\n    assert.strictEqual(image.height, 320);\n  });","file":"image.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a basic JS bundle with CommonJS requires","suites":["javascript"],"updatePoint":{"line":14,"column":61,"index":682},"line":14,"code":"  it('should produce a basic JS bundle with CommonJS requires', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/commonjs/index.js'));\n\n    // assert.equal(b.assets.size, 8);\n    // assert.equal(b.childBundles.size, 1);\n\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support url: imports with CommonJS output","suites":["javascript"],"updatePoint":{"line":24,"column":54,"index":1040},"line":24,"code":"  it('should support url: imports with CommonJS output', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/commonjs-import-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'esmodule-helpers.js']\n    }, {\n      type: 'txt',\n      assets: ['x.txt']\n    }]);\n    let txtBundle = b.getBundles().find(b => b.type === 'txt').filePath;\n    let output = await run(b);\n    assert.strictEqual(path.basename(output), path.basename(txtBundle));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support url: imports of another javascript file","suites":["javascript"],"updatePoint":{"line":37,"column":60,"index":1558},"line":37,"code":"  it('should support url: imports of another javascript file', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worklet/pipeline.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'pipeline.js',\n      assets: ['bundle-url.js', 'pipeline.js', 'bundle-manifest.js']\n    }, {\n      type: 'js',\n      assets: ['worklet.js', 'colors.js']\n    }]);\n    let url;\n    await run(b, {\n      CSS: {\n        paintWorklet: {\n          addModule(u) {\n            url = u;\n          }\n        }\n      }\n    });\n    assert(/^http:\\/\\/localhost\\/worklet\\.[0-9a-f]+\\.js$/.test(url));\n    let name;\n    await runBundle(b, b.getBundles()[1], {\n      registerPaint(n) {\n        name = n;\n      }\n    }, {\n      require: false\n    });\n    assert.equal(name, 'checkerboard');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support new URL() of another javascript file","suites":["javascript"],"updatePoint":{"line":69,"column":57,"index":2370},"line":69,"code":"  it('should support new URL() of another javascript file', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worklet/url.js'));\n    assertBundles(b, [{\n      name: 'url.js',\n      assets: ['bundle-url.js', 'esmodule-helpers.js', 'url.js']\n    }, {\n      type: 'js',\n      assets: ['worklet.js', 'colors.js', 'esmodule-helpers.js']\n    }]);\n    let res = await run(b);\n    assert(/^http:\\/\\/localhost\\/worklet\\.[0-9a-f]+\\.js$/.test(res.default));\n    let name;\n    await runBundle(b, b.getBundles()[1], {\n      registerPaint(n) {\n        name = n;\n      }\n    }, {\n      require: false\n    });\n    assert.equal(name, 'checkerboard');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support CSS paint worklets","suites":["javascript"],"updatePoint":{"line":90,"column":39,"index":3022},"line":90,"code":"  it('should support CSS paint worklets', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worklet/url-worklet.js'));\n    assertBundles(b, [{\n      name: 'url-worklet.js',\n      assets: ['bundle-url.js', 'url-worklet.js']\n    }, {\n      type: 'js',\n      assets: ['worklet.js', 'colors.js', 'esmodule-helpers.js']\n    }]);\n    let url;\n    await run(b, {\n      CSS: {\n        paintWorklet: {\n          addModule(u) {\n            url = u;\n          }\n        }\n      }\n    });\n    assert(/^http:\\/\\/localhost\\/worklet\\.[0-9a-f]+\\.js$/.test(url));\n    let name;\n    await runBundle(b, b.getBundles()[1], {\n      registerPaint(n) {\n        name = n;\n      }\n    }, {\n      require: false\n    });\n    assert.equal(name, 'checkerboard');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on dynamic import() inside worklets","suites":["javascript"],"updatePoint":{"line":120,"column":54,"index":3807},"line":120,"code":"  it('should error on dynamic import() inside worklets', async function () {\n    let errored = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/worklet/url-worklet-error.js'));\n    } catch (err) {\n      errored = true;\n      assert.equal(err.message, 'import() is not allowed in worklets.');\n      assert.deepEqual(err.diagnostics, [{\n        message: 'import() is not allowed in worklets.',\n        origin: '@parcel/transformer-js',\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/worklet/worklet-error.js'),\n          codeHighlights: [{\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 18\n            }\n          }]\n        }, {\n          filePath: path.join(__dirname, 'integration/worklet/url-worklet-error.js'),\n          codeHighlights: [{\n            message: 'The environment was originally created here',\n            start: {\n              line: 1,\n              column: 36\n            },\n            end: {\n              line: 1,\n              column: 53\n            }\n          }]\n        }],\n        hints: ['Try using a static `import`.']\n      }]);\n    }\n    assert(errored);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support audio worklets via a pipeline","suites":["javascript"],"updatePoint":{"line":161,"column":50,"index":5049},"line":161,"code":"  it('should support audio worklets via a pipeline', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worklet/worklet-pipeline.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'worklet-pipeline.js',\n      assets: ['bundle-url.js', 'bundle-manifest.js', 'worklet-pipeline.js']\n    }, {\n      type: 'js',\n      assets: ['worklet.js', 'colors.js']\n    }]);\n    let res = await run(b);\n    assert(/^http:\\/\\/localhost\\/worklet\\.[0-9a-f]+\\.js$/.test(res));\n    let name;\n    await runBundle(b, b.getBundles()[1], {\n      registerPaint(n) {\n        name = n;\n      }\n    }, {\n      require: false\n    });\n    assert.equal(name, 'checkerboard');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on dynamic import() inside worklets imported via a pipeline","suites":["javascript"],"updatePoint":{"line":184,"column":78,"index":5781},"line":184,"code":"  it('should error on dynamic import() inside worklets imported via a pipeline', async function () {\n    let errored = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/worklet/worklet-pipeline-error.js'));\n    } catch (err) {\n      errored = true;\n      assert.equal(err.message, 'import() is not allowed in worklets.');\n      assert.deepEqual(err.diagnostics, [{\n        message: 'import() is not allowed in worklets.',\n        origin: '@parcel/transformer-js',\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/worklet/worklet-error.js'),\n          codeHighlights: [{\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 18\n            }\n          }]\n        }],\n        hints: ['Try using a static `import`.']\n      }]);\n    }\n    assert(errored);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a basic JS bundle with ES6 imports","suites":["javascript"],"updatePoint":{"line":212,"column":55,"index":6659},"line":212,"code":"  it('should produce a basic JS bundle with ES6 imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/es6/index.js'));\n\n    // assert.equal(b.assets.size, 8);\n    // assert.equal(b.childBundles.size, 1);\n\n    let output = await run(b);\n    assert.equal(typeof output, 'object');\n    assert.equal(typeof output.default, 'function');\n    assert.equal(output.default(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect dependencies inserted by a prior transform","suites":["javascript"],"updatePoint":{"line":223,"column":62,"index":7079},"line":223,"code":"  it('should detect dependencies inserted by a prior transform', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/dependency-prior-transform/index.js'));\n    let jsBundle = b.getBundles()[0];\n    let contents = await outputFS.readFile(jsBundle.filePath);\n    assert(!contents.includes('import'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore unused requires after process.env inlining","suites":["javascript"],"updatePoint":{"line":229,"column":62,"index":7407},"line":229,"code":"  it('should ignore unused requires after process.env inlining', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-unused-require/index.js'), {\n      env: {\n        ABC: 'XYZ'\n      }\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.js']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('unused'));\n    let output = await run(b);\n    assert.strictEqual(output(), 'ok');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a basic JS bundle with object rest spread support","suites":["javascript"],"updatePoint":{"line":244,"column":70,"index":7918},"line":244,"code":"  it('should produce a basic JS bundle with object rest spread support', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/object-rest-spread/object-rest-spread.js'));\n\n    // assert.equal(b.assets.size, 1);\n\n    let output = await run(b);\n    assert.equal(typeof output, 'object');\n    assert.equal(typeof output.default, 'function');\n    let res = output.default();\n    assert.equal(res.y, 'a');\n    assert.deepEqual(res.z, {\n      y: 'a',\n      b: 'b'\n    });\n    assert.deepEqual(res.ys, {\n      b: 'b'\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bundle node_modules for a browser environment","suites":["javascript"],"updatePoint":{"line":262,"column":58,"index":8457},"line":262,"code":"  it('should bundle node_modules for a browser environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/node_require_browser/main.js'));\n    assertBundles(b, [{\n      name: 'main.js',\n      assets: ['main.js', 'local.js', 'index.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not bundle node_modules for a node environment","suites":["javascript"],"updatePoint":{"line":272,"column":59,"index":8851},"line":272,"code":"  it('should not bundle node_modules for a node environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/node_require/main.js'));\n    assertBundles(b, [{\n      name: 'main.js',\n      assets: ['main.js', 'local.js']\n    }]);\n    await outputFS.mkdirp(path.join(distDir, 'node_modules/testmodule'));\n    await outputFS.writeFile(path.join(distDir, 'node_modules/testmodule/index.js'), 'exports.a = 5;');\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 7);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not bundle node_modules on --target=electron","suites":["javascript"],"line":284,"code":"  it.skip('should not bundle node_modules on --target=electron', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should preserve hashbangs in bundles and preserve executable file mode","suites":["javascript"],"updatePoint":{"line":298,"column":76,"index":10007},"line":298,"code":"  it('should preserve hashbangs in bundles and preserve executable file mode', async () => {\n    let fixturePath = path.join(__dirname, '/integration/node_hashbang');\n    await bundle(path.join(fixturePath, 'main.js'));\n    let mainPath = path.join(fixturePath, 'dist', 'node', 'main.js');\n    let main = await outputFS.readFile(mainPath, 'utf8');\n    assert.equal(main.lastIndexOf('#!/usr/bin/env node\\n'), 0);\n    assert.equal((await outputFS.stat(mainPath)).mode, (await inputFS.stat(path.join(fixturePath, 'main.js'))).mode);\n    await outputFS.rimraf(path.join(fixturePath, 'dist'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not preserve hashbangs in browser bundles","suites":["javascript"],"updatePoint":{"line":307,"column":54,"index":10580},"line":307,"code":"  it('should not preserve hashbangs in browser bundles', async () => {\n    let fixturePath = path.join(__dirname, '/integration/node_hashbang');\n    await bundle(path.join(fixturePath, 'main.js'));\n    let main = await outputFS.readFile(path.join(fixturePath, 'dist', 'browser', 'main.js'), 'utf8');\n    assert(!main.includes('#!/usr/bin/env node\\n'));\n    await outputFS.rimraf(path.join(fixturePath, 'dist'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should preserve hashbangs in scopehoisted bundles","suites":["javascript"],"updatePoint":{"line":314,"column":55,"index":10999},"line":314,"code":"  it('should preserve hashbangs in scopehoisted bundles', async () => {\n    let fixturePath = path.join(__dirname, '/integration/node_hashbang');\n    await bundle(path.join(__dirname, '/integration/node_hashbang/main.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let main = await outputFS.readFile(path.join(fixturePath, 'dist', 'node', 'main.js'), 'utf8');\n    assert.equal(main.lastIndexOf('#!/usr/bin/env node\\n'), 0);\n    await outputFS.rimraf(path.join(fixturePath, 'dist'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bundle node_modules for a node environment if includeNodeModules is specified","suites":["javascript"],"updatePoint":{"line":325,"column":90,"index":11564},"line":325,"code":"  it('should bundle node_modules for a node environment if includeNodeModules is specified', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/include_node_modules/main.js'));\n    assertBundles(b, [{\n      name: 'main.js',\n      assets: ['main.js', 'local.js', 'index.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bundle builtins for a browser environment","suites":["javascript"],"updatePoint":{"line":335,"column":54,"index":11953},"line":335,"code":"  it('should bundle builtins for a browser environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/include_builtins-browser/main.js'));\n    assertBundles(b, [{\n      name: 'main.js',\n      assets: ['_empty.js', 'browser.js', 'esmodule-helpers.js', 'index.js', 'main.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let [fs, filepath] = output();\n    assert.equal(filepath, path.posix.join('app', 'index.js'));\n    assert.equal(typeof fs, 'object');\n    assert.deepEqual(Object.keys(fs), Object.keys({}));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not bundle builtins for a node environment if includeNodeModules is specified","suites":["javascript"],"updatePoint":{"line":348,"column":90,"index":12583},"line":348,"code":"  it('should not bundle builtins for a node environment if includeNodeModules is specified', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/include_builtins-node/main.js'));\n    assertBundles(b, [{\n      name: 'main.js',\n      assets: ['esmodule-helpers.js', 'main.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let [fs, filepath] = output();\n    assert.equal(filepath, path.join('app', 'index.js'));\n    assert.equal(typeof fs.readFile, 'function');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bundle node_modules on --target=electron and --bundle-node-modules","suites":["javascript"],"line":360,"code":"  it.skip('should bundle node_modules on --target=electron and --bundle-node-modules', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should produce a JS bundle with default exports and no imports","suites":["javascript"],"updatePoint":{"line":373,"column":68,"index":13572},"line":373,"code":"  it('should produce a JS bundle with default exports and no imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/es6-default-only/index.js'));\n\n    // assert.equal(b.assets.size, 1);\n    // assert.equal(b.childBundles.size, 1);\n\n    let output = await run(b);\n    assert.equal(typeof output, 'object');\n    assert.equal(typeof output.default, 'function');\n    assert.equal(output.default(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should split bundles when a dynamic import is used a browser environment","suites":["javascript"],"updatePoint":{"line":384,"column":78,"index":14021},"line":384,"code":"  it('should split bundles when a dynamic import is used a browser environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['local.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should prefetch bundles when declared as an import attribute statically","suites":["javascript"],"updatePoint":{"line":396,"column":77,"index":14492},"line":396,"code":"  it('should prefetch bundles when declared as an import attribute statically', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-static-prefetch/index.js'));\n    let output = await run(b);\n    let headChildren = await output.default;\n    assert.strictEqual(headChildren.length, 4);\n    assert.strictEqual(headChildren[1].tag, 'script');\n    assert(headChildren[1].src.match(/async\\..*\\.js/));\n    assert.strictEqual(headChildren[2].tag, 'link');\n    assert.strictEqual(headChildren[2].rel, 'prefetch');\n    assert.strictEqual(headChildren[2].as, 'script');\n    assert(headChildren[2].href.match(/prefetched\\..*\\.js/));\n    assert.strictEqual(headChildren[3].tag, 'link');\n    assert.strictEqual(headChildren[3].rel, 'prefetch');\n    assert.strictEqual(headChildren[3].as, 'style');\n    assert(headChildren[3].href.match(/prefetched\\..*\\.css/));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should load additional links that were prefetched","suites":["javascript"],"updatePoint":{"line":412,"column":55,"index":15360},"line":412,"code":"  it('should load additional links that were prefetched', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-static-prefetch-loaded/index.js'));\n    let output = await run(b);\n    let outputReturn = await output.default;\n    await outputReturn.loadDependency();\n    let headChildren = outputReturn.children;\n    assert.equal(headChildren.length, 7);\n    let cssBundles = headChildren.filter(child => child.href?.match(/prefetched-loaded\\..*\\.css/));\n    assert.equal(cssBundles.length, 2);\n    assert(cssBundles[0].tag === 'link');\n    assert(cssBundles[0].rel === 'prefetch');\n    assert(cssBundles[0].as === 'style');\n    assert(cssBundles[0].href.match(/prefetched-loaded\\..*\\.css/));\n    assert(cssBundles[1].tag === 'link');\n    assert(cssBundles[1].rel === 'stylesheet');\n    assert(cssBundles[1].href.match(/prefetched-loaded\\..*\\.css/));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should preload bundles when declared as an import attribute statically","suites":["javascript"],"updatePoint":{"line":429,"column":76,"index":16270},"line":429,"code":"  it('should preload bundles when declared as an import attribute statically', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-static-preload/index.js'));\n    let output = await run(b);\n    let headChildren = await output.default;\n    assert(headChildren.length === 4);\n    assert(headChildren[2].tag === 'link');\n    assert(headChildren[2].rel === 'preload');\n    assert(headChildren[2].as === 'script');\n    assert(headChildren[2].href.match(/preloaded\\..*\\.js/));\n    assert(headChildren[3].tag === 'link');\n    assert(headChildren[3].rel === 'preload');\n    assert(headChildren[3].as === 'style');\n    assert(headChildren[3].href.match(/preloaded\\..*\\.css/));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"targetting esmodule, should modulepreload bundles when declared as an import attribute statically","suites":["javascript"],"updatePoint":{"line":445,"column":103,"index":17083},"line":445,"code":"  it('targetting esmodule, should modulepreload bundles when declared as an import attribute statically');","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove import attributes","suites":["javascript"],"updatePoint":{"line":446,"column":37,"index":17124},"line":446,"code":"  it('should remove import attributes', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-import-attributes/index.js'));\n    let mainBundle = b.getBundles()[0];\n    let mainBundleContent = await outputFS.readFile(mainBundle.filePath, 'utf8');\n    assert(!mainBundleContent.includes('foo:'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should split bundles when a dynamic import is used with a node environment","suites":["javascript"],"updatePoint":{"line":452,"column":80,"index":17497},"line":452,"code":"  it('should split bundles when a dynamic import is used with a node environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-node/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      assets: ['local.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should split bundles when a dynamic import is used with an electron-main environment","suites":["javascript"],"updatePoint":{"line":464,"column":90,"index":17935},"line":464,"code":"  it('should split bundles when a dynamic import is used with an electron-main environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-electron-main/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      assets: ['local.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should split bundles when a dynamic import is used with an electron-renderer environment","suites":["javascript"],"updatePoint":{"line":476,"column":94,"index":18386},"line":476,"code":"  it('should split bundles when a dynamic import is used with an electron-renderer environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-electron-renderer/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      assets: ['local.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should load dynamic bundle when entry is in a subdirectory","suites":["javascript"],"line":488,"code":"  it.skip('should load dynamic bundle when entry is in a subdirectory', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"Should not run parcel over external modules","suites":["javascript"],"line":501,"code":"  it.skip('Should not run parcel over external modules', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling workers","suites":["javascript"],"updatePoint":{"line":508,"column":37,"index":19641},"line":508,"code":"  it('should support bundling workers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/workers/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'common.js', 'worker-client.js', 'feature.js', 'get-worker-url.js', 'bundle-url.js']\n    }, {\n      assets: ['service-worker.js']\n    }, {\n      assets: ['shared-worker.js']\n    }, {\n      assets: ['worker.js', 'common.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling workers with dynamic import","suites":["javascript"],"updatePoint":{"line":521,"column":57,"index":20116},"line":521,"code":"  it('should support bundling workers with dynamic import', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-dynamic/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'get-worker-url.js']\n    }, {\n      assets: ['worker.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js', 'esmodule-helpers.js']\n    }]);\n    let res = await new Promise(resolve => {\n      run(b, {\n        output: resolve\n      });\n    });\n    assert.deepEqual(res, {\n      default: 42\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling workers with dynamic import with legacy browser targets","suites":["javascript"],"updatePoint":{"line":540,"column":85,"index":20743},"line":540,"code":"  it('should support bundling workers with dynamic import with legacy browser targets', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-dynamic/index.js'), {\n      defaultTargetOptions: {\n        outputFormat: 'esmodule',\n        shouldScopeHoist: true,\n        engines: {\n          browsers: 'IE 11'\n        }\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'get-worker-url.js']\n    }, {\n      assets: ['worker.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    let res = await new Promise(resolve => {\n      run(b, {\n        output: resolve\n      });\n    });\n    assert.deepEqual(res, {\n      default: 42\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"dynamic imports loaded as high-priority scripts when not all engines support esmodules natively","suites":["javascript"],"updatePoint":{"line":567,"column":101,"index":21533},"line":567,"code":"  it('dynamic imports loaded as high-priority scripts when not all engines support esmodules natively', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-imports-high-prio/index.js'), {\n      defaultTargetOptions: {\n        engines: {\n          browsers: 'IE 11'\n        }\n      }\n    });\n    let output = await run(b);\n    let headChildren = await output.default;\n    assert(headChildren[0].tag === 'link');\n    assert(headChildren[0].rel === 'preload');\n    assert(headChildren[0].as === 'script');\n    assert(headChildren[1].tag === 'script');\n    assert(headChildren[1].src.match(/async\\..*\\.js/));\n    assert(headChildren[0].href === headChildren[1].src);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling workers with dynamic import in both page and worker","suites":["javascript"],"updatePoint":{"line":584,"column":81,"index":22218},"line":584,"code":"  it('should support bundling workers with dynamic import in both page and worker', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-dynamic/index-async.js'));\n    assertBundles(b, [{\n      name: 'index-async.js',\n      assets: ['index-async.js', 'bundle-url.js', 'get-worker-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['worker.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['async.js', 'esmodule-helpers.js']\n    }]);\n    let res = await new Promise(resolve => {\n      run(b, {\n        output: resolve\n      });\n    });\n    assert.deepEqual(res, {\n      default: 42\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling workers with dynamic import in nested worker","suites":["javascript"],"updatePoint":{"line":605,"column":74,"index":22945},"line":605,"code":"  it('should support bundling workers with dynamic import in nested worker', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-dynamic/index-nested.js'));\n    assertBundles(b, [{\n      name: 'index-nested.js',\n      assets: ['index-nested.js', 'bundle-url.js', 'get-worker-url.js']\n    }, {\n      assets: ['worker-nested.js', 'bundle-url.js', 'get-worker-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['worker.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js', 'esmodule-helpers.js']\n    }]);\n    let res = await new Promise(resolve => {\n      run(b, {\n        output: resolve\n      });\n    });\n    assert.deepEqual(res, {\n      default: 42\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support workers pointing to themselves","suites":["javascript"],"updatePoint":{"line":626,"column":51,"index":23675},"line":626,"code":"  it('should support workers pointing to themselves', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-self/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'get-worker-url.js', 'workerHelpers.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['workerHelpers.js', 'bundle-url.js', 'get-worker-url.js', 'esmodule-helpers.js']\n    }]);\n    await run(b);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support workers pointing to themselves with import.meta.url","suites":["javascript"],"updatePoint":{"line":636,"column":72,"index":24149},"line":636,"code":"  it('should support workers pointing to themselves with import.meta.url', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-self/import-meta.js'));\n    assertBundles(b, [{\n      assets: ['import-meta.js', 'bundle-url.js', 'get-worker-url.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['import-meta.js', 'bundle-url.js', 'get-worker-url.js', 'esmodule-helpers.js']\n    }]);\n    await run(b);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling workers of type module","suites":["javascript"],"updatePoint":{"line":645,"column":52,"index":24569},"line":645,"code":"  it('should support bundling workers of type module', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/workers-module/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false,\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      assets: ['dedicated-worker.js']\n    }, {\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'get-worker-url.js', 'bundle-manifest.js']\n    }, {\n      assets: ['shared-worker.js']\n    }, {\n      assets: ['index.js']\n    }]);\n    let dedicated, shared;\n    b.traverseBundles((bundle, ctx, traversal) => {\n      let mainEntry = bundle.getMainEntry();\n      if (mainEntry && mainEntry.filePath.endsWith('shared-worker.js')) {\n        shared = bundle;\n      } else if (mainEntry && mainEntry.filePath.endsWith('dedicated-worker.js')) {\n        dedicated = bundle;\n      }\n      if (dedicated && shared) traversal.stop();\n    });\n    assert(dedicated);\n    assert(shared);\n    let main = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    dedicated = await outputFS.readFile(dedicated.filePath, 'utf8');\n    shared = await outputFS.readFile(shared.filePath, 'utf8');\n    assert(/new Worker(.*?, {[\\n\\s]+type: \"module\"[\\n\\s]+})/.test(main));\n    assert(/new SharedWorker(.*?, {[\\n\\s]+type: \"module\"[\\n\\s]+})/.test(main));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile workers to non modules if ","suites":["javascript"],"updatePoint":{"line":682,"column":128,"index":26073},"line":682,"code":"    it(`should compile workers to non modules if ${shouldScopeHoist ? 'browsers do not support it' : 'shouldScopeHoist = false'}`, async function () {\n      let b = await bundle(path.join(__dirname, '/integration/workers-module/index.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldOptimize: false,\n          shouldScopeHoist,\n          engines: {\n            browsers: '>= 0.25%'\n          }\n        }\n      });\n      assertBundles(b, [{\n        assets: ['dedicated-worker.js']\n      }, {\n        name: 'index.js',\n        assets: ['index.js', 'bundle-url.js', 'get-worker-url.js', 'bundle-manifest.js']\n      }, {\n        assets: [!shouldScopeHoist && 'esmodule-helpers.js', 'index.js'].filter(Boolean)\n      }, {\n        assets: ['shared-worker.js']\n      }]);\n      let dedicated, shared;\n      b.traverseBundles((bundle, ctx, traversal) => {\n        let mainEntry = bundle.getMainEntry();\n        if (mainEntry && mainEntry.filePath.endsWith('shared-worker.js')) {\n          shared = bundle;\n        } else if (mainEntry && mainEntry.filePath.endsWith('dedicated-worker.js')) {\n          dedicated = bundle;\n        }\n        if (dedicated && shared) traversal.stop();\n      });\n      assert(dedicated);\n      assert(shared);\n      let main = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      dedicated = await outputFS.readFile(dedicated.filePath, 'utf8');\n      shared = await outputFS.readFile(shared.filePath, 'utf8');\n      assert(/new Worker([^,]*?)/.test(main));\n      assert(/new SharedWorker([^,]*?)/.test(main));\n      assert(!/export var foo/.test(dedicated));\n      assert(!/export var foo/.test(shared));\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile workers to modules when browsers do support it with esmodule parent script","suites":["javascript"],"updatePoint":{"line":725,"column":149,"index":27823},"line":725,"code":"    it(`should compile workers to ${supported ? '' : 'non '}modules when browsers do ${supported ? '' : 'not '}support it with esmodule parent script`, async function () {\n      let b = await bundle(path.join(__dirname, '/integration/workers-module/index.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          engines: {\n            browsers: supported ? 'Chrome 80' : 'Chrome 75'\n          },\n          outputFormat: 'esmodule',\n          shouldScopeHoist: true,\n          shouldOptimize: false\n        }\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['dedicated-worker.js']\n      }, {\n        name: 'index.js',\n        assets: ['index.js', 'bundle-manifest.js', 'get-worker-url.js']\n      }, {\n        type: 'js',\n        assets: ['shared-worker.js']\n      }, {\n        type: 'js',\n        assets: ['index.js']\n      }]);\n      let dedicated, shared;\n      b.traverseBundles((bundle, ctx, traversal) => {\n        if (bundle.getMainEntry()?.filePath.endsWith('shared-worker.js')) {\n          shared = bundle;\n        } else if (bundle.getMainEntry()?.filePath.endsWith('dedicated-worker.js')) {\n          dedicated = bundle;\n        }\n        if (dedicated && shared) traversal.stop();\n      });\n      assert(dedicated);\n      assert(shared);\n      let main = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(/new Worker([^,]*?)/.test(main));\n      assert(/new SharedWorker([^,]*?)/.test(main));\n      dedicated = await outputFS.readFile(dedicated.filePath, 'utf8');\n      shared = await outputFS.readFile(shared.filePath, 'utf8');\n      let importRegex = supported ? /importScripts\\s*\\(/ : /import\\s*(\"|')/;\n      assert(!importRegex.test(dedicated));\n      assert(!importRegex.test(shared));\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should preserve the name option to workers","suites":["javascript"],"updatePoint":{"line":771,"column":48,"index":29503},"line":771,"code":"  it('should preserve the name option to workers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/workers-module/named.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        engines: {\n          browsers: '>= 0.25%'\n        }\n      }\n    });\n    let main = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(/new Worker(.*?, {[\\n\\s]+name: \"worker\"[\\n\\s]+})/.test(main));\n    assert(/new SharedWorker(.*?, {[\\n\\s]+name: \"shared\"[\\n\\s]+})/.test(main));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error if importing in a worker without type: module","suites":["javascript"],"updatePoint":{"line":784,"column":64,"index":30053},"line":784,"code":"  it('should error if importing in a worker without type: module', async function () {\n    let errored = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/workers-module/error.js'), {\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        }\n      });\n    } catch (err) {\n      errored = true;\n      assert.equal(err.message, 'Web workers cannot have imports or exports without the `type: \"module\"` option.');\n      assert.deepEqual(err.diagnostics, [{\n        message: 'Web workers cannot have imports or exports without the `type: \"module\"` option.',\n        origin: '@parcel/transformer-js',\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/workers-module/dedicated-worker.js'),\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 22\n            }\n          }]\n        }, {\n          filePath: path.join(__dirname, '/integration/workers-module/error.js'),\n          codeHighlights: [{\n            message: 'The environment was originally created here',\n            start: {\n              line: 1,\n              column: 20\n            },\n            end: {\n              line: 1,\n              column: 40\n            }\n          }]\n        }],\n        hints: [\"Add {type: 'module'} as a second argument to the Worker constructor.\"],\n        documentationURL: 'https://parceljs.org/languages/javascript/#classic-scripts'\n      }]);\n    }\n    assert(errored);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling workers with different order","suites":["javascript"],"updatePoint":{"line":831,"column":58,"index":31631},"line":831,"code":"  it('should support bundling workers with different order', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/workers/index-alternative.js'));\n    assertBundles(b, [{\n      name: 'index-alternative.js',\n      assets: ['index-alternative.js', 'common.js', 'worker-client.js', 'feature.js', 'bundle-url.js', 'get-worker-url.js']\n    }, {\n      assets: ['service-worker.js']\n    }, {\n      assets: ['shared-worker.js']\n    }, {\n      assets: ['worker.js', 'common.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when s use importScripts","suites":["javascript"],"updatePoint":{"line":845,"column":58,"index":32202},"line":845,"code":"    it(`should error when ${workerType}s use importScripts`, async function () {\n      let filePath = path.join(__dirname, `/integration/worker-import-scripts/index-${workerType}.js`);\n      let errored = false;\n      try {\n        await bundle(filePath);\n      } catch (err) {\n        errored = true;\n        assert.equal(err.message, 'Argument to importScripts() must be a fully qualified URL.');\n        assert.deepEqual(err.diagnostics, [{\n          message: 'Argument to importScripts() must be a fully qualified URL.',\n          origin: '@parcel/transformer-js',\n          codeFrames: [{\n            filePath: path.join(__dirname, `/integration/worker-import-scripts/importScripts.js`),\n            codeHighlights: [{\n              message: null,\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 27\n              }\n            }]\n          }, {\n            filePath: path.join(__dirname, `integration/worker-import-scripts/index-${workerType}.js`),\n            codeHighlights: [{\n              message: 'The environment was originally created here',\n              start: {\n                line: 1,\n                column: workerType === 'webworker' ? 20 : 42\n              },\n              end: {\n                line: 1,\n                column: workerType === 'webworker' ? 37 : 59\n              }\n            }]\n          }],\n          hints: ['Use a static `import`, or dynamic `import()` instead.', \"Add {type: 'module'} as a second argument to the \" + (workerType === 'webworker' ? 'Worker constructor.' : 'navigator.serviceWorker.register() call.')],\n          documentationURL: 'https://parceljs.org/languages/javascript/#classic-script-workers'\n        }]);\n      }\n      assert(errored);\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore importScripts when not in a worker context","suites":["javascript"],"updatePoint":{"line":890,"column":62,"index":34034},"line":890,"code":"  it('should ignore importScripts when not in a worker context', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-import-scripts/importScripts.js'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['importScripts.js']\n    }]);\n    let res = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(res.includes(`importScripts(\"imported.js\")`));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore importScripts in script workers when not passed a string literal","suites":["javascript"],"updatePoint":{"line":899,"column":84,"index":34469},"line":899,"code":"  it('should ignore importScripts in script workers when not passed a string literal', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-import-scripts/index-variable.js'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index-variable.js', 'bundle-url.js', 'get-worker-url.js']\n    }, {\n      type: 'js',\n      assets: ['variable.js']\n    }]);\n    let res = await outputFS.readFile(b.getBundles()[1].filePath, 'utf8');\n    assert(res.includes('importScripts(url)'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore importScripts in script workers a fully qualified URL is provided","suites":["javascript"],"updatePoint":{"line":911,"column":85,"index":34992},"line":911,"code":"  it('should ignore importScripts in script workers a fully qualified URL is provided', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-import-scripts/index-external.js'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index-external.js', 'bundle-url.js', 'get-worker-url.js']\n    }, {\n      type: 'js',\n      assets: ['external.js']\n    }]);\n    let res = await outputFS.readFile(b.getBundles()[1].filePath, 'utf8');\n    assert(res.includes(`importScripts(\"https://unpkg.com/parcel\")`));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling service-workers","suites":["javascript"],"updatePoint":{"line":923,"column":45,"index":35498},"line":923,"code":"  it('should support bundling service-workers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/service-worker/a/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'index.js', 'bundle-url.js']\n    }, {\n      assets: ['worker-nested.js']\n    }, {\n      assets: ['worker-outside.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling service-workers with type: module","suites":["javascript"],"updatePoint":{"line":934,"column":63,"index":35882},"line":934,"code":"  it('should support bundling service-workers with type: module', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/service-worker/module.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      name: 'module.js',\n      assets: ['module.js', 'bundle-url.js']\n    }, {\n      assets: ['module-worker.js']\n    }]);\n    let bundles = b.getBundles();\n    let main = bundles.find(b => !b.env.isWorker());\n    let worker = bundles.find(b => b.env.isWorker());\n    let mainContents = await outputFS.readFile(main.filePath, 'utf8');\n    let workerContents = await outputFS.readFile(worker.filePath, 'utf8');\n    assert(/navigator.serviceWorker.register\\([^,]+?\\)/.test(mainContents));\n    assert(!/export /.test(workerContents));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should preserve the scope option for service workers","suites":["javascript"],"updatePoint":{"line":954,"column":58,"index":36692},"line":954,"code":"  it('should preserve the scope option for service workers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/service-worker/scope.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      name: 'scope.js',\n      assets: ['bundle-url.js', 'scope.js']\n    }, {\n      assets: ['module-worker.js']\n    }]);\n    let bundles = b.getBundles();\n    let main = bundles.find(b => !b.env.isWorker());\n    let mainContents = await outputFS.readFile(main.filePath, 'utf8');\n    assert(/navigator.serviceWorker.register\\(.*?, {[\\n\\s]*scope: \"foo\"[\\n\\s]*}\\)/.test(mainContents));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error if importing in a service worker without type: module","suites":["javascript"],"updatePoint":{"line":971,"column":72,"index":37366},"line":971,"code":"  it('should error if importing in a service worker without type: module', async function () {\n    let errored = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/service-worker/error.js'), {\n        defaultTargetOptions: {\n          shouldScopeHoist: true\n        }\n      });\n    } catch (err) {\n      errored = true;\n      assert.equal(err.message, 'Service workers cannot have imports or exports without the `type: \"module\"` option.');\n      assert.deepEqual(err.diagnostics, [{\n        message: 'Service workers cannot have imports or exports without the `type: \"module\"` option.',\n        origin: '@parcel/transformer-js',\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/service-worker/module-worker.js'),\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 19\n            }\n          }]\n        }, {\n          filePath: path.join(__dirname, 'integration/service-worker/error.js'),\n          codeHighlights: [{\n            message: 'The environment was originally created here',\n            start: {\n              line: 1,\n              column: 42\n            },\n            end: {\n              line: 1,\n              column: 59\n            }\n          }]\n        }],\n        hints: [\"Add {type: 'module'} as a second argument to the navigator.serviceWorker.register() call.\"],\n        documentationURL: 'https://parceljs.org/languages/javascript/#classic-scripts'\n      }]);\n    }\n    assert(errored);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should expose a manifest to service workers","suites":["javascript"],"updatePoint":{"line":1018,"column":49,"index":38960},"line":1018,"code":"  it('should expose a manifest to service workers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/service-worker/manifest.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      name: 'manifest.js',\n      assets: ['manifest.js', 'bundle-url.js']\n    }, {\n      assets: ['manifest-worker.js', 'service-worker.js']\n    }]);\n    let bundles = b.getBundles();\n    let worker = bundles.find(b => b.env.isWorker());\n    let manifest, version;\n    await runBundle(b, worker, {\n      output(m, v) {\n        manifest = m;\n        version = v;\n      }\n    });\n    assert.deepEqual(manifest, ['/manifest.js']);\n    assert.equal(typeof version, 'string');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should recognize serviceWorker.register with static URL and import.meta.url","suites":["javascript"],"updatePoint":{"line":1042,"column":81,"index":39735},"line":1042,"code":"  it('should recognize serviceWorker.register with static URL and import.meta.url', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/service-worker-import-meta-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js']\n    }, {\n      assets: ['worker.js']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('import.meta.url'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw a codeframe for a missing file in serviceWorker.register with URL and import.meta.url","suites":["javascript"],"updatePoint":{"line":1053,"column":104,"index":40241},"line":1053,"code":"  it('should throw a codeframe for a missing file in serviceWorker.register with URL and import.meta.url', async function () {\n    let fixture = path.join(__dirname, 'integration/service-worker-import-meta-url/missing.js');\n    let code = await inputFS.readFileSync(fixture, 'utf8');\n    await assert.rejects(() => bundle(fixture), {\n      name: 'BuildError',\n      diagnostics: [{\n        codeFrames: [{\n          filePath: fixture,\n          code,\n          codeHighlights: [{\n            end: {\n              column: 55,\n              line: 1\n            },\n            start: {\n              column: 42,\n              line: 1\n            }\n          }]\n        }],\n        message: \"Failed to resolve './invalid.js' from './missing.js'\",\n        origin: '@parcel/core'\n      }, {\n        hints: [\"Did you mean '__./index.js__'?\"],\n        message: \"Cannot load file './invalid.js' in './'.\",\n        origin: '@parcel/resolver-default'\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on dynamic import() inside service workers","suites":["javascript"],"updatePoint":{"line":1082,"column":61,"index":41160},"line":1082,"code":"  it('should error on dynamic import() inside service workers', async function () {\n    let errored = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/service-worker/dynamic-import-index.js'));\n    } catch (err) {\n      errored = true;\n      assert.equal(err.message, 'import() is not allowed in service workers.');\n      assert.deepEqual(err.diagnostics, [{\n        message: 'import() is not allowed in service workers.',\n        origin: '@parcel/transformer-js',\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/service-worker/dynamic-import.js'),\n          codeHighlights: [{\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 27\n            }\n          }]\n        }, {\n          filePath: path.join(__dirname, 'integration/service-worker/dynamic-import-index.js'),\n          codeHighlights: [{\n            message: 'The environment was originally created here',\n            start: {\n              line: 1,\n              column: 42\n            },\n            end: {\n              line: 1,\n              column: 60\n            }\n          }]\n        }],\n        hints: ['Try using a static `import`.']\n      }]);\n    }\n    assert(errored);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling workers with circular dependencies","suites":["javascript"],"updatePoint":{"line":1123,"column":64,"index":42458},"line":1123,"code":"  it('should support bundling workers with circular dependencies', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-circular/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'get-worker-url.js']\n    }, {\n      assets: ['worker.js', 'worker-dep.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should recognize worker constructor with static URL and import.meta.url","suites":["javascript"],"updatePoint":{"line":1132,"column":77,"index":42829},"line":1132,"code":"  it('should recognize worker constructor with static URL and import.meta.url', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-import-meta-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'get-worker-url.js']\n    }, {\n      assets: ['worker.js']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('import.meta.url'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore worker constructors with dynamic URL and import.meta.url","suites":["javascript"],"updatePoint":{"line":1143,"column":76,"index":43320},"line":1143,"code":"  it('should ignore worker constructors with dynamic URL and import.meta.url', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-import-meta-url/dynamic.js'));\n    assertBundles(b, [{\n      name: 'dynamic.js',\n      assets: ['dynamic.js']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('import.meta.url'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore worker constructors with local URL binding and import.meta.url","suites":["javascript"],"updatePoint":{"line":1152,"column":82,"index":43747},"line":1152,"code":"  it('should ignore worker constructors with local URL binding and import.meta.url', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-import-meta-url/local-url.js'));\n    assertBundles(b, [{\n      name: 'local-url.js',\n      assets: ['local-url.js']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('import.meta.url'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw a codeframe for a missing file in worker constructor with URL and import.meta.url","suites":["javascript"],"updatePoint":{"line":1161,"column":100,"index":44198},"line":1161,"code":"  it('should throw a codeframe for a missing file in worker constructor with URL and import.meta.url', async function () {\n    let fixture = path.join(__dirname, 'integration/worker-import-meta-url/missing.js');\n    let code = await inputFS.readFileSync(fixture, 'utf8');\n    await assert.rejects(() => bundle(fixture), {\n      name: 'BuildError',\n      diagnostics: [{\n        codeFrames: [{\n          filePath: fixture,\n          code,\n          codeHighlights: [{\n            end: {\n              column: 33,\n              line: 1\n            },\n            start: {\n              column: 20,\n              line: 1\n            }\n          }]\n        }],\n        message: \"Failed to resolve './invalid.js' from './missing.js'\",\n        origin: '@parcel/core'\n      }, {\n        hints: [\"Did you mean '__./dynamic.js__'?\", \"Did you mean '__./index.js__'?\"],\n        message: \"Cannot load file './invalid.js' in './'.\",\n        origin: '@parcel/resolver-default'\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling in workers with other loaders","suites":["javascript"],"line":1190,"code":"  it.skip('should support bundling in workers with other loaders', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should create a shared bundle to deduplicate assets in workers","suites":["javascript"],"updatePoint":{"line":1209,"column":68,"index":45776},"line":1209,"code":"  it('should create a shared bundle to deduplicate assets in workers', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/worker-shared/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'lodash.js', 'bundle-url.js', 'get-worker-url.js', 'bundle-manifest.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['worker-a.js', 'bundle-url.js', 'get-worker-url.js', 'bundle-manifest.js']\n    }, {\n      assets: ['worker-b.js']\n    }, {\n      assets: ['esmodule-helpers.js', 'lodash.js']\n    }]);\n    let sharedBundle = b.getBundles().sort((a, b) => b.stats.size - a.stats.size).find(b => b.name !== 'index.js');\n    let workerBundle = b.getBundles().find(b => b.name.startsWith('worker-b'));\n    let contents = await outputFS.readFile(workerBundle.filePath, 'utf8');\n    assert(contents.includes(`importScripts(\"./${path.basename(sharedBundle.filePath)}\")`));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should deduplicate and remove an unnecessary async bundle when it contains a cyclic reference to its entry","suites":["javascript"],"updatePoint":{"line":1231,"column":112,"index":46845},"line":1231,"code":"  it('should deduplicate and remove an unnecessary async bundle when it contains a cyclic reference to its entry', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/deduplicate-from-async-cyclic-bundle-entry/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bar.js', 'bundle-url.js', 'cacheLoader.js', 'esmodule-helpers.js', 'foo.js', 'js-loader.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.deepEqual(await Promise.all((await run(b)).default), [5, 4]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not create bundles for dynamic imports when assets are available up the graph","suites":["javascript"],"updatePoint":{"line":1241,"column":88,"index":47359},"line":1241,"code":"  it('does not create bundles for dynamic imports when assets are available up the graph', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/internalize-no-bundle-split/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bar.js', 'foo.js', 'esmodule-helpers.js']\n    }]);\n    assert.deepEqual(await (await run(b)).default, [3, 3]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"async dependency internalization successfully removes unneeded bundlegroups and their bundles","suites":["javascript"],"updatePoint":{"line":1249,"column":99,"index":47769},"line":1249,"code":"  it('async dependency internalization successfully removes unneeded bundlegroups and their bundles', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/internalize-remove-bundlegroup/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['bundle-url.js', 'get-worker-url.js', 'index.js']\n    }, {\n      assets: ['bundle-url.js', 'get-worker-url.js', 'worker1.js', 'worker2.js', 'worker3.js', 'core.js']\n    }, {\n      assets: ['core.js', 'worker3.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a shared bundle between browser and worker contexts","suites":["javascript"],"updatePoint":{"line":1260,"column":71,"index":48253},"line":1260,"code":"  it('should create a shared bundle between browser and worker contexts', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/html-shared-worker/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      assets: ['index.js', 'bundle-url.js', 'get-worker-url.js', 'bundle-manifest.js', 'lodash.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['worker.js', 'lodash.js', 'esmodule-helpers.js']\n    }]);\n\n    // let sharedBundle = b\n    //   .getBundles()\n    //   .sort((a, b) => b.stats.size - a.stats.size)\n    //   .find(b => b.name !== 'index.js');\n    let workerBundle = b.getBundles().find(b => b.name.startsWith('worker'));\n    // let contents = await outputFS.readFile(workerBundle.filePath, 'utf8');\n    // assert(\n    //   contents.includes(\n    //     `importScripts(\"./${path.basename(sharedBundle.filePath)}\")`,\n    //   ),\n    // );\n\n    let outputArgs = [];\n    let workerArgs = [];\n    await run(b, {\n      Worker: class {\n        constructor(url) {\n          workerArgs.push(url);\n        }\n      },\n      output: (ctx, val) => {\n        outputArgs.push([ctx, val]);\n      }\n    });\n    assert.deepStrictEqual(outputArgs, [['main', 3]]);\n    assert.deepStrictEqual(workerArgs, [`http://localhost/${path.basename(workerBundle.filePath)}`]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support workers with shared assets between page and worker with async imports","suites":["javascript"],"updatePoint":{"line":1303,"column":90,"index":49712},"line":1303,"code":"  it('should support workers with shared assets between page and worker with async imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-shared-page/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'get-worker-url.js', 'index.js', 'js-loader.js', 'large.js']\n    }, {\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'large.js', 'worker.js']\n    }, {\n      assets: ['bundle-manifest.js', 'get-worker-url.js', 'index.js', 'large.js']\n    }, {\n      assets: ['async.js']\n    }, {\n      assets: ['async.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    await run(b);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should dynamic import files which import raw files","suites":["javascript"],"updatePoint":{"line":1328,"column":56,"index":50563},"line":1328,"code":"  it('should dynamic import files which import raw files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-references-raw/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['local.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['test.txt']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should return all exports as an object when using ES modules","suites":["javascript"],"updatePoint":{"line":1342,"column":66,"index":51097},"line":1342,"code":"  it('should return all exports as an object when using ES modules', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-esm/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'esmodule-helpers.js', 'js-loader.js']\n    }, {\n      assets: ['local.js']\n    }]);\n    let output = (await run(b)).default;\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should duplicate small modules across multiple bundles","suites":["javascript"],"updatePoint":{"line":1354,"column":60,"index":51588},"line":1354,"code":"  it('should duplicate small modules across multiple bundles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-common-small/index.js'));\n    assertBundles(b, [{\n      assets: ['a.js', 'common.js', 'common-dep.js']\n    }, {\n      assets: ['b.js', 'common.js', 'common-dep.js']\n    }, {\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 7);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a separate bundle for large modules shared between bundles","suites":["javascript"],"updatePoint":{"line":1368,"column":78,"index":52161},"line":1368,"code":"  it('should create a separate bundle for large modules shared between bundles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-common-large/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      assets: ['a.js']\n    }, {\n      assets: ['b.js']\n    }, {\n      name: 'index.js',\n      assets: ['index.js', 'c.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'bundle-manifest.js']\n    }, {\n      assets: ['common.js', 'lodash.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 7);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not duplicate a module which is already in a parent bundle","suites":["javascript"],"updatePoint":{"line":1389,"column":71,"index":52852},"line":1389,"code":"  it('should not duplicate a module which is already in a parent bundle', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-hoist-dup/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'common.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['a.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(await output(), 5);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should duplicate an asset if it is not present in every parent bundle","suites":["javascript"],"updatePoint":{"line":1401,"column":75,"index":53340},"line":1401,"code":"  it('should duplicate an asset if it is not present in every parent bundle', async function () {\n    let b = await bundle(['a.js', 'b.js'].map(entry => path.join(__dirname, 'integration/dynamic-hoist-no-dedupe', entry)));\n    assertBundles(b, [{\n      assets: ['c.js', 'common.js', 'esmodule-helpers.js']\n    }, {\n      name: 'b.js',\n      assets: ['b.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      name: 'a.js',\n      assets: ['a.js', 'bundle-url.js', 'common.js', 'cacheLoader.js', 'esmodule-helpers.js', 'js-loader.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should duplicate an asset if it is not available in all possible ancestries","suites":["javascript"],"updatePoint":{"line":1413,"column":81,"index":53909},"line":1413,"code":"  it('should duplicate an asset if it is not available in all possible ancestries', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-hoist-no-dedupe-ancestry/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['a.js', 'common.js']\n    }, {\n      assets: ['b.js']\n    }, {\n      assets: ['c.js']\n    }, {\n      assets: ['d.js', 'common.js']\n    }]);\n    let {\n      default: promise\n    } = await run(b);\n    assert.equal(await promise, 42);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support shared modules with async imports","suites":["javascript"],"updatePoint":{"line":1432,"column":54,"index":54496},"line":1432,"code":"  it('should support shared modules with async imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dynamic-hoist-deep/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'esmodule-helpers.js', 'js-loader.js']\n    }, {\n      assets: ['a.js', 'c.js']\n    }, {\n      assets: ['b.js', 'c.js']\n    }, {\n      assets: ['1.js']\n    }]);\n    let {\n      default: promise\n    } = await run(b);\n    assert.ok(await promise);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring JSON files","suites":["javascript"],"updatePoint":{"line":1449,"column":41,"index":55013},"line":1449,"code":"  it('should support requiring JSON files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/json/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'local.json']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring JSON5 files","suites":["javascript"],"updatePoint":{"line":1459,"column":42,"index":55367},"line":1459,"code":"  it('should support requiring JSON5 files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/json5/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'local.json5']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing a URL to a raw asset","suites":["javascript"],"updatePoint":{"line":1469,"column":51,"index":55732},"line":1469,"code":"  it('should support importing a URL to a raw asset', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/import-raw/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js']\n    }, {\n      type: 'txt',\n      assets: ['test.txt']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert(/^http:\\/\\/localhost\\/test\\.[0-9a-f]+\\.txt$/.test(output()));\n    let stats = await outputFS.stat(path.join(distDir, url.parse(output()).pathname));\n    assert.equal(stats.size, 9);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support referencing a raw asset with static URL and import.meta.url","suites":["javascript"],"updatePoint":{"line":1484,"column":80,"index":56350},"line":1484,"code":"  it('should support referencing a raw asset with static URL and import.meta.url', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/import-raw-import-meta-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'esmodule-helpers.js']\n    }, {\n      type: 'txt',\n      assets: ['test.txt']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('import.meta.url'));\n    let output = await run(b);\n    assert(/^http:\\/\\/localhost\\/test\\.[0-9a-f]+\\.txt$/.test(output.default));\n    let stats = await outputFS.stat(path.join(distDir, output.default.pathname));\n    assert.equal(stats.size, 9);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support referencing a raw asset with static URL and CJS __filename","suites":["javascript"],"updatePoint":{"line":1500,"column":79,"index":57093},"line":1500,"code":"  it('should support referencing a raw asset with static URL and CJS __filename', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/import-raw-import-meta-url/cjs.js'));\n    assertBundles(b, [{\n      name: 'cjs.js',\n      assets: ['cjs.js', 'bundle-url.js', 'esmodule-helpers.js']\n    }, {\n      type: 'txt',\n      assets: ['test.txt']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('import.meta.url'));\n    let output = await run(b);\n    assert(/^http:\\/\\/localhost\\/test\\.[0-9a-f]+\\.txt$/.test(output.default));\n    let stats = await outputFS.stat(path.join(distDir, output.default.pathname));\n    assert.equal(stats.size, 9);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore new URL and import.meta.url with local binding","suites":["javascript"],"updatePoint":{"line":1516,"column":66,"index":57817},"line":1516,"code":"  it('should ignore new URL and import.meta.url with local binding', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/import-raw-import-meta-url/local-url.js'));\n    assertBundles(b, [{\n      name: 'local-url.js',\n      assets: ['esmodule-helpers.js', 'local-url.js']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('\"file:///local-url.js\"'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw a codeframe for a missing raw asset with static URL and import.meta.url","suites":["javascript"],"updatePoint":{"line":1525,"column":90,"index":58292},"line":1525,"code":"  it('should throw a codeframe for a missing raw asset with static URL and import.meta.url', async function () {\n    let fixture = path.join(__dirname, 'integration/import-raw-import-meta-url/missing.js');\n    let code = await inputFS.readFileSync(fixture, 'utf8');\n    await assert.rejects(() => bundle(fixture), {\n      name: 'BuildError',\n      diagnostics: [{\n        codeFrames: [{\n          filePath: fixture,\n          code,\n          codeHighlights: [{\n            end: {\n              column: 36,\n              line: 1\n            },\n            start: {\n              column: 24,\n              line: 1\n            }\n          }]\n        }],\n        message: \"Failed to resolve 'invalid.txt' from './missing.js'\",\n        origin: '@parcel/core'\n      }, {\n        hints: [],\n        message: \"Cannot load file './invalid.txt' in './'.\",\n        origin: '@parcel/resolver-default'\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing a URL to a large raw asset","suites":["javascript"],"updatePoint":{"line":1554,"column":57,"index":59171},"line":1554,"code":"  it('should support importing a URL to a large raw asset', async function () {\n    // 6 megabytes, which exceeds the threshold in summarizeRequest for buffering\n    // entire contents into memory and should stream content instead\n    let assetSizeBytes = 6000000;\n    let distDir = path.join(outputFS.cwd(), '/dist');\n    let fixtureDir = path.join(__dirname, '/integration/import-raw');\n    let inputDir = path.join(__dirname, 'input');\n    await ncp(fixtureDir, inputDir);\n    await outputFS.writeFile(path.join(inputDir, 'test.txt'), Buffer.alloc(assetSizeBytes));\n    let b = await bundle(path.join(inputDir, 'index.js'), {\n      inputFS: overlayFS,\n      defaultTargetOptions: {\n        distDir\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js']\n    }, {\n      type: 'txt',\n      assets: ['test.txt']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert(/^http:\\/\\/localhost\\/test\\.[0-9a-f]+\\.txt$/.test(output()));\n    let stats = await outputFS.stat(path.join(distDir, url.parse(output()).pathname));\n    assert.equal(stats.size, assetSizeBytes);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify JS in production mode","suites":["javascript"],"updatePoint":{"line":1582,"column":41,"index":60316},"line":1582,"code":"  it('should minify JS in production mode', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/uglify/index.js'), {\n      defaultTargetOptions: {\n        shouldOptimize: true,\n        shouldScopeHoist: false\n      }\n    });\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!js.includes('local.a'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should use terser config","suites":["javascript"],"updatePoint":{"line":1595,"column":30,"index":60786},"line":1595,"code":"  it('should use terser config', async function () {\n    await bundle(path.join(__dirname, '/integration/terser-config/index.js'), {\n      defaultTargetOptions: {\n        shouldOptimize: true,\n        shouldScopeHoist: false\n      }\n    });\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!js.includes('console.log'));\n    assert(!js.includes('// This is a comment'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert global variables when needed","suites":["javascript"],"updatePoint":{"line":1606,"column":48,"index":61220},"line":1606,"code":"  it('should insert global variables when needed', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/globals/index.js'));\n    let output = await run(b);\n    assert.deepEqual(output(), {\n      dir: 'integration/globals',\n      file: 'integration/globals/index.js',\n      buf: Buffer.from('browser').toString('base64'),\n      global: true\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should replace __dirname and __filename with path relative to asset.filePath","suites":["javascript"],"updatePoint":{"line":1616,"column":82,"index":61635},"line":1616,"code":"  it('should replace __dirname and __filename with path relative to asset.filePath', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-node-replacements/index.js'));\n    let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(dist.includes('require(\"path\").resolve(__dirname, \"../test/integration/env-node-replacements\")'));\n    assert(dist.includes('require(\"path\").resolve(__dirname, \"../test/integration/env-node-replacements/other\")'));\n    assert(dist.includes('require(\"path\").resolve(__dirname, \"../test/integration/env-node-replacements\", \"index.js\")'));\n    assert(dist.includes('require(\"path\").resolve(__dirname, \"../test/integration/env-node-replacements/sub\")'));\n    assert(dist.includes('require(\"path\").resolve(__dirname, \"../test/integration/env-node-replacements/sub\", \"index.js\")'));\n    let f = await run(b);\n    let output = f();\n    assert.equal(output.data, 'hello');\n    assert.equal(output.other, 'hello');\n    assert.equal(output.firstDirnameTest, path.join(__dirname, '/integration/env-node-replacements/data'));\n    assert.equal(output.secondDirnameTest, path.join(__dirname, '/integration/env-node-replacements/other-data'));\n    assert.equal(output.firstFilenameTest, path.join(__dirname, '/integration/env-node-replacements/index.js'));\n    assert.equal(output.secondFilenameTest, path.join(__dirname, '/integration/env-node-replacements/index.js?query-string=test'));\n    assert.equal(output.sub.dirname, path.join(__dirname, '/integration/env-node-replacements/sub'));\n    assert.equal(output.sub.filename, path.join(__dirname, '/integration/env-node-replacements/sub/index.js'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should replace __dirname and __filename with path relative to asset.filePath with scope hoisting","suites":["javascript"],"updatePoint":{"line":1635,"column":102,"index":63336},"line":1635,"code":"  it('should replace __dirname and __filename with path relative to asset.filePath with scope hoisting', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-node-replacements/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        shouldOptimize: false\n      }\n    });\n    let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(dist.includes('path.resolve(__dirname, \"../test/integration/env-node-replacements\")'));\n    assert(dist.includes('path.resolve(__dirname, \"../test/integration/env-node-replacements/other\")'));\n    assert(dist.includes('path.resolve(__dirname, \"../test/integration/env-node-replacements\", \"index.js\")'));\n    assert(dist.includes('path.resolve(__dirname, \"../test/integration/env-node-replacements/sub\")'));\n    assert(dist.includes('path.resolve(__dirname, \"../test/integration/env-node-replacements/sub\", \"index.js\")'));\n    let f = await run(b);\n    let output = f();\n    assert.equal(output.data, 'hello');\n    assert.equal(output.other, 'hello');\n    assert.equal(output.firstDirnameTest, path.join(__dirname, '/integration/env-node-replacements/data'));\n    assert.equal(output.secondDirnameTest, path.join(__dirname, '/integration/env-node-replacements/other-data'));\n    assert.equal(output.firstFilenameTest, path.join(__dirname, '/integration/env-node-replacements/index.js'));\n    assert.equal(output.secondFilenameTest, path.join(__dirname, '/integration/env-node-replacements/index.js?query-string=test'));\n    assert.equal(output.sub.dirname, path.join(__dirname, '/integration/env-node-replacements/sub'));\n    assert.equal(output.sub.filename, path.join(__dirname, '/integration/env-node-replacements/sub/index.js'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work when multiple files use globals with scope hoisting","suites":["javascript"],"updatePoint":{"line":1660,"column":69,"index":65084},"line":1660,"code":"  it('should work when multiple files use globals with scope hoisting', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/globals/multiple.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        shouldOptimize: false\n      }\n    });\n    let output = await run(b);\n    assert.deepEqual(output, {\n      file: 'integration/globals/multiple.js',\n      other: 'integration/globals/index.js'\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not insert global variables when used in a module specifier","suites":["javascript"],"updatePoint":{"line":1674,"column":72,"index":65565},"line":1674,"code":"  it('should not insert global variables when used in a module specifier', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/globals-module-specifier/a.js'));\n    assertBundles(b, [{\n      assets: ['a.js', 'b.js', 'c.js', 'esmodule-helpers.js']\n    }]);\n    let output = await run(b);\n    assert.deepEqual(output, 1234);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not insert global variables in dead branches","suites":["javascript"],"updatePoint":{"line":1682,"column":57,"index":65907},"line":1682,"code":"  it('should not insert global variables in dead branches', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/globals-unused/a.js'));\n    assertBundles(b, [{\n      assets: ['a.js']\n    }]);\n    let output = await run(b);\n    assert.deepEqual(output, 'foo');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle re-declaration of the global constant","suites":["javascript"],"updatePoint":{"line":1690,"column":57,"index":66201},"line":1690,"code":"  it('should handle re-declaration of the global constant', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/global-redeclare/index.js'));\n    let output = await run(b);\n    assert.deepEqual(output(), false);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert environment variables inserted by a prior transform","suites":["javascript"],"updatePoint":{"line":1695,"column":71,"index":66461},"line":1695,"code":"  it('should insert environment variables inserted by a prior transform', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/env-prior-transform/index.js'));\n    let jsBundle = b.getBundles()[0];\n    let contents = await outputFS.readFile(jsBundle.filePath, 'utf8');\n    assert(!contents.includes('process.env'));\n    assert.equal(await run(b), 'test');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not insert environment variables in node environment","suites":["javascript"],"updatePoint":{"line":1702,"column":65,"index":66838},"line":1702,"code":"  it('should not insert environment variables in node environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-node/index.js'));\n    let output = await run(b);\n    assert.ok(output.toString().includes('process.env'));\n    assert.equal(output(), 'test:test');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not replace process.env.hasOwnProperty with undefined","suites":["javascript"],"updatePoint":{"line":1708,"column":66,"index":67145},"line":1708,"code":"  it('should not replace process.env.hasOwnProperty with undefined', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-hasOwnProperty/index.js'));\n    let output = await run(b);\n    assert.strictEqual(output, false);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not insert environment variables in electron-main environment","suites":["javascript"],"updatePoint":{"line":1713,"column":74,"index":67410},"line":1713,"code":"  it('should not insert environment variables in electron-main environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env/index.js'), {\n      targets: {\n        main: {\n          context: 'electron-main',\n          distDir: path.join(__dirname, '/integration/env/dist.js')\n        }\n      }\n    });\n    let output = await run(b);\n    assert.ok(output.toString().includes('process.env'));\n    assert.equal(output(), 'test:test');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not insert environment variables in electron-renderer environment","suites":["javascript"],"updatePoint":{"line":1726,"column":78,"index":67888},"line":1726,"code":"  it('should not insert environment variables in electron-renderer environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env/index.js'), {\n      targets: {\n        main: {\n          context: 'electron-renderer',\n          distDir: path.join(__dirname, '/integration/env/dist.js')\n        }\n      }\n    });\n    let output = await run(b);\n    assert.ok(output.toString().includes('process.env'));\n    assert.equal(output(), 'test:test');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline NODE_ENV environment variable in browser environment even if disabled","suites":["javascript"],"updatePoint":{"line":1739,"column":89,"index":68381},"line":1739,"code":"  it('should inline NODE_ENV environment variable in browser environment even if disabled', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-nodeenv/index.js'), {\n      env: {\n        FOO: 'abc'\n      }\n    });\n    let output = await run(b);\n    assert.ok(!output.toString().includes('process.env'));\n    assert.equal(output(), 'test:undefined');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not insert environment variables in browser environment if disabled","suites":["javascript"],"updatePoint":{"line":1749,"column":80,"index":68760},"line":1749,"code":"  it('should not insert environment variables in browser environment if disabled', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-disabled/index.js'), {\n      env: {\n        FOOBAR: 'abc'\n      }\n    });\n    let output = await run(b);\n    assert.ok(!output.toString().includes('process.env'));\n    assert.equal(output(), 'undefined:undefined:undefined');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should only insert environment variables in browser environment matching the glob","suites":["javascript"],"updatePoint":{"line":1759,"column":87,"index":69165},"line":1759,"code":"  it('should only insert environment variables in browser environment matching the glob', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-disabled-glob/index.js'), {\n      env: {\n        A_1: 'abc',\n        B_1: 'def',\n        B_2: 'ghi'\n      }\n    });\n    let output = await run(b);\n    assert.ok(!output.toString().includes('process.env'));\n    assert.equal(output(), 'undefined:def:ghi');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should be able to inline environment variables in browser environment","suites":["javascript"],"updatePoint":{"line":1771,"column":75,"index":69588},"line":1771,"code":"  it('should be able to inline environment variables in browser environment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env/index.js'), {\n      env: {\n        NODE_ENV: 'abc'\n      }\n    });\n    let output = await run(b);\n    assert.ok(!output.toString().includes('process.env'));\n    assert.equal(output(), 'abc:abc');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert the user's NODE_ENV as process.env.NODE_ENV if passed","suites":["javascript"],"updatePoint":{"line":1781,"column":73,"index":69950},"line":1781,"code":"  it(\"should insert the user's NODE_ENV as process.env.NODE_ENV if passed\", async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env/index.js'), {\n      env: {\n        NODE_ENV: 'production'\n      }\n    });\n    let output = await run(b);\n    assert.ok(!output.toString().includes('process.env'));\n    assert.equal(output(), 'production:production');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not inline computed accesses to process.env","suites":["javascript"],"updatePoint":{"line":1791,"column":56,"index":70316},"line":1791,"code":"  it('should not inline computed accesses to process.env', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-computed/index.js'), {\n      env: {\n        ABC: 'abc'\n      }\n    });\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('process.env'));\n    let output = await run(b);\n    assert.strictEqual(output, undefined);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline computed accesses with string literals to process.env","suites":["javascript"],"updatePoint":{"line":1802,"column":73,"index":70753},"line":1802,"code":"  it('should inline computed accesses with string literals to process.env', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-computed-string/index.js'), {\n      env: {\n        ABC: 'XYZ'\n      }\n    });\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('process.env'));\n    let output = await run(b);\n    assert.strictEqual(output, 'XYZ');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline environment variables when destructured in a variable declaration","suites":["javascript"],"updatePoint":{"line":1813,"column":85,"index":71206},"line":1813,"code":"  it('should inline environment variables when destructured in a variable declaration', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-destructuring/index.js'), {\n      env: {\n        TEST: 'XYZ'\n      },\n      defaultTargetOptions: {\n        engines: {\n          browsers: '>= 0.25%'\n        }\n      }\n    });\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('process.env'));\n    let output = await run(b);\n    assert.deepEqual(output, {\n      env: {},\n      NODE_ENV: 'test',\n      renamed: 'XYZ',\n      computed: undefined,\n      fallback: 'yo',\n      rest: {},\n      other: 'hi'\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline environment variables when destructured in an assignment","suites":["javascript"],"updatePoint":{"line":1837,"column":76,"index":71892},"line":1837,"code":"  it('should inline environment variables when destructured in an assignment', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-destructuring/assign.js'), {\n      env: {\n        TEST: 'XYZ'\n      },\n      defaultTargetOptions: {\n        engines: {\n          browsers: '>= 0.25%'\n        }\n      }\n    });\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('process.env'));\n    let output = await run(b);\n    assert.deepEqual(output, {\n      env: {},\n      NODE_ENV: 'test',\n      renamed: 'XYZ',\n      computed: undefined,\n      fallback: 'yo',\n      rest: {},\n      result: {}\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline environment variables with in binary expression whose right branch is process.env and left branch is string literal","suites":["javascript"],"updatePoint":{"line":1861,"column":135,"index":72637},"line":1861,"code":"  it('should inline environment variables with in binary expression whose right branch is process.env and left branch is string literal', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-binary-in-expression/index.js'), {\n      env: {\n        ABC: 'any'\n      },\n      defaultTargetOptions: {\n        engines: {\n          browsers: '>= 0.25%'\n        }\n      }\n    });\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!contents.includes('process.env'));\n    let output = await run(b);\n    assert.deepEqual(output, {\n      existVar: 'correct',\n      notExistVar: 'correct'\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert environment variables from a file","suites":["javascript"],"updatePoint":{"line":1880,"column":53,"index":73218},"line":1880,"code":"  it('should insert environment variables from a file', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-file/index.js'));\n\n    // Make sure dotenv doesn't leak its values into the main process's env\n    assert(process.env.FOO == null);\n    let output = await run(b);\n    assert.equal(output, 'bartest');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert environment variables matching the user's NODE_ENV if passed","suites":["javascript"],"updatePoint":{"line":1888,"column":80,"index":73591},"line":1888,"code":"  it(\"should insert environment variables matching the user's NODE_ENV if passed\", async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-file/index.js'), {\n      env: {\n        NODE_ENV: 'production'\n      }\n    });\n    let output = await run(b);\n    assert.equal(output, 'productiontest');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should overwrite environment variables from a file if passed","suites":["javascript"],"updatePoint":{"line":1897,"column":66,"index":73904},"line":1897,"code":"  it('should overwrite environment variables from a file if passed', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-file/index.js'), {\n      env: {\n        BAR: 'baz'\n      }\n    });\n    let output = await run(b);\n    assert.equal(output, 'barbaz');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert environment variables from a file even if entry file is specified with source value in package.json","suites":["javascript"],"updatePoint":{"line":1906,"column":119,"index":74250},"line":1906,"code":"  it('should insert environment variables from a file even if entry file is specified with source value in package.json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/env-file-with-package-source'));\n    let output = await run(b);\n    assert.equal(output, 'bartest');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on process.env mutations","suites":["javascript"],"updatePoint":{"line":1911,"column":43,"index":74483},"line":1911,"code":"  it('should error on process.env mutations', async function () {\n    let filePath = path.join(__dirname, '/integration/env-mutate/index.js');\n    await assert.rejects(bundle(filePath), {\n      diagnostics: [{\n        origin: '@parcel/transformer-js',\n        message: 'Mutating process.env is not supported',\n        hints: null,\n        codeFrames: [{\n          filePath,\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 29\n            }\n          }]\n        }]\n      }, {\n        origin: '@parcel/transformer-js',\n        message: 'Mutating process.env is not supported',\n        hints: null,\n        codeFrames: [{\n          filePath,\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 2,\n              column: 1\n            },\n            end: {\n              line: 2,\n              column: 30\n            }\n          }]\n        }]\n      }, {\n        origin: '@parcel/transformer-js',\n        message: 'Mutating process.env is not supported',\n        hints: null,\n        codeFrames: [{\n          filePath,\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 3,\n              column: 1\n            },\n            end: {\n              line: 3,\n              column: 28\n            }\n          }]\n        }]\n      }, {\n        origin: '@parcel/transformer-js',\n        message: 'Mutating process.env is not supported',\n        hints: null,\n        codeFrames: [{\n          filePath,\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 4,\n              column: 1\n            },\n            end: {\n              line: 4,\n              column: 23\n            }\n          }]\n        }]\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should warn on process.env mutations in node_modules","suites":["javascript"],"updatePoint":{"line":1989,"column":58,"index":76396},"line":1989,"code":"  it('should warn on process.env mutations in node_modules', async function () {\n    let logs = [];\n    let disposable = Logger.onLog(d => logs.push(d));\n    let b = await bundle(path.join(__dirname, '/integration/env-mutate/warn.js'));\n    disposable.dispose();\n    assert.deepEqual(logs, [{\n      type: 'log',\n      level: 'warn',\n      diagnostics: [{\n        origin: '@parcel/transformer-js',\n        message: 'Mutating process.env is not supported',\n        hints: null,\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/env-mutate/node_modules/foo/index.js'),\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 36\n            }\n          }]\n        }]\n      }, {\n        origin: '@parcel/transformer-js',\n        message: 'Mutating process.env is not supported',\n        hints: null,\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/env-mutate/node_modules/foo/index.js'),\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 2,\n              column: 8\n            },\n            end: {\n              line: 2,\n              column: 35\n            }\n          }]\n        }]\n      }, {\n        origin: '@parcel/transformer-js',\n        message: 'Mutating process.env is not supported',\n        hints: null,\n        codeFrames: [{\n          filePath: path.join(__dirname, '/integration/env-mutate/node_modules/foo/index.js'),\n          codeHighlights: [{\n            message: null,\n            start: {\n              line: 3,\n              column: 8\n            },\n            end: {\n              line: 3,\n              column: 30\n            }\n          }]\n        }]\n      }]\n    }]);\n    let output = [];\n    await run(b, {\n      output(o) {\n        output.push(o);\n      }\n    });\n    assert.deepEqual(output, ['foo', true, undefined]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should replace process.browser for target browser","suites":["javascript"],"updatePoint":{"line":2061,"column":55,"index":78397},"line":2061,"code":"  it('should replace process.browser for target browser', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/process/index.js'), {\n      targets: {\n        main: {\n          context: 'browser',\n          distDir: path.join(__dirname, '/integration/process/dist.js')\n        }\n      }\n    });\n    let output = await run(b);\n    assert.ok(output.toString().indexOf('process.browser') === -1);\n    assert.equal(output(), true);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not touch process.browser for target node","suites":["javascript"],"updatePoint":{"line":2074,"column":54,"index":78856},"line":2074,"code":"  it('should not touch process.browser for target node', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/process/index.js'), {\n      targets: {\n        main: {\n          context: 'node',\n          distDir: path.join(__dirname, '/integration/process/dist.js')\n        }\n      }\n    });\n    let output = await run(b);\n    assert.ok(output.toString().indexOf('process.browser') !== -1);\n    assert.equal(output(), false);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not touch process.browser for target electron-main","suites":["javascript"],"updatePoint":{"line":2087,"column":63,"index":79322},"line":2087,"code":"  it('should not touch process.browser for target electron-main', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/process/index.js'), {\n      targets: {\n        main: {\n          context: 'electron-main',\n          distDir: path.join(__dirname, '/integration/process/dist.js')\n        }\n      }\n    });\n    let output = await run(b);\n    assert.ok(output.toString().indexOf('process.browser') !== -1);\n    assert.equal(output(), false);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should replace process.browser for target electron-renderer","suites":["javascript"],"updatePoint":{"line":2100,"column":65,"index":79799},"line":2100,"code":"  it('should replace process.browser for target electron-renderer', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/process/index.js'), {\n      targets: {\n        main: {\n          context: 'electron-renderer',\n          distDir: path.join(__dirname, '/integration/process/dist.js')\n        }\n      }\n    });\n    let output = await run(b);\n    assert.ok(output.toString().indexOf('process.browser') === -1);\n    assert.equal(output(), true);\n    // Running the bundled code has the side effect of setting process.browser = true, which can mess\n    // up the instantiation of typescript.sys within validator-typescript, so we want to reset it.\n    process.browser = undefined;\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support adding implicit dependencies","suites":["javascript"],"line":2116,"code":"  it.skip('should support adding implicit dependencies', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring YAML files","suites":["javascript"],"updatePoint":{"line":2142,"column":41,"index":81203},"line":2142,"code":"  it('should support requiring YAML files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/yaml/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'local.yaml'],\n      childBundles: [{\n        type: 'map'\n      }]\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring TOML files","suites":["javascript"],"updatePoint":{"line":2155,"column":41,"index":81609},"line":2155,"code":"  it('should support requiring TOML files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/toml/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'local.toml'],\n      childBundles: [{\n        type: 'map'\n      }]\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring CoffeeScript files","suites":["javascript"],"updatePoint":{"line":2168,"column":49,"index":82023},"line":2168,"code":"  it('should support requiring CoffeeScript files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/coffee/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'local.coffee']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve the browser field before main","suites":["javascript"],"updatePoint":{"line":2178,"column":50,"index":82389},"line":2178,"code":"  it('should resolve the browser field before main', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-entries/browser.js'));\n    assertBundles(b, [{\n      name: 'browser.js',\n      assets: ['browser.js', 'browser-module.js', 'esmodule-helpers.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output.test, 'function');\n    assert.equal(output.test(), 'pkg-browser');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should exclude resolving specifiers that map to false in the browser field in browser builds","suites":["javascript"],"updatePoint":{"line":2188,"column":98,"index":82868},"line":2188,"code":"  it('should exclude resolving specifiers that map to false in the browser field in browser builds', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-entries/pkg-ignore-browser/index.js'), {\n      targets: ['browsers']\n    });\n    assert.deepEqual(await run(b), {});\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not exclude resolving specifiers that map to false in the browser field in node builds","suites":["javascript"],"updatePoint":{"line":2194,"column":99,"index":83175},"line":2194,"code":"  it('should not exclude resolving specifiers that map to false in the browser field in node builds', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-entries/pkg-ignore-browser/index.js'), {\n      targets: ['node']\n    });\n    assert.equal(await run(b), 'this should only exist in non-browser builds');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not resolve the browser field for --target=node","suites":["javascript"],"line":2200,"code":"  it.skip('should not resolve the browser field for --target=node', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should resolve advanced browser resolution","suites":["javascript"],"line":2215,"code":"  it.skip('should resolve advanced browser resolution', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should not resolve advanced browser resolution with --target=node","suites":["javascript"],"line":2232,"code":"  it.skip('should not resolve advanced browser resolution with --target=node', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should resolve the module field before main if scope-hoisting is enabled","suites":["javascript"],"line":2251,"code":"  it.skip('should resolve the module field before main if scope-hoisting is enabled', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should resolve the module field before main if scope-hoisting is enabled","suites":["javascript"],"line":2265,"code":"  it.skip('should resolve the module field before main if scope-hoisting is enabled', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should resolve the main field","suites":["javascript"],"updatePoint":{"line":2279,"column":35,"index":86439},"line":2279,"code":"  it('should resolve the main field', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-entries/main-field.js'));\n    assertBundles(b, [{\n      name: 'main-field.js',\n      assets: ['main-field.js', 'main.js', 'esmodule-helpers.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output.test, 'function');\n    assert.equal(output.test(), 'pkg-main-module');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify JSON files","suites":["javascript"],"updatePoint":{"line":2289,"column":30,"index":86853},"line":2289,"code":"  it('should minify JSON files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/uglify-json/index.json'), {\n      defaultTargetOptions: {\n        shouldOptimize: true,\n        shouldScopeHoist: false\n      }\n    });\n    let json = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(json.includes('{\"test\":\"test\"}'));\n    let output = await run(b);\n    assert.deepEqual(output, {\n      test: 'test'\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify JSON5 files","suites":["javascript"],"updatePoint":{"line":2303,"column":31,"index":87324},"line":2303,"code":"  it('should minify JSON5 files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/uglify-json5/index.json5'), {\n      defaultTargetOptions: {\n        shouldOptimize: true,\n        shouldScopeHoist: false\n      }\n    });\n    let json = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(json.includes('{\"test\":\"test\"}'));\n    let output = await run(b);\n    assert.deepEqual(output, {\n      test: 'test'\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify YAML for production","suites":["javascript"],"line":2317,"code":"  it.skip('should minify YAML for production', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should minify TOML for production","suites":["javascript"],"updatePoint":{"line":2330,"column":39,"index":88281},"line":2330,"code":"  it('should minify TOML for production', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/toml/index.js'), {\n      defaultTargetOptions: {\n        shouldOptimize: true,\n        shouldScopeHoist: false\n      }\n    });\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n    let json = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(json.includes('{a:1,b:{c:2}}'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support optional dependencies in try...catch blocks","suites":["javascript"],"updatePoint":{"line":2343,"column":64,"index":88792},"line":2343,"code":"  it('should support optional dependencies in try...catch blocks', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/optional-dep/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }]);\n    let output = await run(b);\n    assert.equal(Object.getPrototypeOf(output).constructor.name, 'Error');\n    assert(/Cannot find module ['\"]optional-dep['\"]/.test(output.message), 'Should set correct error message');\n    assert.equal(output.code, 'MODULE_NOT_FOUND');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support excluding dependencies in falsy branches","suites":["javascript"],"updatePoint":{"line":2354,"column":61,"index":89321},"line":2354,"code":"  it('should support excluding dependencies in falsy branches', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/falsy-dep/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'true-alternate.js', 'true-consequent.js']\n    }]);\n    let output = await run(b);\n    assert.equal(output, 2);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not autoinstall if resolve failed on installed module","suites":["javascript"],"line":2363,"code":"  it.skip('should not autoinstall if resolve failed on installed module', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should not autoinstall if resolve failed on aliased module","suites":["javascript"],"line":2373,"code":"  it.skip('should not autoinstall if resolve failed on aliased module', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should ignore require if it is defined in the scope","suites":["javascript"],"updatePoint":{"line":2383,"column":57,"index":90492},"line":2383,"code":"  it('should ignore require if it is defined in the scope', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/require-scope/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output.test, 'object');\n    let failed = Object.keys(output.test).some(key => output.test[key] !== 'test passed');\n    assert.equal(failed, false);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should expose to CommonJS entry point","suites":["javascript"],"updatePoint":{"line":2394,"column":43,"index":90938},"line":2394,"code":"  it('should expose to CommonJS entry point', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/entry-point/index.js'));\n    let module = {};\n    await run(b, {\n      module,\n      exports: {}\n    });\n    assert.equal(module.exports(), 'Test!');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should expose to RequireJS entry point","suites":["javascript"],"updatePoint":{"line":2403,"column":44,"index":91221},"line":2403,"code":"  it('should expose to RequireJS entry point', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/entry-point/index.js'));\n    let test;\n    const mockDefine = function (f) {\n      test = f();\n    };\n    mockDefine.amd = true;\n    await run(b, {\n      define: mockDefine,\n      module: undefined\n    });\n    assert.equal(test(), 'Test!');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should expose variable with --browser-global","suites":["javascript"],"line":2416,"code":"  it.skip('should expose variable with --browser-global', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should set `define` to undefined so AMD checks in UMD modules do not pass","suites":["javascript"],"line":2427,"code":"  it.skip('should set `define` to undefined so AMD checks in UMD modules do not pass', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should package successfully with comments on last line","suites":["javascript"],"updatePoint":{"line":2440,"column":60,"index":92360},"line":2440,"code":"  it('should package successfully with comments on last line', async function () {\n    let b = await bundle(path.join(__dirname, `/integration/js-comment/index.js`));\n    let output = await run(b);\n    assert.equal(output, 'Hello World!');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should package successfully with comments on last line and minification","suites":["javascript"],"updatePoint":{"line":2445,"column":77,"index":92623},"line":2445,"code":"  it('should package successfully with comments on last line and minification', async function () {\n    let b = await bundle(path.join(__dirname, `/integration/js-comment/index.js`));\n    let output = await run(b);\n    assert.equal(output, 'Hello World!');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should package successfully with comments on last line and scope hoisting","suites":["javascript"],"updatePoint":{"line":2450,"column":79,"index":92888},"line":2450,"code":"  it('should package successfully with comments on last line and scope hoisting', async function () {\n    let b = await bundle(path.join(__dirname, `/integration/js-comment/index.js`), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let output = await run(b);\n    assert.equal(output, 'Hello World!');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should package successfully with comments on last line, scope hoisting and minification","suites":["javascript"],"updatePoint":{"line":2459,"column":93,"index":93245},"line":2459,"code":"  it('should package successfully with comments on last line, scope hoisting and minification', async function () {\n    let b = await bundle(path.join(__dirname, `/integration/js-comment/index.js`), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true,\n        shouldOptimize: true\n      }\n    });\n    let output = await run(b);\n    assert.equal(output, 'Hello World!');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not replace toplevel this with undefined in CommonJS without scope-hoisting","suites":["javascript"],"updatePoint":{"line":2469,"column":88,"index":93627},"line":2469,"code":"  it('should not replace toplevel this with undefined in CommonJS without scope-hoisting', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/js-this-commonjs/a.js'));\n    let output;\n    function result(v) {\n      output = v;\n    }\n    await run(b, {\n      result\n    });\n    assert.deepEqual(output, [{\n      foo: 2\n    }, 1234]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not replace toplevel this with undefined in CommonJS when scope-hoisting","suites":["javascript"],"updatePoint":{"line":2482,"column":85,"index":93992},"line":2482,"code":"  it('should not replace toplevel this with undefined in CommonJS when scope-hoisting', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/js-this-commonjs/a.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let output;\n    function result(v) {\n      output = v;\n    }\n    await run(b, {\n      result\n    });\n    assert.deepEqual(output, [{\n      foo: 2\n    }, 1234]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should replace toplevel this with undefined in ESM without scope-hoisting","suites":["javascript"],"updatePoint":{"line":2499,"column":79,"index":94429},"line":2499,"code":"  it('should replace toplevel this with undefined in ESM without scope-hoisting', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/js-this-es6/a.js'));\n    let output;\n    function result(v) {\n      output = v;\n    }\n    await run(b, {\n      result\n    });\n    assert.deepEqual(output, [undefined, 1234]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should replace toplevel this with undefined in ESM when scope-hoisting","suites":["javascript"],"updatePoint":{"line":2510,"column":76,"index":94769},"line":2510,"code":"  it('should replace toplevel this with undefined in ESM when scope-hoisting', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/js-this-es6/a.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let output;\n    function result(v) {\n      output = v;\n    }\n    await run(b, {\n      result\n    });\n    assert.deepEqual(output, [undefined, 1234]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not dedupe imports with different contents","suites":["javascript"],"line":2525,"code":"  it.skip('should not dedupe imports with different contents', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should not dedupe imports with same content but different absolute dependency paths","suites":["javascript"],"line":2533,"code":"  it.skip('should not dedupe imports with same content but different absolute dependency paths', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should dedupe imports with same content and same dependency paths","suites":["javascript"],"line":2541,"code":"  it.skip('should dedupe imports with same content and same dependency paths', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should not dedupe assets that exist in more than one bundle","suites":["javascript"],"line":2557,"code":"  it.skip('should not dedupe assets that exist in more than one bundle', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support importing HTML from JS async","suites":["javascript"],"line":2570,"code":"  it.skip('should support importing HTML from JS async', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support importing HTML from JS async with --target=node","suites":["javascript"],"line":2597,"code":"  it.skip('should support importing HTML from JS async with --target=node', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support importing HTML from JS sync","suites":["javascript"],"line":2625,"code":"  it.skip('should support importing HTML from JS sync', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should stub require.cache","suites":["javascript"],"line":2661,"code":"  it.skip('should stub require.cache', async function () {","file":"javascript.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support async importing the same module from different bundles","suites":["javascript"],"updatePoint":{"line":2667,"column":75,"index":100170},"line":2667,"code":"  it('should support async importing the same module from different bundles', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/shared-bundlegroup/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'esmodule-helpers.js', 'js-loader.js']\n    }, {\n      assets: ['a.js']\n    }, {\n      assets: ['b.js']\n    }, {\n      assets: ['c.js']\n    }]);\n    let {\n      default: promise\n    } = await run(b);\n    assert.deepEqual(await promise, ['hello from a test', 'hello from b test']);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not create shared bundles from contents of entries","suites":["javascript"],"updatePoint":{"line":2684,"column":63,"index":100738},"line":2684,"code":"  it('should not create shared bundles from contents of entries', async () => {\n    let b = await bundle(['a.js', 'b.js'].map(entry => path.join(__dirname, '/integration/no-shared-bundles-from-entries/', entry)));\n    assertBundles(b, [{\n      name: 'a.js',\n      assets: ['a.js', 'esmodule-helpers.js', 'lodash.js']\n    }, {\n      name: 'b.js',\n      assets: ['b.js', 'esmodule-helpers.js', 'lodash.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should import the same dependency multiple times in the same bundle","suites":["javascript"],"updatePoint":{"line":2694,"column":73,"index":101168},"line":2694,"code":"  it('should import the same dependency multiple times in the same bundle', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/same-dependency-multiple-times/a1.js'));\n    await run(b);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a bundle's compiled text with `bundle-text`","suites":["javascript"],"updatePoint":{"line":2698,"column":63,"index":101373},"line":2698,"code":"  it(\"should inline a bundle's compiled text with `bundle-text`\", async () => {\n    let b = await bundle(path.join(__dirname, '/integration/bundle-text/index.js'));\n    let cssBundleContent = (await run(b)).default;\n    assert(cssBundleContent.startsWith(`body {\n  background-color: #000;\n}\n\n.svg-img {\n  background-image: url(\"data:image/svg+xml,%3Csvg%3E%0A%0A%3C%2Fsvg%3E%0A\");\n}`));\n    assert(!cssBundleContent.includes('sourceMappingURL'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not include the runtime manifest for `bundle-text`","suites":["javascript"],"updatePoint":{"line":2710,"column":63,"index":101826},"line":2710,"code":"  it('should not include the runtime manifest for `bundle-text`', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/bundle-text/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false,\n        shouldOptimize: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      type: 'js',\n      assets: ['esmodule-helpers.js', 'index.js']\n    }, {\n      type: 'svg',\n      assets: ['img.svg']\n    }, {\n      type: 'css',\n      assets: ['text.scss']\n    }]);\n    let cssBundleContent = (await run(b)).default;\n    assert(cssBundleContent.startsWith(`body {\n  background-color: #000;\n}\n\n.svg-img {\n  background-image: url(\"data:image/svg+xml,%3Csvg%3E%0A%0A%3C%2Fsvg%3E%0A\");\n}`));\n    assert(!cssBundleContent.includes('sourceMappingURL'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline an HTML bundle's compiled text with `bundle-text`","suites":["javascript"],"updatePoint":{"line":2739,"column":69,"index":102656},"line":2739,"code":"  it(\"should inline an HTML bundle's compiled text with `bundle-text`\", async () => {\n    let b = await bundle(path.join(__dirname, '/integration/bundle-text/index.html'));\n    let res = await run(b);\n    assert.equal(res.default, '<p>test</p>\\n');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline an HTML bundle and inline scripts with `bundle-text`","suites":["javascript"],"updatePoint":{"line":2744,"column":72,"index":102914},"line":2744,"code":"  it('should inline an HTML bundle and inline scripts with `bundle-text`', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/bundle-text/inline.js'));\n    let res = await run(b);\n    assert.equal(res.default, `<p>test</p>\\n<script>console.log(\"hi\");\\n\\n</script>\\n`);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a JS bundle's compiled text with `bundle-text` and HMR enabled","suites":["javascript"],"updatePoint":{"line":2749,"column":82,"index":103222},"line":2749,"code":"  it(\"should inline a JS bundle's compiled text with `bundle-text` and HMR enabled\", async () => {\n    let b = await bundle(path.join(__dirname, '/integration/bundle-text/javascript.js'), {\n      hmrOptions: {}\n    });\n    let res = await run(b);\n    let log;\n    let ctx = vm.createContext({\n      console: {\n        log(x) {\n          log = x;\n        }\n      }\n    });\n    vm.runInContext(res.default, ctx);\n    assert.equal(log, 'hi');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a JS bundle's compiled text with `bundle-text` with symbol propagation","suites":["javascript"],"updatePoint":{"line":2765,"column":90,"index":103676},"line":2765,"code":"  it(\"should inline a JS bundle's compiled text with `bundle-text` with symbol propagation\", async () => {\n    let b = await bundle(path.join(__dirname, '/integration/bundle-text/javascript.js'), {\n      mode: 'production'\n    });\n    let res = await run(b);\n    let log;\n    let ctx = vm.createContext({\n      console: {\n        log(x) {\n          log = x;\n        }\n      }\n    });\n    vm.runInContext(res, ctx);\n    assert.equal(log, 'hi');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline a bundle's compiled text with `bundle-text` asynchronously","suites":["javascript"],"updatePoint":{"line":2781,"column":78,"index":104114},"line":2781,"code":"  it(\"should inline a bundle's compiled text with `bundle-text` asynchronously\", async () => {\n    let b = await bundle(path.join(__dirname, '/integration/bundle-text/async.js'));\n    let promise = (await run(b)).default;\n    assert.equal(typeof promise.then, 'function');\n    let cssBundleContent = await promise;\n    assert(cssBundleContent.startsWith(`body {\n  background-color: #000;\n}\n\n.svg-img {\n  background-image: url(\"data:image/svg+xml,%3Csvg%3E%0A%0A%3C%2Fsvg%3E%0A\");\n}`));\n    assert(!cssBundleContent.includes('sourceMappingURL'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline text content as url-encoded text and mime type with `data-url:*` imports","suites":["javascript"],"updatePoint":{"line":2795,"column":92,"index":104680},"line":2795,"code":"  it('should inline text content as url-encoded text and mime type with `data-url:*` imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/data-url/text.js'));\n    assert.equal((await run(b)).default, 'data:image/svg+xml,%3Csvg%20width%3D%22120%22%20height%3D%22120%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%20%20%3Cfilter%20id%3D%22blur-_.%21~%2a%22%3E%0A%20%20%20%20%3CfeGaussianBlur%20stdDeviation%3D%225%22%3E%3C%2FfeGaussianBlur%3E%0A%20%20%3C%2Ffilter%3E%0A%20%20%3Ccircle%20cx%3D%2260%22%20cy%3D%2260%22%20r%3D%2250%22%20fill%3D%22green%22%20filter%3D%22url%28%27%23blur-_.%21~%2a%27%29%22%3E%3C%2Fcircle%3E%0A%3C%2Fsvg%3E%0A');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should inline binary content as url-encoded base64 and mime type with `data-url:*` imports","suites":["javascript"],"updatePoint":{"line":2799,"column":96,"index":105376},"line":2799,"code":"  it('should inline binary content as url-encoded base64 and mime type with `data-url:*` imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/data-url/binary.js'));\n    ``;\n    assert((await run(b)).default.startsWith('data:image/webp;base64,UklGR'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support both pipeline and non-pipeline imports","suites":["javascript"],"updatePoint":{"line":2804,"column":59,"index":105628},"line":2804,"code":"  it('should support both pipeline and non-pipeline imports', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/multi-pipeline/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'esmodule-helpers.js']\n    }, {\n      name: 'index.css',\n      assets: ['style.css']\n    }, {\n      type: 'css',\n      assets: ['style.css']\n    }]);\n    assert((await run(b)).default.startsWith('.test'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect typescript style async requires in commonjs","suites":["javascript"],"updatePoint":{"line":2818,"column":63,"index":106083},"line":2818,"code":"  it('should detect typescript style async requires in commonjs', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/require-async/ts.js'));\n    assertBundles(b, [{\n      name: 'ts.js',\n      assets: ['ts.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.equal(await run(b), 2);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect typescript style async requires in commonjs with esModuleInterop flag","suites":["javascript"],"updatePoint":{"line":2828,"column":89,"index":106479},"line":2828,"code":"  it('should detect typescript style async requires in commonjs with esModuleInterop flag', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/require-async/ts-interop.js'));\n    assertBundles(b, [{\n      name: 'ts-interop.js',\n      assets: ['ts-interop.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.deepEqual(await run(b), {\n      default: 2\n    });\n    let jsBundle = b.getBundles()[0];\n    let contents = await outputFS.readFile(jsBundle.filePath, 'utf8');\n    assert(/.then\\(function\\(res\\) {\\n.*return __importStar\\(res\\)/.test(contents));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect typescript style async requires in commonjs with esModuleInterop flag and arrow functions","suites":["javascript"],"updatePoint":{"line":2843,"column":109,"index":107140},"line":2843,"code":"  it('should detect typescript style async requires in commonjs with esModuleInterop flag and arrow functions', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/require-async/ts-interop-arrow.js'));\n    assertBundles(b, [{\n      name: 'ts-interop-arrow.js',\n      assets: ['ts-interop-arrow.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.deepEqual(await run(b), {\n      default: 2\n    });\n    let jsBundle = b.getBundles()[0];\n    let contents = await outputFS.readFile(jsBundle.filePath, 'utf8');\n    assert(/.then\\(\\(res\\)=>__importStar\\(res\\)/.test(contents));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect rollup style async requires in commonjs","suites":["javascript"],"updatePoint":{"line":2858,"column":59,"index":107750},"line":2858,"code":"  it('should detect rollup style async requires in commonjs', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/require-async/rollup.js'));\n    assertBundles(b, [{\n      name: 'rollup.js',\n      assets: ['rollup.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.equal(await run(b), 2);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should only detect requires that are returned from the promise","suites":["javascript"],"updatePoint":{"line":2868,"column":68,"index":108137},"line":2868,"code":"  it('should only detect requires that are returned from the promise', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/require-async/sync.js'));\n    assertBundles(b, [{\n      name: 'sync.js',\n      assets: ['sync.js', 'async.js']\n    }]);\n    assert.equal(await run(b), 5);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should properly chain a dynamic import wrapped in a Promise.resolve()","suites":["javascript"],"updatePoint":{"line":2876,"column":75,"index":108450},"line":2876,"code":"  it('should properly chain a dynamic import wrapped in a Promise.resolve()', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/require-async/resolve-chain.js'));\n    assertBundles(b, [{\n      name: 'resolve-chain.js',\n      assets: ['resolve-chain.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.equal(await run(b), 1337);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect parcel style async requires in commonjs","suites":["javascript"],"updatePoint":{"line":2886,"column":59,"index":108852},"line":2886,"code":"  it('should detect parcel style async requires in commonjs', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/require-async/parcel.js'));\n    assertBundles(b, [{\n      name: 'parcel.js',\n      assets: ['parcel.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.equal(await run(b), 2);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect requires in commonjs with plain template literals","suites":["javascript"],"updatePoint":{"line":2896,"column":69,"index":109240},"line":2896,"code":"  it('should detect requires in commonjs with plain template literals', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/commonjs-template-literal-plain/index.js'));\n    let dist = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n    assert(dist.includes('$cPUKg$lodash = require(\"lodash\");'));\n    let add = await run(b);\n    assert.equal(add(2, 3), 5);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect requires in commonjs with plain template literals","suites":["javascript"],"updatePoint":{"line":2903,"column":69,"index":109668},"line":2903,"code":"  it(`should detect requires in commonjs with plain template literals`, async function () {\n    let b = await bundle(path.join(__dirname, '/integration/commonjs-template-literal-interpolation/index.js'));\n    let dist = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n    assert(dist.includes('const add = require(`lodash/${$8cad8166811e0063$var$fn}`);'));\n    let add = await run(b);\n    assert.equal(add(2, 3), 5);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"only updates bundle names of changed bundles for browsers","suites":["javascript"],"updatePoint":{"line":2910,"column":63,"index":110122},"line":2910,"code":"  it('only updates bundle names of changed bundles for browsers', async () => {\n    let fixtureDir = path.join(__dirname, '/integration/name-invalidation');\n    let _bundle = () => bundle(path.join(fixtureDir, 'index.js'), {\n      inputFS: overlayFS,\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false,\n        shouldOptimize: false\n      }\n    });\n    let first = await _bundle();\n    assert.equal(await (await run(first)).default, 42);\n    let bPath = path.join(fixtureDir, 'b.js');\n    await overlayFS.mkdirp(fixtureDir);\n    overlayFS.writeFile(bPath, (await overlayFS.readFile(bPath, 'utf8')).replace('42', '43'));\n    let second = await _bundle();\n    assert.equal(await (await run(second)).default, 43);\n    let getBundleNameWithPrefix = (b, prefix) => b.getBundles().map(bundle => path.basename(bundle.filePath)).find(name => name.startsWith(prefix));\n    assert.equal(getBundleNameWithPrefix(first, 'a'), getBundleNameWithPrefix(second, 'a'));\n    assert.notEqual(getBundleNameWithPrefix(first, 'b'), getBundleNameWithPrefix(second, 'b'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can load the same resource when referenced in multiple bundles","suites":["javascript"],"updatePoint":{"line":2931,"column":68,"index":111219},"line":2931,"code":"  it('can load the same resource when referenced in multiple bundles', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/same-resource-multiple-bundles/index.js'));\n    let res = await run(b);\n    assert(url.parse(await res.default()).pathname.startsWith('/resource'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can static import and dynamic import in the same bundle without creating a new bundle","suites":["javascript"],"updatePoint":{"line":2936,"column":91,"index":111542},"line":2936,"code":"  it('can static import and dynamic import in the same bundle without creating a new bundle', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/sync-async/same-bundle.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'same-bundle.js',\n      assets: ['same-bundle.js', 'get-dep.js', 'get-dep-2.js', 'dep.js', 'esmodule-helpers.js']\n    }]);\n    assert.deepEqual(await (await run(b)).default, [42, 42, 42]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"async dependency can be resolved internally and externally from two different bundles","suites":["javascript"],"updatePoint":{"line":2949,"column":91,"index":112076},"line":2949,"code":"  it('async dependency can be resolved internally and externally from two different bundles', async () => {\n    let b = await bundle(['entry1.js', 'entry2.js'].map(entry => path.join(__dirname, '/integration/async-dep-internal-external/', entry)), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      assets: ['async.js']\n    }, {\n      name: 'entry1.js',\n      assets: ['child.js', 'entry1.js', 'async.js']\n    }, {\n      name: 'entry2.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'child.js', 'entry2.js', 'js-loader.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can static import and dynamic import in the same bundle ancestry without creating a new bundle","suites":["javascript"],"updatePoint":{"line":2966,"column":100,"index":112737},"line":2966,"code":"  it('can static import and dynamic import in the same bundle ancestry without creating a new bundle', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/sync-async/same-ancestry.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'same-ancestry.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'dep.js', 'js-loader.js', 'same-ancestry.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['get-dep.js']\n    }]);\n    assert.deepEqual(await (await run(b)).default, [42, 42]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can static import and dynamic import in the same bundle when another bundle requires async","suites":["javascript"],"updatePoint":{"line":2981,"column":96,"index":113359},"line":2981,"code":"  it('can static import and dynamic import in the same bundle when another bundle requires async', async () => {\n    let b = await bundle(['same-bundle.js', 'get-dep.js'].map(entry => path.join(__dirname, '/integration/sync-async/', entry)), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      assets: ['dep.js']\n    }, {\n      name: 'same-bundle.js',\n      assets: ['same-bundle.js', 'get-dep.js', 'get-dep-2.js', 'dep.js', 'esmodule-helpers.js']\n    }, {\n      name: 'get-dep.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'get-dep.js', 'js-loader.js', 'esmodule-helpers.js']\n    }]);\n    let bundles = b.getBundles();\n    let sameBundle = bundles.find(b => b.name === 'same-bundle.js');\n    let getDep = bundles.find(b => b.name === 'get-dep.js');\n    assert.deepEqual(await (await runBundle(b, sameBundle)).default, [42, 42, 42]);\n    assert.deepEqual(await (await runBundle(b, getDep)).default, 42);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can share dependencies between a shared bundle and its sibling's descendants","suites":["javascript"],"updatePoint":{"line":3003,"column":82,"index":114370},"line":3003,"code":"  it(\"can share dependencies between a shared bundle and its sibling's descendants\", async () => {\n    let b = await bundle(path.join(__dirname, '/integration/shared-exports-for-sibling-descendant/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      assets: ['wraps.js', 'lodash.js']\n    }, {\n      assets: ['a.js']\n    }, {\n      assets: ['child.js']\n    }, {\n      assets: ['grandchild.js']\n    }, {\n      assets: ['b.js']\n    }, {\n      name: 'index.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'index.js', 'js-loader.js', 'esmodule-helpers.js']\n    }]);\n    assert.deepEqual(await (await run(b)).default, [3, 5]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can run an entry bundle whose entry asset is present in another bundle","suites":["javascript"],"updatePoint":{"line":3026,"column":76,"index":115115},"line":3026,"code":"  it('can run an entry bundle whose entry asset is present in another bundle', async () => {\n    let b = await bundle(['index.js', 'value.js'].map(basename => path.join(__dirname, '/integration/sync-entry-shared', basename)));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'esmodule-helpers.js']\n    }, {\n      name: 'value.js',\n      assets: ['value.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.equal(await (await run(b)).default, 43);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can run an async bundle whose entry asset is present in another bundle","suites":["javascript"],"updatePoint":{"line":3039,"column":76,"index":115677},"line":3039,"code":"  it('can run an async bundle whose entry asset is present in another bundle', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/async-entry-shared/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['value.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.deepEqual(await (await run(b)).default, [42, 43]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should display a codeframe on a Terser parse error","suites":["javascript"],"updatePoint":{"line":3051,"column":56,"index":116140},"line":3051,"code":"  it('should display a codeframe on a Terser parse error', async () => {\n    let fixture = path.join(__dirname, 'integration/terser-codeframe/index.js');\n    let code = await inputFS.readFileSync(fixture, 'utf8');\n    await assert.rejects(() => bundle(fixture, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: 'Name expected',\n        origin: '@parcel/optimizer-terser',\n        codeFrames: [{\n          filePath: undefined,\n          language: 'js',\n          code,\n          codeHighlights: [{\n            message: 'Name expected',\n            start: {\n              column: 4,\n              line: 1\n            },\n            end: {\n              column: 4,\n              line: 1\n            }\n          }]\n        }],\n        hints: [\"It's likely that Terser doesn't support this syntax yet.\"]\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can run an async bundle that depends on a nonentry asset in a sibling","suites":["javascript"],"updatePoint":{"line":3083,"column":75,"index":117075},"line":3083,"code":"  it('can run an async bundle that depends on a nonentry asset in a sibling', async () => {\n    let b = await bundle(['index.js', 'other-entry.js'].map(basename => path.join(__dirname, '/integration/async-entry-shared-sibling', basename)));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'esmodule-helpers.js']\n    }, {\n      name: 'other-entry.js',\n      assets: ['other-entry.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['a.js', 'value.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['b.js']\n    }]);\n    assert.deepEqual(await (await run(b)).default, 43);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can share sibling bundles reachable from a common dependency","suites":["javascript"],"updatePoint":{"line":3098,"column":66,"index":117749},"line":3098,"code":"  it('can share sibling bundles reachable from a common dependency', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/shared-sibling-common-dependency/index.js'));\n    let bundles = b.getBundles();\n    let asyncJsBundles = bundles.filter(b => !b.needsStableName && b.type === 'js');\n    assert.equal(asyncJsBundles.length, 2);\n\n    // Every bundlegroup with an async js bundle should have the corresponding css\n    for (let bundle of asyncJsBundles) {\n      for (let bundleGroup of b.getBundleGroupsContainingBundle(bundle)) {\n        let bundlesInGroup = b.getBundlesInBundleGroup(bundleGroup);\n        assert(bundlesInGroup.find(s => s.type === 'css'));\n      }\n    }\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw a diagnostic for unkown pipelines","suites":["javascript"],"updatePoint":{"line":3112,"column":52,"index":118436},"line":3112,"code":"  it('should throw a diagnostic for unkown pipelines', async function () {\n    let fixture = path.join(__dirname, 'integration/pipeline-unknown/a.js');\n    let code = await inputFS.readFileSync(fixture, 'utf8');\n    await assert.rejects(() => bundle(fixture), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: \"Failed to resolve 'strange-pipeline:./b.js' from './a.js'\",\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: fixture,\n          code,\n          codeHighlights: [{\n            start: {\n              column: 19,\n              line: 1\n            },\n            end: {\n              column: 43,\n              line: 1\n            }\n          }]\n        }]\n      }, {\n        message: \"Unknown url scheme or pipeline 'strange-pipeline:'\",\n        origin: '@parcel/resolver-default'\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can create a bundle starting with a dot","suites":["javascript"],"updatePoint":{"line":3140,"column":45,"index":119283},"line":3140,"code":"  it('can create a bundle starting with a dot', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/dotfile-bundle/index.js'));\n    assertBundles(b, [{\n      name: '.output.js',\n      assets: ['index.js']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not automatically name bundle files starting with a dot","suites":["javascript"],"updatePoint":{"line":3147,"column":68,"index":119554},"line":3147,"code":"  it('should not automatically name bundle files starting with a dot', async function () {\n    await bundle(path.join(__dirname, '/integration/bundle-naming/.invisible/index.js'));\n    let bundleFiles = await outputFS.readdir(distDir);\n    let renamedSomeFiles = bundleFiles.some(currFile => currFile.startsWith('invisible.'));\n    let namedWithDot = bundleFiles.some(currFile => currFile.startsWith('.invisible.'));\n    assert.equal(renamedSomeFiles, true);\n    assert.equal(namedWithDot, false);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support duplicate re-exports without scope hoisting","suites":["javascript"],"updatePoint":{"line":3155,"column":64,"index":120054},"line":3155,"code":"  it('should support duplicate re-exports without scope hoisting', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-duplicate-re-exports/index.js'));\n    let res = await run(b);\n    assert.equal(res.a, 'a');\n    assert.equal(res.b, 'b');\n    assert.equal(typeof res.c, 'function');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should prioritize named exports before re-exports withput scope hoisting (before)","suites":["javascript"],"updatePoint":{"line":3162,"column":87,"index":120398},"line":3162,"code":"  it('should prioritize named exports before re-exports withput scope hoisting (before)', async () => {\n    let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/re-export-priority/entry-a.mjs'));\n    let res = await run(b, null, {\n      require: false\n    });\n    assert.equal(res.output, 2);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should prioritize named exports before re-exports without scope hoisting (after)","suites":["javascript"],"updatePoint":{"line":3169,"column":86,"index":120717},"line":3169,"code":"  it('should prioritize named exports before re-exports without scope hoisting (after)', async () => {\n    let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/re-export-priority/entry-b.mjs'));\n    let res = await run(b, null, {\n      require: false\n    });\n    assert.equal(res.output, 2);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should exclude default from export all declaration","suites":["javascript"],"updatePoint":{"line":3176,"column":56,"index":121006},"line":3176,"code":"  it('should exclude default from export all declaration', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-export-all/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res, {\n      a: 4\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not use arrow functions for reexport declarations unless supported","suites":["javascript"],"updatePoint":{"line":3183,"column":79,"index":121275},"line":3183,"code":"  it('should not use arrow functions for reexport declarations unless supported', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-export-arrow-support/index.js'));\n    let content = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!content.includes('=>'));\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support import namespace declarations of other ES modules","suites":["javascript"],"updatePoint":{"line":3188,"column":70,"index":121586},"line":3188,"code":"  it('should support import namespace declarations of other ES modules', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-namespace/a.js'));\n    let res = await run(b);\n    assert.deepEqual(res, {\n      a: 4,\n      default: 1\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support import namespace declarations of class from CJS","suites":["javascript"],"updatePoint":{"line":3196,"column":68,"index":121864},"line":3196,"code":"  it('should support import namespace declarations of class from CJS', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-namespace/b.js'));\n    let res = await run(b);\n    assert.equal(typeof res, 'function');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support import namespace declarations of object from CJS","suites":["javascript"],"updatePoint":{"line":3201,"column":69,"index":122120},"line":3201,"code":"  it('should support import namespace declarations of object from CJS', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-namespace/c.js'));\n    let res = await run(b);\n    assert.deepEqual(res, {\n      foo: 2,\n      default: 3\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support export namespace declarations","suites":["javascript"],"updatePoint":{"line":3209,"column":50,"index":122382},"line":3209,"code":"  it('should support export namespace declarations', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-export-namespace/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res, {\n      ns: {\n        a: 4,\n        default: 1\n      }\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support export default declarations","suites":["javascript"],"updatePoint":{"line":3219,"column":48,"index":122668},"line":3219,"code":"  it('should support export default declarations', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-export-default/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res, {\n      other: 1\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with many different types of exports","suites":["javascript"],"updatePoint":{"line":3226,"column":54,"index":122920},"line":3226,"code":"  it('should work with many different types of exports', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-export-many/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res, {\n      foo: 'foo',\n      bar: 'bar',\n      default: 'baz',\n      boo: 'boo',\n      foobar: 'foobar',\n      type1: 'type1',\n      type2: 'type2'\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly export functions","suites":["javascript"],"updatePoint":{"line":3239,"column":39,"index":123282},"line":3239,"code":"  it('should correctly export functions', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-export-functions/index.js'));\n    let res = await run(b);\n    assert.deepEqual(Object.keys(res), ['foo', 'bar']);\n    assert.strictEqual(res.foo('test'), 'foo:test');\n    assert.strictEqual(res.bar('test'), 'bar:test');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle exports of imports","suites":["javascript"],"updatePoint":{"line":3246,"column":38,"index":123631},"line":3246,"code":"  it('should handle exports of imports', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-export-import/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res, {\n      other: 2\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle simultaneous import and reexports of the same identifier","suites":["javascript"],"updatePoint":{"line":3253,"column":76,"index":123904},"line":3253,"code":"  it('should handle simultaneous import and reexports of the same identifier', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-export-import-same/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res, {\n      foo: '123',\n      bar: '1234'\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate a unique variable name for imports","suites":["javascript"],"updatePoint":{"line":3261,"column":56,"index":124183},"line":3261,"code":"  it('should generate a unique variable name for imports', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-shadow/index.js'));\n    let res = await run(b);\n    assert.strictEqual(res.baz(), 'foo');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not replace identifier with a var declaration inside a for loop","suites":["javascript"],"updatePoint":{"line":3266,"column":76,"index":124447},"line":3266,"code":"  it('should not replace identifier with a var declaration inside a for loop', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-shadow-for-var/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res.baz(), [0, 1, 2, 3]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should replace an imported identifier with function locals of the same name","suites":["javascript"],"updatePoint":{"line":3271,"column":81,"index":124729},"line":3271,"code":"  it('should replace an imported identifier with function locals of the same name', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-shadow-func-var/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res.default, 123);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should replace imported values in member expressions","suites":["javascript"],"updatePoint":{"line":3276,"column":58,"index":124982},"line":3276,"code":"  it('should replace imported values in member expressions', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-member/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res.default, ['a', 'b', 'bar']);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not freeze live default imports","suites":["javascript"],"updatePoint":{"line":3281,"column":44,"index":125226},"line":3281,"code":"  it('should not freeze live default imports', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-default-live/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res.default, [123, 789]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not rewrite this in arrow function class properties","suites":["javascript"],"updatePoint":{"line":3286,"column":64,"index":125489},"line":3286,"code":"  it('should not rewrite this in arrow function class properties', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-class-this-esm/a.js'));\n    let res = await run(b);\n    assert.deepEqual(res.default, 'x: 123');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should call named imports without this context","suites":["javascript"],"updatePoint":{"line":3291,"column":52,"index":125729},"line":3291,"code":"  it('should call named imports without this context', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-this/index.js'));\n    let res = await run(b, {\n      output: null\n    }, {\n      strict: true\n    });\n    assert.deepEqual(res.default, {\n      unwrappedNamed: [true, false],\n      unwrappedDefault: [true, false],\n      unwrappedNamespace: [false, true],\n      wrappedNamed: [true, false],\n      wrappedDefault: [true, false],\n      wrappedNamespace: [false, true]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should only replace free references to require","suites":["javascript"],"updatePoint":{"line":3307,"column":52,"index":126252},"line":3307,"code":"  it('should only replace free references to require', async () => {\n    let b = await bundle(path.join(__dirname, 'integration/js-require-free/index.js'));\n    let output;\n    await run(b, {\n      output(v) {\n        output = v;\n      }\n    });\n    assert.strictEqual(output, 'a');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should only replace free references to require with scope hoisting","suites":["javascript"],"updatePoint":{"line":3317,"column":72,"index":126561},"line":3317,"code":"  it('should only replace free references to require with scope hoisting', async () => {\n    let b = await bundle(path.join(__dirname, 'integration/js-require-free/index.js'), {\n      mode: 'production'\n    });\n    let output;\n    await run(b, {\n      output(v) {\n        output = v;\n      }\n    });\n    assert.strictEqual(output, 'a');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support runtime module deduplication","suites":["javascript"],"updatePoint":{"line":3329,"column":49,"index":126881},"line":3329,"code":"  it('should support runtime module deduplication', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-runtime-dedup/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['async1.js', 'shared.js', 'esmodule-helpers.js']\n    }, {\n      assets: ['async2.js', 'shared.js', 'esmodule-helpers.js']\n    }]);\n    let res = await run(b);\n    assert.equal(await res, true);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support runtime module deduplication with scope hoisting","suites":["javascript"],"updatePoint":{"line":3342,"column":69,"index":127412},"line":3342,"code":"  it('should support runtime module deduplication with scope hoisting', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-runtime-dedup/index.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js', 'bundle-manifest.js']\n    }, {\n      assets: ['async1.js', 'shared.js']\n    }, {\n      assets: ['async2.js', 'shared.js']\n    }]);\n    let res = await run(b);\n    assert.equal(await res, true);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remap locations in diagnostics using the input source map","suites":["javascript"],"updatePoint":{"line":3357,"column":70,"index":127954},"line":3357,"code":"  it('should remap locations in diagnostics using the input source map', async () => {\n    let fixture = path.join(__dirname, 'integration/diagnostic-sourcemap/index.js');\n    let code = await inputFS.readFileSync(fixture, 'utf8');\n    await assert.rejects(() => bundle(fixture, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: \"Failed to resolve 'foo' from './index.js'\",\n        origin: '@parcel/core',\n        codeFrames: [{\n          filePath: fixture,\n          code,\n          codeHighlights: [{\n            start: {\n              line: 11,\n              column: 17\n            },\n            end: {\n              line: 11,\n              column: 21\n            }\n          }]\n        }]\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should reuse a bundle when its main asset (aka bundleroot) is imported sychronously","suites":["javascript"],"updatePoint":{"line":3386,"column":89,"index":128784},"line":3386,"code":"  it('should reuse a bundle when its main asset (aka bundleroot) is imported sychronously', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/shared-bundle-single-source/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'css-loader.js', 'esmodule-helpers.js', 'js-loader.js', 'bundle-manifest.js']\n    }, {\n      assets: ['bar.js']\n    }, {\n      assets: ['a.js', 'b.js', 'foo.js']\n    }, {\n      assets: ['styles.css']\n    }, {\n      assets: ['local.html']\n    }]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on undeclared external dependencies for libraries","suites":["javascript"],"updatePoint":{"line":3406,"column":68,"index":129443},"line":3406,"code":"  it('should error on undeclared external dependencies for libraries', async function () {\n    let fixture = path.join(__dirname, 'integration/undeclared-external/index.js');\n    let pkg = path.join(__dirname, 'integration/undeclared-external/package.json');\n    await assert.rejects(() => bundle(fixture, {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: \"Failed to resolve 'lodash' from './index.js'\",\n        origin: '@parcel/core',\n        codeFrames: [{\n          code: await inputFS.readFile(fixture, 'utf8'),\n          filePath: fixture,\n          codeHighlights: [{\n            start: {\n              line: 1,\n              column: 19\n            },\n            end: {\n              line: 1,\n              column: 26\n            }\n          }]\n        }]\n      }, {\n        message: 'External dependency \"lodash\" is not declared in package.json.',\n        origin: '@parcel/resolver-default',\n        codeFrames: [{\n          code: await inputFS.readFile(pkg, 'utf8'),\n          filePath: pkg,\n          language: 'json',\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 5,\n              column: 3\n            },\n            end: {\n              line: 5,\n              column: 16\n            }\n          }]\n        }],\n        hints: ['Add \"lodash\" as a dependency.']\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on undeclared helpers dependency for libraries","suites":["javascript"],"updatePoint":{"line":3456,"column":65,"index":130912},"line":3456,"code":"  it('should error on undeclared helpers dependency for libraries', async function () {\n    let fixture = path.join(__dirname, 'integration/undeclared-external/helpers.js');\n    let pkg = path.join(__dirname, 'integration/undeclared-external/package.json');\n    await assert.rejects(() => bundle(fixture, {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: md`Failed to resolve '${'@swc/helpers/lib/_class_call_check.js'}' from '${normalizePath(require.resolve('@parcel/transformer-js/src/JSTransformer.js'))}'`,\n        origin: '@parcel/core',\n        codeFrames: [{\n          code: await inputFS.readFile(fixture, 'utf8'),\n          filePath: fixture,\n          codeHighlights: [{\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }]\n        }]\n      }, {\n        message: 'External dependency \"@swc/helpers\" is not declared in package.json.',\n        origin: '@parcel/resolver-default',\n        codeFrames: [{\n          code: await inputFS.readFile(pkg, 'utf8'),\n          filePath: pkg,\n          language: 'json',\n          codeHighlights: [{\n            message: undefined,\n            start: {\n              line: 5,\n              column: 3\n            },\n            end: {\n              line: 5,\n              column: 16\n            }\n          }]\n        }],\n        hints: ['Add \"@swc/helpers\" as a dependency.']\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error on mismatched helpers version for libraries","suites":["javascript"],"updatePoint":{"line":3506,"column":62,"index":132498},"line":3506,"code":"  it('should error on mismatched helpers version for libraries', async function () {\n    let fixture = path.join(__dirname, 'integration/undeclared-external/helpers.js');\n    let pkg = path.join(__dirname, 'integration/undeclared-external/package.json');\n    let pkgContents = JSON.stringify({\n      ...JSON.parse(await overlayFS.readFile(pkg, 'utf8')),\n      dependencies: {\n        '@swc/helpers': '^0.3.0'\n      }\n    }, false, 2);\n    await overlayFS.mkdirp(path.dirname(pkg));\n    await overlayFS.writeFile(pkg, pkgContents);\n    await assert.rejects(() => bundle(fixture, {\n      mode: 'production',\n      inputFS: overlayFS,\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    }), {\n      name: 'BuildError',\n      diagnostics: [{\n        message: md`Failed to resolve '${'@swc/helpers/lib/_class_call_check.js'}' from '${normalizePath(require.resolve('@parcel/transformer-js/src/JSTransformer.js'))}'`,\n        origin: '@parcel/core',\n        codeFrames: [{\n          code: await inputFS.readFile(fixture, 'utf8'),\n          filePath: fixture,\n          codeHighlights: [{\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }]\n        }]\n      }, {\n        message: 'External dependency \"@swc/helpers\" does not satisfy required semver range \"^0.4.2\".',\n        origin: '@parcel/resolver-default',\n        codeFrames: [{\n          code: pkgContents,\n          filePath: pkg,\n          language: 'json',\n          codeHighlights: [{\n            message: 'Found this conflicting requirement.',\n            start: {\n              line: 6,\n              column: 21\n            },\n            end: {\n              line: 6,\n              column: 28\n            }\n          }]\n        }],\n        hints: ['Update the dependency on \"@swc/helpers\" to satisfy \"^0.4.2\".']\n      }]\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports both static and dynamic imports to the same specifier in the same file","suites":["javascript","multiple import types"],"updatePoint":{"line":3566,"column":87,"index":134507},"line":3566,"code":"    it('supports both static and dynamic imports to the same specifier in the same file', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/static-dynamic.js'));\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['static-dynamic.js', 'other.js', 'esmodule-helpers.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.Foo, 'function');\n      assert.equal(typeof res.LazyFoo, 'object');\n      assert.equal(res.Foo, await res.LazyFoo);\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports both static and dynamic imports to the same specifier in the same file with scope hoisting","suites":["javascript","multiple import types"],"updatePoint":{"line":3577,"column":107,"index":135056},"line":3577,"code":"    it('supports both static and dynamic imports to the same specifier in the same file with scope hoisting', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/static-dynamic.js'), {\n        defaultTargetOptions: {\n          outputFormat: 'esmodule',\n          isLibrary: true,\n          shouldScopeHoist: true\n        }\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['static-dynamic.js', 'other.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.Foo, 'function');\n      assert.equal(typeof res.LazyFoo, 'object');\n      assert.equal(res.Foo, await res.LazyFoo);\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports static, dynamic, and url to the same specifier in the same file","suites":["javascript","multiple import types"],"updatePoint":{"line":3594,"column":80,"index":135704},"line":3594,"code":"    it('supports static, dynamic, and url to the same specifier in the same file', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/static-dynamic-url.js'));\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['static-dynamic-url.js', 'other.js', 'esmodule-helpers.js', 'bundle-url.js']\n      }, {\n        type: 'js',\n        assets: ['other.js', 'esmodule-helpers.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.Foo, 'function');\n      assert.equal(typeof res.LazyFoo, 'object');\n      assert.equal(res.Foo, await res.LazyFoo);\n      assert.equal(res.url, 'http://localhost/' + path.basename(b.getBundles()[1].filePath));\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports static, dynamic, and url to the same specifier in the same file with scope hoisting","suites":["javascript","multiple import types"],"updatePoint":{"line":3609,"column":100,"index":136448},"line":3609,"code":"    it('supports static, dynamic, and url to the same specifier in the same file with scope hoisting', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/static-dynamic-url.js'), {\n        defaultTargetOptions: {\n          outputFormat: 'esmodule',\n          isLibrary: true,\n          shouldScopeHoist: true\n        }\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['static-dynamic-url.js', 'other.js']\n      }, {\n        type: 'js',\n        assets: ['other.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.Foo, 'function');\n      assert.equal(typeof res.LazyFoo, 'object');\n      assert.equal(res.Foo, await res.LazyFoo);\n      assert.equal(res.url, 'http://localhost/' + path.basename(b.getBundles()[1].filePath));\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports dynamic import and url to the same specifier in the same file","suites":["javascript","multiple import types"],"updatePoint":{"line":3630,"column":78,"index":137256},"line":3630,"code":"    it('supports dynamic import and url to the same specifier in the same file', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/dynamic-url.js'));\n\n      // Change in behavior: ExperimentalBundler now produces a single bundle\n      // of the lowest common denominator of bundleBehavior\n      if (process.env.PARCEL_TEST_EXPERIMENTAL_BUNDLER) {\n        assertBundles(b, [{\n          type: 'js',\n          assets: ['dynamic-url.js', 'esmodule-helpers.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n        }, {\n          type: 'js',\n          assets: ['other.js', 'esmodule-helpers.js']\n        }]);\n      } else {\n        assertBundles(b, [{\n          type: 'js',\n          assets: ['dynamic-url.js', 'esmodule-helpers.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n        }, {\n          type: 'js',\n          assets: ['other.js']\n        }, {\n          type: 'js',\n          assets: ['other.js', 'esmodule-helpers.js']\n        }]);\n      }\n      let res = await run(b);\n      assert.equal(typeof res.lazy, 'object');\n      assert.equal(typeof (await res.lazy), 'function');\n      assert.equal(res.url, 'http://localhost/' + path.basename(b.getBundles()[1].filePath));\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports dynamic import and url to the same specifier in the same file with scope hoisting","suites":["javascript","multiple import types"],"updatePoint":{"line":3660,"column":98,"index":138527},"line":3660,"code":"    it('supports dynamic import and url to the same specifier in the same file with scope hoisting', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/dynamic-url.js'), {\n        defaultTargetOptions: {\n          outputFormat: 'esmodule',\n          isLibrary: true,\n          shouldScopeHoist: true\n        }\n      });\n      if (process.env.PARCEL_TEST_EXPERIMENTAL_BUNDLER) {\n        // Change in behavior: ExperimentalBundler now produces a single bundle\n        // of the lowest common denominator of bundleBehavior\n        assertBundles(b, [{\n          type: 'js',\n          assets: ['dynamic-url.js']\n        }, {\n          type: 'js',\n          assets: ['other.js']\n        }]);\n      } else {\n        assertBundles(b, [{\n          type: 'js',\n          assets: ['dynamic-url.js']\n        }, {\n          type: 'js',\n          assets: ['other.js']\n        }, {\n          type: 'js',\n          assets: ['other.js']\n        }]);\n      }\n      let res = await run(b);\n      assert.equal(typeof res.lazy, 'object');\n      assert.equal(typeof (await res.lazy), 'function');\n      assert.equal(res.url, 'http://localhost/' + path.basename(b.getBundles()[1].filePath));\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports static import and inline bundle for the same asset","suites":["javascript","multiple import types"],"updatePoint":{"line":3695,"column":67,"index":139725},"line":3695,"code":"    it('supports static import and inline bundle for the same asset', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/static-inline.js'));\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['static-inline.js', 'other.js', 'esmodule-helpers.js']\n      }, {\n        type: 'js',\n        assets: ['other.js', 'esmodule-helpers.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.Foo, 'function');\n      assert.equal(typeof res.text, 'string');\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports static import and inline bundle for the same asset with scope hoisting","suites":["javascript","multiple import types"],"updatePoint":{"line":3708,"column":87,"index":140284},"line":3708,"code":"    it('supports static import and inline bundle for the same asset with scope hoisting', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/static-inline.js'), {\n        defaultTargetOptions: {\n          outputFormat: 'esmodule',\n          isLibrary: true,\n          shouldScopeHoist: true\n        }\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['static-inline.js', 'other.js']\n      }, {\n        type: 'js',\n        assets: ['other.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.Foo, 'function');\n      assert.equal(typeof res.text, 'string');\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports dynamic import and inline bundle for the same asset","suites":["javascript","multiple import types"],"updatePoint":{"line":3727,"column":68,"index":140927},"line":3727,"code":"    it('supports dynamic import and inline bundle for the same asset', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/dynamic-inline.js'));\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['dynamic-inline.js', 'esmodule-helpers.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n      }, {\n        type: 'js',\n        assets: ['other.js']\n      }, {\n        type: 'js',\n        assets: ['other.js', 'esmodule-helpers.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.lazy, 'object');\n      assert.equal(typeof (await res.lazy), 'function');\n      assert.equal(typeof res.text, 'string');\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports dynamic import and inline bundle for the same asset with scope hoisting","suites":["javascript","multiple import types"],"updatePoint":{"line":3744,"column":88,"index":141644},"line":3744,"code":"    it('supports dynamic import and inline bundle for the same asset with scope hoisting', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/multiple-import-types/dynamic-inline.js'), {\n        defaultTargetOptions: {\n          outputFormat: 'esmodule',\n          isLibrary: true,\n          shouldScopeHoist: true\n        }\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['dynamic-inline.js']\n      }, {\n        type: 'js',\n        assets: ['other.js']\n      }, {\n        type: 'js',\n        assets: ['other.js']\n      }]);\n      let res = await run(b);\n      assert.equal(typeof res.lazy, 'object');\n      assert.equal(typeof (await res.lazy), 'function');\n      assert.equal(typeof res.text, 'string');\n    });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should avoid creating a bundle for lazy dependencies already available in a shared bundle","suites":["javascript","multiple import types"],"updatePoint":{"line":3768,"column":95,"index":142426},"line":3768,"code":"  it('should avoid creating a bundle for lazy dependencies already available in a shared bundle', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/shared-bundle-internalization/index.mjs'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldScopeHoist: false\n      }\n    });\n    assert.deepEqual(await (await run(b)).default, [42, 42]);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support standalone import.meta","suites":["javascript","multiple import types"],"updatePoint":{"line":3777,"column":43,"index":142768},"line":3777,"code":"  it('should support standalone import.meta', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/import-meta/index.js'));\n    let res = await run(b);\n    assert.deepEqual(res.default, {\n      meta: {\n        url: 'file:///integration/import-meta/index.js'\n      },\n      url: 'file:///integration/import-meta/index.js',\n      equal: true\n    });\n    assert.equal(Object.getPrototypeOf(res.default.meta), null);\n    assert.equal(Object.isExtensible(res.default.meta), true);\n    assert.deepEqual(Object.getOwnPropertyDescriptors(res.default.meta), {\n      url: {\n        writable: true,\n        configurable: true,\n        enumerable: true,\n        value: 'file:///integration/import-meta/index.js'\n      }\n    });\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing async bundles from bundles with different dist paths","suites":["javascript","multiple import types"],"updatePoint":{"line":3798,"column":83,"index":143556},"line":3798,"code":"  it('should support importing async bundles from bundles with different dist paths', async function () {\n    let bundleGraph = await bundle(['bar/entry/entry-a.js', 'foo/entry-b.js'].map(f => path.join(__dirname, 'integration/differing-bundle-urls', f)), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    assertBundles(bundleGraph, [{\n      name: 'entry-a.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'entry-a.js', 'js-loader.js']\n    }, {\n      name: 'entry-b.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'entry-b.js', 'js-loader.js']\n    }, {\n      name: /deep\\.[a-f0-9]+\\.js/,\n      assets: ['deep.js']\n    }, {\n      name: /common\\.[a-f0-9]+\\.js/,\n      assets: ['index.js']\n    }]);\n    let [a, b] = bundleGraph.getBundles().filter(b => b.needsStableName);\n    let calls = [];\n    let bundles = [[await outputFS.readFile(a.filePath, 'utf8'), a], [await outputFS.readFile(b.filePath, 'utf8'), b]];\n    await runBundles(bundleGraph, a, bundles, {\n      sideEffect: v => {\n        calls.push(v);\n      }\n    });\n    assert.deepEqual(calls, ['common', 'deep']);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports deferring unused ESM imports with sideEffects: false","suites":["javascript","multiple import types"],"updatePoint":{"line":3828,"column":67,"index":144732},"line":3828,"code":"  it('supports deferring unused ESM imports with sideEffects: false', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/side-effects-false/import.js'));\n    let content = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!content.includes('returned from bar'));\n    let called = false;\n    let output = await run(b, {\n      sideEffect() {\n        called = true;\n      }\n    });\n    assert(!called, 'side effect called');\n    assert.strictEqual(output.default, 4);\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports ESM imports and requires with sideEffects: false","suites":["javascript","multiple import types"],"updatePoint":{"line":3841,"column":63,"index":145250},"line":3841,"code":"  it('supports ESM imports and requires with sideEffects: false', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/side-effects-false/import-require.js'));\n    let output = await run(b, {\n      sideEffect() {}\n    });\n    assert.strictEqual(output.default, '4returned from bar');\n  });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports excluding unused CSS imports","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":3857,"column":49,"index":145877},"line":3857,"code":"        it('supports excluding unused CSS imports', async function () {\n          let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-css/index.html'), options);\n          assertBundles(b, [{\n            name: 'index.html',\n            assets: ['index.html']\n          }, {\n            type: 'js',\n            assets: ['index.js', 'b1.js']\n          }, {\n            type: 'css',\n            assets: ['b1.css']\n          }]);\n          let calls = [];\n          let res = await run(b, {\n            output: null,\n            sideEffect: caller => {\n              calls.push(caller);\n            }\n          }, {\n            require: false\n          });\n          assert.deepEqual(calls, ['b1']);\n          assert.deepEqual(res.output, 2);\n          let css = await outputFS.readFile(b.getBundles().find(bundle => bundle.type === 'css').filePath, 'utf8');\n          assert(!css.includes('.b2'));\n        });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"doesn't create new bundles for dynamic imports in excluded assets","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":3883,"column":77,"index":146848},"line":3883,"code":"        it(\"doesn't create new bundles for dynamic imports in excluded assets\", async function () {\n          let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-no-new-bundle/index.html'), options);\n          assertBundles(b, [{\n            name: 'index.html',\n            assets: ['index.html']\n          }, {\n            type: 'js',\n            assets: ['index.js', 'b1.js']\n          }]);\n          let calls = [];\n          let res = await run(b, {\n            output: null,\n            sideEffect: caller => {\n              calls.push(caller);\n            }\n          }, {\n            require: false\n          });\n          assert.deepEqual(calls, ['b1']);\n          assert.deepEqual(res.output, 2);\n        });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports deferring unused ES6 re-exports (namespace used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":3905,"column":67,"index":147600},"line":3905,"code":"      it('supports deferring unused ES6 re-exports (namespace used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports/a.js'), options);\n        assertBundles(b, [{\n          type: 'js',\n          assets: usesSymbolPropagation ? ['a.js', 'message1.js'] : ['a.js', 'esmodule-helpers.js', 'index.js', 'message1.js', 'message3.js']\n        }]);\n        if (usesSymbolPropagation) {\n          // TODO this only excluded, but should be deferred.\n          assert(!findAsset(b, 'message3.js'));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['message1'] : ['message1', 'message3', 'index']);\n        assert.deepEqual(res.output, 'Message 1');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports deferring an unused ES6 re-export (wildcard, empty, unused)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":3926,"column":78,"index":148536},"line":3926,"code":"      it('supports deferring an unused ES6 re-export (wildcard, empty, unused)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-all-empty/a.js'), options);\n        if (usesSymbolPropagation) {\n          assertDependencyWasExcluded(b, 'index.js', './empty.js');\n        }\n        assert.deepEqual((await run(b, null, {\n          require: false\n        })).output, 123);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports deferring unused ES6 re-exports (reexport named used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":3935,"column":72,"index":148989},"line":3935,"code":"      it('supports deferring unused ES6 re-exports (reexport named used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports/b.js'), options);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'message1.js'));\n          assert(!findAsset(b, 'message3.js'));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['message2'] : ['message1', 'message2', 'message3', 'index']);\n        assert.deepEqual(res.output, 'Message 2');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports deferring unused ES6 re-exports (namespace rename used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":3952,"column":74,"index":149714},"line":3952,"code":"      it('supports deferring unused ES6 re-exports (namespace rename used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports/c.js'), options);\n        assertBundles(b, [{\n          type: 'js',\n          assets: usesSymbolPropagation ? ['c.js', 'message3.js'] : ['c.js', 'esmodule-helpers.js', 'index.js', 'message1.js', 'message3.js']\n        }]);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'message1.js'));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['message3'] : ['message1', 'message3', 'index']);\n        assert.deepEqual(res.output, {\n          default: 'Message 3'\n        });\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports deferring unused ES6 re-exports (direct export used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":3974,"column":71,"index":150612},"line":3974,"code":"      it('supports deferring unused ES6 re-exports (direct export used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports/d.js'), options);\n        assertDependencyWasExcluded(b, 'index.js', './message2.js');\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'message1.js'));\n          assert(!findAsset(b, 'message3.js'));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['index'] : ['message1', 'message3', 'index']);\n        assert.deepEqual(res.output, 'Message 4');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports chained ES6 re-exports","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":3992,"column":41,"index":151358},"line":3992,"code":"      it('supports chained ES6 re-exports', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-chained/index.js'), options);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'bar.js'));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        if (shouldScopeHoist) {\n          try {\n            assert.deepEqual(calls, ['key', 'foo', 'index']);\n          } catch (e) {\n            // A different dependency order, but this is deemed acceptable as it's sideeffect free\n            assert.deepEqual(calls, ['foo', 'key', 'index']);\n          }\n        } else {\n          assert.deepEqual(calls, ['key', 'foo', 'bar', 'types', 'index']);\n        }\n        assert.deepEqual(res.output, ['key', 'foo']);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not optimize away an unused ES6 re-export and an used import","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4017,"column":77,"index":152344},"line":4017,"code":"      it('should not optimize away an unused ES6 re-export and an used import', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-import/a.js'), options);\n        let res = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(res.output, 123);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not optimize away an unused ES6 re-export and an used import (different symbols)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4024,"column":97,"index":152725},"line":4024,"code":"      it('should not optimize away an unused ES6 re-export and an used import (different symbols)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-import-different/a.js'), options);\n        let res = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(res.output, 123);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"correctly handles ES6 re-exports in library mode entries","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4031,"column":66,"index":153085},"line":4031,"code":"      it('correctly handles ES6 re-exports in library mode entries', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-library/a.js'), options);\n        let contents = await outputFS.readFile(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-library/build.js'), 'utf8');\n        assert(!contents.includes('console.log'));\n        let res = await run(b);\n        assert.deepEqual(res, {\n          c1: 'foo'\n        });\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"correctly updates deferred assets that are reexported","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4041,"column":65,"index":153647},"line":4041,"code":"        it('correctly updates deferred assets that are reexported', async function () {\n          let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-update-deferred-reexported');\n          let b = bundler(path.join(testDir, 'index.js'), {\n            inputFS: overlayFS,\n            outputFS: overlayFS,\n            ...options\n          });\n          let subscription = await b.watch();\n          let bundleEvent = await getNextBuild(b);\n          assert(bundleEvent.type === 'buildSuccess');\n          let output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, '12345hello');\n          await overlayFS.mkdirp(path.join(testDir, 'node_modules', 'foo'));\n          await overlayFS.copyFile(path.join(testDir, 'node_modules', 'foo', 'foo_updated.js'), path.join(testDir, 'node_modules', 'foo', 'foo.js'));\n          bundleEvent = await getNextBuild(b);\n          assert(bundleEvent.type === 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, '1234556789');\n          await subscription.unsubscribe();\n        });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"correctly updates deferred assets that are reexported and imported directly","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4061,"column":87,"index":154791},"line":4061,"code":"        it('correctly updates deferred assets that are reexported and imported directly', async function () {\n          let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-update-deferred-direct');\n          let b = bundler(path.join(testDir, 'index.js'), {\n            inputFS: overlayFS,\n            outputFS: overlayFS,\n            ...options\n          });\n          let subscription = await b.watch();\n          let bundleEvent = await getNextBuild(b);\n          assert(bundleEvent.type === 'buildSuccess');\n          let output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, '12345hello');\n          await overlayFS.mkdirp(path.join(testDir, 'node_modules', 'foo'));\n          await overlayFS.copyFile(path.join(testDir, 'node_modules', 'foo', 'foo_updated.js'), path.join(testDir, 'node_modules', 'foo', 'foo.js'));\n          bundleEvent = await getNextBuild(b);\n          assert(bundleEvent.type === 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, '1234556789');\n          await subscription.unsubscribe();\n        });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes deferred reexports when imported from multiple asssets","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4081,"column":74,"index":155918},"line":4081,"code":"        it('removes deferred reexports when imported from multiple asssets', async function () {\n          let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-multiple-dynamic/a.js'), options);\n          let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n          assert(!contents.includes('$import$'));\n          assert(contents.includes('= 1234;'));\n          assert(!contents.includes('= 5678;'));\n          let output = await run(b);\n          assert.deepEqual(output, [1234, {\n            default: 1234\n          }]);\n        });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"keeps side effects by default","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4093,"column":39,"index":156499},"line":4093,"code":"      it('keeps side effects by default', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects/a.js'), options);\n        let called = false;\n        let res = await run(b, {\n          sideEffect: () => {\n            called = true;\n          }\n        }, {\n          require: false\n        });\n        assert(called, 'side effect not called');\n        assert.deepEqual(res.output, 4);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports the package.json sideEffects: false flag","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4106,"column":59,"index":156976},"line":4106,"code":"      it('supports the package.json sideEffects: false flag', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-false/a.js'), options);\n        let called = false;\n        let res = await run(b, {\n          sideEffect: () => {\n            called = true;\n          }\n        }, {\n          require: false\n        });\n        assert(!called, 'side effect called');\n        assert.deepEqual(res.output, 4);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports removing a deferred dependency","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4119,"column":49,"index":157446},"line":4119,"code":"      it('supports removing a deferred dependency', async function () {\n        let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-false');\n        let b = bundler(path.join(testDir, 'a.js'), {\n          inputFS: overlayFS,\n          outputFS: overlayFS,\n          ...options\n        });\n        let subscription = await b.watch();\n        try {\n          let bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          let called = false;\n          let res = await run(bundleEvent.bundleGraph, {\n            sideEffect: () => {\n              called = true;\n            }\n          }, {\n            require: false\n          });\n          assert(!called, 'side effect called');\n          assert.deepEqual(res.output, 4);\n          if (usesSymbolPropagation) {\n            assert(!findAsset(bundleEvent.bundleGraph, 'index.js'));\n          }\n          await overlayFS.mkdirp(path.join(testDir, 'node_modules/bar'));\n          await overlayFS.copyFile(path.join(testDir, 'node_modules/bar/index.1.js'), path.join(testDir, 'node_modules/bar/index.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          called = false;\n          res = await run(bundleEvent.bundleGraph, {\n            sideEffect: () => {\n              called = true;\n            }\n          }, {\n            require: false\n          });\n          assert(!called, 'side effect called');\n          assert.deepEqual(res.output, 4);\n        } finally {\n          await subscription.unsubscribe();\n        }\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports wildcards","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4161,"column":28,"index":159053},"line":4161,"code":"      it('supports wildcards', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-false-wildcards/a.js'), options);\n        let called = false;\n        let res = await run(b, {\n          sideEffect: () => {\n            called = true;\n          }\n        }, {\n          require: false\n        });\n        if (usesSymbolPropagation) {\n          assert(!called, 'side effect called');\n        }\n        assert.deepEqual(res.output, 'bar');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"correctly handles excluded and wrapped reexport assets","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4176,"column":64,"index":159601},"line":4176,"code":"      it('correctly handles excluded and wrapped reexport assets', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-false-wrap-excluded/a.js'), options);\n        let res = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(res.output, 4);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports the package.json sideEffects flag with an array","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4183,"column":66,"index":159951},"line":4183,"code":"      it('supports the package.json sideEffects flag with an array', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-array/a.js'), options);\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert(calls.toString() == 'foo', \"side effect called for 'foo'\");\n        assert.deepEqual(res.output, 4);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports the package.json sideEffects: false flag with shared dependencies","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4196,"column":84,"index":160489},"line":4196,"code":"      it('supports the package.json sideEffects: false flag with shared dependencies', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-false-duplicate/a.js'), options);\n        let called = false;\n        let res = await run(b, {\n          sideEffect: () => {\n            called = true;\n          }\n        }, {\n          require: false\n        });\n        assert(!called, 'side effect called');\n        assert.deepEqual(res.output, 6);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports the package.json sideEffects: false flag with shared dependencies and code splitting","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4209,"column":103,"index":161023},"line":4209,"code":"      it('supports the package.json sideEffects: false flag with shared dependencies and code splitting', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-split/a.js'), options);\n        let res = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(await res.output, 581);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports the package.json sideEffects: false flag with shared dependencies and code splitting II","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4216,"column":106,"index":161407},"line":4216,"code":"      it('supports the package.json sideEffects: false flag with shared dependencies and code splitting II', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-split2/a.js'), options);\n        let res = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(await res.output, [{\n          default: 123,\n          foo: 2\n        }, 581]);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"missing exports should be replaced with an empty object","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4226,"column":65,"index":161807},"line":4226,"code":"      it('missing exports should be replaced with an empty object', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/empty-module/a.js'), options);\n        let res = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(res.output, {\n          b: {}\n        });\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports namespace imports of theoretically excluded reexporting assets","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4235,"column":81,"index":162178},"line":4235,"code":"      it('supports namespace imports of theoretically excluded reexporting assets', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace-sideEffects/index.js'), options);\n        let res = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(res.output, {\n          Main: 'main',\n          a: 'foo',\n          b: 'bar'\n        });\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can import from a different bundle via a re-export","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4246,"column":60,"index":162595},"line":4246,"code":"      it('can import from a different bundle via a re-export', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-bundle-boundary-side-effects/index.js'), options);\n        let res = await run(b, null, {\n          require: false\n        });\n        assert.deepEqual(await res.output, ['operational', 'ui']);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports excluding multiple chained namespace reexports","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4253,"column":65,"index":162980},"line":4253,"code":"      it('supports excluding multiple chained namespace reexports', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-chained-re-exports-multiple/a.js'), options);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'symbol1.js'));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['message1'] : ['message1', 'message2', 'message', 'symbol1', 'symbol2', 'symbol']);\n        assert.deepEqual(res.output, 'Message 1');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports excluding when doing both exports and reexports","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4269,"column":66,"index":163687},"line":4269,"code":"      it('supports excluding when doing both exports and reexports', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-export-reexport/a.js'), options);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'other.js'));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, usesSymbolPropagation ? ['index'] : ['other', 'index']);\n        assert.deepEqual(res.output, 'Message 1');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports deferring with chained renaming reexports","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4285,"column":60,"index":164327},"line":4285,"code":"      it('supports deferring with chained renaming reexports', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-rename-chained/a.js'), options);\n\n        // assertDependencyWasExcluded(b, 'message.js', './message2');\n\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['message1'] : ['message1', 'message2', 'message', 'index2', 'index']);\n        assert.deepEqual(res.output, 'Message 1');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named and renamed reexports of the same asset (default used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4301,"column":79,"index":165011},"line":4301,"code":"      it('supports named and renamed reexports of the same asset (default used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-rename-same2/a.js'), options);\n        if (usesSymbolPropagation) {\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'other.js')))), new Set(['bar']));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['other'] : ['other', 'index']);\n        assert.deepEqual(res.output, 'bar');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports reexports via variable declaration (unused)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4317,"column":62,"index":165722},"line":4317,"code":"      it('supports reexports via variable declaration (unused)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-rename-var-unused/index.js'), options);\n        let res = await run(b, {}, {\n          require: false\n        });\n        assert.deepEqual((await res.output).foo, 'foo');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named and renamed reexports of the same asset (named used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4324,"column":77,"index":166110},"line":4324,"code":"      it('supports named and renamed reexports of the same asset (named used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-rename-same2/b.js'), options);\n        if (usesSymbolPropagation) {\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'other.js')))), new Set(['bar']));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['other'] : ['other', 'index']);\n        assert.deepEqual(res.output, 'bar');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named and namespace exports of the same asset (named used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4340,"column":77,"index":166836},"line":4340,"code":"      it('supports named and namespace exports of the same asset (named used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-namespace-same/a.js'), options);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'index.js'));\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'other.js')))), new Set(['default']));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['other'] : ['other', 'index']);\n        assert.deepEqual(res.output, ['foo']);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named and namespace exports of the same asset (namespace used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4357,"column":81,"index":167619},"line":4357,"code":"      it('supports named and namespace exports of the same asset (namespace used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-namespace-same/b.js'), options);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'index.js'));\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'other.js')))), new Set(['bar']));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['other'] : ['other', 'index']);\n        assert.deepEqual(res.output, ['bar']);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named and namespace exports of the same asset (both used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4374,"column":76,"index":168393},"line":4374,"code":"      it('supports named and namespace exports of the same asset (both used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-namespace-same/c.js'), options);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'index.js'));\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'other.js')))), new Set(['default', 'bar']));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['other'] : ['other', 'index']);\n        assert.deepEqual(res.output, ['foo', 'bar']);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports partially used reexporting index file","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4391,"column":56,"index":169165},"line":4391,"code":"      it('supports partially used reexporting index file', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-re-exports-partially-used/index.js'), options);\n        let calls = [];\n        let res = (await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        })).output;\n        let [v, async] = res;\n        assert.deepEqual(calls, shouldScopeHoist ? ['b'] : ['a', 'b', 'index']);\n        assert.deepEqual(v, 2);\n        v = await async();\n        assert.deepEqual(calls, shouldScopeHoist ? ['b', 'a', 'index', 'dynamic'] : ['a', 'b', 'index', 'dynamic']);\n        assert.deepEqual(v.default, [1, 3]);\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports deferring non-weak dependencies that are not used","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4408,"column":68,"index":169936},"line":4408,"code":"      it('supports deferring non-weak dependencies that are not used', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-semi-weak/a.js'), options);\n\n        // assertDependencyWasExcluded(b, 'esm2.js', './other.js');\n\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['esm1'] : ['esm1', 'other', 'esm2', 'index']);\n        assert.deepEqual(res.output, 'Message 1');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports excluding CommonJS (CommonJS unused)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4424,"column":55,"index":170553},"line":4424,"code":"      it('supports excluding CommonJS (CommonJS unused)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-commonjs/a.js'), options);\n        if (usesSymbolPropagation) {\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'esm.js')))), new Set(['message1']));\n          // We can't statically analyze commonjs.js, so message1 appears to be used\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'commonjs.js')))),\n          // the exports object is used freely\n          new Set(['*', 'message1']));\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'index.js', './commonjs.js'))), new Set(['message1']));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, ['esm', 'commonjs', 'index']);\n        assert.deepEqual(res.output, 'Message 1');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports excluding CommonJS (CommonJS used)","suites":["javascript","sideEffects: false with scope-hoisting"],"updatePoint":{"line":4445,"column":53,"index":171632},"line":4445,"code":"      it('supports excluding CommonJS (CommonJS used)', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-commonjs/b.js'), options);\n        if (usesSymbolPropagation) {\n          assert(!findAsset(b, 'esm.js'));\n          assert(!findAsset(b, 'index.js'));\n          assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'commonjs.js')))),\n          // the exports object is used freely\n          new Set(['*', 'message2']));\n        }\n        let calls = [];\n        let res = await run(b, {\n          sideEffect: caller => {\n            calls.push(caller);\n          }\n        }, {\n          require: false\n        });\n        assert.deepEqual(calls, shouldScopeHoist ? ['commonjs'] : ['esm', 'commonjs', 'index']);\n        assert.deepEqual(res.output, 'Message 2');\n      });","file":"javascript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"logs bundling a commonjs bundle to stdout as json","suites":["json reporter"],"updatePoint":{"line":12,"column":55,"index":376},"line":12,"code":"  it('logs bundling a commonjs bundle to stdout as json', async () => {\n    let consoleStub = sinon.stub(console, 'log');\n    try {\n      await bundle(path.join(__dirname, '/integration/commonjs/index.js'), {\n        config,\n        logLevel: 'info'\n      });\n      let parsedCalls = consoleStub.getCalls().map(call => {\n        invariant(typeof call.lastArg === 'string');\n        return JSON.parse(call.lastArg);\n      });\n      for (let [iStr, parsed] of Object.entries(parsedCalls)) {\n        parsed = parsed;\n        invariant(typeof iStr === 'string');\n        let i = parseInt(iStr, 10);\n        if (i === 0) {\n          assert.deepEqual(parsed, {\n            type: 'buildStart'\n          });\n        } else if (i > 0 && i < 9) {\n          assert.equal(parsed.type, 'buildProgress');\n          assert.equal(parsed.phase, 'transforming');\n          assert(typeof parsed.filePath === 'string');\n        } else if (i === 9) {\n          assert.deepEqual(parsed, {\n            type: 'buildProgress',\n            phase: 'bundling'\n          });\n        } else if (i === 10) {\n          assert.equal(parsed.type, 'buildProgress');\n          assert.equal(parsed.phase, 'packaging');\n          assert.equal(parsed.bundleName, 'index.js');\n        } else if (i === 11) {\n          assert.equal(parsed.type, 'buildProgress');\n          assert.equal(parsed.phase, 'optimizing');\n          assert.equal(parsed.bundleName, 'index.js');\n        } else if (i === 12) {\n          assert.equal(parsed.type, 'buildSuccess');\n          assert(typeof parsed.buildTime === 'number');\n          assert(Array.isArray(parsed.bundles));\n          let bundle = parsed.bundles[0];\n          assert.equal(path.basename(bundle.filePath), 'index.js');\n          assert(typeof bundle.size === 'number');\n          assert(typeof bundle.time === 'number');\n          assert(Array.isArray(bundle.assets));\n        }\n      }\n    } finally {\n      consoleStub.restore();\n    }\n  });","file":"json-reporter.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a basic kotlin bundle","suites":["kotlin"],"updatePoint":{"line":10,"column":42,"index":413},"line":10,"code":"  it('should produce a basic kotlin bundle', async function () {\n    let b = await bundle(__dirname + '/integration/kotlin/index.js');\n    await assertBundleTree(b, {\n      type: 'js',\n      assets: ['test.kt', 'index.js', 'browser.js', 'kotlin.js']\n    });\n    let output = await run(b);\n    assert.equal(output, 5);\n  });","file":"kotlin.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring less files","suites":["less"],"updatePoint":{"line":6,"column":41,"index":252},"line":6,"code":"  it('should support requiring less files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.less']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.index'));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support less imports","suites":["less"],"updatePoint":{"line":21,"column":33,"index":762},"line":21,"code":"  it('should support less imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less-import/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.less']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.a'));\n    assert(css.includes('.b'));\n    assert(css.includes('.c'));\n    assert(css.includes('.d'));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support advanced less imports","suites":["less"],"updatePoint":{"line":39,"column":42,"index":1380},"line":39,"code":"  it('should support advanced less imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less-advanced-import/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.less']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.a'));\n    assert(css.includes('.external-index'));\n    assert(css.includes('.external-a'));\n    assert(css.includes('.external-with-main'));\n    assert(css.includes('.explicit-external-a'));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring empty less files","suites":["less"],"updatePoint":{"line":58,"column":47,"index":2101},"line":58,"code":"  it('should support requiring empty less files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less-empty/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.less']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert.equal(css.trim(), '/*# sourceMappingURL=index.css.map */');\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support linking to assets with url() from less","suites":["less"],"updatePoint":{"line":73,"column":59,"index":2678},"line":73,"code":"  it('should support linking to assets with url() from less', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.less']\n    }, {\n      type: 'woff2',\n      assets: ['test.woff2']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(/url\\(\"?test\\.[0-9a-f]+\\.woff2\"?\\)/.test(css));\n    assert(/url\\(\"?http:\\/\\/google.com\"?\\)/.test(css));\n    assert(css.includes('.index'));\n    assert(await outputFS.exists(path.join(distDir, css.match(/url\\(\"?(test\\.[0-9a-f]+\\.woff2)\"?\\)/)[1])));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support less url rewrites","suites":["less"],"updatePoint":{"line":94,"column":38,"index":3479},"line":94,"code":"  it('should support less url rewrites', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less-url-rewrite/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.less']\n    }, {\n      type: 'woff2',\n      assets: ['a.woff2']\n    }, {\n      type: 'woff2',\n      assets: ['b.woff2']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.a'));\n    assert(css.includes('.b'));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support css modules in less","suites":["less"],"updatePoint":{"line":116,"column":40,"index":4148},"line":116,"code":"  it('should support css modules in less', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less-postcss/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'index.module.less']\n    }, {\n      name: 'index.css',\n      assets: ['index.module.less']\n    }, {\n      assets: ['img.svg']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert(output().endsWith('_index'));\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(/\\.[_0-9a-zA-Z]+_index/.test(css));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw an exception when using webpack syntax","suites":["less"],"updatePoint":{"line":133,"column":57,"index":4774},"line":133,"code":"  it('should throw an exception when using webpack syntax', async function () {\n    await assert.rejects(() => bundle(path.join(__dirname, '/integration/less-webpack-import-error/index.js')), {\n      message: md`The @import path \"${'~library/style.less'}\" is using webpack specific syntax, which isn't supported by Parcel.\\n\\nTo @import files from ${'node_modules'}, use \"${'library/style.less'}\"`\n    });\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support configuring less include paths","suites":["less"],"updatePoint":{"line":138,"column":51,"index":5180},"line":138,"code":"  it('should support configuring less include paths', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less-include-paths/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.less']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.a'));\n    assert(css.includes('.b'));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore url() with IE behavior specifiers","suites":["less"],"updatePoint":{"line":154,"column":53,"index":5752},"line":154,"code":"  it('should ignore url() with IE behavior specifiers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/less-url-behavior/index.less'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.less']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('url(\"#default#VML\")'));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"preserves quotes around data urls that require them","suites":["less"],"updatePoint":{"line":163,"column":57,"index":6147},"line":163,"code":"  it('preserves quotes around data urls that require them', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/less-url-quotes/index.less'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.less']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes(\n    // Note the literal space after \"xml\"\n    'background: url(\"data:image/svg+xml,%3C%3Fxml version%3D%221.0%22%3F%3E%3Csvg%3E%3C%2Fsvg%3E\")'));\n  });","file":"less.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling Markdown","suites":["markdown"],"updatePoint":{"line":5,"column":38,"index":206},"line":5,"code":"  it('should support bundling Markdown', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/markdown/index.md'));\n    await assertBundleTree(b, {\n      name: 'index.html',\n      assets: ['index.md'],\n      childBundles: [{\n        type: 'png',\n        assets: ['100x100.png'],\n        childBundles: []\n      }]\n    });\n    let files = await outputFS.readdir(path.join(__dirname, '/dist'));\n    let html = await outputFS.readFile(path.join(__dirname, '/dist/index.html'));\n    for (let file of files) {\n      let ext = file.match(/\\.([0-9a-z]+)(?:[?#]|$)/i)[0];\n      if (file !== 'index.html' && ext !== '.map') {\n        assert(html.includes(file));\n      }\n    }\n  });","file":"markdown.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling MDX","suites":["mdx"],"updatePoint":{"line":8,"column":33,"index":187},"line":8,"code":"  it('should support bundling MDX', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/mdx/index.mdx'));\n    let output = await run(b);\n    assert.equal(typeof output.default, 'function');\n    assert(output.default.isMDXComponent);\n  });","file":"mdx.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling MDX with React 17","suites":["mdx"],"updatePoint":{"line":14,"column":47,"index":468},"line":14,"code":"  it('should support bundling MDX with React 17', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/mdx-react-17/index.mdx'));\n    let output = await run(b);\n    assert.equal(typeof output.default, 'function');\n    assert(output.default.isMDXComponent);\n  });","file":"mdx.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should dump bundle metrics to parcel-metrics.json","suites":["Build Metrics Reporter"],"updatePoint":{"line":8,"column":55,"index":304},"line":8,"code":"  it('Should dump bundle metrics to parcel-metrics.json', async () => {\n    let b = bundler(path.join(__dirname, '/integration/commonjs/index.js'), {\n      config,\n      logLevel: 'info'\n    });\n    await b.run();\n    let projectRoot = b._getResolvedParcelOptions().projectRoot;\n    let dirContent = await outputFS.readdir(projectRoot);\n    assert(dirContent.includes('parcel-metrics.json'), 'Should create a parcel-metrics.json file');\n    let metrics = JSON.parse(await outputFS.readFile(path.join(projectRoot, 'parcel-metrics.json'), 'utf8'));\n    assert(!!metrics.buildTime, 'Should contain buildTime');\n    assert(metrics.bundles.length > 0, 'Should contain bundle(s)');\n    for (let bundle of metrics.bundles) {\n      assert(bundle.filePath, 'Each bundle should have a filePath');\n      assert(bundle.size, 'Each bundle should have a size');\n      assert(bundle.time, 'Each bundle should have a time');\n      assert(Array.isArray(bundle.largestAssets), 'Each bundle should contain a list of largest assets');\n      assert(bundle.totalAssets, 'Each bundle should contain the amount of assets');\n    }\n  });","file":"metrics-reporter.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile packages with target source overrides","suites":["monorepos"],"updatePoint":{"line":16,"column":58,"index":592},"line":16,"code":"  it('should compile packages with target source overrides', async function () {\n    let fixture = path.join(__dirname, '/integration/target-source');\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(fixture);\n    try {\n      let b = await bundle([path.join(fixture, 'packages/package-a'), path.join(fixture, 'packages/package-b')], {\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          distDir\n        }\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['foo.js', 'index.js']\n      }, {\n        name: 'indexAlternate.js',\n        assets: ['bar.js', 'indexAlternate.js']\n      }, {\n        name: 'index.js',\n        assets: ['foo.js', 'index.js']\n      }, {\n        name: 'indexAlternate.js',\n        assets: ['bar.js', 'indexAlternate.js']\n      }, {\n        name: 'indexAlternate2.js',\n        assets: ['foo.js', 'indexAlternate2.js']\n      }]);\n      let contents = await outputFS.readFile(path.join(distDir, '/package-a/src/index.js'), 'utf8');\n      assert(contents.includes('hello foo'));\n      contents = await outputFS.readFile(path.join(distDir, '/package-a/src/indexAlternate.js'), 'utf8');\n      assert(contents.includes('hello bar'));\n      contents = await outputFS.readFile(path.join(distDir, '/package-a/src/indexAlternate2.js'), 'utf8');\n      assert(contents.includes('hello foo'));\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile packages with target source overrides and --target option","suites":["monorepos"],"updatePoint":{"line":53,"column":78,"index":2023},"line":53,"code":"  it('should compile packages with target source overrides and --target option', async function () {\n    let fixture = path.join(__dirname, '/integration/target-source');\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(fixture);\n    try {\n      let b = await bundle([path.join(fixture, 'packages/package-a'), path.join(fixture, 'packages/package-b')], {\n        targets: ['alternate'],\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          distDir\n        }\n      });\n      assertBundles(b, [{\n        name: 'indexAlternate.js',\n        assets: ['bar.js', 'indexAlternate.js']\n      }, {\n        name: 'indexAlternate.js',\n        assets: ['bar.js', 'indexAlternate.js']\n      }, {\n        name: 'indexAlternate2.js',\n        assets: ['foo.js', 'indexAlternate2.js']\n      }]);\n      let contents = await outputFS.readFile(path.join(distDir, '/package-a/src/indexAlternate.js'), 'utf8');\n      assert(contents.includes('hello bar'));\n      contents = await outputFS.readFile(path.join(distDir, '/package-a/src/indexAlternate2.js'), 'utf8');\n      assert(contents.includes('hello foo'));\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile packages with target source overrides and --target option in serve mode","suites":["monorepos"],"updatePoint":{"line":83,"column":92,"index":3205},"line":83,"code":"  it('should compile packages with target source overrides and --target option in serve mode', async function () {\n    let fixture = path.join(__dirname, '/integration/target-source');\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(fixture);\n    try {\n      let b = await bundle(path.join(fixture, 'packages/package-b'), {\n        targets: ['alternate'],\n        serveOptions: {\n          port: 1234\n        }\n      });\n      assertBundles(b, [{\n        name: 'indexAlternate.js',\n        assets: ['bar.js', 'esmodule-helpers.js', 'indexAlternate.js']\n      }]);\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build using root targets with entry files inside packages and cwd at project root","suites":["monorepos"],"updatePoint":{"line":102,"column":94,"index":3830},"line":102,"code":"  it('should build using root targets with entry files inside packages and cwd at project root', async function () {\n    let fixture = path.join(__dirname, '/integration/monorepo');\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(fixture);\n    try {\n      let b = await bundle([path.join(fixture, 'packages/pkg-a/src/index.js'), path.join(fixture, 'packages/pkg-b/src/index.js')], {\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          distDir\n        }\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js']\n      }, {\n        name: 'index.js',\n        assets: ['index.js', 'index.module.css']\n      }, {\n        name: 'index.css',\n        assets: ['index.module.css']\n      }]);\n      let contents = await outputFS.readFile(path.join(distDir, '/pkg-a/src/index.js'), 'utf8');\n      assert(contents.includes('$parcel$export(module.exports, \"default\"'));\n      contents = await outputFS.readFile(path.join(distDir, '/pkg-b/src/index.js'), 'utf8');\n      assert(contents.includes('require(\"./index.css\")'));\n      contents = await outputFS.readFile(path.join(distDir, '/pkg-b/src/index.css'), 'utf8');\n      assert(/\\.[_0-9a-zA-Z]+_foo/.test(contents));\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build multiple packages in a monorepo at once, pointing at directories with \"source\" field in package.json","suites":["monorepos"],"updatePoint":{"line":133,"column":119,"index":5126},"line":133,"code":"  it('should build multiple packages in a monorepo at once, pointing at directories with \"source\" field in package.json', async function () {\n    let b = await bundle([path.join(__dirname, '/integration/monorepo/packages/pkg-a'), path.join(__dirname, '/integration/monorepo/packages/pkg-b')], {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      name: 'pkg-a.cjs.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-a.module.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-b.cjs.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-b.module.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-b.cjs.css',\n      assets: ['index.module.css']\n    }]);\n    let contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-a/dist/pkg-a.cjs.js'), 'utf8');\n    assert(contents.includes('$parcel$export(module.exports, \"default\"'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-a/dist/pkg-a.module.js'), 'utf8');\n    assert(contents.includes('export {'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-b/dist/pkg-b.cjs.js'), 'utf8');\n    assert(contents.includes('require(\"./pkg-b.cjs.css\")'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-b/dist/pkg-b.cjs.css'), 'utf8');\n    assert(/\\.[_0-9a-zA-Z]+_foo/.test(contents));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-b/dist/pkg-b.module.js'), 'utf8');\n    assert(contents.includes('import \"./pkg-b.cjs.css\"'));\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build using root targets with a glob pointing at files inside packages and cwd at project root","suites":["monorepos"],"updatePoint":{"line":166,"column":107,"index":6830},"line":166,"code":"  it('should build using root targets with a glob pointing at files inside packages and cwd at project root', async function () {\n    let fixture = path.join(__dirname, '/integration/monorepo');\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(fixture);\n    try {\n      let b = await bundle(path.join(fixture, 'packages/*/src/index.js'), {\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          distDir\n        }\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js']\n      }, {\n        name: 'index.js',\n        assets: ['index.js', 'index.module.css']\n      }, {\n        name: 'index.css',\n        assets: ['index.module.css']\n      }]);\n      let contents = await outputFS.readFile(path.join(distDir, '/pkg-a/src/index.js'), 'utf8');\n      assert(contents.includes('$parcel$export(module.exports, \"default\"'));\n      contents = await outputFS.readFile(path.join(distDir, '/pkg-b/src/index.js'), 'utf8');\n      assert(contents.includes('require(\"./index.css\")'));\n      contents = await outputFS.readFile(path.join(distDir, '/pkg-b/src/index.css'), 'utf8');\n      assert(/\\.[_0-9a-zA-Z]+_foo/.test(contents));\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build using root targets with a glob pointing at files inside packages and cwd outside project root","suites":["monorepos"],"updatePoint":{"line":197,"column":112,"index":8062},"line":197,"code":"  it('should build using root targets with a glob pointing at files inside packages and cwd outside project root', async function () {\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(path.join(__dirname, '/integration'));\n    try {\n      let b = await bundle(path.join(__dirname, '/integration/monorepo/packages/*/src/index.js'), {\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          distDir\n        }\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js']\n      }, {\n        name: 'index.js',\n        assets: ['index.js', 'index.module.css']\n      }, {\n        name: 'index.css',\n        assets: ['index.module.css']\n      }]);\n      let contents = await outputFS.readFile(path.join(distDir, '/pkg-a/src/index.js'), 'utf8');\n      assert(contents.includes('$parcel$export(module.exports, \"default\"'));\n      contents = await outputFS.readFile(path.join(distDir, '/pkg-b/src/index.js'), 'utf8');\n      assert(contents.includes('require(\"./index.css\")'));\n      contents = await outputFS.readFile(path.join(distDir, '/pkg-b/src/index.css'), 'utf8');\n      assert(/\\.[_0-9a-zA-Z]+_foo/.test(contents));\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build a single package with an entry file and cwd at a package","suites":["monorepos"],"updatePoint":{"line":227,"column":75,"index":9245},"line":227,"code":"  it('should build a single package with an entry file and cwd at a package', async function () {\n    let fixture = path.join(__dirname, '/integration/monorepo/packages/pkg-a');\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(fixture);\n    try {\n      let b = await bundle(path.join(fixture, 'src/index.js'), {\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          distDir\n        }\n      });\n      assertBundles(b, [{\n        name: 'pkg-a.cjs.js',\n        assets: ['index.js']\n      }, {\n        name: 'pkg-a.module.js',\n        assets: ['index.js']\n      }]);\n      let contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-a/dist/pkg-a.cjs.js'), 'utf8');\n      assert(contents.includes('$parcel$export(module.exports, \"default\"'));\n      contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-a/dist/pkg-a.module.js'), 'utf8');\n      assert(contents.includes('export {'));\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build a single package with an entry file and cwd inside a package","suites":["monorepos"],"updatePoint":{"line":253,"column":79,"index":10281},"line":253,"code":"  it('should build a single package with an entry file and cwd inside a package', async function () {\n    let fixture = path.join(__dirname, '/integration/monorepo/packages/pkg-a/src');\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(fixture);\n    try {\n      let b = await bundle(path.join(fixture, 'index.js'), {\n        defaultTargetOptions: {\n          shouldScopeHoist: true,\n          distDir\n        }\n      });\n      assertBundles(b, [{\n        name: 'pkg-a.cjs.js',\n        assets: ['index.js']\n      }, {\n        name: 'pkg-a.module.js',\n        assets: ['index.js']\n      }]);\n      let contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-a/dist/pkg-a.cjs.js'), 'utf8');\n      assert(contents.includes('$parcel$export(module.exports, \"default\"'));\n      contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-a/dist/pkg-a.module.js'), 'utf8');\n      assert(contents.includes('export {'));\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build multiple packages in a monorepo at once, pointing at a glob of directories","suites":["monorepos"],"updatePoint":{"line":279,"column":93,"index":11331},"line":279,"code":"  it('should build multiple packages in a monorepo at once, pointing at a glob of directories', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/monorepo/packages/*'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      name: 'pkg-a.cjs.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-a.module.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-b.cjs.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-b.module.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-b.cjs.css',\n      assets: ['index.module.css']\n    }]);\n    let contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-a/dist/pkg-a.cjs.js'), 'utf8');\n    assert(contents.includes('$parcel$export(module.exports, \"default\"'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-a/dist/pkg-a.module.js'), 'utf8');\n    assert(contents.includes('export {'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-b/dist/pkg-b.cjs.js'), 'utf8');\n    assert(contents.includes('require(\"./pkg-b.cjs.css\")'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-b/dist/pkg-b.cjs.css'), 'utf8');\n    assert(/\\.[_0-9a-zA-Z]+_foo/.test(contents));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo/packages/pkg-b/dist/pkg-b.module.js'), 'utf8');\n    assert(contents.includes('import \"./pkg-b.cjs.css\"'));\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should watch glob entries and build new packages that are added","suites":["monorepos"],"updatePoint":{"line":312,"column":69,"index":12929},"line":312,"code":"  it('should watch glob entries and build new packages that are added', async function () {\n    // copy into memory fs\n    await ncp(path.join(__dirname, '/integration/monorepo/packages/pkg-a'), path.join(__dirname, '/monorepo/packages/pkg-a'));\n    let b = await bundler(path.join(__dirname, '/monorepo/packages/*'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      },\n      inputFS: overlayFS\n    });\n    subscription = await b.watch();\n    let evt = await getNextBuild(b);\n    assertBundles(evt.bundleGraph, [{\n      name: 'pkg-a.cjs.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-a.module.js',\n      assets: ['index.js']\n    }]);\n    await ncp(path.join(__dirname, '/integration/monorepo/packages/pkg-b'), path.join(__dirname, '/monorepo/packages/pkg-b'));\n    evt = await getNextBuild(b);\n    assertBundles(evt.bundleGraph, [{\n      name: 'pkg-a.cjs.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-a.module.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-b.cjs.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-b.module.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-b.cjs.css',\n      assets: ['index.module.css']\n    }]);\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should watch package.json containing \"source\" field for changes","suites":["monorepos"],"updatePoint":{"line":349,"column":69,"index":14173},"line":349,"code":"  it('should watch package.json containing \"source\" field for changes', async function () {\n    // copy into memory fs\n    await ncp(path.join(__dirname, '/integration/monorepo/packages/pkg-a'), path.join(__dirname, '/monorepo/packages/pkg-a'));\n    let b = await bundler(path.join(__dirname, '/monorepo/packages/*'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      },\n      inputFS: overlayFS\n    });\n    subscription = await b.watch();\n    let evt = await getNextBuild(b);\n    assertBundles(evt.bundleGraph, [{\n      name: 'pkg-a.cjs.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-a.module.js',\n      assets: ['index.js']\n    }]);\n    let pkgFile = path.join(__dirname, '/monorepo/packages/pkg-a/package.json');\n    let pkg = JSON.parse(await outputFS.readFile(pkgFile, 'utf8'));\n    await outputFS.writeFile(pkgFile, JSON.stringify({\n      ...pkg,\n      source: 'src/alt.js'\n    }));\n    evt = await getNextBuild(b);\n    assert(evt.type === 'buildSuccess');\n    assertBundles(evt.bundleGraph, [{\n      name: 'pkg-a.cjs.js',\n      assets: ['alt.js']\n    }, {\n      name: 'pkg-a.module.js',\n      assets: ['alt.js']\n    }]);\n    let contents = await outputFS.readFile(path.join(__dirname, '/monorepo/packages/pkg-a/dist/pkg-a.cjs.js'), 'utf8');\n    assert(contents.includes('return 3'));\n    contents = await outputFS.readFile(path.join(__dirname, '/monorepo/packages/pkg-a/dist/pkg-a.module.js'), 'utf8');\n    assert(contents.includes('return 3'));\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should watch package.json containing targets for changes","suites":["monorepos"],"updatePoint":{"line":387,"column":62,"index":15655},"line":387,"code":"  it('should watch package.json containing targets for changes', async function () {\n    // copy into memory fs\n    await ncp(path.join(__dirname, '/integration/monorepo/packages/pkg-a'), path.join(__dirname, '/monorepo/packages/pkg-a'));\n    let b = await bundler(path.join(__dirname, '/monorepo/packages/*'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      },\n      inputFS: overlayFS\n    });\n    subscription = await b.watch();\n    let evt = await getNextBuild(b);\n    assertBundles(evt.bundleGraph, [{\n      name: 'pkg-a.cjs.js',\n      assets: ['index.js']\n    }, {\n      name: 'pkg-a.module.js',\n      assets: ['index.js']\n    }]);\n    let pkgFile = path.join(__dirname, '/monorepo/packages/pkg-a/package.json');\n    let pkg = JSON.parse(await outputFS.readFile(pkgFile, 'utf8'));\n    await outputFS.writeFile(pkgFile, JSON.stringify({\n      ...pkg,\n      main: 'dist/alt.js',\n      module: 'dist/alt.module.js'\n    }));\n    evt = await getNextBuild(b);\n    assertBundles(evt.bundleGraph, [{\n      name: 'alt.js',\n      assets: ['index.js']\n    }, {\n      name: 'alt.module.js',\n      assets: ['index.js']\n    }]);\n    let contents = await outputFS.readFile(path.join(__dirname, '/monorepo/packages/pkg-a/dist/alt.js'), 'utf8');\n    assert(contents.includes('return 2'));\n    contents = await outputFS.readFile(path.join(__dirname, '/monorepo/packages/pkg-a/dist/alt.module.js'), 'utf8');\n    assert(contents.includes('return 2'));\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not share bundles between targets","suites":["monorepos"],"updatePoint":{"line":425,"column":46,"index":17103},"line":425,"code":"  it('should not share bundles between targets', async function () {\n    let b = await bundle([path.join(__dirname, '/integration/monorepo-shared/packages/pkg-a'), path.join(__dirname, '/integration/monorepo-shared/packages/pkg-b')], {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assertBundles(b, [{\n      name: 'pkg-a.cjs.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-a.module.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-a.cjs.css',\n      assets: ['index.module.css']\n    }, {\n      name: 'pkg-b.cjs.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-b.module.js',\n      assets: ['index.js', 'index.module.css']\n    }, {\n      name: 'pkg-b.cjs.css',\n      assets: ['index.module.css']\n    }]);\n    let contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo-shared/packages/pkg-a/dist/pkg-a.cjs.js'), 'utf8');\n    assert(contents.includes('$parcel$export(module.exports, \"default\"'));\n    assert(contents.includes('require(\"./pkg-a.cjs.css\")'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo-shared/packages/pkg-a/dist/pkg-a.module.js'), 'utf8');\n    assert(contents.includes('export {'));\n    assert(contents.includes('import \"./pkg-a.cjs.css\"'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo-shared/packages/pkg-a/dist/pkg-a.cjs.css'), 'utf8');\n    assert(/\\.[_0-9a-zA-Z]+_foo/.test(contents));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo-shared/packages/pkg-b/dist/pkg-b.cjs.js'), 'utf8');\n    assert(contents.includes('require(\"./pkg-b.cjs.css\")'));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo-shared/packages/pkg-b/dist/pkg-b.cjs.css'), 'utf8');\n    assert(/\\.[_0-9a-zA-Z]+_foo/.test(contents));\n    contents = await outputFS.readFile(path.join(__dirname, '/integration/monorepo-shared/packages/pkg-b/dist/pkg-b.module.js'), 'utf8');\n    assert(contents.includes('import \"./pkg-b.cjs.css\"'));\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should search for .parcelrc at cwd in monorepos","suites":["monorepos"],"updatePoint":{"line":465,"column":53,"index":19221},"line":465,"code":"  it('should search for .parcelrc at cwd in monorepos', async () => {\n    let fixture = path.join(__dirname, '/integration/parcelrc-monorepo/app/index.js');\n    let oldcwd = inputFS.cwd();\n    inputFS.chdir(path.dirname(fixture));\n    try {\n      let b = await bundle(fixture);\n      assert.equal((await run(b)).default, '<svg></svg>\\n');\n    } finally {\n      inputFS.chdir(oldcwd);\n    }\n  });","file":"monorepos.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should determine correct entry root when building a directory","suites":["namer"],"updatePoint":{"line":5,"column":67,"index":218},"line":5,"code":"  it('should determine correct entry root when building a directory', async function () {\n    await bundle(path.join(__dirname, 'integration/namer-dir'));\n    assert(await outputFS.exists(path.join(distDir, 'index.html')));\n    assert(await outputFS.exists(path.join(distDir, 'nested/other.html')));\n  });","file":"namer.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output (exports)","suites":["output formats","commonjs"],"updatePoint":{"line":18,"column":48,"index":656},"line":18,"code":"    it('should support commonjs output (exports)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs/exports.js'));\n      assert.equal((await run(b)).bar, 5);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output (module.exports)","suites":["output formats","commonjs"],"updatePoint":{"line":22,"column":55,"index":879},"line":22,"code":"    it('should support commonjs output (module.exports)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs/module-exports.js'));\n      let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(!dist.includes('function')); // no iife\n      assert.equal(await run(b), 5);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output from esmodule input","suites":["output formats","commonjs"],"updatePoint":{"line":28,"column":58,"index":1237},"line":28,"code":"    it('should support commonjs output from esmodule input', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-commonjs/a.js'));\n      assert.equal((await run(b)).bar, 5);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output from esmodule input (re-export rename)","suites":["output formats","commonjs"],"updatePoint":{"line":32,"column":77,"index":1480},"line":32,"code":"    it('should support commonjs output from esmodule input (re-export rename)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-commonjs/re-export-rename.js'));\n      assert.equal((await run(b)).default, 2);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output from esmodule input (re-export namespace as)","suites":["output formats","commonjs"],"line":36,"code":"    it.skip('should support commonjs output from esmodule input (re-export namespace as)', async function () {","file":"output-formats.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output from esmodule input (same binding multiple exports)","suites":["output formats","commonjs"],"updatePoint":{"line":44,"column":90,"index":2221},"line":44,"code":"    it('should support commonjs output from esmodule input (same binding multiple exports)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-commonjs/multiple-times.js'));\n      assert.deepStrictEqual(await run(b), {\n        default: 1,\n        test: 1,\n        other: 1,\n        foo: 2\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output from esmodule input (skipped exports)","suites":["output formats","commonjs"],"updatePoint":{"line":53,"column":76,"index":2558},"line":53,"code":"    it('should support commonjs output from esmodule input (skipped exports)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-commonjs-isLibrary-false/skipped.js'));\n      assert.deepEqual(await run(b), {});\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with external modules (require)","suites":["output formats","commonjs"],"updatePoint":{"line":57,"column":70,"index":2815},"line":57,"code":"    it('should support commonjs output with external modules (require)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-external/require.js'));\n      let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(dist.includes('require(\"lodash\")'));\n      assert.equal((await run(b)).bar, 3);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with external modules (named import)","suites":["output formats","commonjs"],"updatePoint":{"line":63,"column":75,"index":3195},"line":63,"code":"    it('should support commonjs output with external modules (named import)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-external/named.js'));\n      assert.equal((await run(b)).bar, 3);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with external modules (named import with same name)","suites":["output formats","commonjs"],"updatePoint":{"line":67,"column":90,"index":3460},"line":67,"code":"    it('should support commonjs output with external modules (named import with same name)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-external/named-same.js'));\n      assert.equal((await run(b)).bar, true);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with external modules (namespace import)","suites":["output formats","commonjs"],"updatePoint":{"line":71,"column":79,"index":3722},"line":71,"code":"    it('should support commonjs output with external modules (namespace import)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-external/namespace.js'));\n      let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(dist.includes('= require(\"lodash\")'));\n      assert.equal((await run(b)).bar, 3);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with external modules (default import)","suites":["output formats","commonjs"],"updatePoint":{"line":77,"column":77,"index":4108},"line":77,"code":"    it('should support commonjs output with external modules (default import)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-external/default.js'));\n      let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(dist.includes('$parcel$interopDefault'));\n      assert.equal((await run(b)).bar, 3);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with external modules (default import new call)","suites":["output formats","commonjs"],"updatePoint":{"line":83,"column":86,"index":4504},"line":83,"code":"    it('should support commonjs output with external modules (default import new call)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-external/default-new.js'));\n      let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(dist.includes('$parcel$interopDefault'));\n      await run(b);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with external modules (multiple specifiers)","suites":["output formats","commonjs"],"updatePoint":{"line":89,"column":82,"index":4877},"line":89,"code":"    it('should support commonjs output with external modules (multiple specifiers)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-external/multiple.js'));\n      let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(dist.includes('= require(\"lodash\")'));\n      assert(dist.includes('= (0, ($parcel$interopDefault('));\n      assert(/var {add: \\s*\\$.+?\\$add\\s*} = lodash/);\n      assert.equal((await run(b)).bar, 6);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with old node without destructuring (single)","suites":["output formats","commonjs"],"updatePoint":{"line":97,"column":83,"index":5385},"line":97,"code":"    it('should support commonjs output with old node without destructuring (single)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-destructuring-node/single.js'));\n      assert.equal((await run(b)).bar, 3);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with old node without destructuring (multiple single with same name)","suites":["output formats","commonjs"],"updatePoint":{"line":101,"column":107,"index":5678},"line":101,"code":"    it('should support commonjs output with old node without destructuring (multiple single with same name)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-destructuring-node/single-same.js'));\n      assert.equal((await run(b)).bar, true);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with old node without destructuring (multiple)","suites":["output formats","commonjs"],"updatePoint":{"line":105,"column":85,"index":5957},"line":105,"code":"    it('should support commonjs output with old node without destructuring (multiple)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-destructuring-node/multiple.js'));\n      assert.equal((await run(b)).bar, 2);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with old browsers without destructuring (single)","suites":["output formats","commonjs"],"updatePoint":{"line":109,"column":87,"index":6232},"line":109,"code":"    it('should support commonjs output with old browsers without destructuring (single)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-destructuring-browsers/single.js'));\n      assert.equal((await run(b, {\n        require\n      })).bar, 3);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs output with old node without destructuring (multiple)","suites":["output formats","commonjs"],"updatePoint":{"line":115,"column":85,"index":6534},"line":115,"code":"    it('should support commonjs output with old node without destructuring (multiple)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-destructuring-browsers/multiple.js'));\n      assert.equal((await run(b, {\n        require\n      })).bar, 2);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing sibling bundles in library mode","suites":["output formats","commonjs"],"updatePoint":{"line":121,"column":64,"index":6817},"line":121,"code":"    it('should support importing sibling bundles in library mode', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-siblings/a.js'));\n      let dist = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n      assert(dist.includes('require(\"./index.css\")'));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support async imports","suites":["output formats","commonjs"],"updatePoint":{"line":126,"column":36,"index":7138},"line":126,"code":"    it('should support async imports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-async/index.js'));\n      let index = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('index')).filePath, 'utf8');\n      assert(/Promise\\.resolve\\(require\\(\"\\.\\/async\\..+?\\.js\"\\)\\)/.test(index));\n      assert.equal(await run(b), 4);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support async split bundles","suites":["output formats","commonjs"],"updatePoint":{"line":132,"column":42,"index":7541},"line":132,"code":"    it('should support async split bundles', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-split/index.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldOptimize: false\n        }\n      });\n      let index = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('index')).filePath, 'utf8');\n      assert(/Promise\\.resolve\\(require\\(\"\\.\\/async1\\..+?\\.js\"\\)\\)/.test(index));\n      assert(/Promise\\.resolve\\(require\\(\"\\.\\/async2\\..+?\\.js\"\\)\\)/.test(index));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support async split bundles (reexport default)","suites":["output formats","commonjs"],"updatePoint":{"line":143,"column":61,"index":8122},"line":143,"code":"    it('should support async split bundles (reexport default)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-split-reexport-default/index.js'), {\n        mode: 'production'\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js']\n      }, {\n        type: 'js',\n        assets: ['shared.js']\n      }, {\n        type: 'js',\n        assets: ['async1.js']\n      }, {\n        type: 'js',\n        assets: ['async2.js']\n      }]);\n      assert.strictEqual(await run(b), 20579 * 2);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should call init for wrapped modules when codesplitting to to commonjs","suites":["output formats","commonjs"],"updatePoint":{"line":162,"column":78,"index":8710},"line":162,"code":"    it('should call init for wrapped modules when codesplitting to to commonjs', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-wrap-codesplit/a.js'));\n      assert.equal(await run(b), 2);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support sideEffects: false","suites":["output formats","commonjs"],"updatePoint":{"line":166,"column":41,"index":8922},"line":166,"code":"    it('should support sideEffects: false', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-sideeffects/index.js'));\n      let ns = await run(b);\n      assert.equal(typeof ns.test, 'function');\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw an error on missing export with esmodule input and sideEffects: false","suites":["output formats","commonjs"],"updatePoint":{"line":171,"column":90,"index":9224},"line":171,"code":"    it('should throw an error on missing export with esmodule input and sideEffects: false', async function () {\n      let message = \"other.js does not export 'a'\";\n      let source = path.join(__dirname, '/integration/formats/commonjs-sideeffects', 'missing-export.js');\n      await assert.rejects(() => bundle(path.join(__dirname, '/integration/formats/commonjs-sideeffects', 'missing-export.js')), {\n        name: 'BuildError',\n        message,\n        diagnostics: [{\n          message,\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: source,\n            language: 'js',\n            codeHighlights: [{\n              start: {\n                line: 1,\n                column: 10\n              },\n              end: {\n                line: 1,\n                column: 15\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs input","suites":["output formats","commonjs"],"updatePoint":{"line":197,"column":37,"index":10048},"line":197,"code":"    it('should support commonjs input', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-dynamic/index.js'));\n      let dist = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n      assert(dist.includes('Object.assign(module.exports'));\n      let ns = await run(b);\n      assert.equal(typeof ns.test, 'function');\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs requires without interop","suites":["output formats","commonjs"],"updatePoint":{"line":204,"column":56,"index":10475},"line":204,"code":"    it('should support commonjs requires without interop', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-require/index.js'));\n      let dist = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n      assert(dist.includes('= require(\"lodash\")'));\n      let add = await run(b);\n      assert.equal(add(2, 3), 5);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support generating commonjs output with re-exports in entry","suites":["output formats","commonjs"],"updatePoint":{"line":211,"column":74,"index":10898},"line":211,"code":"    it('should support generating commonjs output with re-exports in entry', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-entry-re-export/a.js'));\n      assert.deepEqual(await run(b), {\n        foo: 'foo'\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile workers to statically analyzable URL expressions","suites":["output formats","commonjs"],"updatePoint":{"line":217,"column":71,"index":11172},"line":217,"code":"    it('should compile workers to statically analyzable URL expressions', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/workers-module/index.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          outputFormat: 'commonjs',\n          shouldScopeHoist: true,\n          shouldOptimize: false,\n          isLibrary: true\n        }\n      });\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      let workerBundle = b.getBundles().find(b => b.name.startsWith('dedicated-worker'));\n      let sharedWorkerBundle = b.getBundles().find(b => b.name.startsWith('shared-worker'));\n      assert(contents.includes(`new Worker(new URL(\"${path.basename(workerBundle.filePath)}\", \"file:\" + __filename)`));\n      assert(contents.includes(`new SharedWorker(new URL(\"${path.basename(sharedWorkerBundle.filePath)}\", \"file:\" + __filename)`));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile url: pipeline dependencies to statically analyzable URL expressions for libraries","suites":["output formats","commonjs"],"updatePoint":{"line":233,"column":104,"index":12124},"line":233,"code":"    it('should compile url: pipeline dependencies to statically analyzable URL expressions for libraries', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/worklet/pipeline.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          outputFormat: 'commonjs',\n          shouldScopeHoist: true,\n          shouldOptimize: false,\n          isLibrary: true\n        }\n      });\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes(`new URL(\"${path.basename(b.getBundles()[1].filePath)}\", \"file:\" + __filename)`));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should URL dependencies to statically analyzable URL expressions for libraries","suites":["output formats","commonjs"],"updatePoint":{"line":246,"column":86,"index":12733},"line":246,"code":"    it('should URL dependencies to statically analyzable URL expressions for libraries', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/worklet/url.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          outputFormat: 'commonjs',\n          shouldScopeHoist: true,\n          shouldOptimize: false,\n          isLibrary: true\n        }\n      });\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes(`new URL(\"${path.basename(b.getBundles()[1].filePath)}\", \"file:\" + __filename)`));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support live binding of external modules","suites":["output formats","commonjs"],"updatePoint":{"line":259,"column":55,"index":13306},"line":259,"code":"    it('should support live binding of external modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-live-externals/a.js'));\n      let external = {\n        foo: 1,\n        setFoo(f) {\n          this.foo = f;\n        }\n      };\n      let out = [];\n      await run(b, {\n        require: () => external,\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, [1, 2]);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (named export)","suites":["output formats","esmodule"],"updatePoint":{"line":278,"column":53,"index":13812},"line":278,"code":"    it('should support esmodule output (named export)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm/named.js'));\n      await assertESMExports(b, {\n        bar: 5,\n        foo: 2\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (default identifier)","suites":["output formats","esmodule"],"updatePoint":{"line":285,"column":59,"index":14064},"line":285,"code":"    it('should support esmodule output (default identifier)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm/default-value.js'));\n      let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(!dist.includes('function')); // no iife\n      await assertESMExports(b, {\n        default: 4\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (default function)","suites":["output formats","esmodule"],"updatePoint":{"line":293,"column":57,"index":14441},"line":293,"code":"    it('should support esmodule output (default function)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm/default-function.js'));\n      assert.strictEqual((await run(b)).default(), 2);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (multiple)","suites":["output formats","esmodule"],"updatePoint":{"line":297,"column":49,"index":14674},"line":297,"code":"    it('should support esmodule output (multiple)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm/multiple.js'));\n      await assertESMExports(b, {\n        a: 2,\n        c: 5,\n        default: 3\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (exporting symbol multiple times)","suites":["output formats","esmodule"],"updatePoint":{"line":305,"column":72,"index":14958},"line":305,"code":"    it('should support esmodule output (exporting symbol multiple times)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm/multiple-times.js'));\n      await assertESMExports(b, {\n        default: 1,\n        foo: 2,\n        other: 1,\n        test: 1\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (re-export)","suites":["output formats","esmodule"],"updatePoint":{"line":314,"column":50,"index":15249},"line":314,"code":"    it('should support esmodule output (re-export)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm/re-export.js'));\n      await assertESMExports(b, {\n        a: 2,\n        c: 5\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (re-export namespace as)","suites":["output formats","esmodule"],"line":321,"code":"    it.skip('should support esmodule output (re-export namespace as)', async function () {","file":"output-formats.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (renaming re-export)","suites":["output formats","esmodule"],"updatePoint":{"line":330,"column":59,"index":15803},"line":330,"code":"    it('should support esmodule output (renaming re-export)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm/re-export-rename.js'));\n      await assertESMExports(b, {\n        foo: 4\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output with external modules (named import)","suites":["output formats","esmodule"],"updatePoint":{"line":336,"column":75,"index":16066},"line":336,"code":"    it('should support esmodule output with external modules (named import)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-external/named.js'));\n      await assertESMExports(b, {\n        bar: 3\n      }, {\n        lodash: () => ({\n          add: (a, b) => a + b\n        })\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output with external modules (named import with same name)","suites":["output formats","esmodule"],"updatePoint":{"line":346,"column":90,"index":16420},"line":346,"code":"    it('should support esmodule output with external modules (named import with same name)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-external/named-same.js'));\n      await assertESMExports(b, {\n        bar: true\n      }, {\n        lodash: () => lodash,\n        'lodash/fp': () => lodashFP\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output with external modules (namespace import)","suites":["output formats","esmodule"],"updatePoint":{"line":355,"column":79,"index":16770},"line":355,"code":"    it('should support esmodule output with external modules (namespace import)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-external/namespace.js'));\n      await assertESMExports(b, {\n        bar: 3\n      }, {\n        lodash: () => lodash\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output with external modules (default import)","suites":["output formats","esmodule"],"updatePoint":{"line":363,"column":77,"index":17077},"line":363,"code":"    it('should support esmodule output with external modules (default import)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-external/default.js'));\n      await assertESMExports(b, {\n        bar: 3\n      }, {\n        lodash: () => lodash\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output with external modules (multiple specifiers)","suites":["output formats","esmodule"],"updatePoint":{"line":371,"column":82,"index":17387},"line":371,"code":"    it('should support esmodule output with external modules (multiple specifiers)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-external/multiple.js'));\n      await assertESMExports(b, {\n        bar: 6\n      }, {\n        lodash: () => lodash\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output with external modules (export)","suites":["output formats","esmodule"],"updatePoint":{"line":379,"column":69,"index":17685},"line":379,"code":"    it('should support esmodule output with external modules (export)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-external/export.js'));\n      await assertESMExports(b, 3, {\n        lodash: () => lodash\n      }, ns => ns.add(1, 2));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output with external modules (re-export)","suites":["output formats","esmodule"],"updatePoint":{"line":385,"column":72,"index":17981},"line":385,"code":"    it('should support esmodule output with external modules (re-export)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-external/re-export.js'));\n      await assertESMExports(b, 3, {\n        lodash: () => lodash\n      }, ns => ns.add(1, 2));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output with external modules (re-export child)","suites":["output formats","esmodule"],"updatePoint":{"line":391,"column":78,"index":18286},"line":391,"code":"    it('should support esmodule output with external modules (re-export child)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-external/re-export-child.js'));\n      await assertESMExports(b, 3, {\n        lodash: () => lodash\n      }, ns => ns.add(1, 2));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing sibling bundles in library mode","suites":["output formats","esmodule"],"updatePoint":{"line":397,"column":64,"index":18583},"line":397,"code":"    it('should support importing sibling bundles in library mode', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-siblings/a.js'));\n      let dist = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n      assert(dist.includes('import \"./index.css\"'));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support esmodule output (skipped exports)","suites":["output formats","esmodule"],"updatePoint":{"line":402,"column":56,"index":18917},"line":402,"code":"    it('should support esmodule output (skipped exports)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-isLibrary-false/skipped.js'));\n      let dist = await outputFS.readFile(b.getBundles().find(b => b.type === 'js').filePath, 'utf8');\n      assert(!dist.includes('foo'));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support interop imports from other bundles","suites":["output formats","esmodule"],"updatePoint":{"line":407,"column":57,"index":19249},"line":407,"code":"    it('should support interop imports from other bundles', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-interop-cross-bundle/a.js'));\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['a.js', 'c.js']\n      }, {\n        type: 'js',\n        assets: ['b.js']\n      }]);\n      let dist = await outputFS.readFile(b.getBundles().find(b => !b.needsStableName).filePath, 'utf8');\n      assert(dist.includes('$parcel$interopDefault'));\n      let ns = await run(b);\n      assert.deepEqual(await ns.default, [123, 123]);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should rename imports that conflict with exports","suites":["output formats","esmodule"],"updatePoint":{"line":421,"column":56,"index":19829},"line":421,"code":"    it('should rename imports that conflict with exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-conflict/a.js'));\n      await assertESMExports(b, {\n        foo: 13\n      }, {\n        foo: () => ({\n          foo: 10\n        })\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support async imports","suites":["output formats","esmodule"],"updatePoint":{"line":431,"column":36,"index":20110},"line":431,"code":"    it('should support async imports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-async/index.js'));\n      let index = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('index')).filePath, 'utf8');\n      assert(/import\\(\"\\.\\/async\\..+?\\.js\"\\)/.test(index));\n      await assertESMExports(b, 4, {}, ns => ns.default);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support dynamic imports with chained reexports","suites":["output formats","esmodule"],"line":440,"code":"    it.skip('should support dynamic imports with chained reexports', async function () {","file":"output-formats.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support dynamic imports with chained reexports II","suites":["output formats","esmodule"],"updatePoint":{"line":445,"column":64,"index":21021},"line":445,"code":"    it('should support dynamic imports with chained reexports II', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-async-chained-reexport2/index.js'));\n      let async = await outputFS.readFile(b.getChildBundles(b.getBundles()[0])[0].filePath, 'utf8');\n      assert(!async.includes('$import$'));\n      await assertESMExports(b, ['index', 'a', 1], {}, ns => ns.default);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw an error on missing export with esmodule output and sideEffects: false","suites":["output formats","esmodule"],"updatePoint":{"line":451,"column":91,"index":21472},"line":451,"code":"    it('should throw an error on missing export with esmodule output and sideEffects: false', async function () {\n      let message = \"b.js does not export 'a'\";\n      let source = path.join(__dirname, 'integration/formats/esm-sideeffects', 'missing-export.js');\n      await assert.rejects(() => bundle(path.join(__dirname, 'integration/formats/esm-sideeffects/missing-export.js')), {\n        name: 'BuildError',\n        message,\n        diagnostics: [{\n          message,\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: source,\n            language: 'js',\n            codeHighlights: [{\n              start: {\n                line: 1,\n                column: 10\n              },\n              end: {\n                line: 1,\n                column: 15\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support async split bundles","suites":["output formats","esmodule"],"updatePoint":{"line":477,"column":42,"index":22282},"line":477,"code":"    it('should support async split bundles', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-split/index.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldOptimize: false\n        }\n      });\n      let index = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('index')).filePath, 'utf8');\n      assert(/import\\(\"\\.\\/async1\\..+?\\.js\"\\)/.test(index));\n      assert(/import\\(\"\\.\\/async2\\..+?\\.js\"\\)/.test(index));\n      await assertESMExports(b, true, {\n        lodash: () => lodash,\n        react: () => react\n      }, ns => ns.default);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should call init for wrapped modules when codesplitting to esmodules","suites":["output formats","esmodule"],"updatePoint":{"line":492,"column":76,"index":22956},"line":492,"code":"    it('should call init for wrapped modules when codesplitting to esmodules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-wrap-codesplit/a.js'));\n      let ns = await run(b);\n      // TODO: https://github.com/parcel-bundler/parcel/issues/5459\n      assert.deepStrictEqual(await ns.default, 2);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support async split bundles for workers","suites":["output formats","esmodule"],"updatePoint":{"line":498,"column":54,"index":23287},"line":498,"code":"    it('should support async split bundles for workers', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-split-worker/index.html'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldOptimize: false\n        }\n      });\n      let workerBundle = nullthrows(b.getBundles().find(b => b.env.context === 'web-worker'));\n      let workerBundleContents = await outputFS.readFile(workerBundle.filePath, 'utf8');\n      let asyncBundle = b.getChildBundles(workerBundle).find(b => b.filePath.includes('async'));\n      let syncBundle = b.getReferencedBundles(workerBundle).find(b => !b.filePath.includes('async'));\n      assert(workerBundleContents.includes(`import \"./${path.basename(syncBundle.filePath)}\"`));\n      assert(workerBundleContents.includes(path.basename(asyncBundle.filePath)));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support building esmodules for browser targets","suites":["output formats","esmodule"],"updatePoint":{"line":512,"column":61,"index":24156},"line":512,"code":"    it('should support building esmodules for browser targets', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-browser/index.html'));\n      let html = await outputFS.readFile(b.getBundles().find(b => b.type === 'html').filePath, 'utf8');\n      assert(html.includes('<script type=\"module\" src=\"/index'));\n      let entry = await outputFS.readFile(b.getBundles().find(b => path.basename(b.filePath) === html.match(/src=\"\\/(.*?)\"/)[1]).filePath, 'utf8');\n      let asyncBundle = b.getBundles().find(bundle => bundle.name.startsWith('async'));\n      assert(entry.includes(`import(\"./${path.basename(asyncBundle.filePath)}\")`));\n      let res = await run(b, {\n        output: null\n      }, {\n        require: false\n      });\n      assert.equal(await res.output, 4);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support using an import polyfill for older browsers","suites":["output formats","esmodule"],"updatePoint":{"line":526,"column":66,"index":24977},"line":526,"code":"    it('should support using an import polyfill for older browsers', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-browser/index.html'), {\n        defaultTargetOptions: {\n          engines: {\n            browsers: [\n            // Implements es modules but not dynamic imports\n            'Chrome 61']\n          }\n        }\n      });\n      let html = await outputFS.readFile(b.getBundles().find(b => b.type === 'html').filePath, 'utf8');\n      assert(html.includes('<script type=\"module\" src=\"/index'));\n      let entry = await outputFS.readFile(b.getBundles().find(b => path.basename(b.filePath) === html.match(/src=\"\\/(.*?)\"/)[1]).filePath, 'utf8');\n      assert(entry.includes('function importModule'));\n      let asyncBundle = b.getBundles().find(bundle => bundle.name.startsWith('async'));\n      assert(new RegExp(`getBundleURL\\\\(\"[a-zA-Z0-9]+\"\\\\) \\\\+ \"` + path.basename(asyncBundle.filePath) + '\"').test(entry));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support building esmodules with css imports","suites":["output formats","esmodule"],"updatePoint":{"line":543,"column":58,"index":25944},"line":543,"code":"    it('should support building esmodules with css imports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-browser-css/index.html'));\n      let html = await outputFS.readFile(b.getBundles().find(b => b.type === 'html').filePath, 'utf8');\n      assert(html.includes('<script type=\"module\" src=\"/index'));\n      assert(html.includes('<link rel=\"stylesheet\" href=\"/index'));\n      let entry = await outputFS.readFile(b.getBundles().find(b => path.basename(b.filePath) === html.match(/src=\"\\/(.*?)\"/)[1]).filePath, 'utf8');\n      let bundles = b.getBundles();\n      let asyncJsBundle = bundles.find(bundle => bundle.type === 'js' && bundle.name.startsWith('async'));\n      let asyncCssBundle = bundles.find(bundle => bundle.type === 'css' && bundle.name.startsWith('async'));\n      assert(new RegExp('Promise.all\\\\(\\\\[\\\\n.+?new URL\\\\(\"' + path.basename(asyncCssBundle.filePath) + '\", import.meta.url\\\\).toString\\\\(\\\\)\\\\),\\\\n\\\\s*import\\\\(\"\\\\.\\\\/' + path.basename(asyncJsBundle.filePath) + '\"\\\\)\\\\n\\\\s*\\\\]\\\\)').test(entry));\n      let async = await outputFS.readFile(b.getBundles().find(b => b.type === 'js' && b.name.startsWith('async')).filePath, 'utf8');\n      assert(!async.includes('.css\"'));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support building esmodules with split bundles","suites":["output formats","esmodule"],"updatePoint":{"line":556,"column":60,"index":27194},"line":556,"code":"    it('should support building esmodules with split bundles', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-browser-split-bundle/index.html'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldOptimize: false\n        }\n      });\n      let html = await outputFS.readFile(b.getBundles().find(b => b.type === 'html').filePath, 'utf8');\n      assert(html.includes('<script type=\"module\" src=\"/index'));\n      let bundles = b.getBundles();\n      let entry = await outputFS.readFile(bundles.find(b => path.basename(b.filePath) === html.match(/src=\"\\/(.*?)\"/)[1]).filePath, 'utf8');\n      let sharedBundle = bundles.find(b => b.getEntryAssets().length === 0);\n      let async1Bundle = bundles.find(b => b.name.startsWith('async1') && b.id !== sharedBundle.id);\n      let async2Bundle = bundles.find(b => b.name.startsWith('async2'));\n      for (let bundle of [async1Bundle, async2Bundle]) {\n        // async import both bundles in parallel for performance\n        assert(new RegExp(`import\\\\(\"\\\\./\" \\\\+ .+\\\\.resolve\\\\(\"${sharedBundle.publicId}\"\\\\)\\\\),\\\\n\\\\s*import\\\\(\"./\" \\\\+ .+\\\\.resolve\\\\(\"${bundle.publicId}\"\\\\)\\\\)`).test(entry));\n      }\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create correct bundle import for reexports","suites":["output formats","esmodule"],"updatePoint":{"line":575,"column":57,"index":28411},"line":575,"code":"    it('should create correct bundle import for reexports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-bundle-import-reexport/index.js'));\n      await assertESMExports(b, ['!!!index!!!', 'DiagramVersion: !!!some name!!!'], {}, ns => ns.default);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support generating ESM from CommonJS","suites":["output formats","esmodule"],"updatePoint":{"line":579,"column":51,"index":28710},"line":579,"code":"    it('should support generating ESM from CommonJS', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-esm/index.js'));\n      let ns = await run(b, {}, {}, {\n        lodash: () => lodash\n      });\n      assert.strictEqual(ns.default(1, 2), 3);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support re-assigning to module.exports","suites":["output formats","esmodule"],"updatePoint":{"line":586,"column":53,"index":29014},"line":586,"code":"    it('should support re-assigning to module.exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-esm/re-assign.js'));\n      let ns = await run(b);\n      assert.deepStrictEqual({\n        ...ns\n      }, {\n        default: 'xyz'\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"doesn't support require.resolve calls for excluded assets without commonjs","suites":["output formats","esmodule"],"line":595,"code":"    it.skip(\"doesn't support require.resolve calls for excluded assets without commonjs\", async function () {","file":"output-formats.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support generating commonjs output with re-exports in entry","suites":["output formats","esmodule"],"updatePoint":{"line":621,"column":74,"index":30192},"line":621,"code":"    it('should support generating commonjs output with re-exports in entry', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-esm-entry-re-export/a.js'));\n      let ns = await run(b);\n      assert.deepEqual({\n        ...ns\n      }, {\n        default: {\n          default: 'default'\n        }\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support rewriting filename and importing path","suites":["output formats","esmodule"],"updatePoint":{"line":632,"column":60,"index":30538},"line":632,"code":"    it('should support rewriting filename and importing path', async function () {\n      let input = path.join(__dirname, '/integration/formats/esm-filename-import/index.js');\n      let b = await bundle(input);\n      let ns = await run(b);\n      assert.deepEqual(ns.foo, input);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should rename shadowed imported specifiers to something unique","suites":["output formats","esmodule"],"updatePoint":{"line":638,"column":70,"index":30835},"line":638,"code":"    it('should rename shadowed imported specifiers to something unique', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-import-shadow/a.mjs'));\n      let _b = await import(pathToFileURL(path.join(__dirname, '/integration/formats/esm-import-shadow/node_modules/b/index.mjs')).toString());\n      let ns = await run(b, {}, {}, {\n        b: () => _b\n      });\n      let [useContext] = ns.createContext('Hello');\n      assert.strictEqual(useContext(), 'Hello World');\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should rename shadowed exports to something unique","suites":["output formats","esmodule"],"updatePoint":{"line":647,"column":58,"index":31341},"line":647,"code":"    it('should rename shadowed exports to something unique', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-export-shadow/a.mjs'));\n      let ns = await run(b);\n      assert.strictEqual(ns.fib(5), 8);\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support ESM output from CJS input","suites":["output formats","esmodule"],"updatePoint":{"line":652,"column":48,"index":31587},"line":652,"code":"    it('should support ESM output from CJS input', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-cjs/a.js'));\n      let ns = await run(b);\n      assert.deepEqual(ns.test, true);\n      assert.deepEqual(ns.default, {\n        test: true\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support outputting .mjs files","suites":["output formats","esmodule"],"updatePoint":{"line":660,"column":44,"index":31883},"line":660,"code":"    it('should support outputting .mjs files', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-mjs/index.js'));\n      let filePath = b.getBundles()[0].filePath;\n      assert(filePath.endsWith('.mjs'));\n      let output = await outputFS.readFile(filePath, 'utf8');\n      assert(output.includes('import '));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support outputting ESM in .js files with \"type\": \"module\"","suites":["output formats","esmodule"],"updatePoint":{"line":667,"column":72,"index":32271},"line":667,"code":"    it('should support outputting ESM in .js files with \"type\": \"module\"', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/esm-type-module/index.js'));\n      let filePath = b.getBundles()[0].filePath;\n      assert(filePath.endsWith('.js'));\n      let output = await outputFS.readFile(filePath, 'utf8');\n      assert(output.includes('import '));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":".cjs extension should override \"type\": \"module\"","suites":["output formats","esmodule"],"updatePoint":{"line":674,"column":55,"index":32649},"line":674,"code":"    it('.cjs extension should override \"type\": \"module\"', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/formats/cjs-type-module/index.js'));\n      let filePath = b.getBundles()[0].filePath;\n      assert(filePath.endsWith('.cjs'));\n      let output = await outputFS.readFile(filePath, 'utf8');\n      assert(!output.includes('import '));\n      assert(output.includes('require('));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile workers to statically analyzable URL expressions","suites":["output formats","esmodule"],"updatePoint":{"line":682,"column":71,"index":33088},"line":682,"code":"    it('should compile workers to statically analyzable URL expressions', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/workers-module/index.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          outputFormat: 'esmodule',\n          shouldScopeHoist: true,\n          shouldOptimize: false,\n          isLibrary: true\n        }\n      });\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      let workerBundle = b.getBundles().find(b => b.name.startsWith('dedicated-worker'));\n      let sharedWorkerBundle = b.getBundles().find(b => b.name.startsWith('shared-worker'));\n      assert(contents.includes(`new Worker(new URL(\"${path.basename(workerBundle.filePath)}\", import.meta.url)`));\n      assert(contents.includes(`new SharedWorker(new URL(\"${path.basename(sharedWorkerBundle.filePath)}\", import.meta.url)`));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile url: pipeline dependencies to statically analyzable URL expressions for libraries","suites":["output formats","esmodule"],"updatePoint":{"line":698,"column":104,"index":34030},"line":698,"code":"    it('should compile url: pipeline dependencies to statically analyzable URL expressions for libraries', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/worklet/pipeline.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          outputFormat: 'esmodule',\n          shouldScopeHoist: true,\n          shouldOptimize: false,\n          isLibrary: true\n        }\n      });\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes(`new URL(\"${path.basename(b.getBundles()[1].filePath)}\", import.meta.url)`));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should URL dependencies to statically analyzable URL expressions for libraries","suites":["output formats","esmodule"],"updatePoint":{"line":711,"column":86,"index":34634},"line":711,"code":"    it('should URL dependencies to statically analyzable URL expressions for libraries', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/worklet/url.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          outputFormat: 'esmodule',\n          shouldScopeHoist: true,\n          shouldOptimize: false,\n          isLibrary: true\n        }\n      });\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes(`new URL(\"${path.basename(b.getBundles()[1].filePath)}\", import.meta.url)`));\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support generating ESM from universal module wrappers","suites":["output formats","esmodule"],"updatePoint":{"line":725,"column":66,"index":35219},"line":725,"code":"  it('should support generating ESM from universal module wrappers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/formats/commonjs-esm/universal-library.js'));\n    let ns = await run(b);\n    assert.deepEqual({\n      ...ns\n    }, {\n      default: {\n        a: 2\n      }\n    });\n  });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"doesn't overwrite used global variables","suites":["output formats","esmodule"],"updatePoint":{"line":736,"column":45,"index":35516},"line":736,"code":"  it(\"doesn't overwrite used global variables\", async function () {\n    let b = await bundle(path.join(__dirname, '/integration/formats/conflict-global/index.js'));\n    let cjs = b.getBundles().find(b => b.type === 'js' && b.env.outputFormat === 'commonjs');\n    let calls = [];\n    assert.deepEqual(await runBundle(b, cjs, {\n      foo(v) {\n        calls.push(v);\n      }\n    }), {\n      Map: 2\n    });\n    assert.deepEqual(calls, [[['a', 10]]]);\n    calls = [];\n    assert.deepEqual(await runBundle(b, cjs, {\n      foo(v) {\n        calls.push(v);\n      }\n    }), {\n      Map: 2\n    });\n    assert.deepEqual(calls, [[['a', 10]]]);\n  });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support split bundles between main script and workers","suites":["output formats","global"],"line":759,"code":"    it.skip('should support split bundles between main script and workers', async function () {","file":"output-formats.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support async split bundles for workers","suites":["output formats","global"],"updatePoint":{"line":798,"column":54,"index":37346},"line":798,"code":"    it('should support async split bundles for workers', async function () {\n      await bundle(path.join(__dirname, '/integration/formats/global-split-worker-async/index.html'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldOptimize: false\n        }\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw with external modules","suites":["output formats","global"],"updatePoint":{"line":806,"column":42,"index":37635},"line":806,"code":"    it('should throw with external modules', async function () {\n      let message = 'External modules are not supported when building for browser';\n      let source = path.join(__dirname, 'integration/formats/global-external/index.js');\n      await assert.rejects(() => bundle(source), {\n        name: 'BuildError',\n        message,\n        diagnostics: [{\n          message,\n          origin: '@parcel/packager-js',\n          codeFrames: [{\n            filePath: source,\n            codeHighlights: [{\n              start: {\n                line: 1,\n                column: 21\n              },\n              end: {\n                line: 1,\n                column: 28\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"output-formats.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can be required at an entry script and transform following requires","suites":["@parcel/register"],"updatePoint":{"line":7,"column":73,"index":214},"line":7,"code":"  it('can be required at an entry script and transform following requires', () => {\n    assert.equal(execSync(`node ${path.join(__dirname, 'integration', 'parcel-register', 'entry.js')}`), '123');\n  });","file":"parcel-register.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"can transform with --r and --require","suites":["@parcel/register"],"updatePoint":{"line":10,"column":42,"index":386},"line":10,"code":"  it('can transform with --r and --require', () => {\n    assert.equal(execSync(`node -r @parcel/register ${path.join(__dirname, 'integration', 'parcel-register', 'index.js')}`), '123');\n  });","file":"parcel-register.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"enables Parcel's resolver in node","suites":["@parcel/register"],"updatePoint":{"line":13,"column":39,"index":575},"line":13,"code":"  it(\"enables Parcel's resolver in node\", () => {\n    let [foo, resolved] = execSync(`node -r @parcel/register ${path.join(__dirname, 'integration', 'parcel-register', 'resolver.js')}`, {\n      cwd: path.join(__dirname, 'integration', 'parcel-register')\n    }).toString().split('\\n');\n    assert.equal(foo, 'foo');\n    assert.equal(resolved, path.join(__dirname, 'integration', 'parcel-register', 'foo.js'));\n  });","file":"parcel-register.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"can be disposed of, which reverts resolving","suites":["@parcel/register"],"updatePoint":{"line":20,"column":49,"index":1000},"line":20,"code":"  it('can be disposed of, which reverts resolving', () => {\n    try {\n      execSync(`node ${path.join(__dirname, 'integration', 'parcel-register', 'dispose-resolve.js')}`, {\n        cwd: path.join(__dirname, 'integration', 'parcel-register'),\n        stdio: 'pipe'\n      }).toString().split('\\n');\n    } catch (e) {\n      assert.equal(e.stdout.toString().trim(), path.join(__dirname, 'integration', 'parcel-register', 'foo.js'));\n      assert(e.stderr.includes(\"Error: Cannot find module '~foo.js'\"));\n      return;\n    }\n\n    // $FlowFixMe\n    assert.fail();\n  });","file":"parcel-register.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"can be disposed of, which reverts transforming","suites":["@parcel/register"],"updatePoint":{"line":35,"column":52,"index":1570},"line":35,"code":"  it('can be disposed of, which reverts transforming', () => {\n    try {\n      execSync(`node ${path.join(__dirname, 'integration', 'parcel-register', 'dispose-transform.js')}`, {\n        cwd: path.join(__dirname, 'integration', 'parcel-register'),\n        stdio: 'pipe'\n      }).toString().split('\\n');\n    } catch (e) {\n      assert.equal(e.stdout.toString().trim(), '123');\n      assert(e.stderr.includes('SyntaxError: Unexpected identifier'));\n      return;\n    }\n\n    // $FlowFixMe\n    assert.fail();\n  });","file":"parcel-register.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support case-insensitive file extension","suites":["parser"],"updatePoint":{"line":5,"column":52,"index":223},"line":5,"code":"  it('should support case-insensitive file extension', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/parser-case-insensitive-ext/index.html'));\n    await assertBundleTree(b, {\n      name: 'index.html',\n      assets: ['index.html'],\n      childBundles: [{\n        type: 'svg',\n        assets: ['icons.SVG'],\n        childBundles: []\n      }, {\n        type: 'css',\n        assets: ['index.cSs'],\n        childBundles: [{\n          type: 'map'\n        }]\n      }, {\n        type: 'html',\n        assets: ['other.HTM'],\n        childBundles: [{\n          type: 'js',\n          assets: ['index.js'],\n          childBundles: [{\n            type: 'map'\n          }]\n        }]\n      }]\n    });\n    let files = await fs.readdir(path.join(__dirname, '/dist'));\n    let html = await fs.readFile(path.join(__dirname, '/dist/index.html'));\n    for (let file of files) {\n      let ext = file.match(/\\.([0-9a-z]+)(?:[?#]|$)/i)[0];\n      if (file !== 'index.html' && ext !== '.map') {\n        assert(html.includes(file));\n      }\n    }\n  });","file":"parser.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"continue transformer pipeline on type change that doesn't change the pipeline","suites":["plugin"],"updatePoint":{"line":9,"column":83,"index":377},"line":9,"code":"  it(\"continue transformer pipeline on type change that doesn't change the pipeline\", async function () {\n    await bundle(path.join(__dirname, '/integration/pipeline-type-change/index.ini'));\n    let output = await fs.readFile(path.join(distDir, 'index.txt'), 'utf8');\n    assert.equal(output, `INPUT\nparcel-transformer-a\nparcel-transformer-b`);\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should allow optimizer plugins to change the output file type","suites":["plugin"],"updatePoint":{"line":16,"column":67,"index":714},"line":16,"code":"  it('should allow optimizer plugins to change the output file type', async function () {\n    await bundle(path.join(__dirname, '/integration/optimizer-changing-type/index.js'));\n    assert.deepEqual(fs.readdirSync(distDir), ['index.test']);\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should allow resolver plugins to disable deferring","suites":["plugin"],"updatePoint":{"line":20,"column":56,"index":951},"line":20,"code":"  it('should allow resolver plugins to disable deferring', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolver-canDefer/index.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.js', 'index.js', 'a.js', 'b.js']\n    }]);\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should allow resolvers to return changes for dependency.meta","suites":["plugin"],"updatePoint":{"line":29,"column":66,"index":1277},"line":29,"code":"  it('should allow resolvers to return changes for dependency.meta', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolver-dependency-meta/a.js'), {\n      shouldDisableCache: false,\n      shouldContentHash: false,\n      inputFS: overlayFS\n    });\n    let calls = [];\n    await run(b, {\n      sideEffect(v) {\n        calls.push(v);\n      }\n    });\n    assert.deepEqual(calls, [1234]);\n    await overlayFS.writeFile(path.join(__dirname, '/integration/resolver-dependency-meta/a.js'), (await overlayFS.readFile(path.join(__dirname, '/integration/resolver-dependency-meta/a.js'), 'utf8')) + '\\n// abc');\n    b = await bundle(path.join(__dirname, '/integration/resolver-dependency-meta/a.js'), {\n      shouldDisableCache: false,\n      shouldContentHash: false,\n      inputFS: overlayFS\n    });\n    calls = [];\n    await run(b, {\n      sideEffect(v) {\n        calls.push(v);\n      }\n    });\n    assert.deepEqual(calls, [1234]);\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"invalidate the cache based on loadBundleConfig in a packager","suites":["plugin"],"updatePoint":{"line":56,"column":66,"index":2240},"line":56,"code":"  it('invalidate the cache based on loadBundleConfig in a packager', async function () {\n    let fixture = path.join(__dirname, '/integration/packager-loadBundleConfig');\n    let entry = path.join(fixture, 'index.html');\n    let b = await bundler(entry, {\n      inputFS: overlayFS,\n      shouldDisableCache: false\n    });\n    let subscription = await b.watch();\n    try {\n      let bundleEvent = await getNextBuild(b);\n      invariant(bundleEvent.type === 'buildSuccess');\n      assert.strictEqual(await overlayFS.readFile(nullthrows(bundleEvent.bundleGraph.getBundles().find(b => b.getMainEntry()?.filePath.endsWith('a.txt'))).filePath, 'utf8'), `Bundles: a.txt. Contents: Hello from a\\n`);\n      await overlayFS.copyFile(path.join(fixture, 'index.2.html'), entry);\n      bundleEvent = await getNextBuild(b);\n      invariant(bundleEvent.type === 'buildSuccess');\n      assert.strictEqual(await overlayFS.readFile(nullthrows(bundleEvent.bundleGraph.getBundles().find(b => b.getMainEntry()?.filePath.endsWith('a.txt'))).filePath, 'utf8'), `Bundles: a.txt,b.txt. Contents: Hello from a\\n`);\n      assert.strictEqual(await overlayFS.readFile(nullthrows(bundleEvent.bundleGraph.getBundles().find(b => b.getMainEntry()?.filePath.endsWith('b.txt'))).filePath, 'utf8'), `Bundles: a.txt,b.txt. Contents: Hello from b\\n`);\n    } finally {\n      await subscription.unsubscribe();\n    }\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"invalidate the cache based on loadConfig in a packager","suites":["plugin"],"updatePoint":{"line":77,"column":60,"index":3616},"line":77,"code":"  it('invalidate the cache based on loadConfig in a packager', async function () {\n    let fixture = path.join(__dirname, '/integration/packager-loadConfig');\n    let entry = path.join(fixture, 'index.txt');\n    let config = path.join(fixture, 'foo.config.json');\n    let b = await bundle(entry, {\n      inputFS: overlayFS,\n      shouldDisableCache: false\n    });\n    assert.strictEqual(await overlayFS.readFile(b.getBundles()[0].filePath, 'utf8'), '1234');\n    await overlayFS.writeFile(config, JSON.stringify({\n      contents: 'xyz'\n    }));\n    b = await bundle(entry, {\n      inputFS: overlayFS,\n      shouldDisableCache: false\n    });\n    assert.strictEqual(await overlayFS.readFile(b.getBundles()[0].filePath, 'utf8'), 'xyz');\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"merges symbol information when applying runtime assets","suites":["plugin"],"updatePoint":{"line":95,"column":60,"index":4355},"line":95,"code":"  it('merges symbol information when applying runtime assets', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/runtime-symbol-merging/entry.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assert(!findAsset(b, 'index.js'));\n    assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'a.js')))), new Set(['a']));\n    assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'b.js')))), new Set(['b']));\n    let calls = [];\n    await run(b, {\n      call(v) {\n        calls.push(v);\n      }\n    });\n    assert.deepStrictEqual(calls, [789, 123]);\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"properly excludes assets that are excluded and deferred by both app code and runtimes","suites":["plugin"],"updatePoint":{"line":112,"column":91,"index":5039},"line":112,"code":"  it('properly excludes assets that are excluded and deferred by both app code and runtimes', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/runtime-deferred-excluded/index.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let calls = [];\n    let output = await run(b, {\n      f(v) {\n        calls.push(v);\n      }\n    });\n    assert.deepStrictEqual(\n    // `output` is from the vm and so is not deepStrictEqual\n    [...output], ['index', 'used']);\n    assert.deepStrictEqual(calls, ['used']);\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"handles multiple assets returned by a transformer","suites":["plugin"],"updatePoint":{"line":129,"column":55,"index":5575},"line":129,"code":"  it('handles multiple assets returned by a transformer', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/multi-asset-transformer/index.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    assert.equal(await run(b), 2);\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should allow resolvers to invalidateOnEnvChange","suites":["plugin"],"updatePoint":{"line":137,"column":53,"index":5867},"line":137,"code":"  it('should allow resolvers to invalidateOnEnvChange', async () => {\n    async function assertAsset(replacedCode) {\n      let b = await bundle(path.join(__dirname, '/integration/resolver-can-invalidateonenvchange/index.js'), {\n        shouldDisableCache: false,\n        inputFS: overlayFS,\n        env: {\n          replacedCode\n        }\n      });\n      let code = await b.getBundles()[0].getEntryAssets()[0].getCode();\n      assert(code.indexOf(replacedCode) !== -1);\n    }\n    await assertAsset('const replaced = 1;');\n    await assertAsset('const replaced = 2;');\n  });","file":"plugin.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should defer to the pnp resolution when needed","suites":["pnp"],"updatePoint":{"line":6,"column":52,"index":231},"line":6,"code":"  it('should defer to the pnp resolution when needed', async function () {\n    let dir = path.join(__dirname, 'integration/pnp-require');\n    let origPnpVersion = process.versions.pnp;\n    process.versions.pnp = 42;\n    let origModuleResolveFilename = Module._resolveFilename;\n    Module.findPnpApi = () => require(path.join(dir, '.pnp.js'));\n    Module._resolveFilename = (name, ...args) => name === 'pnpapi' ? path.join(dir, '.pnp.js') : origModuleResolveFilename(name, ...args);\n    try {\n      let b = await bundle(path.join(dir, 'index.js'));\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js', 'local.js', 'index.js']\n      }]);\n      let output = await run(b);\n      assert.equal(output(), 3);\n    } finally {\n      process.versions.pnp = origPnpVersion;\n      Module._resolveFilename = origModuleResolveFilename;\n    }\n  });","file":"pnp.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing Node builtin modules from npm when requested","suites":["pnp"],"updatePoint":{"line":26,"column":75,"index":1116},"line":26,"code":"  it('should support importing Node builtin modules from npm when requested', async function () {\n    let dir = path.join(__dirname, 'integration/pnp-builtin');\n    let origPnpVersion = process.versions.pnp;\n    process.versions.pnp = 42;\n    let origModuleResolveFilename = Module._resolveFilename;\n    Module.findPnpApi = () => require(path.join(dir, '.pnp.js'));\n    Module._resolveFilename = (name, ...args) => name === 'pnpapi' ? path.join(dir, '.pnp.js') : origModuleResolveFilename(name, ...args);\n    try {\n      let b = await bundle(path.join(dir, 'index.js'));\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.js', 'local.js', 'index.js']\n      }]);\n      let output = await run(b);\n      assert.equal(output(), 3);\n    } finally {\n      process.versions.pnp = origPnpVersion;\n      Module._resolveFilename = origModuleResolveFilename;\n    }\n  });","file":"pnp.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build successfully with only postcss-modules config","suites":["postcss"],"updatePoint":{"line":6,"column":64,"index":363},"line":6,"code":"  it('should build successfully with only postcss-modules config', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-modules-config/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['foo.css', 'foo.js', 'index.css', 'index.js']\n    }, {\n      name: 'index.css',\n      assets: ['foo.css', 'index.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let value = output();\n    assert(/foo_[0-9a-z]/.test(value));\n    let cssClass = value.match(/(foo_[0-9a-z])/)[1];\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes(`.${cssClass}`));\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should build successfully with only postcss-modules config in package.json","suites":["postcss"],"updatePoint":{"line":23,"column":80,"index":1070},"line":23,"code":"  it('should build successfully with only postcss-modules config in package.json', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-modules-config-package/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['foo.css', 'foo.js', 'index.css', 'index.js']\n    }, {\n      name: 'index.css',\n      assets: ['foo.css', 'index.css']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let value = output();\n    assert(/foo_[0-9a-z]/.test(value));\n    let cssClass = value.match(/(foo_[0-9a-z])/)[1];\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes(`.${cssClass}`));\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming with postcss twice with the same result","suites":["postcss"],"updatePoint":{"line":40,"column":73,"index":1778},"line":40,"code":"  it('should support transforming with postcss twice with the same result', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-plugins/index.js'));\n    let c = await bundle(path.join(__dirname, '/integration/postcss-plugins/index2.js'));\n    let [run1, run2] = await Promise.all([run(b), run(c)]);\n    assert.equal(run1(), run2());\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming declarations with missing source","suites":["postcss"],"updatePoint":{"line":46,"column":66,"index":2140},"line":46,"code":"  it('should support transforming declarations with missing source', async () => {\n    await bundle(path.join(__dirname, '/integration/postcss-plugins-decl/index.css'));\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('url(\"data:image/gif;base64,quotes\")'));\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should automatically install postcss plugins if needed","suites":["postcss"],"updatePoint":{"line":51,"column":60,"index":2455},"line":51,"code":"  it('should automatically install postcss plugins if needed', async () => {\n    let inputDir = path.join(__dirname, '/input');\n    await outputFS.rimraf(inputDir);\n    await ncp(path.join(__dirname, '/integration/postcss-autoinstall/npm'), inputDir);\n    let packageInstaller = new MockPackageInstaller();\n    packageInstaller.register('postcss-test', inputFS, path.join(__dirname, '/integration/postcss-autoinstall/postcss-test'));\n\n    // The package manager uses an overlay filesystem, which performs writes to\n    // an in-memory fs and reads first from memory, then falling back to the real fs.\n    let packageManager = new NodePackageManager(overlayFS, inputDir, packageInstaller);\n    let distDir = path.join(outputFS.cwd(), 'dist');\n    await bundle(path.join(__dirname, '/input/index.css'), {\n      inputFS: overlayFS,\n      packageManager,\n      shouldAutoInstall: true,\n      defaultTargetOptions: {\n        distDir\n      }\n    });\n\n    // cssnext was installed\n    let pkg = JSON.parse(await outputFS.readFile(path.join(__dirname, '/input/package.json'), 'utf8'));\n    assert(pkg.devDependencies['postcss-test']);\n\n    // postcss-test is applied\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('background: green'));\n\n    // Increase the timeout for just this test. It takes a while with npm.\n    // This method works with arrow functions, and doesn't seem to be documented\n    // on the main Mocha docs.\n    // https://stackoverflow.com/questions/15971167/how-to-increase-timeout-for-a-single-test-case-in-mocha\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support using postcss for importing","suites":["postcss"],"updatePoint":{"line":85,"column":48,"index":4032},"line":85,"code":"  it('should support using postcss for importing', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-import/style.css'));\n    assertBundles(b, [{\n      name: 'style.css',\n      assets: ['style.css']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'style.css'), 'utf8');\n    assert.equal(css.split('red').length - 1, 1);\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support using a postcss config in package.json","suites":["postcss"],"updatePoint":{"line":94,"column":59,"index":4425},"line":94,"code":"  it('should support using a postcss config in package.json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-config-package/style.css'));\n    assertBundles(b, [{\n      name: 'style.css',\n      assets: ['style.css']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'style.css'), 'utf8');\n    assert(/background-color:\\s*red/.test(css));\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should support postcss.config.js config file with PostCSS 7 plugin","suites":["postcss"],"updatePoint":{"line":103,"column":72,"index":4838},"line":103,"code":"  it('Should support postcss.config.js config file with PostCSS 7 plugin', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-js-config-7/style.css'));\n    assertBundles(b, [{\n      name: 'style.css',\n      assets: ['style.css']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'style.css'), 'utf8');\n    assert(css.includes('background-color: red;'));\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should support postcss.config.js config file with PostCSS 8 plugin","suites":["postcss"],"updatePoint":{"line":112,"column":72,"index":5251},"line":112,"code":"  it('Should support postcss.config.js config file with PostCSS 8 plugin', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/postcss-js-config-8/style.css'));\n    assertBundles(b, [{\n      name: 'style.css',\n      assets: ['style.css']\n    }]);\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support dir-dependency messages from plugins","suites":["postcss"],"updatePoint":{"line":119,"column":57,"index":5517},"line":119,"code":"  it('should support dir-dependency messages from plugins', async function () {\n    let inputDir = path.join(__dirname, '/input', Math.random().toString(36).slice(2));\n    await inputFS.mkdirp(inputDir);\n    await inputFS.ncp(path.join(__dirname, '/integration/postcss-dir-dependency'), inputDir);\n    let b = await bundler(path.join(inputDir, 'index.css'));\n    let subscription = await b.watch();\n    let buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    let contents = await outputFS.readFile(buildEvent.bundleGraph.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('background: linear-gradient(green, pink), linear-gradient(red, orange)'));\n\n    // update\n    await inputFS.writeFile(path.join(inputDir, 'backgrounds', 'green.txt'), 'linear-gradient(purple, orange)');\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    contents = await outputFS.readFile(buildEvent.bundleGraph.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('background: linear-gradient(purple, orange), linear-gradient(red, orange)'));\n\n    // create\n    await inputFS.writeFile(path.join(inputDir, 'backgrounds', 'orange.txt'), 'linear-gradient(orange, purple)');\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    contents = await outputFS.readFile(buildEvent.bundleGraph.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('background: linear-gradient(purple, orange), linear-gradient(orange, purple), linear-gradient(red, orange)'));\n\n    // delete\n    await inputFS.unlink(path.join(inputDir, 'backgrounds', 'red.txt'));\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    contents = await outputFS.readFile(buildEvent.bundleGraph.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('background: linear-gradient(purple, orange), linear-gradient(orange, purple)'));\n    await subscription.unsubscribe();\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw an error with code frame when .postcssrc is invalid","suites":["postcss"],"updatePoint":{"line":152,"column":70,"index":7543},"line":152,"code":"  it('should throw an error with code frame when .postcssrc is invalid', async function () {\n    let configFilePath = path.join(__dirname, '/integration/postcss-modules-config-invalid/.postcssrc');\n    let code = await inputFS.readFile(configFilePath, 'utf8');\n    await assert.rejects(() => bundle(path.join(__dirname, '/integration/postcss-modules-config-invalid/src/index.css')), {\n      name: 'BuildError',\n      diagnostics: [{\n        codeFrames: [{\n          code,\n          filePath: configFilePath,\n          language: 'json5',\n          codeHighlights: [{\n            end: {\n              column: 5,\n              line: 5\n            },\n            start: {\n              column: 5,\n              line: 5\n            },\n            message: `JSON5: invalid character '\\\\\"' at 5:5`\n          }]\n        }],\n        message: 'Failed to parse .postcssrc',\n        origin: '@parcel/utils'\n      }]\n    });\n  });","file":"postcss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming HTML with posthtml","suites":["posthtml"],"updatePoint":{"line":9,"column":52,"index":416},"line":9,"code":"  it('should support transforming HTML with posthtml', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/posthtml/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    assert(html.includes('<h1>Other page</h1>'));\n  });","file":"posthtml.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should find assets inside posthtml","suites":["posthtml"],"updatePoint":{"line":18,"column":40,"index":781},"line":18,"code":"  it('should find assets inside posthtml', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/posthtml-assets/index.html'));\n    assertBundles(b, [{\n      type: 'html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }]);\n  });","file":"posthtml.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should be able to process an html file with plugins without any params for plugin","suites":["posthtml"],"updatePoint":{"line":28,"column":87,"index":1124},"line":28,"code":"  it('Should be able to process an html file with plugins without any params for plugin', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/posthtml-plugins/index.html'));\n    assertBundles(b, [{\n      type: 'html',\n      assets: ['index.html']\n    }]);\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf-8');\n    assert(html.includes('&#115;&#97;&#109;&#64;&#115;&#109;&#105;&#116;&#104;&#46;&#99;&#111;&#109;'));\n    assert(!html.includes('sam@smith.com'));\n  });","file":"posthtml.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should add dependencies referenced by posthtml-include","suites":["posthtml"],"line":38,"code":"  it.skip('should add dependencies referenced by posthtml-include', async () => {","file":"posthtml.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should add dependencies referenced by plugins","suites":["posthtml"],"line":45,"code":"  it.skip('should add dependencies referenced by plugins', async () => {","file":"posthtml.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should automatically install posthtml plugins if needed","suites":["posthtml"],"updatePoint":{"line":52,"column":61,"index":2455},"line":52,"code":"  it('should automatically install posthtml plugins if needed', async () => {\n    let inputDir = path.join(__dirname, '/input');\n    await outputFS.rimraf(inputDir);\n    await ncp(path.join(__dirname, '/integration/posthtml-autoinstall'), inputDir);\n    let packageInstaller = new MockPackageInstaller();\n    packageInstaller.register('posthtml-test', inputFS, path.join(__dirname, '/integration/posthtml-autoinstall/posthtml-test'));\n\n    // The package manager uses an overlay filesystem, which performs writes to\n    // an in-memory fs and reads first from memory, then falling back to the real fs.\n    let packageManager = new NodePackageManager(overlayFS, inputDir, packageInstaller);\n    let distDir = path.join(outputFS.cwd(), 'dist');\n    await bundle(path.join(__dirname, '/input/index.html'), {\n      inputFS: overlayFS,\n      packageManager,\n      shouldAutoInstall: true,\n      defaultTargetOptions: {\n        distDir\n      }\n    });\n\n    // posthtml-test was installed\n    let pkg = JSON.parse(await outputFS.readFile(path.join(__dirname, '/input/package.json'), 'utf8'));\n    assert(pkg.devDependencies['posthtml-test']);\n\n    // posthtml-test is applied\n    let html = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    assert(html.includes('<span id=\"test\">Test</span>'));\n  });","file":"posthtml.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle proxy table written in .proxyrc","suites":["proxy"],"updatePoint":{"line":59,"column":51,"index":1445},"line":59,"code":"  it('should handle proxy table written in .proxyrc', async function () {\n    let dir = path.join(__dirname, 'integration/proxyrc');\n    inputFS.chdir(dir);\n    let port = await getPort();\n    let b = bundler(path.join(dir, 'index.js'), {\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    server = apiServer();\n    let data = await get('/index.js', port);\n    assert.notEqual(data, 'Request URL: /index.js');\n    data = await get('/api/get', port);\n    assert.equal(data, 'Request URL: /api/get');\n  });","file":"proxy.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle proxy table written in .proxyrc.json","suites":["proxy"],"updatePoint":{"line":79,"column":56,"index":2091},"line":79,"code":"  it('should handle proxy table written in .proxyrc.json', async function () {\n    let dir = path.join(__dirname, 'integration/proxyrc-json');\n    inputFS.chdir(dir);\n    let port = await getPort();\n    let b = bundler(path.join(dir, 'index.js'), {\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    server = apiServer();\n    let data = await get('/index.js', port);\n    assert.notEqual(data, 'Request URL: /index.js');\n    data = await get('/api/get', port);\n    assert.equal(data, 'Request URL: /api/get');\n  });","file":"proxy.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle proxy table written in .proxyrc.js","suites":["proxy"],"updatePoint":{"line":99,"column":54,"index":2740},"line":99,"code":"  it('should handle proxy table written in .proxyrc.js', async function () {\n    let dir = path.join(__dirname, 'integration/proxyrc-js');\n    inputFS.chdir(dir);\n    let port = await getPort();\n    let b = bundler(path.join(dir, 'index.js'), {\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    server = apiServer();\n    let data = await get('/index.js', port);\n    assert.notEqual(data, 'Request URL: /index.js');\n    data = await get('/api/get', port);\n    assert.equal(data, 'Request URL: /get');\n  });","file":"proxy.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling HTML","suites":["pug"],"updatePoint":{"line":5,"column":34,"index":198},"line":5,"code":"  it('should support bundling HTML', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/pug/index.pug'));\n    assertBundles(b, [{\n      type: 'html',\n      name: 'index.html',\n      assets: ['index.pug']\n    }, {\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'svg',\n      assets: ['icons.svg']\n    }, {\n      type: 'css',\n      assets: ['index.css']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }]);\n    const files = await outputFS.readdir(distDir);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    for (let file of files) {\n      const ext = file.match(/\\.([0-9a-z]+)(?:[?#]|$)/i)[0];\n      if (file !== 'index.html' && ext !== '.map') {\n        assert(html.includes(file));\n      }\n    }\n  });","file":"pug.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support include and extends files, connect files","suites":["pug"],"updatePoint":{"line":33,"column":61,"index":1021},"line":33,"code":"  it('should support include and extends files, connect files', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/pug-include-extends/index.pug'));\n    assertBundles(b, [{\n      type: 'html',\n      name: 'index.html',\n      assets: ['index.pug']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    assert(html.includes('<!DOCTYPE html>'));\n    assert(html.includes(\"<h1>Yep, it's working!</h1>\"));\n    assert(html.includes('<p>And for nested.</p>'));\n  });","file":"pug.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support variables","suites":["pug"],"updatePoint":{"line":45,"column":30,"index":1516},"line":45,"code":"  it('should support variables', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/pug-var/index.pug'));\n    assertBundles(b, [{\n      type: 'html',\n      name: 'index.html',\n      assets: ['index.pug']\n    }, {\n      type: 'png',\n      assets: ['100x100.png']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    assert(/src=\"\\/?100x100.*.png\"/.test(html));\n  });","file":"pug.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support mixins","suites":["pug"],"updatePoint":{"line":58,"column":27,"index":1946},"line":58,"code":"  it('should support mixins', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/pug-mixins/index.pug'));\n    assertBundles(b, [{\n      type: 'html',\n      name: 'index.html',\n      assets: ['index.pug']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    assert(html.includes('Greetings, Parcel'));\n  });","file":"pug.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support filters","suites":["pug"],"updatePoint":{"line":68,"column":28,"index":2321},"line":68,"code":"  it('should support filters', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/pug-filters/index.pug'));\n    assertBundles(b, [{\n      type: 'html',\n      name: 'index.html',\n      assets: ['index.pug']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    assert(html.includes('FILTERED: Hello!'));\n  });","file":"pug.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support locals with config file","suites":["pug"],"updatePoint":{"line":78,"column":44,"index":2712},"line":78,"code":"  it('should support locals with config file', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/pug-locals/index.pug'));\n    assertBundles(b, [{\n      type: 'html',\n      name: 'index.html',\n      assets: ['index.pug']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    assert(html.includes(\"It's a great!\"));\n  });","file":"pug.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify HTML in production mode","suites":["pug"],"updatePoint":{"line":88,"column":43,"index":3098},"line":88,"code":"  it('should minify HTML in production mode', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/pug-minify/index.pug'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.pug']\n    }]);\n    const html = await outputFS.readFile(path.join(distDir, 'index.html'));\n    assert(html.includes('Minified'));\n  });","file":"pug.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"retains state in functional components","suites":["react-refresh","synchronous (automatic runtime)"],"updatePoint":{"line":37,"column":48,"index":1112},"line":37,"code":"      it('retains state in functional components', async function () {\n        await fs.mkdirp(testDir);\n        await fs.copyFile(path.join(testDir, 'Foo.1.js'), path.join(testDir, 'Foo.js'));\n        assert.equal((await getNextBuild(b)).type, 'buildSuccess');\n\n        // Wait for the hmr-runtime to process the event\n        await sleep(100);\n        let [, indexNum, appNum, fooText, fooNum] = root.textContent.match(/^([\\d.]+) ([\\d.]+) ([\\w]+):([\\d.]+)$/);\n        assert.equal(randoms.indexNum, indexNum);\n        assert.equal(randoms.appNum, appNum);\n        assert.equal(randoms.fooNum, fooNum);\n        assert.equal(fooText, 'OtherFunctional');\n      });","file":"react-refresh.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"retains state in functional components","suites":["react-refresh","synchronous"],"updatePoint":{"line":73,"column":48,"index":2299},"line":73,"code":"      it('retains state in functional components', async function () {\n        await fs.mkdirp(testDir);\n        await fs.copyFile(path.join(testDir, 'Foo.1.js'), path.join(testDir, 'Foo.js'));\n        assert.equal((await getNextBuild(b)).type, 'buildSuccess');\n\n        // Wait for the hmr-runtime to process the event\n        await sleep(100);\n        let [, indexNum, appNum, fooText, fooNum] = root.textContent.match(/^([\\d.]+) ([\\d.]+) ([\\w]+):([\\d.]+)$/);\n        assert.equal(randoms.indexNum, indexNum);\n        assert.equal(randoms.appNum, appNum);\n        assert.equal(randoms.fooNum, fooNum);\n        assert.equal(fooText, 'OtherFunctional');\n      });","file":"react-refresh.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports changing hooks in functional components","suites":["react-refresh","synchronous"],"updatePoint":{"line":86,"column":58,"index":2973},"line":86,"code":"      it('supports changing hooks in functional components', async function () {\n        await fs.mkdirp(testDir);\n        await fs.copyFile(path.join(testDir, 'Foo.2-hooks.js'), path.join(testDir, 'Foo.js'));\n        assert.equal((await getNextBuild(b)).type, 'buildSuccess');\n\n        // Wait for the hmr-runtime to process the event\n        await sleep(100);\n        let [, indexNum, appNum, fooText, fooNum, fooNum2] = root.textContent.match(/^([\\d.]+) ([\\d.]+) ([\\w]+):([\\d.]+):([\\d.]+)$/);\n        assert.equal(randoms.indexNum, indexNum);\n        assert.equal(randoms.appNum, appNum);\n        assert.notEqual(randoms.fooNum, fooNum);\n        assert(fooNum2);\n        assert.equal(fooText, 'Hooks');\n      });","file":"react-refresh.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"retains state in parent components when swapping function and class component","suites":["react-refresh","synchronous"],"updatePoint":{"line":100,"column":87,"index":3718},"line":100,"code":"      it('retains state in parent components when swapping function and class component', async function () {\n        await fs.mkdirp(testDir);\n        await fs.copyFile(path.join(testDir, 'Foo.3-class.js'), path.join(testDir, 'Foo.js'));\n        assert.equal((await getNextBuild(b)).type, 'buildSuccess');\n\n        // Wait for the hmr-runtime to process the event\n        await sleep(100);\n        let [, indexNum, appNum, fooText, fooNum] = root.textContent.match(/^([\\d.]+) ([\\d.]+) ([\\w]+):([\\d.]+)$/);\n        assert.equal(randoms.indexNum, indexNum);\n        assert.equal(randoms.appNum, appNum);\n        assert.notEqual(randoms.fooNum, fooNum);\n        assert.equal(fooText, 'Class');\n      });","file":"react-refresh.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"retains state in async components on change","suites":["react-refresh","lazy child component"],"updatePoint":{"line":136,"column":53,"index":4929},"line":136,"code":"      it('retains state in async components on change', async function () {\n        assert.equal(randoms.fooText, 'Async');\n        await fs.mkdirp(testDir);\n        await fs.copyFile(path.join(testDir, 'Async.1.js'), path.join(testDir, 'Async.js'));\n        assert.equal((await getNextBuild(b)).type, 'buildSuccess');\n\n        // Wait for the hmr-runtime to process the event\n        await sleep(100);\n        let [, indexNum, appNum, fooText, fooNum] = root.textContent.match(/^([\\d.]+) ([\\d.]+) ([\\w]+):([\\d.]+)$/);\n        assert.equal(randoms.indexNum, indexNum);\n        assert.equal(randoms.appNum, appNum);\n        assert.equal(randoms.fooNum, fooNum);\n        assert.equal(fooText, 'OtherAsync');\n      });","file":"react-refresh.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not error on inline scripts","suites":["react-refresh","lazy child component"],"updatePoint":{"line":157,"column":40,"index":5757},"line":157,"code":"    it('does not error on inline scripts', async () => {\n      let port = await getPort();\n      let b = await bundle(path.join(__dirname, 'integration/react-refresh-inline-script/index.html'), {\n        hmrOptions: {\n          port\n        }\n      });\n      await run(b, {}, {\n        require: false\n      });\n    });","file":"react-refresh.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not apply to library targets","suites":["react-refresh","lazy child component"],"updatePoint":{"line":168,"column":41,"index":6077},"line":168,"code":"    it('does not apply to library targets', async () => {\n      let port = await getPort();\n      let parcel = await bundler(path.join(__dirname, '/integration/react-refresh-library-target/index.js'), {\n        hmrOptions: {\n          port\n        }\n      });\n      let result = await getNextBuildSuccess(parcel);\n      let bundle = nullthrows(result.bundleGraph.getBundles().find(b => b.type === 'js'));\n\n      // Make sure react-refresh transforms were not applied.\n      let assets = [];\n      bundle.traverse(node => {\n        if (node.type === 'asset') {\n          assets.push(node.value);\n        } else if (node.type === 'dependency') {\n          assert(!node.value.specifier.startsWith('react-refresh/runtime') && !node.value.specifier.startsWith('@parcel/transformer-react-refresh-wrap'));\n        }\n      });\n      for (let asset of assets) {\n        let code = await asset.getCode();\n        assert(!code.includes('$RefreshReg$') && !code.includes('$RefreshSig$'));\n      }\n    });","file":"react-refresh.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a bundle","suites":["reason"],"updatePoint":{"line":5,"column":29,"index":172},"line":5,"code":"  it('should produce a bundle', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/reason/index.js'));\n    assert.equal(b.assets.size, 2);\n    assert.equal(b.childBundles.size, 1);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 3);\n  });","file":"reason.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support resolving tilde in monorepo packages","suites":["resolver"],"updatePoint":{"line":5,"column":57,"index":223},"line":5,"code":"  it('should support resolving tilde in monorepo packages', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-tilde-monorepo/client/src/index.js'));\n    let output = await run(b);\n    assert.strictEqual(output.default, 1234);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support node: prefix for node_modules","suites":["resolver"],"updatePoint":{"line":10,"column":50,"index":486},"line":10,"code":"  it('should support node: prefix for node_modules', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-node-prefix/src/index.js'));\n    let output = await run(b);\n    assert.strictEqual(output.default, '6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50');\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly resolve tilde in node_modules","suites":["resolver"],"updatePoint":{"line":15,"column":52,"index":803},"line":15,"code":"  it('should correctly resolve tilde in node_modules', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-tilde-nodemodules/index.js'));\n    let output = await run(b);\n    assert.strictEqual(output.default, 1234);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should fall back to index.js if the resolved `main` file does not exist","suites":["resolver"],"updatePoint":{"line":20,"column":77,"index":1085},"line":20,"code":"  it('should fall back to index.js if the resolved `main` file does not exist', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-index-fallback/incorrect-entry.js'));\n    let output = await run(b);\n    assert.strictEqual(output.default, 42);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should fall back to index.js if there is no `main` field at all","suites":["resolver"],"updatePoint":{"line":25,"column":69,"index":1364},"line":25,"code":"  it('should fall back to index.js if there is no `main` field at all', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/resolve-index-fallback/no-entry.js'));\n    let output = await run(b);\n    assert.strictEqual(output.default, 42);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should print a diagnostic when a configured target field will overwrite an entry","suites":["resolver"],"updatePoint":{"line":30,"column":86,"index":1653},"line":30,"code":"  it('should print a diagnostic when a configured target field will overwrite an entry', async function () {\n    let errorThrows = 0;\n    const overwriteDirs = ['browser', 'app', 'main', 'module'];\n    for (const currDir of overwriteDirs) {\n      try {\n        await bundle(path.join(__dirname, `integration/target-overwrite-source/${currDir}`));\n      } catch (e) {\n        errorThrows++;\n        let pkg = JSON.parse(await overlayFS.readFile(path.join(__dirname, `integration/target-overwrite-source/${currDir}/package.json`)));\n        assert.deepEqual(e.diagnostics[0].message, `Target \"${currDir}\" is configured to overwrite entry \"${path.normalize(`test/integration/target-overwrite-source/${currDir}/${pkg.source}`)}\".`);\n      }\n    }\n    assert.deepEqual(errorThrows, overwriteDirs.length);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw an error on Webpack loader imports","suites":["resolver"],"updatePoint":{"line":44,"column":53,"index":2426},"line":44,"code":"  it('should throw an error on Webpack loader imports', async function () {\n    let didThrow = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/webpack-import-syntax-error/index.js'));\n    } catch (e) {\n      didThrow = true;\n      assert.equal(e.diagnostics[1].message, `The import path: node-loader!./index.js is using webpack specific loader import syntax, which isn't supported by Parcel.`);\n    }\n    assert(didThrow);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw an error with codeframe on invalid js import","suites":["resolver"],"updatePoint":{"line":54,"column":63,"index":2888},"line":54,"code":"  it('should throw an error with codeframe on invalid js import', async function () {\n    let didThrow = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/js-invalid-import/index.js'));\n    } catch (e) {\n      didThrow = true;\n      assert(e.diagnostics[0].message.startsWith(`Failed to resolve './doesnotexisstt' from `));\n      assert.deepEqual(e.diagnostics[0].codeFrames[0].codeHighlights[0], {\n        start: {\n          line: 1,\n          column: 8\n        },\n        end: {\n          line: 1,\n          column: 25\n        }\n      });\n    }\n    assert(didThrow);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw an error with codeframe on invalid css import","suites":["resolver"],"updatePoint":{"line":74,"column":64,"index":3485},"line":74,"code":"  it('should throw an error with codeframe on invalid css import', async function () {\n    let didThrow = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/css-invalid-import/index.css'));\n    } catch (e) {\n      didThrow = true;\n      assert(e.diagnostics[0].message.startsWith(`Failed to resolve './thisdoesnotexist.css' from `));\n      assert.deepEqual(e.diagnostics[0].codeFrames[0].codeHighlights[0], {\n        start: {\n          line: 1,\n          column: 9\n        },\n        end: {\n          line: 1,\n          column: 32\n        }\n      });\n    }\n    assert(didThrow);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should return codeframe with hints when package.json is invalid","suites":["resolver"],"updatePoint":{"line":94,"column":69,"index":4095},"line":94,"code":"  it('Should return codeframe with hints when package.json is invalid', async function () {\n    let didThrow = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/resolver-invalid-pkgjson/index.js'));\n    } catch (e) {\n      didThrow = true;\n      assert.equal(e.diagnostics[1].message, `Could not load './entryx.js' from module 'invalid-module' found in package.json#main`);\n      assert.deepEqual(e.diagnostics[1].codeFrames[0].codeHighlights[0], {\n        end: {\n          column: 25,\n          line: 4\n        },\n        message: \"'./entryx.js' does not exist, did you mean './entry.js'?'\",\n        start: {\n          column: 13,\n          line: 4\n        }\n      });\n    }\n    assert(didThrow);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should suggest alternative filenames for relative imports","suites":["resolver"],"updatePoint":{"line":115,"column":63,"index":4814},"line":115,"code":"  it('Should suggest alternative filenames for relative imports', async function () {\n    let threw = 0;\n    try {\n      await bundle(path.join(__dirname, '/integration/resolver-alternative-relative/a.js'));\n    } catch (e) {\n      threw++;\n      assert.equal(e.diagnostics[1].message, `Cannot load file './test/teste.js' in './integration/resolver-alternative-relative'.`);\n      assert.equal(e.diagnostics[1].hints[0], `Did you mean '__./test/test.js__'?`);\n    }\n    try {\n      await bundle(path.join(__dirname, '/integration/resolver-alternative-relative/b.js'));\n    } catch (e) {\n      threw++;\n      assert.equal(e.diagnostics[1].message, `Cannot load file './aa.js' in './integration/resolver-alternative-relative'.`);\n      assert.equal(e.diagnostics[1].hints[0], `Did you mean '__./a.js__'?`);\n    }\n    try {\n      await bundle(path.join(__dirname, '/integration/resolver-alternative-relative/test/test.js'));\n    } catch (e) {\n      threw++;\n      assert.equal(e.diagnostics[1].message, `Cannot load file '../../a.js' in './integration/resolver-alternative-relative/test'.`);\n      assert.equal(e.diagnostics[1].hints[0], `Did you mean '__../a.js__'?`);\n    }\n    assert.equal(threw, 3);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should suggest alternative modules for module imports","suites":["resolver"],"updatePoint":{"line":140,"column":59,"index":6017},"line":140,"code":"  it('Should suggest alternative modules for module imports', async function () {\n    let threw = false;\n    try {\n      await bundle(path.join(__dirname, '/integration/resolver-alternative-module/index.js'));\n    } catch (e) {\n      threw = true;\n      assert.equal(e.diagnostics[1].message, `Cannot find module @baebal/core`);\n      assert.equal(e.diagnostics[1].hints[0], `Did you mean '__@babel/core__'?`);\n    }\n    assert(threw);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve packages to packages through the alias field","suites":["resolver"],"updatePoint":{"line":151,"column":65,"index":6465},"line":151,"code":"  it('should resolve packages to packages through the alias field', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/alias/package-to-package.js'));\n    let output = await run(b);\n    assert.strictEqual(output.default, 3);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve packages to local files through the alias field","suites":["resolver"],"updatePoint":{"line":156,"column":68,"index":6728},"line":156,"code":"  it('should resolve packages to local files through the alias field', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/alias/package-to-local.js'));\n    let output = await run(b);\n    assert.strictEqual(output.default, 'bar');\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should exclude local files using the alias field","suites":["resolver"],"updatePoint":{"line":161,"column":54,"index":6979},"line":161,"code":"  it('should exclude local files using the alias field', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/alias/exclude-local.js'));\n    let output = await run(b);\n    assert.deepEqual(output.default, {});\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should exclude packages using the alias field","suites":["resolver"],"updatePoint":{"line":166,"column":51,"index":7219},"line":166,"code":"  it('should exclude packages using the alias field', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/alias/exclude-package.js'));\n    let output = await run(b);\n    assert.deepEqual(output.default, {});\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support symlinked node_modules structure","suites":["resolver"],"updatePoint":{"line":171,"column":53,"index":7463},"line":171,"code":"  it('should support symlinked node_modules structure', async function () {\n    const rootDir = path.join(__dirname, 'integration/resolve-symlinked-node_modules-structure');\n    await overlayFS.mkdirp(rootDir);\n    await ncp(rootDir, rootDir);\n    await outputFS.symlink(path.join(rootDir, 'node_modules/.origin/library@1.0.0/node_modules/library'), path.join(rootDir, 'node_modules/library'));\n    await outputFS.symlink(path.join(rootDir, 'node_modules/.origin/library-dep@1.0.0/node_modules/library-dep'), path.join(rootDir, 'node_modules/.origin/library@1.0.0/node_modules/library-dep'));\n    let b = await bundle(path.join(__dirname, '/integration/resolve-symlinked-node_modules-structure/index.js'), {\n      inputFS: overlayFS,\n      outputFS\n    });\n    let output = await run(b);\n    assert.strictEqual(output.default, 42);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support symlinked monorepos structure","suites":["resolver"],"updatePoint":{"line":184,"column":50,"index":8298},"line":184,"code":"  it('should support symlinked monorepos structure', async function () {\n    const rootDir = path.join(__dirname, 'integration/resolve-symlinked-monorepos');\n    await overlayFS.mkdirp(rootDir);\n    await ncp(rootDir, rootDir);\n    await outputFS.symlink(path.join(rootDir, 'packages/library'), path.join(rootDir, 'packages/app/node_modules/library'));\n    await outputFS.symlink(path.join(rootDir, 'node_modules/.origin/pkg@1.0.0/node_modules/pkg'), path.join(rootDir, 'packages/app/node_modules/pkg'));\n    await outputFS.symlink(path.join(rootDir, 'node_modules/.origin/pkg@1.0.0/node_modules/pkg'), path.join(rootDir, 'packages/library/node_modules/pkg'));\n    let b = await bundle(path.join(__dirname, '/integration/resolve-symlinked-monorepos/packages/app/index.js'), {\n      inputFS: overlayFS,\n      outputFS\n    });\n    let output = await run(b);\n    assert.strictEqual(output.default, 2);\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support very long dependency specifiers","suites":["resolver"],"updatePoint":{"line":198,"column":52,"index":9205},"line":198,"code":"  it('should support very long dependency specifiers', async function () {\n    this.timeout(8000);\n    let inputDir = path.join(__dirname, 'input');\n    await outputFS.mkdirp(inputDir);\n    await outputFS.writeFile(path.join(inputDir, 'index.html'), `<img src=\"data:image/jpeg;base64,/9j/${'A'.repeat(200000)}\">`);\n    await bundle(path.join(inputDir, 'index.html'), {\n      inputFS: overlayFS\n    });\n  });","file":"resolver.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate a wasm file from a rust file with rustc with --target=browser","suites":["rust"],"updatePoint":{"line":11,"column":83,"index":526},"line":11,"code":"  it('should generate a wasm file from a rust file with rustc with --target=browser', async function () {\n    this.timeout(500000);\n    let b = await bundle(path.join(__dirname, '/integration/rust/index.js'));\n    await assertBundleTree(b, {\n      name: 'index.js',\n      assets: ['bundle-loader.js', 'bundle-url.js', 'index.js', 'wasm-loader.js'],\n      childBundles: [{\n        type: 'wasm',\n        assets: ['add.rs'],\n        childBundles: []\n      }, {\n        type: 'map'\n      }]\n    });\n    var res = await await run(b);\n    assert.equal(res, 5);\n\n    // not minified\n    assert((await outputFS.stat(Array.from(b.childBundles)[0].name)).size > 500);\n  });","file":"rust.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should generate a wasm file from a rust file with rustc with --target=node","suites":["rust"],"updatePoint":{"line":31,"column":80,"index":1187},"line":31,"code":"  it('should generate a wasm file from a rust file with rustc with --target=node', async function () {\n    this.timeout(500000);\n    let b = await bundle(path.join(__dirname, '/integration/rust/index.js'), {\n      target: 'node'\n    });\n    await assertBundleTree(b, {\n      name: 'index.js',\n      assets: ['bundle-loader.js', 'bundle-url.js', 'index.js', 'wasm-loader.js'],\n      childBundles: [{\n        type: 'wasm',\n        assets: ['add.rs'],\n        childBundles: []\n      }, {\n        type: 'map'\n      }]\n    });\n    var res = await run(b);\n    assert.equal(res, 5);\n\n    // not minified\n    assert((await outputFS.stat(Array.from(b.childBundles)[0].name)).size > 500);\n  });","file":"rust.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support rust files with dependencies via rustc","suites":["rust"],"updatePoint":{"line":53,"column":59,"index":1851},"line":53,"code":"  it('should support rust files with dependencies via rustc', async function () {\n    this.timeout(500000);\n    let b = bundler(path.join(__dirname, '/integration/rust-deps/index.js'));\n    let bundle = await b.bundle();\n    await assertBundleTree(bundle, {\n      name: 'index.js',\n      assets: ['bundle-loader.js', 'bundle-url.js', 'index.js', 'wasm-loader.js'],\n      childBundles: [{\n        type: 'map'\n      }, {\n        type: 'wasm',\n        assets: ['test.rs'],\n        childBundles: []\n      }]\n    });\n    var res = await run(bundle);\n    assert.equal(res, 10);\n  });","file":"rust.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should generate a wasm file from a rust file with cargo","suites":["rust"],"updatePoint":{"line":71,"column":61,"index":2431},"line":71,"code":"  it('should generate a wasm file from a rust file with cargo', async function () {\n    this.timeout(500000);\n    let b = await bundle(path.join(__dirname, '/integration/rust-cargo/src/index.js'));\n    await assertBundleTree(b, {\n      name: 'index.js',\n      assets: ['bundle-loader.js', 'bundle-url.js', 'index.js', 'wasm-loader.js'],\n      childBundles: [{\n        type: 'map'\n      }, {\n        type: 'wasm',\n        assets: ['lib.rs'],\n        childBundles: []\n      }]\n    });\n    var res = await run(b);\n    assert.equal(res, 5);\n  });","file":"rust.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should generate a wasm file from a rust file in cargo workspace","suites":["rust"],"updatePoint":{"line":88,"column":69,"index":2982},"line":88,"code":"  it('should generate a wasm file from a rust file in cargo workspace', async function () {\n    this.timeout(500000);\n    let b = await bundle(path.join(__dirname, '/integration/rust-cargo-workspace/member/src/index.js'));\n    await assertBundleTree(b, {\n      name: 'index.js',\n      assets: ['bundle-loader.js', 'bundle-url.js', 'index.js', 'wasm-loader.js'],\n      childBundles: [{\n        type: 'map'\n      }, {\n        type: 'wasm',\n        assets: ['lib.rs'],\n        childBundles: []\n      }]\n    });\n    var res = await run(b);\n    assert.equal(res, 5);\n  });","file":"rust.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring sass files","suites":["sass"],"updatePoint":{"line":5,"column":41,"index":211},"line":5,"code":"  it('should support requiring sass files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/sass/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.sass']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.index'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring scss files","suites":["sass"],"updatePoint":{"line":20,"column":41,"index":729},"line":20,"code":"  it('should support requiring scss files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scss/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.scss']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.index'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support scss imports","suites":["sass"],"updatePoint":{"line":35,"column":33,"index":1239},"line":35,"code":"  it('should support scss imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scss-import/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.scss']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.index'));\n    assert(css.includes('.foo'));\n    assert(css.includes('.bar'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring empty scss files","suites":["sass"],"updatePoint":{"line":52,"column":47,"index":1838},"line":52,"code":"  it('should support requiring empty scss files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scss-empty/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.scss']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert.equal(css.trim(), '/*# sourceMappingURL=index.css.map */');\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support linking to assets with url() from scss","suites":["sass"],"updatePoint":{"line":67,"column":59,"index":2415},"line":67,"code":"  it('should support linking to assets with url() from scss', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scss-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      type: 'jpeg',\n      assets: ['image.jpeg']\n    }, {\n      name: 'index.css',\n      assets: ['index.scss']\n    }, {\n      type: 'woff2',\n      assets: ['test.woff2']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(/url\\(\"test\\.[0-9a-f]+\\.woff2\"\\)/.test(css));\n    assert(css.includes('url(\"http://google.com\")'));\n    assert(css.includes('.index'));\n    assert(await outputFS.exists(path.join(distDir, css.match(/url\\(\"(test\\.[0-9a-f]+\\.woff2)\"\\)/)[1])));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming scss with postcss","suites":["sass"],"updatePoint":{"line":91,"column":51,"index":3281},"line":91,"code":"  it('should support transforming scss with postcss', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scss-postcss/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'index.module.scss']\n    }, {\n      name: 'index.css',\n      assets: ['index.module.scss']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    let className = output();\n    assert.notStrictEqual(className, 'index');\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes(`.${className}`));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support advanced import syntax","suites":["sass"],"updatePoint":{"line":107,"column":43,"index":3890},"line":107,"code":"  it('should support advanced import syntax', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/sass-advanced-import/index.sass'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.sass']\n    }]);\n    let css = (await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8')).replace(/\\s+/g, ' ');\n    assert(css.includes('.foo { color: pink;'));\n    assert(css.includes('.bar { color: green;'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support absolute imports","suites":["sass"],"updatePoint":{"line":117,"column":37,"index":4341},"line":117,"code":"  it('should support absolute imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scss-absolute-imports/style.scss'));\n    assertBundles(b, [{\n      name: 'style.css',\n      assets: ['style.scss']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'style.css'), 'utf8');\n    assert(css.includes('.a'));\n    assert(css.includes('.b'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should merge global data property from .sassrc.js","suites":["sass"],"updatePoint":{"line":127,"column":55,"index":4753},"line":127,"code":"  it('should merge global data property from .sassrc.js', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scss-global-data/index.scss'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.scss']\n    }]);\n    let css = (await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8')).replace(/\\s+/g, ' ');\n    assert(css.includes('.a { color: red;'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support using the custom webpack/sass node_modules syntax","suites":["sass"],"updatePoint":{"line":136,"column":70,"index":5180},"line":136,"code":"  it('should support using the custom webpack/sass node_modules syntax', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/sass-webpack-import-error/index.sass'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.sass']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.external'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support node_modules imports","suites":["sass"],"updatePoint":{"line":145,"column":41,"index":5557},"line":145,"code":"  it('should support node_modules imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/sass-node-modules-import/index.sass'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.sass']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.external'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support imports from includePaths","suites":["sass"],"updatePoint":{"line":154,"column":46,"index":5938},"line":154,"code":"  it('should support imports from includePaths', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/sass-include-paths-import/index.sass'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.sass']\n    }]);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.included'));\n  });","file":"sass.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should parse a LD+JSON schema and collect dependencies","suites":["jsonld"],"updatePoint":{"line":5,"column":60,"index":227},"line":5,"code":"  it('Should parse a LD+JSON schema and collect dependencies', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/schema-jsonld/index.html'), {\n      publicURL: 'https://place.holder/'\n    });\n    assertBundles(b, [{\n      type: 'jsonld',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'css',\n      assets: ['other.css']\n    }, {\n      type: 'png',\n      assets: ['logo.png']\n    }, {\n      type: 'jpeg',\n      assets: ['image.jpeg']\n    }]);\n    let file = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf-8');\n    let contentBetweenScriptTag = new RegExp(/<\\s*script \\s*type=\"application\\/ld\\+json\"\\s*>(.*)<\\/\\s*script\\s*>/gm).exec(file)[1];\n    let jsonldData = assertValidJsonObject(contentBetweenScriptTag);\n    match(jsonldData.logo.url, /logo\\.[a-f0-9]+\\.png/);\n    match(jsonldData.image[0], /image\\.[a-f0-9]+\\.jpeg/);\n    match(jsonldData.image[1], /image\\.[a-f0-9]+\\.jpeg/);\n  });","file":"schema-jsonld.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports default imports and exports of expressions","suites":["scope hoisting","es6"],"updatePoint":{"line":28,"column":59,"index":920},"line":28,"code":"    it('supports default imports and exports of expressions', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/default-export-expression/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports default imports and exports of declarations","suites":["scope hoisting","es6"],"updatePoint":{"line":33,"column":60,"index":1191},"line":33,"code":"    it('supports default imports and exports of declarations', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/default-export-declaration/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports default imports and exports of anonymous declarations","suites":["scope hoisting","es6"],"updatePoint":{"line":38,"column":70,"index":1473},"line":38,"code":"    it('supports default imports and exports of anonymous declarations', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/default-export-anonymous/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports default imports and exports of variables","suites":["scope hoisting","es6"],"updatePoint":{"line":43,"column":57,"index":1740},"line":43,"code":"    it('supports default imports and exports of variables', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/default-export-variable/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named imports and exports of declarations","suites":["scope hoisting","es6"],"updatePoint":{"line":48,"column":58,"index":2007},"line":48,"code":"    it('supports named imports and exports of declarations', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/named-export-declaration/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named imports and exports of variables","suites":["scope hoisting","es6"],"updatePoint":{"line":53,"column":55,"index":2272},"line":53,"code":"    it('supports named imports and exports of variables', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/named-export-variable/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named exports of variables with a different name","suites":["scope hoisting","es6"],"updatePoint":{"line":58,"column":65,"index":2544},"line":58,"code":"    it('supports named exports of variables with a different name', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/named-export-variable-rename/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named exports of variables with a different name when wrapped","suites":["scope hoisting","es6"],"updatePoint":{"line":63,"column":78,"index":2836},"line":63,"code":"    it('supports named exports of variables with a different name when wrapped', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/named-export-variable-rename-wrapped/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports renaming non-ASCII identifiers","suites":["scope hoisting","es6"],"updatePoint":{"line":68,"column":47,"index":3105},"line":68,"code":"    it('supports renaming non-ASCII identifiers', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/non-ascii-identifiers/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, [1, 2, 3, 4]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports renaming superclass identifiers","suites":["scope hoisting","es6"],"updatePoint":{"line":73,"column":48,"index":3375},"line":73,"code":"    it('supports renaming superclass identifiers', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/rename-superclass/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports renaming helpers inserted during transpiling","suites":["scope hoisting","es6"],"updatePoint":{"line":78,"column":61,"index":3639},"line":78,"code":"    it('supports renaming helpers inserted during transpiling', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/rename-helpers/a.js'));\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(/let \\S* = Symbol.toStringTag;/.test(contents));\n      let output = await run(b);\n      assert.deepEqual(output, ['1', '2']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"correctly renames member expression properties","suites":["scope hoisting","es6"],"updatePoint":{"line":85,"column":54,"index":4050},"line":85,"code":"    it('correctly renames member expression properties', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/rename-member-prop/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output({\n        foo: 12,\n        bar: 34\n      }), [12, 12, 34, 34]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports renaming imports","suites":["scope hoisting","es6"],"updatePoint":{"line":93,"column":33,"index":4350},"line":93,"code":"    it('supports renaming imports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/renamed-import/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports renaming exports","suites":["scope hoisting","es6"],"updatePoint":{"line":98,"column":33,"index":4583},"line":98,"code":"    it('supports renaming exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/renamed-export/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing from a reexporting asset in an anchestor (1)","suites":["scope hoisting","es6"],"updatePoint":{"line":103,"column":71,"index":4854},"line":103,"code":"    it('supports importing from a reexporting asset in an anchestor (1)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/ancestor-reexport/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, ['index', 'async']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing from a reexporting asset in an anchestor (2)","suites":["scope hoisting","es6"],"updatePoint":{"line":108,"column":71,"index":5149},"line":108,"code":"    it('supports importing from a reexporting asset in an anchestor (2)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/ancestor-reexport2/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, [123, 123]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing from a reexporting asset in an anchestor (3)","suites":["scope hoisting","es6"],"updatePoint":{"line":113,"column":71,"index":5437},"line":113,"code":"    it('supports importing from a reexporting asset in an anchestor (3)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/ancestor-reexport2/b.js'));\n      let output = await run(b);\n      assert.deepEqual(output, [123, 123]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports async import of internalized asset with unused return value","suites":["scope hoisting","es6"],"updatePoint":{"line":118,"column":76,"index":5730},"line":118,"code":"    it('supports async import of internalized asset with unused return value', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/async-internalize-unused/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 'bc');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing a namespace of exported values","suites":["scope hoisting","es6"],"updatePoint":{"line":123,"column":57,"index":6006},"line":123,"code":"    it('supports importing a namespace of exported values', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports namespace imports of excluded assets (node_modules)","suites":["scope hoisting","es6"],"updatePoint":{"line":128,"column":68,"index":6276},"line":128,"code":"    it('supports namespace imports of excluded assets (node_modules)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace-external/a.js'));\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('require(\"lodash\")'));\n      let output = await run(b);\n      assert.deepEqual(output.default, 12);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting all exports from another module","suites":["scope hoisting","es6"],"updatePoint":{"line":135,"column":61,"index":6697},"line":135,"code":"    it('supports re-exporting all exports from another module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-all/a.js'));\n      let output = await run(b);\n      assert.equal(output, 6);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting all when falling back to namespace at runtime 1","suites":["scope hoisting","es6"],"updatePoint":{"line":140,"column":77,"index":6973},"line":140,"code":"    it('supports re-exporting all when falling back to namespace at runtime 1', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-all-fallback-1/index.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting all when falling back to namespace at runtime 2","suites":["scope hoisting","es6"],"updatePoint":{"line":145,"column":77,"index":7270},"line":145,"code":"    it('supports re-exporting all when falling back to namespace at runtime 2', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-all-fallback-2/index.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting all when falling back to namespace at runtime 3","suites":["scope hoisting","es6"],"updatePoint":{"line":150,"column":77,"index":7567},"line":150,"code":"    it('supports re-exporting all when falling back to namespace at runtime 3', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/re-export-all-fallback-3/entry.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 'FOOBAR!');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports nested re-exporting all when falling back to namespace at runtime","suites":["scope hoisting","es6"],"updatePoint":{"line":155,"column":82,"index":7876},"line":155,"code":"    it('supports nested re-exporting all when falling back to namespace at runtime', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-all-fallback-nested/index.js'));\n      let output = await run(b);\n      assert.strictEqual(output, '2 4');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting all exports from an external module","suites":["scope hoisting","es6"],"updatePoint":{"line":160,"column":65,"index":8170},"line":160,"code":"    it('supports re-exporting all exports from an external module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-all-external/a.js'));\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['a.js', 'b.js']\n      }]);\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'b.js', 'lodash'))), new Set(['add']));\n\n      // getSymbolResolution is broken\n      // let output = await run(b);\n      // assert.equal(output, 3);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting all exports from multiple modules","suites":["scope hoisting","es6"],"updatePoint":{"line":173,"column":63,"index":8690},"line":173,"code":"    it('supports re-exporting all exports from multiple modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-all-multiple/a.js'));\n      let output = await run(b);\n      assert.equal(output, 15);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can import from a different bundle via a re-export (1)","suites":["scope hoisting","es6"],"updatePoint":{"line":178,"column":62,"index":8961},"line":178,"code":"    it('can import from a different bundle via a re-export (1)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-bundle-boundary/index.js'));\n      let output = await run(b);\n      assert.deepEqual(output, ['operational', 'ui']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can import from a different bundle via a re-export (2)","suites":["scope hoisting","es6"],"updatePoint":{"line":183,"column":62,"index":9262},"line":183,"code":"    it('can import from a different bundle via a re-export (2)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-bundle-boundary2/index.js'));\n      let output = await run(b);\n      assert.deepEqual(output, ['foo', 'foo']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can import from its own bundle with a split package","suites":["scope hoisting","es6"],"updatePoint":{"line":188,"column":59,"index":9554},"line":188,"code":"    it('can import from its own bundle with a split package', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-bundle-boundary3/index.js'));\n      let output = await run(b);\n      assert.deepEqual(output, [['a', 'b'], 'themed']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing all exports re-exported from multiple modules deep","suites":["scope hoisting","es6"],"updatePoint":{"line":193,"column":77,"index":9872},"line":193,"code":"    it('supports importing all exports re-exported from multiple modules deep', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-multiple-wildcards/a.js'));\n      let {\n        foo,\n        bar,\n        baz,\n        a,\n        b: bb\n      } = await run(b);\n      assert.equal(foo + bar + baz + a + bb, 15);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting all exports from multiple modules deep","suites":["scope hoisting","es6"],"updatePoint":{"line":204,"column":68,"index":10237},"line":204,"code":"    it('supports re-exporting all exports from multiple modules deep', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-multiple/a.js'));\n      let output = await run(b);\n      assert.equal(output, 7);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting individual named exports from another module","suites":["scope hoisting","es6"],"updatePoint":{"line":209,"column":74,"index":10515},"line":209,"code":"    it('supports re-exporting individual named exports from another module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-named/a.js'));\n      let output = await run(b);\n      assert.equal(output, 3);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting default exports from another module","suites":["scope hoisting","es6"],"updatePoint":{"line":214,"column":65,"index":10781},"line":214,"code":"    it('supports re-exporting default exports from another module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-default/a.js'));\n      let output = await run(b);\n      assert.equal(output, 3);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting a namespace from another module","suites":["scope hoisting","es6"],"updatePoint":{"line":219,"column":61,"index":11045},"line":219,"code":"    it('supports re-exporting a namespace from another module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-namespace/a.js'));\n      let output = await run(b);\n      assert.equal(output, 6);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting a namespace from another module (chained)","suites":["scope hoisting","es6"],"updatePoint":{"line":224,"column":71,"index":11321},"line":224,"code":"    it('supports re-exporting a namespace from another module (chained)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-namespace-chained/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        Bar: {\n          A: 1,\n          B: 2\n        },\n        Foo: {\n          A: 1,\n          B: 2\n        }\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"has the correct order with namespace re-exports","suites":["scope hoisting","es6"],"updatePoint":{"line":238,"column":55,"index":11714},"line":238,"code":"    it('has the correct order with namespace re-exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-namespace-order/index.js'));\n      let output = await run(b);\n      assert.equal(output, Symbol.for('abc'));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"excludes default when re-exporting a module","suites":["scope hoisting","es6"],"updatePoint":{"line":243,"column":51,"index":11996},"line":243,"code":"    it('excludes default when re-exporting a module', async function () {\n      let source = path.normalize('integration/scope-hoisting/es6/re-export-exclude-default/a.js');\n      let message = md`${normalizePath('integration/scope-hoisting/es6/re-export-exclude-default/b.js', false)} does not export 'default'`;\n      await assert.rejects(() => bundle(path.join(__dirname, source)), {\n        name: 'BuildError',\n        message,\n        diagnostics: [{\n          message,\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: path.join(__dirname, source),\n            language: 'js',\n            codeHighlights: [{\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 8\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"throws when reexporting a missing symbol","suites":["scope hoisting","es6"],"updatePoint":{"line":269,"column":48,"index":12874},"line":269,"code":"    it('throws when reexporting a missing symbol', async function () {\n      let source = path.normalize('integration/scope-hoisting/es6/re-export-missing/a.js');\n      let message = md`${normalizePath('integration/scope-hoisting/es6/re-export-missing/c.js', false)} does not export 'foo'`;\n      await assert.rejects(() => bundle(path.join(__dirname, source)), {\n        name: 'BuildError',\n        message,\n        diagnostics: [{\n          message,\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: path.join(__dirname, 'integration/scope-hoisting/es6/re-export-missing/b.js'),\n            language: 'js',\n            codeHighlights: [{\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 11\n              }\n            }]\n          }]\n        }]\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"throws when importing a missing symbol on cached builds without changes","suites":["scope hoisting","es6"],"updatePoint":{"line":295,"column":79,"index":13813},"line":295,"code":"    it('throws when importing a missing symbol on cached builds without changes', async function () {\n      let entry = 'integration/scope-hoisting/es6/import-missing/a.js';\n      let message = md`${normalizePath('integration/scope-hoisting/es6/import-missing/b.js', false)} does not export 'foo'`;\n      let error = {\n        name: 'BuildError',\n        message,\n        diagnostics: [{\n          message,\n          origin: '@parcel/core',\n          codeFrames: [{\n            filePath: path.join(__dirname, entry),\n            language: 'js',\n            codeHighlights: [{\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 11\n              }\n            }]\n          }]\n        }]\n      };\n      let source = path.join(__dirname, entry);\n      await assert.rejects(() => bundle(source, {\n        inputFS: overlayFS,\n        outputFS: overlayFS,\n        shouldDisableCache: false\n      }), error);\n      await assert.rejects(() => bundle(source, {\n        inputFS: overlayFS,\n        outputFS: overlayFS,\n        shouldDisableCache: false\n      }), error);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports multiple exports of the same variable","suites":["scope hoisting","es6"],"updatePoint":{"line":332,"column":54,"index":14966},"line":332,"code":"    it('supports multiple exports of the same variable', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/multi-export/a.js'));\n      let output = await run(b);\n      assert.equal(output, 6);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports live bindings of named exports","suites":["scope hoisting","es6"],"updatePoint":{"line":337,"column":47,"index":15211},"line":337,"code":"    it('supports live bindings of named exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/live-bindings/a.js'));\n      let output = await run(b);\n      assert.equal(output, 8);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports live bindings in namespaces of reexporting assets","suites":["scope hoisting","es6"],"updatePoint":{"line":342,"column":66,"index":15476},"line":342,"code":"    it('supports live bindings in namespaces of reexporting assets', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/live-bindings-reexports-namespace/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, [1, 2]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports live bindings across bundles","suites":["scope hoisting","es6"],"updatePoint":{"line":347,"column":45,"index":15749},"line":347,"code":"    it('supports live bindings across bundles', async function () {\n      let b = await bundle(['a.html', 'b.html'].map(f => path.join(__dirname, '/integration/scope-hoisting/es6/live-bindings-cross-bundle', f)), {\n        mode: 'production'\n      });\n      let ctx = await runBundle(b, b.getBundles().find(b => b.type === 'html'), {\n        output: null\n      }, {\n        require: false\n      });\n      assert.deepEqual(ctx.output, 'aaa');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports live bindings of default exports","suites":["scope hoisting","es6"],"updatePoint":{"line":358,"column":49,"index":16203},"line":358,"code":"    it('supports live bindings of default exports', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5658\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/export-default-live/a.js'));\n      let out = [];\n      await run(b, {\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, [5, 10]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports dynamic import syntax for code splitting","suites":["scope hoisting","es6"],"updatePoint":{"line":369,"column":57,"index":16605},"line":369,"code":"    it('supports dynamic import syntax for code splitting', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/dynamic-import/a.js'));\n      assert.equal(await run(b), 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports nested dynamic imports","suites":["scope hoisting","es6"],"updatePoint":{"line":373,"column":39,"index":16817},"line":373,"code":"    it('supports nested dynamic imports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/dynamic-import-dynamic/a.js'));\n      assert.equal(await run(b), 123);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named exports before the variable declaration","suites":["scope hoisting","es6"],"updatePoint":{"line":377,"column":62,"index":17062},"line":377,"code":"    it('supports named exports before the variable declaration', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/export-before-declaration/a.js'));\n      assert.deepEqual(await run(b), {\n        x: 2\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not export function arguments","suites":["scope hoisting","es6"],"updatePoint":{"line":383,"column":44,"index":17315},"line":383,"code":"    it('should not export function arguments', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/export-binding-identifiers/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, ['test']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should default export classes when wrapped","suites":["scope hoisting","es6"],"updatePoint":{"line":388,"column":50,"index":17588},"line":388,"code":"    it('should default export classes when wrapped', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/export-default-class-wrapped/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output.VERSION, 1234);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should default export functions when wrapped","suites":["scope hoisting","es6"],"updatePoint":{"line":393,"column":52,"index":17871},"line":393,"code":"    it('should default export functions when wrapped', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/export-default-function-wrapped/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output.VERSION, 1234);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should default export globals","suites":["scope hoisting","es6"],"updatePoint":{"line":398,"column":37,"index":18142},"line":398,"code":"    it('should default export globals', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/export-default-global/a.js'));\n      let Test = Symbol('Test');\n      let output = await run(b, {\n        Test\n      });\n      assert.strictEqual(output, Test);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should default export JS globals","suites":["scope hoisting","es6"],"updatePoint":{"line":406,"column":40,"index":18455},"line":406,"code":"    it('should default export JS globals', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/export-default-js-global/a.js'));\n      let output = await run(b);\n      assert(new output([1, 2, 3]).has(1));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove export named declaration without specifiers","suites":["scope hoisting","es6"],"updatePoint":{"line":411,"column":65,"index":18743},"line":411,"code":"    it('should remove export named declaration without specifiers', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/export-named-empty/a.js'));\n      let content = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(!/export\\s*{\\s*}\\s*;/.test(content));\n      let output = await run(b);\n      assert.strictEqual(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"throws a meaningful error on undefined exports","suites":["scope hoisting","es6"],"line":418,"code":"    it.skip('throws a meaningful error on undefined exports', async function () {","file":"scope-hoisting.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"supports importing named CommonJS (export individual)","suites":["scope hoisting","es6"],"updatePoint":{"line":428,"column":61,"index":19538},"line":428,"code":"    it('supports importing named CommonJS (export individual)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-commonjs-export-individual/a.js'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'c.js')))), new Set(['name', 'version']));\n      let output = await run(b);\n      assert.deepEqual(output, 'name:1.2.3');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing named CommonJS (export namespace)","suites":["scope hoisting","es6"],"updatePoint":{"line":434,"column":60,"index":19953},"line":434,"code":"    it('supports importing named CommonJS (export namespace)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-commonjs-export-object/a.js'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'c.js')))), new Set(['name', 'version']));\n      let output = await run(b);\n      assert.deepEqual(output, 'name:1.2.3');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports default importing CommonJS (export namespace)","suites":["scope hoisting","es6"],"updatePoint":{"line":440,"column":62,"index":20366},"line":440,"code":"    it('supports default importing CommonJS (export namespace)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-commonjs-export-object-default/a.js'));\n      assert.deepStrictEqual(new Set(nullthrows(findAsset(b, 'b1.js')).symbols.exportSymbols()), new Set(['*']));\n      assert.deepStrictEqual(new Set(nullthrows(findAsset(b, 'b2.js')).symbols.exportSymbols()), new Set(['*']));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        x: {\n          foo: 1,\n          default: 2\n        },\n        y: 4\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports import default CommonJS interop (export value)","suites":["scope hoisting","es6"],"updatePoint":{"line":453,"column":63,"index":20968},"line":453,"code":"    it('supports import default CommonJS interop (export value)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-commonjs-default/a.js'));\n      let dist = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(dist.includes('$parcel$interopDefault'));\n      let output = await run(b);\n      assert.deepEqual(output, 'foobar:foo:bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports import default CommonJS interop (individual exports)","suites":["scope hoisting","es6"],"updatePoint":{"line":460,"column":69,"index":21398},"line":460,"code":"    it('supports import default CommonJS interop (individual exports)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-commonjs-export-individual-default/a.js'));\n      assert.deepStrictEqual(new Set(nullthrows(findAsset(b, 'b1.js')).symbols.exportSymbols()), new Set(['*', 'default', 'foo']));\n      assert.deepStrictEqual(new Set(nullthrows(findAsset(b, 'b2.js')).symbols.exportSymbols()), new Set(['*', 'foo', 'default', '__esModule']));\n      assert.deepStrictEqual(new Set(nullthrows(findAsset(b, 'b3.js')).symbols.exportSymbols()), new Set(['*']));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        x: {\n          foo: 1,\n          default: 2\n        },\n        y: 4,\n        z: 6\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"falls back when importing missing symbols from CJS","suites":["scope hoisting","es6"],"updatePoint":{"line":475,"column":58,"index":22177},"line":475,"code":"    it('falls back when importing missing symbols from CJS', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-commonjs-missing/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, undefined);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not export reassigned CommonJS exports references","suites":["scope hoisting","es6"],"updatePoint":{"line":480,"column":62,"index":22462},"line":480,"code":"    it('does not export reassigned CommonJS exports references', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/commonjs-exports-reassign/a.js'));\n      let [foo, bExports] = await run(b);\n      assert.equal(foo, 'foobar');\n      assert.equal(typeof bExports, 'object');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports import default CommonJS interop with dynamic imports","suites":["scope hoisting","es6"],"updatePoint":{"line":486,"column":69,"index":22802},"line":486,"code":"    it('supports import default CommonJS interop with dynamic imports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/dynamic-default-interop/a.js'));\n      assert.deepEqual(await run(b), 6);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports exporting an import","suites":["scope hoisting","es6"],"updatePoint":{"line":490,"column":36,"index":23024},"line":490,"code":"    it('supports exporting an import', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-var/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'foobar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing from a wrapped asset","suites":["scope hoisting","es6"],"updatePoint":{"line":495,"column":47,"index":23281},"line":495,"code":"    it('supports importing from a wrapped asset', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-wrapped/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, ['a', true]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"wraps an asset if any of its ancestors is wrapped, even if one is not","suites":["scope hoisting","es6"],"updatePoint":{"line":500,"column":77,"index":23575},"line":500,"code":"    it('wraps an asset if any of its ancestors is wrapped, even if one is not', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/multiple-ancestors-wrap/index.js'));\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(contents.match(/parcelRequire.register\\(/g).length, 2 /* once for parent asset, once for child wrapped asset */);\n\n      let output = await run(b);\n      assert.deepEqual(output, [42, 43]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing from a wrapped asset with multiple bailouts","suites":["scope hoisting","es6"],"updatePoint":{"line":508,"column":70,"index":24091},"line":508,"code":"    it('supports importing from a wrapped asset with multiple bailouts', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-wrapped-bailout/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, ['b', true]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"unused and missing pseudo re-exports doen't fail the build","suites":["scope hoisting","es6"],"updatePoint":{"line":513,"column":66,"index":24382},"line":513,"code":"    it(\"unused and missing pseudo re-exports doen't fail the build\", async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-pseudo/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'foo');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports requiring a re-exported and renamed ES6 import","suites":["scope hoisting","es6"],"updatePoint":{"line":518,"column":63,"index":24655},"line":518,"code":"    it('supports requiring a re-exported and renamed ES6 import', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-renamed/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'foobar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports requiring a re-exported and renamed ES6 import (reversed order)","suites":["scope hoisting","es6"],"updatePoint":{"line":523,"column":80,"index":24949},"line":523,"code":"    it('supports requiring a re-exported and renamed ES6 import (reversed order)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-renamed2/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'foobar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports requiring a re-exported and renamed ES6 namespace import","suites":["scope hoisting","es6"],"updatePoint":{"line":528,"column":73,"index":25237},"line":528,"code":"    it('supports requiring a re-exported and renamed ES6 namespace import', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-renamed-namespace/a.js'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'a.js', './b.js'))), new Set(['default', 'x']));\n      let output = await run(b);\n      assert.deepEqual(output, [123, 123]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports reexporting an asset from a shared bundle inside a shared bundle","suites":["scope hoisting","es6"],"updatePoint":{"line":534,"column":81,"index":25665},"line":534,"code":"    it('supports reexporting an asset from a shared bundle inside a shared bundle', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/shared-bundle-reexport/*.html'), {\n        mode: 'production'\n      });\n      // Fork due to size calculation differences between bundlers\n      if (process.env.PARCEL_TEST_EXPERIMENTAL_BUNDLER) {\n        assertBundles(b, [{\n          type: 'html',\n          assets: ['index1.html']\n        }, {\n          type: 'js',\n          assets: ['index1.js']\n        }, {\n          type: 'html',\n          assets: ['index2.html']\n        }, {\n          type: 'js',\n          assets: ['index2.js', 'b.js']\n        }, {\n          type: 'html',\n          assets: ['index3.html']\n        }, {\n          type: 'js',\n          assets: ['index3.js', 'b.js']\n        }, {\n          type: 'js',\n          assets: ['a.js']\n        }]);\n      } else {\n        assertBundles(b, [{\n          type: 'html',\n          assets: ['index1.html']\n        }, {\n          type: 'js',\n          assets: ['index1.js']\n        }, {\n          type: 'html',\n          assets: ['index2.html']\n        }, {\n          type: 'js',\n          assets: ['index2.js']\n        }, {\n          type: 'html',\n          assets: ['index3.html']\n        }, {\n          type: 'js',\n          assets: ['index3.js']\n        }, {\n          type: 'js',\n          assets: ['a.js']\n        }, {\n          type: 'js',\n          assets: ['b.js']\n        }]);\n      }\n      for (let bundle of b.getBundles().filter(b => b.type === 'html')) {\n        let calls = [];\n        await runBundle(b, bundle, {\n          call(v) {\n            calls.push(v);\n          }\n        });\n        assert.equal(calls.length, 1);\n        assert(calls[0].startsWith('abcabc'));\n      }\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports simultaneous import and re-export of a symbol","suites":["scope hoisting","es6"],"updatePoint":{"line":600,"column":62,"index":27445},"line":600,"code":"    it('supports simultaneous import and re-export of a symbol', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-import/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 5 * 123);\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'e.js')))), new Set(['default']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'e2.js')))), new Set(['default']));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing a namespace from a commonjs module when code split","suites":["scope hoisting","es6"],"updatePoint":{"line":607,"column":77,"index":27961},"line":607,"code":"    it('supports importing a namespace from a commonjs module when code split', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace-commonjs/a.js'));\n      assert.deepEqual(await run(b), 4);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports resolving a static member access on a namespace","suites":["scope hoisting","es6"],"updatePoint":{"line":611,"column":64,"index":28213},"line":611,"code":"    it('supports resolving a static member access on a namespace', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace-static-member/a.js'));\n      let calls = [];\n      let output = await run(b, {\n        sideEffect: v => {\n          calls.push(v);\n        }\n      });\n      assert.deepEqual(output, 'foofoobar');\n      assert.deepEqual(calls, ['c1', 'c3']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bailout with a non-static member access on a namespace","suites":["scope hoisting","es6"],"updatePoint":{"line":622,"column":69,"index":28652},"line":622,"code":"    it('should bailout with a non-static member access on a namespace', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace-static-member/b.js'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'b.js', './library/index.js'))), new Set(['*']));\n      let calls = [];\n      let output = await run(b, {\n        sideEffect: v => {\n          calls.push(v);\n        }\n      });\n      assert.deepEqual(output, 'foo');\n      assert.deepEqual(calls, ['c1', 'c2', 'c3']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing a namespace from a wrapped module","suites":["scope hoisting","es6"],"updatePoint":{"line":634,"column":60,"index":29204},"line":634,"code":"    it('supports importing a namespace from a wrapped module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace-wrapped/a.js'));\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('$parcel$exportWildcard'));\n      let output = await run(b);\n      assert.deepEqual(output, 1);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports wrapped assets importing their own namespace","suites":["scope hoisting","es6"],"updatePoint":{"line":641,"column":61,"index":29621},"line":641,"code":"    it('supports wrapped assets importing their own namespace', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace-wrapped-self/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, true);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports importing a namespace from a transpiled CommonJS module","suites":["scope hoisting","es6"],"updatePoint":{"line":646,"column":72,"index":29917},"line":646,"code":"    it('supports importing a namespace from a transpiled CommonJS module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-namespace-commonjs-transpiled/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        bar: 3,\n        foo: 1\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes unused exports","suites":["scope hoisting","es6"],"updatePoint":{"line":654,"column":30,"index":30212},"line":654,"code":"    it('removes unused exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking/a.js'), {\n        mode: 'production'\n      });\n      let output = await run(b);\n      assert.deepEqual(output, 2);\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('output=2'));\n      assert(!contents.includes('bar'));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes unused function exports when minified","suites":["scope hoisting","es6"],"updatePoint":{"line":664,"column":53,"index":30673},"line":664,"code":"    it('removes unused function exports when minified', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-functions/a.js'), {\n        defaultTargetOptions: {\n          shouldOptimize: true\n        }\n      });\n      let output = await run(b);\n      assert.deepEqual(output, 9);\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(/output=9/.test(contents));\n      assert(!/.-./.test(contents));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes unused transpiled classes using terser when minified","suites":["scope hoisting","es6"],"updatePoint":{"line":676,"column":68,"index":31197},"line":676,"code":"    it('removes unused transpiled classes using terser when minified', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-classes-babel/a.js'), {\n        defaultTargetOptions: {\n          shouldOptimize: true\n        }\n      });\n      let output = await run(b);\n      assert.deepEqual(output, 3);\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('method'));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes unused exports across bundles","suites":["scope hoisting","es6"],"updatePoint":{"line":695,"column":49,"index":31896},"line":695,"code":"        it('removes unused exports across bundles', async () => {\n          let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-cross-bundle/a.js'), {\n            targets,\n            mode: 'production'\n          });\n          if (outputFormat != 'esmodule') {\n            // TODO execute ESM at some point\n            assert.deepEqual(await run(b), ['b1:foo', 'b2:foo']);\n          }\n          let contents = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('b1')).filePath, 'utf8');\n          assert(!contents.includes('bar'));\n          contents = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('b2')).filePath, 'utf8');\n          assert(!contents.includes('bar'));\n        });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes unused exports with re-exports across bundles","suites":["scope hoisting","es6"],"updatePoint":{"line":709,"column":65,"index":32667},"line":709,"code":"        it('removes unused exports with re-exports across bundles', async () => {\n          let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-cross-bundle-re-export/a.js'), {\n            targets,\n            mode: 'production'\n          });\n          if (outputFormat != 'esmodule') {\n            // TODO execute ESM at some point\n            assert.deepEqual(await run(b), ['b1:foo', 'b2:foo']);\n          }\n          let contents = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('b1')).filePath, 'utf8');\n          assert(!contents.includes('bar'));\n          contents = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('b2')).filePath, 'utf8');\n          assert(!contents.includes('bar'));\n        });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes unused exports with wildcard re-exports across bundles","suites":["scope hoisting","es6"],"updatePoint":{"line":723,"column":74,"index":33457},"line":723,"code":"        it('removes unused exports with wildcard re-exports across bundles', async () => {\n          let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-cross-bundle-re-export-wildcard/a.js'), {\n            targets,\n            mode: 'production'\n          });\n          if (outputFormat != 'esmodule') {\n            // TODO execute ESM at some point\n            assert.deepEqual(await run(b), ['b1:foo', 'b2:foo']);\n          }\n          let contents = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('b1')).filePath, 'utf8');\n          assert(!contents.includes('bar'));\n          contents = await outputFS.readFile(b.getBundles().find(b => b.name.startsWith('b2')).filePath, 'utf8');\n          assert(!contents.includes('bar'));\n        });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: destructued await assignment","suites":["scope hoisting","es6","tree shaking dynamic imports"],"line":740,"code":"      it.skip('supports tree shaking statically analyzable dynamic import: destructued await assignment', async function () {","file":"scope-hoisting.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: destructured await declaration","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":750,"column":100,"index":35167},"line":750,"code":"      it('supports tree shaking statically analyzable dynamic import: destructured await declaration', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-dynamic-import/await-declaration.js'), {\n          mode: 'production'\n        });\n        let output = await run(b);\n        assert.deepEqual(output, ['foo', 'thing']);\n        assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'await-declaration.js', './async.js'))), new Set(['foo', 'thing']));\n        assert(b.isDependencySkipped(findDependency(b, 'async.js', './a1.js')));\n        let contents = await outputFS.readFile(b.getBundles().find(b => b.getMainEntry().filePath.endsWith('async.js')).filePath, 'utf8');\n        assert(!contents.includes('bar'));\n        assert(!contents.includes('stuff'));\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: namespace await declaration","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":762,"column":97,"index":36013},"line":762,"code":"      it('supports tree shaking statically analyzable dynamic import: namespace await declaration', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-dynamic-import/await-declaration-namespace.js'), {\n          mode: 'production'\n        });\n        let output = await run(b);\n        assert.deepEqual(output, ['foo', 'thing']);\n        assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'await-declaration-namespace.js', './async.js'))), new Set(['foo', 'thing']));\n        assert(b.isDependencySkipped(findDependency(b, 'async.js', './a1.js')));\n        let contents = await outputFS.readFile(b.getBundles().find(b => b.getMainEntry().filePath.endsWith('async.js')).filePath, 'utf8');\n        assert(!contents.includes('bar'));\n        assert(!contents.includes('stuff'));\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: namespace await declaration bailout","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":774,"column":105,"index":36887},"line":774,"code":"      it('supports tree shaking statically analyzable dynamic import: namespace await declaration bailout', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-dynamic-import/await-declaration-namespace-bailout.js'));\n        let output = await run(b);\n        assert.deepEqual(output, {\n          bar: 'bar',\n          foo: 'foo',\n          other: 'other',\n          stuff: 'stuff',\n          thing: 'thing'\n        });\n        assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'await-declaration-namespace-bailout.js', './async.js'))), new Set(['*']));\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: namespace await declaration eval bailout","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":786,"column":110,"index":37537},"line":786,"code":"      it('supports tree shaking statically analyzable dynamic import: namespace await declaration eval bailout', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-dynamic-import/await-declaration-namespace-bailout-eval.js'));\n        let output = await run(b);\n        assert.deepEqual(output, 'thing');\n        assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'await-declaration-namespace-bailout-eval.js', './async.js'))), new Set(['*']));\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: destructured then","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":792,"column":87,"index":38049},"line":792,"code":"      it('supports tree shaking statically analyzable dynamic import: destructured then', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-dynamic-import/then.js'), {\n          mode: 'production'\n        });\n        let output = await run(b);\n        assert.deepEqual(output, ['foo', 'thing']);\n        assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'then.js', './async.js'))), new Set(['foo', 'thing']));\n        assert(b.isDependencySkipped(findDependency(b, 'async.js', './a1.js')));\n        let contents = await outputFS.readFile(b.getBundles().find(b => b.getMainEntry().filePath.endsWith('async.js')).filePath, 'utf8');\n        assert(!contents.includes('bar'));\n        assert(!contents.includes('stuff'));\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: namespace then","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":804,"column":84,"index":38856},"line":804,"code":"      it('supports tree shaking statically analyzable dynamic import: namespace then', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-dynamic-import/then-namespace.js'), {\n          mode: 'production'\n        });\n        let output = await run(b);\n        assert.deepEqual(output, ['foo', 'thing']);\n        assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'then-namespace.js', './async.js'))), new Set(['foo', 'thing']));\n        assert(b.isDependencySkipped(findDependency(b, 'async.js', './a1.js')));\n        let contents = await outputFS.readFile(b.getBundles().find(b => b.getMainEntry().filePath.endsWith('async.js')).filePath, 'utf8');\n        assert(!contents.includes('bar'));\n        assert(!contents.includes('stuff'));\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: namespace then bailout","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":816,"column":92,"index":39691},"line":816,"code":"      it('supports tree shaking statically analyzable dynamic import: namespace then bailout', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-dynamic-import/then-namespace-bailout.js'));\n        let output = await run(b);\n        assert.deepEqual(output, {\n          bar: 'bar',\n          foo: 'foo',\n          other: 'other',\n          stuff: 'stuff',\n          thing: 'thing'\n        });\n        assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'then-namespace-bailout.js', './async.js'))), new Set(['*']));\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports tree shaking statically analyzable dynamic import: esmodule output","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":828,"column":85,"index":40290},"line":828,"code":"      it('supports tree shaking statically analyzable dynamic import: esmodule output', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-dynamic-import/then.js'), {\n          mode: 'production',\n          targets: {\n            default: {\n              outputFormat: 'esmodule',\n              distDir\n            }\n          }\n        });\n\n        // let output = await run(b);\n        // assert.deepEqual(output, 'foo');\n\n        assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'then.js', './async.js'))), new Set(['foo', 'thing']));\n        assert(b.isDependencySkipped(findDependency(b, 'async.js', './a1.js')));\n        let contents = await outputFS.readFile(b.getBundles().find(b => b.getMainEntry().filePath.endsWith('async.js')).filePath, 'utf8');\n        assert(!contents.includes('bar'));\n        assert(!contents.includes('stuff'));\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"throws an error for missing exports for dynamic import: destructured await assignment","suites":["scope hoisting","es6","tree shaking dynamic imports"],"line":848,"code":"      it.skip('throws an error for missing exports for dynamic import: destructured await assignment', async function () {","file":"scope-hoisting.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"throws an error for missing exports for dynamic import: destructured await declaration","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":874,"column":96,"index":42126},"line":874,"code":"      it('throws an error for missing exports for dynamic import: destructured await declaration', async function () {\n        let source = path.join(__dirname, 'integration/scope-hoisting/es6/tree-shaking-dynamic-import', 'await-declaration-error.js');\n        let message = `async.js does not export 'missing'`;\n        await assert.rejects(() => bundle(path.join(__dirname, 'integration/scope-hoisting/es6/tree-shaking-dynamic-import', 'await-declaration-error.js')), {\n          name: 'BuildError',\n          message,\n          diagnostics: [{\n            message,\n            origin: '@parcel/core',\n            codeFrames: [{\n              filePath: source,\n              language: 'js',\n              codeHighlights: [{\n                start: {\n                  column: 8,\n                  line: 2\n                },\n                end: {\n                  column: 14,\n                  line: 2\n                }\n              }]\n            }]\n          }]\n        });\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"throws an error for missing exports for dynamic import: namespace await declaration","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":900,"column":93,"index":43113},"line":900,"code":"      it('throws an error for missing exports for dynamic import: namespace await declaration', async function () {\n        let source = path.join(__dirname, 'integration/scope-hoisting/es6/tree-shaking-dynamic-import', 'await-declaration-namespace-error.js');\n        let message = `async.js does not export 'missing'`;\n        await assert.rejects(() => bundle(path.join(__dirname, 'integration/scope-hoisting/es6/tree-shaking-dynamic-import', 'await-declaration-namespace-error.js')), {\n          name: 'BuildError',\n          message,\n          diagnostics: [{\n            message,\n            origin: '@parcel/core',\n            codeFrames: [{\n              filePath: source,\n              language: 'js',\n              codeHighlights: [{\n                start: {\n                  column: 10,\n                  line: 3\n                },\n                end: {\n                  column: 19,\n                  line: 3\n                }\n              }]\n            }]\n          }]\n        });\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"throws an error for missing exports for dynamic import: destructured then","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":926,"column":83,"index":44111},"line":926,"code":"      it('throws an error for missing exports for dynamic import: destructured then', async function () {\n        let source = path.join(__dirname, 'integration/scope-hoisting/es6/tree-shaking-dynamic-import', 'then-error.js');\n        let message = `async.js does not export 'missing'`;\n        await assert.rejects(() => bundle(path.join(__dirname, 'integration/scope-hoisting/es6/tree-shaking-dynamic-import', 'then-error.js')), {\n          name: 'BuildError',\n          message,\n          diagnostics: [{\n            message,\n            origin: '@parcel/core',\n            codeFrames: [{\n              filePath: source,\n              language: 'js',\n              codeHighlights: [{\n                start: {\n                  column: 38,\n                  line: 1\n                },\n                end: {\n                  column: 44,\n                  line: 1\n                }\n              }]\n            }]\n          }]\n        });\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"throws an error for missing exports for dynamic import: namespace then","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":952,"column":80,"index":45060},"line":952,"code":"      it('throws an error for missing exports for dynamic import: namespace then', async function () {\n        let source = path.join(__dirname, 'integration/scope-hoisting/es6/tree-shaking-dynamic-import', 'then-namespace-error.js');\n        let message = `async.js does not export 'missing'`;\n        await assert.rejects(() => bundle(path.join(__dirname, 'integration/scope-hoisting/es6/tree-shaking-dynamic-import', 'then-namespace-error.js')), {\n          name: 'BuildError',\n          message,\n          diagnostics: [{\n            message,\n            origin: '@parcel/core',\n            codeFrames: [{\n              filePath: source,\n              language: 'js',\n              codeHighlights: [{\n                start: {\n                  column: 45,\n                  line: 1\n                },\n                end: {\n                  column: 54,\n                  line: 1\n                }\n              }]\n            }]\n          }]\n        });\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"keeps member expression with computed properties that are variables","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":979,"column":75,"index":46032},"line":979,"code":"    it('keeps member expression with computed properties that are variables', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-export-computed-prop/a.js'), {\n        defaultTargetOptions: {\n          shouldOptimize: true\n        }\n      });\n      let output = await run(b);\n      assert.strictEqual(output[0], true);\n      assert.strictEqual(typeof output[1], 'undefined');\n      assert.strictEqual(output[2], true);\n      assert.strictEqual(typeof output[3], 'undefined');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"support exporting a ES6 module exported as CommonJS","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":991,"column":59,"index":46563},"line":991,"code":"    it('support exporting a ES6 module exported as CommonJS', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-commonjs/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'foo');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"concatenates in the correct order when re-exporting assets were excluded","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":996,"column":80,"index":46855},"line":996,"code":"    it('concatenates in the correct order when re-exporting assets were excluded', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-false-order/index.js'));\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(/\\s+class\\s+/.test(contents));\n      let called = false;\n      let output = await run(b, {\n        sideEffect: () => {\n          called = true;\n        }\n      });\n      assert(!called, 'side effect called');\n      assert.strictEqual(output[0], 'a');\n      assert.strictEqual(output[1], 'b');\n      assert(new output[3]() instanceof output[2]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support chained reexports from hybrid modules","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1011,"column":60,"index":47505},"line":1011,"code":"    it('should support chained reexports from hybrid modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-hybrid/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support chained reexports as default from hybrid modules","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1016,"column":71,"index":47784},"line":1016,"code":"    it('should support chained reexports as default from hybrid modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-default-hybrid/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"support chained namespace reexports of CommonJS","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1021,"column":55,"index":48055},"line":1021,"code":"    it('support chained namespace reexports of CommonJS', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/re-export-commonjs-wildcard/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'foo');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support assets importing themselves","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1026,"column":50,"index":48326},"line":1026,"code":"    it('should support assets importing themselves', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-self/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 4);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support named imports on wrapped modules","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1031,"column":55,"index":48584},"line":1031,"code":"    it('should support named imports on wrapped modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-wrapped/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support unused imports of wrapped modules in different bundles","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1036,"column":77,"index":48869},"line":1036,"code":"    it('should support unused imports of wrapped modules in different bundles', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/import-wrapped-bundle-unused/a.js'));\n      let called = false;\n      await run(b, {\n        sideEffect() {\n          called = true;\n        }\n      });\n      assert(called);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert esModule flag for interop for async (or shared) bundles","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1046,"column":77,"index":49233},"line":1046,"code":"    it('should insert esModule flag for interop for async (or shared) bundles', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/interop-async/index.html'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldOptimize: false\n        }\n      });\n      let res = await run(b, {\n        output: null\n      }, {\n        require: false\n      });\n      assert.deepEqual(await res.output, ['client', 'client', 'viewer']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should enable minifier to remove unused modules despite of interopDefault","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1060,"column":81,"index":49738},"line":1060,"code":"    it('should enable minifier to remove unused modules despite of interopDefault', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/interop-pure/a.js'), {\n        mode: 'production',\n        defaultTargetOptions: {\n          shouldOptimize: true,\n          sourceMaps: false\n        }\n      });\n      let contents = await outputFS.readFileSync(b.getBundles()[0].filePath, 'utf8');\n      assert.strictEqual(contents.trim().length, 0);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the jsx pragma","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1071,"column":37,"index":50189},"line":1071,"code":"    it('should support the jsx pragma', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/jsx-pragma/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        children: 'Test',\n        props: null,\n        type: 'span'\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not nameclash with internal variables","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1080,"column":52,"index":50517},"line":1080,"code":"    it('should not nameclash with internal variables', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/name-clash/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should shake pure property assignments","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1085,"column":46,"index":50767},"line":1085,"code":"    it('should shake pure property assignments', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/pure-assignment/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 2);\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(!contents.includes('exports.bar ='));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly rename references to default exported classes","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1092,"column":70,"index":51175},"line":1092,"code":"    it('should correctly rename references to default exported classes', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/default-export-class-rename/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output.foo, 'bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly rename references to a class in the class body","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1097,"column":71,"index":51471},"line":1097,"code":"    it('should correctly rename references to a class in the class body', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/class-selfreference/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output.foo, 'bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly codesplit even with reexporting library index","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1102,"column":70,"index":51758},"line":1102,"code":"    it('should correctly codesplit even with reexporting library index', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/codesplit-reexports/src/entry.js'));\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['entry.js', 'foo.js', 'bar.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n      }, {\n        type: 'js',\n        assets: ['async.js', 'foo2.js', 'bar2.js']\n      }]);\n      let output = await run(b);\n      assert.deepEqual(output, [[20, 30], [2, 3]]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly handle circular dependencies","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1114,"column":53,"index":52284},"line":1114,"code":"    it('should correctly handle circular dependencies', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/circular/a.mjs'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'b.mjs')))), new Set(['foo']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'c.mjs')))), new Set(['run']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'b.mjs', './c.mjs'))), new Set(['run']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'c.mjs', './b.mjs'))), new Set(['foo']));\n      let output = await run(b);\n      assert.strictEqual(output, 'c:foo');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly handle circular dependencies (2)","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1123,"column":57,"index":52996},"line":1123,"code":"    it('should correctly handle circular dependencies (2)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/circular2/a.mjs'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'b.mjs')))), new Set(['run', 'foo']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'c.mjs')))), new Set([]));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'b.mjs', './c.mjs'))), new Set(['foo']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'c.mjs', './b.mjs'))), new Set(['foo']));\n      let output = await run(b);\n      assert.strictEqual(output, 'b:foo:foo');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly handle circular dependencies (3)","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1132,"column":57,"index":53715},"line":1132,"code":"    it('should correctly handle circular dependencies (3)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/circular3/a.mjs'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'b.mjs')))), new Set([]));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'c.mjs')))), new Set(['a']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'd.mjs')))), new Set([]));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'a.mjs', './b.mjs'))), new Set(['h']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'b.mjs', './c.mjs'))), new Set(['a', 'd', 'g']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'c.mjs', './d.mjs'))), new Set(['c', 'f']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'd.mjs', './b.mjs'))), new Set(['b', 'e']));\n      let output = await run(b);\n      assert.strictEqual(output, 123);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle circular dependencies with wrapped assets","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1144,"column":63,"index":54768},"line":1144,"code":"    it('should handle circular dependencies with wrapped assets', async () => {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/circular-wrap/index.mjs'));\n      let output = [];\n      await run(b, {\n        output(o) {\n          output.push(o);\n        }\n      });\n      assert.deepEqual(output, ['d', 'c', 'b', 'a', 'index']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not tree-shake assignments to unknown objects","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1154,"column":58,"index":55133},"line":1154,"code":"    it('does not tree-shake assignments to unknown objects', async () => {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-no-unknown-objects/index.js'));\n      assert.equal(await run(b), 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can conditionally reference an imported symbol and unconditionally reference it","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1158,"column":87,"index":55409},"line":1158,"code":"    it('can conditionally reference an imported symbol and unconditionally reference it', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/conditional-import-reference/index.js'));\n      let output = await run(b);\n      assert.equal(output, 'hello');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can conditionally reference an imported symbol from another bundle in a case clause","suites":["scope hoisting","es6","tree shaking dynamic imports"],"updatePoint":{"line":1163,"column":91,"index":55724},"line":1163,"code":"    it('can conditionally reference an imported symbol from another bundle in a case clause', async () => {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/async-interop-conditional/index.js'));\n      let output = await run(b);\n      assert.equal(await output, 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"handles redirects up the tree","suites":["scope hoisting","es6","considers an asset's closest package.json for sideEffects, not the package through which it found the asset"],"updatePoint":{"line":1169,"column":39,"index":56111},"line":1169,"code":"      it('handles redirects up the tree', async () => {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-package-redirect-up/index.js'));\n        let result = await run(b);\n        assert.strictEqual(result, 1);\n        let bar = findAsset(b, 'real-bar.js');\n        assert(bar);\n        assert.strictEqual(bar.sideEffects, false);\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"handles redirects down the tree","suites":["scope hoisting","es6","considers an asset's closest package.json for sideEffects, not the package through which it found the asset"],"updatePoint":{"line":1177,"column":41,"index":56502},"line":1177,"code":"      it('handles redirects down the tree', async () => {\n        let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/side-effects-package-redirect-down/index.js'));\n        let result = await run(b);\n        assert.strictEqual(result, 1);\n        let bar = findAsset(b, 'real-bar.js');\n        assert(bar);\n        assert.strictEqual(bar.sideEffects, false);\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"dependency symbols change","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1187,"column":35,"index":56963},"line":1187,"code":"      it('dependency symbols change', async function () {\n        let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/update-used-symbols-dependency-symbols');\n        let b = bundler(path.join(testDir, 'index.js'), {\n          inputFS: overlayFS,\n          outputFS: overlayFS\n        });\n        await overlayFS.mkdirp(testDir);\n        await overlayFS.copyFile(path.join(testDir, 'index.1.js'), path.join(testDir, 'index.js'));\n        let subscription = await b.watch();\n        try {\n          let bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          let output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, [123]);\n          await overlayFS.copyFile(path.join(testDir, 'index.2.js'), path.join(testDir, 'index.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, [123, 789]);\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(findAsset(bundleEvent.bundleGraph, 'c.js'))), new Set(['c']));\n          await overlayFS.copyFile(path.join(testDir, 'index.1.js'), path.join(testDir, 'index.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, [123]);\n          assert(!findAsset(bundleEvent.bundleGraph, 'c.js'));\n        } finally {\n          await subscription.unsubscribe();\n        }\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"add and remove dependency","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1217,"column":35,"index":58602},"line":1217,"code":"      it('add and remove dependency', async function () {\n        let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/update-used-symbols-dependency-add');\n        let b = bundler(path.join(testDir, 'index.js'), {\n          inputFS: overlayFS,\n          outputFS: overlayFS\n        });\n        await overlayFS.mkdirp(testDir);\n        await overlayFS.copyFile(path.join(testDir, 'index.1.js'), path.join(testDir, 'index.js'));\n        let subscription = await b.watch();\n        try {\n          let bundleEvent = await getNextBuild(b);\n          assert(bundleEvent.type === 'buildSuccess');\n          let output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, [123]);\n          let assetC = nullthrows(findAsset(bundleEvent.bundleGraph, 'd1.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetC)), new Set(['a']));\n          assert(!findAsset(bundleEvent.bundleGraph, 'd2.js'));\n          await overlayFS.copyFile(path.join(testDir, 'index.2.js'), path.join(testDir, 'index.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, [123, 789, {\n            d1: 1,\n            d2: 2\n          }]);\n          assetC = nullthrows(findAsset(bundleEvent.bundleGraph, 'd1.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetC)), new Set(['a', 'b']));\n          let assetD = nullthrows(findAsset(bundleEvent.bundleGraph, 'd2.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetD)), new Set(['*']));\n          await overlayFS.copyFile(path.join(testDir, 'index.1.js'), path.join(testDir, 'index.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, [123]);\n          assetC = nullthrows(findAsset(bundleEvent.bundleGraph, 'd1.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetC)), new Set(['a']));\n          assert(!findAsset(bundleEvent.bundleGraph, 'd2.js'));\n        } finally {\n          await subscription.unsubscribe();\n        }\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"add and remove dependency with inline asset","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1258,"column":53,"index":60965},"line":1258,"code":"      it('add and remove dependency with inline asset', async function () {\n        let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/update-used-symbols-dependency-add-inline');\n        let b = bundler(path.join(testDir, 'index.js'), {\n          inputFS: overlayFS,\n          outputFS: overlayFS\n        });\n        await overlayFS.mkdirp(testDir);\n        await overlayFS.copyFile(path.join(testDir, 'other.1.js'), path.join(testDir, 'other.js'));\n        let subscription = await b.watch();\n        try {\n          let bundleEvent = await getNextBuild(b);\n          assert(bundleEvent.type === 'buildSuccess');\n          let output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, 123);\n          let assetOther = nullthrows(findAsset(bundleEvent.bundleGraph, 'other.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetOther)), new Set([]));\n          await overlayFS.copyFile(path.join(testDir, 'other.2.js'), path.join(testDir, 'other.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, 1);\n          assetOther = nullthrows(findAsset(bundleEvent.bundleGraph, 'other.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetOther)), new Set(['a']));\n          await overlayFS.copyFile(path.join(testDir, 'other.1.js'), path.join(testDir, 'other.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          output = await run(bundleEvent.bundleGraph);\n          assert.deepEqual(output, 123);\n          assetOther = nullthrows(findAsset(bundleEvent.bundleGraph, 'other.js'));\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(assetOther)), new Set([]));\n          assert(!findAsset(bundleEvent.bundleGraph, 'd2.js'));\n        } finally {\n          await subscription.unsubscribe();\n        }\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"add and remove dependency with namespace","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1293,"column":50,"index":63038},"line":1293,"code":"      it('add and remove dependency with namespace', async function () {\n        let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/update-used-symbols-dependency-add-namespace');\n        let b = bundler(path.join(testDir, 'index.html'), {\n          inputFS: overlayFS,\n          outputFS: overlayFS\n        });\n        await overlayFS.mkdirp(testDir);\n        await overlayFS.copyFile(path.join(testDir, 'index.1.js'), path.join(testDir, 'index.js'));\n        let subscription = await b.watch();\n        try {\n          let bundleEvent = await getNextBuild(b);\n          assert(bundleEvent.type === 'buildSuccess');\n          let res = await run(bundleEvent.bundleGraph, {\n            output: null\n          }, {\n            require: false\n          });\n          assert.deepEqual(await res.output, {\n            akGridSize: 8\n          });\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(findAsset(bundleEvent.bundleGraph, 'themeConstants.js'))), new Set(['gridSize']));\n          assert(!findAsset(bundleEvent.bundleGraph, 'themeColors.js'));\n          await overlayFS.copyFile(path.join(testDir, 'index.2.js'), path.join(testDir, 'index.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          res = await run(bundleEvent.bundleGraph, {\n            output: null\n          }, {\n            require: false\n          });\n          assert.deepEqual(await res.output, [{\n            akGridSize: 8\n          }, {\n            akEmojiSelectedBackgroundColor: '#EBECF0'\n          }]);\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(findAsset(bundleEvent.bundleGraph, 'themeConstants.js'))), new Set(['borderRadius', 'gridSize']));\n          assert(!findAsset(bundleEvent.bundleGraph, 'theme.js'));\n          assert(findAsset(bundleEvent.bundleGraph, 'themeColors.js'));\n          await overlayFS.copyFile(path.join(testDir, 'index.1.js'), path.join(testDir, 'index.js'));\n          bundleEvent = await getNextBuild(b);\n          assert.strictEqual(bundleEvent.type, 'buildSuccess');\n          res = await run(bundleEvent.bundleGraph, {\n            output: null\n          }, {\n            require: false\n          });\n          assert.deepEqual(await res.output, {\n            akGridSize: 8\n          });\n          assert.deepStrictEqual(new Set(bundleEvent.bundleGraph.getUsedSymbols(findAsset(bundleEvent.bundleGraph, 'themeConstants.js'))), new Set(['gridSize']));\n          assert(!findAsset(bundleEvent.bundleGraph, 'themeColors.js'));\n        } finally {\n          await subscription.unsubscribe();\n        }\n      });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes functions that increment variables in object properties","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1349,"column":71,"index":65739},"line":1349,"code":"    it('removes functions that increment variables in object properties', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/tree-shaking-increment-object/a.js'), {\n        defaultTargetOptions: {\n          shouldOptimize: true\n        }\n      });\n      let content = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(!content.includes('++'));\n      await run(b);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"ignores missing import specifiers in source assets","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1359,"column":58,"index":66172},"line":1359,"code":"    it('ignores missing import specifiers in source assets', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/unused-import-specifier/a.js'));\n      let output = await run(b);\n      assert.equal(output, 123);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"ignores unused import specifiers in node-modules","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1364,"column":56,"index":66438},"line":1364,"code":"    it('ignores unused import specifiers in node-modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/unused-import-specifier-node-modules/a.js'));\n      let output = await run(b);\n      assert.equal(output, 123);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can import urls to raw assets","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1369,"column":37,"index":66699},"line":1369,"code":"    it('can import urls to raw assets', async () => {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/raw-url/index-import.js'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'index-import.js', 'url:./foo.png'))), new Set(['default']));\n      let output = await run(b);\n      assert(/foo\\.[a-f0-9]+\\.png$/.test(output));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can reexport urls to raw assets","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1375,"column":39,"index":67090},"line":1375,"code":"    it('can reexport urls to raw assets', async () => {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/raw-url/index-reexport.js'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'index-reexport.js', './reexports'))), new Set(['assetUrl']));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(findDependency(b, 'reexports.js', 'url:./foo.png'))), new Set(['default']));\n      let output = await run(b);\n      assert(/foo\\.[a-f0-9]+\\.png$/.test(output));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should wrap modules in shared bundles","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1382,"column":45,"index":67621},"line":1382,"code":"    it('should wrap modules in shared bundles', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5659\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/shared-bundle-side-effect-order/index.js'), {\n        mode: 'production'\n      });\n      let sideEffects = [];\n      let res = await run(b, {\n        sideEffect(out) {\n          sideEffects.push(out);\n        }\n      });\n      await res;\n      assert.deepEqual(sideEffects, ['shared1', 'run1 1', 'shared2', 'run2 2']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ensure that modules are only executed once in shared bundles","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1396,"column":75,"index":68188},"line":1396,"code":"    it('should ensure that modules are only executed once in shared bundles', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5659\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/shared-bundle-side-effect-duplication/index.js'), {\n        mode: 'production'\n      });\n      let sideEffects = [];\n      let res = await run(b, {\n        sideEffect(out) {\n          sideEffects.push(out);\n        }\n      });\n      await res;\n      assert.deepEqual(sideEffects, ['v']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when assigning to a named import","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1410,"column":53,"index":68702},"line":1410,"code":"    it('should error when assigning to a named import', async function () {\n      let source = path.join(__dirname, 'integration/scope-hoisting/es6/import-local-assign/named.js');\n      await assert.rejects(() => bundle(source), {\n        name: 'BuildError',\n        message: 'Assignment to an import specifier is not allowed',\n        diagnostics: [{\n          message: 'Assignment to an import specifier is not allowed',\n          origin: '@parcel/transformer-js',\n          codeFrames: [{\n            filePath: source,\n            codeHighlights: [{\n              message: null,\n              start: {\n                line: 2,\n                column: 1\n              },\n              end: {\n                line: 2,\n                column: 3\n              }\n            }, {\n              message: 'Originally imported here',\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 11\n              }\n            }]\n          }],\n          hints: null\n        }]\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when assigning to a default import","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1446,"column":55,"index":69793},"line":1446,"code":"    it('should error when assigning to a default import', async function () {\n      let source = path.join(__dirname, 'integration/scope-hoisting/es6/import-local-assign/default.js');\n      await assert.rejects(() => bundle(source), {\n        name: 'BuildError',\n        message: 'Assignment to an import specifier is not allowed',\n        diagnostics: [{\n          message: 'Assignment to an import specifier is not allowed',\n          origin: '@parcel/transformer-js',\n          codeFrames: [{\n            filePath: source,\n            codeHighlights: [{\n              message: null,\n              start: {\n                line: 2,\n                column: 1\n              },\n              end: {\n                line: 2,\n                column: 1\n              }\n            }, {\n              message: 'Originally imported here',\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 8\n              }\n            }]\n          }],\n          hints: null\n        }]\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error when assigning to a namespace import","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1482,"column":57,"index":70887},"line":1482,"code":"    it('should error when assigning to a namespace import', async function () {\n      let source = path.join(__dirname, 'integration/scope-hoisting/es6/import-local-assign/namespace.js');\n      await assert.rejects(() => bundle(source), {\n        name: 'BuildError',\n        message: 'Assignment to an import specifier is not allowed',\n        diagnostics: [{\n          message: 'Assignment to an import specifier is not allowed',\n          origin: '@parcel/transformer-js',\n          codeFrames: [{\n            filePath: source,\n            codeHighlights: [{\n              message: null,\n              start: {\n                line: 2,\n                column: 1\n              },\n              end: {\n                line: 2,\n                column: 1\n              }\n            }, {\n              message: 'Originally imported here',\n              start: {\n                line: 1,\n                column: 13\n              },\n              end: {\n                line: 1,\n                column: 13\n              }\n            }]\n          }],\n          hints: null\n        }]\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error with a destructuring assignment to a namespace import","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1518,"column":74,"index":72002},"line":1518,"code":"    it('should error with a destructuring assignment to a namespace import', async function () {\n      let source = path.join(__dirname, 'integration/scope-hoisting/es6/import-local-assign/destructure-assign.js');\n      await assert.rejects(() => bundle(source), {\n        name: 'BuildError',\n        message: 'Assignment to an import specifier is not allowed',\n        diagnostics: [{\n          message: 'Assignment to an import specifier is not allowed',\n          origin: '@parcel/transformer-js',\n          codeFrames: [{\n            filePath: source,\n            codeHighlights: [{\n              message: null,\n              start: {\n                line: 2,\n                column: 8\n              },\n              end: {\n                line: 2,\n                column: 10\n              }\n            }, {\n              message: 'Originally imported here',\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 11\n              }\n            }]\n          }],\n          hints: null\n        }]\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should error with multiple assignments to an import","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1554,"column":59,"index":73111},"line":1554,"code":"    it('should error with multiple assignments to an import', async function () {\n      let source = path.join(__dirname, 'integration/scope-hoisting/es6/import-local-assign/multiple.js');\n      await assert.rejects(() => bundle(source), {\n        name: 'BuildError',\n        message: 'Assignment to an import specifier is not allowed',\n        diagnostics: [{\n          message: 'Assignment to an import specifier is not allowed',\n          origin: '@parcel/transformer-js',\n          codeFrames: [{\n            filePath: source,\n            codeHighlights: [{\n              message: null,\n              start: {\n                line: 2,\n                column: 1\n              },\n              end: {\n                line: 2,\n                column: 3\n              }\n            }, {\n              message: null,\n              start: {\n                line: 3,\n                column: 1\n              },\n              end: {\n                line: 3,\n                column: 3\n              }\n            }, {\n              message: 'Originally imported here',\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 11\n              }\n            }]\n          }],\n          hints: null\n        }]\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should allow re-declaring __esModule interop flag","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1600,"column":57,"index":74432},"line":1600,"code":"    it('should allow re-declaring __esModule interop flag', async function () {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/double-esmodule/index.js'));\n      let res = await run(b);\n      assert.deepEqual(res, 'default');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can dynamically import a side-effect-free reexport","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1605,"column":58,"index":74700},"line":1605,"code":"    it('can dynamically import a side-effect-free reexport', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/conditional-import-side-effect-free-reexport/index.mjs'));\n      assert.deepEqual(await run(b), 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"individually exports symbols from intermediately wrapped reexports","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1609,"column":74,"index":74980},"line":1609,"code":"    it('individually exports symbols from intermediately wrapped reexports', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/export-intermediate-wrapped-reexports/index.mjs'));\n      let res = await Promise.all(await run(b));\n      assert.deepEqual(res, [42, 42]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should treat type-only TypeScript modules as ESM","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1614,"column":56,"index":75281},"line":1614,"code":"    it('should treat type-only TypeScript modules as ESM', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/empty-ts/index.ts'));\n      let test = await run(b);\n      assert.equal(test({\n        foo: 2\n      }), 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not include default when reexporting * without $parcel$exportWildcard","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1621,"column":84,"index":75578},"line":1621,"code":"    it('should not include default when reexporting * without $parcel$exportWildcard', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/no-reexport-default/index.js'));\n      assert.equal(await run(b), 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not include __esModule when reexporting * without $parcel$exportWildcard","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1625,"column":87,"index":75841},"line":1625,"code":"    it('should not include __esModule when reexporting * without $parcel$exportWildcard', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/no-reexport-esmodule/index.js'));\n      assert.equal(await run(b), undefined);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle interop with a re-export namespace","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1629,"column":56,"index":76081},"line":1629,"code":"    it('should handle interop with a re-export namespace', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/re-export-interop/a.js'));\n      let res = await run(b);\n      assert.deepEqual(res['en_US'], {\n        test: 'foo'\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should prioritize named exports before re-exports (before)","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1636,"column":66,"index":76378},"line":1636,"code":"    it('should prioritize named exports before re-exports (before)', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/re-export-priority/entry-a.mjs'));\n      let res = await run(b);\n      assert.equal(res, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should prioritize named exports before re-exports (after)","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1641,"column":65,"index":76641},"line":1641,"code":"    it('should prioritize named exports before re-exports (after)', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/re-export-priority/entry-b.mjs'));\n      let res = await run(b);\n      assert.equal(res, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should prioritize named exports before re-exports in namespace (before)","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1646,"column":79,"index":76918},"line":1646,"code":"    it('should prioritize named exports before re-exports in namespace (before)', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/re-export-priority/namespace-a.mjs'));\n      let res = await run(b);\n      assert.deepEqual(res, {\n        foo: 2\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should prioritize named exports before re-exports in namespace (after)","suites":["scope hoisting","es6","correctly updates used symbols on changes"],"updatePoint":{"line":1653,"column":78,"index":77225},"line":1653,"code":"    it('should prioritize named exports before re-exports in namespace (after)', async () => {\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/re-export-priority/namespace-b.mjs'));\n      let res = await run(b);\n      assert.deepEqual(res, {\n        foo: 2\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of commonjs modules","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1662,"column":44,"index":77541},"line":1662,"code":"    it('supports require of commonjs modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"concats commonjs modules in the correct order","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1667,"column":53,"index":77792},"line":1667,"code":"    it('concats commonjs modules in the correct order', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/concat-order/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports default imports of commonjs modules","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1672,"column":52,"index":78047},"line":1672,"code":"    it('supports default imports of commonjs modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/default-import/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"concats modules with inserted globals in the correct order","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1677,"column":66,"index":78318},"line":1677,"code":"    it('concats modules with inserted globals in the correct order', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/concat-order-globals/a.js'));\n      let output = await run(b);\n      assert.equal(output, 'foobar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports named imports of commonjs modules","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1682,"column":50,"index":78586},"line":1682,"code":"    it('supports named imports of commonjs modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/named-import/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports namespace imports of commonjs modules","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1687,"column":54,"index":78843},"line":1687,"code":"    it('supports namespace imports of commonjs modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/import-namespace/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of es6 default export of expressions","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1692,"column":61,"index":79111},"line":1692,"code":"    it('supports require of es6 default export of expressions', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-default-export-expression/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of es6 default export of declarations","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1697,"column":62,"index":79397},"line":1697,"code":"    it('supports require of es6 default export of declarations', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-default-export-declaration/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of es6 default export of variables","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1702,"column":59,"index":79681},"line":1702,"code":"    it('supports require of es6 default export of variables', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-default-export-variable/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of es6 named export of declarations","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1707,"column":60,"index":79963},"line":1707,"code":"    it('supports require of es6 named export of declarations', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-named-export-declaration/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of es6 named export of variables","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1712,"column":57,"index":80243},"line":1712,"code":"    it('supports require of es6 named export of variables', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-named-export-variable/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of es6 renamed exports","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1717,"column":47,"index":80510},"line":1717,"code":"    it('supports require of es6 renamed exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-renamed-export/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of es6 module re-exporting all exports from another module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1722,"column":83,"index":80806},"line":1722,"code":"    it('supports require of es6 module re-exporting all exports from another module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-re-export-all/a.js'));\n      let output = await run(b);\n      assert.equal(output, 6);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require of es6 module re-exporting all exports from multiple modules","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1727,"column":85,"index":81103},"line":1727,"code":"    it('supports require of es6 module re-exporting all exports from multiple modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-re-export-multiple/a.js'));\n      let output = await run(b);\n      assert.equal(output, 7);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting individual named exports from another module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1732,"column":74,"index":81394},"line":1732,"code":"    it('supports re-exporting individual named exports from another module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-re-export-named/a.js'));\n      let output = await run(b);\n      assert.equal(output, 3);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting default exports from another module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1737,"column":65,"index":81673},"line":1737,"code":"    it('supports re-exporting default exports from another module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-re-export-default/a.js'));\n      let output = await run(b);\n      assert.equal(output, 3);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports re-exporting a namespace from another module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1742,"column":61,"index":81950},"line":1742,"code":"    it('supports re-exporting a namespace from another module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-re-export-namespace/a.js'));\n      let output = await run(b);\n      assert.equal(output, 6);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"excludes default when re-exporting a module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1747,"column":51,"index":82219},"line":1747,"code":"    it('excludes default when re-exporting a module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-re-export-exclude-default/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        foo: 3\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports hybrid ES6 + commonjs modules","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1754,"column":46,"index":82516},"line":1754,"code":"    it('supports hybrid ES6 + commonjs modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/es6-commonjs-hybrid/a.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"inserts commonjs exports object in the right place","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1759,"column":58,"index":82784},"line":1759,"code":"    it('inserts commonjs exports object in the right place', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/export-order/a.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out exports access resolving if it is accessed freely (exports assign)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1764,"column":84,"index":83071},"line":1764,"code":"    it('bails out exports access resolving if it is accessed freely (exports assign)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/exports-assign.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out exports access resolving if it is accessed freely (exports define)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1769,"column":84,"index":83381},"line":1769,"code":"    it('bails out exports access resolving if it is accessed freely (exports define)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/exports-define.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out exports access resolving if it is accessed freely (module.exports assign)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1774,"column":91,"index":83698},"line":1774,"code":"    it('bails out exports access resolving if it is accessed freely (module.exports assign)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/module-exports-assign.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out exports access resolving if it is accessed freely (module.exports define)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1779,"column":91,"index":84022},"line":1779,"code":"    it('bails out exports access resolving if it is accessed freely (module.exports define)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/module-exports-define.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out imported exports access resolving if it is accessed freely (exports assign)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1784,"column":93,"index":84348},"line":1784,"code":"    it('bails out imported exports access resolving if it is accessed freely (exports assign)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/exports-assign-entry.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out imported exports access resolving if it is accessed freely (exports define)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1789,"column":93,"index":84673},"line":1789,"code":"    it('bails out imported exports access resolving if it is accessed freely (exports define)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/exports-define-entry.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out imported exports access resolving if it is accessed freely (module.exports assign)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1794,"column":100,"index":85005},"line":1794,"code":"    it('bails out imported exports access resolving if it is accessed freely (module.exports assign)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/module-exports-assign-entry.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out imported exports access resolving if it is accessed freely (module.exports define)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1799,"column":100,"index":85344},"line":1799,"code":"    it('bails out imported exports access resolving if it is accessed freely (module.exports define)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/module-exports-define-entry.js'));\n      let output = await run(b);\n      assert.equal(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"bails out imported exports access resolving if it is accessed freely (exports reexport)","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1804,"column":95,"index":85678},"line":1804,"code":"    it('bails out imported exports access resolving if it is accessed freely (exports reexport)', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-access-bailout/exports-assign-reexport-entry.js'));\n      let output = await run(b);\n      assert.deepEqual(output, [5, 5]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"builds commonjs modules that assigns to exports before module.exports","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1809,"column":77,"index":86005},"line":1809,"code":"    it('builds commonjs modules that assigns to exports before module.exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-before-module-exports/a.js'));\n      let output = await run(b);\n      assert.equal(output, 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"builds commonjs modules that assigns to module.exports before exports","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1814,"column":77,"index":86303},"line":1814,"code":"    it('builds commonjs modules that assigns to module.exports before exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/module-exports-before-exports/a.js'));\n      let output = await run(b);\n      assert.equal(output, 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support assigning to module.exports with another export","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1819,"column":70,"index":86594},"line":1819,"code":"    it('should support assigning to module.exports with another export', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5782\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/module-exports-default-assignment/index.js'));\n      let output = await run(b);\n      assert.equal(output.foo, 'b');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"doesn't insert parcelRequire for missing non-js assets","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1825,"column":62,"index":86952},"line":1825,"code":"    it(\"doesn't insert parcelRequire for missing non-js assets\", async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/missing-non-js/a.js'));\n      let output = await run(b);\n      assert.equal(output, 27);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"define exports in the outermost scope","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1830,"column":45,"index":87203},"line":1830,"code":"    it('define exports in the outermost scope', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/define-exports/a.js'));\n      assert.deepStrictEqual(new Set(b.getUsedSymbols(nullthrows(findAsset(b, 'a.js')))), new Set(['*']));\n      let output = await run(b);\n      assert.equal(output, 'bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports live bindings of named exports","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1836,"column":47,"index":87566},"line":1836,"code":"    it('supports live bindings of named exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/live-bindings/a.js'));\n      let output = await run(b);\n      assert.equal(output, 8);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should wrap modules that use eval in a function","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1841,"column":55,"index":87825},"line":1841,"code":"    it('should wrap modules that use eval in a function', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-eval/a.js'));\n      let output = await run(b);\n      assert.equal(output, 4);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should wrap modules that have a top-level return","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1846,"column":56,"index":88081},"line":1846,"code":"    it('should wrap modules that have a top-level return', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-return/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove unused exports assignments for wrapped modules","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1851,"column":68,"index":88351},"line":1851,"code":"    it('should remove unused exports assignments for wrapped modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-unused/a.js'));\n      let output = await run(b);\n      assert.equal(output, 1);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should hoist all vars in the scope","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1856,"column":42,"index":88595},"line":1856,"code":"    it('should hoist all vars in the scope', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-var-hoisting/a.js'));\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.split('f1_var').length - 1, 1);\n      assert(contents.split('f2_var').length - 1, 1);\n      assert(contents.split('f3_var').length - 1, 1);\n      assert(contents.split('f4_var').length - 1, 1);\n      assert(contents.split('c1_var').length - 1, 1);\n      assert(contents.split('c2_var').length - 1, 1);\n      assert(contents.split('BigIntSupported').length - 1, 4);\n      assert(contents.split('inner_let').length - 1, 2);\n      let output = await run(b);\n      assert.equal(output, true);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should wrap modules that access `module` as a free variable","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1870,"column":67,"index":89399},"line":1870,"code":"    it('should wrap modules that access `module` as a free variable', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-module/a.js'));\n      assert.deepEqual((await run(b)).exports, {\n        foo: 2\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should call init for wrapped modules when codesplitting","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1876,"column":63,"index":89674},"line":1876,"code":"    it('should call init for wrapped modules when codesplitting', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-module-codesplit/a.js'));\n      assert.deepEqual(await run(b), 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should wrap modules that non-statically access `module`","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1880,"column":63,"index":89926},"line":1880,"code":"    it('should wrap modules that non-statically access `module`', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-module-computed/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        foo: 2\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support referencing a require in object literal shorthands when wrapped","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1887,"column":86,"index":90250},"line":1887,"code":"    it('should support referencing a require in object literal shorthands when wrapped', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-module-obj-literal-require/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 1234);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support typeof require when wrapped","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1892,"column":50,"index":90531},"line":1892,"code":"    it('should support typeof require when wrapped', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5883\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-typeof-require/a.js'));\n      let output = await run(b);\n      assert.equal(output, 'c1');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not rename function local variables according to global replacements","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1898,"column":83,"index":90889},"line":1898,"code":"    it('should not rename function local variables according to global replacements', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/keep-local-function-var/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'foo');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports using this in arrow functions","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1903,"column":46,"index":91157},"line":1903,"code":"    it('supports using this in arrow functions', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/this-arrow-function/a.js'));\n      let content = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(content.includes('=>'));\n      let output = await run(b);\n      assert.strictEqual(output, 'Say other');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports assigning to this as exports object","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1910,"column":52,"index":91554},"line":1910,"code":"    it('supports assigning to this as exports object', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/this-reference/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports assigning to this as exports object in wrapped module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1915,"column":70,"index":91835},"line":1915,"code":"    it('supports assigning to this as exports object in wrapped module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/this-reference-wrapped/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 6);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports using exports self reference","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1920,"column":45,"index":92099},"line":1920,"code":"    it('supports using exports self reference', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/exports-self-reference/a.js'));\n      let content = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(content.includes('=>'));\n      let output = await run(b);\n      assert.strictEqual(output, 'Say other');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports using module.exports self reference","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1927,"column":52,"index":92499},"line":1927,"code":"    it('supports using module.exports self reference', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/module-exports-self-reference/a.js'));\n      let content = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(content.includes('=>'));\n      let output = await run(b);\n      assert.strictEqual(output, 'Say other');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports using module.require like require","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1934,"column":50,"index":92904},"line":1934,"code":"    it('supports using module.require like require', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/module-require/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output.b, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"support url imports in wrapped modules with interop","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1939,"column":59,"index":93176},"line":1939,"code":"    it('support url imports in wrapped modules with interop', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-interop-url-import/a.js'));\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['a.js', 'b.js', 'bundle-url.js']\n      }, {\n        type: 'txt',\n        assets: ['data.txt']\n      }]);\n      let output = await run(b);\n      assert(output.endsWith('.txt'));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports module object properties","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1951,"column":41,"index":93607},"line":1951,"code":"    it('supports module object properties', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/module-object/a.js'));\n      let entryAsset = b.getBundles()[0].getMainEntry();\n\n      // TODO: this test doesn't currently work in older browsers since babel\n      // replaces the typeof calls before we can get to them.\n      let output = await run(b);\n      assert.equal(output.id, b.getAssetPublicId(entryAsset));\n      assert.equal(output.hot, null);\n      assert.equal(output.moduleRequire, null);\n      assert.equal(output.type, 'object');\n      assert.deepEqual(output.exports, {});\n      assert.equal(output.exportsType, 'object');\n      assert.equal(output.require, 'function');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"doesn't support require.resolve calls for included assets","suites":["scope hoisting","commonjs"],"line":1966,"code":"    it.skip(\"doesn't support require.resolve calls for included assets\", async function () {","file":"scope-hoisting.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"supports mutations of the exports object by the importer","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1992,"column":64,"index":95225},"line":1992,"code":"    it('supports mutations of the exports object by the importer', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/mutated-exports-object-importer/index.js'));\n      assert.deepEqual(await run(b), [43, {\n        foo: 43\n      }]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports mutations of the exports object by a different asset","suites":["scope hoisting","commonjs"],"updatePoint":{"line":1998,"column":69,"index":95527},"line":1998,"code":"    it('supports mutations of the exports object by a different asset', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/mutated-exports-object-different/index.js'));\n      assert.equal(await run(b), 43);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports mutations of the exports object inside an expression","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2002,"column":69,"index":95797},"line":2002,"code":"    it('supports mutations of the exports object inside an expression', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/mutated-exports-object-expression/index.js'));\n      assert.deepEqual(await run(b), [{\n        foo: 3\n      }, 3, 3]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports non-static mutations of the exports object","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2008,"column":59,"index":96092},"line":2008,"code":"    it('supports non-static mutations of the exports object', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5591\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/mutated-non-static-require/index.js'));\n      assert.deepEqual(await run(b), 4);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports require.resolve calls for excluded modules","suites":["scope hoisting","commonjs"],"line":2013,"code":"    it.skip('supports require.resolve calls for excluded modules', async function () {","file":"scope-hoisting.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should support assets requiring themselves","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2022,"column":50,"index":96782},"line":2022,"code":"    it('should support assets requiring themselves', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-self/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output, 4);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports requiring a re-exported ES6 import","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2027,"column":51,"index":97042},"line":2027,"code":"    it('supports requiring a re-exported ES6 import', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/re-export-var/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 'foobar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports object pattern requires","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2032,"column":40,"index":97297},"line":2032,"code":"    it('supports object pattern requires', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/object-pattern/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 5);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"eliminates CommonJS export object where possible","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2037,"column":56,"index":97562},"line":2037,"code":"    it('eliminates CommonJS export object where possible', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/eliminate-exports/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 6);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports multiple assignments in one line","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2042,"column":49,"index":97823},"line":2042,"code":"    it('supports multiple assignments in one line', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/multi-assign/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        foo: 2,\n        bar: 2,\n        baz: 2\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports circular dependencies","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2051,"column":38,"index":98123},"line":2051,"code":"    it('supports circular dependencies', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-circular/a.js'));\n      let output = await run(b);\n      assert.equal(output, 'foo bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"executes modules in the correct order","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2056,"column":45,"index":98383},"line":2056,"code":"    it('executes modules in the correct order', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-execution-order/a.js'));\n      let out = [];\n      await run(b, {\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, ['a', 'b', 'c', 'd']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports conditional requires","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2066,"column":37,"index":98725},"line":2066,"code":"    it('supports conditional requires', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-conditional/a.js'));\n      let out = [];\n      await run(b, {\n        b: false,\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, ['a', 'd']);\n      out = [];\n      await run(b, {\n        b: true,\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, ['a', 'b', 'c', 'd']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports requiring a CSS asset","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2085,"column":38,"index":99240},"line":2085,"code":"    it('supports requiring a CSS asset', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-css/a.js'));\n      assertBundles(b, [{\n        name: 'a.js',\n        assets: ['a.js']\n      }, {\n        type: 'css',\n        assets: ['b.css']\n      }]);\n      await run(b);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports requires inside functions","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2096,"column":42,"index":99582},"line":2096,"code":"    it('supports requires inside functions', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-in-function/a.js'));\n      let out = [];\n      await run(b, {\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, ['a', 'c', 'b']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports requires inside functions with es6 import side effects","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2106,"column":71,"index":99949},"line":2106,"code":"    it('supports requires inside functions with es6 import side effects', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-in-function-import/a.js'));\n      let out = [];\n      await run(b, {\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, ['a', 'd', 'c', 'b']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"hoists import calls to the top","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2116,"column":38,"index":100295},"line":2116,"code":"    it('hoists import calls to the top', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-in-function-import-hoist/a.js'));\n      let out = [];\n      await run(b, {\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, ['a', 'd', 'c', 'b']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports requires inside functions with es6 re-export side effects","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2126,"column":74,"index":100683},"line":2126,"code":"    it('supports requires inside functions with es6 re-export side effects', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-in-function-reexport/a.js'));\n      let out = [];\n      await run(b, {\n        output(o) {\n          out.push(o);\n        }\n      });\n      assert.deepEqual(out, ['a', 'd', 'c', 'b']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can bundle the node stream module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2136,"column":41,"index":101034},"line":2136,"code":"    it('can bundle the node stream module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/stream-module/a.js'));\n      let res = await run(b);\n      assert.equal(typeof res.Readable, 'function');\n      assert.equal(typeof res.Writable, 'function');\n      assert.equal(typeof res.Duplex, 'function');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"missing exports should be replaced with an empty object","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2143,"column":63,"index":101424},"line":2143,"code":"    it('missing exports should be replaced with an empty object', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/empty-module/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        b: {}\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes unused exports","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2150,"column":30,"index":101683},"line":2150,"code":"    it('removes unused exports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/tree-shaking/a.js'), {\n        mode: 'production'\n      });\n      let output = await run(b);\n      assert.deepEqual(output, 2);\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('foo'));\n      assert(!contents.includes('bar'));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"removes unused exports when assigning with a string literal","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2160,"column":67,"index":102158},"line":2160,"code":"    it('removes unused exports when assigning with a string literal', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/tree-shaking-string/a.js'), {\n        mode: 'production'\n      });\n      let output = await run(b);\n      assert.deepEqual(output, [2, 20]);\n      let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n      assert(contents.includes('foo'));\n      assert(!contents.includes('bar'));\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports removing an unused inline export with uglify minification","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2170,"column":74,"index":102653},"line":2170,"code":"    it('supports removing an unused inline export with uglify minification', async function () {\n      // Uglify does strange things to multiple assignments in a line.\n      // See https://github.com/parcel-bundler/parcel/issues/1549\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/export-local/a.js'), {\n        defaultTargetOptions: {\n          shouldOptimize: true\n        }\n      });\n      let output = await run(b);\n      assert.deepEqual(output, 3);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support sideEffects: false","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2181,"column":41,"index":103122},"line":2181,"code":"    it('should support sideEffects: false', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/side-effects-false/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 9);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can bundle browserify-produced umd bundles","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2186,"column":50,"index":103385},"line":2186,"code":"    it('can bundle browserify-produced umd bundles', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/browserify-compat/index.js'));\n      assert.equal(await run(b), 'foo');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"replaces properties of require with undefined","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2190,"column":53,"index":103627},"line":2190,"code":"    it('replaces properties of require with undefined', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-extensions/index.js'));\n      await run(b);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support two aliases to the same module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2194,"column":53,"index":103849},"line":2194,"code":"    it('should support two aliases to the same module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-aliases/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should retain the correct concat order with wrapped assets","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2199,"column":66,"index":104123},"line":2199,"code":"    it('should retain the correct concat order with wrapped assets', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-concat-order/a.js'));\n      let calls = [];\n      await run(b, {\n        sideEffect(v) {\n          calls.push(v);\n        }\n      });\n      assert.deepStrictEqual(calls, [1, 2, 3, 4, 5, 6, 7]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support optional requires","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2209,"column":40,"index":104479},"line":2209,"code":"    it('should support optional requires', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-optional/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert __esModule interop flag when importing from an ES module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2214,"column":78,"index":104766},"line":2214,"code":"    it('should insert __esModule interop flag when importing from an ES module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/interop-require-es-module/a.js'));\n      let output = await run(b);\n      assert.equal(output.__esModule, true);\n      assert.equal(output.default, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should export the same values for interop shared modules in main and child bundle","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2220,"column":89,"index":105124},"line":2220,"code":"    it('should export the same values for interop shared modules in main and child bundle', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/interop-require-es-module-code-split/main.js'));\n      assert.equal(await run(b), 'bar:bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should export the same values for interop shared modules in main and child bundle if shared bundle is deep nested","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2224,"column":121,"index":105456},"line":2224,"code":"    it('should export the same values for interop shared modules in main and child bundle if shared bundle is deep nested', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/interop-require-es-module-code-split-intermediate/main.js'));\n      assert.equal(await run(b), 'bar:bar');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not insert interop default for commonjs modules with default export","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2228,"column":82,"index":105762},"line":2228,"code":"    it('should not insert interop default for commonjs modules with default export', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/interop-require-commonjs/a.js'));\n      let output = await run(b);\n      let obj = {\n        test: 2\n      };\n      obj.default = obj;\n      assert.deepEqual(output.default, obj);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should add a default interop for a CJS module used in a hybrid module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2237,"column":77,"index":106136},"line":2237,"code":"    it('should add a default interop for a CJS module used in a hybrid module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/interop-commonjs-hybrid/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should add a default interop for a CJS module used non-statically in a hybrid module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2242,"column":92,"index":106442},"line":2242,"code":"    it('should add a default interop for a CJS module used non-statically in a hybrid module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/interop-commonjs-hybrid-dynamic/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not insert default interop for wrapped CJS modules","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2247,"column":65,"index":106729},"line":2247,"code":"    it('should not insert default interop for wrapped CJS modules', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/interop-require-commonjs-wrapped/a.js'));\n      let output = await run(b);\n      assert.equal(output, 'default');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support multiple requires in the same variable declaration","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2252,"column":73,"index":107033},"line":2252,"code":"    it('should support multiple requires in the same variable declaration', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-multiple/a.js'));\n      let output = await run(b);\n      assert.equal(output, 'before foo middle bar after');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support assigning to exports from inside a function","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2257,"column":66,"index":107334},"line":2257,"code":"    it('should support assigning to exports from inside a function', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/export-assign-scope/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should also hoist inserted polyfills of globals","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2262,"column":55,"index":107603},"line":2262,"code":"    it('should also hoist inserted polyfills of globals', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/globals-polyfills/a.js'));\n      let output = await run(b);\n      assert.equal(output, true);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support wrapping array destructuring declarations","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2267,"column":64,"index":107878},"line":2267,"code":"    it('should support wrapping array destructuring declarations', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-destructuring-array/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, [1, 2]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support wrapping object destructuring declarations","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2272,"column":65,"index":108167},"line":2272,"code":"    it('should support wrapping object destructuring declarations', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-destructuring-object/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, [4, 2]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not tree-shake assignments to unknown objects","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2277,"column":58,"index":108450},"line":2277,"code":"    it('does not tree-shake assignments to unknown objects', async () => {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/tree-shaking-no-unknown-objects/index.js'));\n      assert.equal(await run(b), 42);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can conditionally reference an imported symbol and unconditionally reference it","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2281,"column":87,"index":108731},"line":2281,"code":"    it('can conditionally reference an imported symbol and unconditionally reference it', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/conditional-import-reference/index.js'));\n      let output = await run(b);\n      assert.equal(output, 'hello');\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports assigning to the result of a require","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2286,"column":53,"index":109013},"line":2286,"code":"    it('supports assigning to the result of a require', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-assign/a.js'));\n      let output = await run(b);\n      assert.equal(output, 4);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"supports both static and non-static exports in the same module with self-reference","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2291,"column":90,"index":109308},"line":2291,"code":"    it('supports both static and non-static exports in the same module with self-reference', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/non-static-exports/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        foo: 2,\n        bar: 4,\n        baz: 6\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not replace assignments to the exports object in the same module","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2300,"column":77,"index":109653},"line":2300,"code":"    it('does not replace assignments to the exports object in the same module', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/self-reference-assignment/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output, {\n        foo: {\n          bar: 'bar'\n        }\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"replaces static require member expressions with the correct `this` context","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2309,"column":82,"index":110009},"line":2309,"code":"    it('replaces static require member expressions with the correct `this` context', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-member-wrapped/a.js'));\n      let output = await run(b);\n      assert.deepEqual(output(), {\n        foo: 2,\n        bar: 4\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not create a self-referencing dependency for the default symbol without an __esModule flag","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2317,"column":103,"index":110370},"line":2317,"code":"    it('does not create a self-referencing dependency for the default symbol without an __esModule flag', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/self-reference-default/a.js'));\n      let output = await run(b);\n      assert.equal(output, 2);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ensure that side effect ordering is correct in sequence expressions with require","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2322,"column":95,"index":110678},"line":2322,"code":"    it('should ensure that side effect ordering is correct in sequence expressions with require', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5606\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/commonjs/wrap-expressions/a.js'));\n      let sideEffects = [];\n      let res = await run(b, {\n        sideEffect(out) {\n          sideEffects.push(out);\n        }\n      });\n      await res;\n      assert.deepEqual(sideEffects, ['before', 'require', 'after']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ensure that side effect ordering is correct in binary expressions with require","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2334,"column":93,"index":111199},"line":2334,"code":"    it('should ensure that side effect ordering is correct in binary expressions with require', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5606\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/commonjs/wrap-expressions/b.js'));\n      let sideEffects = [];\n      let res = await run(b, {\n        sideEffect(out) {\n          sideEffects.push(out);\n        }\n      });\n      await res;\n      assert.deepEqual(sideEffects, ['before', 'require', 'after']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ensure that side effect ordering is correct with default interop","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2346,"column":79,"index":111706},"line":2346,"code":"    it('should ensure that side effect ordering is correct with default interop', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5662\n      let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/commonjs/wrap-default-interop/index.js'));\n      let sideEffects = [];\n      let res = await run(b, {\n        sideEffect(out) {\n          sideEffects.push(out);\n        }\n      });\n      await res;\n      assert.deepEqual(sideEffects, ['shared', 'run1', 'async c: 123']);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support non-object module.exports","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2358,"column":48,"index":112194},"line":2358,"code":"    it('should support non-object module.exports', async function () {\n      // https://github.com/parcel-bundler/parcel/issues/5892\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/export-non-object/index.js'));\n      await run(b, null, {\n        strict: true\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support assignment to a local variable with require","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2365,"column":66,"index":112528},"line":2365,"code":"    it('should support assignment to a local variable with require', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-local-assign/basic.js'));\n      let outputs = [];\n      await run(b, {\n        output(x) {\n          outputs.push(x);\n        }\n      });\n      assert.deepEqual(outputs, [[{\n        foo: 2\n      }, {\n        foo: 2\n      }], [4, {\n        foo: 2\n      }]]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support out of order assignment to a local variable with require","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2381,"column":79,"index":112990},"line":2381,"code":"    it('should support out of order assignment to a local variable with require', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-local-assign/in-function.js'));\n      let outputs = [];\n      await run(b, {\n        output(x) {\n          outputs.push(x);\n        }\n      });\n      assert.deepEqual(outputs, [[{\n        foo: 2\n      }, {\n        foo: 2\n      }], [4, {\n        foo: 2\n      }]]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support assignment to a local variable with require and member expression","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2397,"column":88,"index":113467},"line":2397,"code":"    it('should support assignment to a local variable with require and member expression', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-local-assign/member.js'));\n      let outputs = [];\n      await run(b, {\n        output(x) {\n          outputs.push(x);\n        }\n      });\n      assert.deepEqual(outputs, [[2, 2], [4, 2]]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support assignment to a local variable with require and destructuring","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2407,"column":84,"index":113866},"line":2407,"code":"    it('should support assignment to a local variable with require and destructuring', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-local-assign/destructure.js'));\n      let outputs = [];\n      await run(b, {\n        output(x) {\n          outputs.push(x);\n        }\n      });\n      assert.deepEqual(outputs, [[2, 2], [4, 2]]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support assignment to a local variable with require and non-static access","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2417,"column":88,"index":114274},"line":2417,"code":"    it('should support assignment to a local variable with require and non-static access', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-local-assign/destructure.js'));\n      let outputs = [];\n      await run(b, {\n        output(x) {\n          outputs.push(x);\n        }\n      });\n      assert.deepEqual(outputs, [[2, 2], [4, 2]]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle require as the callee in a new expression","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2427,"column":63,"index":114657},"line":2427,"code":"    it('should handle require as the callee in a new expression', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-new/a.js'));\n      let output = await run(b);\n      assert.strictEqual(output.foo(), 1);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not update mutated destructured requires","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2432,"column":55,"index":114926},"line":2432,"code":"    it('should not update mutated destructured requires', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-non-const-export/destructure.js'));\n      let outputs = [];\n      await run(b, {\n        output(x) {\n          outputs.push(x);\n        }\n      });\n      assert.deepEqual(outputs, [2, 2]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not update mutated require members","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2442,"column":49,"index":115289},"line":2442,"code":"    it('should not update mutated require members', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-non-const-export/member.js'));\n      let outputs = [];\n      await run(b, {\n        output(x) {\n          outputs.push(x);\n        }\n      });\n      assert.deepEqual(outputs, [2, 2]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should update live mutated require members","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2452,"column":50,"index":115648},"line":2452,"code":"    it('should update live mutated require members', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/require-non-const-export/live.js'));\n      let outputs = [];\n      await run(b, {\n        output(x) {\n          outputs.push(x);\n        }\n      });\n      assert.deepEqual(outputs, [2, 3]);\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should wrap all assets with an incoming wrapped dependency","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2462,"column":66,"index":116021},"line":2462,"code":"    it('should wrap all assets with an incoming wrapped dependency', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/commonjs/wrap-deps-circular/index.js'));\n      assert.deepEqual(await run(b), {\n        test: 2\n      });\n    });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not throw with JS included from HTML","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2469,"column":49,"index":116290},"line":2469,"code":"  it('should not throw with JS included from HTML', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js', 'other.js']\n    }]);\n    let asset = nullthrows(findAsset(b, 'other.js'));\n    assert.deepStrictEqual(new Set(b.getUsedSymbols(asset)), new Set(['default']));\n    let value = [];\n    await run(b, {\n      alert: v => value.push(v)\n    });\n    assert.deepEqual(value, ['other']);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not throw with JS dynamic imports included from HTML","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2486,"column":65,"index":116878},"line":2486,"code":"  it('should not throw with JS dynamic imports included from HTML', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-js-dynamic/index.html'));\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }, {\n      type: 'js',\n      assets: ['local.js']\n    }]);\n    let res = await run(b, {\n      output: null\n    }, {\n      require: false\n    });\n    assert.equal(typeof res.output, 'function');\n    assert.equal(await res.output(), 'Imported: foobar');\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should include the prelude in shared entry bundles","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2506,"column":56,"index":117443},"line":2506,"code":"  it('should include the prelude in shared entry bundles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/html-shared/index.html'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }, {\n      name: 'iframe.html',\n      assets: ['iframe.html']\n    }, {\n      type: 'js',\n      assets: ['iframe.js']\n    }, {\n      type: 'js',\n      assets: ['lodash.js']\n    }]);\n    let sharedBundle = b.getBundles().sort((a, b) => b.stats.size - a.stats.size)[0];\n    let contents = await outputFS.readFile(sharedBundle.filePath, 'utf8');\n    assert(contents.includes(`if (parcelRequire == null) {`));\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"does not include prelude if child bundles are isolated","suites":["scope hoisting","commonjs"],"line":2533,"code":"  it.skip('does not include prelude if child bundles are isolated', async function () {","file":"scope-hoisting.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should include prelude in shared worker bundles","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2540,"column":53,"index":118701},"line":2540,"code":"  it('should include prelude in shared worker bundles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/worker-shared/index.js'), {\n      mode: 'production',\n      defaultTargetOptions: {\n        shouldOptimize: false\n      }\n    });\n    let sharedBundle = b.getBundles().sort((a, b) => b.stats.size - a.stats.size).find(b => b.name !== 'index.js');\n    let contents = await outputFS.readFile(sharedBundle.filePath, 'utf8');\n    assert(contents.includes(`if (parcelRequire == null) {`));\n    let workerBundle = b.getBundles().find(b => b.name.startsWith('worker-b'));\n    contents = await outputFS.readFile(workerBundle.filePath, 'utf8');\n    assert(contents.includes(`importScripts(\"./${path.basename(sharedBundle.filePath)}\")`));\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert global variables when needed","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2556,"column":48,"index":119517},"line":2556,"code":"  it('should insert global variables when needed', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/globals/scope-hoisting.js'));\n    let output = await run(b);\n    assert.deepEqual(output(), {\n      dir: 'integration/globals',\n      file: 'integration/globals/index.js',\n      buf: Buffer.from('browser').toString('base64'),\n      global: true\n    });\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should be able to named import a reexported namespace in an async bundle","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2566,"column":78,"index":119937},"line":2566,"code":"  it('should be able to named import a reexported namespace in an async bundle', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/async-named-import-ns-reexport/index.js'));\n    assert.deepEqual(await run(b), [42, 42, 42, 42]);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not remove a binding with a used AssignmentExpression","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2570,"column":66,"index":120209},"line":2570,"code":"  it('should not remove a binding with a used AssignmentExpression', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/used-assignmentexpression/a.js'));\n    assert.strictEqual(await run(b), 3);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should wrap imports inside arrow functions","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2574,"column":48,"index":120441},"line":2574,"code":"  it('should wrap imports inside arrow functions', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/wrap-import-arrowfunction/a.js'));\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes('=>'));\n    let calls = [];\n    let output = await run(b, {\n      sideEffect(id) {\n        calls.push(id);\n      }\n    });\n    assert.deepEqual(calls, []);\n    assert.equal(typeof output, 'function');\n    assert.deepEqual(await output(), {\n      default: 1234\n    });\n    assert.deepEqual(calls, ['async']);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can static import and dynamic import in the same bundle without creating a new bundle","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2591,"column":91,"index":121092},"line":2591,"code":"  it('can static import and dynamic import in the same bundle without creating a new bundle', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/sync-async/same-bundle-scope-hoisting.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'same-bundle-scope-hoisting.js',\n      assets: ['same-bundle-scope-hoisting.js', 'get-dep.js', 'get-dep-2.js', 'dep.js']\n    }]);\n    assert.deepEqual(await await run(b), [42, 42, 42]);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can static import and dynamic import in the same bundle ancestry without creating a new bundle","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2601,"column":100,"index":121576},"line":2601,"code":"  it('can static import and dynamic import in the same bundle ancestry without creating a new bundle', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/sync-async/same-ancestry-scope-hoisting.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'same-ancestry-scope-hoisting.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'dep.js', 'js-loader.js', 'same-ancestry-scope-hoisting.js']\n    }, {\n      assets: ['get-dep.js']\n    }]);\n    assert.deepEqual(await run(b), [42, 42]);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"loads another bundle from a dynamic import with a shared dependency only when necessary","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2613,"column":93,"index":122130},"line":2613,"code":"  it('loads another bundle from a dynamic import with a shared dependency only when necessary', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/sync-async-when-needed/index.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['dep.js']\n    }, {\n      assets: ['async-has-dep.js', 'dep.js', 'get-dep.js']\n    }, {\n      assets: ['get-dep.js']\n    }]);\n    assert.deepEqual(await run(b), [42, 42]);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can static import and dynamic import in the same bundle when another bundle requires async","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2629,"column":96,"index":122722},"line":2629,"code":"  it('can static import and dynamic import in the same bundle when another bundle requires async', async () => {\n    let b = await bundle(['same-bundle-scope-hoisting.js', 'get-dep-scope-hoisting.js'].map(entry => path.join(__dirname, '/integration/sync-async/', entry)), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      assets: ['dep.js']\n    }, {\n      name: 'same-bundle-scope-hoisting.js',\n      assets: ['same-bundle-scope-hoisting.js', 'get-dep.js', 'get-dep-2.js', 'dep.js']\n    }, {\n      name: 'get-dep-scope-hoisting.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'get-dep-scope-hoisting.js', 'js-loader.js']\n    }]);\n    let bundles = b.getBundles();\n    let sameBundle = bundles.find(b => b.name === 'same-bundle-scope-hoisting.js');\n    let getDep = bundles.find(b => b.name === 'get-dep-scope-hoisting.js');\n    assert.deepEqual(await runBundle(b, sameBundle), [42, 42, 42]);\n    assert.deepEqual(await runBundle(b, getDep), 42);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can share dependencies between a shared bundle and its sibling's descendants","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2648,"column":82,"index":123704},"line":2648,"code":"  it(\"can share dependencies between a shared bundle and its sibling's descendants\", async () => {\n    let b = await bundle(path.join(__dirname, '/integration/shared-exports-for-sibling-descendant/scope-hoisting.js'), {\n      mode: 'production'\n    });\n    assertBundles(b, [{\n      assets: ['wraps.js', 'lodash.js']\n    }, {\n      assets: ['a.js']\n    }, {\n      assets: ['child.js']\n    }, {\n      assets: ['grandchild.js']\n    }, {\n      assets: ['b.js']\n    }, {\n      name: 'scope-hoisting.js',\n      assets: ['bundle-manifest.js', 'bundle-url.js', 'cacheLoader.js', 'scope-hoisting.js', 'js-loader.js']\n    }]);\n    assert.deepEqual(await run(b), [3, 5]);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"deduplicates shared sibling assets between bundle groups","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2668,"column":62,"index":124352},"line":2668,"code":"  it('deduplicates shared sibling assets between bundle groups', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/shared-sibling-scope-hoist/index.js'));\n    assert.deepEqual(await run(b), ['a', 'b', 'c']);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can run an entry bundle whose entry asset is present in another bundle","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2672,"column":76,"index":124604},"line":2672,"code":"  it('can run an entry bundle whose entry asset is present in another bundle', async () => {\n    let b = await bundle(['index.js', 'value.js'].map(basename => path.join(__dirname, '/integration/sync-entry-shared', basename)), {\n      targets: {\n        main: {\n          context: 'node',\n          distDir,\n          isLibrary: true\n        }\n      }\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'value.js',\n      assets: ['value.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.equal(await (await run(b)).default, 43);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can run an async bundle whose entry asset is present in another bundle","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2693,"column":76,"index":125201},"line":2693,"code":"  it('can run an async bundle whose entry asset is present in another bundle', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/async-entry-shared/scope-hoisting.js'));\n    assertBundles(b, [{\n      name: 'scope-hoisting.js',\n      assets: ['scope-hoisting.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['value.js']\n    }, {\n      assets: ['async.js']\n    }]);\n    assert.deepEqual(await run(b), [42, 43]);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"can run an async bundle that depends on a nonentry asset in a sibling","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2705,"column":75,"index":125671},"line":2705,"code":"  it('can run an async bundle that depends on a nonentry asset in a sibling', async () => {\n    let b = await bundle(['scope-hoisting.js', 'other-entry.js'].map(basename => path.join(__dirname, '/integration/async-entry-shared-sibling', basename)));\n    assertBundles(b, [{\n      name: 'scope-hoisting.js',\n      assets: ['scope-hoisting.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      name: 'other-entry.js',\n      assets: ['other-entry.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['a.js', 'value.js']\n    }, {\n      assets: ['b.js']\n    }]);\n    assert.deepEqual(await run(b), 43);\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"correctly updates dependencies when a specifier is added","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2720,"column":62,"index":126306},"line":2720,"code":"  it('correctly updates dependencies when a specifier is added', async function () {\n    let testDir = path.join(__dirname, '/integration/scope-hoisting/es6/cache-add-specifier');\n    let b = bundler(path.join(testDir, 'a.js'), {\n      inputFS: overlayFS,\n      outputFS: overlayFS\n    });\n    let subscription = await b.watch();\n    let bundleEvent = await getNextBuild(b);\n    assert(bundleEvent.type === 'buildSuccess');\n    let output = await run(bundleEvent.bundleGraph);\n    assert.deepEqual(output, 'foo');\n    await overlayFS.mkdirp(testDir);\n    await overlayFS.copyFile(path.join(testDir, 'a.1.js'), path.join(testDir, 'a.js'));\n    bundleEvent = await getNextBuild(b);\n    assert(bundleEvent.type === 'buildSuccess');\n    output = await run(bundleEvent.bundleGraph);\n    assert.deepEqual(output, 'foobar');\n    await subscription.unsubscribe();\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not rewrite this in arrow function class properties","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2739,"column":64,"index":127170},"line":2739,"code":"  it('should not rewrite this in arrow function class properties', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-class-this-esm/a.js'));\n    let res = await run(b);\n    assert.deepEqual(res, 'x: 123');\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should call named imports without this context","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2744,"column":52,"index":127402},"line":2744,"code":"  it('should call named imports without this context', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/js-import-this/index.js'));\n    let res = await run(b, {\n      output: null\n    }, {\n      strict: true\n    });\n    assert.deepEqual(res, {\n      unwrappedNamed: [true, false],\n      unwrappedDefault: [true, false],\n      // TODO: unwrappedNamespace should actually be `[false, true]` but we optimize\n      // the `ns.foo` expression into a named import, so that namespace isn't available anymore.\n      unwrappedNamespace: [true, false],\n      wrappedNamed: [true, false],\n      wrappedDefault: [true, false],\n      wrappedNamespace: [false, true]\n    });\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should insert the prelude for sibling bundles referenced in HTML","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2762,"column":70,"index":128117},"line":2762,"code":"  it('should insert the prelude for sibling bundles referenced in HTML', async function () {\n    let b = await bundle(path.join(__dirname, 'integration/scope-hoisting/es6/sibling-dependencies/index.html'));\n    let res = await run(b, {\n      output: null\n    }, {\n      require: false\n    });\n    assert.equal(res.output, 'a');\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should unmark dependency as deferred when dependency becomes used","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2771,"column":71,"index":128452},"line":2771,"code":"  it('should unmark dependency as deferred when dependency becomes used', async function () {\n    let testDir = path.join(__dirname, 'integration/scope-hoisting/es6/unmarks-defer-for-new-deps');\n    let packageDir = path.join(testDir, '/package');\n    await overlayFS.mkdirp(packageDir);\n    await overlayFS.copyFile(path.join(packageDir, 'b1.js'), path.join(packageDir, 'b.js'));\n    await bundle(path.join(testDir, 'index.js'), {\n      inputFS: overlayFS,\n      outputFS: overlayFS,\n      shouldDisableCache: true\n    });\n    await overlayFS.copyFile(path.join(packageDir, 'b2.js'), path.join(packageDir, 'b.js'));\n    await bundle(path.join(testDir, 'index.js'), {\n      inputFS: overlayFS,\n      outputFS: overlayFS,\n      shouldDisableCache: false\n    });\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"unmark an asset group as deferred when it becomes used","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2788,"column":60,"index":129208},"line":2788,"code":"  it('unmark an asset group as deferred when it becomes used', async function () {\n    let testDir = path.join(__dirname, 'integration/scope-hoisting/es6/unmarks-defer-for-assetgroup');\n    await overlayFS.mkdirp(testDir);\n    await overlayFS.copyFile(path.join(testDir, 'index1.js'), path.join(testDir, 'index.js'));\n    let b = await bundle(path.join(testDir, 'index.js'), {\n      inputFS: overlayFS,\n      outputFS: overlayFS,\n      shouldDisableCache: true\n    });\n    assert.strictEqual(await run(b), 'bar');\n    await overlayFS.copyFile(path.join(testDir, 'index2.js'), path.join(testDir, 'index.js'));\n    b = await bundle(path.join(testDir, 'index.js'), {\n      inputFS: overlayFS,\n      outputFS: overlayFS,\n      shouldDisableCache: false\n    });\n    assert.strictEqual(await run(b), 'bar foo');\n    await overlayFS.copyFile(path.join(testDir, 'index3.js'), path.join(testDir, 'index.js'));\n    b = await bundle(path.join(testDir, 'index.js'), {\n      inputFS: overlayFS,\n      outputFS: overlayFS,\n      shouldDisableCache: false\n    });\n    assert.strictEqual(await run(b), 'bar foo bar');\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"not insert unused requires that aren't registered anywhere","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2813,"column":64,"index":130320},"line":2813,"code":"  it(\"not insert unused requires that aren't registered anywhere\", async function () {\n    let b = await bundle(path.join(__dirname, '/integration/scope-hoisting/es6/unused-require/index.js'));\n    let output = await run(b);\n    assert.strictEqual(output, 'foo');\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"produce the same bundle hash regardless of transformation order","suites":["scope hoisting","commonjs"],"updatePoint":{"line":2818,"column":69,"index":130595},"line":2818,"code":"  it('produce the same bundle hash regardless of transformation order', async function () {\n    let testDir = path.join(__dirname, 'integration/scope-hoisting/es6/non-deterministic-bundle-hashes');\n    const waitHandler = (fileToDelay, fileToWaitFor) => {\n      const waitMap = new Map();\n      function wait(filePath) {\n        if (waitMap.has(filePath)) {\n          return Promise.resolve();\n        }\n        return new Promise(resolve => {\n          waitMap.set(filePath, resolve);\n        });\n      }\n      // a set of filepaths that have been read\n      function seen(filePath) {\n        // check map of things we're waiting for to resolved promises\n        let promisesToResolve = waitMap.get(filePath);\n        if (promisesToResolve) {\n          // if we find any, we call it\n          promisesToResolve();\n        }\n        waitMap.set(filePath, null);\n      }\n      return {\n        get(target, prop) {\n          let original = Reflect.get(...arguments);\n          if (prop === 'readFile') {\n            return async function (...args) {\n              if (args[0].includes(fileToDelay)) {\n                await wait(fileToWaitFor);\n              }\n              let result = await original.apply(this, args);\n              seen(path.basename(args[0]));\n              return result;\n            };\n          }\n          return original;\n        }\n      };\n    };\n    let workerFarm = createWorkerFarm({\n      maxConcurrentWorkers: 0\n    });\n    let slowFooFS = new Proxy(overlayFS, waitHandler('foo.js', 'bar.js'));\n    try {\n      let b = await bundle(path.join(testDir, 'index.html'), {\n        inputFS: slowFooFS,\n        outputFS: slowFooFS,\n        shouldDisableCache: true,\n        workerFarm\n      });\n      let bundleHashDelayFoo = b.getBundles().find(b => b.filePath.endsWith('.js') && b.filePath.includes('index')).filePath.split('.')[1];\n      let slowBarFS = new Proxy(overlayFS, waitHandler('bar.js', 'foo.js'));\n      let b2 = await bundle(path.join(testDir, 'index.html'), {\n        inputFS: slowBarFS,\n        outputFS: slowBarFS,\n        shouldDisableCache: true,\n        workerFarm\n      });\n      let bundleHashDelayBar = b2.getBundles().find(b => b.filePath.endsWith('.js') && b.filePath.includes('index')).filePath.split('.')[1];\n      assert.strictEqual(bundleHashDelayFoo, bundleHashDelayBar);\n    } finally {\n      await workerFarm.end();\n    }\n  });","file":"scope-hoisting.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should serve files","suites":["server"],"updatePoint":{"line":18,"column":24,"index":652},"line":18,"code":"  it('should serve files', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/commonjs/index.js'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let data = await get('/index.js', port);\n    let distFile = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert.equal(data, distFile);\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should include content length for HEAD requests","suites":["server"],"updatePoint":{"line":37,"column":53,"index":1245},"line":37,"code":"  it('should include content length for HEAD requests', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/commonjs/index.js'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let result = await getRaw('/index.js', port, {\n      method: 'HEAD'\n    });\n    let distFile = await outputFS.readFile(path.join(distDir, 'index.js'));\n    assert.strictEqual(result.res.headers['content-length'], String(distFile.byteLength));\n    assert.strictEqual(result.data, '');\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should serve source files","suites":["server"],"updatePoint":{"line":59,"column":31,"index":1941},"line":59,"code":"  it('should serve source files', async function () {\n    let port = await getPort();\n    let inputPath = path.join(__dirname, '/integration/commonjs/index.js');\n    let b = bundler(inputPath, {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let data = await get('/__parcel_source_root/integration/commonjs/index.js', port);\n    let inputFile = await inputFS.readFile(inputPath, 'utf8');\n    assert.equal(data, inputFile);\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should serve sourcemaps","suites":["server"],"updatePoint":{"line":79,"column":29,"index":2563},"line":79,"code":"  it('should serve sourcemaps', async function () {\n    let port = await getPort();\n    let inputPath = path.join(__dirname, '/integration/commonjs/index.js');\n    let b = bundler(inputPath, {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let data = await get('/index.js.map', port);\n    let distFile = await outputFS.readFile(path.join(distDir, 'index.js.map'), 'utf8');\n    assert.equal(data, distFile);\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should serve a default page if the main bundle is an HTML asset","suites":["server"],"updatePoint":{"line":99,"column":69,"index":3211},"line":99,"code":"  it('should serve a default page if the main bundle is an HTML asset', async function () {\n    let port = await getPort();\n    let b = bundler([path.join(__dirname, '/integration/html/other.html'), path.join(__dirname, '/integration/html/index.html')], {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let rootIndexFile = await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8');\n    let data = await get('/', port);\n    assert.equal(data, rootIndexFile);\n    let fooIndexFile = await outputFS.readFile(path.join(distDir, 'foo/index.html'), 'utf8');\n    data = await get('/foo', port);\n    assert.equal(data, fooIndexFile);\n    data = await get('/foo/bar', port);\n    assert.equal(data, fooIndexFile);\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should serve a default page if the main bundle is an HTML asset even if it is not called index","suites":["server"],"updatePoint":{"line":123,"column":100,"index":4155},"line":123,"code":"  it('should serve a default page if the main bundle is an HTML asset even if it is not called index', async function () {\n    let port = await getPort();\n    let inputPath = path.join(__dirname, '/integration/html/other.html');\n    let b = bundler(inputPath, {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let rootIndexFile = await outputFS.readFile(path.join(distDir, 'other.html'), 'utf8');\n    let data = await get('/', port);\n    assert.equal(data, rootIndexFile);\n    data = await get('/foo', port);\n    assert.equal(data, rootIndexFile);\n    data = await get('/foo/bar', port);\n    assert.equal(data, rootIndexFile);\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should serve a default page if the main bundle is an HTML asset with package.json#source","suites":["server"],"updatePoint":{"line":147,"column":94,"index":4976},"line":147,"code":"  it('should serve a default page if the main bundle is an HTML asset with package.json#source', async function () {\n    let port = await getPort();\n    let inputPath = path.join(__dirname, '/integration/html-pkg-source/');\n    let b = bundler(inputPath, {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    let event = await getNextBuild(b);\n    invariant(event.type === 'buildSuccess');\n    let bundleGraph = event.bundleGraph;\n    let outputFile = await outputFS.readFile(bundleGraph.getBundles()[0].filePath, 'utf8');\n    let data = await get('/', port);\n    assert.equal(data, outputFile);\n    data = await get('/foo/bar', port);\n    assert.equal(data, outputFile);\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should serve a 404 if the file does not exist","suites":["server"],"updatePoint":{"line":171,"column":51,"index":5774},"line":171,"code":"  it('should serve a 404 if the file does not exist', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/commonjs/index.js'), {\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let statusCode = 200;\n    try {\n      await get('/fake.js', port);\n    } catch (err) {\n      statusCode = err.statusCode;\n    }\n    assert.equal(statusCode, 404);\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should serve a 500 if the bundler errored","suites":["server"],"updatePoint":{"line":191,"column":47,"index":6310},"line":191,"code":"  it('should serve a 500 if the bundler errored', async function () {\n    let port = await getPort();\n    let inputDir = path.join(__dirname, '/input/server-500');\n    await ncp(path.join(__dirname, '/integration/babel'), inputDir);\n    let entry = path.join(inputDir, 'index.js');\n    let b = bundler(entry, {\n      defaultTargetOptions: {\n        distDir\n      },\n      inputFS: overlayFS,\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    await outputFS.writeFile(path.join(inputDir, 'foo.js'), 'syntax\\\\error');\n\n    // Await the second build failing (which means resolving with\n    // a buildFailure event)\n    await getNextBuild(b);\n    let statusCode = 200;\n    try {\n      await get('/index.js', port);\n    } catch (err) {\n      statusCode = err.statusCode;\n      assert(err.data.includes('Expected unicode escape'));\n    }\n    assert.equal(statusCode, 500);\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support HTTPS","suites":["server"],"updatePoint":{"line":224,"column":26,"index":7299},"line":224,"code":"  it('should support HTTPS', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/commonjs/index.js'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: true,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let data = await get('/index.js', port, https);\n    assert.equal(data, await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8'));\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support HTTPS via custom certificate","suites":["server"],"updatePoint":{"line":242,"column":49,"index":7865},"line":242,"code":"  it('should support HTTPS via custom certificate', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/commonjs/index.js'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: {\n          key: path.join(__dirname, '/integration/https/private.pem'),\n          cert: path.join(__dirname, '/integration/https/primary.crt')\n        },\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let data = await get('/index.js', port, https);\n    assert.equal(data, await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8'));\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support setting a public url","suites":["server"],"updatePoint":{"line":263,"column":41,"index":8572},"line":263,"code":"  it('should support setting a public url', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/commonjs/index.js'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost',\n        publicUrl: '/dist'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let data = await get('/dist/index.js', port);\n    assert.equal(data, await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8'));\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with query parameters that contain a dot","suites":["server"],"updatePoint":{"line":282,"column":58,"index":9174},"line":282,"code":"  it('should work with query parameters that contain a dot', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/commonjs/index.js'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let data = await get('/index.js?foo=bar.baz', port);\n    assert.equal(data, await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8'));\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with paths that contain a dot","suites":["server"],"updatePoint":{"line":300,"column":47,"index":9744},"line":300,"code":"  it('should work with paths that contain a dot', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/html/index.html'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let data = await get('/bar.baz', port);\n    assert.equal(data, await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8'));\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support lazy bundling","suites":["server"],"updatePoint":{"line":318,"column":34,"index":10288},"line":318,"code":"  it('should support lazy bundling', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/html/index.html'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      },\n      shouldBuildLazily: true,\n      shouldContentHash: false\n    });\n    await outputFS.mkdirp(distDir);\n    let builds = [];\n    subscription = await b.watch((err, buildEvent) => {\n      builds.push(buildEvent);\n    });\n    let build = await getNextBuild(b);\n    invariant(build.type === 'buildSuccess');\n    assertBundles(build.bundleGraph, [{\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      name: 'index.html',\n      assets: ['index.html']\n    }]);\n\n    // Bundle should exist in the graph, but not written to disk as it is just a placeholder\n    let dir = await outputFS.readdir(distDir);\n    assert.deepEqual(dir, []);\n    let data = await get('/index.html', port);\n    assert.equal(data, await outputFS.readFile(path.join(distDir, 'index.html'), 'utf8'));\n    assert.equal(builds.length, 2);\n    build = builds[1];\n    invariant(build?.type === 'buildSuccess');\n    assertBundles(build.bundleGraph, [{\n      type: 'css',\n      assets: ['index.html']\n    }, {\n      // index.html\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      // foo/index.html\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      name: 'other.html',\n      assets: ['other.html']\n    }, {\n      type: 'svg',\n      assets: ['icons.svg']\n    }, {\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'js',\n      assets: ['index.js']\n    }, {\n      type: 'css',\n      assets: ['index.css']\n    }]);\n\n    // Sibling bundles should have been fully written to disk, but not async bundles.\n    dir = await outputFS.readdir(distDir);\n    assert.deepEqual(dir.length, 8);\n    assert(!dir.includes('other.html'));\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support lazy bundling sibling css files of dynamic import","suites":["server"],"updatePoint":{"line":389,"column":70,"index":12312},"line":389,"code":"  it('should support lazy bundling sibling css files of dynamic import', async function () {\n    let port = await getPort();\n    let b = bundler(path.join(__dirname, '/integration/dynamic-css/index.js'), {\n      defaultTargetOptions: {\n        distDir\n      },\n      config,\n      serveOptions: {\n        https: false,\n        port: port,\n        host: 'localhost'\n      },\n      shouldBuildLazily: true,\n      shouldContentHash: false\n    });\n    await outputFS.mkdirp(distDir);\n    let builds = [];\n    subscription = await b.watch((err, buildEvent) => {\n      builds.push(buildEvent);\n    });\n    let build = await getNextBuild(b);\n    invariant(build.type === 'buildSuccess');\n    assertBundles(build.bundleGraph, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }]);\n\n    // Bundle should exist in the graph, but not written to disk as it is just a placeholder\n    let dir = await outputFS.readdir(distDir);\n    assert.deepEqual(dir, []);\n    let data = await get(`/index.js`, port);\n    assert.equal(data, await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8'));\n    assert.equal(builds.length, 2);\n    build = builds[1];\n    invariant(build?.type === 'buildSuccess');\n    assertBundles(build.bundleGraph, [{\n      name: 'index.js',\n      assets: ['bundle-url.js', 'cacheLoader.js', 'css-loader.js', 'index.js', 'js-loader.js']\n    }, {\n      name: /local\\.[0-9a-f]{8}\\.js/,\n      assets: ['local.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.css']\n    }]);\n\n    // local.js should exist in the graph, but not written to disk\n    dir = await outputFS.readdir(distDir);\n    assert.deepEqual(dir.sort(), ['index.js', 'index.css', 'index.js.map', 'index.css.map'].sort());\n    let local = build.bundleGraph.getBundles().find(b => b.type === 'js' && path.basename(b.filePath).startsWith('local'));\n    invariant(local);\n    data = await get(`/${path.basename(local.filePath)}`, port);\n    assert.equal(data, await outputFS.readFile(path.join(distDir, path.basename(local.filePath)), 'utf8'));\n    assert.equal(builds.length, 3);\n    build = builds[2];\n    invariant(build?.type === 'buildSuccess');\n    assertBundles(build.bundleGraph, [{\n      name: 'index.js',\n      assets: ['bundle-url.js', 'cacheLoader.js', 'css-loader.js', 'index.js', 'js-loader.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.css']\n    }, {\n      name: /local\\.[0-9a-f]{8}\\.js/,\n      assets: ['local.js']\n    }, {\n      name: /local\\.[0-9a-f]{8}\\.css/,\n      assets: ['local.css']\n    }]);\n    dir = await outputFS.readdir(distDir);\n    assert.deepEqual(dir.length, 8); // bundles + source maps\n\n    let localCSS = build.bundleGraph.getBundles().find(b => b.type === 'css' && path.basename(b.filePath).startsWith('local'));\n    invariant(localCSS);\n    assert(data.includes(path.basename(localCSS.filePath)));\n    assert(data.includes('css-loader'));\n  });","file":"server.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should create a basic browser sourcemap","suites":["sourcemaps"],"updatePoint":{"line":88,"column":45,"index":3355},"line":88,"code":"  it('Should create a basic browser sourcemap', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap/index.js');\n    await bundle(sourceFilename);\n    let distDir = path.join(__dirname, '/integration/sourcemap/dist/');\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[0]), 'utf8');\n    let sourcePath = 'index.js';\n    let name = raw.match(/function (\\$.*\\$var\\$helloWorld)/)[1];\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'function helloWorld',\n      generatedStr: 'function ' + name,\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'module.exports = helloWorld;',\n      generatedStr: 'module.exports = ' + name + ';',\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: '\"hello world\"',\n      sourcePath\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should create a basic browser sourcemap when serving","suites":["sourcemaps"],"updatePoint":{"line":128,"column":58,"index":4739},"line":128,"code":"  it('Should create a basic browser sourcemap when serving', async function () {\n    let fixture = path.join(__dirname, '/integration/sourcemap');\n    let sourceFilename = path.join(fixture, 'index.js');\n    await bundle(sourceFilename, {\n      serveOptions: {\n        port: 1234\n      }\n    });\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    assert.strictEqual(map.sourceRoot, '/__parcel_source_root/');\n    let input = await inputFS.readFile(path.join(fixture, map.sources[0]), 'utf8');\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'function helloWorld',\n      sourcePath: map.sources[0]\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'module.exports = helloWorld;',\n      sourcePath: map.sources[0]\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: '\"hello world\"',\n      sourcePath: map.sources[0]\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should create a basic node sourcemap","suites":["sourcemaps"],"updatePoint":{"line":169,"column":42,"index":6025},"line":169,"code":"  it('Should create a basic node sourcemap', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap-node/index.js');\n    await bundle(sourceFilename);\n    let distDir = path.join(__dirname, '/integration/sourcemap-node/dist/');\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceRoot = map.sourceRoot;\n    assert.equal(sourceRoot, '../', 'sourceRoot should be the root of the source files, relative to the output directory.');\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let input = await inputFS.readFile(sourceFilename, 'utf8');\n    let sourcePath = 'index.js';\n    let mapData = sourceMap.getMap();\n    assert.equal(mapData.sources.length, 1);\n    assert(await inputFS.exists(path.resolve(distDir + sourceRoot + sourcePath)), 'combining sourceRoot and sources object should resolve to the original file');\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'function helloWorld',\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'module.exports = helloWorld;',\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: '\"hello world\"',\n      sourcePath\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap for a js file with requires","suites":["sourcemaps"],"updatePoint":{"line":211,"column":65,"index":7623},"line":211,"code":"  it('should create a valid sourcemap for a js file with requires', async function () {\n    let sourceDir = path.join(__dirname, '/integration/sourcemap-nested/');\n    let sourceFilename = path.join(sourceDir, '/index.js');\n    await bundle(sourceFilename);\n    let distDir = path.join(__dirname, '/integration/sourcemap-nested/dist/');\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceRoot = map.sourceRoot;\n    assert.equal(sourceRoot, '../', 'sourceRoot should be the root of the source files, relative to the output directory.');\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let mapData = sourceMap.getMap();\n    assert.equal(mapData.sources.length, 3);\n    for (let source of mapData.sources) {\n      assert(await inputFS.exists(path.resolve(distDir + sourceRoot + source)), 'combining sourceRoot and sources object should resolve to the original file');\n    }\n    let inputs = [await inputFS.readFile(sourceFilename, 'utf8'), await inputFS.readFile(path.join(sourceDir, 'local.js'), 'utf8'), await inputFS.readFile(path.join(sourceDir, 'utils/util.js'), 'utf8')];\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[0],\n      generated: raw,\n      str: 'const local',\n      sourcePath: 'index.js'\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[0],\n      generated: raw,\n      str: 'local.a',\n      sourcePath: 'index.js'\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[1],\n      generated: raw,\n      str: 'exports.a',\n      sourcePath: 'local.js'\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[2],\n      generated: raw,\n      str: 'exports.count = function(a, b) {',\n      generatedStr: 'exports.count = function(a, b) {',\n      sourcePath: 'utils/util.js'\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[2],\n      generated: raw,\n      str: 'return a + b',\n      sourcePath: 'utils/util.js'\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap for a minified js bundle with requires","suites":["sourcemaps"],"updatePoint":{"line":270,"column":76,"index":9853},"line":270,"code":"  it('should create a valid sourcemap for a minified js bundle with requires', async function () {\n    let sourceDir = path.join(__dirname, '/integration/sourcemap-nested-minified/');\n    let sourceFilename = path.join(sourceDir, '/index.js');\n    await bundle(sourceFilename, {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    let distDir = path.join(__dirname, '/integration/sourcemap-nested-minified/dist/');\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceRoot = map.sourceRoot;\n    assert.equal(sourceRoot, '../', 'sourceRoot should be the root of the source files, relative to the output directory.');\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let mapData = sourceMap.getMap();\n    assert.equal(mapData.sources.length, 3);\n    for (let source of mapData.sources) {\n      assert(await inputFS.exists(path.resolve(distDir + sourceRoot + source)), 'combining sourceRoot and sources object should resolve to the original file');\n    }\n    let inputs = [await inputFS.readFile(sourceFilename, 'utf8'), await inputFS.readFile(path.join(sourceDir, 'local.js'), 'utf8'), await inputFS.readFile(path.join(sourceDir, 'utils/util.js'), 'utf8')];\n\n    // TODO: Figure out a way to tests these without relying on generatedStr as much\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[0],\n      generated: raw,\n      str: 'const local',\n      generatedStr: 'const t',\n      sourcePath: 'index.js'\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[0],\n      generated: raw,\n      str: 'local.a',\n      generatedStr: 't.a',\n      sourcePath: 'index.js'\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[1],\n      generated: raw,\n      str: 'exports.a',\n      generatedStr: 'o.a',\n      sourcePath: 'local.js'\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: inputs[2],\n      generated: raw,\n      str: 'exports.count = function(a, b) {',\n      generatedStr: 'o.count=function(e,n){',\n      sourcePath: 'utils/util.js'\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap as a child of a TS bundle","suites":["sourcemaps"],"updatePoint":{"line":331,"column":63,"index":12162},"line":331,"code":"  it('should create a valid sourcemap as a child of a TS bundle', async function () {\n    let inputFilePath = path.join(__dirname, '/integration/sourcemap-typescript/index.ts');\n    await bundle(inputFilePath);\n    let distDir = path.join(__dirname, '../dist/');\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    assert.equal(map.file, 'index.js.map');\n    assert(raw.includes('//# sourceMappingURL=index.js.map'));\n    // assert.equal(map.sourceRoot, '/__parcel_source_root/');\n\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let mapData = sourceMap.getMap();\n    assert.equal(mapData.sources.length, 2);\n    assert.deepEqual(mapData.sources, ['index.ts', '../../../../../transformers/js/src/esmodule-helpers.js']);\n    let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[0]), 'utf8');\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'function env()',\n      sourcePath: 'index.ts'\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap as a child of a nested TS bundle","suites":["sourcemaps"],"updatePoint":{"line":360,"column":70,"index":13426},"line":360,"code":"  it('should create a valid sourcemap as a child of a nested TS bundle', async function () {\n    let inputFilePath = path.join(__dirname, '/integration/sourcemap-typescript-nested/index.ts');\n    await bundle(inputFilePath);\n    let distDir = path.join(__dirname, '../dist/');\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    assert.equal(map.file, 'index.js.map');\n    assert(raw.includes('//# sourceMappingURL=index.js.map'));\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let mapData = sourceMap.getMap();\n    assert.equal(mapData.sources.length, 3);\n    assert.deepEqual(mapData.sources, ['index.ts', 'local.ts', '../../../../../transformers/js/src/esmodule-helpers.js']);\n    let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[0]), 'utf8');\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'function env()',\n      sourcePath: 'index.ts'\n    });\n    let local = await inputFS.readFile(path.join(__dirname, '/integration/sourcemap-typescript-nested/local.ts'), 'utf-8');\n    checkSourceMapping({\n      map: sourceMap,\n      source: local,\n      generated: raw,\n      str: 'exports.local',\n      sourcePath: 'local.ts'\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap when using the Typescript tsc transformer","suites":["sourcemaps"],"updatePoint":{"line":395,"column":79,"index":14933},"line":395,"code":"  it('should create a valid sourcemap when using the Typescript tsc transformer', async function () {\n    let inputFilePath = path.join(__dirname, '/integration/sourcemap-typescript-tsc/index.ts');\n    await bundle(inputFilePath);\n    let distDir = path.join(__dirname, '../dist/');\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    assert.equal(map.file, 'index.js.map');\n    assert(raw.includes('//# sourceMappingURL=index.js.map'));\n    // assert.equal(map.sourceRoot, '/__parcel_source_root/');\n\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let mapData = sourceMap.getMap();\n    assert.equal(mapData.sources.length, 1);\n    assert.deepEqual(mapData.sources, ['index.ts']);\n    let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[0]), 'utf8');\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'nonExistsFunc',\n      sourcePath: 'index.ts'\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap for a CSS bundle","suites":["sourcemaps"],"updatePoint":{"line":424,"column":54,"index":16126},"line":424,"code":"  it('should create a valid sourcemap for a CSS bundle', async function () {\n    async function test(minify) {\n      let inputFilePath = path.join(__dirname, '/integration/sourcemap-css/style.css');\n      await bundle(inputFilePath, {\n        defaultTargetOptions: {\n          shouldOptimize: minify\n        }\n      });\n      let distDir = path.join(__dirname, '../dist/');\n      let filename = path.join(distDir, 'style.css');\n      let raw = await outputFS.readFile(filename, 'utf8');\n      let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n      if (!mapUrlData) {\n        throw new Error('Could not load map');\n      }\n      let map = mapUrlData.map;\n      assert.equal(map.file, 'style.css.map');\n      assert(raw.includes('/*# sourceMappingURL=style.css.map */'));\n      let sourceMap = new SourceMap('/');\n      sourceMap.addVLQMap(map);\n      let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[0]), 'utf8');\n      let mapData = sourceMap.getMap();\n      assert.equal(mapData.sources.length, 1);\n      assert.deepEqual(mapData.sources, ['style.css']);\n      checkSourceMapping({\n        map: sourceMap,\n        source: input,\n        generated: raw,\n        str: 'body',\n        sourcePath: 'style.css',\n        msg: ' ' + (minify ? 'with' : 'without') + ' minification'\n      });\n    }\n    await test(false);\n    await test(true);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap for a CSS bundle with imports","suites":["sourcemaps"],"updatePoint":{"line":460,"column":67,"index":17546},"line":460,"code":"  it('should create a valid sourcemap for a CSS bundle with imports', async function () {\n    async function test(minify) {\n      let inputFilePath = path.join(__dirname, '/integration/sourcemap-css-import/style.css');\n      await bundle(inputFilePath, {\n        defaultTargetOptions: {\n          shouldOptimize: minify\n        }\n      });\n      let distDir = path.join(__dirname, '../dist/');\n      let filename = path.join(distDir, 'style.css');\n      let raw = await outputFS.readFile(filename, 'utf8');\n      let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n      if (!mapUrlData) {\n        throw new Error('Could not load map');\n      }\n      let map = mapUrlData.map;\n      assert.equal(map.file, 'style.css.map');\n      assert(raw.includes('/*# sourceMappingURL=style.css.map */'));\n      let sourceMap = new SourceMap('/');\n      sourceMap.addVLQMap(map);\n      let mapData = sourceMap.getMap();\n      let sources = minify ? ['style.css', 'other-style.css', 'another-style.css'] : ['other-style.css', 'another-style.css', 'style.css'];\n      assert.deepEqual(mapData.sources, sources);\n      let otherStyle = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[sources.indexOf('other-style.css')]), 'utf-8');\n      let anotherStyle = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[sources.indexOf('another-style.css')]), 'utf-8');\n      let style = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[sources.indexOf('style.css')]), 'utf8');\n      checkSourceMapping({\n        map: sourceMap,\n        source: style,\n        generated: raw,\n        str: 'body',\n        sourcePath: 'style.css',\n        msg: ' ' + (minify ? 'with' : 'without') + ' minification'\n      });\n      checkSourceMapping({\n        map: sourceMap,\n        source: otherStyle,\n        generated: raw,\n        str: 'div',\n        sourcePath: 'other-style.css',\n        msg: ' ' + (minify ? 'with' : 'without') + ' minification'\n      });\n      checkSourceMapping({\n        map: sourceMap,\n        source: anotherStyle,\n        generated: raw,\n        str: 'main',\n        sourcePath: 'another-style.css',\n        msg: ' ' + (minify ? 'with' : 'without') + ' minification'\n      });\n    }\n    await test(false);\n    await test(true);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap for a Sass asset","suites":["sourcemaps"],"updatePoint":{"line":514,"column":54,"index":19873},"line":514,"code":"  it('should create a valid sourcemap for a Sass asset', async function () {\n    async function test(shouldOptimize) {\n      let inputFilePath = path.join(__dirname, '/integration/sourcemap-sass/style.scss');\n      await bundle(inputFilePath, {\n        defaultTargetOptions: {\n          shouldOptimize\n        }\n      });\n      let distDir = path.join(__dirname, '../dist/');\n      let filename = path.join(distDir, 'style.css');\n      let raw = await outputFS.readFile(filename, 'utf8');\n      let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n      if (!mapUrlData) {\n        throw new Error('Could not load map');\n      }\n      let map = mapUrlData.map;\n      assert.equal(map.file, 'style.css.map');\n      assert(raw.includes('/*# sourceMappingURL=style.css.map */'));\n      let sourceMap = new SourceMap('/');\n      sourceMap.addVLQMap(map);\n      let mapData = sourceMap.getMap();\n      assert.equal(mapData.sources.length, shouldOptimize ? 2 : 1);\n      let index = mapData.sources.indexOf('style.scss');\n      assert.strictEqual(mapData.sources[index], 'style.scss');\n      let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[index]), 'utf-8');\n      checkSourceMapping({\n        map: sourceMap,\n        source: input,\n        generated: raw,\n        str: 'body',\n        sourcePath: 'style.scss',\n        msg: ' ' + (shouldOptimize ? 'with' : 'without') + ' minification'\n      });\n    }\n    await test(false);\n    await test(true);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap for a Sass asset w/ imports","suites":["sourcemaps"],"updatePoint":{"line":551,"column":65,"index":21393},"line":551,"code":"  it('should create a valid sourcemap for a Sass asset w/ imports', async function () {\n    let inputFilePath = path.join(__dirname, '/integration/scss-sourcemap-imports/style.scss');\n    await bundle(inputFilePath);\n    let distDir = path.join(__dirname, '../dist/');\n    let filename = path.join(distDir, 'style.css');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    assert.equal(map.file, 'style.css.map');\n    assert(raw.includes('/*# sourceMappingURL=style.css.map */'));\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let mapData = sourceMap.getMap();\n    // This should actually just be `./integration/scss-sourcemap-imports/with_url.scss`\n    // but this is a small bug in the extend utility of the source-map library\n    assert.deepEqual(mapData.sources, ['integration/scss-sourcemap-imports/style.scss', 'integration/scss-sourcemap-imports/with_url.scss']);\n    let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[1]), 'utf-8');\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: 'body',\n      sourcePath: 'integration/scss-sourcemap-imports/with_url.scss'\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap when for a CSS asset importing Sass","suites":["sourcemaps"],"updatePoint":{"line":579,"column":73,"index":22791},"line":579,"code":"  it('should create a valid sourcemap when for a CSS asset importing Sass', async function () {\n    async function test(shouldOptimize) {\n      let inputFilePath = path.join(__dirname, '/integration/sourcemap-sass-imported/style.css');\n      await bundle(inputFilePath, {\n        defaultTargetOptions: {\n          shouldOptimize\n        }\n      });\n      let distDir = path.join(__dirname, '../dist/');\n      let filename = path.join(distDir, 'style.css');\n      let raw = await outputFS.readFile(filename, 'utf8');\n      let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n      if (!mapUrlData) {\n        throw new Error('Could not load map');\n      }\n      let map = mapUrlData.map;\n      assert.equal(map.file, 'style.css.map');\n      assert(raw.includes('/*# sourceMappingURL=style.css.map */'));\n      let sourceMap = new SourceMap('/');\n      sourceMap.addVLQMap(map);\n      let mapData = sourceMap.getMap();\n      // TODO: htmlnano inserts `./<input css 1>`\n      assert(mapData.sources.includes('other.scss'));\n      assert(mapData.sources.includes('style.css'));\n      let style = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, 'style.css'), 'utf-8');\n      let other = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, 'other.scss'), 'utf-8');\n      checkSourceMapping({\n        map: sourceMap,\n        source: style,\n        generated: raw,\n        str: 'body',\n        sourcePath: 'style.css',\n        msg: ' ' + (shouldOptimize ? 'with' : 'without') + ' minification'\n      });\n      checkSourceMapping({\n        map: sourceMap,\n        source: other,\n        generated: raw,\n        str: 'div',\n        sourcePath: 'other.scss',\n        msg: ' ' + (shouldOptimize ? 'with' : 'without') + ' minification'\n      });\n    }\n    await test(false);\n    await test(true);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should create a valid sourcemap for a LESS asset","suites":["sourcemaps"],"updatePoint":{"line":625,"column":54,"index":24621},"line":625,"code":"  it('should create a valid sourcemap for a LESS asset', async function () {\n    async function test(shouldOptimize) {\n      let inputFilePath = path.join(__dirname, '/integration/sourcemap-less/style.less');\n      await bundle(inputFilePath, {\n        defaultTargetOptions: {\n          shouldOptimize\n        }\n      });\n      let distDir = path.join(__dirname, '../dist/');\n      let filename = path.join(distDir, 'style.css');\n      let raw = await outputFS.readFile(filename, 'utf8');\n      let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n      if (!mapUrlData) {\n        throw new Error('Could not load map');\n      }\n      let map = mapUrlData.map;\n      assert.equal(map.file, 'style.css.map');\n      assert(raw.includes('/*# sourceMappingURL=style.css.map */'));\n      let sourceMap = new SourceMap('/');\n      sourceMap.addVLQMap(map);\n      let mapData = sourceMap.getMap();\n      assert(mapData.sources.includes('style.less'));\n      let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, 'style.less'), 'utf-8');\n      checkSourceMapping({\n        map: sourceMap,\n        source: input,\n        generated: raw,\n        str: 'div',\n        sourcePath: 'style.less',\n        msg: ' ' + (shouldOptimize ? 'with' : 'without') + ' minification'\n      });\n    }\n    await test(false);\n    await test(true);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should be able to create a sourcemap with inlined sources","suites":["sourcemaps"],"updatePoint":{"line":660,"column":63,"index":25997},"line":660,"code":"  it('Should be able to create a sourcemap with inlined sources', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap-inline-sources/index.js');\n    await bundle(sourceFilename);\n    let distDir = path.join(__dirname, '/integration/sourcemap-inline-sources/dist/');\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapData) {\n      throw new Error('Could not load map');\n    }\n    let sourceContent = await inputFS.readFile(sourceFilename, 'utf-8');\n    let map = mapData.map;\n    assert.equal(map.file, 'index.js.map');\n    assert.deepEqual(map.sources, ['index.js', '../../../../../transformers/js/src/esmodule-helpers.js']);\n    assert.equal(map.sourcesContent[0], sourceContent);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should be able to create inline sourcemaps","suites":["sourcemaps"],"updatePoint":{"line":676,"column":48,"index":26845},"line":676,"code":"  it('Should be able to create inline sourcemaps', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap-generate-inline/index.js');\n    await bundle(sourceFilename);\n    let distDir = path.join(__dirname, '/integration/sourcemap-generate-inline/dist/');\n    let filename = path.join(distDir, 'index.js');\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    assert(mapUrlData.url.startsWith('data:application/json;charset=utf-8;base64,'), 'inline sourcemap bundles should have a base64 url');\n    let map = mapUrlData.map;\n    assert.equal(map.file, 'index.js.map');\n    assert.deepEqual(map.sources, ['index.js', '../../../../../transformers/js/src/esmodule-helpers.js']);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should respect --no-source-maps","suites":["sourcemaps"],"updatePoint":{"line":691,"column":37,"index":27703},"line":691,"code":"  it('should respect --no-source-maps', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/sourcemap/index.js'), {\n      defaultTargetOptions: {\n        sourceMaps: false\n      }\n    });\n    assert.deepStrictEqual(await outputFS.readdir(path.dirname(b.getBundles()[0].filePath)), ['index.js']);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"Should just skip invalid inlined sourcemaps","suites":["sourcemaps"],"updatePoint":{"line":699,"column":49,"index":28045},"line":699,"code":"  it('Should just skip invalid inlined sourcemaps', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap-invalid-existing/index.js');\n    let b = await bundle(sourceFilename);\n    let filename = b.getBundles()[0].filePath;\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let sourcemapData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!sourcemapData) {\n      throw new Error('Could not load map');\n    }\n    let map = sourcemapData.map;\n    assert.equal(map.sourceRoot, '../test/');\n    assert.equal(map.sources.length, 2);\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should load existing sourcemaps of libraries","suites":["sourcemaps"],"updatePoint":{"line":712,"column":50,"index":28639},"line":712,"code":"  it('should load existing sourcemaps of libraries', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap-existing/index.js');\n    let b = await bundle(sourceFilename);\n    let filename = b.getBundles()[0].filePath;\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let sourcemapData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!sourcemapData) {\n      throw new Error('Could not load map');\n    }\n    let map = sourcemapData.map;\n    assert.equal(map.sourceRoot, '../test/');\n    assert.equal(map.sources.length, 3);\n    for (let source of map.sources) {\n      if (path.extname(source) !== '.coffee') {\n        assert(await inputFS.exists(path.join(path.basename(filename), map.sourceRoot, source)), `Source File ${source} should exist`);\n      }\n    }\n    assert.equal(map.sourcesContent[2], 'module.exports = (a, b) => a + b');\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should load inline sourcemaps of libraries","suites":["sourcemaps"],"updatePoint":{"line":731,"column":48,"index":29536},"line":731,"code":"  it('should load inline sourcemaps of libraries', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap-inline/index.js');\n    let b = await bundle(sourceFilename);\n    let filename = b.getBundles()[0].filePath;\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let sourcemapData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!sourcemapData) {\n      throw new Error('Could not load map');\n    }\n    let map = sourcemapData.map;\n    assert.equal(map.sourceRoot, '../test/');\n    assert.equal(map.sources.length, 3);\n    for (let source of map.sources) {\n      if (path.extname(source) !== '.coffee') {\n        assert(await inputFS.exists(path.join(path.basename(filename), map.sourceRoot, source)), `Source File ${source} should exist`);\n      }\n    }\n    assert.equal(map.sourcesContent[2], 'module.exports = (a, b) => a + b\\n');\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should load referenced contents of sourcemaps","suites":["sourcemaps"],"updatePoint":{"line":750,"column":51,"index":30436},"line":750,"code":"  it('should load referenced contents of sourcemaps', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap-external-contents/index.js');\n    let b = await bundle(sourceFilename);\n    let filename = b.getBundles()[0].filePath;\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let sourcemapData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!sourcemapData) {\n      throw new Error('Could not load map');\n    }\n    let map = sourcemapData.map;\n    assert.equal(map.sourceRoot, '../test/');\n    assert.equal(map.sources.length, 3);\n    for (let source of map.sources) {\n      assert(await inputFS.exists(path.join(path.basename(filename), map.sourceRoot, source)), `Source File ${source} should exist`);\n    }\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should load existing sourcemaps for CSS files","suites":["sourcemaps"],"line":766,"code":"  it.skip('should load existing sourcemaps for CSS files', async function () {","file":"sourcemaps.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should handle comments correctly in sourcemaps","suites":["sourcemaps"],"updatePoint":{"line":834,"column":52,"index":33440},"line":834,"code":"  it('should handle comments correctly in sourcemaps', async function () {\n    let sourceFilename = path.join(__dirname, '/integration/sourcemap-comments/index.js');\n    let b = await bundle(sourceFilename, {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let filename = b.getBundles()[0].filePath;\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let input = await inputFS.readFile(path.join(path.dirname(filename), map.sourceRoot, map.sources[0]), 'utf8');\n    let sourcePath = 'index.js';\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: \"console.log('foo')\",\n      generatedStr: `console.log(\"foo\")`,\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: \"console.log('bar')\",\n      generatedStr: `console.log(\"bar\")`,\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: \"console.log('baz')\",\n      generatedStr: `console.log(\"baz\")`,\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: input,\n      generated: raw,\n      str: \"console.log('idhf')\",\n      generatedStr: `console.log(\"idhf\")`,\n      sourcePath\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"carries sourcesContent from the original sources through multiple transformations (babel and swc)","suites":["sourcemaps"],"updatePoint":{"line":885,"column":103,"index":35041},"line":885,"code":"  it('carries sourcesContent from the original sources through multiple transformations (babel and swc)', async () => {\n    let b = await bundle(path.join(__dirname, 'integration/sourcemap-original-sourcecontents/index.js'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let filename = b.getBundles()[0].filePath;\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let sourcePath = 'index.js';\n    let sourceContent = nullthrows(sourceMap.getSourceContent(sourcePath));\n    checkSourceMapping({\n      map: sourceMap,\n      source: sourceContent,\n      generated: raw,\n      str: 'bar=\"bar\"' /* from jsx: <App bar=\"bar\" /> */,\n      generatedStr: 'bar: \"bar\"',\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: sourceContent,\n      generated: raw,\n      str: 'document.getElementById(',\n      sourcePath\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"carries sourcesContent from the original sources (tsx) through multiple transformations (babel and swc)","suites":["sourcemaps"],"updatePoint":{"line":918,"column":109,"index":36191},"line":918,"code":"  it('carries sourcesContent from the original sources (tsx) through multiple transformations (babel and swc)', async () => {\n    let b = await bundle(path.join(__dirname, 'integration/sourcemap-original-sourcecontents-ts/index.tsx'), {\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let filename = b.getBundles()[0].filePath;\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let sourcePath = 'index.tsx';\n    let sourceContent = nullthrows(sourceMap.getSourceContent(sourcePath));\n    checkSourceMapping({\n      map: sourceMap,\n      source: sourceContent,\n      generated: raw,\n      str: 'bar=\"bar\"' /* from tsx: <App bar=\"bar\" /> */,\n      generatedStr: 'bar: \"bar\"',\n      sourcePath\n    });\n    checkSourceMapping({\n      map: sourceMap,\n      source: sourceContent,\n      generated: raw,\n      str: 'document.getElementById(',\n      sourcePath\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"retains sourcesContent from the original sources from a large text file","suites":["sourcemaps"],"updatePoint":{"line":951,"column":77,"index":37314},"line":951,"code":"  it('retains sourcesContent from the original sources from a large text file', async () => {\n    let testDir = path.join(__dirname, 'integration/sourcemap-original-sourcecontents-large');\n    await outputFS.mkdirp(testDir);\n    await Promise.all([outputFS.writeFile(path.join(testDir, 'index.js'), 'const foo = ' + `'${\n    // Generate ~6MB of text to exceed the stream threshold\n    'Lorem ipsum dolor sit amet '.repeat(245000)}';`), outputFS.writeFile(path.join(testDir, 'yarn.lock'), '')]);\n    let b = await bundle(path.join(testDir, 'index.js'), {\n      inputFS: overlayFS,\n      defaultTargetOptions: {\n        shouldScopeHoist: true\n      }\n    });\n    let filename = b.getBundles()[0].filePath;\n    let raw = await outputFS.readFile(filename, 'utf8');\n    let mapUrlData = await loadSourceMapUrl(outputFS, filename, raw);\n    if (!mapUrlData) {\n      throw new Error('Could not load map');\n    }\n    let map = mapUrlData.map;\n    let sourceMap = new SourceMap('/');\n    sourceMap.addVLQMap(map);\n    let sourceContent = map.sourcesContent[0];\n    let sourcePath = 'index.js';\n    checkSourceMapping({\n      map: sourceMap,\n      source: sourceContent,\n      generated: raw,\n      str: `foo = 'Lorem ipsum`,\n      generatedStr: `foo = \"Lorem ipsum`,\n      sourcePath\n    });\n  });","file":"sourcemaps.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring stylus files","suites":["stylus"],"updatePoint":{"line":5,"column":43,"index":215},"line":5,"code":"  it('should support requiring stylus files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/stylus/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.styl']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.index'));\n  });","file":"stylus.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring stylus files with dependencies","suites":["stylus"],"updatePoint":{"line":20,"column":61,"index":755},"line":20,"code":"  it('should support requiring stylus files with dependencies', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/stylus-deps/index.js'));\n\n    // a.styl shouldn't be included as a dependency that we can see.\n    // stylus takes care of inlining it.\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.styl']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.index'));\n    assert(css.includes('.a'));\n    assert(css.includes('.b'));\n    assert(css.includes('-webkit-box'));\n    assert(css.includes('.foo'));\n  });","file":"stylus.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support linking to assets with url() from stylus","suites":["stylus"],"updatePoint":{"line":42,"column":61,"index":1550},"line":42,"code":"  it('should support linking to assets with url() from stylus', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/stylus-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.styl']\n    }, {\n      type: 'woff2',\n      assets: ['test.woff2']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(/url\\(\"?test\\.[0-9a-f]+\\.woff2\"?\\)/.test(css));\n    assert(/url\\(\"?http:\\/\\/google.com\"?\\)/.test(css));\n    assert(css.includes('.index'));\n    assert(await outputFS.exists(path.join(distDir, css.match(/url\\(\"?(test\\.[0-9a-f]+\\.woff2)\"?\\)/)[1])));\n  });","file":"stylus.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should ignore paths starting with \"#\" when resolving with stylus url()","suites":["stylus"],"updatePoint":{"line":63,"column":76,"index":2391},"line":63,"code":"  it('should ignore paths starting with \"#\" when resolving with stylus url()', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/stylus-id-url/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.styl']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('#clip-path'));\n    assert(css.includes('.svg-background'));\n  });","file":"stylus.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming stylus with css modules","suites":["stylus"],"updatePoint":{"line":79,"column":57,"index":2983},"line":79,"code":"  it('should support transforming stylus with css modules', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/stylus-postcss/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js', 'index.module.styl']\n    }, {\n      name: 'index.css',\n      assets: ['index.module.styl']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert(output().endsWith('_index'));\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(/\\.[_0-9a-zA-Z]+_index/.test(css));\n  });","file":"stylus.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support requiring stylus files with glob dependencies","suites":["stylus"],"updatePoint":{"line":94,"column":66,"index":3585},"line":94,"code":"  it('should support requiring stylus files with glob dependencies', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/stylus-glob-import/index.js'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }, {\n      name: 'index.css',\n      assets: ['index.styl']\n    }]);\n    let output = await run(b);\n    assert.equal(typeof output, 'function');\n    assert.equal(output(), 2);\n    let css = await outputFS.readFile(path.join(distDir, 'index.css'), 'utf8');\n    assert(css.includes('.index'));\n    assert(css.includes('.main'));\n    assert(css.includes('.foo'));\n    assert(css.includes('.bar'));\n  });","file":"stylus.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly parse SugarSS asset","suites":["sugarss"],"updatePoint":{"line":5,"column":42,"index":210},"line":5,"code":"  it('should correctly parse SugarSS asset', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/sugarss/index.sss'));\n    assertBundles(b, [{\n      name: 'index.css',\n      assets: ['index.sss']\n    }]);\n    let cssContent = await outputFS.readFile(path.join(distDir, '/index.css'), 'utf8');\n    assert(cssContent.includes('{'));\n  });","file":"sugarss.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming SVGs to react components","suites":["svg-react"],"updatePoint":{"line":5,"column":58,"index":204},"line":5,"code":"  it('should support transforming SVGs to react components', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/svg-react/react.js'), {\n      defaultConfig: path.join(__dirname, 'integration/custom-configs/.parcelrc-svg-react')\n    });\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf-8');\n    assert(!file.includes('inkscape'));\n    assert(file.includes('const SvgIcon ='));\n    assert(file.includes('_react.createElement(\"svg\"'));\n  });","file":"svg-react.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transforming SVGs to typescript react components","suites":["svg-react"],"updatePoint":{"line":14,"column":69,"index":706},"line":14,"code":"  it('should support transforming SVGs to typescript react components', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/svg-react-typescript/react.ts'), {\n      defaultConfig: path.join(__dirname, 'integration/custom-configs/.parcelrc-svg-react')\n    });\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf-8');\n    let types = await outputFS.readFile(b.getBundles()[1].filePath, 'utf-8');\n    assert(!file.includes('inkscape'));\n    assert(file.includes('react.createElement(\"svg\"'));\n    assert(types.includes('const Icon: SVGRComponent'));\n  });","file":"svg-react.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support bundling SVG","suites":["svg"],"updatePoint":{"line":5,"column":33,"index":197},"line":5,"code":"  it('should support bundling SVG', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/svg/circle.svg'));\n    assertBundles(b, [{\n      name: 'circle.svg',\n      assets: ['circle.svg']\n    }, {\n      name: 'other1.html',\n      assets: ['other1.html']\n    }, {\n      type: 'svg',\n      assets: ['square.svg']\n    }, {\n      name: 'other2.html',\n      assets: ['other2.html']\n    }, {\n      type: 'svg',\n      assets: ['path.svg']\n    }, {\n      type: 'svg',\n      assets: ['gradient.svg']\n    }, {\n      type: 'js',\n      assets: ['script.js']\n    }, {\n      type: 'js',\n      assets: ['module.js', 'script.js']\n    }, {\n      type: 'css',\n      assets: ['style.css']\n    }]);\n    let file = await outputFS.readFile(b.getBundles().find(b => b.type === 'svg').filePath, 'utf-8');\n    assert(file.includes('<a href=\"/other1.html\">'));\n    assert(file.includes('<use href=\"#circle\"'));\n    assert(file.includes(`<use xlink:href=\"/${path.basename(b.getBundles().find(b => b.name.startsWith('square')).filePath)}#square\"`));\n    assert(file.includes(`fill=\"url('/${path.basename(b.getBundles().find(b => b.name.startsWith('gradient')).filePath)}#myGradient')\"`));\n    assert(file.includes(`<script xlink:href=\"/${path.basename(b.getBundles().find(b => b.type === 'js' && b.env.sourceType === 'script').filePath)}\"`));\n    assert(file.includes(`<script href=\"/${path.basename(b.getBundles().find(b => b.type === 'js' && b.env.sourceType === 'module').filePath)}\"`));\n    assert(file.includes(`<?xml-stylesheet href=\"/${path.basename(b.getBundles().find(b => b.type === 'css').filePath)}\"?>`));\n  });","file":"svg.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify SVG bundles","suites":["svg"],"updatePoint":{"line":44,"column":31,"index":1811},"line":44,"code":"  it('should minify SVG bundles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/svg/circle.svg'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    let file = await outputFS.readFile(b.getBundles().find(b => b.type === 'svg').filePath, 'utf-8');\n    assert(!file.includes('comment'));\n  });","file":"svg.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"support SVGO config files","suites":["svg"],"updatePoint":{"line":53,"column":31,"index":2167},"line":53,"code":"  it('support SVGO config files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/svgo-config/index.html'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    let file = await outputFS.readFile(b.getBundles().find(b => b.type === 'svg').filePath, 'utf-8');\n    assert(!file.includes('inkscape'));\n    assert(file.includes('comment'));\n  });","file":"svg.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should detect xml-stylesheet processing instructions","suites":["svg"],"updatePoint":{"line":63,"column":58,"index":2597},"line":63,"code":"  it('should detect xml-stylesheet processing instructions', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/svg-xml-stylesheet/img.svg'));\n    assertBundles(b, [{\n      name: 'img.svg',\n      assets: ['img.svg']\n    }, {\n      type: 'css',\n      assets: ['style1.css']\n    }, {\n      type: 'css',\n      assets: ['style3.css']\n    }]);\n    let file = await outputFS.readFile(b.getBundles().find(b => b.type === 'svg').filePath, 'utf-8');\n    assert(file.includes('<?xml-stylesheet'));\n    assert(file.includes('<?xml-not-a-stylesheet'));\n  });","file":"svg.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle inline CSS with @imports","suites":["svg"],"updatePoint":{"line":79,"column":44,"index":3159},"line":79,"code":"  it('should handle inline CSS with @imports', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/svg-inline-css-import/img.svg'));\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['img.svg', 'test.css']\n    }, {\n      type: 'css',\n      assets: ['img.svg']\n    }, {\n      name: 'img.svg',\n      assets: ['img.svg']\n    }, {\n      type: 'svg',\n      assets: ['gradient.svg']\n    }, {\n      type: 'js',\n      assets: ['img.svg', 'script.js']\n    }]);\n    const svg = await outputFS.readFile(path.join(distDir, 'img.svg'), 'utf8');\n    assert(!svg.includes('@import'));\n    assert(svg.includes(':root {\\n  fill: red;\\n}'));\n    assert(svg.includes(`\"fill: url(&quot;${path.basename(b.getBundles().find(b => b.name.startsWith('gradient')).filePath)}#myGradient&quot;)`));\n    assert(svg.includes('<script>'));\n    assert(svg.includes(`console.log(\"script\")`));\n    assert(!svg.includes('import '));\n  });","file":"svg.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should process inline styles using lang","suites":["svg"],"updatePoint":{"line":105,"column":45,"index":4102},"line":105,"code":"  it('should process inline styles using lang', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/svg-inline-sass/img.svg'), {\n      defaultTargetOptions: {\n        shouldOptimize: true\n      }\n    });\n    assertBundles(b, [{\n      type: 'css',\n      assets: ['img.svg']\n    }, {\n      name: 'img.svg',\n      assets: ['img.svg']\n    }]);\n    const svg = await outputFS.readFile(path.join(distDir, 'img.svg'), 'utf8');\n    assert(svg.includes('<style>:root{fill:red}</style>'));\n  });","file":"svg.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should be in separate bundles","suites":["svg"],"updatePoint":{"line":121,"column":35,"index":4608},"line":121,"code":"  it('should be in separate bundles', async function () {\n    const b = await bundle(path.join(__dirname, '/integration/svg-multiple/index.js'));\n    assertBundles(b, [{\n      assets: ['index.js', 'bundle-url.js']\n    }, {\n      assets: ['circle.svg']\n    }, {\n      assets: ['square.svg']\n    }]);\n  });","file":"svg.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support tailwind from SCSS","suites":["tailwind"],"updatePoint":{"line":5,"column":39,"index":184},"line":5,"code":"  it('should support tailwind from SCSS', async function () {\n    let fixture = path.join(__dirname, '/integration/tailwind-scss');\n    let b = await bundle(path.join(fixture, 'index.html'));\n    let css = await outputFS.readFile(b.getBundles().find(b => b.type === 'css').filePath, 'utf8');\n    assert(css.includes('.p-2'));\n    assert(!css.includes('.m-2'));\n  });","file":"tailwind-tests.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not transpile if no targets are defined","suites":["transpilation"],"updatePoint":{"line":9,"column":52,"index":368},"line":9,"code":"  it('should not transpile if no targets are defined', async function () {\n    await bundle(path.join(__dirname, '/integration/babel-default/index.js'), {\n      defaultTargetOptions: {\n        engines: undefined,\n        shouldOptimize: false\n      }\n    });\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('class Foo'));\n    assert(file.includes('class Bar'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transpiling using browserlist","suites":["transpilation"],"updatePoint":{"line":20,"column":50,"index":791},"line":20,"code":"  it('should support transpiling using browserlist', async function () {\n    await bundle(path.join(__dirname, '/integration/babel-browserslist/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('function Foo'));\n    assert(file.includes('function Bar'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transpiling when engines have semver ranges","suites":["transpilation"],"updatePoint":{"line":26,"column":64,"index":1134},"line":26,"code":"  it('should support transpiling when engines have semver ranges', async () => {\n    let fixtureDir = path.join(__dirname, '/integration/babel-semver-engine');\n    await bundle(path.join(fixtureDir, 'index.js'));\n    let legacy = await outputFS.readFile(path.join(fixtureDir, 'dist', 'legacy.js'), 'utf8');\n    assert(legacy.includes('function Foo'));\n    assert(legacy.includes('function Bar'));\n    let modern = await outputFS.readFile(path.join(fixtureDir, 'dist', 'modern.js'), 'utf8');\n    assert(modern.includes('class Foo'));\n    assert(modern.includes('class Bar'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should transpile node_modules by default","suites":["transpilation"],"updatePoint":{"line":36,"column":46,"index":1697},"line":36,"code":"  it('should transpile node_modules by default', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/babel-node-modules/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!/class \\S+ \\{/.test(file));\n    assert(file.includes('function Bar'));\n    let res = await run(b);\n    assert.equal(res.t, 'function');\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not support JSX in node_modules","suites":["transpilation"],"updatePoint":{"line":44,"column":44,"index":2090},"line":44,"code":"  it('should not support JSX in node_modules', async function () {\n    // $FlowFixMe\n    await assert.rejects(() => bundle(path.join(__dirname, '/integration/babel-node-modules-jsx/index.js')));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile node_modules with a source field in package.json when not symlinked","suites":["transpilation"],"updatePoint":{"line":48,"column":88,"index":2335},"line":48,"code":"  it('should compile node_modules with a source field in package.json when not symlinked', async function () {\n    await bundle(path.join(__dirname, '/integration/babel-node-modules-source-unlinked/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('function Foo'));\n    assert(file.includes('function Bar'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX","suites":["transpilation"],"updatePoint":{"line":54,"column":34,"index":2664},"line":54,"code":"  it('should support compiling JSX', async function () {\n    await bundle(path.join(__dirname, '/integration/jsx/index.jsx'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('React.createElement(\"div\"'));\n    assert(file.includes('fileName: \"integration/jsx/index.jsx\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX correctly with member expression type","suites":["transpilation"],"updatePoint":{"line":60,"column":72,"index":3039},"line":60,"code":"  it('should support compiling JSX correctly with member expression type', async function () {\n    await bundle(path.join(__dirname, '/integration/jsx-member/index.jsx'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('React.createElement(S.Foo'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX in JS files with React dependency","suites":["transpilation"],"updatePoint":{"line":65,"column":68,"index":3349},"line":65,"code":"  it('should support compiling JSX in JS files with React dependency', async function () {\n    await bundle(path.join(__dirname, '/integration/jsx-react/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('React.createElement(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX with pure annotations","suites":["transpilation"],"updatePoint":{"line":70,"column":56,"index":3645},"line":70,"code":"  it('should support compiling JSX with pure annotations', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-react/pure-comment.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'pure-comment.js'), 'utf8');\n    assert(file.includes('/*#__PURE__*/ (0, _reactDefault.default).createElement'));\n    let res = await run(b);\n    assert(res.Foo());\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX in JS files with React aliased to Preact","suites":["transpilation"],"updatePoint":{"line":77,"column":75,"index":4062},"line":77,"code":"  it('should support compiling JSX in JS files with React aliased to Preact', async function () {\n    await bundle(path.join(__dirname, '/integration/jsx-react-alias/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('React.createElement(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX in JS files with Preact dependency","suites":["transpilation"],"updatePoint":{"line":82,"column":69,"index":4377},"line":82,"code":"  it('should support compiling JSX in JS files with Preact dependency', async function () {\n    await bundle(path.join(__dirname, '/integration/jsx-preact/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('h(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX in JS files with Preact url dependency","suites":["transpilation"],"updatePoint":{"line":87,"column":73,"index":4673},"line":87,"code":"  it('should support compiling JSX in JS files with Preact url dependency', async function () {\n    await bundle(path.join(__dirname, '/integration/jsx-preact-with-url/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('h(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX in TS files with Preact dependency","suites":["transpilation"],"updatePoint":{"line":92,"column":69,"index":4974},"line":92,"code":"  it('should support compiling JSX in TS files with Preact dependency', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-preact-ts/index.tsx'));\n    assert(typeof (await run(b)) === 'object');\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX in JS files with Nerv dependency","suites":["transpilation"],"updatePoint":{"line":96,"column":67,"index":5206},"line":96,"code":"  it('should support compiling JSX in JS files with Nerv dependency', async function () {\n    await bundle(path.join(__dirname, '/integration/jsx-nervjs/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('Nerv.createElement(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX in JS files with Hyperapp dependency","suites":["transpilation"],"updatePoint":{"line":101,"column":71,"index":5517},"line":101,"code":"  it('should support compiling JSX in JS files with Hyperapp dependency', async function () {\n    await bundle(path.join(__dirname, '/integration/jsx-hyperapp/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(file.includes('h(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not transpile spread in JSX with modern targets","suites":["transpilation"],"updatePoint":{"line":106,"column":60,"index":5802},"line":106,"code":"  it('should not transpile spread in JSX with modern targets', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-spread/index.jsx'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('React.createElement(\"div\"'));\n    assert(file.includes('...a'));\n    assert(!file.includes('@swc/helpers'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the automatic JSX runtime with React >= 17","suites":["transpilation"],"updatePoint":{"line":113,"column":63,"index":6190},"line":113,"code":"  it('should support the automatic JSX runtime with React >= 17', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-automatic/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('react/jsx-dev-runtime'));\n    assert(file.includes('(0, _jsxDevRuntime.jsxDEV)(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the automatic JSX runtime with preact >= 10.5","suites":["transpilation"],"updatePoint":{"line":119,"column":66,"index":6563},"line":119,"code":"  it('should support the automatic JSX runtime with preact >= 10.5', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-automatic-preact/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('preact/jsx-dev-runtime'));\n    assert(file.includes('(0, _jsxDevRuntime.jsxDEV)(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the automatic JSX runtime with React ^16.14.0","suites":["transpilation"],"updatePoint":{"line":125,"column":66,"index":6944},"line":125,"code":"  it('should support the automatic JSX runtime with React ^16.14.0', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-automatic-16/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('react/jsx-dev-runtime'));\n    assert(file.includes('(0, _jsxDevRuntime.jsxDEV)(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the automatic JSX runtime with React 18 prereleases","suites":["transpilation"],"updatePoint":{"line":131,"column":72,"index":7326},"line":131,"code":"  it('should support the automatic JSX runtime with React 18 prereleases', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-automatic-18/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('react/jsx-dev-runtime'));\n    assert(file.includes('(0, _jsxDevRuntime.jsxDEV)(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the automatic JSX runtime with experimental React versions","suites":["transpilation"],"updatePoint":{"line":137,"column":79,"index":7715},"line":137,"code":"  it('should support the automatic JSX runtime with experimental React versions', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-automatic-experimental/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('react/jsx-dev-runtime'));\n    assert(file.includes('(0, _jsxDevRuntime.jsxDEV)(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the automatic JSX runtime with preact with alias","suites":["transpilation"],"updatePoint":{"line":143,"column":69,"index":8104},"line":143,"code":"  it('should support the automatic JSX runtime with preact with alias', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-automatic-preact-with-alias/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(/\\Wreact\\/jsx-dev-runtime\\W/.test(file));\n    assert(file.includes('(0, _jsxDevRuntime.jsxDEV)(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support the automatic JSX runtime with explicit tsconfig.json","suites":["transpilation"],"updatePoint":{"line":149,"column":74,"index":8504},"line":149,"code":"  it('should support the automatic JSX runtime with explicit tsconfig.json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-automatic-tsconfig/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('preact/jsx-dev-runtime'));\n    assert(file.includes('(0, _jsxDevRuntime.jsxDEV)(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support explicit JSX pragma in tsconfig.json","suites":["transpilation"],"updatePoint":{"line":155,"column":57,"index":8878},"line":155,"code":"  it('should support explicit JSX pragma in tsconfig.json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-pragma-tsconfig/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('JSX(JSXFragment'));\n    assert(file.includes('JSX(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support explicitly enabling JSX in tsconfig.json","suites":["transpilation"],"updatePoint":{"line":161,"column":61,"index":9223},"line":161,"code":"  it('should support explicitly enabling JSX in tsconfig.json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/jsx-tsconfig/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('React.createElement(\"div\"'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support enabling decorators in tsconfig.json","suites":["transpilation"],"updatePoint":{"line":166,"column":57,"index":9527},"line":166,"code":"  it('should support enabling decorators in tsconfig.json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/decorators/index.ts'));\n    let output = [];\n    await run(b, {\n      output(o) {\n        output.push(o);\n      }\n    });\n    assert.deepEqual(output, ['first(): factory evaluated', 'second(): factory evaluated', 'second(): called', 'first(): called']);\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support enabling decorators and setting useDefineForClassFields in tsconfig.json","suites":["transpilation"],"updatePoint":{"line":176,"column":93,"index":9963},"line":176,"code":"  it('should support enabling decorators and setting useDefineForClassFields in tsconfig.json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/decorators-useDefineForClassFields/index.ts'));\n    let output = [];\n    await run(b, {\n      output(...o) {\n        output.push(...o);\n      }\n    });\n    assert.deepEqual(output, ['foo 15', 'foo 16']);\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support transpiling optional chaining","suites":["transpilation"],"updatePoint":{"line":186,"column":50,"index":10306},"line":186,"code":"  it('should support transpiling optional chaining', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/babel-optional-chaining/index.js'));\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(!file.includes('?.'));\n    let output = await run(b);\n    assert.equal(typeof output, 'object');\n    assert.deepEqual(output.default, [undefined, undefined]);\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should only include necessary parts of core-js using browserlist","suites":["transpilation"],"updatePoint":{"line":194,"column":70,"index":10748},"line":194,"code":"  it('should only include necessary parts of core-js using browserlist', async function () {\n    await bundle(path.join(__dirname, '/integration/babel-core-js/index.js'));\n    let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    // console.log(file)\n    assert(file.includes('async function Bar() {'));\n    // Check that core-js's globalThis polyfill is referenced.\n    // NOTE: This may change if core-js internals change.\n    assert(file.includes('esnext.global-this'));\n    assert(!file.includes('es.array.concat'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve @swc/helpers and regenerator-runtime relative to parcel","suites":["transpilation"],"updatePoint":{"line":204,"column":76,"index":11307},"line":204,"code":"  it('should resolve @swc/helpers and regenerator-runtime relative to parcel', async function () {\n    let dir = path.join('/tmp/' + Math.random().toString(36).slice(2));\n    await outputFS.mkdirp(dir);\n    await ncp(path.join(__dirname, '/integration/swc-helpers'), dir);\n    await bundle(path.join(dir, 'index.js'), {\n      mode: 'production',\n      inputFS: overlayFS,\n      defaultTargetOptions: {\n        engines: {\n          browsers: '>= 0.25%'\n        }\n      }\n    });\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs and esm versions of @swc/helpers","suites":["transpilation"],"updatePoint":{"line":218,"column":62,"index":11777},"line":218,"code":"  it('should support commonjs and esm versions of @swc/helpers', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/swc-helpers-library/index.js'));\n    let file = await outputFS.readFile(nullthrows(b.getBundles().find(b => b.env.outputFormat === 'commonjs')).filePath, 'utf8');\n    assert(file.includes('@swc/helpers/lib/_class_call_check.js'));\n    file = await outputFS.readFile(nullthrows(b.getBundles().find(b => b.env.outputFormat === 'esmodule')).filePath, 'utf8');\n    assert(file.includes('@swc/helpers/src/_class_call_check.mjs'));\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support commonjs versions of @swc/helpers without scope hoisting","suites":["transpilation"],"updatePoint":{"line":225,"column":77,"index":12369},"line":225,"code":"  it('should support commonjs versions of @swc/helpers without scope hoisting', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/swc-helpers-library/index.js'), {\n      targets: {\n        test: {\n          distDir,\n          isLibrary: true,\n          scopeHoist: false\n        }\n      }\n    });\n    let file = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(file.includes('@swc/helpers/lib/_class_call_check.js'));\n    await run(b);\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should print errors from transpilation","suites":["transpilation"],"updatePoint":{"line":239,"column":44,"index":12831},"line":239,"code":"  it('should print errors from transpilation', async function () {\n    let source = path.join(__dirname, '/integration/transpilation-invalid/index.js');\n    // $FlowFixMe\n    await assert.rejects(() => bundle(source), {\n      name: 'BuildError',\n      diagnostics: [{\n        codeFrames: [{\n          codeHighlights: [{\n            message: null,\n            start: {\n              column: 15,\n              line: 3\n            },\n            end: {\n              column: 43,\n              line: 3\n            }\n          }],\n          filePath: source\n        }],\n        hints: null,\n        message: 'Spread children are not supported in React.',\n        origin: '@parcel/transformer-js'\n      }, {\n        codeFrames: [{\n          codeHighlights: [{\n            message: null,\n            start: {\n              column: 4,\n              line: 7\n            },\n            end: {\n              column: 4,\n              line: 7\n            }\n          }],\n          filePath: source\n        }],\n        hints: null,\n        message: 'duplicate private name #x.',\n        origin: '@parcel/transformer-js'\n      }]\n    });\n  });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should compile node_modules when symlinked with a source field in package.json","suites":["transpilation","tests needing the real filesystem"],"updatePoint":{"line":295,"column":86,"index":14287},"line":295,"code":"    it('should compile node_modules when symlinked with a source field in package.json', async function () {\n      if (process.platform === 'win32') {\n        this.skip();\n        return;\n      }\n      const inputDir = path.join(__dirname, '/input');\n      await fs.rimraf(inputDir);\n      await fs.mkdirp(path.join(inputDir, 'node_modules'));\n      await fs.ncp(path.join(path.join(__dirname, '/integration/babel-node-modules-source')), inputDir);\n\n      // Create the symlink here to prevent cross platform and git issues\n      symlinkSync(path.join(inputDir, 'packages/foo'), path.join(inputDir, 'node_modules/foo'), 'dir');\n      await bundle(inputDir + '/index.js', {\n        outputFS: fs\n      });\n      let file = await fs.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(file.includes('function Foo'));\n      assert(file.includes('function Bar'));\n    });","file":"transpilation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate a typescript declaration file","suites":["typescript types"],"updatePoint":{"line":5,"column":51,"index":244},"line":5,"code":"  it('should generate a typescript declaration file', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/ts-types/main/index.ts'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.ts']\n    }, {\n      type: 'ts',\n      assets: ['index.ts']\n    }]);\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/main/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/main/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate ts declarations with imports","suites":["typescript types"],"updatePoint":{"line":18,"column":50,"index":834},"line":18,"code":"  it('should generate ts declarations with imports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/ts-types/importing/index.ts'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.ts', 'namespace.ts']\n    }, {\n      type: 'ts',\n      assets: ['index.ts']\n    }]);\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/importing/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/importing/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate ts declarations with imports and naming collisions","suites":["typescript types"],"updatePoint":{"line":31,"column":72,"index":1477},"line":31,"code":"  it('should generate ts declarations with imports and naming collisions', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/ts-types/importing-collision/index.ts'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.ts', 'other1.ts', 'other2.ts']\n    }, {\n      type: 'ts',\n      assets: ['index.ts']\n    }]);\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/importing-collision/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/importing-collision/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate ts declarations with exports","suites":["typescript types"],"updatePoint":{"line":44,"column":50,"index":2138},"line":44,"code":"  it('should generate ts declarations with exports', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/ts-types/exporting/index.ts'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.ts', 'message.ts', 'other.ts', 'test.ts']\n    }, {\n      type: 'ts',\n      assets: ['index.ts']\n    }]);\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/exporting/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/exporting/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate ts declarations with export of an overloaded function signature","suites":["typescript types"],"updatePoint":{"line":57,"column":85,"index":2815},"line":57,"code":"  it('should generate ts declarations with export of an overloaded function signature', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/ts-types/exporting-overload/index.ts'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.ts']\n    }, {\n      type: 'ts',\n      assets: ['index.ts']\n    }]);\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/exporting-overload/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/exporting-overload/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate ts declarations with externals","suites":["typescript types"],"updatePoint":{"line":70,"column":52,"index":3449},"line":70,"code":"  it('should generate ts declarations with externals', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/ts-types/externals/index.tsx'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.tsx', 'other.tsx']\n    }, {\n      type: 'ts',\n      assets: ['index.tsx']\n    }]);\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/externals/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/externals/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate ts declarations with externals that conflict with exported names","suites":["typescript types"],"updatePoint":{"line":83,"column":86,"index":4106},"line":83,"code":"  it('should generate ts declarations with externals that conflict with exported names', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/ts-types/import-export-collision/index.ts'));\n    assertBundles(b, [{\n      type: 'js',\n      assets: ['index.ts']\n    }, {\n      type: 'ts',\n      assets: ['index.ts']\n    }]);\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/import-export-collision/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/import-export-collision/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should remove private properties","suites":["typescript types"],"updatePoint":{"line":96,"column":38,"index":4741},"line":96,"code":"  it('should remove private properties', async function () {\n    await bundle(path.join(__dirname, '/integration/ts-types/private/index.ts'));\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/private/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/private/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should not throw errors on typing of a callback which returns a promise or value","suites":["typescript types"],"updatePoint":{"line":102,"column":86,"index":5236},"line":102,"code":"  it('should not throw errors on typing of a callback which returns a promise or value', async function () {\n    await bundle(path.join(__dirname, '/integration/ts-types/promise-or-value/index.ts'));\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/promise-or-value/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/promise-or-value/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should correctly reference unbuilt monorepo packages","suites":["typescript types"],"updatePoint":{"line":108,"column":58,"index":5730},"line":108,"code":"  it('should correctly reference unbuilt monorepo packages', async function () {\n    let fixtureDir = path.join(__dirname, 'integration/ts-types/monorepo');\n    await outputFS.mkdirp(path.join(fixtureDir, 'node_modules'));\n    await ncp(fixtureDir, fixtureDir);\n    await outputFS.symlink(path.join(fixtureDir, 'b'), path.join(fixtureDir, 'node_modules/b'));\n    let b = await bundle(path.join(fixtureDir, 'a'), {\n      inputFS: overlayFS\n    });\n    assertBundles(b, [{\n      type: 'ts',\n      assets: ['index.ts']\n    }]);\n    let dist = (await outputFS.readFile(b.getBundles()[0].filePath, 'utf8')).replace(/\\r\\n/g, '\\n');\n    assert(/import\\s*{\\s*B\\s*}\\s*from\\s*\"b\";/.test(dist));\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should generate a typescript declaration file even when composite and incremental are true","suites":["typescript types"],"updatePoint":{"line":123,"column":96,"index":6459},"line":123,"code":"  it('should generate a typescript declaration file even when composite and incremental are true', async function () {\n    await bundle(path.join(__dirname, '/integration/ts-types/composite/index.ts'));\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/composite/dist/index.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/composite/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work with module augmentation","suites":["typescript types"],"updatePoint":{"line":129,"column":42,"index":6916},"line":129,"code":"  it('should work with module augmentation', async function () {\n    let fixtureDir = path.join(__dirname, 'integration/ts-types/augmentation');\n    await outputFS.mkdirp(path.join(fixtureDir, 'node_modules'));\n    await ncp(fixtureDir, fixtureDir);\n    await outputFS.symlink(path.join(fixtureDir, 'original'), path.join(fixtureDir, 'node_modules/original'));\n    let b = await bundle(path.join(fixtureDir, 'augmenter'), {\n      inputFS: overlayFS\n    });\n    assertBundles(b, [{\n      name: 'index.js',\n      type: 'js',\n      assets: ['index.ts']\n    }, {\n      name: 'index.d.ts',\n      type: 'ts',\n      assets: ['index.ts']\n    }]);\n    let dist = (await outputFS.readFile(path.join(fixtureDir, 'augmenter/dist/index.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(fixtureDir, 'augmenter/src/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle re-exporting aggregating correctly","suites":["typescript types"],"updatePoint":{"line":150,"column":54,"index":7837},"line":150,"code":"  it('should handle re-exporting aggregating correctly', async function () {\n    await bundle(path.join(__dirname, '/integration/ts-types/re-exporting-aggregating/index.ts'));\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/re-exporting-aggregating/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/re-exporting-aggregating/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle a tsconfig file with paths on windows","suites":["typescript types"],"updatePoint":{"line":156,"column":57,"index":8354},"line":156,"code":"  it('should handle a tsconfig file with paths on windows', async function () {\n    await bundle(path.join(__dirname, '/integration/ts-types/windows-paths/index.ts'));\n    let dist = (await outputFS.readFile(path.join(__dirname, '/integration/ts-types/windows-paths/dist/types.d.ts'), 'utf8')).replace(/\\r\\n/g, '\\n');\n    let expected = await inputFS.readFile(path.join(__dirname, '/integration/ts-types/windows-paths/expected.d.ts'), 'utf8');\n    assert.equal(dist, expected);\n  });","file":"ts-types.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw validation error on typescript typing errors across multiple files","suites":["ts-validator"],"updatePoint":{"line":13,"column":85,"index":540},"line":13,"code":"  it('should throw validation error on typescript typing errors across multiple files', async function () {\n    let didThrow = false;\n    let entry = normalizeFilePath(path.join(__dirname, '/integration/ts-validation-error/index.ts'));\n    let testFile = normalizeFilePath(path.join(__dirname, '/integration/ts-validation-error/test.ts'));\n    try {\n      await bundle(entry, {\n        defaultConfig: config\n      });\n    } catch (e) {\n      assert.equal(e.name, 'BuildError');\n      assert(!!Array.isArray(e.diagnostics));\n      assert(e.diagnostics.length === 2);\n      let entryDiagnostic = e.diagnostics.find(diagnostic => diagnostic.codeFrames[0].filePath === entry);\n      assert(!!entryDiagnostic);\n      assert(!!entryDiagnostic.codeFrames);\n      assert.equal(entryDiagnostic.origin, '@parcel/validator-typescript');\n      assert.equal(entryDiagnostic.message, `Argument of type 'string' is not assignable to parameter of type 'Params'.`);\n      assert.equal(entryDiagnostic.codeFrames[0].filePath, entry);\n      let testFileDiagnostic = e.diagnostics.find(diagnostic => diagnostic.codeFrames[0].filePath === testFile);\n      assert(!!testFileDiagnostic);\n      assert(!!testFileDiagnostic.codeFrames);\n      assert.equal(testFileDiagnostic.origin, '@parcel/validator-typescript');\n      assert.equal(testFileDiagnostic.message, `Property 'world' does not exist on type 'Params'.`);\n      didThrow = true;\n    }\n    assert(didThrow);\n  });","file":"ts-validation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should re-run when .ts files change","suites":["ts-validator"],"updatePoint":{"line":40,"column":41,"index":1945},"line":40,"code":"  it('should re-run when .ts files change', async function () {\n    // We to try to avoid conflicts between tests using the same in-memory file system, we're creating a separate folder.\n    // During the first test pass, this is unnecessary, but because fileSystems won't be re-created when running in 'watch' mode, this is safer.\n    const inputDir = path.join(__dirname, '/ts-validator-change');\n    await outputFS.mkdirp(inputDir);\n    await outputFS.writeFile(path.join(inputDir, '/tsconfig.json'), `{}`);\n    await outputFS.writeFile(path.join(inputDir, '/index.ts'), `export const message: number = \"This is a type error!\"`);\n    let b = bundler(path.join(inputDir, '/index.ts'), {\n      inputFS: overlayFS,\n      defaultConfig: config\n    });\n    subscription = await b.watch();\n    let buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildFailure');\n    assert.equal(buildEvent.diagnostics.length, 1);\n    assert.equal(buildEvent.diagnostics[0].message, \"Type 'string' is not assignable to type 'number'.\");\n    await outputFS.writeFile(path.join(inputDir, '/index.ts'), `export const message: string = \"The type error is fixed!\"`);\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    let output = await run(buildEvent.bundleGraph);\n    assert.equal(output.message, 'The type error is fixed!');\n    await outputFS.writeFile(path.join(inputDir, '/index.ts'), `export const message: boolean = {}`);\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildFailure');\n    assert.equal(buildEvent.diagnostics.length, 1);\n    assert.equal(buildEvent.diagnostics[0].message, \"Type '{}' is not assignable to type 'boolean'.\");\n  });","file":"ts-validation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should report correct errors when multiple .ts files change at the same time - no errors","suites":["ts-validator"],"updatePoint":{"line":67,"column":94,"index":3721},"line":67,"code":"  it('should report correct errors when multiple .ts files change at the same time - no errors', async function () {\n    // We to try to avoid conflicts between tests using the same in-memory file system, we're creating a separate folder.\n    // During the first test pass, this is unnecessary, but because fileSystems won't be re-created when running in 'watch' mode, this is safer.\n    const inputDir = path.join(__dirname, '/ts-validator-multi-change');\n    await outputFS.mkdirp(inputDir);\n    await outputFS.writeFile(path.join(inputDir, '/tsconfig.json'), `{}`);\n    await outputFS.writeFile(path.join(inputDir, '/index.ts'), `import { returnMessage } from \"./returnMessage\";\n      const message: string = \"My Message!\";\n      export const output = returnMessage(message);`);\n    await outputFS.writeFile(path.join(inputDir, '/returnMessage.ts'), `export function returnMessage(message: string): string { return message; }`);\n    let b = bundler([path.join(inputDir, '/index.ts')], {\n      inputFS: overlayFS,\n      defaultConfig: config\n    });\n    subscription = await b.watch();\n    let buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    let output = await run(buildEvent.bundleGraph);\n    assert.equal(output.output, 'My Message!');\n    await outputFS.writeFile(path.join(inputDir, '/index.ts'), `import { returnMessage } from \"./returnMessage\";\n      const message: number = 123456;\n      export const output = returnMessage(message);`);\n    await outputFS.writeFile(path.join(inputDir, '/returnMessage.ts'), `export function returnMessage(message: number): number { return message; }`);\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    output = await run(buildEvent.bundleGraph);\n    assert.equal(output.output, 123456);\n  });","file":"ts-validation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should report correct errors when multiple .ts files change at the same time - with errors","suites":["ts-validator"],"updatePoint":{"line":95,"column":96,"index":5548},"line":95,"code":"  it('should report correct errors when multiple .ts files change at the same time - with errors', async function () {\n    // We to try to avoid conflicts between tests using the same in-memory file system, we're creating a separate folder.\n    // During the first test pass, this is unnecessary, but because fileSystems won't be re-created when running in 'watch' mode, this is safer.\n    const inputDir = path.join(__dirname, '/ts-validator-multi-change-errors');\n    await outputFS.mkdirp(inputDir);\n    await outputFS.writeFile(path.join(inputDir, '/tsconfig.json'), `{}`);\n    await outputFS.writeFile(path.join(inputDir, '/index.ts'), `import { returnMessage } from \"./returnMessage\";\n      const message: string = \"My Message!\";\n      export const output: string = returnMessage(message);`);\n    await outputFS.writeFile(path.join(inputDir, '/returnMessage.ts'), `export function returnMessage(message: number): number { return message; }`);\n    let b = bundler([path.join(inputDir, '/index.ts')], {\n      inputFS: overlayFS,\n      defaultConfig: config\n    });\n    subscription = await b.watch();\n    let buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildFailure');\n    assert.equal(buildEvent.diagnostics.length, 2);\n    assert.equal(buildEvent.diagnostics[1].message, \"Argument of type 'string' is not assignable to parameter of type 'number'.\");\n    await outputFS.writeFile(path.join(inputDir, '/index.ts'), `import { returnMessage } from \"./returnMessage\";\n      const message: boolean = true;\n      export const output: boolean = returnMessage(message);`);\n    await outputFS.writeFile(path.join(inputDir, '/returnMessage.ts'), `export function returnMessage(message: null): null { return message; }`);\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildFailure');\n    assert.equal(buildEvent.diagnostics.length, 1);\n    assert.equal(buildEvent.diagnostics[0].message, \"Argument of type 'true' is not assignable to parameter of type 'null'.\");\n  });","file":"ts-validation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should report correct errors when .ts dependencies change in a way that breaks a contract","suites":["ts-validator"],"updatePoint":{"line":123,"column":95,"index":7566},"line":123,"code":"  it('should report correct errors when .ts dependencies change in a way that breaks a contract', async function () {\n    // We to try to avoid conflicts between tests using the same in-memory file system, we're creating a separate folder.\n    // During the first test pass, this is unnecessary, but because fileSystems won't be re-created when running in 'watch' mode, this is safer.\n    const inputDir = path.join(__dirname, '/ts-validator-dependencies-change');\n    await outputFS.mkdirp(inputDir);\n    await outputFS.writeFile(path.join(inputDir, '/tsconfig.json'), `{}`);\n    await outputFS.writeFile(path.join(inputDir, '/index.ts'), `import { returnMessage } from \"./returnMessage\";\n      const message: string = \"My Message!\";\n      export const output = returnMessage(message);`);\n    await outputFS.writeFile(path.join(inputDir, '/returnMessage.ts'), `export function returnMessage(message: string): string { return message; }`);\n    let b = bundler([path.join(inputDir, '/index.ts')], {\n      inputFS: overlayFS,\n      defaultConfig: config\n    });\n    subscription = await b.watch();\n    let buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    let output = await run(buildEvent.bundleGraph);\n    assert.equal(output.output, 'My Message!');\n    await outputFS.writeFile(path.join(inputDir, '/returnMessage.ts'), `export function returnMessage(message: number): number { return message; }`);\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildFailure');\n    assert.equal(buildEvent.diagnostics.length, 1);\n    assert.equal(buildEvent.diagnostics[0].message, \"Argument of type 'string' is not assignable to parameter of type 'number'.\");\n  });","file":"ts-validation.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support loading tsconfig.json","suites":["typescript tsc"],"updatePoint":{"line":6,"column":42,"index":303},"line":6,"code":"  it('should support loading tsconfig.json', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/typescript-config/index.ts'), {\n      config\n    });\n    let output = await run(b);\n    assert.equal(output, 2);\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!js.includes('/* test comment */'));\n  });","file":"typescript-tsc.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support loading tsconfig.json with extends","suites":["typescript tsc"],"updatePoint":{"line":15,"column":55,"index":680},"line":15,"code":"  it('should support loading tsconfig.json with extends', async () => {\n    let b = await bundle(path.join(__dirname, '/integration/typescript-config-extends/index.ts'), {\n      config\n    });\n    let output = await run(b);\n    assert.equal(output, 2);\n    let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!js.includes('/* test comment */'));\n  });","file":"typescript-tsc.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a type declaration file when overriding the ts pipeline","suites":["typescript tsc"],"updatePoint":{"line":24,"column":76,"index":1086},"line":24,"code":"  it('should produce a type declaration file when overriding the ts pipeline', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/typescript-types-parcelrc/index.ts'));\n    assertBundles(b, [{\n      name: 'index.js',\n      assets: ['index.ts']\n    }, {\n      name: 'index.d.ts',\n      assets: ['index.ts']\n    }]);\n    let output = await run(b);\n    assert.equal(new output.Foo().run(), 'bar');\n  });","file":"typescript-tsc.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a ts bundle using ES6 imports","suites":["typescript"],"updatePoint":{"line":14,"column":52,"index":798},"line":14,"code":"    it('should produce a ts bundle using ES6 imports', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/typescript/index.ts'), {\n        config\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['index.ts', 'Local.ts', 'esmodule-helpers.js']\n      }]);\n      let output = await run(b);\n      assert.equal(typeof output.count, 'function');\n      assert.equal(output.count(), 3);\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a ts bundle using commonJS require","suites":["typescript"],"updatePoint":{"line":26,"column":57,"index":1244},"line":26,"code":"    it('should produce a ts bundle using commonJS require', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/typescript-require/index.ts'), {\n        config\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['index.ts', 'Local.ts', 'esmodule-helpers.js']\n      }]);\n      let output = await run(b);\n      assert.equal(typeof output.count, 'function');\n      assert.equal(output.count(), 3);\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support json require","suites":["typescript"],"updatePoint":{"line":38,"column":35,"index":1676},"line":38,"code":"    it('should support json require', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/typescript-json/index.ts'));\n\n      // assert.equal(b.assets.size, 2);\n      // assert.equal(b.childBundles.size, 1);\n\n      let output = await run(b);\n      assert.equal(typeof output.count, 'function');\n      assert.equal(output.count(), 3);\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support env variables","suites":["typescript"],"updatePoint":{"line":48,"column":36,"index":2049},"line":48,"code":"    it('should support env variables', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/typescript-env/index.ts'), {\n        config\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['index.ts', 'esmodule-helpers.js']\n      }]);\n      let output = await run(b);\n      assert.equal(typeof output.env, 'function');\n      assert.equal(output.env(), 'test');\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support importing a URL to a raw asset","suites":["typescript"],"updatePoint":{"line":60,"column":53,"index":2484},"line":60,"code":"    it('should support importing a URL to a raw asset', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/typescript-raw/index.ts'), {\n        config\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['index.ts', 'bundle-url.js', 'esmodule-helpers.js']\n      }, {\n        type: 'txt',\n        assets: ['test.txt']\n      }]);\n      let output = await run(b);\n      assert.equal(typeof output.getRaw, 'function');\n      assert(/http:\\/\\/localhost\\/test\\.[0-9a-f]+\\.txt$/.test(output.getRaw()));\n      assert(await outputFS.exists(path.join(distDir, url.parse(output.getRaw()).pathname)));\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should minify with minify enabled","suites":["typescript"],"updatePoint":{"line":76,"column":41,"index":3127},"line":76,"code":"    it('should minify with minify enabled', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/typescript-require/index.ts'), {\n        config,\n        defaultTargetOptions: {\n          shouldOptimize: true\n        }\n      });\n      assertBundles(b, [{\n        type: 'js',\n        assets: ['index.ts', 'Local.ts', 'esmodule-helpers.js']\n      }]);\n      let output = await run(b);\n      assert.equal(typeof output.count, 'function');\n      assert.equal(output.count(), 3);\n      let js = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(!js.includes('local.a'));\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support compiling JSX","suites":["typescript"],"updatePoint":{"line":93,"column":36,"index":3753},"line":93,"code":"    it('should support compiling JSX', async function () {\n      await bundle(path.join(__dirname, '/integration/typescript-jsx/index.tsx'), {\n        config\n      });\n      let file = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n      assert(file.includes('React.createElement(\"div\"'));\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should use esModuleInterop by default","suites":["typescript"],"updatePoint":{"line":100,"column":45,"index":4078},"line":100,"code":"    it('should use esModuleInterop by default', async function () {\n      let b = await bundle(path.join(__dirname, '/integration/typescript-interop/index.ts'), {\n        config\n      });\n      assertBundles(b, [{\n        name: 'index.js',\n        assets: ['esmodule-helpers.js', 'index.ts', 'commonjs-module.js']\n      }]);\n      let output = await run(b);\n      assert.equal(typeof output.test, 'function');\n      assert.equal(output.test(), 'test passed');\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"fs.readFileSync should inline a file as a string","suites":["typescript"],"updatePoint":{"line":112,"column":56,"index":4557},"line":112,"code":"    it('fs.readFileSync should inline a file as a string', async function () {\n      if (config != null) {\n        return;\n      }\n      let b = await bundle(path.join(__dirname, '/integration/typescript-fs/index.ts'), {\n        config\n      });\n      const text = 'export default <div>Hello</div>;';\n      let output = await run(b);\n      assert.deepEqual(output, {\n        fromTs: text,\n        fromTsx: text\n      });\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle legacy cast in .ts file","suites":["typescript"],"updatePoint":{"line":126,"column":45,"index":4975},"line":126,"code":"    it('should handle legacy cast in .ts file', async function () {\n      if (config != null) {\n        return;\n      }\n      await bundle(path.join(__dirname, '/integration/typescript-legacy-cast/index.ts'), {\n        config\n      });\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should handle compile enums correctly","suites":["typescript"],"updatePoint":{"line":134,"column":45,"index":5219},"line":134,"code":"    it('should handle compile enums correctly', async function () {\n      if (config != null) {\n        return;\n      }\n      let b = await bundle(path.join(__dirname, '/integration/typescript-enum/index.ts'), {\n        config\n      });\n      let output = await run(b);\n      assert.deepEqual(output, {\n        A: {\n          X: 'X',\n          Y: 'Y'\n        },\n        B: {\n          X: 'X',\n          Y: 'Y'\n        },\n        C: {\n          X: 'X',\n          Y: 'Y'\n        },\n        z: {\n          a: 'X',\n          c: 'Y'\n        }\n      });\n    });","file":"typescript.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a basic vue bundle","suites":["vue"],"updatePoint":{"line":5,"column":39,"index":193},"line":5,"code":"  it('should produce a basic vue bundle', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-basic/Basic.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert.deepEqual(output.data(), {\n      msg: 'Hello from Component A!'\n    });\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a vue bundle with dependencies","suites":["vue"],"updatePoint":{"line":13,"column":51,"index":533},"line":13,"code":"  it('should produce a vue bundle with dependencies', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-dependencies/App.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert.deepEqual(output.data(), {\n      msg: 'Welcome to Your Vue.js App!'\n    });\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a vue bundle using preprocessors","suites":["vue"],"updatePoint":{"line":21,"column":53,"index":884},"line":21,"code":"  it('should produce a vue bundle using preprocessors', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-preprocessors/pre-processors.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert.deepEqual(output.data(), {\n      msg: 'Hello from coffee!'\n    });\n    let contents = await outputFS.readFile(path.join(distDir, 'pre-processors.css'), 'utf8');\n    assert(contents.includes('color: #999'));\n    assert(contents.includes('background: red'));\n    assert(contents.includes('color: green'));\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a vue bundle using scoped styles","suites":["vue"],"updatePoint":{"line":33,"column":53,"index":1475},"line":33,"code":"  it('should produce a vue bundle using scoped styles', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-scoped/App.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert(/^data-v-[0-9a-h]{6}$/.test(output.__scopeId));\n    assert.deepEqual(output.data(), {\n      ok: true\n    });\n    let contents = await outputFS.readFile(path.join(distDir, 'App.css'), 'utf8');\n    assert(contents.includes(`.test[${output.__scopeId}]`));\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a vue bundle using CSS modules","suites":["vue"],"updatePoint":{"line":44,"column":51,"index":1995},"line":44,"code":"  it('should produce a vue bundle using CSS modules', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-css-modules/App.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    let modules = output.__cssModules;\n    assert.equal(typeof modules.$style.red, 'string');\n    let contents = await outputFS.readFile(path.join(distDir, 'App.css'), 'utf8');\n    assert(contents.includes('.' + modules.$style.red));\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should bundle nested components dynamically","suites":["vue"],"updatePoint":{"line":53,"column":49,"index":2488},"line":53,"code":"  it('should bundle nested components dynamically', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-nested-components/testcomp.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert.equal(typeof output.components.InsideComp, 'function');\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should apply custom block preprocessors","suites":["vue"],"updatePoint":{"line":59,"column":45,"index":2821},"line":59,"code":"  it('should apply custom block preprocessors', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-custom-blocks/App.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert.deepEqual(output.data().docs, {\n      standard: '\\nThis component represents the home page of the application.\\n',\n      brief: '\\nHome Page\\n'\n    });\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should produce a basic production vue bundle","suites":["vue"],"updatePoint":{"line":68,"column":50,"index":3246},"line":68,"code":"  it('should produce a basic production vue bundle', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-basic/Basic.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert.deepEqual(output.data(), {\n      msg: 'Hello from Component A!'\n    });\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should load external templates/styles/scripts properly","suites":["vue"],"updatePoint":{"line":76,"column":60,"index":3595},"line":76,"code":"  it('should load external templates/styles/scripts properly', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-external-files/App.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert.deepEqual(output.data(), {\n      msg: 'Hello World'\n    });\n    let contents = await outputFS.readFile(path.join(distDir, 'App.css'), 'utf8');\n    assert(contents.includes('color: #c0ff33'));\n    assert(contents.includes('h2:hover'));\n    assert(contents.includes('.box p'));\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should load <script setup> component files","suites":["vue"],"updatePoint":{"line":88,"column":48,"index":4143},"line":88,"code":"  it('should load <script setup> component files', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/vue-script-setup/App.vue'));\n    let output = (await run(b)).default;\n    assert.equal(typeof output.render, 'function');\n    assert.equal(typeof output.setup, 'function');\n  });","file":"vue.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should preload a wasm file for a sync require","suites":["wasm","--target="],"updatePoint":{"line":10,"column":55,"index":379},"line":10,"code":"      it('should preload a wasm file for a sync require', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/wasm-sync/index.js'), {\n          target\n        });\n        await assertBundleTree(b, {\n          name: 'index.js',\n          assets: ['index.js', 'bundle-loader.js', 'bundle-url.js', 'wasm-loader.js'],\n          childBundles: [{\n            type: 'wasm',\n            assets: ['add.wasm'],\n            childBundles: []\n          }, {\n            type: 'map'\n          }]\n        });\n        let promise = deferred();\n        await run(b, {\n          output: promise.resolve\n        }, {\n          require: false\n        });\n        assert.equal(await promise, 5);\n      });","file":"wasm.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should load a wasm file asynchronously with dynamic import","suites":["wasm","--target="],"updatePoint":{"line":33,"column":68,"index":1109},"line":33,"code":"      it('should load a wasm file asynchronously with dynamic import', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/wasm-async/index.js'), {\n          target\n        });\n        await assertBundleTree(b, {\n          name: 'index.js',\n          assets: ['index.js', 'bundle-loader.js', 'bundle-url.js', 'wasm-loader.js'],\n          childBundles: [{\n            type: 'wasm',\n            assets: ['add.wasm'],\n            childBundles: []\n          }, {\n            type: 'map'\n          }]\n        });\n        var res = await run(b);\n        assert.equal(await res, 5);\n      });","file":"wasm.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should load a wasm file in parallel with a dynamic JS import","suites":["wasm","--target="],"updatePoint":{"line":51,"column":70,"index":1729},"line":51,"code":"      it('should load a wasm file in parallel with a dynamic JS import', async function () {\n        let b = await bundle(path.join(__dirname, '/integration/wasm-dynamic/index.js'), {\n          target\n        });\n        await assertBundleTree(b, {\n          name: 'index.js',\n          assets: ['index.js', 'bundle-loader.js', 'bundle-url.js', 'js-loader.js', 'wasm-loader.js'],\n          childBundles: [{\n            type: 'js',\n            assets: ['dynamic.js'],\n            childBundles: [{\n              type: 'wasm',\n              assets: ['add.wasm'],\n              childBundles: []\n            }, {\n              type: 'map'\n            }]\n          }, {\n            type: 'map'\n          }]\n        });\n        var res = await run(b);\n        assert.equal(await res, 5);\n      });","file":"wasm.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should rebuild on source file change","suites":["watcher"],"updatePoint":{"line":16,"column":42,"index":616},"line":16,"code":"  it('should rebuild on source file change', async function () {\n    await outputFS.mkdirp(inputDir);\n    await outputFS.writeFile(path.join(inputDir, '/index.js'), 'module.exports = \"hello\"', 'utf8');\n    let b = bundler(path.join(inputDir, '/index.js'), {\n      inputFS: overlayFS\n    });\n    subscription = await b.watch();\n    let buildEvent = await getNextBuild(b);\n    let output = await run(buildEvent.bundleGraph);\n    assert.equal(output, 'hello');\n    await outputFS.writeFile(path.join(inputDir, '/index.js'), 'module.exports = \"something else\"', 'utf8');\n    buildEvent = await getNextBuild(b);\n    output = await run(buildEvent.bundleGraph);\n    assert.equal(output, 'something else');\n  });","file":"watcher.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should rebuild on a source file change after a failed transformation","suites":["watcher"],"updatePoint":{"line":31,"column":74,"index":1353},"line":31,"code":"  it('should rebuild on a source file change after a failed transformation', async () => {\n    await outputFS.mkdirp(inputDir);\n    await outputFS.writeFile(path.join(inputDir, '/index.js'), 'syntax\\\\error', 'utf8');\n    let b = bundler(path.join(inputDir, '/index.js'), {\n      inputFS: overlayFS\n    });\n    subscription = await b.watch();\n    let buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildFailure');\n    await outputFS.writeFile(path.join(inputDir, '/index.js'), 'module.exports = \"hello\"', 'utf8');\n    buildEvent = await getNextBuild(b);\n    let output = await run(buildEvent.bundleGraph);\n    assert.equal(output, 'hello');\n  });","file":"watcher.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should rebuild on a config file change","suites":["watcher"],"updatePoint":{"line":45,"column":44,"index":1993},"line":45,"code":"  it('should rebuild on a config file change', async function () {\n    let inDir = path.join(__dirname, 'integration/parcelrc-custom');\n    let outDir = path.join(inDir, 'dist');\n    await ncp(path.join(__dirname, 'integration/parcelrc-custom'), inDir);\n    await ncp(path.dirname(require.resolve('@parcel/config-default')), path.join(inDir, 'node_modules', '@parcel', 'config-default'));\n    let copyPath = path.join(inDir, 'configCopy');\n    let configPath = path.join(inDir, '.parcelrc');\n    let b = bundler(path.join(inDir, 'index.js'), {\n      inputFS: overlayFS,\n      targets: {\n        main: {\n          distDir: outDir\n        }\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let distFile = await outputFS.readFile(path.join(outDir, 'index.js'), 'utf8');\n    assert(distFile.includes('() => null'));\n    await outputFS.copyFile(copyPath, configPath);\n    await getNextBuild(b);\n    distFile = await outputFS.readFile(path.join(outDir, 'index.js'), 'utf8');\n    assert(distFile.includes('TRANSFORMED CODE'));\n  });","file":"watcher.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should rebuild properly when a dependency is removed","suites":["watcher"],"updatePoint":{"line":69,"column":58,"index":3067},"line":69,"code":"  it('should rebuild properly when a dependency is removed', async function () {\n    await ncp(path.join(__dirname, 'integration/babel-default'), inputDir);\n    let b = bundler(path.join(inputDir, 'index.js'), {\n      inputFS: overlayFS,\n      targets: {\n        main: {\n          engines: {\n            node: '^8.0.0'\n          },\n          distDir\n        }\n      }\n    });\n    subscription = await b.watch();\n    await getNextBuild(b);\n    let distFile = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(distFile.includes('Foo'));\n    await outputFS.writeFile(path.join(inputDir, 'index.js'), 'console.log(\"no more dependencies\")');\n    await getNextBuild(b);\n    distFile = await outputFS.readFile(path.join(distDir, 'index.js'), 'utf8');\n    assert(!distFile.includes('Foo'));\n  });","file":"watcher.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should re-generate bundle tree when files change","suites":["watcher"],"line":91,"code":"  it.skip('should re-generate bundle tree when files change', async function () {","file":"watcher.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should only re-package bundles that changed","suites":["watcher"],"line":142,"code":"  it.skip('should only re-package bundles that changed', async function () {","file":"watcher.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should unload assets that are orphaned","suites":["watcher"],"line":156,"code":"  it.skip('should unload assets that are orphaned', async function () {","file":"watcher.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should recompile all assets when a config file changes","suites":["watcher"],"line":208,"code":"  it.skip('should recompile all assets when a config file changes', async function () {","file":"watcher.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should rebuild if the file behind a symlink changes","suites":["watcher"],"line":228,"code":"  it.skip('should rebuild if the file behind a symlink changes', async function () {","file":"watcher.js","skipped":true,"dir":"packages/core/integration-tests/test"},{"name":"should add and remove necessary runtimes to bundles","suites":["watcher"],"updatePoint":{"line":253,"column":57,"index":9755},"line":253,"code":"  it('should add and remove necessary runtimes to bundles', async () => {\n    await ncp(path.join(__dirname, 'integration/dynamic'), inputDir);\n    let indexPath = path.join(inputDir, 'index.js');\n    let b = bundler(indexPath, {\n      inputFS: overlayFS\n    });\n    let bundleGraph;\n    subscription = await b.watch((err, event) => {\n      assert(event.type === 'buildSuccess');\n      bundleGraph = event.bundleGraph;\n    });\n    await getNextBuild(b);\n    assertBundles(bundleGraph, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['local.js']\n    }]);\n    await outputFS.writeFile(path.join(inputDir, 'other.js'), '');\n    await outputFS.writeFile(indexPath, (await outputFS.readFile(indexPath, 'utf8')) + \"\\nimport('./other.js');\\n\");\n    await getNextBuild(b);\n    assertBundles(bundleGraph, [{\n      name: 'index.js',\n      assets: ['index.js', 'bundle-url.js', 'cacheLoader.js', 'js-loader.js']\n    }, {\n      assets: ['local.js']\n    }, {\n      assets: ['other.js']\n    }]);\n    await outputFS.writeFile(indexPath, '');\n    await getNextBuild(b);\n    assertBundles(bundleGraph, [{\n      name: 'index.js',\n      assets: ['index.js']\n    }]);\n  });","file":"watcher.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should rebuild if a missing file is added","suites":["watcher"],"updatePoint":{"line":289,"column":47,"index":10980},"line":289,"code":"  it('should rebuild if a missing file is added', async function () {\n    await outputFS.mkdirp(inputDir);\n    await outputFS.writeFile(path.join(inputDir, '/index.js'), 'import {other} from \"./other\";\\nexport default other;', 'utf8');\n    let b = bundler(path.join(inputDir, 'index.js'), {\n      inputFS: overlayFS\n    });\n    subscription = await b.watch();\n    let buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildFailure');\n    await outputFS.writeFile(path.join(inputDir, '/other.js'), 'export const other = 2;', 'utf8');\n    buildEvent = await getNextBuild(b);\n    assert.equal(buildEvent.type, 'buildSuccess');\n    let res = await run(buildEvent.bundleGraph);\n    assert.equal(res.default, 2);\n  });","file":"watcher.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve a full webextension bundle","suites":["webextension"],"updatePoint":{"line":5,"column":47,"index":220},"line":5,"code":"  it('should resolve a full webextension bundle', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/webextension/manifest.json'));\n    assertBundles(b, [{\n      name: 'tmp.aff',\n      assets: ['tmp.aff']\n    }, {\n      name: 'tmp.dic',\n      assets: ['tmp.dic']\n    }, {\n      name: 'messages.json',\n      assets: ['messages.json']\n    }, {\n      name: 'manifest.json',\n      assets: ['manifest.json']\n    }, {\n      assets: ['background.ts']\n    }, {\n      assets: ['a.txt']\n    }, {\n      assets: ['b.txt']\n    }, {\n      assets: ['foo.png']\n    }, {\n      assets: ['foo-dark.png']\n    }, {\n      assets: ['popup.html']\n    }, {\n      assets: ['devtools.html']\n    }, {\n      assets: ['content.js']\n    }, {\n      assets: ['content.css']\n    }, {\n      assets: ['ruleset_1.json']\n    }]);\n    assert(await outputFS.exists(path.join(distDir, '_locales', 'en_US', 'messages.json')));\n    const manifest = JSON.parse(await outputFS.readFile(b.getBundles().find(b => b.name == 'manifest.json').filePath, 'utf8'));\n    const scripts = manifest.background.scripts;\n    assert.equal(scripts.length, 1);\n    for (const {\n      path: resourcePath\n    } of manifest.declarative_net_request?.rule_resources ?? []) {\n      assert(await outputFS.exists(path.join(distDir, resourcePath)));\n    }\n    assert((await outputFS.readFile(path.join(distDir, scripts[0]), 'utf-8')).includes('Hello Parcel!'));\n  });","file":"webextension.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should resolve the web_accessible_resources globs","suites":["webextension"],"updatePoint":{"line":51,"column":55,"index":1654},"line":51,"code":"  it('should resolve the web_accessible_resources globs', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/webextension-resolve-web-accessible-resources/manifest.json'));\n    assertBundles(b, [{\n      name: 'manifest.json',\n      assets: ['manifest.json']\n    }, {\n      assets: ['index.ts', 'esmodule-helpers.js']\n    }, {\n      assets: ['other.ts', 'esmodule-helpers.js']\n    }, {\n      assets: ['esmodule-helpers.js', 'index-jsx.jsx', 'index.js', 'index.js', 'react.development.js']\n    }, {\n      assets: ['single.js', 'esmodule-helpers.js']\n    }]);\n    const manifest = JSON.parse(await outputFS.readFile(b.getBundles().find(b => b.name == 'manifest.json').filePath, 'utf8'));\n    const war = manifest.web_accessible_resources;\n    assert.equal(war.length, 4);\n  });","file":"webextension.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support web extension manifest v3","suites":["webextension"],"updatePoint":{"line":69,"column":46,"index":2449},"line":69,"code":"  it('should support web extension manifest v3', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/webextension-mv3/manifest.json'));\n    assertBundles(b, [{\n      name: 'manifest.json',\n      assets: ['manifest.json']\n    }, {\n      assets: ['background.js']\n    }, {\n      assets: ['popup.html']\n    }, {\n      assets: ['popup.css']\n    }, {\n      assets: ['popup.js', 'esmodule-helpers.js', 'bundle-url.js']\n    }, {\n      assets: ['content-script.js']\n    }, {\n      assets: ['other-content-script.js']\n    }, {\n      assets: ['injected.css']\n    }]);\n    const manifest = JSON.parse(await outputFS.readFile(path.join(distDir, 'manifest.json'), 'utf-8'));\n    const css = manifest.content_scripts[0].css;\n    assert.equal(css.length, 1);\n    assert((await outputFS.readFile(path.join(distDir, css[0]), 'utf-8')).includes('Comic Sans MS'));\n  });","file":"webextension.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support .webmanifest","suites":["webmanifest"],"updatePoint":{"line":6,"column":33,"index":246},"line":6,"code":"  it('should support .webmanifest', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/webmanifest/index.html'));\n    await assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      name: 'manifest.webmanifest',\n      assets: ['manifest.webmanifest']\n    }, {\n      type: 'png',\n      assets: ['icon.png']\n    }, {\n      type: 'png',\n      assets: ['screenshot.png']\n    }]);\n    const manifest = await outputFS.readFile(b.getBundles().find(b => b.type === 'webmanifest').filePath, 'utf8');\n    assert(/screenshot\\.[0-9a-f]+\\.png/.test(manifest));\n    assert(/icon\\.[0-9a-f]+\\.png/.test(manifest));\n  });","file":"webmanifest.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should support .json","suites":["webmanifest"],"updatePoint":{"line":25,"column":26,"index":905},"line":25,"code":"  it('should support .json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/webmanifest-json/index.html'));\n    await assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      name: 'manifest.webmanifest',\n      assets: ['manifest.json']\n    }, {\n      type: 'png',\n      assets: ['icon.png']\n    }, {\n      type: 'png',\n      assets: ['screenshot.png']\n    }]);\n    const manifest = await outputFS.readFile(b.getBundles().find(b => b.type === 'webmanifest').filePath, 'utf8');\n    assert(/screenshot\\.[0-9a-f]+\\.png/.test(manifest));\n    assert(/icon\\.[0-9a-f]+\\.png/.test(manifest));\n  });","file":"webmanifest.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw on malformed icons and screenshots","suites":["webmanifest"],"updatePoint":{"line":44,"column":53,"index":1589},"line":44,"code":"  it('should throw on malformed icons and screenshots', async function () {\n    let manifestPath = path.join(__dirname, '/integration/webmanifest-schema/manifest.webmanifest');\n    let manifest = await inputFS.readFileSync(manifestPath, 'utf8');\n    await assert.rejects(() => bundle(path.join(__dirname, '/integration/webmanifest-schema/index.html')), {\n      name: 'BuildError',\n      message: path.normalize('Invalid webmanifest'),\n      diagnostics: [{\n        codeFrames: [{\n          filePath: manifestPath,\n          language: 'json',\n          code: manifest,\n          codeHighlights: [{\n            end: {\n              column: 5,\n              line: 12\n            },\n            message: 'Missing property src',\n            start: {\n              column: 5,\n              line: 9\n            }\n          }, {\n            end: {\n              column: 6,\n              line: 13\n            },\n            message: 'Missing property src',\n            start: {\n              column: 5,\n              line: 13\n            }\n          }, {\n            end: {\n              column: 19,\n              line: 15\n            },\n            message: 'Expected type array',\n            start: {\n              column: 18,\n              line: 15\n            }\n          }]\n        }],\n        message: 'Invalid webmanifest',\n        origin: '@parcel/transformer-webmanifest'\n      }]\n    });\n  });","file":"webmanifest.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should throw on missing dependency","suites":["webmanifest"],"updatePoint":{"line":92,"column":40,"index":2971},"line":92,"code":"  it('should throw on missing dependency', async function () {\n    let manifestPathRelative = './integration/webmanifest-not-found/manifest.webmanifest';\n    let manifestPath = path.join(__dirname, manifestPathRelative);\n    let manifest = await inputFS.readFileSync(manifestPath, 'utf8');\n    let message = md`Failed to resolve 'icon.png' from '${manifestPathRelative}'`;\n    await assert.rejects(() => bundle(path.join(__dirname, '/integration/webmanifest-not-found/index.html')), {\n      name: 'BuildError',\n      message,\n      diagnostics: [{\n        codeFrames: [{\n          filePath: manifestPath,\n          code: manifest,\n          codeHighlights: [{\n            end: {\n              column: 23,\n              line: 5\n            },\n            start: {\n              column: 14,\n              line: 5\n            }\n          }]\n        }],\n        message,\n        origin: '@parcel/core'\n      }, {\n        hints: [],\n        message: `Cannot load file './icon.png' in '${path.dirname(manifestPathRelative)}'.`,\n        origin: '@parcel/resolver-default'\n      }]\n    });\n  });","file":"webmanifest.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should work when there is a target in package.json","suites":["webmanifest"],"updatePoint":{"line":124,"column":56,"index":4075},"line":124,"code":"  it('should work when there is a target in package.json', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/webmanifest-targets/index.html'));\n    await assertBundles(b, [{\n      name: 'index.html',\n      assets: ['index.html']\n    }, {\n      name: 'manifest.webmanifest',\n      assets: ['manifest.json']\n    }]);\n  });","file":"webmanifest.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should transform an atom feed","suites":["xml"],"updatePoint":{"line":5,"column":35,"index":190},"line":5,"code":"  it('should transform an atom feed', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/xml/atom.xml'), {\n      defaultTargetOptions: {\n        publicUrl: 'http://example.org/'\n      }\n    });\n    assertBundles(b, [{\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'xhtml',\n      assets: ['atom.xml']\n    }, {\n      name: 'post.html',\n      assets: ['post.html']\n    }, {\n      name: 'atom.xml',\n      assets: ['atom.xml']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes(`<img src=\"http://example.org/${path.basename(b.getBundles().find(b => b.type === 'png').filePath)}\"/>`));\n    assert(contents.includes(`<link href=\"http://example.org/post.html\"/>`));\n  });","file":"xml.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should transform an atom feed with namespaced elements","suites":["xml"],"updatePoint":{"line":28,"column":60,"index":999},"line":28,"code":"  it('should transform an atom feed with namespaced elements', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/xml/atom-namespace.xml'), {\n      defaultTargetOptions: {\n        publicUrl: 'http://example.org/'\n      }\n    });\n    assertBundles(b, [{\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'xhtml',\n      assets: ['atom-namespace.xml']\n    }, {\n      name: 'post.html',\n      assets: ['post.html']\n    }, {\n      name: 'atom-namespace.xml',\n      assets: ['atom-namespace.xml']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes(`<img src=\"http://example.org/${path.basename(b.getBundles().find(b => b.type === 'png').filePath)}\"/>`));\n    assert(contents.includes(`<atom:link href=\"http://example.org/post.html\"/>`));\n  });","file":"xml.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"should transform an rss feed","suites":["xml"],"updatePoint":{"line":51,"column":34,"index":1827},"line":51,"code":"  it('should transform an rss feed', async function () {\n    let b = await bundle(path.join(__dirname, '/integration/xml/rss.xml'), {\n      defaultTargetOptions: {\n        publicUrl: 'http://example.org/'\n      }\n    });\n    assertBundles(b, [{\n      type: 'png',\n      assets: ['100x100.png']\n    }, {\n      type: 'html',\n      assets: ['rss.xml']\n    }, {\n      type: 'html',\n      assets: ['rss.xml']\n    }, {\n      name: 'post.html',\n      assets: ['post.html']\n    }, {\n      name: 'rss.xml',\n      assets: ['rss.xml']\n    }]);\n    let contents = await outputFS.readFile(b.getBundles()[0].filePath, 'utf8');\n    assert(contents.includes(`&lt;img src=\"http://example.org/${path.basename(b.getBundles().find(b => b.type === 'png').filePath)}\">`));\n    assert(contents.includes(`<link>http://example.org/post.html</link>`));\n  });","file":"xml.js","skipped":false,"dir":"packages/core/integration-tests/test"},{"name":"emits log diagnostics with info level","suites":["Logger"],"updatePoint":{"line":16,"column":43,"index":347},"line":16,"code":"  it('emits log diagnostics with info level', () => {\n    let diagnostic = {\n      message: 'hello',\n      origin: 'logger'\n    };\n    Logger.log(diagnostic);\n    assert(onLog.calledWith({\n      level: 'info',\n      diagnostics: [diagnostic],\n      type: 'log'\n    }));\n  });","file":"Logger.test.js","skipped":false,"dir":"packages/core/logger/test"},{"name":"emits warn diagnostic with warn level","suites":["Logger"],"updatePoint":{"line":28,"column":43,"index":623},"line":28,"code":"  it('emits warn diagnostic with warn level', () => {\n    let diagnostic = {\n      message: 'zomg',\n      origin: 'logger'\n    };\n    Logger.warn(diagnostic);\n    assert(onLog.calledWith({\n      level: 'warn',\n      diagnostics: [diagnostic],\n      type: 'log'\n    }));\n  });","file":"Logger.test.js","skipped":false,"dir":"packages/core/logger/test"},{"name":"emits error messages with error level","suites":["Logger"],"updatePoint":{"line":40,"column":43,"index":899},"line":40,"code":"  it('emits error messages with error level', () => {\n    let diagnostic = {\n      message: 'oh noes',\n      origin: 'logger'\n    };\n    Logger.error(diagnostic);\n    assert(onLog.calledWith({\n      level: 'error',\n      diagnostics: [diagnostic],\n      type: 'log'\n    }));\n  });","file":"Logger.test.js","skipped":false,"dir":"packages/core/logger/test"},{"name":"emits progress messages with progress level","suites":["Logger"],"updatePoint":{"line":52,"column":49,"index":1186},"line":52,"code":"  it('emits progress messages with progress level', () => {\n    Logger.progress('update');\n    assert(onLog.calledWith({\n      level: 'progress',\n      message: 'update',\n      type: 'log'\n    }));\n  });","file":"Logger.test.js","skipped":false,"dir":"packages/core/logger/test"},{"name":"should support asteriks for bold and italic","suites":["markdown-ansi"],"updatePoint":{"line":7,"column":49,"index":248},"line":7,"code":"  it('should support asteriks for bold and italic', () => {\n    let res = mdAnsi('**bold** *italic*');\n    assert.equal(res, '\\u001b[1mbold\\u001b[22m \\u001b[3mitalic\\u001b[23m');\n  });","file":"markdown-ansi.js","skipped":false,"dir":"packages/core/markdown-ansi/test"},{"name":"should support underscores for underlined and italic","suites":["markdown-ansi"],"updatePoint":{"line":11,"column":58,"index":442},"line":11,"code":"  it('should support underscores for underlined and italic', () => {\n    let res = mdAnsi('__underline__ _italic_');\n    assert.equal(res, '\\u001b[4munderline\\u001b[24m \\u001b[3mitalic\\u001b[23m');\n  });","file":"markdown-ansi.js","skipped":false,"dir":"packages/core/markdown-ansi/test"},{"name":"should support combination of bold and underline","suites":["markdown-ansi"],"updatePoint":{"line":15,"column":54,"index":642},"line":15,"code":"  it('should support combination of bold and underline', () => {\n    let res = mdAnsi('**bold _italic_**');\n    assert.equal(res, '\\u001b[1mbold \\u001b[3mitalic\\u001b[23m\\u001b[22m');\n  });","file":"markdown-ansi.js","skipped":false,"dir":"packages/core/markdown-ansi/test"},{"name":"should support strikethrough","suites":["markdown-ansi"],"updatePoint":{"line":19,"column":34,"index":812},"line":19,"code":"  it('should support strikethrough', () => {\n    let res = mdAnsi('~~strikethrough~~');\n    assert.equal(res, '\\u001b[9mstrikethrough\\u001b[29m');\n  });","file":"markdown-ansi.js","skipped":false,"dir":"packages/core/markdown-ansi/test"},{"name":"should support escape character","suites":["markdown-ansi"],"updatePoint":{"line":23,"column":37,"index":968},"line":23,"code":"  it('should support escape character', () => {\n    let res = mdAnsi('\\\\*\\\\*bold\\\\*\\\\* \\\\\\\\escape\\\\\\\\');\n    assert.equal(res, '**bold** \\\\escape\\\\');\n  });","file":"markdown-ansi.js","skipped":false,"dir":"packages/core/markdown-ansi/test"},{"name":"should support italic with escape character","suites":["markdown-ansi"],"updatePoint":{"line":27,"column":49,"index":1137},"line":27,"code":"  it('should support italic with escape character', () => {\n    let res = mdAnsi('\\\\__italic_\\\\_');\n    assert.equal(res, '_\\u001b[3mitalic\\u001b[23m_');\n  });","file":"markdown-ansi.js","skipped":false,"dir":"packages/core/markdown-ansi/test"},{"name":"resolves packages that exist","suites":["NodePackageManager"],"updatePoint":{"line":33,"column":34,"index":1059},"line":33,"code":"  it('resolves packages that exist', async () => {\n    assert.deepEqual(await packageManager.resolve('foo', path.join(FIXTURES_DIR, 'has-foo/index.js')), {\n      pkg: {\n        version: '1.1.0'\n      },\n      resolved: path.join(FIXTURES_DIR, 'has-foo/node_modules/foo/index.js'),\n      invalidateOnFileChange: new Set([path.join(FIXTURES_DIR, 'has-foo/node_modules/foo/package.json')]),\n      invalidateOnFileCreate: [{\n        fileName: 'node_modules/foo',\n        aboveFilePath: path.join(FIXTURES_DIR, 'has-foo/index.js')\n      }]\n    });\n  });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"requires packages that exist","suites":["NodePackageManager"],"updatePoint":{"line":46,"column":34,"index":1608},"line":46,"code":"  it('requires packages that exist', async () => {\n    assert.deepEqual(await packageManager.require('foo', path.join(FIXTURES_DIR, 'has-foo/index.js')), 'foobar');\n  });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"autoinstalls packages that don't exist","suites":["NodePackageManager"],"updatePoint":{"line":49,"column":44,"index":1789},"line":49,"code":"  it(\"autoinstalls packages that don't exist\", async () => {\n    packageInstaller.register('a', fs, path.join(FIXTURES_DIR, 'packages/a'));\n    assert.deepEqual(await packageManager.resolve('a', path.join(FIXTURES_DIR, 'has-foo/index.js'), {\n      shouldAutoInstall: true\n    }), {\n      pkg: {\n        name: 'a'\n      },\n      resolved: path.join(FIXTURES_DIR, 'has-foo/node_modules/a/index.js'),\n      invalidateOnFileChange: new Set([path.join(FIXTURES_DIR, 'has-foo/node_modules/a/package.json')]),\n      invalidateOnFileCreate: [{\n        fileName: 'node_modules/a',\n        aboveFilePath: path.join(FIXTURES_DIR, 'has-foo/index.js')\n      }]\n    });\n  });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"does not autoinstall packages that are already listed in package.json","suites":["NodePackageManager"],"updatePoint":{"line":65,"column":75,"index":2482},"line":65,"code":"  it('does not autoinstall packages that are already listed in package.json', async () => {\n    packageInstaller.register('a', fs, path.join(FIXTURES_DIR, 'packages/a'));\n\n    // $FlowFixMe assert.rejects is Node 10+\n    await assert.rejects(() => packageManager.resolve('a', path.join(FIXTURES_DIR, 'has-a-not-yet-installed/index.js'), {\n      shouldAutoInstall: true\n    }), err => {\n      invariant(err instanceof ThrowableDiagnostic);\n      assert(err.message.includes('Run your package manager'));\n      return true;\n    });\n  });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"does not autoinstall peer dependencies that are already listed in package.json","suites":["NodePackageManager"],"updatePoint":{"line":77,"column":84,"index":3027},"line":77,"code":"  it('does not autoinstall peer dependencies that are already listed in package.json', async () => {\n    packageInstaller.register('peers', fs, path.join(FIXTURES_DIR, 'packages/peers'));\n    let spy = sinon.spy(packageInstaller, 'install');\n    await packageManager.resolve('peers', path.join(FIXTURES_DIR, 'has-foo/index.js'), {\n      shouldAutoInstall: true\n    });\n    assert.deepEqual(spy.args, [[{\n      cwd: path.join(FIXTURES_DIR, 'has-foo'),\n      packagePath: path.join(FIXTURES_DIR, 'has-foo/package.json'),\n      fs,\n      saveDev: true,\n      modules: [{\n        name: 'peers',\n        range: undefined\n      }]\n    }]]);\n  });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"autoinstalls peer dependencies that are not listed in package.json","suites":["NodePackageManager"],"updatePoint":{"line":94,"column":72,"index":3656},"line":94,"code":"  it('autoinstalls peer dependencies that are not listed in package.json', async () => {\n    packageInstaller.register('foo', fs, path.join(FIXTURES_DIR, 'packages/foo-2.0'));\n    packageInstaller.register('peers', fs, path.join(FIXTURES_DIR, 'packages/peers-2.0'));\n    let spy = sinon.spy(packageInstaller, 'install');\n    await packageManager.resolve('peers', path.join(FIXTURES_DIR, 'empty/index.js'), {\n      shouldAutoInstall: true\n    });\n    assert.deepEqual(spy.args, [[{\n      cwd: path.join(FIXTURES_DIR, 'empty'),\n      packagePath: path.join(FIXTURES_DIR, 'empty/package.json'),\n      fs,\n      saveDev: true,\n      modules: [{\n        name: 'peers',\n        range: undefined\n      }]\n    }], [{\n      cwd: path.join(FIXTURES_DIR, 'empty'),\n      packagePath: path.join(FIXTURES_DIR, 'empty/package.json'),\n      fs,\n      saveDev: true,\n      modules: [{\n        name: 'foo',\n        range: '^2.0.0'\n      }]\n    }]]);\n  });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"cannot autoinstall if there's a local requirement","suites":["NodePackageManager","range mismatch"],"updatePoint":{"line":122,"column":57,"index":4617},"line":122,"code":"    it(\"cannot autoinstall if there's a local requirement\", async () => {\n      packageManager.invalidate('foo', path.join(FIXTURES_DIR, 'has-foo/index.js'));\n\n      // $FlowFixMe assert.rejects is Node 10+\n      await assert.rejects(() => packageManager.resolve('foo', path.join(FIXTURES_DIR, 'has-foo/index.js'), {\n        range: '^2.0.0'\n      }), err => {\n        invariant(err instanceof ThrowableDiagnostic);\n        assert.equal(err.message, 'Could not find module \"foo\" satisfying ^2.0.0.');\n        return true;\n      });\n    });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"can autoinstall into local package if there isn't a local requirement","suites":["NodePackageManager","range mismatch"],"updatePoint":{"line":134,"column":77,"index":5176},"line":134,"code":"    it(\"can autoinstall into local package if there isn't a local requirement\", async () => {\n      packageInstaller.register('foo', fs, path.join(FIXTURES_DIR, 'packages/foo-2.0'));\n      let spy = sinon.spy(packageInstaller, 'install');\n      assert.deepEqual(await packageManager.resolve('foo', path.join(FIXTURES_DIR, 'has-foo/subpackage/index.js'), {\n        range: '^2.0.0',\n        shouldAutoInstall: true\n      }), {\n        pkg: {\n          name: 'foo',\n          version: '2.0.0'\n        },\n        resolved: path.join(FIXTURES_DIR, 'has-foo/subpackage/node_modules/foo/index.js'),\n        invalidateOnFileChange: new Set([path.join(FIXTURES_DIR, 'has-foo/subpackage/node_modules/foo/package.json')]),\n        invalidateOnFileCreate: [{\n          fileName: 'node_modules/foo',\n          aboveFilePath: path.join(FIXTURES_DIR, 'has-foo/subpackage/index.js')\n        }]\n      });\n      assert.deepEqual(spy.args, [[{\n        cwd: path.join(FIXTURES_DIR, 'has-foo/subpackage'),\n        packagePath: path.join(FIXTURES_DIR, 'has-foo/subpackage/package.json'),\n        fs,\n        saveDev: true,\n        modules: [{\n          name: 'foo',\n          range: '^2.0.0'\n        }]\n      }]]);\n    });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"cannot autoinstall peer dependencies if there's an incompatible local requirement","suites":["NodePackageManager","range mismatch"],"updatePoint":{"line":163,"column":89,"index":6389},"line":163,"code":"    it(\"cannot autoinstall peer dependencies if there's an incompatible local requirement\", async () => {\n      packageManager.invalidate('peers', path.join(FIXTURES_DIR, 'has-foo/index.js'));\n      packageInstaller.register('foo', fs, path.join(FIXTURES_DIR, 'packages/foo-2.0'));\n      packageInstaller.register('peers', fs, path.join(FIXTURES_DIR, 'packages/peers-2.0'));\n\n      // $FlowFixMe assert.rejects is Node 10+\n      await assert.rejects(() => packageManager.resolve('peers', path.join(FIXTURES_DIR, 'has-foo/index.js'), {\n        range: '^2.0.0',\n        shouldAutoInstall: true\n      }), err => {\n        assert(err instanceof ThrowableDiagnostic);\n        assert.equal(err.message, 'Could not install the peer dependency \"foo\" for \"peers\", installed version 1.1.0 is incompatible with ^2.0.0');\n        return true;\n      });\n    });","file":"NodePackageManager.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"Validate Module Specifiers","suites":["Validate Module Specifiers"],"updatePoint":{"line":5,"column":32,"index":180},"line":5,"code":"  it('Validate Module Specifiers', () => {\n    let modules = ['@parcel/transformer-posthtml/package.json', '@some-org/package@v1.0.0', '@org/some-package@v1.0.0-alpha.1', 'something.js/something/index.js', '@some.org/something.js/index.js', 'lodash/something/index.js'];\n    assert.deepEqual(modules.map(module => validateModuleSpecifier(module)), ['@parcel/transformer-posthtml', '@some-org/package@v1.0.0', '@org/some-package@v1.0.0-alpha.1', 'something.js', '@some.org/something.js', 'lodash']);\n  });","file":"validateModuleSpecifiers.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"Return empty on invalid modules","suites":["Validate Module Specifiers"],"updatePoint":{"line":9,"column":37,"index":690},"line":9,"code":"  it('Return empty on invalid modules', () => {\n    let modules = ['./somewhere.js', './hello/world.js', '~/hello/world.js'];\n    assert.deepEqual(modules.map(module => validateModuleSpecifier(module)), ['', '', '']);\n  });","file":"validateModuleSpecifiers.test.js","skipped":false,"dir":"packages/core/package-manager/test"},{"name":"returns a sorted list of key/value tuples","suites":["objectSortedEntries"],"updatePoint":{"line":6,"column":47,"index":201},"line":6,"code":"  it('returns a sorted list of key/value tuples', () => {\n    assert.deepEqual(objectSortedEntries({\n      foo: 'foo',\n      baz: 'baz',\n      bar: 'bar'\n    }), [['bar', 'bar'], ['baz', 'baz'], ['foo', 'foo']]);\n  });","file":"collection.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"returns a deeply sorted list of key/value tuples","suites":["objectSortedEntriesDeep"],"updatePoint":{"line":15,"column":54,"index":475},"line":15,"code":"  it('returns a deeply sorted list of key/value tuples', () => {\n    assert.deepEqual(objectSortedEntriesDeep({\n      foo: 'foo',\n      baz: ['d', 'c'],\n      bar: {\n        g: 'g',\n        b: 'b'\n      }\n    }), [['bar', [['b', 'b'], ['g', 'g']]], ['baz', ['d', 'c']], ['foo', 'foo']]);\n  });","file":"collection.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"load config with json","suites":["loadConfig"],"updatePoint":{"line":8,"column":27,"index":211},"line":8,"code":"  it('load config with json', async () => {\n    assert.deepEqual((await loadConfig(fs, path.join(__dirname, './input/config/config.json'), ['config.json'], path.join(__dirname, './input/config/')))?.config, {\n      hoge: 'fuga'\n    });\n  });","file":"config.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should throw error with empty string json","suites":["loadConfig"],"updatePoint":{"line":13,"column":47,"index":473},"line":13,"code":"  it('should throw error with empty string json', async () => {\n    // $FlowFixMe[prop-missing]\n    await assert.rejects(async () => {\n      await loadConfig(fs, path.join(__dirname, './input/config/empty.json'), ['empty.json'], path.join(__dirname, './input/config/'));\n    });\n  });","file":"config.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should load with empty string config toml","suites":["loadConfig"],"updatePoint":{"line":19,"column":47,"index":758},"line":19,"code":"  it('should load with empty string config toml', async () => {\n    assert.deepEqual((await loadConfig(fs, path.join(__dirname, './input/config/empty.toml'), ['empty.toml'], path.join(__dirname, './input/config/')))?.config, {});\n  });","file":"config.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should load with js","suites":["loadConfig"],"updatePoint":{"line":22,"column":25,"index":972},"line":22,"code":"  it('should load with js', async () => {\n    assert.deepEqual((await loadConfig(fs, path.join(__dirname, './input/config/config.js'), ['config.js'], path.join(__dirname, './input/config/')))?.config, {\n      hoge: 'fuga'\n    });\n  });","file":"config.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should load with cjs","suites":["loadConfig"],"updatePoint":{"line":27,"column":26,"index":1209},"line":27,"code":"  it('should load with cjs', async () => {\n    assert.deepEqual((await loadConfig(fs, path.join(__dirname, './input/config/config.cjs'), ['config.cjs'], path.join(__dirname, './input/config/')))?.config, {\n      hoge: 'fuga'\n    });\n  });","file":"config.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should load without an extension as json","suites":["loadConfig"],"updatePoint":{"line":32,"column":46,"index":1468},"line":32,"code":"  it('should load without an extension as json', async () => {\n    assert.deepEqual((await loadConfig(fs, path.join(__dirname, './input/config/.testrc'), ['.testrc'], path.join(__dirname, './input/config/')))?.config, {\n      hoge: 'fuga'\n    });\n  });","file":"config.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"constructs with entries just like Map","suites":["DefaultMap"],"updatePoint":{"line":6,"column":43,"index":154},"line":6,"code":"  it('constructs with entries just like Map', () => {\n    let map = new DefaultMap(k => k, [[1, 3], [2, 27]]);\n    assert.equal(map.get(1), 3);\n    assert.deepEqual(Array.from(map.entries()), [[1, 3], [2, 27]]);\n  });","file":"DefaultMap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"returns a default value based on a key if it doesn't exist","suites":["DefaultMap"],"updatePoint":{"line":11,"column":64,"index":393},"line":11,"code":"  it(\"returns a default value based on a key if it doesn't exist\", () => {\n    let map = new DefaultMap(k => k);\n    assert.equal(map.get(3), 3);\n  });","file":"DefaultMap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"sets a default value based on a key if it doesn't exist","suites":["DefaultMap"],"updatePoint":{"line":15,"column":61,"index":542},"line":15,"code":"  it(\"sets a default value based on a key if it doesn't exist\", () => {\n    let map = new DefaultMap(k => k);\n    map.get(3);\n    assert.deepEqual(Array.from(map.entries()), [[3, 3]]);\n  });","file":"DefaultMap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"respects undefined/null if it already existed in the map","suites":["DefaultMap"],"updatePoint":{"line":20,"column":62,"index":734},"line":20,"code":"  it('respects undefined/null if it already existed in the map', () => {\n    let map = new DefaultMap(k => k);\n    map.set(3, undefined);\n    assert.equal(map.get(3), undefined);\n    map.set(4, null);\n    assert.equal(map.get(4), null);\n  });","file":"DefaultMap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"calculates the same hash for two different but deep equal objects","suites":["objectHash"],"updatePoint":{"line":5,"column":71,"index":177},"line":5,"code":"  it('calculates the same hash for two different but deep equal objects', () => {\n    const obj1 = {\n      foo: {\n        foo: 'foo',\n        baz: ['foo', 'baz', 'bar'],\n        bar: 'bar'\n      },\n      baz: 'baz',\n      bar: 'bar'\n    };\n    const obj2 = {\n      foo: {\n        foo: 'foo',\n        baz: ['foo', 'baz', 'bar'],\n        bar: 'bar'\n      },\n      baz: 'baz',\n      bar: 'bar'\n    };\n    assert.equal(objectHash(obj1), objectHash(obj2));\n  });","file":"objectHash.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"calculates a unique hash for two deep equal objects","suites":["objectHash"],"updatePoint":{"line":26,"column":57,"index":621},"line":26,"code":"  it('calculates a unique hash for two deep equal objects', () => {\n    const obj1 = {\n      baz: 'baz',\n      bar: 'ba'\n    };\n    const obj2 = {\n      baz: 'baz',\n      bar: 'bar'\n    };\n    assert.notEqual(objectHash(obj1), objectHash(obj2));\n  });","file":"objectHash.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should format numbers less than 1000 as ms","suites":["prettifyTime"],"updatePoint":{"line":5,"column":48,"index":160},"line":5,"code":"  it('should format numbers less than 1000 as ms', () => {\n    assert.equal(prettifyTime(888), '888ms');\n    assert.equal(prettifyTime(50), '50ms');\n    assert.equal(prettifyTime(0), '0ms');\n  });","file":"prettifyTime.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should format numbers greater than 1000 as s with 2 fractional digits","suites":["prettifyTime"],"updatePoint":{"line":10,"column":75,"index":384},"line":10,"code":"  it('should format numbers greater than 1000 as s with 2 fractional digits', () => {\n    assert.equal(prettifyTime(4000), '4.00s');\n    assert.equal(prettifyTime(90000), '90.00s');\n    assert.equal(prettifyTime(45678), '45.68s');\n  });","file":"prettifyTime.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"run() should resolve when all async functions in queue have completed","suites":["PromiseQueue"],"updatePoint":{"line":6,"column":75,"index":223},"line":6,"code":"  it('run() should resolve when all async functions in queue have completed', async () => {\n    let queue = new PromiseQueue();\n    let someBooleanToBeChanged = false;\n    queue.add(() => Promise.resolve().then(() => {\n      someBooleanToBeChanged = true;\n    }));\n    await queue.run();\n    assert(someBooleanToBeChanged);\n  });","file":"PromiseQueue.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"run() should reject if any of the async functions in the queue failed","suites":["PromiseQueue"],"updatePoint":{"line":15,"column":75,"index":553},"line":15,"code":"  it('run() should reject if any of the async functions in the queue failed', async () => {\n    let error = new Error('some failure');\n    try {\n      let queue = new PromiseQueue();\n      queue.add(() => Promise.reject(error)).catch( /* catch this to prevent an unhandled promise rejection*/() => {});\n      await queue.run();\n    } catch (e) {\n      assert.equal(e, error);\n    }\n  });","file":"PromiseQueue.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":".run() should instantly resolve when the queue is empty","suites":["PromiseQueue"],"updatePoint":{"line":25,"column":61,"index":927},"line":25,"code":"  it('.run() should instantly resolve when the queue is empty', async () => {\n    let queue = new PromiseQueue();\n    await queue.run();\n    // no need to assert, test will hang or throw an error if condition fails\n  });","file":"PromiseQueue.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":".add() should resolve with the same result when the passed in function's promise resolves","suites":["PromiseQueue"],"updatePoint":{"line":31,"column":95,"index":1183},"line":31,"code":"  it(\".add() should resolve with the same result when the passed in function's promise resolves\", async () => {\n    let queue = new PromiseQueue();\n    let promise = queue.add(() => Promise.resolve(42));\n    await queue.run();\n    let result = await promise;\n    assert.equal(result, 42);\n  });","file":"PromiseQueue.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":".add() should reject with the same error when the passed in function's promise rejects","suites":["PromiseQueue"],"updatePoint":{"line":38,"column":92,"index":1475},"line":38,"code":"  it(\".add() should reject with the same error when the passed in function's promise rejects\", async () => {\n    let queue = new PromiseQueue();\n    let error = new Error('Oh no!');\n    let promise = queue.add(() => Promise.reject(error));\n    await queue.run().catch(() => null);\n    await promise.then(null, e => assert.equal(e, error));\n  });","file":"PromiseQueue.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"constructor() should allow for configuration of max concurrent running functions","suites":["PromiseQueue"],"updatePoint":{"line":45,"column":86,"index":1815},"line":45,"code":"  it('constructor() should allow for configuration of max concurrent running functions', async () => {\n    const maxConcurrent = 5;\n    const queue = new PromiseQueue({\n      maxConcurrent\n    });\n    let running = 0;\n    new Array(100).fill(0).map(() => queue.add(async () => {\n      running++;\n      assert(queue._numRunning === running);\n      assert(running <= maxConcurrent);\n      await Promise.resolve(randomInt(1, 10)); //sleep(randomInt(1, 10));\n      running--;\n    }));\n    await queue.run();\n  });","file":"PromiseQueue.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Query params and named pipeline, relative","suites":["replace bundle references"],"updatePoint":{"line":6,"column":47,"index":193},"line":6,"code":"  it('Query params and named pipeline, relative', () => {\n    // $FlowFixMe\n    let fromBundle = {\n      filePath: '/user/dist/reformat.html',\n      name: 'reformat.html',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: '/'\n      }\n    };\n\n    // $FlowFixMe\n    let toBundle = {\n      filePath: '/user/dist/image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp',\n      name: 'image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: '/'\n      }\n    };\n\n    // $FlowFixMe\n    let dependency = {\n      id: '074b36596e3147e900a8ad17ceb5c90b',\n      specifier: 'url:./image.jpg?as=webp',\n      specifierType: 'esm'\n    };\n    let result = getURLReplacement({\n      dependency,\n      fromBundle,\n      toBundle,\n      relative: true\n    });\n    assert.equal(result.to, 'image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp');\n    assert.equal(result.from, '074b36596e3147e900a8ad17ceb5c90b');\n  });","file":"replaceBundleReferences.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Query params and named pipeline, absolute","suites":["replace bundle references"],"updatePoint":{"line":44,"column":47,"index":1208},"line":44,"code":"  it('Query params and named pipeline, absolute', () => {\n    // $FlowFixMe\n    let fromBundle = {\n      filePath: '/user/dist/reformat.html',\n      name: 'reformat.html',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: '/'\n      }\n    };\n\n    // $FlowFixMe\n    let toBundle = {\n      filePath: '/user/dist/image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp',\n      name: 'image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: '/'\n      }\n    };\n\n    // $FlowFixMe\n    let dependency = {\n      id: '074b36596e3147e900a8ad17ceb5c90b',\n      specifier: 'url:./image.jpg?as=webp',\n      specifierType: 'esm'\n    };\n    let result = getURLReplacement({\n      dependency,\n      fromBundle,\n      toBundle,\n      relative: false\n    });\n    assert.equal(result.to, '/image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp');\n    assert.equal(result.from, '074b36596e3147e900a8ad17ceb5c90b');\n  });","file":"replaceBundleReferences.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Custom Public URL","suites":["replace bundle references"],"updatePoint":{"line":82,"column":23,"index":2201},"line":82,"code":"  it('Custom Public URL', () => {\n    // $FlowFixMe\n    let fromBundle = {\n      filePath: '/user/dist/reformat.html',\n      name: 'reformat.html',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: 'https://test.com/static'\n      }\n    };\n\n    // $FlowFixMe\n    let toBundle = {\n      filePath: '/user/dist/image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp',\n      name: 'image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: 'https://test.com/static'\n      }\n    };\n\n    // $FlowFixMe\n    let dependency = {\n      id: '074b36596e314797845a8ad17ceb5c9b',\n      specifier: './image.jpg',\n      specifierType: 'esm'\n    };\n    let result = getURLReplacement({\n      dependency,\n      fromBundle,\n      toBundle,\n      relative: false\n    });\n    assert.equal(result.to, 'https://test.com/static/image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp');\n    assert.equal(result.from, '074b36596e314797845a8ad17ceb5c9b');\n  });","file":"replaceBundleReferences.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Relative with folders in between","suites":["replace bundle references"],"updatePoint":{"line":120,"column":38,"index":3264},"line":120,"code":"  it('Relative with folders in between', () => {\n    // $FlowFixMe\n    let fromBundle = {\n      filePath: '/user/dist/reformat.html',\n      name: 'reformat.html',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: 'https://test.com/static'\n      }\n    };\n\n    // $FlowFixMe\n    let toBundle = {\n      filePath: '/user/dist/assets/image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp',\n      name: 'image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist/assets',\n        publicUrl: 'https://test.com/static'\n      }\n    };\n\n    // $FlowFixMe\n    let dependency = {\n      id: '074b36596e3147e900a8ad17ceb5c90b',\n      specifier: 'url:./image.jpg?as=webp',\n      specifierType: 'esm'\n    };\n    let result = getURLReplacement({\n      dependency,\n      fromBundle,\n      toBundle,\n      relative: true\n    });\n    assert.equal(result.to, 'assets/image.HASH_REF_87f9d66c16c2216ccc7e5664cf089305.webp');\n    assert.equal(result.from, '074b36596e3147e900a8ad17ceb5c90b');\n  });","file":"replaceBundleReferences.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should work with bundle names with colons, relative","suites":["replace bundle references"],"updatePoint":{"line":158,"column":57,"index":4354},"line":158,"code":"  it('should work with bundle names with colons, relative', () => {\n    // $FlowFixMe\n    let fromBundle = {\n      filePath: '/user/dist/reformat.html',\n      name: 'reformat.html',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: '/'\n      }\n    };\n\n    // $FlowFixMe\n    let toBundle = {\n      filePath: '/user/dist/a:b:c.html',\n      name: 'a:b:c.html',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: '/'\n      }\n    };\n\n    // $FlowFixMe\n    let dependency = {\n      id: '074b36596e3147e900a8ad17ceb5c90b',\n      specifier: './a:b:c.html',\n      specifierType: 'esm'\n    };\n    let result = getURLReplacement({\n      dependency,\n      fromBundle,\n      toBundle,\n      relative: true\n    });\n    assert.equal(result.to, './a:b:c.html');\n  });","file":"replaceBundleReferences.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should work with bundle names with colons, absolute","suites":["replace bundle references"],"updatePoint":{"line":195,"column":57,"index":5177},"line":195,"code":"  it('should work with bundle names with colons, absolute', () => {\n    // $FlowFixMe\n    let fromBundle = {\n      filePath: '/user/dist/reformat.html',\n      name: 'reformat.html',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: '/'\n      }\n    };\n\n    // $FlowFixMe\n    let toBundle = {\n      filePath: '/user/dist/a:b:c.html',\n      name: 'a:b:c.html',\n      // $FlowFixMe\n      target: {\n        distDir: '/user/dist',\n        publicUrl: '/'\n      }\n    };\n\n    // $FlowFixMe\n    let dependency = {\n      id: '074b36596e3147e900a8ad17ceb5c90b',\n      specifier: './a:b:c.html',\n      specifierType: 'esm'\n    };\n    let result = getURLReplacement({\n      dependency,\n      fromBundle,\n      toBundle,\n      relative: false\n    });\n    assert.equal(result.to, '/a:b:c.html');\n  });","file":"replaceBundleReferences.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should not match sourceMappingURL when not at the end of the bundle","suites":["loadSourceMap"],"updatePoint":{"line":7,"column":73,"index":315},"line":7,"code":"  it('should not match sourceMappingURL when not at the end of the bundle', () => {\n    // Code example taken from livescript.js (issue #2408 in parcel-bundler)\n    // This snippet lead to JSAsset.js being mislead and incorrectly trying to\n    // load (due to false-positive match) sourcemap before fix was introduced\n    let code = fs.readFileSync(path.join(__dirname, './input/sourcemap/no-sourcemap.js'), 'utf-8');\n    assert(!matchSourceMappingURL(code));\n  });","file":"sourcemap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should match referenced-min sourceMappingURL when correctly inserted at end of the bundle","suites":["loadSourceMap"],"updatePoint":{"line":14,"column":95,"index":803},"line":14,"code":"  it('should match referenced-min sourceMappingURL when correctly inserted at end of the bundle', () => {\n    let code = fs.readFileSync(path.join(__dirname, './input/sourcemap/referenced-min.js'), 'utf-8');\n    assert(!!matchSourceMappingURL(code));\n  });","file":"sourcemap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should match inline sourceMappingURL when correctly inserted at end of the bundle","suites":["loadSourceMap"],"updatePoint":{"line":18,"column":87,"index":1052},"line":18,"code":"  it('should match inline sourceMappingURL when correctly inserted at end of the bundle', () => {\n    // inline source map taken from https://github.com/thlorenz/inline-source-map\n    let code = fs.readFileSync(path.join(__dirname, './input/sourcemap/inline.js'), 'utf-8');\n    assert(!!matchSourceMappingURL(code));\n  });","file":"sourcemap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should be able to load sourcemap data from a url reference","suites":["loadSourceMap"],"updatePoint":{"line":23,"column":64,"index":1352},"line":23,"code":"  it('Should be able to load sourcemap data from a url reference', async () => {\n    let filename = path.join(__dirname, './input/sourcemap/referenced-min.js');\n    let contents = fs.readFileSync(filename, 'utf-8');\n    let foundMap = await loadSourceMapUrl(fs, filename, contents);\n    assert.equal(foundMap.url, 'file://referenced-min.js.map');\n    assert.equal(foundMap.filename, path.join(__dirname, 'input/sourcemap/referenced-min.js.map'));\n    assert.deepEqual(foundMap.map, {\n      version: 3,\n      sources: ['./referenced.js'],\n      names: ['hello', 'l', 'o', 'console', 'log'],\n      mappings: 'AAAA,SAASA,QACP,IAAIC,EAAI,QACNC,EAAI,QACNC,QAAQC,IAAIH,EAAI,IAAMC,EAAI,KAE5BF'\n    });\n  });","file":"sourcemap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should be able to load sourcemap data from an inline url reference","suites":["loadSourceMap"],"updatePoint":{"line":36,"column":72,"index":2061},"line":36,"code":"  it('Should be able to load sourcemap data from an inline url reference', async () => {\n    let filename = path.join(__dirname, './input/sourcemap/inline.js');\n    let contents = fs.readFileSync(filename, 'utf-8');\n    let foundMap = await loadSourceMapUrl(fs, filename, contents);\n    assert.equal(foundMap.url, 'data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiIiwic291cmNlcyI6WyJmb28uanMiLCJiYXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O1VBQ0c7Ozs7Ozs7Ozs7Ozs7O3NCQ0RIO3NCQUNBIn0=');\n    assert.equal(foundMap.filename, filename);\n    assert.deepEqual(foundMap.map, {\n      version: 3,\n      file: '',\n      sources: ['foo.js', 'bar.js'],\n      names: [],\n      mappings: ';;;;;;;;;UACG;;;;;;;;;;;;;;sBCDH;sBACA'\n    });\n  });","file":"sourcemap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should be able to load a SourceMap instance from a file","suites":["loadSourceMap"],"updatePoint":{"line":50,"column":61,"index":2811},"line":50,"code":"  it('Should be able to load a SourceMap instance from a file', async () => {\n    let filename = path.join(__dirname, './input/sourcemap/referenced-min.js');\n    let contents = fs.readFileSync(filename, 'utf-8');\n    let map = await loadSourceMap(filename, contents, {\n      fs,\n      projectRoot: __dirname\n    });\n    assert(!!map);\n    let parsedMap = map.getMap();\n    assert.deepEqual(parsedMap.sources, ['input/sourcemap/referenced.js']);\n    assert.deepEqual(parsedMap.names, ['hello', 'l', 'o', 'console', 'log']);\n    assert.deepEqual(parsedMap.mappings, [{\n      generated: {\n        line: 1,\n        column: 0\n      },\n      original: {\n        line: 1,\n        column: 0\n      },\n      source: 0\n    }, {\n      generated: {\n        line: 1,\n        column: 9\n      },\n      original: {\n        line: 1,\n        column: 9\n      },\n      source: 0,\n      name: 0\n    }, {\n      generated: {\n        line: 1,\n        column: 17\n      },\n      original: {\n        line: 2,\n        column: 2\n      },\n      source: 0\n    }, {\n      generated: {\n        line: 1,\n        column: 21\n      },\n      original: {\n        line: 2,\n        column: 6\n      },\n      source: 0,\n      name: 1\n    }, {\n      generated: {\n        line: 1,\n        column: 23\n      },\n      original: {\n        line: 2,\n        column: 10\n      },\n      source: 0\n    }, {\n      generated: {\n        line: 1,\n        column: 31\n      },\n      original: {\n        line: 3,\n        column: 4\n      },\n      source: 0,\n      name: 2\n    }, {\n      generated: {\n        line: 1,\n        column: 33\n      },\n      original: {\n        line: 3,\n        column: 8\n      },\n      source: 0\n    }, {\n      generated: {\n        line: 1,\n        column: 41\n      },\n      original: {\n        line: 4,\n        column: 2\n      },\n      source: 0,\n      name: 3\n    }, {\n      generated: {\n        line: 1,\n        column: 49\n      },\n      original: {\n        line: 4,\n        column: 10\n      },\n      source: 0,\n      name: 4\n    }, {\n      generated: {\n        line: 1,\n        column: 53\n      },\n      original: {\n        line: 4,\n        column: 14\n      },\n      source: 0,\n      name: 1\n    }, {\n      generated: {\n        line: 1,\n        column: 55\n      },\n      original: {\n        line: 4,\n        column: 18\n      },\n      source: 0\n    }, {\n      generated: {\n        line: 1,\n        column: 59\n      },\n      original: {\n        line: 4,\n        column: 24\n      },\n      source: 0,\n      name: 2\n    }, {\n      generated: {\n        line: 1,\n        column: 61\n      },\n      original: {\n        line: 4,\n        column: 28\n      },\n      source: 0\n    }, {\n      generated: {\n        line: 1,\n        column: 66\n      },\n      original: {\n        line: 6,\n        column: 0\n      },\n      source: 0,\n      name: 0\n    }]);\n  });","file":"sourcemap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should remap sources when using sourceRoot","suites":["loadSourceMap"],"updatePoint":{"line":211,"column":48,"index":5609},"line":211,"code":"  it('Should remap sources when using sourceRoot', async () => {\n    let filename = path.join(__dirname, './input/sourcemap/referenced-min.js');\n    let contents = fs.readFileSync(filename, 'utf-8');\n    let map = await loadSourceMap(filename, contents, {\n      fs,\n      projectRoot: __dirname\n    });\n    assert(!!map);\n    let parsedMap = map.getMap();\n    assert.deepEqual(parsedMap.sources, ['input/sourcemap/referenced.js']);\n  });","file":"sourcemap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should remap sources when using sourceRoot","suites":["loadSourceMap"],"updatePoint":{"line":222,"column":48,"index":6047},"line":222,"code":"  it('Should remap sources when using sourceRoot', async () => {\n    let filename = path.join(__dirname, './input/sourcemap/source-root.js');\n    let contents = fs.readFileSync(filename, 'utf-8');\n    let map = await loadSourceMap(filename, contents, {\n      fs,\n      projectRoot: __dirname\n    });\n    assert(!!map);\n    let parsedMap = map.getMap();\n    assert.deepEqual(parsedMap.sources, ['input/source.js']);\n  });","file":"sourcemap.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"doesn't invoke a function more than once in a given interval","suites":["throttle"],"updatePoint":{"line":7,"column":66,"index":194},"line":7,"code":"  it(\"doesn't invoke a function more than once in a given interval\", () => {\n    let spy = sinon.spy();\n    let throttled = throttle(spy, 100);\n    throttled(1);\n    throttled(2);\n    throttled(3);\n    assert(spy.calledOnceWithExactly(1));\n  });","file":"throttle.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"calls the underlying function again once the interval has passed","suites":["throttle"],"updatePoint":{"line":15,"column":70,"index":444},"line":15,"code":"  it('calls the underlying function again once the interval has passed', () => {\n    let time = sinon.useFakeTimers();\n    let spy = sinon.spy();\n    let throttled = throttle(spy, 100);\n    throttled(1);\n    throttled(2);\n    throttled(3);\n    time.tick(100);\n    throttled(4);\n    assert.deepEqual(spy.args, [[1], [4]]);\n    time.restore();\n  });","file":"throttle.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"preserves the `this` when throttled functions are invoked","suites":["throttle"],"updatePoint":{"line":27,"column":63,"index":785},"line":27,"code":"  it('preserves the `this` when throttled functions are invoked', () => {\n    let result;\n    let throttled = throttle(function () {\n      result = this.bar;\n    }, 100);\n    throttled.call({\n      bar: 'baz'\n    });\n    assert(result === 'baz');\n  });","file":"throttle.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should join two paths","suites":["urlJoin"],"updatePoint":{"line":6,"column":27,"index":125},"line":6,"code":"  it('Should join two paths', () => {\n    let joinedUrl = urlJoin('/', './image.jpeg?test=test');\n    assert.equal(joinedUrl, '/image.jpeg?test=test');\n  });","file":"urlJoin.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should join two paths with longer publicUrl","suites":["urlJoin"],"updatePoint":{"line":10,"column":49,"index":305},"line":10,"code":"  it('Should join two paths with longer publicUrl', () => {\n    let joinedUrl = urlJoin('/static', './image.jpeg?test=test');\n    assert.equal(joinedUrl, '/static/image.jpeg?test=test');\n  });","file":"urlJoin.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should join two paths with longer publicUrl","suites":["urlJoin"],"updatePoint":{"line":14,"column":49,"index":498},"line":14,"code":"  it('Should join two paths with longer publicUrl', () => {\n    let joinedUrl = urlJoin('/static', 'image.jpeg?test=test');\n    assert.equal(joinedUrl, '/static/image.jpeg?test=test');\n  });","file":"urlJoin.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should turn windows path into posix","suites":["urlJoin"],"updatePoint":{"line":18,"column":41,"index":681},"line":18,"code":"  it('Should turn windows path into posix', () => {\n    let joinedUrl = urlJoin('/static', '.\\\\image.jpeg?test=test');\n    assert.equal(joinedUrl, '/static/image.jpeg?test=test');\n  });","file":"urlJoin.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"should support paths with colons","suites":["urlJoin"],"updatePoint":{"line":22,"column":38,"index":864},"line":22,"code":"  it('should support paths with colons', () => {\n    let joinedUrl = urlJoin('/static', 'a:b:c.html');\n    assert.equal(joinedUrl, '/static/a:b:c.html');\n    joinedUrl = urlJoin('/static', '/a:b:c.html');\n    assert.equal(joinedUrl, '/static/a:b:c.html');\n    joinedUrl = urlJoin('/static', './a:b:c.html');\n    assert.equal(joinedUrl, '/static/a:b:c.html');\n  });","file":"urlJoin.test.js","skipped":false,"dir":"packages/core/utils/test"},{"name":"Should be able to detect real cpu count","suites":["cpuCount"],"updatePoint":{"line":5,"column":45,"index":192},"line":5,"code":"  it('Should be able to detect real cpu count', () => {\n    // Windows not supported as getting the cpu count takes a couple seconds...\n    if (os.platform() === 'win32') return;\n    let cores = detectRealCores();\n    assert(cores > 0);\n  });","file":"cpuCount.test.js","skipped":false,"dir":"packages/core/workers/test"},{"name":"getCores should return more than 0","suites":["cpuCount"],"updatePoint":{"line":11,"column":40,"index":430},"line":11,"code":"  it('getCores should return more than 0', () => {\n    let cores = getCores(true);\n    assert(cores > 0);\n  });","file":"cpuCount.test.js","skipped":false,"dir":"packages/core/workers/test"},{"name":"identifies requires","suites":["utils","isRequire"],"updatePoint":{"line":21,"column":27,"index":478},"line":21,"code":"    it('identifies requires', () => {\n      assert.equal(isStaticRequire(getFirstExpression(parse(\"require('@parcel/core')\"))), true);\n    });","file":"utils.test.js","skipped":false,"dir":"packages/dev/eslint-plugin/test"},{"name":"doesn't handle dynamic requires","suites":["utils","isRequire"],"updatePoint":{"line":24,"column":39,"index":633},"line":24,"code":"    it(\"doesn't handle dynamic requires\", () => {\n      assert.equal(isStaticRequire(getFirstExpression(parse('require(dynamic)'))), false);\n    });","file":"utils.test.js","skipped":false,"dir":"packages/dev/eslint-plugin/test"},{"name":"identifies built-in require.resolve","suites":["utils","isResolve"],"updatePoint":{"line":29,"column":43,"index":824},"line":29,"code":"    it('identifies built-in require.resolve', () => {\n      assert.equal(isStaticResolve(getFirstExpression(parse(\"require.resolve('@parcel/core')\"))), true);\n    });","file":"utils.test.js","skipped":false,"dir":"packages/dev/eslint-plugin/test"},{"name":"behaves identically as path.relative on unix","suites":["utils","relativePathForRequire"],"updatePoint":{"line":34,"column":52,"index":1051},"line":34,"code":"    it('behaves identically as path.relative on unix', () => {\n      let sep = path.sep;\n      path.sep = '/';\n      assert.equal(relativePathForRequire({\n        origin: __filename,\n        request: '@parcel/eslint-plugin/',\n        pkgName,\n        pkgPath\n      }), '../');\n      path.sep = sep;\n    });","file":"utils.test.js","skipped":false,"dir":"packages/dev/eslint-plugin/test"},{"name":"uses / to separate paths even when path.sep is not /","suites":["utils","relativePathForRequire"],"updatePoint":{"line":45,"column":60,"index":1366},"line":45,"code":"    it('uses / to separate paths even when path.sep is not /', () => {\n      let sep = path.sep;\n      path.sep = '\\\\';\n      assert.equal(relativePathForRequire({\n        origin: __filename,\n        request: '@parcel/eslint-plugin/',\n        pkgName,\n        pkgPath\n      }), '../');\n      path.sep = sep;\n    });","file":"utils.test.js","skipped":false,"dir":"packages/dev/eslint-plugin/test"},{"name":"leaves absolute paths alone","suites":["utils","relativePathForRequire"],"updatePoint":{"line":56,"column":35,"index":1657},"line":56,"code":"    it('leaves absolute paths alone', () => {\n      assert.equal(relativePathForRequire({\n        origin: __filename,\n        request: '/a/b',\n        pkgName,\n        pkgPath\n      }), '/a/b');\n    });","file":"utils.test.js","skipped":false,"dir":"packages/dev/eslint-plugin/test"},{"name":"prepends ./ to peer paths","suites":["utils","relativePathForRequire"],"updatePoint":{"line":64,"column":33,"index":1858},"line":64,"code":"    it('prepends ./ to peer paths', () => {\n      assert.equal(relativePathForRequire({\n        origin: __filename,\n        request: '@parcel/eslint-plugin/test/baz',\n        pkgName,\n        pkgPath\n      }), './baz');\n    });","file":"utils.test.js","skipped":false,"dir":"packages/dev/eslint-plugin/test"},{"name":"writes log, info, success, and verbose log messages to stdout","suites":["CLIReporter"],"updatePoint":{"line":60,"column":67,"index":1732},"line":60,"code":"  it('writes log, info, success, and verbose log messages to stdout', async () => {\n    let options = {\n      ...EMPTY_OPTIONS,\n      logLevel: 'verbose'\n    };\n    await _report({\n      type: 'log',\n      level: 'info',\n      diagnostics: [{\n        origin: 'test',\n        message: 'info'\n      }]\n    }, options);\n    await _report({\n      type: 'log',\n      level: 'success',\n      message: 'success'\n    }, options);\n    await _report({\n      type: 'log',\n      level: 'verbose',\n      diagnostics: [{\n        origin: 'test',\n        message: 'verbose'\n      }]\n    }, options);\n    assert.equal(stdoutOutput, 'test: info\\nsuccess\\ntest: verbose\\n');\n  });","file":"CLIReporter.test.js","skipped":false,"dir":"packages/reporters/cli/test"},{"name":"writes errors and warnings to stderr","suites":["CLIReporter"],"updatePoint":{"line":88,"column":42,"index":2369},"line":88,"code":"  it('writes errors and warnings to stderr', async () => {\n    await _report({\n      type: 'log',\n      level: 'error',\n      diagnostics: [{\n        origin: 'test',\n        message: 'error'\n      }]\n    }, EMPTY_OPTIONS);\n    await _report({\n      type: 'log',\n      level: 'warn',\n      diagnostics: [{\n        origin: 'test',\n        message: 'warn'\n      }]\n    }, EMPTY_OPTIONS);\n    assert.equal(stdoutOutput, '\\n\\n');\n    assert.equal(stderrOutput, 'test: error\\ntest: warn\\n');\n  });","file":"CLIReporter.test.js","skipped":false,"dir":"packages/reporters/cli/test"},{"name":"prints errors nicely","suites":["CLIReporter"],"updatePoint":{"line":108,"column":26,"index":2845},"line":108,"code":"  it('prints errors nicely', async () => {\n    await _report({\n      type: 'log',\n      level: 'error',\n      diagnostics: [{\n        origin: 'test',\n        message: 'error'\n      }]\n    }, EMPTY_OPTIONS);\n    await _report({\n      type: 'log',\n      level: 'warn',\n      diagnostics: [{\n        origin: 'test',\n        message: 'warn'\n      }]\n    }, EMPTY_OPTIONS);\n    assert.equal(stdoutOutput, '\\n\\n');\n    assert(stderrOutput.includes('test: error\\n'));\n    assert(stderrOutput.includes('test: warn\\n'));\n  });","file":"CLIReporter.test.js","skipped":false,"dir":"packages/reporters/cli/test"},{"name":"writes buildProgress messages to stdout on the default loglevel","suites":["CLIReporter"],"updatePoint":{"line":129,"column":69,"index":3406},"line":129,"code":"  it('writes buildProgress messages to stdout on the default loglevel', async () => {\n    await _report({\n      type: 'buildProgress',\n      phase: 'bundling'\n    }, EMPTY_OPTIONS);\n    assert.equal(stdoutOutput, 'Bundling...\\n');\n  });","file":"CLIReporter.test.js","skipped":false,"dir":"packages/reporters/cli/test"},{"name":"writes buildSuccess messages to stdout on the default loglevel","suites":["CLIReporter"],"updatePoint":{"line":136,"column":68,"index":3642},"line":136,"code":"  it('writes buildSuccess messages to stdout on the default loglevel', async () => {\n    await _report({\n      type: 'buildProgress',\n      phase: 'bundling'\n    }, EMPTY_OPTIONS);\n    assert.equal(stdoutOutput, 'Bundling...\\n');\n  });","file":"CLIReporter.test.js","skipped":false,"dir":"packages/reporters/cli/test"},{"name":"should parse unquoted url()","suites":["parseFuncIRI"],"updatePoint":{"line":4,"column":33,"index":148},"line":4,"code":"  it('should parse unquoted url()', () => {\n    assert.deepEqual(parseFuncIRI('url(test)'), ['test', '']);\n    assert.deepEqual(parseFuncIRI('url(test hi)'), null);\n    assert.deepEqual(parseFuncIRI('url(test\"hi)'), null);\n    assert.deepEqual(parseFuncIRI('url(test\\\\ hi)'), ['test hi', '']);\n    assert.deepEqual(parseFuncIRI('url(test\\\\\"hi)'), ['test\"hi', '']);\n    assert.deepEqual(parseFuncIRI('url(test\\nhi)'), null);\n    assert.deepEqual(parseFuncIRI('url(test\\\\\\nhi)'), ['test\\nhi', '']);\n  });","file":"parseFuncIRI.test.js","skipped":false,"dir":"packages/transformers/svg/test"},{"name":"should parse quoted url()","suites":["parseFuncIRI"],"updatePoint":{"line":13,"column":31,"index":649},"line":13,"code":"  it('should parse quoted url()', () => {\n    assert.deepEqual(parseFuncIRI('url(\"test\")'), ['test', '']);\n    assert.deepEqual(parseFuncIRI(\"url('test')\"), ['test', '']);\n    assert.deepEqual(parseFuncIRI('url(\\'test\")'), null);\n    assert.deepEqual(parseFuncIRI('url(\"test\\')'), null);\n    assert.deepEqual(parseFuncIRI('url(\"test)'), null);\n    assert.deepEqual(parseFuncIRI('url(\"test\" hi)'), ['test', ' hi']);\n    assert.deepEqual(parseFuncIRI('url(\"te\\\\\"st\" hi)'), ['te\"st', ' hi']);\n  });","file":"parseFuncIRI.test.js","skipped":false,"dir":"packages/transformers/svg/test"},{"name":"compiles against targets passed through caller with env = esmodule","suites":["@parcel/plugin-transform-runtime"],"updatePoint":{"line":14,"column":72,"index":375},"line":14,"code":"  it('compiles against targets passed through caller with env = esmodule', () => {\n    let {\n      code: transformed\n    } = babel.transformSync(input, {\n      configFile: false,\n      presets: [preset],\n      plugins: [plugin],\n      caller: {\n        name: 'parcel',\n        version: '2.0.0',\n        targets: JSON.stringify({\n          browsers: ['last 1 Chrome version']\n        }),\n        env: 'esmodule'\n      }\n    });\n    assert(transformed.includes('function Foo'));\n    assert(transformed.includes('...x'));\n  });","file":"babel-plugin-transform-runtime.test.js","skipped":false,"dir":"packages/utils/babel-plugin-transform-runtime/test"},{"name":"compiles against targets passed through caller with no env","suites":["@parcel/plugin-transform-runtime"],"updatePoint":{"line":33,"column":64,"index":892},"line":33,"code":"  it('compiles against targets passed through caller with no env', () => {\n    let {\n      code: transformed\n    } = babel.transformSync(input, {\n      configFile: false,\n      presets: [preset],\n      plugins: [plugin],\n      caller: {\n        name: 'parcel',\n        version: '2.0.0',\n        targets: JSON.stringify({\n          browsers: ['last 1 Chrome version']\n        })\n      }\n    });\n    assert(transformed.includes('function Foo'));\n    assert(transformed.includes('...x'));\n  });","file":"babel-plugin-transform-runtime.test.js","skipped":false,"dir":"packages/utils/babel-plugin-transform-runtime/test"},{"name":"compiles against targets passed through caller when the caller is parcel 2.x","suites":["@parcel/babel-preset-env"],"updatePoint":{"line":22,"column":82,"index":405},"line":22,"code":"  it('compiles against targets passed through caller when the caller is parcel 2.x', () => {\n    let {\n      code: transformed\n    } = babel.transformSync(input, {\n      configFile: false,\n      presets: [preset],\n      caller: {\n        name: 'parcel',\n        version: '2.0.0',\n        targets: JSON.stringify({\n          browsers: ['last 1 Chrome version']\n        })\n      }\n    });\n    assert(transformed.includes('class Foo'));\n    assert(transformed.includes('this.x ** 2'));\n    assert(transformed.includes('export default'));\n  });","file":"preset-env.test.js","skipped":false,"dir":"packages/utils/babel-preset-env/test"},{"name":"does not compile against targets passed through caller when the caller is not parcel","suites":["@parcel/babel-preset-env"],"updatePoint":{"line":40,"column":90,"index":954},"line":40,"code":"  it('does not compile against targets passed through caller when the caller is not parcel', () => {\n    let {\n      code: transformed\n    } = babel.transformSync(input, {\n      configFile: false,\n      presets: [preset],\n      caller: {\n        name: 'foo',\n        version: '2.0.0',\n        targets: JSON.stringify({\n          browsers: ['last 1 Chrome version']\n        })\n      }\n    });\n    assert(!transformed.includes('class Foo'));\n    assert(!transformed.includes('this.x ** 2'));\n    assert(!transformed.includes('export default'));\n  });","file":"preset-env.test.js","skipped":false,"dir":"packages/utils/babel-preset-env/test"},{"name":"does not compile against targets passed through caller when the caller is not present","suites":["@parcel/babel-preset-env"],"updatePoint":{"line":58,"column":91,"index":1504},"line":58,"code":"  it('does not compile against targets passed through caller when the caller is not present', () => {\n    let {\n      code: transformed\n    } = babel.transformSync(input, {\n      configFile: false,\n      presets: [preset]\n    });\n    assert(!transformed.includes('class Foo'));\n    assert(!transformed.includes('this.x ** 2'));\n    assert(!transformed.includes('export default'));\n  });","file":"preset-env.test.js","skipped":false,"dir":"packages/utils/babel-preset-env/test"},{"name":"can wrap an IDisposable","suites":["Disposable"],"updatePoint":{"line":7,"column":29,"index":190},"line":7,"code":"  it('can wrap an IDisposable', () => {\n    let disposed;\n    new Disposable({\n      dispose() {\n        disposed = true;\n      }\n    }).dispose();\n    assert.equal(disposed, true);\n  });","file":"Disposable.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"can wrap a function to dispose","suites":["Disposable"],"updatePoint":{"line":16,"column":36,"index":385},"line":16,"code":"  it('can wrap a function to dispose', () => {\n    let disposed;\n    new Disposable(() => {\n      disposed = true;\n    }).dispose();\n    assert.equal(disposed, true);\n  });","file":"Disposable.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"can wrap many disposable-likes","suites":["Disposable"],"updatePoint":{"line":23,"column":36,"index":558},"line":23,"code":"  it('can wrap many disposable-likes', () => {\n    let disposed1;\n    let disposed2;\n    new Disposable({\n      dispose() {\n        disposed1 = true;\n      }\n    }, () => {\n      disposed2 = true;\n    }).dispose();\n    assert.equal(disposed1, true);\n    assert.equal(disposed2, true);\n  });","file":"Disposable.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"can add disposables after construction","suites":["Disposable"],"updatePoint":{"line":36,"column":44,"index":857},"line":36,"code":"  it('can add disposables after construction', () => {\n    let disposed1;\n    let disposed2;\n    let disposed3;\n    let disposed4;\n    let disposable = new Disposable({\n      dispose() {\n        disposed1 = true;\n      }\n    }, () => {\n      disposed2 = true;\n    });\n    disposable.add(() => {\n      disposed3 = true;\n    }, {\n      dispose() {\n        disposed4 = true;\n      }\n    });\n    assert.notEqual(disposed1, true);\n    assert.notEqual(disposed2, true);\n    assert.notEqual(disposed3, true);\n    assert.notEqual(disposed4, true);\n    disposable.dispose();\n    assert.equal(disposed1, true);\n    assert.equal(disposed2, true);\n    assert.equal(disposed3, true);\n    assert.equal(disposed4, true);\n  });","file":"Disposable.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"throws if `add` is called after it has been disposed","suites":["Disposable"],"updatePoint":{"line":77,"column":58,"index":1924},"line":77,"code":"  it('throws if `add` is called after it has been disposed', () => {\n    let disposable = new Disposable();\n    disposable.dispose();\n    assert.throws(() => {\n      disposable.add(() => {});\n    }, AlreadyDisposedError);\n  });","file":"Disposable.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"can be checked for disposal state","suites":["Disposable"],"updatePoint":{"line":84,"column":39,"index":2133},"line":84,"code":"  it('can be checked for disposal state', () => {\n    let disposable = new Disposable();\n    assert.equal(disposable.disposed, false);\n    disposable.dispose();\n    assert.equal(disposable.disposed, true);\n  });","file":"Disposable.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"registers new listeners and can dispose of them","suites":["ValueEmitter"],"updatePoint":{"line":19,"column":53,"index":431},"line":19,"code":"  it('registers new listeners and can dispose of them', () => {\n    let disposable = emitter.addListener(numberListener);\n    assert.deepEqual(emitter._listeners, [numberListener]);\n    disposable.dispose();\n    assert.deepEqual(emitter._listeners, []);\n  });","file":"ValueEmitter.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"emits values to registered listeners","suites":["ValueEmitter"],"updatePoint":{"line":25,"column":42,"index":680},"line":25,"code":"  it('emits values to registered listeners', () => {\n    let disposable = emitter.addListener(numberListener);\n    emitter.emit(42);\n    assert.deepEqual(values, [42]);\n    disposable.dispose();\n  });","file":"ValueEmitter.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"does not emit to listeners that were just registered","suites":["ValueEmitter"],"updatePoint":{"line":31,"column":58,"index":897},"line":31,"code":"  it('does not emit to listeners that were just registered', () => {\n    let innerDisposable;\n    let disposable = emitter.addListener(() => {\n      innerDisposable = emitter.addListener(numberListener);\n    });\n    emitter.emit(42);\n    assert.deepEqual(values, []);\n    emitter.emit(27);\n    assert.deepEqual(values, [27]);\n    disposable.dispose();\n    innerDisposable && innerDisposable.dispose();\n  });","file":"ValueEmitter.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"finishes emitting even if a listener disposes of the emitter mid-emit","suites":["ValueEmitter"],"updatePoint":{"line":43,"column":75,"index":1322},"line":43,"code":"  it('finishes emitting even if a listener disposes of the emitter mid-emit', () => {\n    let disposableA = emitter.addListener(() => {\n      emitter.dispose();\n    });\n    let disposableB = emitter.addListener(numberListener);\n    emitter.emit(42);\n    assert.deepEqual(values, [42]);\n    disposableA.dispose();\n    disposableB.dispose();\n  });","file":"ValueEmitter.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"clears listeners when disposed","suites":["ValueEmitter"],"updatePoint":{"line":53,"column":36,"index":1629},"line":53,"code":"  it('clears listeners when disposed', () => {\n    let disposable = emitter.addListener(numberListener);\n    assert.deepEqual(emitter._listeners, [numberListener]);\n    emitter.dispose();\n    assert.deepEqual(emitter._listeners, []);\n    disposable.dispose();\n  });","file":"ValueEmitter.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"throws when adding a listener when already disposed","suites":["ValueEmitter"],"updatePoint":{"line":60,"column":57,"index":1916},"line":60,"code":"  it('throws when adding a listener when already disposed', () => {\n    emitter.dispose();\n    assert.throws(() => {\n      emitter.addListener(numberListener);\n    }, AlreadyDisposedError);\n  });","file":"ValueEmitter.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"throws when emitting when already disposed","suites":["ValueEmitter"],"updatePoint":{"line":66,"column":48,"index":2103},"line":66,"code":"  it('throws when emitting when already disposed', () => {\n    emitter.dispose();\n    assert.throws(() => {\n      emitter.emit(42);\n    }, AlreadyDisposedError);\n  });","file":"ValueEmitter.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"can be disposed multiple times","suites":["ValueEmitter"],"updatePoint":{"line":72,"column":36,"index":2259},"line":72,"code":"  it('can be disposed multiple times', () => {\n    emitter.dispose();\n    assert.doesNotThrow(() => {\n      emitter.dispose();\n    });\n  });","file":"ValueEmitter.test.js","skipped":false,"dir":"packages/utils/events/test"},{"name":"should resolve a relative path with an extension","suites":["resolver","file paths"],"updatePoint":{"line":46,"column":56,"index":2133},"line":46,"code":"    it('should resolve a relative path with an extension', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './bar.js',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'bar.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a relative path without an extension","suites":["resolver","file paths"],"updatePoint":{"line":55,"column":59,"index":2491},"line":55,"code":"    it('should resolve a relative path without an extension', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'bar.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve an absolute path from the root module","suites":["resolver","file paths"],"updatePoint":{"line":64,"column":60,"index":2847},"line":64,"code":"    it('should resolve an absolute path from the root module', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '/bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'nested', 'test.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'bar.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve an absolute path from a node_modules folder","suites":["resolver","file paths"],"updatePoint":{"line":73,"column":66,"index":3219},"line":73,"code":"    it('should resolve an absolute path from a node_modules folder', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '/bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'foo', 'index.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'bar.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a tilde path from the root module","suites":["resolver","file paths"],"updatePoint":{"line":82,"column":56,"index":3595},"line":82,"code":"    it('should resolve a tilde path from the root module', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '~/bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'nested', 'test.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'bar.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a tilde path from the root module without a slash","suites":["resolver","file paths"],"updatePoint":{"line":91,"column":72,"index":3974},"line":91,"code":"    it('should resolve a tilde path from the root module without a slash', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '~bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'nested', 'test.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'bar.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a tilde path from a node_modules folder","suites":["resolver","file paths"],"updatePoint":{"line":100,"column":62,"index":4342},"line":100,"code":"    it('should resolve a tilde path from a node_modules folder', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '~/bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'foo', 'nested', 'baz.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'node_modules', 'foo', 'bar.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve an index file in a directory","suites":["resolver","file paths"],"updatePoint":{"line":109,"column":51,"index":4745},"line":109,"code":"    it('should resolve an index file in a directory', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './nested',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'nested', 'index.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not resolve an index file in a directory for URL specifiers","suites":["resolver","file paths"],"updatePoint":{"line":118,"column":74,"index":5130},"line":118,"code":"    it('should not resolve an index file in a directory for URL specifiers', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './nested',\n        specifierType: 'url',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(nullthrows(resolved).diagnostics, [{\n        message: \"Cannot load file './nested' in './'.\",\n        hints: []\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a file with a question mark with CommonJS specifiers","suites":["resolver","file paths"],"updatePoint":{"line":130,"column":75,"index":5569},"line":130,"code":"    it('should resolve a file with a question mark with CommonJS specifiers', async function () {\n      // Windows filenames cannot contain question marks.\n      if (process.platform === 'win32') {\n        return;\n      }\n      await overlayFS.writeFile(path.join(rootDir, 'a?b.js'), '');\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './a?b.js',\n        specifierType: 'commonjs',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'a?b.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not resolve a file with a question mark with ESM specifiers","suites":["resolver","file paths"],"updatePoint":{"line":144,"column":74,"index":6138},"line":144,"code":"    it('should not resolve a file with a question mark with ESM specifiers', async function () {\n      // Windows filenames cannot contain question marks.\n      if (process.platform === 'win32') {\n        return;\n      }\n      await overlayFS.writeFile(path.join(rootDir, 'a?b.js'), '');\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './a?b.js',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(nullthrows(resolved).diagnostics, [{\n        message: \"Cannot load file './a' in './'.\",\n        hints: []\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a file with an encoded question mark with ESM specifiers","suites":["resolver","file paths"],"updatePoint":{"line":161,"column":79,"index":6767},"line":161,"code":"    it('should resolve a file with an encoded question mark with ESM specifiers', async function () {\n      // Windows filenames cannot contain question marks.\n      if (process.platform === 'win32') {\n        return;\n      }\n      await overlayFS.writeFile(path.join(rootDir, 'a?b.js'), '');\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './a%3Fb.js',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'a?b.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not support percent encoding in CommonJS specifiers","suites":["resolver","file paths"],"updatePoint":{"line":175,"column":66,"index":7325},"line":175,"code":"    it('should not support percent encoding in CommonJS specifiers', async function () {\n      // Windows filenames cannot contain question marks.\n      if (process.platform === 'win32') {\n        return;\n      }\n      await overlayFS.writeFile(path.join(rootDir, 'a?b.js'), '');\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './a%3Fb.js',\n        specifierType: 'commonjs',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(nullthrows(resolved).diagnostics, [{\n        message: \"Cannot load file './a%3Fb.js' in './'.\",\n        hints: [\"Did you mean '__./a?b.js__'?\"]\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should support query params for ESM specifiers","suites":["resolver","file paths"],"updatePoint":{"line":192,"column":54,"index":7973},"line":192,"code":"    it('should support query params for ESM specifiers', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './nested?foo=bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'nested', 'index.js'));\n      assert.deepEqual(nullthrows(resolved).query?.toString(), 'foo=bar');\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not support query params for CommonJS specifiers","suites":["resolver","file paths"],"updatePoint":{"line":202,"column":63,"index":8430},"line":202,"code":"    it('should not support query params for CommonJS specifiers', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './nested?foo=bar',\n        specifierType: 'commonjs',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(nullthrows(resolved).diagnostics, [{\n        message: \"Cannot load file './nested?foo=bar' in './'.\",\n        hints: []\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve node builtin modules","suites":["resolver","builtins"],"updatePoint":{"line":216,"column":43,"index":8901},"line":216,"code":"    it('should resolve node builtin modules', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'zlib',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: require.resolve('browserify-zlib'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/browserify-zlib',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: require.resolve('browserify-zlib/lib/index.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), require.resolve('browserify-zlib/package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"Should be able to handle node: prefixes","suites":["resolver","builtins"],"updatePoint":{"line":243,"column":47,"index":9916},"line":243,"code":"    it('Should be able to handle node: prefixes', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'node:zlib',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: require.resolve('browserify-zlib'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/browserify-zlib',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: require.resolve('browserify-zlib/lib/index.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), require.resolve('browserify-zlib/package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve unimplemented node builtin modules to an empty file","suites":["resolver","builtins"],"updatePoint":{"line":270,"column":74,"index":10963},"line":270,"code":"    it('should resolve unimplemented node builtin modules to an empty file', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'fs',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(__dirname, '..', 'src', '_empty.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(__dirname, '..', 'src', '_empty.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(__dirname, '..', 'src', '_empty.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(__dirname, '..', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should error when resolving node builtin modules with --target=node","suites":["resolver","builtins"],"updatePoint":{"line":297,"column":75,"index":12013},"line":297,"code":"    it('should error when resolving node builtin modules with --target=node', async function () {\n      let resolved = await resolver.resolve({\n        env: NODE_ENV,\n        filename: 'zlib',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        isExcluded: true\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should exclude the electron module in electron environments","suites":["resolver","builtins"],"updatePoint":{"line":308,"column":67,"index":12361},"line":308,"code":"    it('should exclude the electron module in electron environments', async function () {\n      let resolved = await resolver.resolve({\n        env: new Environment(createEnvironment({\n          context: 'electron-main',\n          isLibrary: true\n        }), DEFAULT_OPTIONS),\n        filename: 'electron',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js'),\n        sourcePath: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        isExcluded: true\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a node_modules index.js","suites":["resolver","node_modules"],"updatePoint":{"line":325,"column":46,"index":12907},"line":325,"code":"    it('should resolve a node_modules index.js', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'foo', 'index.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/foo',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'foo', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a node_modules package.main","suites":["resolver","node_modules"],"updatePoint":{"line":349,"column":50,"index":13820},"line":349,"code":"    it('should resolve a node_modules package.main', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-main',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-main', 'main.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/package-main',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-main', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a node_modules package.module","suites":["resolver","node_modules"],"updatePoint":{"line":373,"column":52,"index":14770},"line":373,"code":"    it('should resolve a node_modules package.module', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-module',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-module', 'module.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/package-module',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-module', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a node_modules package.browser main field","suites":["resolver","node_modules"],"updatePoint":{"line":397,"column":64,"index":15742},"line":397,"code":"    it('should resolve a node_modules package.browser main field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-browser',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-browser', 'browser.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/package-browser',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-browser', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not resolve a node_modules package.browser main field with --target=node","suites":["resolver","node_modules"],"updatePoint":{"line":421,"column":87,"index":16742},"line":421,"code":"    it('should not resolve a node_modules package.browser main field with --target=node', async function () {\n      let resolved = await resolver.resolve({\n        env: NODE_INCLUDE_ENV,\n        filename: 'package-browser',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-browser', 'main.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/package-browser',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-browser', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should fall back to index.js when it cannot find package.main","suites":["resolver","node_modules"],"updatePoint":{"line":445,"column":69,"index":17726},"line":445,"code":"    it('should fall back to index.js when it cannot find package.main', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-fallback',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-fallback', 'index.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/package-fallback',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-fallback', 'main.js')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-fallback', 'main.js.js')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-fallback', 'main.js.json')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-fallback', 'main.js/package.json')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-fallback', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a node_module package.main pointing to a directory","suites":["resolver","node_modules"],"updatePoint":{"line":477,"column":73,"index":19131},"line":477,"code":"    it('should resolve a node_module package.main pointing to a directory', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-main-directory',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-main-directory', 'nested', 'index.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/package-main-directory',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-main-directory', 'nested.js')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-main-directory', 'nested.json')\n        }, {\n          filePath: path.join(rootDir, 'node_modules', 'package-main-directory', 'nested', 'package.json')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-main-directory', 'nested', 'index.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-main-directory', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a file inside a node_modules folder","suites":["resolver","node_modules"],"updatePoint":{"line":510,"column":58,"index":20631},"line":510,"code":"    it('should resolve a file inside a node_modules folder', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'foo/nested/baz',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'foo', 'nested', 'baz.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/foo',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'foo', 'nested', 'baz.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'foo', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a scoped module","suites":["resolver","node_modules"],"updatePoint":{"line":537,"column":38,"index":21687},"line":537,"code":"    it('should resolve a scoped module', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '@scope/pkg',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.resolve(rootDir, 'node_modules/@scope/pkg/index.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/@scope/pkg',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', '@scope', 'pkg', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a file inside a scoped module","suites":["resolver","node_modules"],"updatePoint":{"line":561,"column":52,"index":22630},"line":561,"code":"    it('should resolve a file inside a scoped module', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '@scope/pkg/foo/bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.resolve(rootDir, 'node_modules/@scope/pkg/foo/bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/@scope/pkg',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', '@scope', 'pkg', 'foo', 'bar.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', '@scope', 'pkg', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (file)","suites":["resolver","node_modules","sideEffects: false"],"updatePoint":{"line":589,"column":55,"index":23778},"line":589,"code":"      it('should determine sideEffects correctly (file)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false/src/index.js',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        assert.deepEqual(resolved, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false/src/index.js'),\n          sideEffects: false,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'index')\n          }, {\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }, {\n            fileName: 'node_modules/side-effects-false',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }, {\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'node_modules', 'side-effects-false', 'src', 'index.js')\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'side-effects-false', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (extensionless file)","suites":["resolver","node_modules","sideEffects: false"],"updatePoint":{"line":616,"column":69,"index":24982},"line":616,"code":"      it('should determine sideEffects correctly (extensionless file)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false/src/index',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        assert.deepEqual(resolved, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false/src/index.js'),\n          sideEffects: false,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'index')\n          }, {\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }, {\n            fileName: 'node_modules/side-effects-false',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }, {\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'node_modules', 'side-effects-false', 'src', 'index.js')\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'side-effects-false', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (sub folder)","suites":["resolver","node_modules","sideEffects: false"],"updatePoint":{"line":643,"column":61,"index":26175},"line":643,"code":"      it('should determine sideEffects correctly (sub folder)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false/src/',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        assert.deepEqual(resolved, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false/src/index.js'),\n          sideEffects: false,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'index')\n          }, {\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }, {\n            fileName: 'node_modules/side-effects-false',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-false', 'src', 'package.json')\n          }, {\n            aboveFilePath: path.join(rootDir, 'node_modules', 'side-effects-false', 'src', 'index'),\n            fileName: 'package.json'\n          }, {\n            aboveFilePath: path.join(rootDir, 'node_modules', 'side-effects-false', 'src', 'index.js'),\n            fileName: 'package.json'\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'side-effects-false', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (main field)","suites":["resolver","node_modules","sideEffects: false"],"updatePoint":{"line":675,"column":61,"index":27633},"line":675,"code":"      it('should determine sideEffects correctly (main field)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false/src/',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        assert.deepEqual(resolved, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false/src/index.js'),\n          sideEffects: false,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'index')\n          }, {\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }, {\n            fileName: 'node_modules/side-effects-false',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-false', 'src', 'package.json')\n          }, {\n            aboveFilePath: path.join(rootDir, 'node_modules', 'side-effects-false', 'src', 'index'),\n            fileName: 'package.json'\n          }, {\n            aboveFilePath: path.join(rootDir, 'node_modules', 'side-effects-false', 'src', 'index.js'),\n            fileName: 'package.json'\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'side-effects-false', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (main field exists in upward package)","suites":["resolver","node_modules","sideEffects: false"],"updatePoint":{"line":707,"column":86,"index":29116},"line":707,"code":"      it('should determine sideEffects correctly (main field exists in upward package)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-package-redirect-up/foo/bar',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        assert.deepEqual(resolved, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-package-redirect-up/foo/real-bar.js'),\n          sideEffects: false,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'index')\n          }, {\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }, {\n            fileName: 'node_modules/side-effects-package-redirect-up',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-up', 'foo', 'bar.js')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-up', 'foo', 'bar.json')\n          }, {\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'node_modules/side-effects-package-redirect-up/foo/real-bar.js')\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'side-effects-package-redirect-up', 'package.json'), path.join(rootDir, 'node_modules', 'side-effects-package-redirect-up', 'foo', 'bar', 'package.json'), path.join(rootDir, 'node_modules', 'side-effects-package-redirect-up', 'foo', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (main field exists in downward package)","suites":["resolver","node_modules","sideEffects: false"],"updatePoint":{"line":738,"column":88,"index":30850},"line":738,"code":"      it('should determine sideEffects correctly (main field exists in downward package)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-package-redirect-down/foo/bar',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        assert.deepEqual(resolved, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-package-redirect-down/foo/bar/baz/real-bar.js'),\n          sideEffects: false,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'index')\n          }, {\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }, {\n            fileName: 'node_modules/side-effects-package-redirect-down',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-down', 'foo', 'bar.js')\n          }, {\n            filePath: path.join(rootDir, 'node_modules', 'side-effects-package-redirect-down', 'foo', 'bar.json')\n          }, {\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'node_modules/side-effects-package-redirect-down/foo/bar/baz/real-bar.js')\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'side-effects-package-redirect-down', 'package.json'), path.join(rootDir, 'node_modules', 'side-effects-package-redirect-down', 'foo', 'bar', 'package.json'), path.join(rootDir, 'node_modules', 'side-effects-package-redirect-down', 'foo', 'bar', 'baz', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (matched)","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":771,"column":58,"index":32659},"line":771,"code":"      it('should determine sideEffects correctly (matched)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false-glob/a/index',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        assert.deepEqual({\n          filePath: resolved?.filePath,\n          sideEffects: resolved?.sideEffects\n        }, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false-glob/a/index.js'),\n          sideEffects: undefined\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (unmatched)","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":786,"column":60,"index":33238},"line":786,"code":"      it('should determine sideEffects correctly (unmatched)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false-glob/b/index.js',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        assert.deepEqual({\n          filePath: resolved?.filePath,\n          sideEffects: resolved?.sideEffects\n        }, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false-glob/b/index.js'),\n          sideEffects: false\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (matched dotslash)","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":801,"column":67,"index":33823},"line":801,"code":"      it('should determine sideEffects correctly (matched dotslash)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false-glob/sub/index.js',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        assert.deepEqual({\n          filePath: resolved?.filePath,\n          sideEffects: resolved?.sideEffects\n        }, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false-glob/sub/index.js'),\n          sideEffects: undefined\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (unmatched, prefix in subdir)","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":816,"column":78,"index":34427},"line":816,"code":"      it('should determine sideEffects correctly (unmatched, prefix in subdir)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false-glob/sub/a/index.js',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        assert.deepEqual({\n          filePath: resolved?.filePath,\n          sideEffects: resolved?.sideEffects\n        }, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false-glob/sub/a/index.js'),\n          sideEffects: false\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should determine sideEffects correctly (only name)","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":831,"column":60,"index":35013},"line":831,"code":"      it('should determine sideEffects correctly (only name)', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'side-effects-false-glob/sub/index.json',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        assert.deepEqual({\n          filePath: resolved?.filePath,\n          sideEffects: resolved?.sideEffects\n        }, {\n          filePath: path.resolve(rootDir, 'node_modules/side-effects-false-glob/sub/index.json'),\n          sideEffects: undefined\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not resolve a node module for URL dependencies","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":847,"column":61,"index":35612},"line":847,"code":"    it('should not resolve a node module for URL dependencies', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '@scope/pkg',\n        specifierType: 'url',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(nullthrows(resolved).diagnostics, [{\n        message: \"Cannot load file './@scope/pkg' in './'.\",\n        hints: []\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve a node module for URL dependencies with the npm: prefix","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":859,"column":78,"index":36060},"line":859,"code":"    it('should resolve a node module for URL dependencies with the npm: prefix', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'npm:@scope/pkg',\n        specifierType: 'url',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(nullthrows(resolved).filePath, path.join(rootDir, 'node_modules', '@scope', 'pkg', 'index.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should support query params for bare ESM specifiers","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":868,"column":59,"index":36463},"line":868,"code":"    it('should support query params for bare ESM specifiers', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '@scope/pkg?foo=2',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.resolve(rootDir, 'node_modules/@scope/pkg/index.js'));\n      assert.deepEqual(nullthrows(resolved).query?.toString(), 'foo=2');\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not support query params for bare CommonJS specifiers","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":878,"column":68,"index":36940},"line":878,"code":"    it('should not support query params for bare CommonJS specifiers', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '@scope/pkg?foo=2',\n        specifierType: 'commonjs',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(nullthrows(resolved).diagnostics, [{\n        message: 'Cannot find module @scope/pkg?foo=2',\n        hints: [\"Did you mean '__@scope/pkg__'?\"]\n      }]);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should support query params for npm: specifiers","suites":["resolver","node_modules","sideEffects: globs"],"updatePoint":{"line":890,"column":55,"index":37403},"line":890,"code":"    it('should support query params for npm: specifiers', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'npm:@scope/pkg?foo=2',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.resolve(rootDir, 'node_modules/@scope/pkg/index.js'));\n      assert.deepEqual(nullthrows(resolved).query?.toString(), 'foo=2');\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should alias the main file using the package.browser field","suites":["resolver","aliases"],"updatePoint":{"line":902,"column":66,"index":37924},"line":902,"code":"    it('should alias the main file using the package.browser field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-browser-alias',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-browser-alias', 'browser.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/package-browser-alias',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-browser-alias', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should alias a sub-file using the package.browser field","suites":["resolver","aliases"],"updatePoint":{"line":926,"column":63,"index":38924},"line":926,"code":"    it('should alias a sub-file using the package.browser field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-browser-alias/foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-browser-alias', 'bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/package-browser-alias',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-browser-alias', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should alias a relative file using the package.browser field","suites":["resolver","aliases"],"updatePoint":{"line":950,"column":68,"index":39929},"line":950,"code":"    it('should alias a relative file using the package.browser field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'package-browser-alias', 'browser.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-browser-alias', 'bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-browser-alias', 'browser.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-browser-alias', 'bar')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-browser-alias', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not alias using the package.browser field with --target=node","suites":["resolver","aliases"],"updatePoint":{"line":974,"column":75,"index":41027},"line":974,"code":"    it('should not alias using the package.browser field with --target=node', async function () {\n      let resolved = await resolver.resolve({\n        env: NODE_INCLUDE_ENV,\n        filename: 'package-browser-alias/foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-browser-alias', 'foo.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/package-browser-alias',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-browser-alias', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should alias a deep nested relative file using the package.browser field","suites":["resolver","aliases"],"updatePoint":{"line":998,"column":80,"index":42049},"line":998,"code":"    it('should alias a deep nested relative file using the package.browser field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './nested',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'package-browser-alias', 'browser.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-browser-alias', 'subfolder1/subfolder2/subfile.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-browser-alias', 'browser.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-browser-alias', 'nested')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-browser-alias', 'subfolder1', 'subfolder2', 'subfile.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-browser-alias', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should alias a sub-file using the package.alias field","suites":["resolver","aliases"],"updatePoint":{"line":1025,"column":61,"index":43341},"line":1025,"code":"    it('should alias a sub-file using the package.alias field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-alias/foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-alias', 'bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/package-alias',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-alias', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should alias a relative file using the package.alias field","suites":["resolver","aliases"],"updatePoint":{"line":1049,"column":66,"index":44312},"line":1049,"code":"    it('should alias a relative file using the package.alias field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'package-alias', 'browser.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-alias', 'bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-alias', 'browser.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-alias', 'bar')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-alias', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should alias a glob using the package.alias field","suites":["resolver","aliases"],"updatePoint":{"line":1073,"column":57,"index":45352},"line":1073,"code":"    it('should alias a glob using the package.alias field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './lib/test',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'package-alias-glob', 'index.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'package-alias-glob', 'src', 'test.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-alias-glob', 'index.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-alias-glob', 'src', 'test')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-alias-glob', 'src', 'test.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-alias-glob', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply a module alias using the package.alias field in the root package","suites":["resolver","aliases"],"updatePoint":{"line":1100,"column":85,"index":46611},"line":1100,"code":"    it('should apply a module alias using the package.alias field in the root package', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliased',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'foo', 'index.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/foo',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'foo', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply a global module alias using the package.alias field in the root package","suites":["resolver","aliases"],"updatePoint":{"line":1124,"column":92,"index":47570},"line":1124,"code":"    it('should apply a global module alias using the package.alias field in the root package', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliased',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'package-alias', 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'foo', 'index.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-alias', 'foo.js')\n        }, {\n          fileName: 'node_modules/foo',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-alias', 'foo.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-alias', 'package.json'), path.join(rootDir, 'node_modules', 'foo', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply a global module alias to a sub-file in a package","suites":["resolver","aliases"],"updatePoint":{"line":1148,"column":69,"index":48674},"line":1148,"code":"    it('should apply a global module alias to a sub-file in a package', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliased/bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'package-alias', 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'node_modules', 'foo', 'bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-alias', 'foo.js')\n        }, {\n          fileName: 'node_modules/foo',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-alias', 'foo.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-alias', 'package.json'), path.join(rootDir, 'node_modules', 'foo', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply a module alias pointing to a file using the package.alias field","suites":["resolver","aliases"],"updatePoint":{"line":1172,"column":84,"index":49795},"line":1172,"code":"    it('should apply a module alias pointing to a file using the package.alias field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliased-file',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'bar.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply a global module alias pointing to a file using the package.alias field","suites":["resolver","aliases"],"updatePoint":{"line":1196,"column":91,"index":50670},"line":1196,"code":"    it('should apply a global module alias pointing to a file using the package.alias field', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliased-file',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'package-alias', 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-alias', 'foo.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'bar.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-alias', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply an alias for a virtual module folder (relative to project dir)","suites":["resolver","aliases"],"updatePoint":{"line":1220,"column":83,"index":51672},"line":1220,"code":"    it('should apply an alias for a virtual module folder (relative to project dir)', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliasedfolder/test.js',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'nested', 'test.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested', 'test.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested', 'test.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply an alias for a virtual module folder only (relative to project dir)","suites":["resolver","aliases"],"updatePoint":{"line":1247,"column":88,"index":52689},"line":1247,"code":"    it('should apply an alias for a virtual module folder only (relative to project dir)', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliasedfolder',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'nested', 'index.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested')\n        }, {\n          filePath: path.join(rootDir, 'nested.js')\n        }, {\n          filePath: path.join(rootDir, 'nested.json')\n        }, {\n          filePath: path.join(rootDir, 'nested', 'package.json')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested/index.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply an alias for a virtual module folder (relative to root dir)","suites":["resolver","aliases"],"updatePoint":{"line":1280,"column":80,"index":53888},"line":1280,"code":"    it('should apply an alias for a virtual module folder (relative to root dir)', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliasedabsolute/test.js',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'nested', 'test.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested', 'test.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested', 'test.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply an alias for a virtual module folder only (relative to root dir)","suites":["resolver","aliases"],"updatePoint":{"line":1307,"column":85,"index":54904},"line":1307,"code":"    it('should apply an alias for a virtual module folder only (relative to root dir)', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'aliasedabsolute',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'nested', 'index.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested')\n        }, {\n          filePath: path.join(rootDir, 'nested.js')\n        }, {\n          filePath: path.join(rootDir, 'nested.json')\n        }, {\n          filePath: path.join(rootDir, 'nested', 'package.json')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested/index.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply an alias for a virtual module folder sub-path","suites":["resolver","aliases"],"updatePoint":{"line":1340,"column":66,"index":56091},"line":1340,"code":"    it('should apply an alias for a virtual module folder sub-path', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'foo/bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'bar.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'bar.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply an alias for a virtual module folder glob sub-path","suites":["resolver","aliases"],"updatePoint":{"line":1364,"column":71,"index":56941},"line":1364,"code":"    it('should apply an alias for a virtual module folder glob sub-path', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'glob/bar/test',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'nested', 'test.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested', 'test')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested', 'test.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply an alias for a virtual module","suites":["resolver","aliases"],"updatePoint":{"line":1391,"column":50,"index":57909},"line":1391,"code":"    it('should apply an alias for a virtual module', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'something',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'nested', 'test.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested', 'test.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested', 'test.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should apply a global alias for a virtual module","suites":["resolver","aliases"],"updatePoint":{"line":1418,"column":56,"index":58882},"line":1418,"code":"    it('should apply a global alias for a virtual module', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'something',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'node_modules', 'package-alias', 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(rootDir, 'nested', 'test.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'node_modules', 'package-alias', 'foo.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested', 'test.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'nested', 'test.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-alias', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve to an empty file when package.browser resolves to false","suites":["resolver","aliases"],"updatePoint":{"line":1445,"column":78,"index":60012},"line":1445,"code":"    it('should resolve to an empty file when package.browser resolves to false', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-browser-exclude',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(__dirname, '..', 'src', '_empty.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/package-browser-exclude',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(__dirname, '..', 'src', '_empty.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-browser-exclude', 'package.json'), path.join(__dirname, '..', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve to an empty file when package.alias resolves to false","suites":["resolver","aliases"],"updatePoint":{"line":1472,"column":76,"index":61169},"line":1472,"code":"    it('should resolve to an empty file when package.alias resolves to false', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-alias-exclude',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        filePath: path.join(__dirname, '..', 'src', '_empty.js'),\n        sideEffects: undefined,\n        query: undefined,\n        invalidateOnFileCreate: [{\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'index')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'node_modules/package-alias-exclude',\n          aboveFilePath: path.join(rootDir, 'foo.js')\n        }, {\n          fileName: 'package.json',\n          aboveFilePath: path.join(__dirname, '..', 'src', '_empty.js')\n        }],\n        invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'package-alias-exclude', 'package.json'), path.join(__dirname, '..', 'package.json')]\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should use the source field, when its realpath is not under `node_modules`","suites":["resolver","source field","package behind symlinks"],"updatePoint":{"line":1502,"column":84,"index":62429},"line":1502,"code":"      it('should use the source field, when its realpath is not under `node_modules`', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'source',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        assert.deepEqual(resolved, {\n          filePath: path.join(rootDir, 'packages', 'source', 'source.js'),\n          sideEffects: undefined,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'index')\n          }, {\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }, {\n            fileName: 'node_modules/source',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'source', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not use the source field, when its realpath is under `node_modules`","suites":["resolver","source field","package behind symlinks"],"updatePoint":{"line":1526,"column":84,"index":63431},"line":1526,"code":"      it('should not use the source field, when its realpath is under `node_modules`', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'source-pnpm',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        assert.deepEqual(resolved, {\n          filePath: path.join(rootDir, 'node_modules', '.pnpm', 'source-pnpm@1.0.0', 'node_modules', 'source-pnpm', 'dist.js'),\n          sideEffects: undefined,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'index')\n          }, {\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }, {\n            fileName: 'node_modules/source-pnpm',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'source-pnpm', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not use the source field","suites":["resolver","source field","package not behind symlinks"],"updatePoint":{"line":1552,"column":41,"index":64524},"line":1552,"code":"      it('should not use the source field', async function () {\n        let resolved = await resolver.resolve({\n          env: BROWSER_ENV,\n          filename: 'source-not-symlinked',\n          specifierType: 'esm',\n          parent: path.join(rootDir, 'foo.js')\n        });\n        assert.deepEqual(resolved, {\n          filePath: path.join(rootDir, 'node_modules', 'source-not-symlinked', 'dist.js'),\n          sideEffects: undefined,\n          query: undefined,\n          invalidateOnFileCreate: [{\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'index')\n          }, {\n            fileName: 'package.json',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }, {\n            fileName: 'node_modules/source-not-symlinked',\n            aboveFilePath: path.join(rootDir, 'foo.js')\n          }],\n          invalidateOnFileChange: [path.join(rootDir, 'package.json'), path.join(rootDir, 'node_modules', 'source-not-symlinked', 'package.json')]\n        });\n      });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve symlinked files to their realpath","suites":["resolver","symlinks"],"updatePoint":{"line":1579,"column":56,"index":65607},"line":1579,"code":"    it('should resolve symlinked files to their realpath', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './baz.js',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'bar.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should resolve symlinked directories to their realpath","suites":["resolver","symlinks"],"updatePoint":{"line":1588,"column":62,"index":65968},"line":1588,"code":"    it('should resolve symlinked directories to their realpath', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './symlinked-nested',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(resolved).filePath, path.join(rootDir, 'nested', 'index.js'));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should return diagnostics when package.module does not exist","suites":["resolver","error handling"],"updatePoint":{"line":1599,"column":68,"index":66406},"line":1599,"code":"    it('should return diagnostics when package.module does not exist', async function () {\n      let result = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'package-module-fallback',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(nullthrows(result).diagnostics)[0].message, `Could not load './module.js' from module 'package-module-fallback' found in package.json#module`);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should throw when a relative path cannot be resolved","suites":["resolver","error handling"],"updatePoint":{"line":1608,"column":60,"index":66871},"line":1608,"code":"    it('should throw when a relative path cannot be resolved', async function () {\n      let result = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: './xyz.js',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(nullthrows(nullthrows(result).diagnostics)[0].message, `Cannot load file './xyz.js' in './'.`);\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should throw when a node_module cannot be resolved","suites":["resolver","error handling"],"updatePoint":{"line":1617,"column":58,"index":67260},"line":1617,"code":"    it('should throw when a node_module cannot be resolved', async function () {\n      assert.strictEqual(null, await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'xyz',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      }));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should throw when a subfile of a node_module cannot be resolved","suites":["resolver","error handling"],"updatePoint":{"line":1625,"column":71,"index":67555},"line":1625,"code":"    it('should throw when a subfile of a node_module cannot be resolved', async function () {\n      assert.strictEqual(null, await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'xyz/test/file',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js')\n      }));\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should error when a library is missing an external dependency","suites":["resolver","error handling"],"updatePoint":{"line":1633,"column":69,"index":67858},"line":1633,"code":"    it('should error when a library is missing an external dependency', async function () {\n      let result = await resolver.resolve({\n        env: new Environment(createEnvironment({\n          context: 'browser',\n          isLibrary: true,\n          includeNodeModules: false\n        }), DEFAULT_OPTIONS),\n        filename: 'test',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js'),\n        sourcePath: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(result?.diagnostics?.[0].message, 'External dependency \"test\" is not declared in package.json.');\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not error when external dependencies are declared","suites":["resolver","error handling"],"updatePoint":{"line":1647,"column":64,"index":68447},"line":1647,"code":"    it('should not error when external dependencies are declared', async function () {\n      let result = await resolver.resolve({\n        env: new Environment(createEnvironment({\n          context: 'browser',\n          isLibrary: true,\n          includeNodeModules: false\n        }), DEFAULT_OPTIONS),\n        filename: 'foo',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js'),\n        sourcePath: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(result, {\n        isExcluded: true\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not error when external dependencies are declared in peerDependencies","suites":["resolver","error handling"],"updatePoint":{"line":1663,"column":84,"index":69006},"line":1663,"code":"    it('should not error when external dependencies are declared in peerDependencies', async function () {\n      let result = await resolver.resolve({\n        env: new Environment(createEnvironment({\n          context: 'browser',\n          isLibrary: true,\n          includeNodeModules: false\n        }), DEFAULT_OPTIONS),\n        filename: 'bar',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'foo.js'),\n        sourcePath: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(result, {\n        isExcluded: true\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not error on missing dependencies for environment builtins","suites":["resolver","error handling"],"updatePoint":{"line":1679,"column":73,"index":69554},"line":1679,"code":"    it('should not error on missing dependencies for environment builtins', async function () {\n      let result = await resolver.resolve({\n        env: new Environment(createEnvironment({\n          context: 'browser',\n          isLibrary: true,\n          includeNodeModules: false\n        }), DEFAULT_OPTIONS),\n        filename: 'atom',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'env-dep/foo.js'),\n        sourcePath: path.join(rootDir, 'env-dep/foo.js')\n      });\n      assert.deepEqual(result, {\n        isExcluded: true\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should not error on builtin node modules","suites":["resolver","error handling"],"updatePoint":{"line":1695,"column":48,"index":70094},"line":1695,"code":"    it('should not error on builtin node modules', async function () {\n      let result = await resolver.resolve({\n        env: new Environment(createEnvironment({\n          context: 'browser',\n          isLibrary: true,\n          includeNodeModules: false\n        }), DEFAULT_OPTIONS),\n        filename: 'buffer',\n        specifierType: 'esm',\n        parent: path.join(rootDir, 'env-dep/foo.js'),\n        sourcePath: path.join(rootDir, 'env-dep/foo.js')\n      });\n      assert.deepEqual(result, {\n        isExcluded: true\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should error when a library has an incorrect external dependency version","suites":["resolver","error handling"],"updatePoint":{"line":1711,"column":80,"index":70668},"line":1711,"code":"    it('should error when a library has an incorrect external dependency version', async function () {\n      let result = await resolver.resolve({\n        env: new Environment(createEnvironment({\n          context: 'browser',\n          isLibrary: true,\n          includeNodeModules: false\n        }), DEFAULT_OPTIONS),\n        filename: 'foo',\n        specifierType: 'esm',\n        range: '^0.4.0',\n        parent: path.join(rootDir, 'foo.js'),\n        sourcePath: path.join(rootDir, 'foo.js')\n      });\n      assert.equal(result?.diagnostics?.[0].message, 'External dependency \"foo\" does not satisfy required semver range \"^0.4.0\".');\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should ignore protocol relative urls","suites":["resolver","urls"],"updatePoint":{"line":1728,"column":44,"index":71315},"line":1728,"code":"    it('should ignore protocol relative urls', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '//example.com/foo.png',\n        specifierType: 'url',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        isExcluded: true\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should ignore hash urls","suites":["resolver","urls"],"updatePoint":{"line":1739,"column":31,"index":71647},"line":1739,"code":"    it('should ignore hash urls', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: '#hash',\n        specifierType: 'url',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        isExcluded: true\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"},{"name":"should ignore http: urls","suites":["resolver","urls"],"updatePoint":{"line":1750,"column":32,"index":71964},"line":1750,"code":"    it('should ignore http: urls', async function () {\n      let resolved = await resolver.resolve({\n        env: BROWSER_ENV,\n        filename: 'http://example.com/foo.png',\n        specifierType: 'url',\n        parent: path.join(rootDir, 'foo.js')\n      });\n      assert.deepEqual(resolved, {\n        isExcluded: true\n      });\n    });","file":"resolver.js","skipped":false,"dir":"packages/utils/node-resolver-core/test"}]}