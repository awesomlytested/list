{
    "repo": "caolan/async",
    "url": "https://github.com/caolan/async",
    "branch": "master",
    "configs": [
        {
            "package": "async",
            "lang": "js",
            "dir": "test",
            "framework": "mocha",
            "pattern": "**/*.{js,ts}"
        }
    ],
    "tests": [
        {
            "name": "apply",
            "suites": [
                "concat"
            ],
            "updatePoint": {
                "line": 8,
                "column": 11
            },
            "line": 8,
            "code": "  it('apply', done => {\n    var fn = function (...args) {\n      expect(args).to.eql([1, 2, 3, 4]);\n    };\n\n    async.apply(fn, 1, 2, 3, 4)();\n    async.apply(fn, 1, 2, 3)(4);\n    async.apply(fn, 1, 2)(3, 4);\n    async.apply(fn, 1)(2, 3, 4);\n    async.apply(fn)(1, 2, 3, 4);\n    expect(async.apply(name => {\n      return 'hello ' + name;\n    }, 'world')()).to.equal('hello world');\n    done();\n  });",
            "file": "apply.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "applyEach",
            "suites": [
                "applyEach"
            ],
            "updatePoint": {
                "line": 10,
                "column": 15
            },
            "line": 10,
            "code": "  it('applyEach', done => {\n    var call_order = [];\n\n    var one = function (val, cb) {\n      call_order.push(val);\n      setTimeout(() => {\n        call_order.push('done');\n        cb(null, 1);\n      }, 1);\n    };\n\n    var two = function (val, cb) {\n      call_order.push(val);\n      setTimeout(() => {\n        call_order.push('done');\n        cb(null, 2);\n      }, 2);\n    };\n\n    var three = function (val, cb) {\n      call_order.push(val);\n      setTimeout(() => {\n        call_order.push('done');\n        cb(null, 3);\n      }, 2);\n    };\n\n    async.applyEach([one, two, three], 5)((err, results) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(call_order).to.eql([5, 5, 5, 'done', 'done', 'done']);\n      expect(results).to.eql([1, 2, 3]);\n      done();\n    });\n  });",
            "file": "applyEach.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "applyEach canceled",
            "suites": [
                "applyEach"
            ],
            "updatePoint": {
                "line": 44,
                "column": 24
            },
            "line": 44,
            "code": "  it('applyEach canceled', done => {\n    var call_order = [];\n\n    function one(_, cb) {\n      call_order.push('one');\n      cb(null, 1);\n    }\n\n    function two(_, cb) {\n      call_order.push('two');\n      cb(false);\n    }\n\n    function three() {\n      throw new Error('third task - should not get here');\n    }\n\n    async.applyEach({\n      one,\n      two,\n      three\n    }, 5)(() => {\n      throw new Error('final callback - should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql(['one', 'two']);\n      done();\n    }, 25);\n  });",
            "file": "applyEach.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "applyEachSeries",
            "suites": [
                "applyEach"
            ],
            "updatePoint": {
                "line": 73,
                "column": 21
            },
            "line": 73,
            "code": "  it('applyEachSeries', done => {\n    var call_order = [];\n\n    function one(val, cb) {\n      call_order.push(val);\n      setTimeout(() => {\n        call_order.push('done');\n        cb(null, 1);\n      }, 1);\n    }\n\n    function two(val, cb) {\n      call_order.push(val);\n      setTimeout(() => {\n        call_order.push('done');\n        cb(null, 2);\n      }, 5);\n    }\n\n    function three(val, cb) {\n      call_order.push(val);\n      setTimeout(() => {\n        call_order.push('done');\n        cb(null, 3);\n      }, 1);\n    }\n\n    async.applyEachSeries([one, two, three], 5)((err, results) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(call_order).to.eql([5, 'done', 5, 'done', 5, 'done']);\n      expect(results).to.eql([1, 2, 3]);\n      done();\n    });\n  });",
            "file": "applyEach.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "applyEachSeries canceled",
            "suites": [
                "applyEach"
            ],
            "updatePoint": {
                "line": 107,
                "column": 30
            },
            "line": 107,
            "code": "  it('applyEachSeries canceled', done => {\n    var call_order = [];\n\n    function one(_, cb) {\n      async.setImmediate(() => {\n        call_order.push('one');\n        cb(null, 1);\n      });\n    }\n\n    function two(_, cb) {\n      async.setImmediate(() => {\n        call_order.push('two');\n        cb(false);\n      });\n    }\n\n    function three() {\n      throw new Error('third task - should not get here');\n    }\n\n    async.applyEachSeries([one, two, three], 5)(() => {\n      throw new Error('final callback - should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql(['one', 'two']);\n      done();\n    }, 25);\n  });",
            "file": "applyEach.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not test async functions in this environment",
            "suites": [
                "async function support",
                "awaitable functions"
            ],
            "updatePoint": {
                "line": 41,
                "column": 59
            },
            "line": 41,
            "code": "    it('should not test async functions in this environment');",
            "file": "asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not test async generators in this environment",
            "suites": [
                "async function support",
                "awaitable functions"
            ],
            "updatePoint": {
                "line": 47,
                "column": 60
            },
            "line": 47,
            "code": "    it('should not test async generators in this environment');",
            "file": "asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "asyncify",
            "suites": [
                "asyncify"
            ],
            "updatePoint": {
                "line": 10,
                "column": 14
            },
            "line": 10,
            "code": "  it('asyncify', done => {\n    var parse = async.asyncify(JSON.parse);\n    parse(\"{\\\"a\\\":1}\", (err, result) => {\n      assert(!err);\n      expect(result.a).to.equal(1);\n      done();\n    });\n  });",
            "file": "asyncify.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "asyncify null",
            "suites": [
                "asyncify"
            ],
            "updatePoint": {
                "line": 18,
                "column": 19
            },
            "line": 18,
            "code": "  it('asyncify null', done => {\n    var parse = async.asyncify(() => {\n      return null;\n    });\n    parse(\"{\\\"a\\\":1}\", (err, result) => {\n      assert(!err);\n      expect(result).to.equal(null);\n      done();\n    });\n  });",
            "file": "asyncify.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "variable numbers of arguments",
            "suites": [
                "asyncify"
            ],
            "updatePoint": {
                "line": 28,
                "column": 35
            },
            "line": 28,
            "code": "  it('variable numbers of arguments', done => {\n    const fn = (...args\n    /*x, y, z*/\n    ) => args;\n\n    async.asyncify(fn)(1, 2, 3, (err, result) => {\n      expect(result.length).to.equal(3);\n      expect(result[0]).to.equal(1);\n      expect(result[1]).to.equal(2);\n      expect(result[2]).to.equal(3);\n      done();\n    });\n  });",
            "file": "asyncify.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "catch errors",
            "suites": [
                "asyncify"
            ],
            "updatePoint": {
                "line": 41,
                "column": 18
            },
            "line": 41,
            "code": "  it('catch errors', done => {\n    async.asyncify(() => {\n      throw new Error(\"foo\");\n    })(err => {\n      assert(err);\n      expect(err.message).to.equal(\"foo\");\n      done();\n    });\n  });",
            "file": "asyncify.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "dont catch errors in the callback",
            "suites": [
                "asyncify"
            ],
            "updatePoint": {
                "line": 50,
                "column": 39
            },
            "line": 50,
            "code": "  it('dont catch errors in the callback', done => {\n    try {\n      async.asyncify(() => {})(err => {\n        if (err) {\n          return done(new Error(\"should not get an error here\"));\n        }\n\n        throw new Error(\"callback error\");\n      });\n    } catch (err) {\n      expect(err.message).to.equal(\"callback error\");\n      done();\n    }\n  });",
            "file": "asyncify.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "resolve",
            "suites": [
                "asyncify",
                "promisified"
            ],
            "updatePoint": {
                "line": 66,
                "column": 17
            },
            "line": 66,
            "code": "      it('resolve', done => {\n        var promisified = function (argument) {\n          return new Promise(resolve => {\n            setTimeout(() => {\n              resolve(argument + \" resolved\");\n            }, 15);\n          });\n        };\n\n        async.asyncify(promisified)(\"argument\", (err, value) => {\n          if (err) {\n            return done(new Error(\"should not get an error here\"));\n          }\n\n          expect(value).to.equal(\"argument resolved\");\n          done();\n        });\n      });",
            "file": "asyncify.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reject",
            "suites": [
                "asyncify",
                "promisified"
            ],
            "updatePoint": {
                "line": 84,
                "column": 16
            },
            "line": 84,
            "code": "      it('reject', done => {\n        var promisified = function (argument) {\n          return new Promise((resolve, reject) => {\n            reject(argument + \" rejected\");\n          });\n        };\n\n        async.asyncify(promisified)(\"argument\", err => {\n          assert(err);\n          expect(err.message).to.equal(\"argument rejected\");\n          done();\n        });\n      });",
            "file": "asyncify.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reject without reason",
            "suites": [
                "asyncify",
                "promisified"
            ],
            "updatePoint": {
                "line": 97,
                "column": 31
            },
            "line": 97,
            "code": "      it('reject without reason', done => {\n        var promisified = function () {\n          return new Promise((resolve, reject) => {\n            reject();\n          });\n        };\n\n        async.asyncify(promisified)(\"argument\", err => {\n          assert(err);\n          expect(err.message).to.eql('');\n          done();\n        });\n      });",
            "file": "asyncify.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "callback error @nodeonly",
            "suites": [
                "asyncify",
                "promisified"
            ],
            "updatePoint": {
                "line": 110,
                "column": 34
            },
            "line": 110,
            "code": "      it('callback error @nodeonly', done => {\n        expectUncaughtException();\n\n        var promisified = function (argument) {\n          return new Promise(resolve => {\n            resolve(argument + \" resolved\");\n          });\n        };\n\n        var call_count = 0;\n        async.asyncify(promisified)(\"argument\", () => {\n          call_count++;\n\n          if (call_count === 1) {\n            throw new Error(\"error in callback\");\n          }\n        });\n        setTimeout(() => {\n          expect(call_count).to.equal(1);\n          done();\n        }, 15);\n      });",
            "file": "asyncify.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "dont catch errors in the callback @nodeonly",
            "suites": [
                "asyncify",
                "promisified"
            ],
            "updatePoint": {
                "line": 132,
                "column": 53
            },
            "line": 132,
            "code": "      it('dont catch errors in the callback @nodeonly', done => {\n        expectUncaughtException(checkErr);\n        var callbackError = new Error('thrown from callback');\n\n        function checkErr(err) {\n          expect(err).to.equal(callbackError);\n          done();\n        }\n\n        function callback() {\n          throw callbackError;\n        }\n\n        async.asyncify(() => {\n          return Promise.reject(new Error('rejection'));\n        })(callback);\n      });",
            "file": "asyncify.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basics",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 10,
                "column": 12
            },
            "line": 10,
            "code": "  it('basics', done => {\n    var callOrder = [];\n    async.auto({\n      task1: ['task2', function (results, callback) {\n        setTimeout(() => {\n          callOrder.push('task1');\n          callback();\n        }, 25);\n      }],\n\n      task2(callback) {\n        setTimeout(() => {\n          callOrder.push('task2');\n          callback();\n        }, 50);\n      },\n\n      task3: ['task2', function (results, callback) {\n        callOrder.push('task3');\n        callback();\n      }],\n      task4: ['task1', 'task2', function (results, callback) {\n        callOrder.push('task4');\n        callback();\n      }],\n      task5: ['task2', function (results, callback) {\n        setTimeout(() => {\n          callOrder.push('task5');\n          callback();\n        }, 0);\n      }],\n      task6: ['task2', function (results, callback) {\n        callOrder.push('task6');\n        callback();\n      }]\n    }, err => {\n      expect(err).to.equal(null);\n      expect(callOrder).to.eql(['task2', 'task3', 'task6', 'task5', 'task1', 'task4']);\n      done();\n    });\n  });",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "auto concurrency",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 51,
                "column": 22
            },
            "line": 51,
            "code": "  it('auto concurrency', done => {\n    var concurrency = 2;\n    var runningTasks = [];\n\n    function makeCallback(taskName) {\n      return function (...args\n      /*..., callback*/\n      ) {\n        var callback = _.last(args);\n\n        runningTasks.push(taskName);\n        setTimeout(() => {\n          // Each task returns the array of running tasks as results.\n          var result = runningTasks.slice(0);\n          runningTasks.splice(runningTasks.indexOf(taskName), 1);\n          callback(null, result);\n        });\n      };\n    }\n\n    async.auto({\n      task1: ['task2', makeCallback('task1')],\n      task2: makeCallback('task2'),\n      task3: ['task2', makeCallback('task3')],\n      task4: ['task1', 'task2', makeCallback('task4')],\n      task5: ['task2', makeCallback('task5')],\n      task6: ['task2', makeCallback('task6')]\n    }, concurrency, (err, results) => {\n      Object.values(results).forEach(result => {\n        expect(result.length).to.be.below(concurrency + 1);\n      });\n      done();\n    });\n  });",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "auto petrify",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 85,
                "column": 18
            },
            "line": 85,
            "code": "  it('auto petrify', done => {\n    var callOrder = [];\n    async.auto({\n      task1: ['task2', function (results, callback) {\n        setTimeout(() => {\n          callOrder.push('task1');\n          callback();\n        }, 100);\n      }],\n\n      task2(callback) {\n        setTimeout(() => {\n          callOrder.push('task2');\n          callback();\n        }, 200);\n      },\n\n      task3: ['task2', function (results, callback) {\n        callOrder.push('task3');\n        callback();\n      }],\n      task4: ['task1', 'task2', function (results, callback) {\n        callOrder.push('task4');\n        callback();\n      }]\n    }, err => {\n      if (err) throw err;\n      expect(callOrder).to.eql(['task2', 'task3', 'task1', 'task4']);\n      done();\n    });\n  });",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "auto results",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 116,
                "column": 18
            },
            "line": 116,
            "code": "  it('auto results', done => {\n    var callOrder = [];\n    async.auto({\n      task1: ['task2', function (results, callback) {\n        expect(results.task2).to.eql('task2');\n        setTimeout(() => {\n          callOrder.push('task1');\n          callback(null, 'task1a', 'task1b');\n        }, 25);\n      }],\n\n      task2(callback) {\n        setTimeout(() => {\n          callOrder.push('task2');\n          callback(null, 'task2');\n        }, 50);\n      },\n\n      task3: ['task2', function (results, callback) {\n        expect(results.task2).to.eql('task2');\n        callOrder.push('task3');\n        callback(null);\n      }],\n      task4: ['task1', 'task2', function (results, callback) {\n        expect(results.task1).to.eql(['task1a', 'task1b']);\n        expect(results.task2).to.eql('task2');\n        callOrder.push('task4');\n        callback(null, 'task4');\n      }]\n    }, (err, results) => {\n      expect(callOrder).to.eql(['task2', 'task3', 'task1', 'task4']);\n      expect(results).to.eql({\n        task1: ['task1a', 'task1b'],\n        task2: 'task2',\n        task3: undefined,\n        task4: 'task4'\n      });\n      done();\n    });\n  });",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "auto empty object",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 156,
                "column": 23
            },
            "line": 156,
            "code": "  it('auto empty object', done => {\n    async.auto({}, err => {\n      expect(err).to.equal(null);\n      done();\n    });\n  });",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "auto error",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 162,
                "column": 16
            },
            "line": 162,
            "code": "  it('auto error', done => {\n    async.auto({\n      task1(callback) {\n        callback('testerror');\n      },\n\n      task2: ['task1', function () {\n        throw new Error('task2 should not be called');\n      }],\n\n      task3(callback) {\n        callback('testerror2');\n      }\n\n    }, err => {\n      expect(err).to.equal('testerror');\n    });\n    setTimeout(done, 100);\n  });",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "auto canceled",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 181,
                "column": 19
            },
            "line": 181,
            "code": "  it('auto canceled', done => {\n    const call_order = [];\n    async.auto({\n      task1(callback) {\n        call_order.push(1);\n        callback(false);\n      },\n\n      task2: ['task1', function () {\n        call_order.push(2);\n        throw new Error('task2 should not be called');\n      }],\n\n      task3(callback) {\n        call_order.push(3);\n        callback('testerror2');\n      }\n\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 3]);\n      done();\n    }, 10);\n  });",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not start other tasks when it has been canceled",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 207,
                "column": 58
            },
            "line": 207,
            "code": "  it('does not start other tasks when it has been canceled', done => {\n    const call_order = [];\n    async.auto({\n      task1(callback) {\n        call_order.push(1); // defer calling task2, so task3 has time to stop execution\n\n        async.setImmediate(callback);\n      },\n\n      task2: ['task1', function () {\n        call_order.push(2);\n        throw new Error('task2 should not be called');\n      }],\n\n      task3(callback) {\n        call_order.push(3);\n        callback(false);\n      },\n\n      task4: ['task3', function () {\n        call_order.push(4);\n        throw new Error('task4 should not be called');\n      }]\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 3]);\n      done();\n    }, 25);\n  });",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "auto no callback",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 238,
                "column": 22
            },
            "line": 238,
            "code": "  it('auto no callback', done => {\n    async.auto({\n      task1(callback) {\n        callback();\n      },\n\n      task2: ['task1', function (results, callback) {\n        callback();\n        done();\n      }]\n    });\n  });",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "auto concurrency no callback",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 250,
                "column": 34
            },
            "line": 250,
            "code": "  it('auto concurrency no callback', done => {\n    async.auto({\n      task1(callback) {\n        callback();\n      },\n\n      task2: ['task1', function (results, callback) {\n        callback();\n        done();\n      }]\n    }, 1);\n  });",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "auto error should pass partial results",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 262,
                "column": 44
            },
            "line": 262,
            "code": "  it('auto error should pass partial results', done => {\n    async.auto({\n      task1(callback) {\n        callback(null, 'result1');\n      },\n\n      task2: ['task1', function (results, callback) {\n        callback('testerror', 'result2');\n      }],\n      task3: ['task2', function () {\n        throw new Error('task3 should not be called');\n      }]\n    }, (err, results) => {\n      expect(err).to.equal('testerror');\n      expect(results.task1).to.equal('result1');\n      expect(results.task2).to.equal('result2');\n      done();\n    });\n  }); // Issue 24 on github: https://github.com/caolan/async/issues#issue/24",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "auto removeListener has side effect on loop iteratee",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 283,
                "column": 58
            },
            "line": 283,
            "code": "  it('auto removeListener has side effect on loop iteratee', done => {\n    async.auto({\n      task1: ['task3', function () {\n        done();\n      }],\n      task2: ['task3', function () {\n        /* by design: DON'T call callback */\n      }],\n\n      task3(callback) {\n        callback();\n      }\n\n    });\n  }); // Issue 410 on github: https://github.com/caolan/async/issues/410",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "auto calls callback multiple times",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 299,
                "column": 40
            },
            "line": 299,
            "code": "  it('auto calls callback multiple times', done => {\n    var finalCallCount = 0;\n\n    try {\n      async.auto({\n        task1(callback) {\n          callback(null);\n        },\n\n        task2: ['task1', function (results, callback) {\n          callback(null);\n        }]\n      }, // Error throwing final callback. This should only run once\n      () => {\n        finalCallCount++;\n        var e = new Error('An error');\n        e._test_error = true;\n        throw e;\n      });\n    } catch (e) {\n      if (!e._test_error) {\n        throw e;\n      }\n    }\n\n    setTimeout(() => {\n      expect(finalCallCount).to.equal(1);\n      done();\n    }, 10);\n  });",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "auto calls callback multiple times with parallel functions",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 329,
                "column": 64
            },
            "line": 329,
            "code": "  it('auto calls callback multiple times with parallel functions', done => {\n    async.auto({\n      task1(callback) {\n        setTimeout(callback, 0, 'err');\n      },\n\n      task2(callback) {\n        setTimeout(callback, 0, 'err');\n      }\n\n    }, // Error throwing final callback. This should only run once\n    err => {\n      expect(err).to.equal('err');\n      done();\n    });\n  }); // Issue 462 on github: https://github.com/caolan/async/issues/462",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "auto modifying results causes final callback to run early",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 346,
                "column": 63
            },
            "line": 346,
            "code": "  it('auto modifying results causes final callback to run early', done => {\n    async.auto({\n      task1(callback) {\n        callback(null, 'task1');\n      },\n\n      task2: ['task1', function (results, callback) {\n        results.inserted = true;\n        setTimeout(() => {\n          callback(null, 'task2');\n        }, 50);\n      }],\n\n      task3(callback) {\n        setTimeout(() => {\n          callback(null, 'task3');\n        }, 100);\n      }\n\n    }, (err, results) => {\n      expect(results.inserted).to.equal(true);\n      expect(results.task3).to.equal('task3');\n      done();\n    });\n  }); // Issue 263 on github: https://github.com/caolan/async/issues/263",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "auto prevent dead-locks due to inexistant dependencies",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 372,
                "column": 60
            },
            "line": 372,
            "code": "  it('auto prevent dead-locks due to inexistant dependencies', done => {\n    expect(() => {\n      async.auto({\n        task1: ['noexist', function (results, callback) {\n          callback(null, 'task1');\n        }]\n      });\n    }).to.throw(/dependency `noexist`/);\n    done();\n  }); // Issue 263 on github: https://github.com/caolan/async/issues/263",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "auto prevent dead-locks due to cyclic dependencies",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 383,
                "column": 56
            },
            "line": 383,
            "code": "  it('auto prevent dead-locks due to cyclic dependencies', done => {\n    expect(() => {\n      async.auto({\n        task1: ['task2', function (results, callback) {\n          callback(null, 'task1');\n        }],\n        task2: ['task1', function (results, callback) {\n          callback(null, 'task2');\n        }]\n      });\n    }).to.throw();\n    done();\n  }); // Issue 1092 on github: https://github.com/caolan/async/issues/1092",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "extended cycle detection",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 397,
                "column": 30
            },
            "line": 397,
            "code": "  it('extended cycle detection', done => {\n    var task = function (name) {\n      return function (results, callback) {\n        callback(null, 'task ' + name);\n      };\n    };\n\n    expect(() => {\n      async.auto({\n        a: ['c', task('a')],\n        b: ['a', task('b')],\n        c: ['b', task('c')]\n      });\n    }).to.throw();\n    done();\n  }); // Issue 988 on github: https://github.com/caolan/async/issues/988",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "auto stops running tasks on error",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 414,
                "column": 39
            },
            "line": 414,
            "code": "  it('auto stops running tasks on error', done => {\n    async.auto({\n      task1(callback) {\n        callback('error');\n      },\n\n      task2() {\n        throw new Error('test2 should not be called');\n      }\n\n    }, 1, error => {\n      expect(error).to.equal('error');\n      done();\n    });\n  });",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "ignores results after an error",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 429,
                "column": 36
            },
            "line": 429,
            "code": "  it('ignores results after an error', done => {\n    async.auto({\n      task1(cb) {\n        setTimeout(cb, 25, 'error');\n      },\n\n      task2(cb) {\n        setTimeout(cb, 30, null);\n      },\n\n      task3: ['task2', function () {\n        throw new Error(\"task should not have been called\");\n      }]\n    }, err => {\n      expect(err).to.equal('error');\n      setTimeout(done, 25, null);\n    });\n  });",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not allow calling callbacks twice",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 447,
                "column": 44
            },
            "line": 447,
            "code": "  it(\"does not allow calling callbacks twice\", () => {\n    expect(() => {\n      async.auto({\n        bad(cb) {\n          cb();\n          cb();\n        }\n\n      }, () => {});\n    }).to.throw();\n  });",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle array tasks with just a function",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 458,
                "column": 52
            },
            "line": 458,
            "code": "  it('should handle array tasks with just a function', done => {\n    async.auto({\n      a: [function (cb) {\n        cb(null, 1);\n      }],\n      b: [\"a\", function (results, cb) {\n        expect(results.a).to.equal(1);\n        cb();\n      }]\n    }, done);\n  });",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should avoid unncecessary deferrals",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 469,
                "column": 41
            },
            "line": 469,
            "code": "  it(\"should avoid unncecessary deferrals\", done => {\n    var isSync = true;\n    async.auto({\n      step1(cb) {\n        cb(null, 1);\n      },\n\n      step2: [\"step1\", function (results, cb) {\n        cb();\n      }]\n    }, () => {\n      expect(isSync).to.equal(true);\n      done();\n    });\n    isSync = false;\n  }); // Issue 1358 on github: https://github.com/caolan/async/issues/1358",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should report errors when a task name is an array method",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 486,
                "column": 62
            },
            "line": 486,
            "code": "  it('should report errors when a task name is an array method', done => {\n    async.auto({\n      'one'(next) {\n        next('Something bad happened here');\n      },\n\n      'filter'(next) {\n        setTimeout(() => {\n          next(null, 'All fine here though');\n        }, 25);\n      },\n\n      'finally': ['one', 'filter', function (a, next) {\n        _.defer(next);\n      }]\n    }, err => {\n      expect(err).to.equal('Something bad happened here');\n      setTimeout(done, 30);\n    });\n  });",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should report errors when a task name is an obj prototype method",
            "suites": [
                "auto"
            ],
            "updatePoint": {
                "line": 506,
                "column": 70
            },
            "line": 506,
            "code": "  it('should report errors when a task name is an obj prototype method', done => {\n    async.auto({\n      'one'(next) {\n        next('Something bad happened here');\n      },\n\n      'hasOwnProperty'(next) {\n        setTimeout(() => {\n          next(null, 'All fine here though');\n        }, 25);\n      },\n\n      'finally': ['one', 'hasOwnProperty', function (a, next) {\n        _.defer(next);\n      }]\n    }, err => {\n      expect(err).to.equal('Something bad happened here');\n      setTimeout(done, 30);\n    });\n  });",
            "file": "auto.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basics",
            "suites": [
                "autoInject"
            ],
            "updatePoint": {
                "line": 9,
                "column": 12
            },
            "line": 9,
            "code": "  it(\"basics\", done => {\n    var callOrder = [];\n    async.autoInject({\n      task1(task2, callback) {\n        expect(task2).to.equal(2);\n        setTimeout(() => {\n          callOrder.push('task1');\n          callback(null, 1);\n        }, 25);\n      },\n\n      task2(callback) {\n        setTimeout(() => {\n          callOrder.push('task2');\n          callback(null, 2);\n        }, 50);\n      },\n\n      task3: function (task2, callback) {\n        expect(task2).to.equal(2);\n        callOrder.push('task3');\n        callback(null, 3);\n      },\n      task4: function task4(task1, task2, callback) {\n        expect(task1).to.equal(1);\n        expect(task2).to.equal(2);\n        callOrder.push('task4');\n        callback(null, 4);\n      },\n\n      task5(task2, callback) {\n        expect(task2).to.equal(2);\n        setTimeout(() => {\n          callOrder.push('task5');\n          callback(null, 5);\n        }, 0);\n      },\n\n      task6(task2, callback) {\n        expect(task2).to.equal(2);\n        callOrder.push('task6');\n        callback(null, 6);\n      }\n\n    }, (err, results) => {\n      expect(results).to.eql({\n        task1: 1,\n        task2: 2,\n        task3: 3,\n        task4: 4,\n        task5: 5,\n        task6: 6\n      });\n      expect(results.task6).to.equal(6);\n      expect(callOrder).to.eql(['task2', 'task3', 'task6', 'task5', 'task1', 'task4']);\n      done();\n    });\n  });",
            "file": "autoInject.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should work with array tasks",
            "suites": [
                "autoInject"
            ],
            "updatePoint": {
                "line": 67,
                "column": 34
            },
            "line": 67,
            "code": "  it('should work with array tasks', done => {\n    var callOrder = [];\n    async.autoInject({\n      task1(cb) {\n        callOrder.push('task1');\n        cb(null, 1);\n      },\n\n      task2: ['task3', function (task3, cb) {\n        expect(task3).to.equal(3);\n        callOrder.push('task2');\n        cb(null, 2);\n      }],\n\n      task3(cb) {\n        callOrder.push('task3');\n        cb(null, 3);\n      }\n\n    }, (err, results) => {\n      expect(results).to.eql({\n        task1: 1,\n        task2: 2,\n        task3: 3\n      });\n      expect(callOrder).to.eql(['task1', 'task3', 'task2']);\n      done();\n    });\n  });",
            "file": "autoInject.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle array tasks with just a function",
            "suites": [
                "autoInject"
            ],
            "updatePoint": {
                "line": 96,
                "column": 52
            },
            "line": 96,
            "code": "  it('should handle array tasks with just a function', done => {\n    async.autoInject({\n      a: [function (cb) {\n        cb(null, 1);\n      }],\n      b: [\"a\", function (a, cb) {\n        expect(a).to.equal(1);\n        cb();\n      }]\n    }, done);\n  });",
            "file": "autoInject.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should throw error for function without explicit parameters",
            "suites": [
                "autoInject"
            ],
            "updatePoint": {
                "line": 107,
                "column": 65
            },
            "line": 107,
            "code": "  it('should throw error for function without explicit parameters', () => {\n    expect(() => async.autoInject({\n      a() {}\n\n    })).to.throw();\n  });",
            "file": "autoInject.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should work with es6 arrow syntax",
            "suites": [
                "autoInject"
            ],
            "updatePoint": {
                "line": 113,
                "column": 39
            },
            "line": 113,
            "code": "  it('should work with es6 arrow syntax', done => {\n    async.autoInject({\n      task1: cb => cb(null, 1),\n      task2: (task3, cb) => cb(null, 2),\n      task3: cb => cb(null, 3)\n    }, (err, results) => {\n      expect(results.task1).to.equal(1);\n      expect(results.task3).to.equal(3);\n      done();\n    });\n  });",
            "file": "autoInject.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should work with es6 default param syntax",
            "suites": [
                "autoInject"
            ],
            "updatePoint": {
                "line": 124,
                "column": 47
            },
            "line": 124,
            "code": "  it('should work with es6 default param syntax', done => {\n    async.autoInject({\n      task1(cb) {\n        cb(null, 1);\n      },\n\n      task2(task3, cb) {\n        cb(null, 2);\n      },\n\n      task3(cb) {\n        cb(null, 3);\n      },\n\n      task4(task2, cb) {\n        cb(null);\n      },\n\n      task5(task4 = 4, cb) {\n        cb(null, task4 + 1);\n      }\n\n    }, (err, results) => {\n      expect(results.task1).to.equal(1);\n      expect(results.task3).to.equal(3);\n      expect(results.task4).to.equal(undefined);\n      expect(results.task5).to.equal(5);\n      done();\n    });\n  });",
            "file": "autoInject.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should be cancelable",
            "suites": [
                "autoInject"
            ],
            "updatePoint": {
                "line": 154,
                "column": 26
            },
            "line": 154,
            "code": "  it('should be cancelable', done => {\n    var call_order = [];\n    async.autoInject({\n      task1(cb) {\n        call_order.push('task1');\n        cb(null, 1);\n      },\n\n      task2(task3, cb) {\n        call_order.push('task2');\n        cb(null, 2);\n      },\n\n      task3(cb) {\n        call_order.push('task3');\n        cb(false);\n      }\n\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql(['task1', 'task3']);\n      done();\n    }, 25);\n  });",
            "file": "autoInject.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should work with complicated functions",
            "suites": [
                "autoInject"
            ],
            "updatePoint": {
                "line": 180,
                "column": 44
            },
            "line": 180,
            "code": "  it('should work with complicated functions', done => {\n    async.autoInject({\n      one: cb => cb(null, 1),\n      two: cb => cb(null, 2),\n      three: cb => cb(null, 3),\n      result: (one, two, three, cb) => {\n        if (!one || !two || !three) {\n          return cb('fail');\n        }\n\n        function add(a, b, c) {\n          return a + b + c;\n        }\n\n        add(one, two, three);\n        cb(null, 1 + 2 + 3);\n      }\n    }, (err, results) => {\n      expect(results).to.eql({\n        one: 1,\n        two: 2,\n        three: 3,\n        result: 6\n      });\n      done();\n    });\n  });",
            "file": "autoInject.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should work with functions with args on multiple lines",
            "suites": [
                "autoInject"
            ],
            "updatePoint": {
                "line": 207,
                "column": 60
            },
            "line": 207,
            "code": "  it('should work with functions with args on multiple lines', done => {\n    async.autoInject({\n      one: cb => cb(null, 1),\n      two: cb => cb(null, 2),\n      three: cb => cb(null, 3),\n      result: function (one, two, three, cb) {\n        cb(null, 1 + 2 + 3);\n      }\n    }, (err, results) => {\n      expect(results).to.eql({\n        one: 1,\n        two: 2,\n        three: 3,\n        result: 6\n      });\n      done();\n    });\n  });",
            "file": "autoInject.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should work with methods with args on multiple lines",
            "suites": [
                "autoInject"
            ],
            "updatePoint": {
                "line": 225,
                "column": 58
            },
            "line": 225,
            "code": "  it('should work with methods with args on multiple lines', done => {\n    async.autoInject({\n      one: cb => cb(null, 1),\n      two: cb => cb(null, 2),\n      three: cb => cb(null, 3),\n\n      result(one, two, three, cb) {\n        cb(null, 1 + 2 + 3);\n      }\n\n    }, (err, results) => {\n      expect(results).to.eql({\n        one: 1,\n        two: 2,\n        three: 3,\n        result: 6\n      });\n      done();\n    });\n  });",
            "file": "autoInject.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should work with arrow functions with args on multiple lines",
            "suites": [
                "autoInject"
            ],
            "updatePoint": {
                "line": 245,
                "column": 66
            },
            "line": 245,
            "code": "  it('should work with arrow functions with args on multiple lines', done => {\n    async.autoInject({\n      one: cb => cb(null, 1),\n      two: cb => cb(null, 2),\n      three: cb => cb(null, 3),\n      result: (one, two, three, cb) => cb(null, 1 + 2 + 3)\n    }, (err, results) => {\n      expect(results).to.eql({\n        one: 1,\n        two: 2,\n        three: 3,\n        result: 6\n      });\n      done();\n    });\n  });",
            "file": "autoInject.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not be subject to ReDoS",
            "suites": [
                "autoInject"
            ],
            "updatePoint": {
                "line": 261,
                "column": 36
            },
            "line": 261,
            "code": "  it('should not be subject to ReDoS', () => {\n    // This test will timeout if the bug is present.\n    var someComments = 'text/*'.repeat(1000000);\n    expect(() => async.autoInject({\n      someComments,\n\n      a() {}\n\n    })).to.throw();\n  });",
            "file": "autoInject.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should properly strip comments in argument definitions",
            "suites": [
                "autoInject"
            ],
            "updatePoint": {
                "line": 271,
                "column": 60
            },
            "line": 271,
            "code": "  it('should properly strip comments in argument definitions', done => {\n    async.autoInject({\n      task1: function (task2,\n      /* ) */\n      callback) {\n        callback(null, true);\n      },\n      task2: function task2(task3 // )\n      , callback) {\n        callback(null, true);\n      },\n      task3: function task3(callback) {\n        callback(null, true);\n      }\n    }, (err, result) => {\n      expect(err).to.eql(null);\n      expect(result).to.deep.eql({\n        task1: true,\n        task2: true,\n        task3: true\n      });\n      done();\n    });\n  });",
            "file": "autoInject.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "cargo",
            "suites": [
                "cargo"
            ],
            "updatePoint": {
                "line": 10,
                "column": 11
            },
            "line": 10,
            "code": "  it('cargo', done => {\n    var call_order = [],\n        delays = [40, 40, 20]; // worker: --12--34--5-\n    // order of completion: 1,2,3,4,5\n\n    var c = async.cargo((tasks, callback) => {\n      setTimeout(() => {\n        call_order.push('process ' + tasks.join(' '));\n        callback('error', 'arg');\n      }, delays.shift());\n    }, 2);\n    c.push(1, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(c.length()).to.equal(3);\n      call_order.push('callback ' + 1);\n    });\n    c.push(2, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(c.length()).to.equal(3);\n      call_order.push('callback ' + 2);\n    });\n    expect(c.length()).to.equal(2); // async push\n\n    setTimeout(() => {\n      c.push(3, (err, arg) => {\n        expect(err).to.equal('error');\n        expect(arg).to.equal('arg');\n        expect(c.length()).to.equal(1);\n        call_order.push('callback ' + 3);\n      });\n    }, 15);\n    setTimeout(() => {\n      c.push(4, (err, arg) => {\n        expect(err).to.equal('error');\n        expect(arg).to.equal('arg');\n        expect(c.length()).to.equal(1);\n        call_order.push('callback ' + 4);\n      });\n      expect(c.length()).to.equal(2);\n      c.push(5, (err, arg) => {\n        expect(err).to.equal('error');\n        expect(arg).to.equal('arg');\n        expect(c.length()).to.equal(0);\n        call_order.push('callback ' + 5);\n      });\n    }, 30);\n    c.drain(() => {\n      expect(call_order).to.eql(['process 1 2', 'callback 1', 'callback 2', 'process 3 4', 'callback 3', 'callback 4', 'process 5', 'callback 5']);\n      expect(c.length()).to.equal(0);\n      done();\n    });\n  });",
            "file": "cargo.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "without callback",
            "suites": [
                "cargo"
            ],
            "updatePoint": {
                "line": 64,
                "column": 22
            },
            "line": 64,
            "code": "  it('without callback', done => {\n    var call_order = [],\n        delays = [40, 60, 60, 20]; // worker: --1-2---34-5-\n    // order of completion: 1,2,3,4,5\n\n    var c = async.cargo((tasks, callback) => {\n      setTimeout(() => {\n        call_order.push('process ' + tasks.join(' '));\n        callback('error', 'arg');\n      }, delays.shift());\n    }, 2);\n    c.push(1);\n    setTimeout(() => {\n      c.push(2);\n    }, 20);\n    setTimeout(() => {\n      c.push(3);\n      c.push(4);\n      c.push(5);\n    }, 80);\n    c.drain(() => {\n      expect(call_order).to.eql(['process 1', 'process 2', 'process 3 4', 'process 5']);\n      done();\n    });\n  });",
            "file": "cargo.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "bulk task",
            "suites": [
                "cargo"
            ],
            "updatePoint": {
                "line": 89,
                "column": 15
            },
            "line": 89,
            "code": "  it('bulk task', done => {\n    var call_order = [],\n        delays = [30, 20]; // worker: -123-4-\n    // order of completion: 1,2,3,4\n\n    var c = async.cargo((tasks, callback) => {\n      setTimeout(() => {\n        call_order.push('process ' + tasks.join(' '));\n        callback('error', tasks.join(' '));\n      }, delays.shift());\n    }, 3);\n    c.push([1, 2, 3, 4], (err, arg) => {\n      expect(err).to.equal('error');\n      call_order.push('callback ' + arg);\n    });\n    expect(c.length()).to.equal(4);\n    setTimeout(() => {\n      expect(call_order).to.eql(['process 1 2 3', 'callback 1 2 3', 'callback 1 2 3', 'callback 1 2 3', 'process 4', 'callback 4']);\n      expect(c.length()).to.equal(0);\n      done();\n    }, 200);\n  });",
            "file": "cargo.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "drain once",
            "suites": [
                "cargo"
            ],
            "updatePoint": {
                "line": 111,
                "column": 16
            },
            "line": 111,
            "code": "  it('drain once', done => {\n    var c = async.cargo((tasks, callback) => {\n      callback();\n    }, 3);\n    var drainCounter = 0;\n    c.drain(() => {\n      drainCounter++;\n    });\n\n    for (var i = 0; i < 10; i++) {\n      c.push(i);\n    }\n\n    setTimeout(() => {\n      expect(drainCounter).to.equal(1);\n      done();\n    }, 50);\n  });",
            "file": "cargo.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "drain twice",
            "suites": [
                "cargo"
            ],
            "updatePoint": {
                "line": 129,
                "column": 17
            },
            "line": 129,
            "code": "  it('drain twice', done => {\n    var c = async.cargo((tasks, callback) => {\n      callback();\n    }, 3);\n\n    function loadCargo() {\n      for (var i = 0; i < 10; i++) {\n        c.push(i);\n      }\n    }\n\n    var drainCounter = 0;\n    c.drain(() => {\n      drainCounter++;\n\n      if (drainCounter === 1) {\n        loadCargo();\n      } else {\n        expect(drainCounter).to.equal(2);\n        done();\n      }\n    });\n    loadCargo();\n  });",
            "file": "cargo.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "events",
            "suites": [
                "cargo"
            ],
            "updatePoint": {
                "line": 153,
                "column": 12
            },
            "line": 153,
            "code": "  it('events', done => {\n    var calls = [];\n    var q = async.cargo((task, cb) => {\n      // nop\n      calls.push('process ' + task);\n      async.setImmediate(cb);\n    }, 1);\n    q.concurrency = 3;\n    q.saturated(() => {\n      assert(q.running() == 3, 'cargo should be saturated now');\n      calls.push('saturated');\n    });\n    q.empty(() => {\n      assert(q.length() === 0, 'cargo should be empty now');\n      calls.push('empty');\n    });\n    q.drain(() => {\n      assert(q.length() === 0 && q.running() === 0, 'cargo should be empty now and no more workers should be running');\n      calls.push('drain');\n      expect(calls).to.eql(['process foo', 'process bar', 'saturated', 'process zoo', 'foo cb', 'saturated', 'process poo', 'bar cb', 'empty', 'saturated', 'process moo', 'zoo cb', 'poo cb', 'moo cb', 'drain']);\n      done();\n    });\n    q.push('foo', () => {\n      calls.push('foo cb');\n    });\n    q.push('bar', () => {\n      calls.push('bar cb');\n    });\n    q.push('zoo', () => {\n      calls.push('zoo cb');\n    });\n    q.push('poo', () => {\n      calls.push('poo cb');\n    });\n    q.push('moo', () => {\n      calls.push('moo cb');\n    });\n  });",
            "file": "cargo.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "expose payload",
            "suites": [
                "cargo"
            ],
            "updatePoint": {
                "line": 191,
                "column": 20
            },
            "line": 191,
            "code": "  it('expose payload', done => {\n    var called_once = false;\n    var cargo = async.cargo((tasks, cb) => {\n      if (!called_once) {\n        expect(cargo.payload).to.equal(1);\n        assert(tasks.length === 1, 'should start with payload = 1');\n      } else {\n        expect(cargo.payload).to.equal(2);\n        assert(tasks.length === 2, 'next call shold have payload = 2');\n      }\n\n      called_once = true;\n      setTimeout(cb, 25);\n    }, 1);\n    cargo.drain(done);\n    expect(cargo.payload).to.equal(1);\n    cargo.push([1, 2, 3]);\n    setTimeout(() => {\n      cargo.payload = 2;\n    }, 15);\n  });",
            "file": "cargo.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "workersList",
            "suites": [
                "cargo"
            ],
            "updatePoint": {
                "line": 212,
                "column": 17
            },
            "line": 212,
            "code": "  it('workersList', done => {\n    var called_once = false;\n\n    function getWorkersListData(cargo) {\n      return cargo.workersList().map(v => {\n        return v.data;\n      });\n    }\n\n    var cargo = async.cargo((tasks, cb) => {\n      if (!called_once) {\n        expect(tasks).to.eql(['foo', 'bar']);\n      } else {\n        expect(tasks).to.eql(['baz']);\n      }\n\n      expect(getWorkersListData(cargo)).to.eql(tasks);\n      async.setImmediate(() => {\n        // ensure nothing has changed\n        expect(getWorkersListData(cargo)).to.eql(tasks);\n        called_once = true;\n        cb();\n      });\n    }, 2);\n    cargo.drain(() => {\n      expect(cargo.workersList()).to.eql([]);\n      expect(cargo.running()).to.equal(0);\n      done();\n    });\n    cargo.push('foo');\n    cargo.push('bar');\n    cargo.push('baz');\n  });",
            "file": "cargo.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "running",
            "suites": [
                "cargo"
            ],
            "updatePoint": {
                "line": 245,
                "column": 13
            },
            "line": 245,
            "code": "  it('running', done => {\n    var cargo = async.cargo((tasks, cb) => {\n      expect(cargo.running()).to.equal(1);\n      async.setImmediate(() => {\n        expect(cargo.running()).to.equal(1);\n        cb();\n      });\n    }, 2);\n    cargo.drain(() => {\n      expect(cargo.running()).to.equal(0);\n      done();\n    });\n    cargo.push('foo');\n    cargo.push('bar');\n    cargo.push('baz');\n  });",
            "file": "cargo.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "cargoQueue",
            "suites": [
                "cargoQueue"
            ],
            "updatePoint": {
                "line": 15,
                "column": 16
            },
            "line": 15,
            "code": "  it('cargoQueue', done => {\n    var call_order = [],\n        delays = [50, 50, 50]; // worker: --12--34--5-\n    // order of completion: 1,2,3,4,5\n\n    var c = async.cargoQueue((tasks, callback) => {\n      if (tasks[0] === 1) {\n        c.push(3, (err, arg) => {\n          expect(err).to.equal('error');\n          expect(arg).to.equal('arg');\n          expect(c.length()).to.equal(0);\n          call_order.push('callback ' + 3);\n        });\n      } else if (tasks[0] === 3) {\n        c.push(4, (err, arg) => {\n          expect(err).to.equal('error');\n          expect(arg).to.equal('arg');\n          expect(c.length()).to.equal(0);\n          call_order.push('callback ' + 4);\n        });\n        expect(c.length()).to.equal(1);\n        c.push(5, (err, arg) => {\n          expect(err).to.equal('error');\n          expect(arg).to.equal('arg');\n          expect(c.length()).to.equal(0);\n          call_order.push('callback ' + 5);\n        });\n      }\n\n      setTimeout(() => {\n        call_order.push('process ' + tasks.join(' '));\n        callback('error', 'arg');\n      }, delays.shift());\n    }, 2, 2);\n    c.push(1, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(c.length()).to.equal(2);\n      call_order.push('callback ' + 1);\n    });\n    c.push(2, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(c.length()).to.equal(2);\n      call_order.push('callback ' + 2);\n    });\n    expect(c.length()).to.equal(2);\n    c.drain(() => {\n      expect(call_order).to.eql(['process 1 2', 'callback 1', 'callback 2', 'process 3', 'callback 3', 'process 4 5', 'callback 4', 'callback 5']);\n      expect(c.length()).to.equal(0);\n      done();\n    });\n  });",
            "file": "cargoQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "without callback",
            "suites": [
                "cargoQueue"
            ],
            "updatePoint": {
                "line": 68,
                "column": 22
            },
            "line": 68,
            "code": "  it('without callback', done => {\n    var call_order = [];\n    var c = async.cargoQueue(worker.bind({\n      call_order\n    }), 2, 2);\n    c.push(1);\n    async.setImmediate(() => {\n      c.push(2);\n      async.setImmediate(() => {\n        c.push(3);\n        c.push(4);\n        async.setImmediate(() => {\n          c.push(5);\n          c.drain(() => {\n            expect(call_order).to.eql(['process 1', 'process 2', 'process 3 4', 'process 5']);\n            done();\n          });\n        });\n      });\n    });\n  });",
            "file": "cargoQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "bulk task",
            "suites": [
                "cargoQueue"
            ],
            "updatePoint": {
                "line": 89,
                "column": 15
            },
            "line": 89,
            "code": "  it('bulk task', done => {\n    var call_order = [],\n        delays = [20, 30]; // worker: -123-4-\n    // order of completion: 1,2,3,4\n\n    var c = async.cargoQueue((tasks, callback) => {\n      setTimeout(() => {\n        call_order.push('process ' + tasks.join(' '));\n        callback('error', tasks.join(' '));\n      }, delays.shift());\n    }, 3, 2);\n    c.push([1, 2, 3, 4], (err, arg) => {\n      expect(err).to.equal('error');\n      call_order.push('callback ' + arg);\n    });\n    expect(c.length()).to.equal(4);\n    setTimeout(() => {\n      expect(call_order).to.eql(['process 1 2', 'callback 1 2', 'callback 1 2', 'process 3 4', 'callback 3 4', 'callback 3 4']);\n      expect(c.length()).to.equal(0);\n      done();\n    }, 200);\n  });",
            "file": "cargoQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "drain once",
            "suites": [
                "cargoQueue"
            ],
            "updatePoint": {
                "line": 111,
                "column": 16
            },
            "line": 111,
            "code": "  it('drain once', done => {\n    var c = async.cargoQueue((tasks, callback) => {\n      callback();\n    }, 3, 2);\n    var drainCounter = 0;\n    c.drain(() => {\n      drainCounter++;\n    });\n\n    for (var i = 0; i < 10; i++) {\n      c.push(i);\n    }\n\n    setTimeout(() => {\n      expect(drainCounter).to.equal(1);\n      done();\n    }, 50);\n  });",
            "file": "cargoQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "drain twice",
            "suites": [
                "cargoQueue"
            ],
            "updatePoint": {
                "line": 129,
                "column": 17
            },
            "line": 129,
            "code": "  it('drain twice', done => {\n    var c = async.cargoQueue((tasks, callback) => {\n      callback();\n    }, 3, 2);\n\n    function loadCargo() {\n      for (var i = 0; i < 10; i++) {\n        c.push(i);\n      }\n    }\n\n    var drainCounter = 0;\n    c.drain(() => {\n      drainCounter++;\n\n      if (drainCounter === 1) {\n        loadCargo();\n      } else {\n        expect(drainCounter).to.equal(2);\n        done();\n      }\n    });\n    loadCargo();\n  });",
            "file": "cargoQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "events",
            "suites": [
                "cargoQueue"
            ],
            "updatePoint": {
                "line": 153,
                "column": 12
            },
            "line": 153,
            "code": "  it('events', done => {\n    var calls = [];\n    var q = async.cargoQueue((task, cb) => {\n      // nop\n      calls.push('process ' + task);\n      async.setImmediate(cb);\n    }, 3, 1);\n    q.saturated(() => {\n      assert(q.running() == 3, 'cargoQueue should be saturated now');\n      calls.push('saturated');\n    });\n    q.empty(() => {\n      assert(q.length() === 0, 'cargoQueue should be empty now');\n      calls.push('empty');\n    });\n    q.drain(() => {\n      assert(q.length() === 0 && q.running() === 0, 'cargoQueue should be empty now and no more workers should be running');\n      calls.push('drain');\n      expect(calls).to.eql(['process foo', 'process bar', 'saturated', 'process zoo', 'foo cb', 'saturated', 'process poo', 'bar cb', 'empty', 'saturated', 'process moo', 'zoo cb', 'poo cb', 'moo cb', 'drain']);\n      done();\n    });\n    q.push('foo', () => {\n      calls.push('foo cb');\n    });\n    q.push('bar', () => {\n      calls.push('bar cb');\n    });\n    q.push('zoo', () => {\n      calls.push('zoo cb');\n    });\n    q.push('poo', () => {\n      calls.push('poo cb');\n    });\n    q.push('moo', () => {\n      calls.push('moo cb');\n    });\n  });",
            "file": "cargoQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "expose payload",
            "suites": [
                "cargoQueue"
            ],
            "updatePoint": {
                "line": 190,
                "column": 20
            },
            "line": 190,
            "code": "  it('expose payload', done => {\n    var called_once = false;\n    var cargo = async.cargoQueue((tasks, cb) => {\n      if (!called_once) {\n        expect(cargo.payload).to.equal(1);\n        assert(tasks.length === 1, 'should start with payload = 1');\n      } else {\n        expect(cargo.payload).to.equal(2);\n        assert(tasks.length === 2, 'next call shold have payload = 2');\n      }\n\n      called_once = true;\n      setTimeout(cb, 25);\n    }, 1, 1);\n    cargo.drain(done);\n    expect(cargo.payload).to.equal(1);\n    cargo.push([1, 2, 3]);\n    setTimeout(() => {\n      cargo.payload = 2;\n    }, 15);\n  });",
            "file": "cargoQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "expose concurrency",
            "suites": [
                "cargoQueue"
            ],
            "updatePoint": {
                "line": 211,
                "column": 24
            },
            "line": 211,
            "code": "  it('expose concurrency', done => {\n    var called_once = false;\n    var cargo = async.cargoQueue((tasks, cb) => {\n      if (!called_once) {\n        expect(cargo.concurrency).to.equal(1);\n      } else {\n        expect(cargo.concurrency).to.equal(2);\n      }\n\n      called_once = true;\n      setTimeout(cb, 25);\n    }, 1, 1);\n    cargo.drain(done);\n    expect(cargo.concurrency).to.equal(1);\n    cargo.push([1, 2, 3]);\n    setTimeout(() => {\n      cargo.concurrency = 2;\n    }, 15);\n  });",
            "file": "cargoQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "workersList",
            "suites": [
                "cargoQueue"
            ],
            "updatePoint": {
                "line": 230,
                "column": 17
            },
            "line": 230,
            "code": "  it('workersList', done => {\n    var called_once = false;\n\n    function getWorkersListData(cargo) {\n      return cargo.workersList().map(v => {\n        return v.data;\n      });\n    }\n\n    var cargo = async.cargoQueue((tasks, cb) => {\n      if (!called_once) {\n        expect(tasks).to.eql(['foo', 'bar']);\n      } else {\n        expect(tasks).to.eql(['baz']);\n      }\n\n      expect(getWorkersListData(cargo)).to.eql(tasks);\n      async.setImmediate(() => {\n        // ensure nothing has changed\n        expect(getWorkersListData(cargo)).to.eql(tasks);\n        called_once = true;\n        cb();\n      });\n    }, 1, 2);\n    cargo.drain(() => {\n      expect(cargo.workersList()).to.eql([]);\n      expect(cargo.running()).to.equal(0);\n      done();\n    });\n    cargo.push('foo');\n    cargo.push('bar');\n    cargo.push('baz');\n  });",
            "file": "cargoQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "running",
            "suites": [
                "cargoQueue"
            ],
            "updatePoint": {
                "line": 263,
                "column": 13
            },
            "line": 263,
            "code": "  it('running', done => {\n    var cargo = async.cargoQueue((tasks, cb) => {\n      expect(cargo.running()).to.equal(1);\n      async.setImmediate(() => {\n        expect(cargo.running()).to.equal(1);\n        cb();\n      });\n    }, 1, 1);\n    cargo.drain(() => {\n      expect(cargo.running()).to.equal(0);\n      done();\n    });\n    cargo.push(['foo', 'bar', 'baz', 'boo']);\n  });",
            "file": "cargoQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "yields the result of the composition of the functions",
            "suites": [
                "compose",
                "all functions succeed"
            ],
            "updatePoint": {
                "line": 9,
                "column": 61
            },
            "line": 9,
            "code": "    it('yields the result of the composition of the functions', done => {\n      var add2 = function (n, cb) {\n        setTimeout(() => {\n          cb(null, n + 2);\n        });\n      };\n\n      var mul3 = function (n, cb) {\n        setTimeout(() => {\n          cb(null, n * 3);\n        });\n      };\n\n      var add1 = function (n, cb) {\n        setTimeout(() => {\n          cb(null, n + 1);\n        });\n      };\n\n      var add2mul3add1 = async.compose(add1, mul3, add2);\n      add2mul3add1(3, (err, result) => {\n        expect(err).to.not.exist;\n        expect(result).to.eql(16);\n        done();\n      });\n    });",
            "file": "compose.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "yields the error and does not call later functions",
            "suites": [
                "compose",
                "a function errors"
            ],
            "updatePoint": {
                "line": 37,
                "column": 58
            },
            "line": 37,
            "code": "    it('yields the error and does not call later functions', done => {\n      var add1called = false;\n      var mul3error = new Error('mul3 error');\n\n      var add2 = function (n, cb) {\n        setTimeout(() => {\n          cb(null, n + 2);\n        });\n      };\n\n      var mul3 = function (n, cb) {\n        setTimeout(() => {\n          cb(mul3error);\n        });\n      };\n\n      var add1 = function (n, cb) {\n        add1called = true;\n        setTimeout(() => {\n          cb(null, n + 1);\n        });\n      };\n\n      var add2mul3add1 = async.compose(add1, mul3, add2);\n      add2mul3add1(3, (err, result) => {\n        expect(err).to.eql(mul3error);\n        expect(result).to.not.exist;\n        expect(add1called).to.be.false;\n        done();\n      });\n    });",
            "file": "compose.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "calls each function with the binding of the composed function",
            "suites": [
                "compose",
                "a function errors"
            ],
            "updatePoint": {
                "line": 69,
                "column": 67
            },
            "line": 69,
            "code": "  it('calls each function with the binding of the composed function', done => {\n    var context = {};\n    var add2Context = null;\n    var mul3Context = null;\n\n    var add2 = function (n, cb) {\n      add2Context = this;\n      setTimeout(() => {\n        cb(null, n + 2);\n      });\n    };\n\n    var mul3 = function (n, cb) {\n      mul3Context = this;\n      setTimeout(() => {\n        cb(null, n * 3);\n      });\n    };\n\n    var add2mul3 = async.compose(mul3, add2);\n    add2mul3.call(context, 3, (err, result) => {\n      expect(err).to.not.exist;\n      expect(result).to.eql(15);\n      expect(add2Context).to.equal(context);\n      expect(mul3Context).to.equal(context);\n      done();\n    });\n  });",
            "file": "compose.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should be cancelable",
            "suites": [
                "compose",
                "a function errors"
            ],
            "updatePoint": {
                "line": 97,
                "column": 26
            },
            "line": 97,
            "code": "  it('should be cancelable', done => {\n    var call_order = [];\n\n    var add2 = function (n, cb) {\n      call_order.push('add2');\n      cb(null, n + 2);\n    };\n\n    var mul3 = function (n, cb) {\n      call_order.push('mul3');\n      cb(false, n * 3);\n    };\n\n    var add1 = function () {\n      throw new Error('add1 - should not get here');\n    };\n\n    var add2mul3add1 = async.compose(add1, mul3, add2);\n    add2mul3add1(3, () => {\n      throw new Error('final callback - should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql(['add2', 'mul3']);\n      done();\n    }, 25);\n  });",
            "file": "compose.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basics",
            "suites": [
                "concat",
                "concat"
            ],
            "updatePoint": {
                "line": 20,
                "column": 14
            },
            "line": 20,
            "code": "    it('basics', function (done) {\n      var callOrder = [];\n      async.concat([1, 3, 2], concatIteratee.bind(this, callOrder), (err, result) => {\n        expect(err).to.eql(null);\n        expect(callOrder).to.eql([1, 2, 3]);\n        expect(result).to.eql([1, 2, 3, 4, 2, 3]);\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "error",
            "suites": [
                "concat",
                "concat"
            ],
            "updatePoint": {
                "line": 29,
                "column": 13
            },
            "line": 29,
            "code": "    it('error', done => {\n      async.concat([1, 3, 2], (val, next) => {\n        if (val === 3) {\n          return next(new Error('fail'));\n        }\n\n        next(null, [val, val + 1]);\n      }, (err, result) => {\n        expect(err).to.not.eql(null);\n        expect(result).to.eql([1, 2]);\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "canceled",
            "suites": [
                "concat",
                "concat"
            ],
            "updatePoint": {
                "line": 42,
                "column": 16
            },
            "line": 42,
            "code": "    it('canceled', done => {\n      var callOrder = [];\n      async.concat([1, 3, 2], (val, next) => {\n        callOrder.push(val);\n\n        if (val === 3) {\n          return next(false, [val, val + 1]);\n        }\n\n        next(null, [val, val + 1]);\n      }, () => {\n        throw new Error('should not get here');\n      });\n      setTimeout(() => {\n        expect(callOrder).to.eql([1, 3]);\n        done();\n      }, 25);\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "original untouched",
            "suites": [
                "concat",
                "concat"
            ],
            "updatePoint": {
                "line": 60,
                "column": 26
            },
            "line": 60,
            "code": "    it('original untouched', done => {\n      var arr = ['foo', 'bar', 'baz'];\n      async.concat(arr, (val, next) => {\n        next(null, [val, val]);\n      }, (err, result) => {\n        expect(arr).to.eql(['foo', 'bar', 'baz']);\n        expect(result).to.eql(['foo', 'foo', 'bar', 'bar', 'baz', 'baz']);\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "empty results",
            "suites": [
                "concat",
                "concat"
            ],
            "updatePoint": {
                "line": 70,
                "column": 21
            },
            "line": 70,
            "code": "    it('empty results', done => {\n      var arr = ['foo', 'bar', 'baz'];\n      async.concat(arr, (val, next) => {\n        next(null);\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.be.an('array').that.is.empty;\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "empty arrays",
            "suites": [
                "concat",
                "concat"
            ],
            "updatePoint": {
                "line": 80,
                "column": 20
            },
            "line": 80,
            "code": "    it('empty arrays', done => {\n      var arr = ['foo', 'bar', 'baz'];\n      async.concat(arr, (val, next) => {\n        next(null, []);\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.be.an('array').that.is.empty;\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles empty object",
            "suites": [
                "concat",
                "concat"
            ],
            "updatePoint": {
                "line": 90,
                "column": 28
            },
            "line": 90,
            "code": "    it('handles empty object', done => {\n      async.concat({}, (val, next) => {\n        assert(false, 'iteratee should not be called');\n        next();\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.be.an('array').that.is.empty;\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "variadic",
            "suites": [
                "concat",
                "concat"
            ],
            "updatePoint": {
                "line": 100,
                "column": 16
            },
            "line": 100,
            "code": "    it('variadic', done => {\n      var arr = ['foo', 'bar', 'baz'];\n      async.concat(arr, (val, next) => {\n        next(null, val, val);\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql(['foo', 'foo', 'bar', 'bar', 'baz', 'baz']);\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "flattens arrays",
            "suites": [
                "concat",
                "concat"
            ],
            "updatePoint": {
                "line": 110,
                "column": 23
            },
            "line": 110,
            "code": "    it('flattens arrays', done => {\n      var arr = ['foo', 'bar'];\n      async.concat(arr, (val, next) => {\n        next(null, [val, [val]]);\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql(['foo', ['foo'], 'bar', ['bar']]);\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles fasly values",
            "suites": [
                "concat",
                "concat"
            ],
            "updatePoint": {
                "line": 120,
                "column": 28
            },
            "line": 120,
            "code": "    it('handles fasly values', done => {\n      var falsy = [null, undefined, 0, ''];\n      async.concat(falsy, (val, next) => {\n        next(null, val);\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql(falsy);\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles objects",
            "suites": [
                "concat",
                "concat"
            ],
            "updatePoint": {
                "line": 130,
                "column": 23
            },
            "line": 130,
            "code": "    it('handles objects', done => {\n      var obj = {\n        a: 'foo',\n        b: 'bar',\n        c: 'baz'\n      };\n      async.concat(obj, (val, next) => {\n        next(null, val);\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql(['foo', 'bar', 'baz']);\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "main callback optional",
            "suites": [
                "concat",
                "concat"
            ],
            "updatePoint": {
                "line": 144,
                "column": 30
            },
            "line": 144,
            "code": "    it('main callback optional', done => {\n      var arr = [1, 2, 3];\n      var runs = [];\n      async.concat(arr, (val, next) => {\n        runs.push(val);\n\n        var _done = runs.length === arr.length;\n\n        async.setImmediate(() => {\n          next(null);\n\n          if (_done) {\n            expect(runs).to.eql(arr);\n            done();\n          }\n        });\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "iteratee callback is only called once",
            "suites": [
                "concat",
                "concat"
            ],
            "updatePoint": {
                "line": 162,
                "column": 45
            },
            "line": 162,
            "code": "    it('iteratee callback is only called once', done => {\n      async.concat([1, 2], (val, next) => {\n        try {\n          next(val);\n        } catch (exception) {\n          expect(() => {\n            next(exception);\n          }).to.throw(/already called/);\n          done();\n        }\n      }, () => {\n        throw new Error();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "preserves order",
            "suites": [
                "concat",
                "concat"
            ],
            "updatePoint": {
                "line": 176,
                "column": 23
            },
            "line": 176,
            "code": "    it('preserves order', done => {\n      var arr = [30, 15];\n      async.concat(arr, (x, cb) => {\n        setTimeout(() => {\n          cb(null, x);\n        }, x);\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql(arr);\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles Map",
            "suites": [
                "concat",
                "concat"
            ],
            "updatePoint": {
                "line": 188,
                "column": 19
            },
            "line": 188,
            "code": "    it('handles Map', done => {\n      if (typeof Map !== 'function') {\n        return done();\n      }\n\n      var map = new Map([['a', 'b'], ['b', 'c'], ['c', 'd']]);\n      async.concat(map, (val, next) => {\n        next(null, val);\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql(['a', 'b', 'b', 'c', 'c', 'd']);\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles sparse results",
            "suites": [
                "concat",
                "concat"
            ],
            "updatePoint": {
                "line": 202,
                "column": 30
            },
            "line": 202,
            "code": "    it('handles sparse results', done => {\n      var arr = [1, 2, 3, 4];\n      async.concat(arr, (val, next) => {\n        if (val === 1 || val === 3) {\n          return next(null, val + 1);\n        } else if (val === 2) {\n          async.setImmediate(() => {\n            return next(null, val + 1);\n          });\n        } else {\n          return next('error');\n        }\n      }, (err, result) => {\n        expect(err).to.not.eql(null);\n        expect(result).to.eql([2, 4]);\n        async.setImmediate(done);\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basics",
            "suites": [
                "concat",
                "concatLimit"
            ],
            "updatePoint": {
                "line": 222,
                "column": 14
            },
            "line": 222,
            "code": "    it('basics', done => {\n      var running = 0;\n      var concurrency = {\n        'foo': 2,\n        'bar': 2,\n        'baz': 1\n      };\n      async.concatLimit(['foo', 'bar', 'baz'], 2, (val, next) => {\n        running++;\n        async.setImmediate(() => {\n          expect(running).to.equal(concurrency[val]);\n          running--;\n          next(null, val, val);\n        });\n      }, (err, result) => {\n        expect(running).to.equal(0);\n        expect(err).to.eql(null);\n        expect(result).to.eql(['foo', 'foo', 'bar', 'bar', 'baz', 'baz']);\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "error",
            "suites": [
                "concat",
                "concatLimit"
            ],
            "updatePoint": {
                "line": 243,
                "column": 13
            },
            "line": 243,
            "code": "    it('error', done => {\n      async.concatLimit(['foo', 'bar', 'baz'], 1, (val, next) => {\n        if (val === 'bar') {\n          return next(new Error('fail'));\n        }\n\n        next(null, val);\n      }, (err, result) => {\n        expect(err).to.not.eql(null);\n        expect(result).to.eql(['foo']);\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "canceled",
            "suites": [
                "concat",
                "concatLimit"
            ],
            "updatePoint": {
                "line": 256,
                "column": 16
            },
            "line": 256,
            "code": "    it('canceled', done => {\n      var callOrder = [];\n      async.concatLimit([1, 2, 3, 4, 5], 2, (val, next) => {\n        callOrder.push(val);\n        async.setImmediate(() => {\n          if (val === 3) {\n            return next(false, val);\n          }\n\n          next(null, val);\n        });\n      }, () => {\n        throw new Error('should not get here');\n      });\n      setTimeout(() => {\n        expect(callOrder).to.eql([1, 2, 3, 4]);\n        done();\n      }, 50);\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles objects",
            "suites": [
                "concat",
                "concatLimit"
            ],
            "updatePoint": {
                "line": 275,
                "column": 23
            },
            "line": 275,
            "code": "    it('handles objects', done => {\n      async.concatLimit({\n        'foo': 1,\n        'bar': 2,\n        'baz': 3\n      }, 2, (val, next) => {\n        next(null, val + 1);\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql([2, 3, 4]);\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles empty object",
            "suites": [
                "concat",
                "concatLimit"
            ],
            "updatePoint": {
                "line": 288,
                "column": 28
            },
            "line": 288,
            "code": "    it('handles empty object', done => {\n      async.concatLimit({}, 2, (val, next) => {\n        assert(false, 'iteratee should not be called');\n        next();\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.be.an('array').that.is.empty;\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles undefined",
            "suites": [
                "concat",
                "concatLimit"
            ],
            "updatePoint": {
                "line": 298,
                "column": 25
            },
            "line": 298,
            "code": "    it('handles undefined', done => {\n      async.concatLimit(undefined, 2, (val, next) => {\n        assert(false, 'iteratee should not be called');\n        next();\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.be.an('array').that.is.empty;\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "limit exceeds size",
            "suites": [
                "concat",
                "concatLimit"
            ],
            "updatePoint": {
                "line": 308,
                "column": 26
            },
            "line": 308,
            "code": "    it('limit exceeds size', function (done) {\n      var callOrder = [];\n      async.concatLimit([3, 2, 2, 1], 10, concatIteratee.bind(this, callOrder), (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql([3, 4, 2, 3, 2, 3, 1, 2]);\n        expect(callOrder).to.eql([1, 2, 2, 3]);\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "limit equal size",
            "suites": [
                "concat",
                "concatLimit"
            ],
            "updatePoint": {
                "line": 317,
                "column": 24
            },
            "line": 317,
            "code": "    it('limit equal size', function (done) {\n      var callOrder = [];\n      async.concatLimit([3, 2, 2, 1], 4, concatIteratee.bind(this, callOrder), (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql([3, 4, 2, 3, 2, 3, 1, 2]);\n        expect(callOrder).to.eql([1, 2, 2, 3]);\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "zero limit",
            "suites": [
                "concat",
                "concatLimit"
            ],
            "updatePoint": {
                "line": 326,
                "column": 18
            },
            "line": 326,
            "code": "    it('zero limit', () => {\n      expect(() => {\n        async.concatLimit([3, 2, 2, 1], 0, (val, next) => {\n          assert(false, 'iteratee should not be called');\n          next();\n        }, () => {\n          assert(false, 'callback should not be called');\n        });\n      }).to.throw(/limit/);\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not continue replenishing after error",
            "suites": [
                "concat",
                "concatLimit"
            ],
            "updatePoint": {
                "line": 336,
                "column": 50
            },
            "line": 336,
            "code": "    it('does not continue replenishing after error', done => {\n      var started = 0;\n      var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n      var limit = 3;\n      async.concatLimit(arr, limit, (val, next) => {\n        started++;\n\n        if (started === 3) {\n          return next(new Error('fail'));\n        }\n\n        async.setImmediate(() => {\n          next();\n        });\n      }, (err, result) => {\n        expect(err).to.not.eql(null);\n        expect(result).to.be.an('array').that.is.empty;\n      }); // wait `maxSteps` event loop cycles before calling done to ensure\n      // the iteratee is not called on more items in arr.\n\n      function waitCycle() {\n        expect(started).to.equal(3);\n        done();\n      }\n\n      setTimeout(waitCycle, 25);\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basics",
            "suites": [
                "concat",
                "concatSeries"
            ],
            "updatePoint": {
                "line": 365,
                "column": 14
            },
            "line": 365,
            "code": "    it('basics', done => {\n      var callOrder = [];\n      var running = 0;\n\n      var iteratee = function (x, cb) {\n        running++;\n        setTimeout(() => {\n          expect(running).to.equal(1);\n          running--;\n          callOrder.push(x);\n          var r = [];\n\n          while (x > 0) {\n            r.push(x);\n            x--;\n          }\n\n          cb(null, r);\n        }, x * 10);\n      };\n\n      async.concatSeries([1, 3, 2], iteratee, (err, results) => {\n        expect(results).to.eql([1, 3, 2, 1, 2, 1]);\n        expect(running).to.equal(0);\n        expect(callOrder).to.eql([1, 3, 2]);\n        assert(err === null, err + \" passed instead of 'null'\");\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "error",
            "suites": [
                "concat",
                "concatSeries"
            ],
            "updatePoint": {
                "line": 394,
                "column": 13
            },
            "line": 394,
            "code": "    it('error', done => {\n      async.concatSeries(['foo', 'bar', 'baz'], (val, next) => {\n        if (val === 'bar') {\n          return next(new Error('fail'));\n        }\n\n        next(null, [val, val]);\n      }, (err, result) => {\n        expect(err).to.not.eql(null);\n        expect(result).to.eql(['foo', 'foo']);\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "canceled",
            "suites": [
                "concat",
                "concatSeries"
            ],
            "updatePoint": {
                "line": 407,
                "column": 16
            },
            "line": 407,
            "code": "    it('canceled', done => {\n      var callOrder = [];\n      async.concatSeries([1, 2, 3], (val, next) => {\n        callOrder.push(val);\n        async.setImmediate(() => {\n          if (val === 2) {\n            return next(false, val);\n          }\n\n          next(null, val);\n        });\n      }, () => {\n        throw new Error('should not get here');\n      });\n      setTimeout(() => {\n        expect(callOrder).to.eql([1, 2]);\n        done();\n      }, 50);\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles objects",
            "suites": [
                "concat",
                "concatSeries"
            ],
            "updatePoint": {
                "line": 426,
                "column": 23
            },
            "line": 426,
            "code": "    it('handles objects', done => {\n      async.concatSeries({\n        'foo': 1,\n        'bar': 2,\n        'baz': 3\n      }, (val, next) => {\n        return next(null, [val, val + 1]);\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql([1, 2, 2, 3, 3, 4]);\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles empty object",
            "suites": [
                "concat",
                "concatSeries"
            ],
            "updatePoint": {
                "line": 439,
                "column": 28
            },
            "line": 439,
            "code": "    it('handles empty object', done => {\n      async.concatSeries({}, (val, next) => {\n        assert(false, 'iteratee should not be called');\n        next();\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.be.an('array').that.is.empty;\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles undefined",
            "suites": [
                "concat",
                "concatSeries"
            ],
            "updatePoint": {
                "line": 449,
                "column": 25
            },
            "line": 449,
            "code": "    it('handles undefined', done => {\n      async.concatSeries(undefined, (val, next) => {\n        assert(false, 'iteratee should not be called');\n        next();\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.be.an('array').that.is.empty;\n        done();\n      });\n    });",
            "file": "concat.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basic usage",
            "suites": [
                "constant"
            ],
            "updatePoint": {
                "line": 8,
                "column": 17
            },
            "line": 8,
            "code": "  it('basic usage', done => {\n    var f = async.constant(42, 1, 2, 3);\n    f((err, value, a, b, c) => {\n      expect(err).to.equal(null);\n      expect(value).to.equal(42);\n      expect(a).to.equal(1);\n      expect(b).to.equal(2);\n      expect(c).to.equal(3);\n      done();\n    });\n  });",
            "file": "constant.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "called with multiple arguments",
            "suites": [
                "constant"
            ],
            "updatePoint": {
                "line": 19,
                "column": 36
            },
            "line": 19,
            "code": "  it('called with multiple arguments', done => {\n    var f = async.constant(42, 1, 2, 3);\n    f('argument to ignore', 'another argument', (err, value, a) => {\n      expect(err).to.equal(null);\n      expect(value).to.equal(42);\n      expect(a).to.equal(1);\n      done();\n    });\n  });",
            "file": "constant.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detect",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 17,
                "column": 12
            },
            "line": 17,
            "code": "  it('detect', function (done) {\n    var call_order = [];\n    async.detect([3, 2, 1], detectIteratee.bind(this, call_order), (err, result) => {\n      call_order.push('callback');\n      expect(err).to.equal(null);\n      expect(result).to.equal(2);\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 2, 'callback', 3]);\n      done();\n    }, 25);\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detect - multiple matches",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 29,
                "column": 31
            },
            "line": 29,
            "code": "  it('detect - multiple matches', function (done) {\n    var call_order = [];\n    async.detect([3, 2, 2, 1, 2], detectIteratee.bind(this, call_order), (err, result) => {\n      call_order.push('callback');\n      expect(err).to.equal(null);\n      expect(result).to.equal(2);\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 2, 'callback', 2, 2, 3]);\n      done();\n    }, 25);\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detect error",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 41,
                "column": 18
            },
            "line": 41,
            "code": "  it('detect error', done => {\n    async.detect([3, 2, 1], (x, callback) => {\n      setTimeout(() => {\n        callback('error');\n      }, 0);\n    }, (err, result) => {\n      expect(err).to.equal('error');\n      expect(result).to.not.exist;\n      done();\n    });\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detect canceled",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 52,
                "column": 21
            },
            "line": 52,
            "code": "  it('detect canceled', done => {\n    var call_order = [];\n    async.detect({\n      'a': 3,\n      'b': 2,\n      'c': 1\n    }, (x, callback) => {\n      call_order.push(x);\n\n      if (x === 2) {\n        return callback(false);\n      }\n\n      callback(null);\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([3, 2]);\n      done();\n    }, 25);\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detectSeries",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 74,
                "column": 18
            },
            "line": 74,
            "code": "  it('detectSeries', function (done) {\n    var call_order = [];\n    async.detectSeries([3, 2, 1], detectIteratee.bind(this, call_order), (err, result) => {\n      call_order.push('callback');\n      expect(err).to.equal(null);\n      expect(result).to.equal(2);\n      expect(call_order).to.eql([3, 2, 'callback']);\n      done();\n    });\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detectSeries - multiple matches",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 84,
                "column": 37
            },
            "line": 84,
            "code": "  it('detectSeries - multiple matches', function (done) {\n    var call_order = [];\n    async.detectSeries([3, 2, 2, 1, 2], detectIteratee.bind(this, call_order), (err, result) => {\n      call_order.push('callback');\n      expect(err).to.equal(null);\n      expect(result).to.equal(2);\n      expect(call_order).to.eql([3, 2, 'callback']);\n      done();\n    });\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detect no callback",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 94,
                "column": 24
            },
            "line": 94,
            "code": "  it('detect no callback', done => {\n    var calls = [];\n    async.detect([1, 2, 3], (val, cb) => {\n      calls.push(val);\n      cb();\n    });\n    setTimeout(() => {\n      expect(calls).to.eql([1, 2, 3]);\n      done();\n    }, 10);\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detectSeries - ensure stop",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 105,
                "column": 32
            },
            "line": 105,
            "code": "  it('detectSeries - ensure stop', done => {\n    async.detectSeries([1, 2, 3, 4, 5], (num, cb) => {\n      if (num > 3) throw new Error(\"detectSeries did not stop iterating\");\n      cb(null, num === 3);\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.equal(3);\n      done();\n    });\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detectSeries canceled",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 115,
                "column": 27
            },
            "line": 115,
            "code": "  it('detectSeries canceled', done => {\n    var call_order = [];\n    async.detectSeries([3, 2, 1], (x, callback) => {\n      async.setImmediate(() => {\n        call_order.push(x);\n\n        if (x === 2) {\n          return callback(false);\n        }\n\n        callback(null);\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([3, 2]);\n      done();\n    }, 50);\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detectLimit",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 135,
                "column": 17
            },
            "line": 135,
            "code": "  it('detectLimit', function (done) {\n    var call_order = [];\n    async.detectLimit([3, 2, 1], 2, detectIteratee.bind(this, call_order), (err, result) => {\n      call_order.push('callback');\n      expect(err).to.equal(null);\n      expect(result).to.equal(2);\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([2, 'callback', 3]);\n      done();\n    }, 50);\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detectLimit - multiple matches",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 147,
                "column": 36
            },
            "line": 147,
            "code": "  it('detectLimit - multiple matches', function (done) {\n    var call_order = [];\n    async.detectLimit([3, 2, 2, 1, 2], 2, detectIteratee.bind(this, call_order), (err, result) => {\n      call_order.push('callback');\n      expect(err).to.equal(null);\n      expect(result).to.equal(2);\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([2, 'callback', 3]);\n      done();\n    }, 50);\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detectLimit - ensure stop",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 159,
                "column": 31
            },
            "line": 159,
            "code": "  it('detectLimit - ensure stop', done => {\n    async.detectLimit([1, 2, 3, 4, 5], 2, (num, cb) => {\n      if (num > 4) throw new Error(\"detectLimit did not stop iterating\");\n      cb(null, num === 3);\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.equal(3);\n      done();\n    });\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detectLimit canceled",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 169,
                "column": 26
            },
            "line": 169,
            "code": "  it('detectLimit canceled', done => {\n    var call_order = [];\n    async.detectLimit([3, 3, 2, 2, 1], 2, (x, callback) => {\n      async.setImmediate(() => {\n        call_order.push(x);\n\n        if (x === 2) {\n          return callback(false);\n        }\n\n        callback(null);\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([3, 3, 2, 2]);\n      done();\n    }, 50);\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detectSeries doesn't cause stack overflow (#1293)",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 189,
                "column": 56
            },
            "line": 189,
            "code": "  it('detectSeries doesn\\'t cause stack overflow (#1293)', done => {\n    var arr = _.range(10000);\n\n    let calls = 0;\n    async.detectSeries(arr, (data, cb) => {\n      calls += 1;\n      async.setImmediate(_.partial(cb, null, true));\n    }, err => {\n      expect(err).to.equal(null);\n      expect(calls).to.equal(1);\n      done();\n    });\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "detectLimit doesn't cause stack overflow (#1293)",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 202,
                "column": 55
            },
            "line": 202,
            "code": "  it('detectLimit doesn\\'t cause stack overflow (#1293)', done => {\n    var arr = _.range(10000);\n\n    let calls = 0;\n    async.detectLimit(arr, 100, (data, cb) => {\n      calls += 1;\n      async.setImmediate(_.partial(cb, null, true));\n    }, err => {\n      expect(err).to.equal(null);\n      expect(calls).to.equal(100);\n      done();\n    });\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "find alias",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 215,
                "column": 16
            },
            "line": 215,
            "code": "  it('find alias', () => {\n    expect(async.find).to.equal(async.detect);\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "findLimit alias",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 218,
                "column": 21
            },
            "line": 218,
            "code": "  it('findLimit alias', () => {\n    expect(async.findLimit).to.equal(async.detectLimit);\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "findSeries alias",
            "suites": [
                "detect"
            ],
            "updatePoint": {
                "line": 221,
                "column": 22
            },
            "line": 221,
            "code": "  it('findSeries alias', () => {\n    expect(async.findSeries).to.be.a('function');\n    expect(async.findSeries).to.equal(async.detectSeries);\n  });",
            "file": "detect.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "each",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 23,
                "column": 10
            },
            "line": 23,
            "code": "  it('each', function (done) {\n    var args = [];\n    async.each([1, 3, 2], eachIteratee.bind(this, args), err => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(args).to.eql([1, 2, 3]);\n      done();\n    });\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "each extra callback",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 31,
                "column": 25
            },
            "line": 31,
            "code": "  it('each extra callback', done => {\n    var count = 0;\n    async.each([1, 3, 2], (val, callback) => {\n      count++;\n      var done_ = count == 3;\n      callback();\n      assert.throws(callback);\n\n      if (done_) {\n        done();\n      }\n    });\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "each empty array",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 44,
                "column": 22
            },
            "line": 44,
            "code": "  it('each empty array', done => {\n    async.each([], (x, callback) => {\n      assert(false, 'iteratee should not be called');\n      callback();\n    }, err => {\n      if (err) throw err;\n      assert(true, 'should call callback');\n    });\n    setTimeout(done, 25);\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "each empty array, with other property on the array",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 54,
                "column": 56
            },
            "line": 54,
            "code": "  it('each empty array, with other property on the array', done => {\n    var myArray = [];\n    myArray.myProp = \"anything\";\n    async.each(myArray, (x, callback) => {\n      assert(false, 'iteratee should not be called');\n      callback();\n    }, err => {\n      if (err) throw err;\n      assert(true, 'should call callback');\n    });\n    setTimeout(done, 25);\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "each error",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 66,
                "column": 16
            },
            "line": 66,
            "code": "  it('each error', done => {\n    async.each([1, 2, 3], (x, callback) => {\n      callback('error');\n    }, err => {\n      expect(err).to.equal('error');\n    });\n    setTimeout(done, 50);\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "each canceled",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 74,
                "column": 19
            },
            "line": 74,
            "code": "  it('each canceled', done => {\n    var call_order = [];\n    async.each([1, 2, 3], (x, callback) => {\n      call_order.push(x);\n\n      if (x === 2) {\n        return callback(false);\n      }\n\n      callback(null);\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 2, 3]);\n      done();\n    }, 25);\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "each no callback",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 92,
                "column": 22
            },
            "line": 92,
            "code": "  it('each no callback', function (done) {\n    async.each([1], eachNoCallbackIteratee.bind(this, done));\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "each no callback",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 95,
                "column": 22
            },
            "line": 95,
            "code": "  it('each no callback', async done => {\n    try {\n      async.each([1], 'INVALID_CALL_BACK', () => {});\n    } catch (err) {\n      expect(err.message).to.equal('expected a function');\n      done();\n    }\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachSeries",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 103,
                "column": 16
            },
            "line": 103,
            "code": "  it('eachSeries', function (done) {\n    var args = [];\n    async.eachSeries([1, 3, 2], eachIteratee.bind(this, args), err => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(args).to.eql([1, 3, 2]);\n      done();\n    });\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachSeries empty array",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 111,
                "column": 28
            },
            "line": 111,
            "code": "  it('eachSeries empty array', done => {\n    async.eachSeries([], (x, callback) => {\n      assert(false, 'iteratee should not be called');\n      callback();\n    }, err => {\n      if (err) throw err;\n      assert(true, 'should call callback');\n    });\n    setTimeout(done, 25);\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachSeries array modification",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 121,
                "column": 35
            },
            "line": 121,
            "code": "  it('eachSeries array modification', done => {\n    var arr = [1, 2, 3, 4];\n    async.eachSeries(arr, (x, callback) => {\n      async.setImmediate(callback);\n    }, () => {\n      assert(true, 'should call callback');\n    });\n    arr.pop();\n    arr.splice(0, 1);\n    setTimeout(done, 50);\n  }); // bug #782.  Remove in next major release",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachSeries single item",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 133,
                "column": 28
            },
            "line": 133,
            "code": "  it('eachSeries single item', done => {\n    var sync = true;\n    async.eachSeries([1], (i, cb) => {\n      cb(null);\n    }, () => {\n      assert(sync, \"callback not called on same tick\");\n    });\n    sync = false;\n    done();\n  }); // bug #782.  Remove in next major release",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachSeries single item",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 144,
                "column": 28
            },
            "line": 144,
            "code": "  it('eachSeries single item', done => {\n    var sync = true;\n    async.eachSeries([1], (i, cb) => {\n      cb(null);\n    }, () => {\n      assert(sync, \"callback not called on same tick\");\n    });\n    sync = false;\n    done();\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachSeries error",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 154,
                "column": 22
            },
            "line": 154,
            "code": "  it('eachSeries error', done => {\n    var call_order = [];\n    async.eachSeries([1, 2, 3], (x, callback) => {\n      call_order.push(x);\n      callback('error');\n    }, err => {\n      expect(call_order).to.eql([1]);\n      expect(err).to.equal('error');\n    });\n    setTimeout(done, 50);\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachSeries canceled",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 165,
                "column": 25
            },
            "line": 165,
            "code": "  it('eachSeries canceled', done => {\n    var call_order = [];\n    async.eachSeries([1, 2, 3], (x, callback) => {\n      call_order.push(x);\n      async.setImmediate(() => {\n        if (x === 2) {\n          return callback(false);\n        }\n\n        callback(null);\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 2]);\n      done();\n    }, 50);\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachSeries no callback",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 184,
                "column": 28
            },
            "line": 184,
            "code": "  it('eachSeries no callback', function (done) {\n    async.eachSeries([1], eachNoCallbackIteratee.bind(this, done));\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachLimit",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 187,
                "column": 15
            },
            "line": 187,
            "code": "  it('eachLimit', done => {\n    var args = [];\n    var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    async.eachLimit(arr, 2, (x, callback) => {\n      setTimeout(() => {\n        args.push(x);\n        callback();\n      }, x * 5);\n    }, err => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(args).to.eql(arr);\n      done();\n    });\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachLimit empty array",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 201,
                "column": 27
            },
            "line": 201,
            "code": "  it('eachLimit empty array', done => {\n    async.eachLimit([], 2, (x, callback) => {\n      assert(false, 'iteratee should not be called');\n      callback();\n    }, err => {\n      if (err) throw err;\n      assert(true, 'should call callback');\n    });\n    setTimeout(done, 25);\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachLimit limit exceeds size",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 211,
                "column": 34
            },
            "line": 211,
            "code": "  it('eachLimit limit exceeds size', function (done) {\n    var args = [];\n    var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    async.eachLimit(arr, 20, eachIteratee.bind(this, args), err => {\n      if (err) throw err;\n      expect(args).to.eql(arr);\n      done();\n    });\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachLimit limit equal size",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 220,
                "column": 32
            },
            "line": 220,
            "code": "  it('eachLimit limit equal size', function (done) {\n    var args = [];\n    var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    async.eachLimit(arr, 10, eachIteratee.bind(this, args), err => {\n      if (err) throw err;\n      expect(args).to.eql(arr);\n      done();\n    });\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachLimit zero limit",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 229,
                "column": 26
            },
            "line": 229,
            "code": "  it('eachLimit zero limit', () => {\n    expect(() => {\n      async.eachLimit([0, 1, 2, 3, 4, 5], 0, (x, callback) => {\n        assert(false, 'iteratee should not be called');\n        callback();\n      }, () => {\n        assert(false, 'should not call callback');\n      });\n    }).to.throw(/limit/);\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachLimit error",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 239,
                "column": 21
            },
            "line": 239,
            "code": "  it('eachLimit error', done => {\n    var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    var call_order = [];\n    async.eachLimit(arr, 3, (x, callback) => {\n      call_order.push(x);\n\n      if (x === 2) {\n        callback('error');\n      }\n    }, err => {\n      expect(call_order).to.eql([0, 1, 2]);\n      expect(err).to.equal('error');\n    });\n    setTimeout(done, 25);\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachLimit canceled",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 254,
                "column": 24
            },
            "line": 254,
            "code": "  it('eachLimit canceled', done => {\n    var call_order = [];\n    async.eachLimit([1, 1, 2, 2, 3], 2, (x, callback) => {\n      call_order.push(x);\n      async.setImmediate(() => {\n        if (x === 2) {\n          return callback(false);\n        }\n\n        callback(null);\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 1, 2, 2]);\n      done();\n    }, 50);\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachLimit no callback",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 273,
                "column": 27
            },
            "line": 273,
            "code": "  it('eachLimit no callback', function (done) {\n    async.eachLimit([1], 1, eachNoCallbackIteratee.bind(this, done));\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachLimit synchronous",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 276,
                "column": 27
            },
            "line": 276,
            "code": "  it('eachLimit synchronous', done => {\n    var args = [];\n    var arr = [0, 1, 2];\n    async.eachLimit(arr, 5, (x, callback) => {\n      args.push(x);\n      callback();\n    }, err => {\n      if (err) throw err;\n      expect(args).to.eql(arr);\n      done();\n    });\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachLimit does not continue replenishing after error",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 288,
                "column": 58
            },
            "line": 288,
            "code": "  it('eachLimit does not continue replenishing after error', done => {\n    var started = 0;\n    var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    var delay = 10;\n    var limit = 3;\n    var maxTime = 10 * arr.length;\n    async.eachLimit(arr, limit, (x, callback) => {\n      started++;\n\n      if (started === 3) {\n        return callback(new Error(\"Test Error\"));\n      }\n\n      setTimeout(() => {\n        callback();\n      }, delay);\n    }, () => {});\n    setTimeout(() => {\n      expect(started).to.equal(3);\n      done();\n    }, maxTime);\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEach alias",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 310,
                "column": 19
            },
            "line": 310,
            "code": "  it('forEach alias', done => {\n    assert.strictEqual(async.each, async.forEach);\n    done();\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachSeries alias",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 314,
                "column": 25
            },
            "line": 314,
            "code": "  it('forEachSeries alias', done => {\n    assert.strictEqual(async.eachSeries, async.forEachSeries);\n    done();\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachLimit alias",
            "suites": [
                "each"
            ],
            "updatePoint": {
                "line": 318,
                "column": 24
            },
            "line": 318,
            "code": "  it('forEachLimit alias', done => {\n    assert.strictEqual(async.eachLimit, async.forEachLimit);\n    done();\n  });",
            "file": "each.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachOf alias",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 26,
                "column": 18
            },
            "line": 26,
            "code": "  it('eachOf alias', done => {\n    expect(async.eachOf).to.equal(async.forEachOf);\n    done();\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachOfLimit alias",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 30,
                "column": 23
            },
            "line": 30,
            "code": "  it('eachOfLimit alias', done => {\n    expect(async.eachOfLimit).to.equal(async.forEachOfLimit);\n    done();\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachOfSeries alias",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 34,
                "column": 24
            },
            "line": 34,
            "code": "  it('eachOfSeries alias', done => {\n    expect(async.eachOfSeries).to.equal(async.forEachOfSeries);\n    done();\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOf",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 38,
                "column": 15
            },
            "line": 38,
            "code": "  it('forEachOf', function (done) {\n    var args = [];\n    async.forEachOf({\n      a: 1,\n      b: 2\n    }, forEachOfIteratee.bind(this, args), err => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(args).to.eql([\"a\", 1, \"b\", 2]);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOf no call stack size exceed error",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 49,
                "column": 47
            },
            "line": 49,
            "code": "  it('forEachOf no call stack size exceed error', done => {\n    var obj = {};\n    var len = 3000;\n    var args = new Array(len * 2);\n    var expected = new Array(len * 2);\n\n    for (var i = 0; i < len; i++) {\n      obj[\"a\" + i] = i;\n      expected[2 * i] = \"a\" + i;\n      expected[2 * i + 1] = i;\n    }\n\n    async.forEachOf(obj, (value, key, callback) => {\n      var index = parseInt(key.slice(1), 10);\n      args[2 * index] = key;\n      args[2 * index + 1] = value;\n      callback();\n    }, err => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(args).to.eql(expected);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOf - instant resolver",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 72,
                "column": 34
            },
            "line": 72,
            "code": "  it('forEachOf - instant resolver', done => {\n    var args = [];\n    async.forEachOf({\n      a: 1,\n      b: 2\n    }, (x, k, cb) => {\n      args.push(k, x);\n      cb();\n    }, () => {\n      // ensures done callback isn't called before all items iterated\n      expect(args).to.eql([\"a\", 1, \"b\", 2]);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOf empty object",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 86,
                "column": 28
            },
            "line": 86,
            "code": "  it('forEachOf empty object', done => {\n    async.forEachOf({}, (value, key, callback) => {\n      assert(false, 'iteratee should not be called');\n      callback();\n    }, err => {\n      if (err) throw err;\n      assert(true, 'should call callback');\n    });\n    setTimeout(done, 25);\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOf empty array",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 96,
                "column": 27
            },
            "line": 96,
            "code": "  it('forEachOf empty array', done => {\n    async.forEachOf([], (value, key, callback) => {\n      assert(false, 'iteratee should not be called');\n      callback();\n    }, err => {\n      if (err) throw err;\n      assert(true, 'should call callback');\n    });\n    setTimeout(done, 25);\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOf error",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 106,
                "column": 21
            },
            "line": 106,
            "code": "  it('forEachOf error', done => {\n    async.forEachOf({\n      a: 1,\n      b: 2\n    }, (value, key, callback) => {\n      callback('error');\n    }, err => {\n      expect(err).to.equal('error');\n    });\n    setTimeout(done, 50);\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOf no callback",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 117,
                "column": 27
            },
            "line": 117,
            "code": "  it('forEachOf no callback', function (done) {\n    async.forEachOf({\n      a: 1\n    }, forEachOfNoCallbackIteratee.bind(this, done));\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOf with array",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 122,
                "column": 26
            },
            "line": 122,
            "code": "  it('forEachOf with array', function (done) {\n    var args = [];\n    async.forEachOf([\"a\", \"b\"], forEachOfIteratee.bind(this, args), err => {\n      if (err) throw err;\n      expect(args).to.eql([0, \"a\", 1, \"b\"]);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOf with Set (iterators)",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 130,
                "column": 36
            },
            "line": 130,
            "code": "  it('forEachOf with Set (iterators)', function (done) {\n    if (typeof Set !== 'function') return done();\n    var args = [];\n    var set = new Set();\n    set.add(\"a\");\n    set.add(\"b\");\n    async.forEachOf(set, forEachOfIteratee.bind(this, args), err => {\n      if (err) throw err;\n      expect(args).to.eql([0, \"a\", 1, \"b\"]);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOf with Map (iterators)",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 142,
                "column": 36
            },
            "line": 142,
            "code": "  it('forEachOf with Map (iterators)', function (done) {\n    if (typeof Map !== 'function') return done();\n    var args = [];\n    var map = new Map();\n    map.set(1, \"a\");\n    map.set(2, \"b\");\n    async.forEachOf(map, forEachOfIteratee.bind(this, args), err => {\n      if (err) throw err;\n      expect(args).to.eql([0, [1, \"a\"], 1, [2, \"b\"]]);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfSeries",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 154,
                "column": 21
            },
            "line": 154,
            "code": "  it('forEachOfSeries', function (done) {\n    var args = [];\n    async.forEachOfSeries({\n      a: 1,\n      b: 2\n    }, forEachOfIteratee.bind(this, args), err => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(args).to.eql([\"a\", 1, \"b\", 2]);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfSeries no call stack size exceed error",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 165,
                "column": 53
            },
            "line": 165,
            "code": "  it('forEachOfSeries no call stack size exceed error', done => {\n    var obj = {};\n    var len = 3000;\n    var args = new Array(len * 2);\n    var expected = new Array(len * 2);\n\n    for (var i = 0; i < len; i++) {\n      obj[\"a\" + i] = i;\n      expected[2 * i] = \"a\" + i;\n      expected[2 * i + 1] = i;\n    }\n\n    async.forEachOfSeries(obj, (value, key, callback) => {\n      var index = parseInt(key.slice(1), 10);\n      args[2 * index] = key;\n      args[2 * index + 1] = value;\n      callback();\n    }, err => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(args).to.eql(expected);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfSeries empty object",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 188,
                "column": 34
            },
            "line": 188,
            "code": "  it('forEachOfSeries empty object', done => {\n    async.forEachOfSeries({}, (x, callback) => {\n      assert(false, 'iteratee should not be called');\n      callback();\n    }, err => {\n      if (err) throw err;\n      assert(true, 'should call callback');\n    });\n    setTimeout(done, 25);\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfSeries error",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 198,
                "column": 27
            },
            "line": 198,
            "code": "  it('forEachOfSeries error', done => {\n    var call_order = [];\n    async.forEachOfSeries({\n      a: 1,\n      b: 2\n    }, (value, key, callback) => {\n      call_order.push(value, key);\n      callback('error');\n    }, err => {\n      expect(call_order).to.eql([1, \"a\"]);\n      expect(err).to.equal('error');\n    });\n    setTimeout(done, 50);\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfSeries no callback",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 212,
                "column": 33
            },
            "line": 212,
            "code": "  it('forEachOfSeries no callback', function (done) {\n    async.forEachOfSeries({\n      a: 1\n    }, forEachOfNoCallbackIteratee.bind(this, done));\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfSeries with array",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 217,
                "column": 32
            },
            "line": 217,
            "code": "  it('forEachOfSeries with array', function (done) {\n    var args = [];\n    async.forEachOfSeries([\"a\", \"b\"], forEachOfIteratee.bind(this, args), err => {\n      if (err) throw err;\n      expect(args).to.eql([0, \"a\", 1, \"b\"]);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfSeries with Set (iterators)",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 225,
                "column": 42
            },
            "line": 225,
            "code": "  it('forEachOfSeries with Set (iterators)', function (done) {\n    if (typeof Set !== 'function') return done();\n    var args = [];\n    var set = new Set();\n    set.add(\"a\");\n    set.add(\"b\");\n    async.forEachOfSeries(set, forEachOfIteratee.bind(this, args), err => {\n      if (err) throw err;\n      expect(args).to.eql([0, \"a\", 1, \"b\"]);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfSeries with Map (iterators)",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 237,
                "column": 42
            },
            "line": 237,
            "code": "  it('forEachOfSeries with Map (iterators)', function (done) {\n    if (typeof Map !== 'function') return done();\n    var args = [];\n    var map = new Map();\n    map.set(1, \"a\");\n    map.set(2, \"b\");\n    async.forEachOfSeries(map, forEachOfIteratee.bind(this, args), err => {\n      if (err) throw err;\n      expect(args).to.eql([0, [1, \"a\"], 1, [2, \"b\"]]);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfLimit",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 249,
                "column": 20
            },
            "line": 249,
            "code": "  it('forEachOfLimit', done => {\n    var args = [];\n    var obj = {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4\n    };\n    async.forEachOfLimit(obj, 2, (value, key, callback) => {\n      setTimeout(() => {\n        args.push(value, key);\n        callback();\n      }, value * 5);\n    }, err => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(args).to.eql([1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\"]);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfLimit empty object",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 268,
                "column": 33
            },
            "line": 268,
            "code": "  it('forEachOfLimit empty object', done => {\n    async.forEachOfLimit({}, 2, (value, key, callback) => {\n      assert(false, 'iteratee should not be called');\n      callback();\n    }, err => {\n      if (err) throw err;\n      assert(true, 'should call callback');\n    });\n    setTimeout(done, 25);\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfLimit limit exceeds size",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 278,
                "column": 39
            },
            "line": 278,
            "code": "  it('forEachOfLimit limit exceeds size', function (done) {\n    var args = [];\n    var obj = {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4,\n      e: 5\n    };\n    async.forEachOfLimit(obj, 10, forEachOfIteratee.bind(this, args), err => {\n      if (err) throw err;\n      expect(args).to.eql([\"a\", 1, \"b\", 2, \"c\", 3, \"d\", 4, \"e\", 5]);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfLimit limit equal size",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 293,
                "column": 37
            },
            "line": 293,
            "code": "  it('forEachOfLimit limit equal size', function (done) {\n    var args = [];\n    var obj = {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4,\n      e: 5\n    };\n    async.forEachOfLimit(obj, 5, forEachOfIteratee.bind(this, args), err => {\n      if (err) throw err;\n      expect(args).to.eql([\"a\", 1, \"b\", 2, \"c\", 3, \"d\", 4, \"e\", 5]);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfLimit zero limit",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 308,
                "column": 31
            },
            "line": 308,
            "code": "  it('forEachOfLimit zero limit', () => {\n    expect(() => {\n      async.forEachOfLimit({\n        a: 1,\n        b: 2\n      }, 0, (x, callback) => {\n        assert(false, 'iteratee should not be called');\n        callback();\n      }, () => {\n        assert(true, 'should call callback');\n      });\n    }).to.throw(/concurrency limit/);\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfLimit no limit",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 321,
                "column": 29
            },
            "line": 321,
            "code": "  it('forEachOfLimit no limit', done => {\n    var count = 0;\n    async.forEachOfLimit(_.range(100), Infinity, (x, i, callback) => {\n      count++;\n      callback();\n    }, err => {\n      if (err) throw err;\n      expect(count).to.equal(100);\n    });\n    setTimeout(done, 25);\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfLimit no call stack size exceed error",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 332,
                "column": 52
            },
            "line": 332,
            "code": "  it('forEachOfLimit no call stack size exceed error', done => {\n    var count = 0;\n    async.forEachOfLimit(_.range(1024 * 1024), Infinity, (x, i, callback) => {\n      count++;\n      callback();\n    }, err => {\n      if (err) throw err;\n      expect(count).to.equal(1024 * 1024);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfLimit error",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 343,
                "column": 26
            },
            "line": 343,
            "code": "  it('forEachOfLimit error', done => {\n    var obj = {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4,\n      e: 5\n    };\n    var call_order = [];\n    async.forEachOfLimit(obj, 3, (value, key, callback) => {\n      call_order.push(value, key);\n\n      if (value === 2) {\n        callback('error');\n      }\n    }, err => {\n      expect(call_order).to.eql([1, \"a\", 2, \"b\"]);\n      expect(err).to.equal('error');\n    });\n    setTimeout(done, 25);\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfLimit no callback",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 364,
                "column": 32
            },
            "line": 364,
            "code": "  it('forEachOfLimit no callback', function (done) {\n    async.forEachOfLimit({\n      a: 1\n    }, 1, forEachOfNoCallbackIteratee.bind(this, done));\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfLimit synchronous",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 369,
                "column": 32
            },
            "line": 369,
            "code": "  it('forEachOfLimit synchronous', function (done) {\n    var args = [];\n    var obj = {\n      a: 1,\n      b: 2\n    };\n    async.forEachOfLimit(obj, 5, forEachOfIteratee.bind(this, args), err => {\n      if (err) throw err;\n      expect(args).to.eql([\"a\", 1, \"b\", 2]);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfLimit with array",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 381,
                "column": 31
            },
            "line": 381,
            "code": "  it('forEachOfLimit with array', function (done) {\n    var args = [];\n    var arr = [\"a\", \"b\"];\n    async.forEachOfLimit(arr, 1, forEachOfIteratee.bind(this, args), err => {\n      if (err) throw err;\n      expect(args).to.eql([0, \"a\", 1, \"b\"]);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfLimit with Set (iterators)",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 390,
                "column": 41
            },
            "line": 390,
            "code": "  it('forEachOfLimit with Set (iterators)', function (done) {\n    if (typeof Set !== 'function') return done();\n    var args = [];\n    var set = new Set();\n    set.add(\"a\");\n    set.add(\"b\");\n    async.forEachOfLimit(set, 1, forEachOfIteratee.bind(this, args), err => {\n      if (err) throw err;\n      expect(args).to.eql([0, \"a\", 1, \"b\"]);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfLimit with Map (iterators)",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 402,
                "column": 41
            },
            "line": 402,
            "code": "  it('forEachOfLimit with Map (iterators)', function (done) {\n    if (typeof Map !== 'function') return done();\n    var args = [];\n    var map = new Map();\n    map.set(1, \"a\");\n    map.set(2, \"b\");\n    async.forEachOfLimit(map, 1, forEachOfIteratee.bind(this, args), err => {\n      if (err) throw err;\n      expect(args).to.eql([0, [1, \"a\"], 1, [2, \"b\"]]);\n      done();\n    });\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfLimit canceled",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 414,
                "column": 29
            },
            "line": 414,
            "code": "  it('forEachOfLimit canceled', done => {\n    var obj = {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4,\n      e: 5\n    };\n    var call_order = [];\n    async.forEachOfLimit(obj, 3, (value, key, callback) => {\n      call_order.push(value, key);\n\n      if (value === 2) {\n        return callback(false);\n      }\n\n      callback();\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, \"a\", 2, \"b\"]);\n      done();\n    }, 10);\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfLimit canceled (async)",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 439,
                "column": 37
            },
            "line": 439,
            "code": "  it('forEachOfLimit canceled (async)', done => {\n    var obj = {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4,\n      e: 5\n    };\n    var call_order = [];\n    async.forEachOfLimit(obj, 3, (value, key, callback) => {\n      call_order.push(value, key);\n      setTimeout(() => {\n        if (value === 2) {\n          return callback(false);\n        }\n\n        callback();\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\"]);\n      done();\n    }, 20);\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachOfLimit canceled (async, array)",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 465,
                "column": 41
            },
            "line": 465,
            "code": "  it('eachOfLimit canceled (async, array)', done => {\n    var obj = ['a', 'b', 'c', 'd', 'e'];\n    var call_order = [];\n    async.eachOfLimit(obj, 3, (value, key, callback) => {\n      call_order.push(key, value);\n      setTimeout(() => {\n        if (value === 'b') {\n          return callback(false);\n        }\n\n        callback();\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([0, \"a\", 1, \"b\", 2, \"c\", 3, \"d\"]);\n      done();\n    }, 20);\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "eachOf canceled (async, array)",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 485,
                "column": 36
            },
            "line": 485,
            "code": "  it('eachOf canceled (async, array)', done => {\n    var arr = ['a', 'b', 'c', 'd', 'e'];\n    var call_order = [];\n    async.eachOf(arr, (value, key, callback) => {\n      call_order.push(key, value);\n      setTimeout(() => {\n        if (value === 'b') {\n          return callback(false);\n        }\n\n        callback();\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([0, \"a\", 1, \"b\", 2, \"c\", 3, \"d\", 4, \"e\"]);\n      done();\n    }, 20);\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "forEachOfLimit canceled (async, w/ error)",
            "suites": [
                "eachOf"
            ],
            "updatePoint": {
                "line": 505,
                "column": 47
            },
            "line": 505,
            "code": "  it('forEachOfLimit canceled (async, w/ error)', done => {\n    var obj = {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4,\n      e: 5\n    };\n    var call_order = [];\n    async.forEachOfLimit(obj, 3, (value, key, callback) => {\n      call_order.push(value, key);\n      setTimeout(() => {\n        if (value === 2) {\n          return callback(false);\n        }\n\n        if (value === 3) {\n          return callback('fail');\n        }\n\n        callback();\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, \"a\", 2, \"b\", 3, \"c\", 4, \"d\"]);\n      done();\n    }, 20);\n  });",
            "file": "eachOf.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "defer sync functions",
            "suites": [
                "ensureAsync"
            ],
            "updatePoint": {
                "line": 14,
                "column": 26
            },
            "line": 14,
            "code": "  it('defer sync functions', done => {\n    var sync = true;\n    async.ensureAsync((arg1, arg2, cb) => {\n      expect(arg1).to.equal(1);\n      expect(arg2).to.equal(2);\n      cb(null, 4, 5);\n    })(1, 2, (err, arg4, arg5) => {\n      expect(err).to.equal(null);\n      expect(arg4).to.equal(4);\n      expect(arg5).to.equal(5);\n      assert(!sync, 'callback called on same tick');\n      done();\n    });\n    sync = false;\n  });",
            "file": "ensureAsync.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "do not defer async functions",
            "suites": [
                "ensureAsync"
            ],
            "updatePoint": {
                "line": 29,
                "column": 34
            },
            "line": 29,
            "code": "  it('do not defer async functions', done => {\n    var sync = false;\n    async.ensureAsync((arg1, arg2, cb) => {\n      expect(arg1).to.equal(1);\n      expect(arg2).to.equal(2);\n      async.setImmediate(() => {\n        sync = true;\n        cb(null, 4, 5);\n        sync = false;\n      });\n    })(1, 2, (err, arg4, arg5) => {\n      expect(err).to.equal(null);\n      expect(arg4).to.equal(4);\n      expect(arg5).to.equal(5);\n      assert(sync, 'callback called on next tick');\n      done();\n    });\n  });",
            "file": "ensureAsync.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "double wrapping",
            "suites": [
                "ensureAsync"
            ],
            "updatePoint": {
                "line": 47,
                "column": 21
            },
            "line": 47,
            "code": "  it('double wrapping', done => {\n    var sync = true;\n    async.ensureAsync(async.ensureAsync((arg1, arg2, cb) => {\n      expect(arg1).to.equal(1);\n      expect(arg2).to.equal(2);\n      cb(null, 4, 5);\n    }))(1, 2, (err, arg4, arg5) => {\n      expect(err).to.equal(null);\n      expect(arg4).to.equal(4);\n      expect(arg5).to.equal(5);\n      assert(!sync, 'callback called on same tick');\n      done();\n    });\n    sync = false;\n  });",
            "file": "ensureAsync.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should propely bind context to the wrapped function",
            "suites": [
                "ensureAsync"
            ],
            "updatePoint": {
                "line": 62,
                "column": 57
            },
            "line": 62,
            "code": "  it('should propely bind context to the wrapped function', done => {\n    // call bind after wrapping with ensureAsync\n    var context = {\n      context: \"post\"\n    };\n    var postBind = async.ensureAsync(passContext);\n    postBind = postBind.bind(context);\n    postBind(ref => {\n      expect(ref).to.equal(context);\n      done();\n    });\n  });",
            "file": "ensureAsync.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not override the bound context of a function when wrapping",
            "suites": [
                "ensureAsync"
            ],
            "updatePoint": {
                "line": 74,
                "column": 71
            },
            "line": 74,
            "code": "  it('should not override the bound context of a function when wrapping', done => {\n    // call bind before wrapping with ensureAsync\n    var context = {\n      context: \"pre\"\n    };\n    var preBind = passContext.bind(context);\n    preBind = async.ensureAsync(preBind);\n    preBind(ref => {\n      expect(ref).to.equal(context);\n      done();\n    });\n  });",
            "file": "ensureAsync.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should asyncify async functions",
            "suites": [],
            "updatePoint": {
                "line": 22,
                "column": 37
            },
            "line": 22,
            "code": "  it('should asyncify async functions', done => {\n    async.asyncify(asyncIdentity)(42, (err, val) => {\n      assert(val === 42);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle errors in async functions",
            "suites": [],
            "updatePoint": {
                "line": 28,
                "column": 45
            },
            "line": 28,
            "code": "  it('should handle errors in async functions', done => {\n    async.asyncify(async () => {\n      throw new Error('thrown error');\n    })(err => {\n      assert(err.message = 'thrown error');\n      done();\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in each",
            "suites": [],
            "updatePoint": {
                "line": 40,
                "column": 43
            },
            "line": 40,
            "code": "  it('should handle async functions in each', done => {\n    async.each(input, asyncIdentity, done);\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in eachLimit",
            "suites": [],
            "updatePoint": {
                "line": 43,
                "column": 48
            },
            "line": 43,
            "code": "  it('should handle async functions in eachLimit', done => {\n    async.eachLimit(input, 2, asyncIdentity, done);\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in eachSeries",
            "suites": [],
            "updatePoint": {
                "line": 46,
                "column": 49
            },
            "line": 46,
            "code": "  it('should handle async functions in eachSeries', done => {\n    async.eachSeries(input, asyncIdentity, done);\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in eachOf",
            "suites": [],
            "updatePoint": {
                "line": 49,
                "column": 45
            },
            "line": 49,
            "code": "  it('should handle async functions in eachOf', done => {\n    async.eachOf(input, asyncIdentity, done);\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in eachOfLimit",
            "suites": [],
            "updatePoint": {
                "line": 52,
                "column": 50
            },
            "line": 52,
            "code": "  it('should handle async functions in eachOfLimit', done => {\n    async.eachOfLimit(input, 2, asyncIdentity, done);\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in eachOfSeries",
            "suites": [],
            "updatePoint": {
                "line": 55,
                "column": 51
            },
            "line": 55,
            "code": "  it('should handle async functions in eachOfSeries', done => {\n    async.eachOfSeries(input, asyncIdentity, done);\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in map",
            "suites": [],
            "updatePoint": {
                "line": 58,
                "column": 42
            },
            "line": 58,
            "code": "  it('should handle async functions in map', done => {\n    async.map(input, asyncIdentity, (err, result) => {\n      expect(result).to.eql(input);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in mapLimit",
            "suites": [],
            "updatePoint": {
                "line": 64,
                "column": 47
            },
            "line": 64,
            "code": "  it('should handle async functions in mapLimit', done => {\n    async.mapLimit(input, 2, asyncIdentity, (err, result) => {\n      expect(result).to.eql(input);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in mapSeries",
            "suites": [],
            "updatePoint": {
                "line": 70,
                "column": 48
            },
            "line": 70,
            "code": "  it('should handle async functions in mapSeries', done => {\n    async.mapSeries(input, asyncIdentity, (err, result) => {\n      expect(result).to.eql(input);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in mapValues",
            "suites": [],
            "updatePoint": {
                "line": 76,
                "column": 48
            },
            "line": 76,
            "code": "  it('should handle async functions in mapValues', done => {\n    async.mapValues(inputObj, asyncIdentity, (err, result) => {\n      expect(result).to.eql(inputObj);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in mapValuesLimit",
            "suites": [],
            "updatePoint": {
                "line": 82,
                "column": 53
            },
            "line": 82,
            "code": "  it('should handle async functions in mapValuesLimit', done => {\n    async.mapValuesLimit(inputObj, 2, asyncIdentity, (err, result) => {\n      expect(result).to.eql(inputObj);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in mapValuesSeries",
            "suites": [],
            "updatePoint": {
                "line": 88,
                "column": 54
            },
            "line": 88,
            "code": "  it('should handle async functions in mapValuesSeries', done => {\n    async.mapValuesSeries(inputObj, asyncIdentity, (err, result) => {\n      expect(result).to.eql(inputObj);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in filter",
            "suites": [],
            "updatePoint": {
                "line": 94,
                "column": 45
            },
            "line": 94,
            "code": "  it('should handle async functions in filter', done => {\n    async.filter(input, asyncIdentity, (err, result) => {\n      expect(result).to.eql(input);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in filterLimit",
            "suites": [],
            "updatePoint": {
                "line": 100,
                "column": 50
            },
            "line": 100,
            "code": "  it('should handle async functions in filterLimit', done => {\n    async.filterLimit(input, 2, asyncIdentity, (err, result) => {\n      expect(result).to.eql(input);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in filterSeries",
            "suites": [],
            "updatePoint": {
                "line": 106,
                "column": 51
            },
            "line": 106,
            "code": "  it('should handle async functions in filterSeries', done => {\n    async.filterSeries(input, asyncIdentity, (err, result) => {\n      expect(result).to.eql(input);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in reject",
            "suites": [],
            "updatePoint": {
                "line": 112,
                "column": 45
            },
            "line": 112,
            "code": "  it('should handle async functions in reject', done => {\n    async.reject(input, asyncIdentity, (err, result) => {\n      expect(result).to.eql([]);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in rejectLimit",
            "suites": [],
            "updatePoint": {
                "line": 118,
                "column": 50
            },
            "line": 118,
            "code": "  it('should handle async functions in rejectLimit', done => {\n    async.rejectLimit(input, 2, asyncIdentity, (err, result) => {\n      expect(result).to.eql([]);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in rejectSeries",
            "suites": [],
            "updatePoint": {
                "line": 124,
                "column": 51
            },
            "line": 124,
            "code": "  it('should handle async functions in rejectSeries', done => {\n    async.rejectSeries(input, asyncIdentity, (err, result) => {\n      expect(result).to.eql([]);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in every",
            "suites": [],
            "updatePoint": {
                "line": 130,
                "column": 44
            },
            "line": 130,
            "code": "  it('should handle async functions in every', done => {\n    async.every(input, asyncIdentity, (err, result) => {\n      expect(result).to.eql(true);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in everyLimit",
            "suites": [],
            "updatePoint": {
                "line": 136,
                "column": 49
            },
            "line": 136,
            "code": "  it('should handle async functions in everyLimit', done => {\n    async.everyLimit(input, 2, asyncIdentity, (err, result) => {\n      expect(result).to.eql(true);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in everySeries",
            "suites": [],
            "updatePoint": {
                "line": 142,
                "column": 50
            },
            "line": 142,
            "code": "  it('should handle async functions in everySeries', done => {\n    async.everySeries(input, asyncIdentity, (err, result) => {\n      expect(result).to.eql(true);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in some",
            "suites": [],
            "updatePoint": {
                "line": 148,
                "column": 43
            },
            "line": 148,
            "code": "  it('should handle async functions in some', done => {\n    async.some(input, asyncIdentity, (err, result) => {\n      expect(result).to.eql(true);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in someLimit",
            "suites": [],
            "updatePoint": {
                "line": 154,
                "column": 48
            },
            "line": 154,
            "code": "  it('should handle async functions in someLimit', done => {\n    async.someLimit(input, 2, asyncIdentity, (err, result) => {\n      expect(result).to.eql(true);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in someSeries",
            "suites": [],
            "updatePoint": {
                "line": 160,
                "column": 49
            },
            "line": 160,
            "code": "  it('should handle async functions in someSeries', done => {\n    async.someSeries(input, asyncIdentity, (err, result) => {\n      expect(result).to.eql(true);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in groupBy",
            "suites": [],
            "updatePoint": {
                "line": 166,
                "column": 46
            },
            "line": 166,
            "code": "  it('should handle async functions in groupBy', done => {\n    async.groupBy(input, asyncIdentity, (err, result) => {\n      expect(result).to.eql({\n        1: [1],\n        2: [2],\n        3: [3]\n      });\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in groupByLimit",
            "suites": [],
            "updatePoint": {
                "line": 176,
                "column": 51
            },
            "line": 176,
            "code": "  it('should handle async functions in groupByLimit', done => {\n    async.groupByLimit(input, 2, asyncIdentity, (err, result) => {\n      expect(result).to.eql({\n        1: [1],\n        2: [2],\n        3: [3]\n      });\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in groupBySeries",
            "suites": [],
            "updatePoint": {
                "line": 186,
                "column": 52
            },
            "line": 186,
            "code": "  it('should handle async functions in groupBySeries', done => {\n    async.groupBySeries(input, asyncIdentity, (err, result) => {\n      expect(result).to.eql({\n        1: [1],\n        2: [2],\n        3: [3]\n      });\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in concat",
            "suites": [],
            "updatePoint": {
                "line": 196,
                "column": 45
            },
            "line": 196,
            "code": "  it('should handle async functions in concat', done => {\n    async.concat(input, asyncIdentity, (err, result) => {\n      expect(result).to.eql(input);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in concatLimit",
            "suites": [],
            "updatePoint": {
                "line": 202,
                "column": 50
            },
            "line": 202,
            "code": "  it('should handle async functions in concatLimit', done => {\n    async.concatLimit(input, 2, asyncIdentity, (err, result) => {\n      expect(err).to.eql(null);\n      expect(result).to.eql(input);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in concatSeries",
            "suites": [],
            "updatePoint": {
                "line": 209,
                "column": 51
            },
            "line": 209,
            "code": "  it('should handle async functions in concatSeries', done => {\n    async.concatSeries(input, asyncIdentity, (err, result) => {\n      expect(result).to.eql(input);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in reduce",
            "suites": [],
            "updatePoint": {
                "line": 215,
                "column": 45
            },
            "line": 215,
            "code": "  it('should handle async functions in reduce', done => {\n    async.reduce(input, 0, async (acc, val) => {\n      var res = await Promise.resolve(acc + val);\n      return res;\n    }, (err, result) => {\n      expect(result).to.eql(6);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in reduceRight",
            "suites": [],
            "updatePoint": {
                "line": 224,
                "column": 50
            },
            "line": 224,
            "code": "  it('should handle async functions in reduceRight', done => {\n    async.reduceRight(input, 0, async (acc, val) => {\n      var res = await Promise.resolve(acc + val);\n      return res;\n    }, (err, result) => {\n      expect(result).to.eql(6);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in sortBy",
            "suites": [],
            "updatePoint": {
                "line": 233,
                "column": 45
            },
            "line": 233,
            "code": "  it('should handle async functions in sortBy', done => {\n    async.sortBy([3, 2, 1], asyncIdentity, (err, result) => {\n      expect(result).to.eql(input);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in transform",
            "suites": [],
            "updatePoint": {
                "line": 239,
                "column": 48
            },
            "line": 239,
            "code": "  it('should handle async functions in transform', done => {\n    async.transform(inputObj, async (obj, val, key) => {\n      obj[key] = await Promise.resolve(val);\n    }, (err, result) => {\n      expect(result).to.eql(inputObj);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in applyEach",
            "suites": [],
            "updatePoint": {
                "line": 251,
                "column": 48
            },
            "line": 251,
            "code": "  it('should handle async functions in applyEach', done => {\n    async.applyEach([asyncIdentity, asyncIdentity], input)((err, result) => {\n      expect(result).to.eql([input, input]);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in applyEachSeries",
            "suites": [],
            "updatePoint": {
                "line": 257,
                "column": 54
            },
            "line": 257,
            "code": "  it('should handle async functions in applyEachSeries', done => {\n    async.applyEachSeries([asyncIdentity, asyncIdentity], input)((err, result) => {\n      expect(result).to.eql([input, input]);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in auto",
            "suites": [],
            "updatePoint": {
                "line": 263,
                "column": 43
            },
            "line": 263,
            "code": "  it('should handle async functions in auto', done => {\n    async.auto({\n      async a() {\n        return await Promise.resolve(1);\n      },\n\n      async b() {\n        return await Promise.resolve(2);\n      },\n\n      c: ['a', 'b', async function (results) {\n        return await Promise.resolve(results.a + results.b);\n      }]\n    }, (err, result) => {\n      expect(result).to.eql({\n        a: 1,\n        b: 2,\n        c: 3\n      });\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in autoInject",
            "suites": [],
            "updatePoint": {
                "line": 287,
                "column": 49
            },
            "line": 287,
            "code": "  it('should handle async functions in autoInject', done => {\n    async.autoInject({\n      z: async function () {\n        return 0;\n      },\n      a: async function () {\n        return 1;\n      },\n      b: function (a, next) {\n        next(null, a + 1);\n      },\n\n      async c(a, b) {\n        return await Promise.resolve(a + b);\n      },\n\n      d: async c => {\n        return await Promise.resolve(c + 1);\n      }\n    }, (err, result) => {\n      expect(result).to.eql({\n        z: 0,\n        a: 1,\n        b: 2,\n        c: 3,\n        d: 4\n      });\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in autoInject (shorthand)",
            "suites": [],
            "updatePoint": {
                "line": 317,
                "column": 61
            },
            "line": 317,
            "code": "  it('should handle async functions in autoInject (shorthand)', done => {\n    async.autoInject({\n      async a() {\n        return await Promise.resolve(1);\n      },\n\n      async b(a) {\n        return await Promise.resolve(a + 1);\n      },\n\n      async c(a, b) {\n        return await Promise.resolve(a + b);\n      },\n\n      async d(c) {\n        return await Promise.resolve(c + 1);\n      }\n\n    }, (err, result) => {\n      expect(result).to.eql({\n        a: 1,\n        b: 2,\n        c: 3,\n        d: 4\n      });\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in cargo",
            "suites": [],
            "updatePoint": {
                "line": 345,
                "column": 44
            },
            "line": 345,
            "code": "  it('should handle async functions in cargo', done => {\n    var result = [];\n    var q = async.cargo(async val => {\n      result.push(await Promise.resolve(val));\n    }, 2);\n    q.drain(() => {\n      expect(result).to.eql([[1, 2], [3]]);\n      done();\n    });\n    q.push(1);\n    q.push(2);\n    q.push(3);\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in queue",
            "suites": [],
            "updatePoint": {
                "line": 358,
                "column": 44
            },
            "line": 358,
            "code": "  it('should handle async functions in queue', done => {\n    var result = [];\n    var q = async.queue(async val => {\n      result.push(await Promise.resolve(val));\n    }, 2);\n    q.drain(() => {\n      expect(result).to.eql([1, 2, 3]);\n      done();\n    });\n    q.push(1);\n    q.push(2);\n    q.push(3);\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in priorityQueue",
            "suites": [],
            "updatePoint": {
                "line": 371,
                "column": 52
            },
            "line": 371,
            "code": "  it('should handle async functions in priorityQueue', done => {\n    var result = [];\n    var q = async.priorityQueue(async val => {\n      result.push(await Promise.resolve(val));\n    }, 2);\n    q.drain(() => {\n      expect(result).to.eql([1, 2, 3]);\n      done();\n    });\n    q.push(1);\n    q.push(2);\n    q.push(3);\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in compose",
            "suites": [],
            "updatePoint": {
                "line": 384,
                "column": 46
            },
            "line": 384,
            "code": "  it('should handle async functions in compose', done => {\n    async.compose(async a => a + 1, async a => a + 1, async a => a + 1)(0, (err, result) => {\n      expect(result).to.equal(3);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in seq",
            "suites": [],
            "updatePoint": {
                "line": 390,
                "column": 42
            },
            "line": 390,
            "code": "  it('should handle async functions in seq', done => {\n    async.seq(async a => a + 1, async a => a + 1, async a => a + 1)(0, (err, result) => {\n      expect(result).to.equal(3);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in whilst",
            "suites": [],
            "updatePoint": {
                "line": 396,
                "column": 45
            },
            "line": 396,
            "code": "  it('should handle async functions in whilst', done => {\n    var val = 0;\n    async.whilst(async () => val < 3, async () => {\n      val += 1;\n      return val;\n    }, done);\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in doWhilst",
            "suites": [],
            "updatePoint": {
                "line": 403,
                "column": 47
            },
            "line": 403,
            "code": "  it('should handle async functions in doWhilst', done => {\n    var val = 0;\n    async.doWhilst(async () => {\n      val += 1;\n      return val;\n    }, async res => res < 3, done);\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in until",
            "suites": [],
            "updatePoint": {
                "line": 410,
                "column": 44
            },
            "line": 410,
            "code": "  it('should handle async functions in until', done => {\n    var val = 0;\n    async.until(async () => val > 3, async () => {\n      val += 1;\n      return val;\n    }, done);\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in doUntil",
            "suites": [],
            "updatePoint": {
                "line": 417,
                "column": 46
            },
            "line": 417,
            "code": "  it('should handle async functions in doUntil', done => {\n    var val = 0;\n    async.doUntil(async () => {\n      val += 1;\n      return val;\n    }, async res => res > 3, done);\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in forever",
            "suites": [],
            "updatePoint": {
                "line": 424,
                "column": 46
            },
            "line": 424,
            "code": "  it('should handle async functions in forever', done => {\n    var counter = 0;\n    async.forever(async () => {\n      counter += 1;\n      if (counter > 10) throw new Error('too big');\n    }, err => {\n      expect(err.message).to.equal('too big');\n      done();\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in parallel",
            "suites": [],
            "updatePoint": {
                "line": 434,
                "column": 47
            },
            "line": 434,
            "code": "  it('should handle async functions in parallel', done => {\n    async.parallel([async () => 1, async () => 2, async () => 3], (err, result) => {\n      expect(result).to.eql([1, 2, 3]);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in parallel (object)",
            "suites": [],
            "updatePoint": {
                "line": 440,
                "column": 56
            },
            "line": 440,
            "code": "  it('should handle async functions in parallel (object)', done => {\n    async.parallel({\n      a: async () => 1,\n      b: async () => 2,\n      c: async () => 3\n    }, (err, result) => {\n      expect(result).to.eql({\n        a: 1,\n        b: 2,\n        c: 3\n      });\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in parallelLimit",
            "suites": [],
            "updatePoint": {
                "line": 454,
                "column": 52
            },
            "line": 454,
            "code": "  it('should handle async functions in parallelLimit', done => {\n    async.parallelLimit([async () => 1, async () => 2, async () => 3], 2, (err, result) => {\n      expect(result).to.eql([1, 2, 3]);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in parallelLimit (object)",
            "suites": [],
            "updatePoint": {
                "line": 460,
                "column": 61
            },
            "line": 460,
            "code": "  it('should handle async functions in parallelLimit (object)', done => {\n    async.parallelLimit({\n      a: async () => 1,\n      b: async () => 2,\n      c: async () => 3\n    }, 2, (err, result) => {\n      expect(result).to.eql({\n        a: 1,\n        b: 2,\n        c: 3\n      });\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in series",
            "suites": [],
            "updatePoint": {
                "line": 474,
                "column": 45
            },
            "line": 474,
            "code": "  it('should handle async functions in series', done => {\n    async.series([async () => 1, async () => 2, async () => 3], (err, result) => {\n      expect(result).to.eql([1, 2, 3]);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in series (object)",
            "suites": [],
            "updatePoint": {
                "line": 480,
                "column": 54
            },
            "line": 480,
            "code": "  it('should handle async functions in series (object)', done => {\n    async.series({\n      a: async () => 1,\n      b: async () => 2,\n      c: async () => 3\n    }, (err, result) => {\n      expect(result).to.eql({\n        a: 1,\n        b: 2,\n        c: 3\n      });\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in race",
            "suites": [],
            "updatePoint": {
                "line": 494,
                "column": 43
            },
            "line": 494,
            "code": "  it('should handle async functions in race', done => {\n    async.race([async () => 1, async () => 2, async () => 3], (err, result) => {\n      expect(result).to.eql(1);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in retry",
            "suites": [],
            "updatePoint": {
                "line": 500,
                "column": 44
            },
            "line": 500,
            "code": "  it('should handle async functions in retry', done => {\n    var count = 0;\n    async.retry(4, async () => {\n      count += 1;\n      if (count < 3) throw new Error('fail');\n      return count;\n    }, (err, result) => {\n      expect(result).to.eql(3);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in retryable",
            "suites": [],
            "updatePoint": {
                "line": 511,
                "column": 48
            },
            "line": 511,
            "code": "  it('should handle async functions in retryable', done => {\n    var count = 0;\n    async.retryable(4, async () => {\n      count += 1;\n      if (count < 3) throw new Error('fail');\n      return count;\n    })((err, result) => {\n      expect(result).to.eql(3);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in times",
            "suites": [],
            "updatePoint": {
                "line": 522,
                "column": 44
            },
            "line": 522,
            "code": "  it('should handle async functions in times', done => {\n    var count = 0;\n    async.times(4, async () => {\n      count += 1;\n      return count;\n    }, (err, result) => {\n      expect(result).to.eql([1, 2, 3, 4]);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in timesLimit",
            "suites": [],
            "updatePoint": {
                "line": 532,
                "column": 49
            },
            "line": 532,
            "code": "  it('should handle async functions in timesLimit', done => {\n    var count = 0;\n    async.timesLimit(4, 2, async () => {\n      count += 1;\n      return count;\n    }, (err, result) => {\n      expect(result).to.eql([1, 2, 3, 4]);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in timesSeries",
            "suites": [],
            "updatePoint": {
                "line": 542,
                "column": 50
            },
            "line": 542,
            "code": "  it('should handle async functions in timesSeries', done => {\n    var count = 0;\n    async.timesSeries(4, async () => {\n      count += 1;\n      return count;\n    }, (err, result) => {\n      expect(result).to.eql([1, 2, 3, 4]);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in waterfall",
            "suites": [],
            "updatePoint": {
                "line": 552,
                "column": 48
            },
            "line": 552,
            "code": "  it('should handle async functions in waterfall', done => {\n    async.waterfall([async () => 1, async a => a + 1, async a => [a, a + 1], async ([a, b]) => a + b], (err, result) => {\n      expect(result).to.eql(5);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functons in tryEach",
            "suites": [],
            "updatePoint": {
                "line": 558,
                "column": 45
            },
            "line": 558,
            "code": "  it('should handle async functons in tryEach', done => {\n    async.tryEach([async () => {\n      throw new Error('fail1');\n    }, async () => {\n      throw new Error('fail2');\n    }, async () => 5, async () => {\n      throw new Error('shoult not get here');\n    }], (err, result) => {\n      expect(result).to.eql(5);\n      done();\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in dir",
            "suites": [],
            "updatePoint": {
                "line": 574,
                "column": 42
            },
            "line": 574,
            "code": "  it('should handle async functions in dir', done => {\n    async.dir(async val => val, 'foo');\n    setTimeout(done);\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in log",
            "suites": [],
            "updatePoint": {
                "line": 578,
                "column": 42
            },
            "line": 578,
            "code": "  it('should handle async functions in log', done => {\n    async.log(async val => val, 'foo');\n    setTimeout(done);\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in ensureAsync",
            "suites": [],
            "updatePoint": {
                "line": 582,
                "column": 50
            },
            "line": 582,
            "code": "  it('should handle async functions in ensureAsync', () => {\n    var fn = async.ensureAsync(asyncIdentity);\n    assert(fn === asyncIdentity);\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in memoize",
            "suites": [],
            "updatePoint": {
                "line": 586,
                "column": 46
            },
            "line": 586,
            "code": "  it('should handle async functions in memoize', done => {\n    var fn = async.memoize(asyncIdentity);\n    fn(1, () => {\n      fn(1, done);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in reflect",
            "suites": [],
            "updatePoint": {
                "line": 592,
                "column": 46
            },
            "line": 592,
            "code": "  it('should handle async functions in reflect', done => {\n    var fn = async.reflect(asyncIdentity);\n    fn(1, (err, result) => {\n      expect(result).to.eql({\n        value: 1\n      });\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in reflect (error case)",
            "suites": [],
            "updatePoint": {
                "line": 601,
                "column": 59
            },
            "line": 601,
            "code": "  it('should handle async functions in reflect (error case)', done => {\n    var thrown;\n    var fn = async.reflect(async () => {\n      thrown = new Error('foo');\n      throw thrown;\n    });\n    fn(1, (err, result) => {\n      expect(result).to.eql({\n        error: thrown,\n        value: undefined\n      });\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in timeout",
            "suites": [],
            "updatePoint": {
                "line": 615,
                "column": 46
            },
            "line": 615,
            "code": "  it('should handle async functions in timeout', done => {\n    var fn = async.timeout(asyncIdentity, 50);\n    fn(1, (err, result) => {\n      expect(result).to.eql(1);\n      done(err);\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async functions in timeout (error case)",
            "suites": [],
            "updatePoint": {
                "line": 622,
                "column": 59
            },
            "line": 622,
            "code": "  it('should handle async functions in timeout (error case)', done => {\n    var fn = async.timeout(async val => {\n      await new Promise(resolve => setTimeout(resolve, 100));\n      return val;\n    }, 20);\n    fn(1, err => {\n      expect(err.message).to.match(/timed out/);\n      done();\n    });\n  });",
            "file": "es2017/asyncFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async generators in each",
            "suites": [],
            "updatePoint": {
                "line": 35,
                "column": 44
            },
            "line": 35,
            "code": "  it('should handle async generators in each', done => {\n    const calls = [];\n    async.each(range(5), async val => {\n      calls.push(val);\n      await delay(1);\n    }, err => {\n      if (err) throw err;\n      expect(calls).to.eql([0, 1, 2, 3, 4]);\n      done();\n    });\n  });",
            "file": "es2017/asyncGenerators.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async generators in eachLimit",
            "suites": [],
            "updatePoint": {
                "line": 46,
                "column": 49
            },
            "line": 46,
            "code": "  it('should handle async generators in eachLimit', done => {\n    const calls = [];\n    async.eachLimit(range(5), 2, async val => {\n      calls.push(val);\n      await delay(5);\n    }, err => {\n      if (err) throw err;\n      expect(calls).to.eql([0, 1, 2, 3, 4]);\n      done();\n    });\n  });",
            "file": "es2017/asyncGenerators.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async generators in eachSeries",
            "suites": [],
            "updatePoint": {
                "line": 57,
                "column": 50
            },
            "line": 57,
            "code": "  it('should handle async generators in eachSeries', done => {\n    const calls = [];\n    async.eachSeries(range(5), async val => {\n      calls.push(val);\n      await delay(5);\n    }, err => {\n      if (err) throw err;\n      expect(calls).to.eql([0, 1, 2, 3, 4]);\n      done();\n    });\n  });",
            "file": "es2017/asyncGenerators.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async iterables in each",
            "suites": [],
            "updatePoint": {
                "line": 68,
                "column": 43
            },
            "line": 68,
            "code": "  it('should handle async iterables in each', done => {\n    const calls = [];\n    async.each(new AsyncIterable(5), async val => {\n      calls.push(val);\n      await delay(5);\n    }, err => {\n      if (err) throw err;\n      expect(calls).to.eql([0, 1, 2, 3, 4]);\n      done();\n    });\n  });",
            "file": "es2017/asyncGenerators.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async iterables in each (errors)",
            "suites": [],
            "updatePoint": {
                "line": 79,
                "column": 52
            },
            "line": 79,
            "code": "  it('should handle async iterables in each (errors)', done => {\n    const calls = [];\n    async.each(new AsyncIterable(5), async val => {\n      calls.push(val);\n      if (val === 3) throw new Error('fail');\n      await delay(5);\n    }, err => {\n      expect(err.message).to.equal('fail');\n      expect(calls).to.eql([0, 1, 2, 3]);\n      done();\n    });\n  });",
            "file": "es2017/asyncGenerators.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should handle async iterables in each (cancelled)",
            "suites": [],
            "updatePoint": {
                "line": 91,
                "column": 55
            },
            "line": 91,
            "code": "  it('should handle async iterables in each (cancelled)', async () => {\n    const calls = [];\n    async.each(new AsyncIterable(5), (val, cb) => {\n      calls.push(val);\n      if (val === 2) cb(false);\n      cb();\n    }, () => {\n      throw new Error('should not get here');\n    });\n    await delay(20);\n    expect(calls).to.eql([0, 1, 2]);\n  });",
            "file": "es2017/asyncGenerators.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "asyncify should not add an additional level of wrapping",
            "suites": [],
            "updatePoint": {
                "line": 23,
                "column": 61
            },
            "line": 23,
            "code": "  it('asyncify should not add an additional level of wrapping', () => {\n    const wrapped = wrapAsync(async.each);\n    let sameStack = false;\n    wrapped([1], (val, cb) => cb(), () => {\n      sameStack = true;\n    });\n    expect(sameStack).to.equal(true);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should throw as expected (async)",
            "suites": [],
            "updatePoint": {
                "line": 31,
                "column": 38
            },
            "line": 31,
            "code": "  it('should throw as expected (async)', async () => {\n    try {\n      await async.each(input, async val => {\n        throw new Error(val);\n      });\n    } catch (e) {\n      var thrown = e;\n    }\n\n    expect(thrown).to.be.an('error');\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should throw as expected (callback)",
            "suites": [],
            "updatePoint": {
                "line": 42,
                "column": 41
            },
            "line": 42,
            "code": "  it('should throw as expected (callback)', async () => {\n    let thrown;\n    await async.each(input, val => {\n      throw new Error(val);\n    }).catch(e => {\n      thrown = e;\n    });\n    expect(thrown).to.be.an('error');\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should throw as expected (callback, try/catch)",
            "suites": [],
            "updatePoint": {
                "line": 51,
                "column": 52
            },
            "line": 51,
            "code": "  it('should throw as expected (callback, try/catch)', async () => {\n    try {\n      await async.each(input, (val, cb) => {\n        cb(new Error(val));\n      });\n    } catch (e) {\n      var thrown = e;\n    }\n\n    expect(thrown).to.be.an('error');\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: each",
            "suites": [],
            "updatePoint": {
                "line": 66,
                "column": 35
            },
            "line": 66,
            "code": "  it('should return a Promise: each', async () => {\n    const calls = [];\n    await async.each(input, async val => {\n      calls.push(val);\n    });\n    expect(calls).to.eql([1, 2, 3]);\n    expect(async.each(input, asyncIdentity) instanceof Promise).to.equal(true);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: eachSeries",
            "suites": [],
            "updatePoint": {
                "line": 74,
                "column": 41
            },
            "line": 74,
            "code": "  it('should return a Promise: eachSeries', async () => {\n    const calls = [];\n    await async.eachSeries(input, async val => {\n      calls.push(val);\n    });\n    expect(calls).to.eql([1, 2, 3]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: eachLimit",
            "suites": [],
            "updatePoint": {
                "line": 81,
                "column": 40
            },
            "line": 81,
            "code": "  it('should return a Promise: eachLimit', async () => {\n    const calls = [];\n    await async.eachLimit(input, 1, async val => {\n      calls.push(val);\n    });\n    expect(calls).to.eql([1, 2, 3]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: eachOf",
            "suites": [],
            "updatePoint": {
                "line": 88,
                "column": 37
            },
            "line": 88,
            "code": "  it('should return a Promise: eachOf', async () => {\n    const calls = [];\n    await async.eachOf(inputObj, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1, 'a'], [2, 'b'], [3, 'c']]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: eachOfSeries",
            "suites": [],
            "updatePoint": {
                "line": 95,
                "column": 43
            },
            "line": 95,
            "code": "  it('should return a Promise: eachOfSeries', async () => {\n    const calls = [];\n    await async.eachOfSeries(inputObj, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1, 'a'], [2, 'b'], [3, 'c']]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: eachOfLimit",
            "suites": [],
            "updatePoint": {
                "line": 102,
                "column": 42
            },
            "line": 102,
            "code": "  it('should return a Promise: eachOfLimit', async () => {\n    const calls = [];\n    await async.eachOfLimit(inputObj, 1, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1, 'a'], [2, 'b'], [3, 'c']]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: concat",
            "suites": [],
            "updatePoint": {
                "line": 109,
                "column": 37
            },
            "line": 109,
            "code": "  it('should return a Promise: concat', async () => {\n    const calls = [];\n    await async.concat(inputObj, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: concatSeries",
            "suites": [],
            "updatePoint": {
                "line": 116,
                "column": 43
            },
            "line": 116,
            "code": "  it('should return a Promise: concatSeries', async () => {\n    const calls = [];\n    await async.concatSeries(inputObj, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: concatLimit",
            "suites": [],
            "updatePoint": {
                "line": 123,
                "column": 42
            },
            "line": 123,
            "code": "  it('should return a Promise: concatLimit', async () => {\n    const calls = [];\n    await async.concatLimit(inputObj, 1, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: detect",
            "suites": [],
            "updatePoint": {
                "line": 130,
                "column": 37
            },
            "line": 130,
            "code": "  it('should return a Promise: detect', async () => {\n    const calls = [];\n    await async.detect(input, async (...args) => {\n      calls.push(args);\n      return args[0] === 3;\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: detectSeries",
            "suites": [],
            "updatePoint": {
                "line": 138,
                "column": 43
            },
            "line": 138,
            "code": "  it('should return a Promise: detectSeries', async () => {\n    const calls = [];\n    await async.detectSeries(input, async (...args) => {\n      calls.push(args);\n      return args[0] === 3;\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: detectLimit",
            "suites": [],
            "updatePoint": {
                "line": 146,
                "column": 42
            },
            "line": 146,
            "code": "  it('should return a Promise: detectLimit', async () => {\n    const calls = [];\n    await async.detectLimit(input, 1, async (...args) => {\n      calls.push(args);\n      return args[0] === 3;\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: every",
            "suites": [],
            "updatePoint": {
                "line": 154,
                "column": 36
            },
            "line": 154,
            "code": "  it('should return a Promise: every', async () => {\n    const calls = [];\n    await async.every(input, async (...args) => {\n      calls.push(args);\n      return args[0] !== 3;\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: everySeries",
            "suites": [],
            "updatePoint": {
                "line": 162,
                "column": 42
            },
            "line": 162,
            "code": "  it('should return a Promise: everySeries', async () => {\n    const calls = [];\n    await async.everySeries(input, async (...args) => {\n      calls.push(args);\n      return args[0] !== 3;\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: everyLimit",
            "suites": [],
            "updatePoint": {
                "line": 170,
                "column": 41
            },
            "line": 170,
            "code": "  it('should return a Promise: everyLimit', async () => {\n    const calls = [];\n    await async.everyLimit(input, 1, async (...args) => {\n      calls.push(args);\n      return args[0] !== 3;\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: filter",
            "suites": [],
            "updatePoint": {
                "line": 178,
                "column": 37
            },
            "line": 178,
            "code": "  it('should return a Promise: filter', async () => {\n    const calls = [];\n    await async.filter(inputObj, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: filterSeries",
            "suites": [],
            "updatePoint": {
                "line": 185,
                "column": 43
            },
            "line": 185,
            "code": "  it('should return a Promise: filterSeries', async () => {\n    const calls = [];\n    await async.filterSeries(inputObj, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: filterLimit",
            "suites": [],
            "updatePoint": {
                "line": 192,
                "column": 42
            },
            "line": 192,
            "code": "  it('should return a Promise: filterLimit', async () => {\n    const calls = [];\n    await async.filterLimit(inputObj, 1, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: groupBy",
            "suites": [],
            "updatePoint": {
                "line": 199,
                "column": 38
            },
            "line": 199,
            "code": "  it('should return a Promise: groupBy', async () => {\n    const calls = [];\n    await async.groupBy(inputObj, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: groupBySeries",
            "suites": [],
            "updatePoint": {
                "line": 206,
                "column": 44
            },
            "line": 206,
            "code": "  it('should return a Promise: groupBySeries', async () => {\n    const calls = [];\n    await async.groupBySeries(inputObj, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: groupByLimit",
            "suites": [],
            "updatePoint": {
                "line": 213,
                "column": 43
            },
            "line": 213,
            "code": "  it('should return a Promise: groupByLimit', async () => {\n    const calls = [];\n    await async.groupByLimit(inputObj, 1, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: map",
            "suites": [],
            "updatePoint": {
                "line": 220,
                "column": 34
            },
            "line": 220,
            "code": "  it('should return a Promise: map', async () => {\n    const calls = [];\n    await async.map(inputObj, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: mapSeries",
            "suites": [],
            "updatePoint": {
                "line": 227,
                "column": 40
            },
            "line": 227,
            "code": "  it('should return a Promise: mapSeries', async () => {\n    const calls = [];\n    await async.mapSeries(inputObj, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: mapLimit",
            "suites": [],
            "updatePoint": {
                "line": 234,
                "column": 39
            },
            "line": 234,
            "code": "  it('should return a Promise: mapLimit', async () => {\n    const calls = [];\n    await async.mapLimit(inputObj, 1, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: mapValues",
            "suites": [],
            "updatePoint": {
                "line": 241,
                "column": 40
            },
            "line": 241,
            "code": "  it('should return a Promise: mapValues', async () => {\n    const calls = [];\n    await async.mapValues(inputObj, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1, 'a'], [2, 'b'], [3, 'c']]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: mapValuesSeries",
            "suites": [],
            "updatePoint": {
                "line": 248,
                "column": 46
            },
            "line": 248,
            "code": "  it('should return a Promise: mapValuesSeries', async () => {\n    const calls = [];\n    await async.mapValuesSeries(inputObj, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1, 'a'], [2, 'b'], [3, 'c']]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: mapValuesLimit",
            "suites": [],
            "updatePoint": {
                "line": 255,
                "column": 45
            },
            "line": 255,
            "code": "  it('should return a Promise: mapValuesLimit', async () => {\n    const calls = [];\n    await async.mapValuesLimit(inputObj, 1, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1, 'a'], [2, 'b'], [3, 'c']]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: reduce",
            "suites": [],
            "updatePoint": {
                "line": 262,
                "column": 37
            },
            "line": 262,
            "code": "  it('should return a Promise: reduce', async () => {\n    const calls = [];\n    await async.reduce(input, 1, async (...args) => calls.push(args));\n    expect(calls).to.eql([[1, 1], [1, 2], [2, 3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: reduceRight",
            "suites": [],
            "updatePoint": {
                "line": 267,
                "column": 42
            },
            "line": 267,
            "code": "  it('should return a Promise: reduceRight', async () => {\n    const calls = [];\n    await async.reduceRight(input, 1, async (...args) => calls.push(args));\n    expect(calls).to.eql([[1, 3], [1, 2], [2, 1]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: reject",
            "suites": [],
            "updatePoint": {
                "line": 272,
                "column": 37
            },
            "line": 272,
            "code": "  it('should return a Promise: reject', async () => {\n    const calls = [];\n    await async.reject(inputObj, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: rejectSeries",
            "suites": [],
            "updatePoint": {
                "line": 279,
                "column": 43
            },
            "line": 279,
            "code": "  it('should return a Promise: rejectSeries', async () => {\n    const calls = [];\n    await async.rejectSeries(inputObj, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: rejectLimit",
            "suites": [],
            "updatePoint": {
                "line": 286,
                "column": 42
            },
            "line": 286,
            "code": "  it('should return a Promise: rejectLimit', async () => {\n    const calls = [];\n    await async.rejectLimit(inputObj, 1, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: some",
            "suites": [],
            "updatePoint": {
                "line": 293,
                "column": 35
            },
            "line": 293,
            "code": "  it('should return a Promise: some', async () => {\n    const calls = [];\n    await async.some(input, async (...args) => {\n      calls.push(args);\n      return args[0] === 3;\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: someSeries",
            "suites": [],
            "updatePoint": {
                "line": 301,
                "column": 41
            },
            "line": 301,
            "code": "  it('should return a Promise: someSeries', async () => {\n    const calls = [];\n    await async.someSeries(input, async (...args) => {\n      calls.push(args);\n      return args[0] === 3;\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: someLimit",
            "suites": [],
            "updatePoint": {
                "line": 309,
                "column": 40
            },
            "line": 309,
            "code": "  it('should return a Promise: someLimit', async () => {\n    const calls = [];\n    await async.someLimit(input, 1, async (...args) => {\n      calls.push(args);\n      return args[0] === 3;\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: sortBy",
            "suites": [],
            "updatePoint": {
                "line": 317,
                "column": 37
            },
            "line": 317,
            "code": "  it('should return a Promise: sortBy', async () => {\n    const calls = [];\n    await async.sortBy(input, async (...args) => {\n      calls.push(args);\n    });\n    expect(calls).to.eql([[1], [2], [3]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: times",
            "suites": [],
            "updatePoint": {
                "line": 324,
                "column": 36
            },
            "line": 324,
            "code": "  it('should return a Promise: times', async () => {\n    const calls = [];\n    await async.times(3, async (...args) => {\n      calls.push(args);\n      return args[0] === 3;\n    });\n    expect(calls).to.eql([[0], [1], [2]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: timesSeries",
            "suites": [],
            "updatePoint": {
                "line": 332,
                "column": 42
            },
            "line": 332,
            "code": "  it('should return a Promise: timesSeries', async () => {\n    const calls = [];\n    await async.timesSeries(3, async (...args) => {\n      calls.push(args);\n      return args[0] === 3;\n    });\n    expect(calls).to.eql([[0], [1], [2]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: timesLimit",
            "suites": [],
            "updatePoint": {
                "line": 340,
                "column": 41
            },
            "line": 340,
            "code": "  it('should return a Promise: timesLimit', async () => {\n    const calls = [];\n    await async.timesLimit(3, 1, async (...args) => {\n      calls.push(args);\n      return args[0] === 3;\n    });\n    expect(calls).to.eql([[0], [1], [2]]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: transform",
            "suites": [],
            "updatePoint": {
                "line": 348,
                "column": 40
            },
            "line": 348,
            "code": "  it('should return a Promise: transform', async () => {\n    const calls = [];\n    await async.transform(inputObj, 1, async (...args) => calls.push(args));\n    expect(calls).to.eql([[1, 1, 'a'], [1, 2, 'b'], [1, 3, 'c']]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: transform (2 args)",
            "suites": [],
            "updatePoint": {
                "line": 353,
                "column": 49
            },
            "line": 353,
            "code": "  it('should return a Promise: transform (2 args)', async () => {\n    const calls = [];\n    await async.transform(inputObj, async (...args) => calls.push(args));\n    expect(calls).to.eql([[{}, 1, 'a'], [{}, 2, 'b'], [{}, 3, 'c']]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: applyEach",
            "suites": [],
            "updatePoint": {
                "line": 362,
                "column": 40
            },
            "line": 362,
            "code": "  it('should return a Promise: applyEach', async () => {\n    const calls = [];\n    await async.applyEach([async (v, x) => {\n      calls.push(v, x);\n    }, async (v, x) => {\n      calls.push(v, x);\n    }], 5, 6)();\n    expect(calls).to.eql([5, 6, 5, 6]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: applyEachSeries",
            "suites": [],
            "updatePoint": {
                "line": 371,
                "column": 46
            },
            "line": 371,
            "code": "  it('should return a Promise: applyEachSeries', async () => {\n    const calls = [];\n    await async.applyEachSeries([async (v, x) => {\n      calls.push(v, x);\n    }, async (v, x) => {\n      calls.push(v, x);\n    }], 5, 6)();\n    expect(calls).to.eql([5, 6, 5, 6]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: auto",
            "suites": [],
            "updatePoint": {
                "line": 380,
                "column": 35
            },
            "line": 380,
            "code": "  it('should return a Promise: auto', async () => {\n    const calls = [];\n    await async.auto({\n      async a() {\n        calls.push('a');\n        return Promise.resolve('a');\n      },\n\n      b: ['a', 'c', async () => calls.push('b')],\n\n      async c() {\n        await Promise.resolve();\n        calls.push('c');\n        return Promise.resolve('c');\n      }\n\n    });\n    expect(calls).to.eql(['a', 'c', 'b']);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: autoInject",
            "suites": [],
            "updatePoint": {
                "line": 399,
                "column": 41
            },
            "line": 399,
            "code": "  it('should return a Promise: autoInject', async () => {\n    const calls = [];\n    await async.autoInject({\n      async a() {\n        calls.push('a');\n        return 'a';\n      },\n\n      async b(a, c) {\n        calls.push('b');\n        calls.push(a, c);\n      },\n\n      async c() {\n        calls.push('c');\n        return 'c';\n      }\n\n    }, 1);\n    expect(calls).to.eql(['a', 'c', 'b', 'a', 'c']);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: compose",
            "suites": [],
            "updatePoint": {
                "line": 420,
                "column": 38
            },
            "line": 420,
            "code": "  it('should return a Promise: compose', async () => {\n    const calls = [];\n    const fn = async.compose(async (...args) => calls.push('a', args), async (...args) => calls.push('b', args));\n    const result = await fn(1, 2);\n    expect(calls).to.eql(['b', [1, 2], 'a', [2]]);\n    expect(result).to.eql(4);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: seq",
            "suites": [],
            "updatePoint": {
                "line": 427,
                "column": 34
            },
            "line": 427,
            "code": "  it('should return a Promise: seq', async () => {\n    const calls = [];\n    const fn = async.seq(async (...args) => calls.push('a', args), async (...args) => calls.push('b', args));\n    const result = await fn(1, 2);\n    expect(calls).to.eql(['a', [1, 2], 'b', [2]]);\n    expect(result).to.eql(4);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: whilst",
            "suites": [],
            "updatePoint": {
                "line": 434,
                "column": 37
            },
            "line": 434,
            "code": "  it('should return a Promise: whilst', async () => {\n    const calls = [];\n    let counter = 0;\n    await async.whilst(async () => {\n      calls.push('test', counter);\n      return counter < 5;\n    }, async () => {\n      calls.push('fn');\n      counter++;\n    });\n    expect(calls).to.eql(['test', 0, 'fn', 'test', 1, 'fn', 'test', 2, 'fn', 'test', 3, 'fn', 'test', 4, 'fn', 'test', 5]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: until",
            "suites": [],
            "updatePoint": {
                "line": 446,
                "column": 36
            },
            "line": 446,
            "code": "  it('should return a Promise: until', async () => {\n    const calls = [];\n    let counter = 0;\n    await async.until(async () => {\n      calls.push('test', counter);\n      return counter === 5;\n    }, async () => {\n      calls.push('fn');\n      counter++;\n    });\n    expect(calls).to.eql(['test', 0, 'fn', 'test', 1, 'fn', 'test', 2, 'fn', 'test', 3, 'fn', 'test', 4, 'fn', 'test', 5]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: doWhilst",
            "suites": [],
            "updatePoint": {
                "line": 458,
                "column": 39
            },
            "line": 458,
            "code": "  it('should return a Promise: doWhilst', async () => {\n    const calls = [];\n    let counter = 0;\n    await async.doWhilst(async () => {\n      calls.push('fn');\n      counter++;\n    }, async () => {\n      calls.push('test', counter);\n      return counter < 5;\n    });\n    expect(calls).to.eql(['fn', 'test', 1, 'fn', 'test', 2, 'fn', 'test', 3, 'fn', 'test', 4, 'fn', 'test', 5]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: doUntil",
            "suites": [],
            "updatePoint": {
                "line": 470,
                "column": 38
            },
            "line": 470,
            "code": "  it('should return a Promise: doUntil', async () => {\n    const calls = [];\n    let counter = 0;\n    await async.doUntil(async () => {\n      calls.push('fn');\n      counter++;\n    }, async () => {\n      calls.push('test', counter);\n      return counter === 5;\n    });\n    expect(calls).to.eql(['fn', 'test', 1, 'fn', 'test', 2, 'fn', 'test', 3, 'fn', 'test', 4, 'fn', 'test', 5]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: forever",
            "suites": [],
            "updatePoint": {
                "line": 482,
                "column": 38
            },
            "line": 482,
            "code": "  it('should return a Promise: forever', async () => {\n    const calls = [];\n    let counter = 0;\n\n    try {\n      await async.forever(async () => {\n        calls.push(counter);\n        counter++;\n        await Promise.resolve();\n        if (counter === 5) throw new Error();\n      });\n    } catch (e) {\n      var err = e;\n    }\n\n    expect(calls).to.eql([0, 1, 2, 3, 4]);\n    expect(err).to.be.an('error');\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: parallel",
            "suites": [],
            "updatePoint": {
                "line": 500,
                "column": 39
            },
            "line": 500,
            "code": "  it('should return a Promise: parallel', async () => {\n    const calls = [];\n    await async.parallel([async () => {\n      await Promise.resolve();\n      calls.push(1);\n    }, async () => {\n      await Promise.resolve();\n      calls.push(1);\n    }, async () => {\n      await Promise.resolve();\n      calls.push(1);\n    }, async () => {\n      await Promise.resolve();\n      calls.push(1);\n    }]);\n    expect(calls).to.eql([1, 1, 1, 1]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: parallelLimit",
            "suites": [],
            "updatePoint": {
                "line": 517,
                "column": 44
            },
            "line": 517,
            "code": "  it('should return a Promise: parallelLimit', async () => {\n    const calls = [];\n    await async.parallelLimit([async () => {\n      await Promise.resolve();\n      calls.push(1);\n    }, async () => {\n      await Promise.resolve();\n      calls.push(1);\n    }, async () => {\n      await Promise.resolve();\n      calls.push(1);\n    }, async () => {\n      await Promise.resolve();\n      calls.push(1);\n    }], 2);\n    expect(calls).to.eql([1, 1, 1, 1]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: series",
            "suites": [],
            "updatePoint": {
                "line": 534,
                "column": 37
            },
            "line": 534,
            "code": "  it('should return a Promise: series', async () => {\n    const calls = [];\n    await async.series([async () => {\n      await Promise.resolve();\n      calls.push(1);\n    }, async () => {\n      await Promise.resolve();\n      calls.push(1);\n    }, async () => {\n      await Promise.resolve();\n      calls.push(1);\n    }, async () => {\n      await Promise.resolve();\n      calls.push(1);\n    }], 2);\n    expect(calls).to.eql([1, 1, 1, 1]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: race",
            "suites": [],
            "updatePoint": {
                "line": 551,
                "column": 35
            },
            "line": 551,
            "code": "  it('should return a Promise: race', async () => {\n    const calls = [];\n    await async.race([async () => {\n      await Promise.resolve();\n      calls.push(1);\n    }, async () => {\n      await Promise.resolve();\n      calls.push(1);\n    }, async () => {\n      await Promise.resolve();\n      calls.push(1);\n    }, async () => {\n      await Promise.resolve();\n      calls.push(1);\n    }], 2);\n    expect(calls).to.eql([1, 1, 1, 1]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: retryable",
            "suites": [],
            "updatePoint": {
                "line": 568,
                "column": 40
            },
            "line": 568,
            "code": "  it('should return a Promise: retryable', async () => {\n    let counter = 0;\n    const calls = [];\n    const fn = async.retryable(async (a, b) => {\n      calls.push(a, b);\n      counter++;\n      if (counter < 3) throw new Error();\n    });\n    const promise = fn(1, 2);\n    expect(promise.then).to.be.a('function');\n    await promise;\n    expect(calls).to.eql([1, 2, 1, 2, 1, 2]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: retryable (arity 0)",
            "suites": [],
            "updatePoint": {
                "line": 581,
                "column": 50
            },
            "line": 581,
            "code": "  it('should return a Promise: retryable (arity 0)', async () => {\n    let counter = 0;\n    const calls = [];\n    const fn = async.retryable({\n      times: 5\n    }, async () => {\n      calls.push(0);\n      counter++;\n      if (counter < 3) throw new Error();\n    });\n    await fn();\n    expect(calls).to.eql([0, 0, 0]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: retry",
            "suites": [],
            "updatePoint": {
                "line": 594,
                "column": 36
            },
            "line": 594,
            "code": "  it('should return a Promise: retry', async () => {\n    let counter = 0;\n    const calls = [];\n    await async.retry(async () => {\n      calls.push(counter);\n      counter++;\n      if (counter < 3) throw new Error();\n    });\n    expect(calls).to.eql([0, 1, 2]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: retry (multiple cb args)",
            "suites": [],
            "updatePoint": {
                "line": 604,
                "column": 55
            },
            "line": 604,
            "code": "  it('should return a Promise: retry (multiple cb args)', async () => {\n    let counter = 0;\n    const results = await async.retry(cb => {\n      counter++;\n      if (counter < 3) return cb(new Error());\n      cb(null, 0, 1, 2);\n    });\n    expect(results).to.eql([0, 1, 2]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: tryEach",
            "suites": [],
            "updatePoint": {
                "line": 613,
                "column": 38
            },
            "line": 613,
            "code": "  it('should return a Promise: tryEach', async () => {\n    const calls = [];\n    await async.tryEach([async () => {\n      await Promise.resolve();\n      calls.push(1);\n      throw new Error();\n    }, async () => {\n      await Promise.resolve();\n      calls.push(2);\n      throw new Error();\n    }, async () => {\n      await Promise.resolve();\n      calls.push(3);\n    }, async () => {\n      await Promise.resolve();\n      calls.push(4);\n    }], 2);\n    expect(calls).to.eql([1, 2, 3]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should return a Promise: waterfall",
            "suites": [],
            "updatePoint": {
                "line": 632,
                "column": 40
            },
            "line": 632,
            "code": "  it('should return a Promise: waterfall', async () => {\n    const calls = [];\n    await async.waterfall([async () => {\n      await Promise.resolve();\n      calls.push(1);\n    }, async () => {\n      await Promise.resolve();\n      calls.push(2);\n    }, async () => {\n      await Promise.resolve();\n      calls.push(3);\n    }, async () => {\n      await Promise.resolve();\n      calls.push(4);\n    }], 2);\n    expect(calls).to.eql([1, 2, 3, 4]);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should work with queues",
            "suites": [],
            "updatePoint": {
                "line": 649,
                "column": 29
            },
            "line": 649,
            "code": "  it('should work with queues', async () => {\n    const q = async.queue(async data => {\n      if (data === 2) throw new Error('oh noes');\n      await new Promise(resolve => setTimeout(resolve, 10));\n      return data;\n    }, 5);\n    const calls = [];\n    const errorCalls = [];\n    const emptyCalls = [];\n    q.error().catch(d => errorCalls.push('error ' + d));\n    q.saturated().then(() => calls.push('saturated'));\n    q.unsaturated().then(() => calls.push('unsaturated'));\n    q.empty().then(() => emptyCalls.push('empty'));\n    q.push(1).then(d => calls.push('push cb ' + d));\n    q.push(2).then(d => errorCalls.push('push cb ' + d));\n    q.push([3, 4, 5, 6]).map(p => p.then(d => calls.push('push cb ' + d)));\n    q.push(7).then(d => calls.push('push cb ' + d));\n    q.push(8).then(d => calls.push('push cb ' + d));\n    const multiP = Promise.all(q.push([9, 10]));\n    await q.drain();\n    await multiP;\n    expect(calls.join()).to.eql(['saturated', 'push cb 1', 'push cb 3', 'push cb 4', 'push cb 5', 'push cb 6', 'push cb 7', 'unsaturated', 'push cb 8'].join());\n    expect(errorCalls).to.eql(['push cb undefined', 'error Error: oh noes']);\n    expect(emptyCalls).to.eql(['empty']);\n  });",
            "file": "es2017/awaitableFunctions.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "everyLimit true",
            "suites": [
                "every"
            ],
            "updatePoint": {
                "line": 10,
                "column": 21
            },
            "line": 10,
            "code": "  it('everyLimit true', done => {\n    async.everyLimit([3, 1, 2], 1, (x, callback) => {\n      setTimeout(() => {\n        callback(null, x >= 1);\n      }, 0);\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.equal(true);\n      done();\n    });\n  });",
            "file": "every.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "everyLimit false",
            "suites": [
                "every"
            ],
            "updatePoint": {
                "line": 21,
                "column": 22
            },
            "line": 21,
            "code": "  it('everyLimit false', done => {\n    async.everyLimit([3, 1, 2], 2, (x, callback) => {\n      setTimeout(() => {\n        callback(null, x === 2);\n      }, 0);\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.equal(false);\n      done();\n    });\n  });",
            "file": "every.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "everyLimit short-circuit",
            "suites": [
                "every"
            ],
            "updatePoint": {
                "line": 32,
                "column": 30
            },
            "line": 32,
            "code": "  it('everyLimit short-circuit', done => {\n    var calls = 0;\n    async.everyLimit([3, 1, 2], 1, (x, callback) => {\n      calls++;\n      callback(null, x === 1);\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.equal(false);\n      expect(calls).to.equal(1);\n      done();\n    });\n  });",
            "file": "every.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "true",
            "suites": [
                "every"
            ],
            "updatePoint": {
                "line": 44,
                "column": 10
            },
            "line": 44,
            "code": "  it('true', done => {\n    async.every([1, 2, 3], (x, callback) => {\n      setTimeout(() => {\n        callback(null, true);\n      }, 0);\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.equal(true);\n      done();\n    });\n  });",
            "file": "every.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "false",
            "suites": [
                "every"
            ],
            "updatePoint": {
                "line": 55,
                "column": 11
            },
            "line": 55,
            "code": "  it('false', done => {\n    async.every([1, 2, 3], (x, callback) => {\n      setTimeout(() => {\n        callback(null, x % 2);\n      }, 0);\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.equal(false);\n      done();\n    });\n  });",
            "file": "every.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "early return",
            "suites": [
                "every"
            ],
            "updatePoint": {
                "line": 66,
                "column": 18
            },
            "line": 66,
            "code": "  it('early return', done => {\n    var call_order = [];\n    async.every([1, 2, 3], (x, callback) => {\n      setTimeout(() => {\n        call_order.push(x);\n        callback(null, x === 1);\n      }, x * 5);\n    }, () => {\n      call_order.push('callback');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 2, 'callback', 3]);\n      done();\n    }, 25);\n  });",
            "file": "every.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "error",
            "suites": [
                "every"
            ],
            "updatePoint": {
                "line": 81,
                "column": 11
            },
            "line": 81,
            "code": "  it('error', done => {\n    async.every([1, 2, 3], (x, callback) => {\n      setTimeout(() => {\n        callback('error');\n      }, 0);\n    }, (err, result) => {\n      expect(err).to.equal('error');\n      expect(result).to.not.exist;\n      done();\n    });\n  });",
            "file": "every.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "canceled",
            "suites": [
                "every"
            ],
            "updatePoint": {
                "line": 92,
                "column": 14
            },
            "line": 92,
            "code": "  it('canceled', done => {\n    var call_order = [];\n    async.every([1, 2, 3], (x, callback) => {\n      call_order.push(x);\n\n      if (x === 2) {\n        return callback(false, true);\n      }\n\n      callback(null, true);\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 2, 3]);\n      done();\n    }, 25);\n  });",
            "file": "every.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "everySeries doesn't cause stack overflow (#1293)",
            "suites": [
                "every"
            ],
            "updatePoint": {
                "line": 110,
                "column": 55
            },
            "line": 110,
            "code": "  it('everySeries doesn\\'t cause stack overflow (#1293)', done => {\n    var arr = _.range(10000);\n\n    let calls = 0;\n    async.everySeries(arr, (data, cb) => {\n      calls += 1;\n      async.setImmediate(_.partial(cb, null, false));\n    }, err => {\n      expect(err).to.equal(null);\n      expect(calls).to.equal(1);\n      done();\n    });\n  });",
            "file": "every.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "everySeries canceled",
            "suites": [
                "every"
            ],
            "updatePoint": {
                "line": 123,
                "column": 26
            },
            "line": 123,
            "code": "  it('everySeries canceled', done => {\n    var call_order = [];\n    async.everySeries([1, 2, 3], (x, callback) => {\n      call_order.push(x);\n      async.setImmediate(() => {\n        if (x === 2) {\n          return callback(false, true);\n        }\n\n        callback(null, true);\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 2]);\n      done();\n    }, 50);\n  });",
            "file": "every.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "everyLimit doesn't cause stack overflow (#1293)",
            "suites": [
                "every"
            ],
            "updatePoint": {
                "line": 142,
                "column": 54
            },
            "line": 142,
            "code": "  it('everyLimit doesn\\'t cause stack overflow (#1293)', done => {\n    var arr = _.range(10000);\n\n    let calls = 0;\n    async.everyLimit(arr, 100, (data, cb) => {\n      calls += 1;\n      async.setImmediate(_.partial(cb, null, false));\n    }, err => {\n      expect(err).to.equal(null);\n      expect(calls).to.equal(100);\n      done();\n    });\n  });",
            "file": "every.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "everyLimit canceled",
            "suites": [
                "every"
            ],
            "updatePoint": {
                "line": 155,
                "column": 25
            },
            "line": 155,
            "code": "  it('everyLimit canceled', done => {\n    var call_order = [];\n    async.everyLimit([1, 1, 2, 2, 3], 2, (x, callback) => {\n      call_order.push(x);\n      async.setImmediate(() => {\n        if (x === 2) {\n          return callback(false, true);\n        }\n\n        callback(null, true);\n      });\n    }, () => {\n      throw new Error('final callback - should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 1, 2, 2]);\n      done();\n    }, 50);\n  });",
            "file": "every.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "all alias",
            "suites": [
                "every"
            ],
            "updatePoint": {
                "line": 174,
                "column": 15
            },
            "line": 174,
            "code": "  it('all alias', () => {\n    expect(async.all).to.equal(async.every);\n  });",
            "file": "every.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "allLimit alias",
            "suites": [
                "every"
            ],
            "updatePoint": {
                "line": 177,
                "column": 20
            },
            "line": 177,
            "code": "  it('allLimit alias', () => {\n    expect(async.allLimit).to.equal(async.everyLimit);\n  });",
            "file": "every.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "allSeries alias",
            "suites": [
                "every"
            ],
            "updatePoint": {
                "line": 180,
                "column": 21
            },
            "line": 180,
            "code": "  it('allSeries alias', () => {\n    expect(async.allSeries).to.be.a('function');\n    expect(async.allSeries).to.equal(async.everySeries);\n  });",
            "file": "every.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "filter",
            "suites": [
                "filter"
            ],
            "updatePoint": {
                "line": 25,
                "column": 12
            },
            "line": 25,
            "code": "  it('filter', done => {\n    async.filter([3, 1, 2], filterIteratee, (err, results) => {\n      expect(err).to.equal(null);\n      expect(results).to.eql([3, 1]);\n      done();\n    });\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "filter original untouched",
            "suites": [
                "filter"
            ],
            "updatePoint": {
                "line": 32,
                "column": 31
            },
            "line": 32,
            "code": "  it('filter original untouched', done => {\n    var a = [3, 1, 2];\n    async.filter(a, (x, callback) => {\n      callback(null, x % 2);\n    }, (err, results) => {\n      expect(err).to.equal(null);\n      expect(results).to.eql([3, 1]);\n      expect(a).to.eql([3, 1, 2]);\n      done();\n    });\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "filter collection",
            "suites": [
                "filter"
            ],
            "updatePoint": {
                "line": 43,
                "column": 23
            },
            "line": 43,
            "code": "  it('filter collection', done => {\n    var a = {\n      a: 3,\n      b: 1,\n      c: 2\n    };\n    async.filter(a, (x, callback) => {\n      callback(null, x % 2);\n    }, (err, results) => {\n      expect(err).to.equal(null);\n      expect(results).to.eql([3, 1]);\n      expect(a).to.eql({\n        a: 3,\n        b: 1,\n        c: 2\n      });\n      done();\n    });\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "filter iterator",
            "suites": [
                "filter"
            ],
            "updatePoint": {
                "line": 86,
                "column": 21
            },
            "line": 86,
            "code": "  it('filter iterator', done => {\n    var a = makeIterator([500, 20, 100]);\n    async.filter(a, (x, callback) => {\n      setTimeout(() => {\n        callback(null, x > 20);\n      }, x);\n    }, (err, results) => {\n      expect(err).to.equal(null);\n      expect(results).to.eql([500, 100]);\n      done();\n    });\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "filter error",
            "suites": [
                "filter"
            ],
            "updatePoint": {
                "line": 98,
                "column": 18
            },
            "line": 98,
            "code": "  it('filter error', done => {\n    async.filter([3, 1, 2], (x, callback) => {\n      callback('error');\n    }, (err, results) => {\n      expect(err).to.equal('error');\n      expect(results).to.not.exist;\n      done();\n    });\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "filter canceled",
            "suites": [
                "filter"
            ],
            "updatePoint": {
                "line": 107,
                "column": 21
            },
            "line": 107,
            "code": "  it('filter canceled', done => {\n    var call_order = [];\n    async.filter([3, 1, 2], (x, callback) => {\n      call_order.push(x);\n\n      if (x === 1) {\n        return callback(false, true);\n      }\n\n      callback(null, true);\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([3, 1, 2]);\n      done();\n    }, 25);\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "filterSeries",
            "suites": [
                "filter"
            ],
            "updatePoint": {
                "line": 125,
                "column": 18
            },
            "line": 125,
            "code": "  it('filterSeries', done => {\n    async.filterSeries([3, 1, 2], filterIteratee, (err, results) => {\n      expect(err).to.equal(null);\n      expect(results).to.eql([3, 1]);\n      done();\n    });\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "filterSeries canceled",
            "suites": [
                "filter"
            ],
            "updatePoint": {
                "line": 132,
                "column": 27
            },
            "line": 132,
            "code": "  it('filterSeries canceled', done => {\n    var call_order = [];\n    async.filterSeries([3, 1, 2], (x, callback) => {\n      call_order.push(x);\n      async.setImmediate(() => {\n        if (x === 1) {\n          return callback(false, true);\n        }\n\n        callback(null, true);\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([3, 1]);\n      done();\n    }, 50);\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "select alias",
            "suites": [
                "filter"
            ],
            "updatePoint": {
                "line": 151,
                "column": 18
            },
            "line": 151,
            "code": "  it('select alias', () => {\n    expect(async.select).to.equal(async.filter);\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "selectSeries alias",
            "suites": [
                "filter"
            ],
            "updatePoint": {
                "line": 154,
                "column": 24
            },
            "line": 154,
            "code": "  it('selectSeries alias', () => {\n    expect(async.selectSeries).to.equal(async.filterSeries);\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "filterLimit",
            "suites": [
                "filter"
            ],
            "updatePoint": {
                "line": 157,
                "column": 17
            },
            "line": 157,
            "code": "  it('filterLimit', done => {\n    testLimit([5, 4, 3, 2, 1], async.filterLimit, 2, (v, next) => {\n      next(null, v % 2);\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.eql([5, 3, 1]);\n      done();\n    });\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "filterLimit canceled",
            "suites": [
                "filter"
            ],
            "updatePoint": {
                "line": 166,
                "column": 26
            },
            "line": 166,
            "code": "  it('filterLimit canceled', done => {\n    var call_order = [];\n    async.filterLimit([1, 1, 2, 2, 3], 2, (x, callback) => {\n      call_order.push(x);\n      async.setImmediate(() => {\n        if (x === 2) {\n          return callback(false, true);\n        }\n\n        callback(null, true);\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 1, 2, 2]);\n      done();\n    }, 50);\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reject",
            "suites": [
                "reject"
            ],
            "updatePoint": {
                "line": 187,
                "column": 12
            },
            "line": 187,
            "code": "  it('reject', done => {\n    async.reject([3, 1, 2], filterIteratee, (err, results) => {\n      expect(err).to.equal(null);\n      expect(results).to.eql([2]);\n      done();\n    });\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reject original untouched",
            "suites": [
                "reject"
            ],
            "updatePoint": {
                "line": 194,
                "column": 31
            },
            "line": 194,
            "code": "  it('reject original untouched', done => {\n    var a = [3, 1, 2];\n    async.reject(a, (x, callback) => {\n      callback(null, x % 2);\n    }, (err, results) => {\n      expect(err).to.equal(null);\n      expect(results).to.eql([2]);\n      expect(a).to.eql([3, 1, 2]);\n      done();\n    });\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reject error",
            "suites": [
                "reject"
            ],
            "updatePoint": {
                "line": 205,
                "column": 18
            },
            "line": 205,
            "code": "  it('reject error', done => {\n    async.reject([3, 1, 2], (x, callback) => {\n      callback('error');\n    }, (err, results) => {\n      expect(err).to.equal('error');\n      expect(results).to.not.exist;\n      done();\n    });\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reject canceled",
            "suites": [
                "reject"
            ],
            "updatePoint": {
                "line": 214,
                "column": 21
            },
            "line": 214,
            "code": "  it('reject canceled', done => {\n    var call_order = [];\n    async.filter([3, 1, 2], (x, callback) => {\n      call_order.push(x);\n\n      if (x === 2) {\n        return callback(false, false);\n      }\n\n      callback(null, false);\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([3, 1, 2]);\n      done();\n    }, 25);\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "rejectSeries",
            "suites": [
                "reject"
            ],
            "updatePoint": {
                "line": 232,
                "column": 18
            },
            "line": 232,
            "code": "  it('rejectSeries', done => {\n    async.rejectSeries([3, 1, 2], filterIteratee, (err, results) => {\n      expect(err).to.equal(null);\n      expect(results).to.eql([2]);\n      done();\n    });\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "rejectSeries canceled",
            "suites": [
                "reject"
            ],
            "updatePoint": {
                "line": 239,
                "column": 27
            },
            "line": 239,
            "code": "  it('rejectSeries canceled', done => {\n    var call_order = [];\n    async.rejectSeries([3, 1, 2], (x, callback) => {\n      call_order.push(x);\n      async.setImmediate(() => {\n        if (x === 1) {\n          return callback(false, false);\n        }\n\n        callback(null, false);\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([3, 1]);\n      done();\n    }, 50);\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "rejectLimit",
            "suites": [
                "reject"
            ],
            "updatePoint": {
                "line": 258,
                "column": 17
            },
            "line": 258,
            "code": "  it('rejectLimit', done => {\n    testLimit([5, 4, 3, 2, 1], async.rejectLimit, 2, (v, next) => {\n      next(null, v % 2);\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.eql([4, 2]);\n      done();\n    });\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "rejectLimit canceled",
            "suites": [
                "reject"
            ],
            "updatePoint": {
                "line": 267,
                "column": 26
            },
            "line": 267,
            "code": "  it('rejectLimit canceled', done => {\n    var call_order = [];\n    async.filterLimit([1, 1, 2, 2, 3], 2, (x, callback) => {\n      call_order.push(x);\n      async.setImmediate(() => {\n        if (x === 2) {\n          return callback(false, false);\n        }\n\n        callback(null, false);\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 1, 2, 2]);\n      done();\n    }, 50);\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "filter fails",
            "suites": [
                "reject"
            ],
            "updatePoint": {
                "line": 286,
                "column": 18
            },
            "line": 286,
            "code": "  it('filter fails', done => {\n    async.filter({\n      a: 1,\n      b: 2,\n      c: 3\n    }, (item, callback) => {\n      if (item === 3) {\n        callback(\"error\", false);\n      } else {\n        callback(null, true);\n      }\n    }, (err, res) => {\n      expect(err).to.equal(\"error\");\n      expect(res).to.equal(undefined);\n      done();\n    });\n  });",
            "file": "filter.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "executes the function over and over until it yields an error",
            "suites": [
                "forever",
                "function is asynchronous"
            ],
            "updatePoint": {
                "line": 9,
                "column": 68
            },
            "line": 9,
            "code": "    it('executes the function over and over until it yields an error', done => {\n      var counter = 0;\n\n      function addOne(callback) {\n        counter++;\n\n        if (counter === 50) {\n          return callback('too big!');\n        }\n\n        async.setImmediate(() => {\n          callback();\n        });\n      }\n\n      async.forever(addOne, err => {\n        expect(err).to.eql('too big!');\n        expect(counter).to.eql(50);\n        done();\n      });\n    });",
            "file": "forever.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not cause a stack overflow @nodeonly",
            "suites": [
                "forever",
                "function is synchronous"
            ],
            "updatePoint": {
                "line": 32,
                "column": 49
            },
            "line": 32,
            "code": "    it('does not cause a stack overflow @nodeonly', done => {\n      // this will take forever in a browser\n      var counter = 0;\n\n      function addOne(callback) {\n        counter++;\n\n        if (counter === 50000) {\n          // needs to be huge to potentially overflow stack in node\n          return callback('too big!');\n        }\n\n        callback();\n      }\n\n      async.forever(addOne, err => {\n        expect(err).to.eql('too big!');\n        expect(counter).to.eql(50000);\n        done();\n      });\n    });",
            "file": "forever.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should cancel",
            "suites": [
                "forever",
                "function is synchronous"
            ],
            "updatePoint": {
                "line": 53,
                "column": 21
            },
            "line": 53,
            "code": "    it('should cancel', done => {\n      var counter = 0;\n      async.forever(cb => {\n        counter++;\n        cb(counter === 2 ? false : null);\n      }, () => {\n        throw new Error('should not get here');\n      });\n      setTimeout(() => {\n        expect(counter).to.eql(2);\n        done();\n      }, 10);\n    });",
            "file": "forever.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basics",
            "suites": [
                "groupBy",
                "groupBy"
            ],
            "updatePoint": {
                "line": 20,
                "column": 14
            },
            "line": 20,
            "code": "    it('basics', function (done) {\n      var callOrder = [];\n      async.groupBy([1, 3, 2], groupByIteratee.bind(this, callOrder), (err, result) => {\n        expect(err).to.eql(null);\n        expect(callOrder).to.eql([1, 2, 3]);\n        expect(result).to.eql({\n          2: [1],\n          3: [2],\n          4: [3]\n        });\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "error",
            "suites": [
                "groupBy",
                "groupBy"
            ],
            "updatePoint": {
                "line": 33,
                "column": 13
            },
            "line": 33,
            "code": "    it('error', done => {\n      async.groupBy([1, 3, 2], (val, next) => {\n        if (val === 3) {\n          return next(new Error('fail'));\n        }\n\n        next(null, val + 1);\n      }, (err, result) => {\n        expect(err).to.not.eql(null);\n        expect(result).to.eql({\n          2: [1]\n        });\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "canceled",
            "suites": [
                "groupBy",
                "groupBy"
            ],
            "updatePoint": {
                "line": 48,
                "column": 16
            },
            "line": 48,
            "code": "    it('canceled', done => {\n      var callOrder = [];\n      async.groupBy([1, 3, 2], (val, next) => {\n        callOrder.push(val);\n\n        if (val === 3) {\n          return next(false, val + 1);\n        }\n\n        next(null, val + 1);\n      }, () => {\n        throw new Error('should not get here');\n      });\n      setTimeout(() => {\n        expect(callOrder).to.eql([1, 3]);\n        done();\n      }, 25);\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "original untouched",
            "suites": [
                "groupBy",
                "groupBy"
            ],
            "updatePoint": {
                "line": 66,
                "column": 26
            },
            "line": 66,
            "code": "    it('original untouched', done => {\n      var obj = {\n        a: 'b',\n        b: 'c',\n        c: 'd'\n      };\n      async.groupBy(obj, (val, next) => {\n        next(null, val);\n      }, (err, result) => {\n        expect(obj).to.eql({\n          a: 'b',\n          b: 'c',\n          c: 'd'\n        });\n        expect(result).to.eql({\n          b: ['b'],\n          c: ['c'],\n          d: ['d']\n        });\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles multiple matches",
            "suites": [
                "groupBy",
                "groupBy"
            ],
            "updatePoint": {
                "line": 88,
                "column": 32
            },
            "line": 88,
            "code": "    it('handles multiple matches', function (done) {\n      var callOrder = [];\n      async.groupBy([1, 3, 2, 2], groupByIteratee.bind(this, callOrder), (err, result) => {\n        expect(err).to.eql(null);\n        expect(callOrder).to.eql([1, 2, 2, 3]);\n        expect(result).to.eql({\n          2: [1],\n          3: [2, 2],\n          4: [3]\n        });\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles objects",
            "suites": [
                "groupBy",
                "groupBy"
            ],
            "updatePoint": {
                "line": 101,
                "column": 23
            },
            "line": 101,
            "code": "    it('handles objects', done => {\n      var obj = {\n        a: 'b',\n        b: 'c',\n        c: 'd'\n      };\n      var concurrency = {\n        b: 3,\n        c: 2,\n        d: 1\n      };\n      var running = 0;\n      async.groupBy(obj, (val, next) => {\n        running++;\n        async.setImmediate(() => {\n          expect(running).to.equal(concurrency[val]);\n          running--;\n          next(null, val);\n        });\n      }, (err, result) => {\n        expect(running).to.equal(0);\n        expect(err).to.eql(null);\n        expect(result).to.eql({\n          b: ['b'],\n          c: ['c'],\n          d: ['d']\n        });\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles undefined",
            "suites": [
                "groupBy",
                "groupBy"
            ],
            "updatePoint": {
                "line": 131,
                "column": 25
            },
            "line": 131,
            "code": "    it('handles undefined', done => {\n      async.groupBy(undefined, (val, next) => {\n        assert(false, 'iteratee should not be called');\n        next();\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql({});\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles empty object",
            "suites": [
                "groupBy",
                "groupBy"
            ],
            "updatePoint": {
                "line": 141,
                "column": 28
            },
            "line": 141,
            "code": "    it('handles empty object', done => {\n      async.groupBy({}, (val, next) => {\n        assert(false, 'iteratee should not be called');\n        next();\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql({});\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "main callback optional",
            "suites": [
                "groupBy",
                "groupBy"
            ],
            "updatePoint": {
                "line": 151,
                "column": 30
            },
            "line": 151,
            "code": "    it('main callback optional', done => {\n      var arr = [1, 2, 3];\n      var runs = [];\n      async.groupBy(arr, (val, next) => {\n        runs.push(val);\n\n        var _done = runs.length === arr.length;\n\n        async.setImmediate(() => {\n          next(null);\n\n          if (_done) {\n            expect(runs).to.eql(arr);\n            done();\n          }\n        });\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "iteratee callback is only called once",
            "suites": [
                "groupBy",
                "groupBy"
            ],
            "updatePoint": {
                "line": 169,
                "column": 45
            },
            "line": 169,
            "code": "    it('iteratee callback is only called once', done => {\n      async.groupBy([1, 2], (item, callback) => {\n        try {\n          callback(item);\n        } catch (exception) {\n          expect(() => {\n            callback(exception);\n          }).to.throw(/already called/);\n          done();\n        }\n      }, () => {\n        throw new Error();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles Map",
            "suites": [
                "groupBy",
                "groupBy"
            ],
            "updatePoint": {
                "line": 183,
                "column": 19
            },
            "line": 183,
            "code": "    it('handles Map', done => {\n      if (typeof Map !== 'function') {\n        return done();\n      }\n\n      var map = new Map([['a', 'a'], ['b', 'b'], ['c', 'a']]);\n      async.groupBy(map, (val, next) => {\n        next(null, val[1] + 1);\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql({\n          a1: [['a', 'a'], ['c', 'a']],\n          b1: [['b', 'b']]\n        });\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles sparse results",
            "suites": [
                "groupBy",
                "groupBy"
            ],
            "updatePoint": {
                "line": 200,
                "column": 30
            },
            "line": 200,
            "code": "    it('handles sparse results', done => {\n      var arr = [1, 2, 3];\n      async.groupBy(arr, (val, next) => {\n        if (val === 1) {\n          return next(null, val + 1);\n        } else if (val === 2) {\n          async.setImmediate(() => {\n            return next(null, val + 1);\n          });\n        } else {\n          return next('error');\n        }\n      }, (err, result) => {\n        expect(err).to.not.eql(null);\n        expect(result).to.eql({\n          2: [1]\n        });\n        async.setImmediate(done);\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basics",
            "suites": [
                "groupBy",
                "groupByLimit"
            ],
            "updatePoint": {
                "line": 227,
                "column": 14
            },
            "line": 227,
            "code": "    it('basics', done => {\n      var running = 0;\n      var concurrency = {\n        'b': 2,\n        'c': 2,\n        'd': 1\n      };\n      async.groupByLimit(obj, 2, (val, next) => {\n        running++;\n        async.setImmediate(() => {\n          expect(running).to.equal(concurrency[val]);\n          running--;\n          next(null, val);\n        });\n      }, (err, result) => {\n        expect(running).to.equal(0);\n        expect(err).to.eql(null);\n        expect(result).to.eql({\n          'b': ['b'],\n          'c': ['c'],\n          'd': ['d']\n        });\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "error",
            "suites": [
                "groupBy",
                "groupByLimit"
            ],
            "updatePoint": {
                "line": 252,
                "column": 13
            },
            "line": 252,
            "code": "    it('error', done => {\n      async.groupByLimit(obj, 1, (val, next) => {\n        if (val === 'c') {\n          return next(new Error('fail'));\n        }\n\n        next(null, val);\n      }, (err, result) => {\n        expect(err).to.not.eql(null);\n        expect(result).to.eql({\n          b: ['b']\n        });\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "canceled",
            "suites": [
                "groupBy",
                "groupByLimit"
            ],
            "updatePoint": {
                "line": 267,
                "column": 16
            },
            "line": 267,
            "code": "    it('canceled', done => {\n      var callOrder = [];\n      async.groupByLimit([1, 1, 2, 2, 3], 2, (val, next) => {\n        callOrder.push(val);\n        async.setImmediate(() => {\n          if (val === 2) {\n            return next(false, val + 1);\n          }\n\n          next(null, val + 1);\n        });\n      }, () => {\n        throw new Error('should not get here');\n      });\n      setTimeout(() => {\n        expect(callOrder).to.eql([1, 1, 2, 2]);\n        done();\n      }, 50);\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles empty object",
            "suites": [
                "groupBy",
                "groupByLimit"
            ],
            "updatePoint": {
                "line": 286,
                "column": 28
            },
            "line": 286,
            "code": "    it('handles empty object', done => {\n      async.groupByLimit({}, 2, (val, next) => {\n        assert(false, 'iteratee should not be called');\n        next();\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql({});\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles undefined",
            "suites": [
                "groupBy",
                "groupByLimit"
            ],
            "updatePoint": {
                "line": 296,
                "column": 25
            },
            "line": 296,
            "code": "    it('handles undefined', done => {\n      async.groupByLimit(undefined, 2, (val, next) => {\n        assert(false, 'iteratee should not be called');\n        next();\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql({});\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "limit exceeds size",
            "suites": [
                "groupBy",
                "groupByLimit"
            ],
            "updatePoint": {
                "line": 306,
                "column": 26
            },
            "line": 306,
            "code": "    it('limit exceeds size', function (done) {\n      var callOrder = [];\n      async.groupByLimit([3, 2, 2, 1], 10, groupByIteratee.bind(this, callOrder), (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql({\n          2: [1],\n          3: [2, 2],\n          4: [3]\n        });\n        expect(callOrder).to.eql([1, 2, 2, 3]);\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "limit equal size",
            "suites": [
                "groupBy",
                "groupByLimit"
            ],
            "updatePoint": {
                "line": 319,
                "column": 24
            },
            "line": 319,
            "code": "    it('limit equal size', function (done) {\n      var callOrder = [];\n      async.groupByLimit([3, 2, 2, 1], 4, groupByIteratee.bind(this, callOrder), (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql({\n          2: [1],\n          3: [2, 2],\n          4: [3]\n        });\n        expect(callOrder).to.eql([1, 2, 2, 3]);\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "zero limit",
            "suites": [
                "groupBy",
                "groupByLimit"
            ],
            "updatePoint": {
                "line": 332,
                "column": 18
            },
            "line": 332,
            "code": "    it('zero limit', () => {\n      expect(() => {\n        async.groupByLimit([3, 2, 2, 1], 0, (val, next) => {\n          assert(false, 'iteratee should not be called');\n          next();\n        }, () => {\n          assert(false, 'should not be called');\n        });\n      }).to.throw(/concurrency limit/);\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "does not continue replenishing after error",
            "suites": [
                "groupBy",
                "groupByLimit"
            ],
            "updatePoint": {
                "line": 342,
                "column": 50
            },
            "line": 342,
            "code": "    it('does not continue replenishing after error', done => {\n      var started = 0;\n      var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n      var delay = 10;\n      var limit = 3;\n      var maxTime = 10 * arr.length;\n      async.groupByLimit(arr, limit, (val, next) => {\n        started++;\n\n        if (started === 3) {\n          return next(new Error('fail'));\n        }\n\n        setTimeout(() => {\n          next();\n        }, delay);\n      }, (err, result) => {\n        expect(err).to.not.eql(null);\n        expect(result).to.eql({});\n      });\n      setTimeout(() => {\n        expect(started).to.equal(3);\n        done();\n      }, maxTime);\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basics",
            "suites": [
                "groupBy",
                "groupBySeries"
            ],
            "updatePoint": {
                "line": 374,
                "column": 14
            },
            "line": 374,
            "code": "    it('basics', done => {\n      var running = 0;\n      var concurrency = {\n        'b': 1,\n        'c': 1,\n        'd': 1\n      };\n      async.groupBySeries(obj, (val, next) => {\n        running++;\n        async.setImmediate(() => {\n          expect(running).to.equal(concurrency[val]);\n          running--;\n          next(null, val);\n        });\n      }, (err, result) => {\n        expect(running).to.equal(0);\n        expect(err).to.eql(null);\n        expect(result).to.eql({\n          'b': ['b'],\n          'c': ['c'],\n          'd': ['d']\n        });\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "error",
            "suites": [
                "groupBy",
                "groupBySeries"
            ],
            "updatePoint": {
                "line": 399,
                "column": 13
            },
            "line": 399,
            "code": "    it('error', done => {\n      async.groupBySeries(obj, (val, next) => {\n        if (val === 'c') {\n          return next(new Error('fail'));\n        }\n\n        next(null, val);\n      }, (err, result) => {\n        expect(err).to.not.eql(null);\n        expect(result).to.eql({\n          b: ['b']\n        });\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "canceled",
            "suites": [
                "groupBy",
                "groupBySeries"
            ],
            "updatePoint": {
                "line": 414,
                "column": 16
            },
            "line": 414,
            "code": "    it('canceled', done => {\n      var callOrder = [];\n      async.groupBySeries([1, 2, 3], (val, next) => {\n        callOrder.push(val);\n        async.setImmediate(() => {\n          if (val === 2) {\n            return next(false, val + 1);\n          }\n\n          next(null, val + 1);\n        });\n      }, () => {\n        throw new Error('should not get here');\n      });\n      setTimeout(() => {\n        expect(callOrder).to.eql([1, 2]);\n        done();\n      }, 50);\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles arrays",
            "suites": [
                "groupBy",
                "groupBySeries"
            ],
            "updatePoint": {
                "line": 433,
                "column": 22
            },
            "line": 433,
            "code": "    it('handles arrays', done => {\n      async.groupBySeries(['a', 'a', 'b'], (val, next) => {\n        next(null, val);\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql({\n          'a': ['a', 'a'],\n          'b': ['b']\n        });\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles empty object",
            "suites": [
                "groupBy",
                "groupBySeries"
            ],
            "updatePoint": {
                "line": 445,
                "column": 28
            },
            "line": 445,
            "code": "    it('handles empty object', done => {\n      async.groupBySeries({}, (val, next) => {\n        assert(false, 'iteratee should not be called');\n        next();\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql({});\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "handles undefined",
            "suites": [
                "groupBy",
                "groupBySeries"
            ],
            "updatePoint": {
                "line": 455,
                "column": 25
            },
            "line": 455,
            "code": "    it('handles undefined', done => {\n      async.groupBySeries(undefined, (val, next) => {\n        assert(false, 'iteratee should not be called');\n        next();\n      }, (err, result) => {\n        expect(err).to.eql(null);\n        expect(result).to.eql({});\n        done();\n      });\n    });",
            "file": "groupBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "push",
            "suites": [
                "Heap"
            ],
            "updatePoint": {
                "line": 8,
                "column": 10
            },
            "line": 8,
            "code": "  it('push', () => {\n    var heap = new Heap();\n    expect(heap.length).to.eql(0);\n    heap.push({\n      priority: 1,\n      data: 'foo1'\n    });\n    heap.push({\n      priority: 2,\n      data: 'foo2'\n    });\n    heap.push({\n      priority: 9,\n      data: 'foo3'\n    });\n    heap.push({\n      priority: 2,\n      data: 'foo4'\n    });\n    heap.push({\n      priority: 2,\n      data: 'foo5'\n    });\n    heap.push({\n      priority: 5,\n      data: 'foo6'\n    });\n    heap.push({\n      priority: -5,\n      data: 'foo7'\n    });\n    heap.push({\n      priority: 1,\n      data: 'foo8'\n    });\n    expect(heap.length).to.eql(8);\n    expect(heap.shift().data).to.eql('foo7');\n    expect(heap.shift().data).to.eql('foo1');\n    heap.push({\n      priority: -10,\n      data: 'foo9'\n    });\n    heap.push({\n      priority: 12,\n      data: 'foo10'\n    });\n    expect(heap.shift().data).to.eql('foo9');\n    expect(heap.shift().data).to.eql('foo8');\n    expect(heap.shift().data).to.eql('foo2');\n    expect(heap.shift().data).to.eql('foo4');\n    expect(heap.shift().data).to.eql('foo5');\n    heap.push({\n      priority: -1,\n      data: 'foo11'\n    });\n    heap.push({\n      priority: 7,\n      data: 'foo12'\n    });\n    expect(heap.shift().data).to.eql('foo11');\n    expect(heap.shift().data).to.eql('foo6');\n    expect(heap.shift().data).to.eql('foo12');\n    expect(heap.shift().data).to.eql('foo3');\n    expect(heap.shift().data).to.eql('foo10');\n    expect(heap.length).to.eql(0);\n  });",
            "file": "heap.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "toArray",
            "suites": [
                "Heap"
            ],
            "updatePoint": {
                "line": 74,
                "column": 13
            },
            "line": 74,
            "code": "  it('toArray', () => {\n    var heap = new Heap();\n    expect(heap.toArray()).to.eql([]);\n\n    for (var i = 0; i < 5; i++) {\n      heap.push({\n        data: i\n      });\n    }\n\n    expect(heap.toArray()).to.eql([0, 1, 2, 3, 4]);\n  });",
            "file": "heap.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "remove",
            "suites": [
                "Heap"
            ],
            "updatePoint": {
                "line": 86,
                "column": 12
            },
            "line": 86,
            "code": "  it('remove', () => {\n    var heap = new Heap();\n\n    for (var i = 0; i < 5; i++) {\n      heap.push({\n        data: i\n      });\n    }\n\n    heap.remove(node => {\n      return node.data === 3;\n    });\n    expect(heap.toArray()).to.eql([0, 1, 2, 4]);\n  });",
            "file": "heap.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "remove (head)",
            "suites": [
                "Heap"
            ],
            "updatePoint": {
                "line": 100,
                "column": 19
            },
            "line": 100,
            "code": "  it('remove (head)', () => {\n    var heap = new Heap();\n\n    for (var i = 0; i < 5; i++) {\n      heap.push({\n        data: i\n      });\n    }\n\n    heap.remove(node => {\n      return node.data === 0;\n    });\n    expect(heap.toArray()).to.eql([1, 2, 3, 4]);\n  });",
            "file": "heap.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "remove (tail)",
            "suites": [
                "Heap"
            ],
            "updatePoint": {
                "line": 114,
                "column": 19
            },
            "line": 114,
            "code": "  it('remove (tail)', () => {\n    var heap = new Heap();\n\n    for (var i = 0; i < 5; i++) {\n      heap.push({\n        data: i\n      });\n    }\n\n    heap.remove(node => {\n      return node.data === 4;\n    });\n    expect(heap.toArray()).to.eql([0, 1, 2, 3]);\n  });",
            "file": "heap.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "remove (all)",
            "suites": [
                "Heap"
            ],
            "updatePoint": {
                "line": 128,
                "column": 18
            },
            "line": 128,
            "code": "  it('remove (all)', () => {\n    var heap = new Heap();\n\n    for (var i = 0; i < 5; i++) {\n      heap.push({\n        data: i\n      });\n    }\n\n    heap.remove(node => {\n      return node.data < 5;\n    });\n    expect(heap.toArray()).to.eql([]);\n  });",
            "file": "heap.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "empty",
            "suites": [
                "Heap"
            ],
            "updatePoint": {
                "line": 142,
                "column": 11
            },
            "line": 142,
            "code": "  it('empty', () => {\n    var heap = new Heap();\n\n    for (var i = 0; i < 5; i++) {\n      heap.push({\n        data: i\n      });\n    }\n\n    var empty = heap.empty();\n    expect(heap).to.equal(empty);\n    expect(heap.toArray()).to.eql([]);\n  });",
            "file": "heap.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "toArray",
            "suites": [
                "DoublyLinkedList"
            ],
            "updatePoint": {
                "line": 8,
                "column": 13
            },
            "line": 8,
            "code": "  it('toArray', () => {\n    var list = new DLL();\n    expect(list.toArray()).to.eql([]);\n\n    for (var i = 0; i < 5; i++) {\n      list.push({\n        data: i\n      });\n    }\n\n    expect(list.toArray()).to.eql([0, 1, 2, 3, 4]);\n  });",
            "file": "linked_list.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "remove",
            "suites": [
                "DoublyLinkedList"
            ],
            "updatePoint": {
                "line": 20,
                "column": 12
            },
            "line": 20,
            "code": "  it('remove', () => {\n    var list = new DLL();\n\n    for (var i = 0; i < 5; i++) {\n      list.push({\n        data: i\n      });\n    }\n\n    list.remove(node => {\n      return node.data === 3;\n    });\n    expect(list.toArray()).to.eql([0, 1, 2, 4]);\n  });",
            "file": "linked_list.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "remove (head)",
            "suites": [
                "DoublyLinkedList"
            ],
            "updatePoint": {
                "line": 34,
                "column": 19
            },
            "line": 34,
            "code": "  it('remove (head)', () => {\n    var list = new DLL();\n\n    for (var i = 0; i < 5; i++) {\n      list.push({\n        data: i\n      });\n    }\n\n    list.remove(node => {\n      return node.data === 0;\n    });\n    expect(list.toArray()).to.eql([1, 2, 3, 4]);\n  });",
            "file": "linked_list.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "remove (tail)",
            "suites": [
                "DoublyLinkedList"
            ],
            "updatePoint": {
                "line": 48,
                "column": 19
            },
            "line": 48,
            "code": "  it('remove (tail)', () => {\n    var list = new DLL();\n\n    for (var i = 0; i < 5; i++) {\n      list.push({\n        data: i\n      });\n    }\n\n    list.remove(node => {\n      return node.data === 4;\n    });\n    expect(list.toArray()).to.eql([0, 1, 2, 3]);\n  });",
            "file": "linked_list.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "remove (all)",
            "suites": [
                "DoublyLinkedList"
            ],
            "updatePoint": {
                "line": 62,
                "column": 18
            },
            "line": 62,
            "code": "  it('remove (all)', () => {\n    var list = new DLL();\n\n    for (var i = 0; i < 5; i++) {\n      list.push({\n        data: i\n      });\n    }\n\n    list.remove(node => {\n      return node.data < 5;\n    });\n    expect(list.toArray()).to.eql([]);\n  });",
            "file": "linked_list.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "empty",
            "suites": [
                "DoublyLinkedList"
            ],
            "updatePoint": {
                "line": 76,
                "column": 11
            },
            "line": 76,
            "code": "  it('empty', () => {\n    var list = new DLL();\n\n    for (var i = 0; i < 5; i++) {\n      list.push({\n        data: i\n      });\n    }\n\n    var empty = list.empty();\n    expect(list).to.equal(empty);\n    expect(list.toArray()).to.eql([]);\n  });",
            "file": "linked_list.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basic",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 17,
                "column": 11
            },
            "line": 17,
            "code": "  it('basic', function (done) {\n    var call_order = [];\n    async.map([1, 3, 2], mapIteratee.bind(this, call_order), (err, results) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(call_order).to.eql([1, 2, 3]);\n      expect(results).to.eql([2, 6, 4]);\n      done();\n    });\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "with reflect",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 26,
                "column": 18
            },
            "line": 26,
            "code": "  it('with reflect', done => {\n    var call_order = [];\n    async.map([1, 3, 2], async.reflect((item, cb) => {\n      setTimeout(() => {\n        call_order.push(item);\n        cb(null, item * 2);\n      }, item * 25);\n    }), (err, results) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(call_order).to.eql([1, 2, 3]);\n      expect(results).to.eql([{\n        value: 2\n      }, {\n        value: 6\n      }, {\n        value: 4\n      }]);\n      done();\n    });\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "error with reflect",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 46,
                "column": 24
            },
            "line": 46,
            "code": "  it('error with reflect', done => {\n    var call_order = [];\n    async.map([-1, 1, 3, 2], async.reflect((item, cb) => {\n      setTimeout(() => {\n        call_order.push(item);\n\n        if (item < 0) {\n          cb('number less then zero');\n        } else {\n          cb(null, item * 2);\n        }\n      }, item * 25);\n    }), (err, results) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(call_order).to.eql([-1, 1, 2, 3]);\n      expect(results).to.eql([{\n        error: 'number less then zero'\n      }, {\n        value: 2\n      }, {\n        value: 6\n      }, {\n        value: 4\n      }]);\n      done();\n    });\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "map original untouched",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 73,
                "column": 28
            },
            "line": 73,
            "code": "  it('map original untouched', done => {\n    var a = [1, 2, 3];\n    async.map(a, (x, callback) => {\n      callback(null, x * 2);\n    }, (err, results) => {\n      expect(results).to.eql([2, 4, 6]);\n      expect(a).to.eql([1, 2, 3]);\n      done();\n    });\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "map without main callback",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 83,
                "column": 31
            },
            "line": 83,
            "code": "  it('map without main callback', done => {\n    var a = [1, 2, 3];\n    var r = [];\n    async.map(a, (x, callback) => {\n      r.push(x);\n      var done_ = r.length == a.length;\n      callback(null);\n\n      if (done_) {\n        expect(r).to.eql(a);\n        done();\n      }\n    });\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "map error",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 97,
                "column": 15
            },
            "line": 97,
            "code": "  it('map error', done => {\n    async.map([1, 2, 3], (x, callback) => {\n      callback('error');\n    }, err => {\n      expect(err).to.equal('error');\n    });\n    setTimeout(done, 50);\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "map canceled",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 105,
                "column": 18
            },
            "line": 105,
            "code": "  it('map canceled', done => {\n    var call_order = [];\n    async.map([1, 2, 3], (x, callback) => {\n      call_order.push(x);\n\n      if (x === 2) {\n        return callback(false, x * 2);\n      }\n\n      callback(null, x * 2);\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 2, 3]);\n      done();\n    }, 25);\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "map undefined array",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 123,
                "column": 25
            },
            "line": 123,
            "code": "  it('map undefined array', done => {\n    async.map(undefined, (x, callback) => {\n      callback();\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.eql([]);\n    });\n    setTimeout(done, 50);\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "map object",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 132,
                "column": 16
            },
            "line": 132,
            "code": "  it('map object', done => {\n    async.map({\n      a: 1,\n      b: 2,\n      c: 3\n    }, (val, callback) => {\n      callback(null, val * 2);\n    }, (err, result) => {\n      if (err) throw err;\n      expect(Array.isArray(result)).to.equal(true);\n      expect(result).to.contain(2);\n      expect(result).to.contain(4);\n      expect(result).to.contain(6);\n      done();\n    });\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "mapSeries",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 148,
                "column": 15
            },
            "line": 148,
            "code": "  it('mapSeries', function (done) {\n    var call_order = [];\n    async.mapSeries([1, 3, 2], mapIteratee.bind(this, call_order), (err, results) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(call_order).to.eql([1, 3, 2]);\n      expect(results).to.eql([2, 6, 4]);\n      done();\n    });\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "mapSeries error",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 157,
                "column": 21
            },
            "line": 157,
            "code": "  it('mapSeries error', done => {\n    async.mapSeries([1, 2, 3], (x, callback) => {\n      callback('error');\n    }, err => {\n      expect(err).to.equal('error');\n    });\n    setTimeout(done, 50);\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "mapSeries canceled",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 165,
                "column": 24
            },
            "line": 165,
            "code": "  it('mapSeries canceled', done => {\n    var call_order = [];\n    async.mapSeries([1, 2, 3], (x, callback) => {\n      call_order.push(x);\n      async.setImmediate(() => {\n        if (x === 2) {\n          return callback(false, x * 2);\n        }\n\n        callback(null, x * 2);\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 2]);\n      done();\n    }, 50);\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "mapSeries undefined array",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 184,
                "column": 31
            },
            "line": 184,
            "code": "  it('mapSeries undefined array', done => {\n    async.mapSeries(undefined, (x, callback) => {\n      callback();\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.eql([]);\n    });\n    setTimeout(done, 50);\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "mapSeries object",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 193,
                "column": 22
            },
            "line": 193,
            "code": "  it('mapSeries object', done => {\n    async.mapSeries({\n      a: 1,\n      b: 2,\n      c: 3\n    }, (val, callback) => {\n      callback(null, val * 2);\n    }, (err, result) => {\n      if (err) throw err;\n      expect(result).to.contain(2);\n      expect(result).to.contain(4);\n      expect(result).to.contain(6);\n      done();\n    });\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "mapLimit",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 208,
                "column": 14
            },
            "line": 208,
            "code": "  it('mapLimit', function (done) {\n    var call_order = [];\n    async.mapLimit([2, 4, 3], 2, mapIteratee.bind(this, call_order), (err, results) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(call_order).to.eql([2, 4, 3]);\n      expect(results).to.eql([4, 8, 6]);\n      done();\n    });\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "mapLimit empty array",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 217,
                "column": 26
            },
            "line": 217,
            "code": "  it('mapLimit empty array', done => {\n    async.mapLimit([], 2, (x, callback) => {\n      assert(false, 'iteratee should not be called');\n      callback();\n    }, err => {\n      if (err) throw err;\n      assert(true, 'should call callback');\n    });\n    setTimeout(done, 25);\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "mapLimit undefined array",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 227,
                "column": 30
            },
            "line": 227,
            "code": "  it('mapLimit undefined array', done => {\n    async.mapLimit(undefined, 2, (x, callback) => {\n      callback();\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.eql([]);\n    });\n    setTimeout(done, 50);\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "mapLimit limit exceeds size",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 236,
                "column": 33
            },
            "line": 236,
            "code": "  it('mapLimit limit exceeds size', function (done) {\n    var call_order = [];\n    async.mapLimit([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 20, mapIteratee.bind(this, call_order), (err, results) => {\n      expect(call_order).to.eql([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n      expect(results).to.eql([0, 2, 4, 6, 8, 10, 12, 14, 16, 18]);\n      done();\n    });\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "mapLimit limit equal size",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 244,
                "column": 31
            },
            "line": 244,
            "code": "  it('mapLimit limit equal size', function (done) {\n    var call_order = [];\n    async.mapLimit([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 10, mapIteratee.bind(this, call_order), (err, results) => {\n      expect(call_order).to.eql([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n      expect(results).to.eql([0, 2, 4, 6, 8, 10, 12, 14, 16, 18]);\n      done();\n    });\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "mapLimit zero limit",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 252,
                "column": 25
            },
            "line": 252,
            "code": "  it('mapLimit zero limit', () => {\n    expect(() => {\n      async.mapLimit([0, 1, 2, 3, 4, 5], 0, (x, callback) => {\n        assert(false, 'iteratee should not be called');\n        callback();\n      }, () => {\n        assert(false, 'should not be called');\n      });\n    }).to.throw(/concurrency limit/);\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "mapLimit error",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 262,
                "column": 20
            },
            "line": 262,
            "code": "  it('mapLimit error', done => {\n    var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    var call_order = [];\n    async.mapLimit(arr, 3, (x, callback) => {\n      call_order.push(x);\n\n      if (x === 2) {\n        callback('error');\n      }\n    }, err => {\n      expect(call_order).to.eql([0, 1, 2]);\n      expect(err).to.equal('error');\n    });\n    setTimeout(done, 25);\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "mapLimit canceled",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 277,
                "column": 23
            },
            "line": 277,
            "code": "  it('mapLimit canceled', done => {\n    var call_order = [];\n    async.mapLimit([1, 2, 3, 4, 5], 2, (x, callback) => {\n      call_order.push(x);\n      async.setImmediate(() => {\n        if (x === 3) {\n          return callback(false, x * 2);\n        }\n\n        callback(null, x * 2);\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 2, 3, 4]);\n      done();\n    }, 50);\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "mapLimit does not continue replenishing after error",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 296,
                "column": 57
            },
            "line": 296,
            "code": "  it('mapLimit does not continue replenishing after error', done => {\n    var started = 0;\n    var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    var delay = 10;\n    var limit = 3;\n    var maxTime = 10 * arr.length;\n    async.mapLimit(arr, limit, (x, callback) => {\n      started++;\n\n      if (started === 3) {\n        return callback(new Error(\"Test Error\"));\n      }\n\n      setTimeout(() => {\n        callback();\n      }, delay);\n    }, () => {});\n    setTimeout(() => {\n      expect(started).to.equal(3);\n      done();\n    }, maxTime);\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "map with Map",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 318,
                "column": 18
            },
            "line": 318,
            "code": "  it('map with Map', done => {\n    if (typeof Map !== 'function') return done();\n    var map = new Map();\n    map.set(1, \"a\");\n    map.set(2, \"b\");\n    async.map(map, (val, cb) => {\n      cb(null, val);\n    }, (err, result) => {\n      assert(Array.isArray(result), \"map should return an array for an iterable\");\n      done();\n    });\n  }); // Issue 1106 on github: https://github.com/caolan/async/issues/1106",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "map main callback is called only once",
            "suites": [
                "map"
            ],
            "updatePoint": {
                "line": 331,
                "column": 43
            },
            "line": 331,
            "code": "  it('map main callback is called only once', done => {\n    async.map([1, 2], (item, callback) => {\n      try {\n        callback(item);\n      } catch (exception) {\n        expect(() => {\n          callback(exception);\n        }).to.throw(/already called/);\n        done();\n      }\n    }, () => {\n      throw new Error();\n    });\n  });",
            "file": "map.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basics",
            "suites": [
                "mapValues",
                "mapValuesLimit"
            ],
            "updatePoint": {
                "line": 15,
                "column": 14
            },
            "line": 15,
            "code": "    it('basics', done => {\n      var running = 0;\n      var concurrency = {\n        a: 2,\n        b: 2,\n        c: 2,\n        d: 1\n      };\n      async.mapValuesLimit(obj, 2, (val, key, next) => {\n        running++;\n        async.setImmediate(() => {\n          expect(running).to.equal(concurrency[key]);\n          running--;\n          next(null, key + val);\n        });\n      }, (err, result) => {\n        expect(running).to.equal(0);\n        expect(err).to.eql(null);\n        expect(result).to.eql({\n          a: 'a1',\n          b: 'b2',\n          c: 'c3',\n          d: 'd4'\n        });\n        done();\n      });\n    });",
            "file": "mapValues.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "error",
            "suites": [
                "mapValues",
                "mapValuesLimit"
            ],
            "updatePoint": {
                "line": 42,
                "column": 13
            },
            "line": 42,
            "code": "    it('error', done => {\n      async.mapValuesLimit(obj, 1, (val, key, next) => {\n        if (key === 'b') {\n          return next(new Error(\"fail\"));\n        }\n\n        next(null, val);\n      }, (err, result) => {\n        expect(err).to.not.eql(null);\n        expect(result).to.eql({\n          a: 1\n        });\n        done();\n      });\n    });",
            "file": "mapValues.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "canceled",
            "suites": [
                "mapValues",
                "mapValuesLimit"
            ],
            "updatePoint": {
                "line": 57,
                "column": 16
            },
            "line": 57,
            "code": "    it('canceled', done => {\n      var callOrder = [];\n      async.mapValuesLimit(obj, 2, (val, key, next) => {\n        callOrder.push(val, key);\n        async.setImmediate(() => {\n          if (key === 'b') {\n            return next(false);\n          }\n\n          next(null, val);\n        });\n      }, () => {\n        throw new Error('should not get here');\n      });\n      setTimeout(() => {\n        expect(callOrder).to.eql([1, 'a', 2, 'b', 3, 'c']);\n        done();\n      }, 50);\n    });",
            "file": "mapValues.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "prototype pollution",
            "suites": [
                "mapValues",
                "mapValuesLimit"
            ],
            "updatePoint": {
                "line": 76,
                "column": 27
            },
            "line": 76,
            "code": "    it('prototype pollution', done => {\n      var input = JSON.parse('{\"a\": 1, \"b\": 2, \"__proto__\": { \"exploit\": true }}');\n      async.mapValues(input, (val, key, next) => {\n        next(null, val);\n      }, (err, result) => {\n        expect(result.exploit).to.equal(undefined);\n        done(err);\n      });\n    });",
            "file": "mapValues.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basics",
            "suites": [
                "mapValues",
                "mapValues"
            ],
            "updatePoint": {
                "line": 87,
                "column": 14
            },
            "line": 87,
            "code": "    it('basics', done => {\n      var running = 0;\n      var concurrency = {\n        a: 4,\n        b: 3,\n        c: 2,\n        d: 1\n      };\n      async.mapValues(obj, (val, key, next) => {\n        running++;\n        async.setImmediate(() => {\n          expect(running).to.equal(concurrency[key]);\n          running--;\n          next(null, key + val);\n        });\n      }, (err, result) => {\n        expect(running).to.equal(0);\n        expect(err).to.eql(null);\n        expect(result).to.eql({\n          a: 'a1',\n          b: 'b2',\n          c: 'c3',\n          d: 'd4'\n        });\n        done();\n      });\n    });",
            "file": "mapValues.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "canceled",
            "suites": [
                "mapValues",
                "mapValues"
            ],
            "updatePoint": {
                "line": 114,
                "column": 16
            },
            "line": 114,
            "code": "    it('canceled', done => {\n      var callOrder = [];\n      async.mapValues(obj, (val, key, next) => {\n        callOrder.push(val, key);\n\n        if (key === 'b') {\n          return next(false, val);\n        }\n\n        next(null, val);\n      }, () => {\n        throw new Error('should not get here');\n      });\n      setTimeout(() => {\n        expect(callOrder).to.eql([1, 'a', 2, 'b']);\n        done();\n      }, 25);\n    });",
            "file": "mapValues.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basics",
            "suites": [
                "mapValues",
                "mapValuesSeries"
            ],
            "updatePoint": {
                "line": 134,
                "column": 14
            },
            "line": 134,
            "code": "    it('basics', done => {\n      var running = 0;\n      var concurrency = {\n        a: 1,\n        b: 1,\n        c: 1,\n        d: 1\n      };\n      async.mapValuesSeries(obj, (val, key, next) => {\n        running++;\n        async.setImmediate(() => {\n          expect(running).to.equal(concurrency[key]);\n          running--;\n          next(null, key + val);\n        });\n      }, (err, result) => {\n        expect(running).to.equal(0);\n        expect(err).to.eql(null);\n        expect(result).to.eql({\n          a: 'a1',\n          b: 'b2',\n          c: 'c3',\n          d: 'd4'\n        });\n        done();\n      });\n    });",
            "file": "mapValues.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "canceled",
            "suites": [
                "mapValues",
                "mapValuesSeries"
            ],
            "updatePoint": {
                "line": 161,
                "column": 16
            },
            "line": 161,
            "code": "    it('canceled', done => {\n      var callOrder = [];\n      async.mapValuesSeries(obj, (val, key, next) => {\n        callOrder.push(val, key);\n        async.setImmediate(() => {\n          if (key === 'b') {\n            return next(false, val);\n          }\n\n          next(null, val);\n        });\n      }, () => {\n        throw new Error('should not get here');\n      });\n      setTimeout(() => {\n        expect(callOrder).to.eql([1, 'a', 2, 'b']);\n        done();\n      }, 50);\n    });",
            "file": "mapValues.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "memoize",
            "suites": [
                "memoize"
            ],
            "updatePoint": {
                "line": 10,
                "column": 13
            },
            "line": 10,
            "code": "  it('memoize', done => {\n    var call_order = [];\n\n    var fn = function (arg1, arg2, callback) {\n      async.setImmediate(() => {\n        call_order.push(['fn', arg1, arg2]);\n        callback(null, arg1 + arg2);\n      });\n    };\n\n    var fn2 = async.memoize(fn);\n    fn2(1, 2, (err, result) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(result).to.equal(3);\n      fn2(1, 2, (err2, result2) => {\n        expect(result2).to.equal(3);\n        fn2(2, 2, (err3, result3) => {\n          expect(result3).to.equal(4);\n          expect(call_order).to.eql([['fn', 1, 2], ['fn', 2, 2]]);\n          done();\n        });\n      });\n    });\n  });",
            "file": "memoize.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "maintains asynchrony",
            "suites": [
                "memoize"
            ],
            "updatePoint": {
                "line": 34,
                "column": 26
            },
            "line": 34,
            "code": "  it('maintains asynchrony', done => {\n    var call_order = [];\n\n    var fn = function (arg1, arg2, callback) {\n      call_order.push(['fn', arg1, arg2]);\n      async.setImmediate(() => {\n        call_order.push(['cb', arg1, arg2]);\n        callback(null, arg1 + arg2);\n      });\n    };\n\n    var fn2 = async.memoize(fn);\n    fn2(1, 2, (err, result) => {\n      expect(result).to.equal(3);\n      fn2(1, 2, (err2, result2) => {\n        expect(result2).to.equal(3);\n        async.nextTick(memoize_done);\n        call_order.push('tick3');\n      });\n      call_order.push('tick2');\n    });\n    call_order.push('tick1');\n\n    function memoize_done() {\n      var async_call_order = [['fn', 1, 2], // initial async call\n      'tick1', // async caller\n      ['cb', 1, 2], // async callback\n      //  ['fn',1,2], // memoized // memoized async body\n      'tick2', // handler for first async call\n      //  ['cb',1,2], // memoized // memoized async response body\n      'tick3' // handler for memoized async call\n      ];\n      expect(call_order).to.eql(async_call_order);\n      done();\n    }\n  });",
            "file": "memoize.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "unmemoize",
            "suites": [
                "memoize"
            ],
            "updatePoint": {
                "line": 70,
                "column": 15
            },
            "line": 70,
            "code": "  it('unmemoize', done => {\n    var call_order = [];\n\n    var fn = function (arg1, arg2, callback) {\n      call_order.push(['fn', arg1, arg2]);\n      async.setImmediate(() => {\n        callback(null, arg1 + arg2);\n      });\n    };\n\n    var fn2 = async.memoize(fn);\n    var fn3 = async.unmemoize(fn2);\n    fn3(1, 2, (err, result) => {\n      expect(result).to.equal(3);\n      fn3(1, 2, (err2, result2) => {\n        expect(result2).to.equal(3);\n        fn3(2, 2, (err3, result3) => {\n          expect(result3).to.equal(4);\n          expect(call_order).to.eql([['fn', 1, 2], ['fn', 1, 2], ['fn', 2, 2]]);\n          done();\n        });\n      });\n    });\n  });",
            "file": "memoize.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "unmemoize a not memoized function",
            "suites": [
                "memoize"
            ],
            "updatePoint": {
                "line": 94,
                "column": 39
            },
            "line": 94,
            "code": "  it('unmemoize a not memoized function', done => {\n    var fn = function (arg1, arg2, callback) {\n      callback(null, arg1 + arg2);\n    };\n\n    var fn2 = async.unmemoize(fn);\n    fn2(1, 2, (err, result) => {\n      expect(result).to.equal(3);\n      done();\n    });\n  });",
            "file": "memoize.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "error",
            "suites": [
                "memoize"
            ],
            "updatePoint": {
                "line": 105,
                "column": 11
            },
            "line": 105,
            "code": "  it('error', done => {\n    var testerr = new Error('test');\n\n    var fn = function (arg1, arg2, callback) {\n      callback(testerr, arg1 + arg2);\n    };\n\n    async.memoize(fn)(1, 2, err => {\n      expect(err).to.equal(testerr);\n      done();\n    });\n  });",
            "file": "memoize.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not memoize result if error occurs",
            "suites": [
                "memoize"
            ],
            "updatePoint": {
                "line": 117,
                "column": 47
            },
            "line": 117,
            "code": "  it('should not memoize result if error occurs', done => {\n    var testerr = new Error('test');\n\n    var fn = function (arg1, arg2, callback) {\n      callback(testerr, arg1 + arg2);\n    };\n\n    var memoized = async.memoize(fn);\n    memoized(1, 2, err => {\n      expect(err).to.equal(testerr);\n      testerr = null;\n      memoized(1, 3, (err2, result) => {\n        expect(err2).to.equal(null);\n        expect(result).to.equal(4);\n        done();\n      });\n    });\n  });",
            "file": "memoize.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "multiple calls",
            "suites": [
                "memoize"
            ],
            "updatePoint": {
                "line": 135,
                "column": 20
            },
            "line": 135,
            "code": "  it('multiple calls', done => {\n    var fn = function (arg1, arg2, callback) {\n      assert(true);\n      setTimeout(() => {\n        callback(null, arg1, arg2);\n      }, 10);\n    };\n\n    var fn2 = async.memoize(fn);\n    fn2(1, 2, (err, result) => {\n      expect(result).to.equal(1, 2);\n    });\n    fn2(1, 2, (err, result) => {\n      expect(result).to.equal(1, 2);\n      done();\n    });\n  });",
            "file": "memoize.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "custom hash function",
            "suites": [
                "memoize"
            ],
            "updatePoint": {
                "line": 152,
                "column": 26
            },
            "line": 152,
            "code": "  it('custom hash function', done => {\n    var fn = function (arg1, arg2, callback) {\n      callback(null, arg1 + arg2);\n    };\n\n    var fn2 = async.memoize(fn, () => {\n      return 'custom hash';\n    });\n    fn2(1, 2, (err, result) => {\n      expect(result).to.equal(3);\n      fn2(2, 2, (err2, result2) => {\n        expect(result2).to.equal(3);\n        done();\n      });\n    });\n  });",
            "file": "memoize.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "manually added memo value",
            "suites": [
                "memoize"
            ],
            "updatePoint": {
                "line": 168,
                "column": 31
            },
            "line": 168,
            "code": "  it('manually added memo value', done => {\n    var fn = async.memoize(() => {\n      throw new Error(\"Function should never be called\");\n    });\n    fn.memo.foo = [\"bar\"];\n    fn(\"foo\", (err, val) => {\n      expect(val).to.equal(\"bar\");\n      done();\n    });\n  });",
            "file": "memoize.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "avoid constructor key return undefined",
            "suites": [
                "memoize"
            ],
            "updatePoint": {
                "line": 178,
                "column": 44
            },
            "line": 178,
            "code": "  it('avoid constructor key return undefined', done => {\n    var fn = async.memoize((name, callback) => {\n      setTimeout(() => {\n        callback(null, name);\n      }, 100);\n    });\n    fn('constructor', (error, results) => {\n      expect(results).to.equal('constructor');\n      done();\n    });\n  });",
            "file": "memoize.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "avoid __proto__ key return undefined",
            "suites": [
                "memoize"
            ],
            "updatePoint": {
                "line": 189,
                "column": 42
            },
            "line": 189,
            "code": "  it('avoid __proto__ key return undefined', done => {\n    // Skip test if there is a Object.create bug (node 0.10 and some Chrome 30x versions)\n    var x = Object.create(null);\n    /* jshint proto: true */\n\n    x.__proto__ = 'foo';\n\n    if (x.__proto__ !== 'foo') {\n      return done();\n    }\n\n    var fn = async.memoize((name, callback) => {\n      setTimeout(() => {\n        callback(null, name);\n      }, 100);\n    });\n    fn('__proto__', (error, results) => {\n      expect(results).to.equal('__proto__');\n      done();\n    });\n  });",
            "file": "memoize.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "allow hasOwnProperty as key",
            "suites": [
                "memoize"
            ],
            "updatePoint": {
                "line": 210,
                "column": 33
            },
            "line": 210,
            "code": "  it('allow hasOwnProperty as key', done => {\n    var fn = async.memoize((name, callback) => {\n      setTimeout(() => {\n        callback(null, name);\n      }, 100);\n    });\n    fn('hasOwnProperty', (error, results) => {\n      expect(results).to.equal('hasOwnProperty');\n      done();\n    });\n  });",
            "file": "memoize.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basics",
            "suites": [
                "nextTick"
            ],
            "updatePoint": {
                "line": 8,
                "column": 12
            },
            "line": 8,
            "code": "  it('basics', done => {\n    var call_order = [];\n    async.nextTick(() => {\n      call_order.push('two');\n    });\n    call_order.push('one');\n    setTimeout(() => {\n      expect(call_order).to.eql(['one', 'two']);\n      done();\n    }, 50);\n  });",
            "file": "nextTick.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "nextTick in the browser @nodeonly",
            "suites": [
                "nextTick"
            ],
            "updatePoint": {
                "line": 19,
                "column": 39
            },
            "line": 19,
            "code": "  it('nextTick in the browser @nodeonly', done => {\n    var call_order = [];\n    async.nextTick(() => {\n      call_order.push('two');\n    });\n    call_order.push('one');\n    setTimeout(() => {\n      expect(call_order).to.eql(['one', 'two']);\n      done();\n    }, 50);\n  });",
            "file": "nextTick.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "extra args",
            "suites": [
                "nextTick"
            ],
            "updatePoint": {
                "line": 30,
                "column": 16
            },
            "line": 30,
            "code": "  it(\"extra args\", done => {\n    async.nextTick((a, b, c) => {\n      expect([a, b, c]).to.eql([1, 2, 3]);\n      done();\n    }, 1, 2, 3);\n  });",
            "file": "nextTick.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 12,
                "column": 14
            },
            "line": 12,
            "code": "  it('parallel', done => {\n    var call_order = [];\n    async.parallel([function (callback) {\n      setTimeout(() => {\n        call_order.push(1);\n        callback(null, 1);\n      }, 50);\n    }, function (callback) {\n      setTimeout(() => {\n        call_order.push(2);\n        callback(null, 2);\n      }, 100);\n    }, function (callback) {\n      setTimeout(() => {\n        call_order.push(3);\n        callback(null, 3, 3);\n      }, 25);\n    }], (err, results) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(call_order).to.eql([3, 1, 2]);\n      expect(results).to.eql([1, 2, [3, 3]]);\n      done();\n    });\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel empty array",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 36,
                "column": 26
            },
            "line": 36,
            "code": "  it('parallel empty array', done => {\n    async.parallel([], (err, results) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(results).to.eql([]);\n      done();\n    });\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel error",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 43,
                "column": 20
            },
            "line": 43,
            "code": "  it('parallel error', done => {\n    async.parallel([function (callback) {\n      callback('error', 1);\n    }, function (callback) {\n      callback('error2', 2);\n    }], err => {\n      expect(err).to.equal('error');\n    });\n    setTimeout(done, 100);\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel canceled",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 53,
                "column": 23
            },
            "line": 53,
            "code": "  it('parallel canceled', done => {\n    var call_order = [];\n    async.parallel([function (callback) {\n      call_order.push('one');\n      callback(false);\n    }, function (callback) {\n      call_order.push('two');\n      callback(null);\n    }], () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql(['one', 'two']);\n      done();\n    }, 25);\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel no callback",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 69,
                "column": 26
            },
            "line": 69,
            "code": "  it('parallel no callback', done => {\n    async.parallel([function (callback) {\n      callback();\n    }, function (callback) {\n      callback();\n      done();\n    }]);\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel object",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 77,
                "column": 21
            },
            "line": 77,
            "code": "  it('parallel object', done => {\n    var call_order = [];\n    async.parallel(getFunctionsObject(call_order), (err, results) => {\n      expect(err).to.equal(null);\n      expect(call_order).to.eql([3, 1, 2]);\n      expect(results).to.eql({\n        one: 1,\n        two: 2,\n        three: [3, 3]\n      });\n      done();\n    });\n  }); // Issue 10 on github: https://github.com/caolan/async/issues#issue/10",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "paralel falsy return values",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 91,
                "column": 33
            },
            "line": 91,
            "code": "  it('paralel falsy return values', done => {\n    function taskFalse(callback) {\n      async.nextTick(() => {\n        callback(null, false);\n      });\n    }\n\n    function taskUndefined(callback) {\n      async.nextTick(() => {\n        callback(null, undefined);\n      });\n    }\n\n    function taskEmpty(callback) {\n      async.nextTick(() => {\n        callback(null);\n      });\n    }\n\n    function taskNull(callback) {\n      async.nextTick(() => {\n        callback(null, null);\n      });\n    }\n\n    async.parallel([taskFalse, taskUndefined, taskEmpty, taskNull], (err, results) => {\n      expect(results.length).to.equal(4);\n      assert.strictEqual(results[0], false);\n      assert.strictEqual(results[1], undefined);\n      assert.strictEqual(results[2], undefined);\n      assert.strictEqual(results[3], null);\n      done();\n    });\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel limit",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 125,
                "column": 20
            },
            "line": 125,
            "code": "  it('parallel limit', done => {\n    var call_order = [];\n    async.parallelLimit([function (callback) {\n      setTimeout(() => {\n        call_order.push(1);\n        callback(null, 1);\n      }, 10);\n    }, function (callback) {\n      setTimeout(() => {\n        call_order.push(2);\n        callback(null, 2);\n      }, 180);\n    }, function (callback) {\n      setTimeout(() => {\n        call_order.push(3);\n        callback(null, 3, 3);\n      }, 10);\n    }], 2, (err, results) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(call_order).to.eql([1, 3, 2]);\n      expect(results).to.eql([1, 2, [3, 3]]);\n      done();\n    });\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel limit empty array",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 149,
                "column": 32
            },
            "line": 149,
            "code": "  it('parallel limit empty array', done => {\n    async.parallelLimit([], 2, (err, results) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(results).to.eql([]);\n      done();\n    });\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel limit error",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 156,
                "column": 26
            },
            "line": 156,
            "code": "  it('parallel limit error', done => {\n    async.parallelLimit([function (callback) {\n      callback('error', 1);\n    }, function (callback) {\n      callback('error2', 2);\n    }], 1, err => {\n      expect(err).to.equal('error');\n    });\n    setTimeout(done, 100);\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel limit no callback",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 166,
                "column": 32
            },
            "line": 166,
            "code": "  it('parallel limit no callback', done => {\n    async.parallelLimit([function (callback) {\n      callback();\n    }, function (callback) {\n      callback();\n      done();\n    }], 1);\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel limit object",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 174,
                "column": 27
            },
            "line": 174,
            "code": "  it('parallel limit object', done => {\n    var call_order = [];\n    async.parallelLimit(getFunctionsObject(call_order), 2, (err, results) => {\n      expect(err).to.equal(null);\n      expect(call_order).to.eql([1, 3, 2]);\n      expect(results).to.eql({\n        one: 1,\n        two: 2,\n        three: [3, 3]\n      });\n      done();\n    });\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel limit canceled",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 187,
                "column": 29
            },
            "line": 187,
            "code": "  it('parallel limit canceled', done => {\n    const call_order = [];\n    async.parallelLimit([function (callback) {\n      call_order.push(1);\n      callback();\n    }, function (callback) {\n      call_order.push(2);\n      callback(false);\n    }, function (callback) {\n      call_order.push(3);\n      callback('error', 2);\n    }], 1, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 2]);\n      done();\n    }, 25);\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel call in another context @nycinvalid @nodeonly",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 206,
                "column": 60
            },
            "line": 206,
            "code": "  it('parallel call in another context @nycinvalid @nodeonly', done => {\n    var vm = require('vm');\n\n    var sandbox = {\n      async,\n      done\n    };\n\n    var fn = \"(\" + function () {\n      async.parallel([function (callback) {\n        callback();\n      }], err => {\n        if (err) {\n          return done(err);\n        }\n\n        done();\n      });\n    }.toString() + \"())\";\n\n    vm.runInNewContext(fn, sandbox);\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel error with reflect",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 228,
                "column": 33
            },
            "line": 228,
            "code": "  it('parallel error with reflect', done => {\n    async.parallel([async.reflect(callback => {\n      callback('error', 1);\n    }), async.reflect(callback => {\n      callback('error2', 2);\n    }), async.reflect(callback => {\n      callback(null, 2);\n    }), async.reflect(callback => {\n      callback('error3');\n    })], (err, results) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(results).to.eql([{\n        error: 'error',\n        value: 1\n      }, {\n        error: 'error2',\n        value: 2\n      }, {\n        value: 2\n      }, {\n        error: 'error3'\n      }]);\n      done();\n    });\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel object with reflect all (values and errors)",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 253,
                "column": 58
            },
            "line": 253,
            "code": "  it('parallel object with reflect all (values and errors)', done => {\n    var tasks = {\n      one(callback) {\n        setTimeout(() => {\n          callback(null, 'one');\n        }, 200);\n      },\n\n      two(callback) {\n        callback('two');\n      },\n\n      three(callback) {\n        setTimeout(() => {\n          callback(null, 'three');\n        }, 100);\n      },\n\n      four(callback) {\n        setTimeout(() => {\n          callback('four', 4);\n        }, 100);\n      }\n\n    };\n    async.parallel(async.reflectAll(tasks), (err, results) => {\n      expect(results).to.eql({\n        one: {\n          value: 'one'\n        },\n        two: {\n          error: 'two'\n        },\n        three: {\n          value: 'three'\n        },\n        four: {\n          error: 'four',\n          value: 4\n        }\n      });\n      done();\n    });\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel empty object with reflect all",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 297,
                "column": 44
            },
            "line": 297,
            "code": "  it('parallel empty object with reflect all', done => {\n    var tasks = {};\n    async.parallel(async.reflectAll(tasks), (err, results) => {\n      expect(results).to.eql({});\n      done();\n    });\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel array with reflect all (errors)",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 304,
                "column": 46
            },
            "line": 304,
            "code": "  it('parallel array with reflect all (errors)', done => {\n    var tasks = [function (callback) {\n      callback('one', 1);\n    }, function (callback) {\n      callback('two');\n    }, function (callback) {\n      callback('three', 3);\n    }];\n    async.parallel(async.reflectAll(tasks), (err, results) => {\n      expect(results).to.eql([{\n        error: 'one',\n        value: 1\n      }, {\n        error: 'two'\n      }, {\n        error: 'three',\n        value: 3\n      }]);\n      done();\n    });\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel empty object with reflect all (values)",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 325,
                "column": 53
            },
            "line": 325,
            "code": "  it('parallel empty object with reflect all (values)', done => {\n    var tasks = {\n      one(callback) {\n        callback(null, 'one');\n      },\n\n      two(callback) {\n        callback(null, 'two');\n      },\n\n      three(callback) {\n        callback(null, 'three');\n      }\n\n    };\n    async.parallel(async.reflectAll(tasks), (err, results) => {\n      expect(results).to.eql({\n        one: {\n          value: 'one'\n        },\n        two: {\n          value: 'two'\n        },\n        three: {\n          value: 'three'\n        }\n      });\n      done();\n    });\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "parallel does not continue replenishing after error",
            "suites": [
                "parallel"
            ],
            "updatePoint": {
                "line": 355,
                "column": 57
            },
            "line": 355,
            "code": "  it('parallel does not continue replenishing after error', done => {\n    var started = 0;\n    var arr = [funcToCall, funcToCall, funcToCall, funcToCall, funcToCall, funcToCall, funcToCall, funcToCall, funcToCall];\n    var delay = 10;\n    var limit = 3;\n    var maxTime = 10 * arr.length;\n\n    function funcToCall(callback) {\n      started++;\n\n      if (started === 3) {\n        return callback(new Error(\"Test Error\"));\n      }\n\n      setTimeout(() => {\n        callback();\n      }, delay);\n    }\n\n    async.parallelLimit(arr, limit, () => {});\n    setTimeout(() => {\n      expect(started).to.equal(3);\n      done();\n    }, maxTime);\n  });",
            "file": "parallel.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "priorityQueue",
            "suites": [
                "priorityQueue"
            ],
            "updatePoint": {
                "line": 8,
                "column": 19
            },
            "line": 8,
            "code": "  it('priorityQueue', done => {\n    var call_order = []; // order of completion: 2,1,4,3\n\n    var q = async.priorityQueue((task, callback) => {\n      call_order.push('process ' + task);\n      callback('error', 'arg');\n    }, 1);\n    q.push(1, 1.4, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(q.length()).to.equal(2);\n      call_order.push('callback ' + 1);\n    });\n    q.push(2, 0.2, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(q.length()).to.equal(3);\n      call_order.push('callback ' + 2);\n    });\n    q.push(3, 3.8, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(q.length()).to.equal(0);\n      call_order.push('callback ' + 3);\n    });\n    q.push(4, 2.9, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(q.length()).to.equal(1);\n      call_order.push('callback ' + 4);\n    });\n    expect(q.length()).to.equal(4);\n    expect(q.concurrency).to.equal(1);\n    q.drain(() => {\n      expect(call_order).to.eql(['process 2', 'callback 2', 'process 1', 'callback 1', 'process 4', 'callback 4', 'process 3', 'callback 3']);\n      expect(q.concurrency).to.equal(1);\n      expect(q.length()).to.equal(0);\n      q.push([]);\n      expect(q.length()).to.equal(0);\n      done();\n    });\n\n    try {\n      q.push(5, 5, 'NOT_A_FUNCTION');\n    } catch (e) {\n      expect(e.message).to.equal('task callback must be a function');\n    }\n  });",
            "file": "priorityQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "concurrency",
            "suites": [
                "priorityQueue"
            ],
            "updatePoint": {
                "line": 56,
                "column": 17
            },
            "line": 56,
            "code": "  it('concurrency', done => {\n    var call_order = [],\n        delays = [80, 20, 180, 20]; // worker1: --2-3\n    // worker2: -1---4\n    // order of completion: 1,2,3,4\n\n    var q = async.priorityQueue((task, callback) => {\n      setTimeout(() => {\n        call_order.push('process ' + task);\n        callback('error', 'arg');\n      }, delays.shift());\n    }, 2);\n    q.push(1, 1.4, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(q.length()).to.equal(2);\n      call_order.push('callback ' + 1);\n    });\n    q.push(2, 0.2, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(q.length()).to.equal(1);\n      call_order.push('callback ' + 2);\n    });\n    q.push(3, 3.8, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(q.length()).to.equal(0);\n      call_order.push('callback ' + 3);\n    });\n    q.push(4, 2.9, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(q.length()).to.equal(0);\n      call_order.push('callback ' + 4);\n    });\n    expect(q.length()).to.equal(4);\n    expect(q.concurrency).to.equal(2);\n    q.drain(() => {\n      expect(call_order).to.eql(['process 1', 'callback 1', 'process 2', 'callback 2', 'process 3', 'callback 3', 'process 4', 'callback 4']);\n      expect(q.concurrency).to.equal(2);\n      expect(q.length()).to.equal(0);\n      done();\n    });\n  });",
            "file": "priorityQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "pause in worker with concurrency",
            "suites": [
                "priorityQueue"
            ],
            "updatePoint": {
                "line": 101,
                "column": 38
            },
            "line": 101,
            "code": "  it('pause in worker with concurrency', done => {\n    var call_order = [];\n    var q = async.priorityQueue((task, callback) => {\n      if (task.isLongRunning) {\n        q.pause();\n        setTimeout(() => {\n          call_order.push(task.id);\n          q.resume();\n          callback();\n        }, 50);\n      } else {\n        call_order.push(task.id);\n        setTimeout(callback, 10);\n      }\n    }, 10);\n    q.push({\n      id: 1,\n      isLongRunning: true\n    });\n    q.push({\n      id: 2\n    });\n    q.push({\n      id: 3\n    });\n    q.push({\n      id: 4\n    });\n    q.push({\n      id: 5\n    });\n    q.drain(() => {\n      expect(call_order).to.eql([1, 2, 3, 4, 5]);\n      done();\n    });\n  });",
            "file": "priorityQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should call the saturated callback if tasks length is concurrency",
            "suites": [
                "priorityQueue",
                "q.saturated(): "
            ],
            "updatePoint": {
                "line": 138,
                "column": 73
            },
            "line": 138,
            "code": "    it('should call the saturated callback if tasks length is concurrency', done => {\n      var calls = [];\n      var q = async.priorityQueue((task, cb) => {\n        calls.push('process ' + task);\n        async.setImmediate(cb);\n      }, 4);\n      q.saturated(() => {\n        calls.push('saturated');\n      });\n      q.empty(() => {\n        expect(calls.indexOf('saturated')).to.be.above(-1);\n        setTimeout(() => {\n          expect(calls).eql(['process foo4', 'process foo3', 'process foo2', \"saturated\", 'process foo1', 'foo4 cb', \"saturated\", 'process foo0', 'foo3 cb', 'foo2 cb', 'foo1 cb', 'foo0 cb']);\n          done();\n        }, 50);\n      });\n      q.push('foo0', 5, () => {\n        calls.push('foo0 cb');\n      });\n      q.push('foo1', 4, () => {\n        calls.push('foo1 cb');\n      });\n      q.push('foo2', 3, () => {\n        calls.push('foo2 cb');\n      });\n      q.push('foo3', 2, () => {\n        calls.push('foo3 cb');\n      });\n      q.push('foo4', 1, () => {\n        calls.push('foo4 cb');\n      });\n    });",
            "file": "priorityQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should have a default buffer property that equals 25% of the concurrenct rate",
            "suites": [
                "priorityQueue",
                "q.unsaturated(): "
            ],
            "updatePoint": {
                "line": 172,
                "column": 85
            },
            "line": 172,
            "code": "    it('should have a default buffer property that equals 25% of the concurrenct rate', done => {\n      var calls = [];\n      var q = async.priorityQueue((task, cb) => {\n        // nop\n        calls.push('process ' + task);\n        async.setImmediate(cb);\n      }, 10);\n      expect(q.buffer).to.equal(2.5);\n      done();\n    });",
            "file": "priorityQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should allow a user to change the buffer property",
            "suites": [
                "priorityQueue",
                "q.unsaturated(): "
            ],
            "updatePoint": {
                "line": 182,
                "column": 57
            },
            "line": 182,
            "code": "    it('should allow a user to change the buffer property', done => {\n      var calls = [];\n      var q = async.priorityQueue((task, cb) => {\n        // nop\n        calls.push('process ' + task);\n        async.setImmediate(cb);\n      }, 10);\n      q.buffer = 4;\n      expect(q.buffer).to.not.equal(2.5);\n      expect(q.buffer).to.equal(4);\n      done();\n    });",
            "file": "priorityQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should call the unsaturated callback if tasks length is less than concurrency minus buffer",
            "suites": [
                "priorityQueue",
                "q.unsaturated(): "
            ],
            "updatePoint": {
                "line": 194,
                "column": 98
            },
            "line": 194,
            "code": "    it('should call the unsaturated callback if tasks length is less than concurrency minus buffer', done => {\n      var calls = [];\n      var q = async.priorityQueue((task, cb) => {\n        calls.push('process ' + task);\n        setTimeout(cb, 10);\n      }, 4);\n      q.unsaturated(() => {\n        calls.push('unsaturated');\n      });\n      q.empty(() => {\n        expect(calls.indexOf('unsaturated')).to.be.above(-1);\n        setTimeout(() => {\n          expect(calls).eql(['process foo4', 'process foo3', 'process foo2', 'process foo1', 'foo4 cb', 'unsaturated', 'process foo0', 'foo3 cb', 'unsaturated', 'foo2 cb', 'unsaturated', 'foo1 cb', 'unsaturated', 'foo0 cb', 'unsaturated']);\n          done();\n        }, 50);\n      });\n      q.push('foo0', 5, () => {\n        calls.push('foo0 cb');\n      });\n      q.push('foo1', 4, () => {\n        calls.push('foo1 cb');\n      });\n      q.push('foo2', 3, () => {\n        calls.push('foo2 cb');\n      });\n      q.push('foo3', 2, () => {\n        calls.push('foo3 cb');\n      });\n      q.push('foo4', 1, () => {\n        calls.push('foo4 cb');\n      });\n    });",
            "file": "priorityQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not call the drain callback if receives empty push and tasks are still pending",
            "suites": [
                "priorityQueue",
                "q.unsaturated(): "
            ],
            "updatePoint": {
                "line": 227,
                "column": 91
            },
            "line": 227,
            "code": "  it('should not call the drain callback if receives empty push and tasks are still pending', done => {\n    var call_order = [];\n    var q = async.priorityQueue((task, callback) => {\n      call_order.push('process ' + task);\n      callback('error', 'arg');\n    }, 1);\n    q.push(1, 1, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      call_order.push('callback ' + 1);\n    });\n    q.push(2, 1, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      call_order.push('callback ' + 2);\n    });\n    expect(q.length()).to.equal(2);\n    q.drain(() => {\n      expect(call_order).to.eql(['process 1', 'callback 1', 'process 2', 'callback 2']);\n      expect(q.concurrency).to.equal(1);\n      expect(q.length()).to.equal(0);\n      expect(q.running()).to.equal(0);\n      done();\n    });\n    q.push([], 1, () => {});\n  });",
            "file": "priorityQueue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basics",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 12,
                "column": 12
            },
            "line": 12,
            "code": "  it('basics', done => {\n    var call_order = [];\n    var delays = [50, 10, 180, 10]; // worker1: --1-4\n    // worker2: -2---3\n    // order of completion: 2,1,4,3\n\n    var q = async.queue((task, callback) => {\n      setTimeout(() => {\n        call_order.push('process ' + task);\n        callback('error', 'arg');\n      }, delays.shift());\n    }, 2);\n    q.push(1, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(q.length()).to.equal(1);\n      call_order.push('callback ' + 1);\n    });\n    q.push(2, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(q.length()).to.equal(2);\n      call_order.push('callback ' + 2);\n    });\n    q.push(3, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(q.length()).to.equal(0);\n      call_order.push('callback ' + 3);\n    });\n    q.push(4, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(q.length()).to.equal(0);\n      call_order.push('callback ' + 4);\n    });\n    expect(q.length()).to.equal(4);\n    expect(q.concurrency).to.equal(2);\n    q.drain(() => {\n      expect(call_order).to.eql(['process 2', 'callback 2', 'process 1', 'callback 1', 'process 4', 'callback 4', 'process 3', 'callback 3']);\n      expect(q.concurrency).to.equal(2);\n      expect(q.length()).to.equal(0);\n      done();\n    });\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "default concurrency",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 57,
                "column": 25
            },
            "line": 57,
            "code": "  it('default concurrency', done => {\n    var call_order = [],\n        delays = [50, 10, 180, 10]; // order of completion: 1,2,3,4\n\n    var q = async.queue((task, callback) => {\n      setTimeout(() => {\n        call_order.push('process ' + task);\n        callback('error', 'arg');\n      }, delays.shift());\n    });\n    q.push(1, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(q.length()).to.equal(3);\n      call_order.push('callback ' + 1);\n    });\n    q.push(2, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(q.length()).to.equal(2);\n      call_order.push('callback ' + 2);\n    });\n    q.push(3, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(q.length()).to.equal(1);\n      call_order.push('callback ' + 3);\n    });\n    q.push(4, (err, arg) => {\n      expect(err).to.equal('error');\n      expect(arg).to.equal('arg');\n      expect(q.length()).to.equal(0);\n      call_order.push('callback ' + 4);\n    });\n    expect(q.length()).to.equal(4);\n    expect(q.concurrency).to.equal(1);\n    q.drain(() => {\n      expect(call_order).to.eql(['process 1', 'callback 1', 'process 2', 'callback 2', 'process 3', 'callback 3', 'process 4', 'callback 4']);\n      expect(q.concurrency).to.equal(1);\n      expect(q.length()).to.equal(0);\n      done();\n    });\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "zero concurrency",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 100,
                "column": 22
            },
            "line": 100,
            "code": "  it('zero concurrency', done => {\n    expect(() => {\n      async.queue((task, callback) => {\n        callback(null, task);\n      }, 0);\n    }).to.throw();\n    done();\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "error propagation",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 108,
                "column": 23
            },
            "line": 108,
            "code": "  it('error propagation', done => {\n    var results = [];\n    var q = async.queue((task, callback) => {\n      callback(task.name === 'foo' ? new Error('fooError') : null);\n    }, 2);\n    q.drain(() => {\n      expect(results).to.eql(['bar', 'fooError']);\n      done();\n    });\n    q.push({\n      name: 'bar'\n    }, err => {\n      if (err) {\n        results.push('barError');\n        return;\n      }\n\n      results.push('bar');\n    });\n    q.push({\n      name: 'foo'\n    }, err => {\n      if (err) {\n        results.push('fooError');\n        return;\n      }\n\n      results.push('foo');\n    });\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "pushAsync",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 138,
                "column": 15
            },
            "line": 138,
            "code": "  it('pushAsync', done => {\n    const calls = [];\n    var q = async.queue((task, cb) => {\n      if (task === 2) return cb(new Error('fail'));\n      cb();\n    });\n    q.pushAsync(1, () => {\n      throw new Error('should not be called');\n    }).then(() => calls.push(1));\n    q.pushAsync(2).catch(err => {\n      expect(err.message).to.equal('fail');\n      calls.push(2);\n    });\n    q.pushAsync([3, 4]).map(p => p.then(() => calls.push('arr')));\n    q.drain(() => setTimeout(() => {\n      console.log('drain');\n      expect(calls).to.eql([1, 2, 'arr', 'arr']);\n      done();\n    }));\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "unshiftAsync",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 158,
                "column": 18
            },
            "line": 158,
            "code": "  it('unshiftAsync', done => {\n    const calls = [];\n    var q = async.queue((task, cb) => {\n      if (task === 2) return cb(new Error('fail'));\n      cb();\n    });\n    q.unshiftAsync(1).then(() => calls.push(1));\n    q.unshiftAsync(2).catch(err => {\n      expect(err.message).to.equal('fail');\n      calls.push(2);\n    });\n    q.unshiftAsync([3, 4]).map(p => p.then(() => calls.push('arr')));\n    q.drain(() => setTimeout(() => {\n      console.log('drain');\n      expect(calls).to.eql(['arr', 'arr', 2, 1]);\n      done();\n    }));\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "global error handler",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 176,
                "column": 26
            },
            "line": 176,
            "code": "  it('global error handler', done => {\n    var results = [];\n    var q = async.queue((task, callback) => {\n      callback(task.name === 'foo' ? new Error('fooError') : null);\n    }, 2);\n    q.error((error, task) => {\n      expect(error).to.exist;\n      expect(error.message).to.equal('fooError');\n      expect(task.name).to.equal('foo');\n      results.push('fooError');\n    });\n    q.drain(() => {\n      expect(results).to.eql(['fooError', 'bar']);\n      done();\n    });\n    q.push({\n      name: 'foo'\n    });\n    q.push({\n      name: 'bar'\n    }, error => {\n      expect(error).to.not.exist;\n      results.push('bar');\n    });\n  }); // The original queue implementation allowed the concurrency to be changed only",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "changing concurrency",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 207,
                "column": 26
            },
            "line": 207,
            "code": "  it('changing concurrency', done => {\n    var q = async.queue((task, callback) => {\n      setTimeout(() => {\n        callback();\n      }, 10);\n    }, 1);\n\n    for (var i = 0; i < 50; i++) {\n      q.push('');\n    }\n\n    q.drain(done);\n    setTimeout(() => {\n      expect(q.concurrency).to.equal(1);\n      q.concurrency = 2;\n      setTimeout(() => {\n        expect(q.running()).to.equal(2);\n        q.concurrency = 5;\n        setTimeout(() => {\n          expect(q.running()).to.equal(5);\n        }, 40);\n      }, 40);\n    }, 40);\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "push without callback",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 231,
                "column": 27
            },
            "line": 231,
            "code": "  it('push without callback', function (done) {\n    this.retries(3); // test can be flakey\n\n    var call_order = [];\n    var delays = [50, 10, 180, 10];\n    var concurrencyList = [];\n    var running = 0; // worker1: --1-4\n    // worker2: -2---3\n    // order of completion: 2,1,4,3\n\n    var q = async.queue((task, callback) => {\n      running++;\n      concurrencyList.push(running);\n      setTimeout(() => {\n        call_order.push('process ' + task);\n        running--;\n        callback('error', 'arg');\n      }, delays.shift());\n    }, 2);\n    q.push(1);\n    q.push(2);\n    q.push(3);\n    q.push(4);\n    q.drain(() => {\n      expect(running).to.eql(0);\n      expect(concurrencyList).to.eql([1, 2, 2, 2]);\n      expect(call_order).to.eql(['process 2', 'process 1', 'process 4', 'process 3']);\n      done();\n    });\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "push with non-function",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 261,
                "column": 28
            },
            "line": 261,
            "code": "  it('push with non-function', done => {\n    var q = async.queue(() => {}, 1);\n    expect(() => {\n      q.push({}, 1);\n    }).to.throw();\n    done();\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "push with arrays",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 268,
                "column": 22
            },
            "line": 268,
            "code": "  it('push with arrays', done => {\n    const tasks = [];\n    var q = async.queue((task, cb) => {\n      tasks.push(task);\n      cb();\n    }, 1);\n    q.push([[1, 2, 3], [4, 5, 6]]);\n    q.drain(() => {\n      expect(tasks).to.eql([[1, 2, 3], [4, 5, 6]]);\n      done();\n    });\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "unshift",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 280,
                "column": 13
            },
            "line": 280,
            "code": "  it('unshift', done => {\n    var queue_order = [];\n    var q = async.queue((task, callback) => {\n      queue_order.push(task);\n      callback();\n    }, 1);\n    q.unshift(4);\n    q.unshift(3);\n    q.unshift(2);\n    q.unshift(1);\n    setTimeout(() => {\n      expect(queue_order).to.eql([1, 2, 3, 4]);\n      done();\n    }, 100);\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "too many callbacks",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 295,
                "column": 24
            },
            "line": 295,
            "code": "  it('too many callbacks', done => {\n    var q = async.queue((task, callback) => {\n      callback();\n      expect(() => {\n        callback();\n      }).to.throw();\n      done();\n    }, 2);\n    q.push(1);\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "bulk task",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 305,
                "column": 15
            },
            "line": 305,
            "code": "  it('bulk task', done => {\n    var call_order = [],\n        delays = [50, 10, 180, 10]; // worker1: --1-4\n    // worker2: -2---3\n    // order of completion: 2,1,4,3\n\n    var q = async.queue((task, callback) => {\n      setTimeout(() => {\n        call_order.push('process ' + task);\n        callback('error', task);\n      }, delays.splice(0, 1)[0]);\n    }, 2);\n    q.push([1, 2, 3, 4], (err, arg) => {\n      expect(err).to.equal('error');\n      call_order.push('callback ' + arg);\n    });\n    expect(q.length()).to.equal(4);\n    expect(q.concurrency).to.equal(2);\n    q.drain(() => {\n      expect(call_order).to.eql(['process 2', 'callback 2', 'process 1', 'callback 1', 'process 4', 'callback 4', 'process 3', 'callback 3']);\n      expect(q.concurrency).to.equal(2);\n      expect(q.length()).to.equal(0);\n      done();\n    });\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "idle",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 330,
                "column": 10
            },
            "line": 330,
            "code": "  it('idle', done => {\n    var q = async.queue((task, callback) => {\n      // Queue is busy when workers are running\n      expect(q.idle()).to.equal(false);\n      callback();\n    }, 1); // Queue is idle before anything added\n\n    expect(q.idle()).to.equal(true);\n    q.unshift(4);\n    q.unshift(3);\n    q.unshift(2);\n    q.unshift(1); // Queue is busy when tasks added\n\n    expect(q.idle()).to.equal(false);\n    q.drain(() => {\n      // Queue is idle after drain\n      expect(q.idle()).to.equal(true);\n      done();\n    });\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "pause",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 350,
                "column": 11
            },
            "line": 350,
            "code": "  it('pause', done => {\n    var call_order = [];\n    var running = 0;\n    var concurrencyList = [];\n    var pauseCalls = ['process 1', 'process 2', 'process 3'];\n    var q = async.queue((task, callback) => {\n      running++;\n      call_order.push('process ' + task);\n      concurrencyList.push(running);\n      setTimeout(() => {\n        running--;\n        callback();\n      }, 10);\n    }, 2);\n    q.push(1);\n    q.push(2, after2);\n    q.push(3);\n\n    function after2() {\n      q.pause();\n      expect(concurrencyList).to.eql([1, 2, 2]);\n      expect(call_order).to.eql(pauseCalls);\n      setTimeout(whilePaused, 5);\n      setTimeout(afterPause, 10);\n    }\n\n    function whilePaused() {\n      q.push(4);\n    }\n\n    function afterPause() {\n      expect(concurrencyList).to.eql([1, 2, 2]);\n      expect(call_order).to.eql(pauseCalls);\n      q.resume();\n      q.push(5);\n      q.push(6);\n      q.drain(drain);\n    }\n\n    function drain() {\n      expect(concurrencyList).to.eql([1, 2, 2, 1, 2, 2]);\n      expect(call_order).to.eql(['process 1', 'process 2', 'process 3', 'process 4', 'process 5', 'process 6']);\n      done();\n    }\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "pause in worker with concurrency",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 395,
                "column": 38
            },
            "line": 395,
            "code": "  it('pause in worker with concurrency', done => {\n    var call_order = [];\n    var q = async.queue((task, callback) => {\n      if (task.isLongRunning) {\n        q.pause();\n        setTimeout(() => {\n          call_order.push(task.id);\n          q.resume();\n          callback();\n        }, 50);\n      } else {\n        call_order.push(task.id);\n        setTimeout(callback, 10);\n      }\n    }, 10);\n    q.push({\n      id: 1,\n      isLongRunning: true\n    });\n    q.push({\n      id: 2\n    });\n    q.push({\n      id: 3\n    });\n    q.push({\n      id: 4\n    });\n    q.push({\n      id: 5\n    });\n    q.drain(() => {\n      expect(call_order).to.eql([1, 2, 3, 4, 5]);\n      done();\n    });\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "start paused",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 431,
                "column": 18
            },
            "line": 431,
            "code": "  it('start paused', done => {\n    var q = async.queue((task, callback) => {\n      if (task === 2) {\n        expect(q.length()).to.equal(1);\n        expect(q.running()).to.equal(2);\n      }\n\n      setTimeout(() => {\n        callback();\n      }, 40);\n    }, 2);\n    q.pause();\n    q.push([1, 2, 3]);\n    setTimeout(() => {\n      expect(q.running()).to.equal(0);\n      q.resume();\n    }, 5);\n    q.drain(done);\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "kill",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 450,
                "column": 10
            },
            "line": 450,
            "code": "  it('kill', done => {\n    var q = async.queue(() => {\n      setTimeout(() => {\n        throw new Error(\"Function should never be called\");\n      }, 20);\n    }, 1);\n    q.drain(() => {\n      throw new Error(\"Function should never be called\");\n    });\n    q.push(0);\n    q.kill();\n    setTimeout(() => {\n      expect(q.length()).to.equal(0);\n      done();\n    }, 40);\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "events",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 466,
                "column": 12
            },
            "line": 466,
            "code": "  it('events', done => {\n    var calls = [];\n    var q = async.queue((task, cb) => {\n      // nop\n      calls.push('process ' + task);\n      setTimeout(cb, 10);\n    }, 3);\n    q.concurrency = 3;\n    q.saturated(() => {\n      assert(q.running() == 3, 'queue should be saturated now');\n      calls.push('saturated');\n    });\n    q.empty(() => {\n      assert(q.length() === 0, 'queue should be empty now');\n      calls.push('empty');\n    });\n    q.drain(() => {\n      assert(q.length() === 0 && q.running() === 0, 'queue should be empty now and no more workers should be running');\n      calls.push('drain');\n      expect(calls).to.eql(['process foo', 'process bar', 'saturated', 'process zoo', 'foo cb', 'saturated', 'process poo', 'bar cb', 'empty', 'saturated', 'process moo', 'zoo cb', 'poo cb', 'moo cb', 'drain']);\n      done();\n    });\n    q.push('foo', () => {\n      calls.push('foo cb');\n    });\n    q.push('bar', () => {\n      calls.push('bar cb');\n    });\n    q.push('zoo', () => {\n      calls.push('zoo cb');\n    });\n    q.push('poo', () => {\n      calls.push('poo cb');\n    });\n    q.push('moo', () => {\n      calls.push('moo cb');\n    });\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "empty",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 504,
                "column": 11
            },
            "line": 504,
            "code": "  it('empty', done => {\n    var calls = [];\n    var q = async.queue((task, cb) => {\n      // nop\n      calls.push('process ' + task);\n      async.setImmediate(cb);\n    }, 3);\n    q.drain(() => {\n      assert(q.length() === 0 && q.running() === 0, 'queue should be empty now and no more workers should be running');\n      calls.push('drain');\n      expect(calls).to.eql(['drain']);\n      done();\n    });\n    q.push([]);\n  }); // #1367",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "empty and not idle()",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 520,
                "column": 26
            },
            "line": 520,
            "code": "  it('empty and not idle()', done => {\n    var calls = [];\n    var q = async.queue((task, cb) => {\n      // nop\n      calls.push('process ' + task);\n      async.setImmediate(cb);\n    }, 1);\n    q.empty(() => {\n      calls.push('empty');\n      assert(q.idle() === false, 'tasks should be running when empty is called');\n      expect(q.running()).to.equal(1);\n    });\n    q.drain(() => {\n      calls.push('drain');\n      expect(calls).to.eql(['empty', 'process 1', 'drain']);\n      done();\n    });\n    q.push(1);\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "saturated",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 539,
                "column": 15
            },
            "line": 539,
            "code": "  it('saturated', done => {\n    var saturatedCalled = false;\n    var q = async.queue((task, cb) => {\n      async.setImmediate(cb);\n    }, 2);\n    q.saturated(() => {\n      saturatedCalled = true;\n    });\n    q.drain(() => {\n      assert(saturatedCalled, \"saturated not called\");\n      done();\n    });\n    q.push(['foo', 'bar', 'baz', 'moo']);\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "started",
            "suites": [
                "queue"
            ],
            "updatePoint": {
                "line": 553,
                "column": 13
            },
            "line": 553,
            "code": "  it('started', done => {\n    var q = async.queue((task, cb) => {\n      cb(null, task);\n    });\n    expect(q.started).to.equal(false);\n    q.push('a');\n    expect(q.started).to.equal(true);\n    done();\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should call the saturated callback if tasks length is concurrency",
            "suites": [
                "queue",
                "q.saturated(): "
            ],
            "updatePoint": {
                "line": 563,
                "column": 73
            },
            "line": 563,
            "code": "    it('should call the saturated callback if tasks length is concurrency', done => {\n      var calls = [];\n      var q = async.queue((task, cb) => {\n        calls.push('process ' + task);\n        async.setImmediate(cb);\n      }, 4);\n      q.saturated(() => {\n        calls.push('saturated');\n      });\n      q.empty(() => {\n        expect(calls.indexOf('saturated')).to.be.above(-1);\n        setTimeout(() => {\n          expect(calls).eql(['process foo0', 'process foo1', 'process foo2', \"saturated\", 'process foo3', 'foo0 cb', \"saturated\", 'process foo4', 'foo1 cb', 'foo2 cb', 'foo3 cb', 'foo4 cb']);\n          done();\n        }, 50);\n      });\n      q.push('foo0', () => {\n        calls.push('foo0 cb');\n      });\n      q.push('foo1', () => {\n        calls.push('foo1 cb');\n      });\n      q.push('foo2', () => {\n        calls.push('foo2 cb');\n      });\n      q.push('foo3', () => {\n        calls.push('foo3 cb');\n      });\n      q.push('foo4', () => {\n        calls.push('foo4 cb');\n      });\n    });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should have a default buffer property that equals 25% of the concurrenct rate",
            "suites": [
                "queue",
                "q.unsaturated(): "
            ],
            "updatePoint": {
                "line": 597,
                "column": 85
            },
            "line": 597,
            "code": "    it('should have a default buffer property that equals 25% of the concurrenct rate', done => {\n      var calls = [];\n      var q = async.queue((task, cb) => {\n        // nop\n        calls.push('process ' + task);\n        async.setImmediate(cb);\n      }, 10);\n      expect(q.buffer).to.equal(2.5);\n      done();\n    });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should allow a user to change the buffer property",
            "suites": [
                "queue",
                "q.unsaturated(): "
            ],
            "updatePoint": {
                "line": 607,
                "column": 57
            },
            "line": 607,
            "code": "    it('should allow a user to change the buffer property', done => {\n      var calls = [];\n      var q = async.queue((task, cb) => {\n        // nop\n        calls.push('process ' + task);\n        async.setImmediate(cb);\n      }, 10);\n      q.buffer = 4;\n      expect(q.buffer).to.not.equal(2.5);\n      expect(q.buffer).to.equal(4);\n      done();\n    });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should call the unsaturated callback if tasks length is less than concurrency minus buffer",
            "suites": [
                "queue",
                "q.unsaturated(): "
            ],
            "updatePoint": {
                "line": 619,
                "column": 98
            },
            "line": 619,
            "code": "    it('should call the unsaturated callback if tasks length is less than concurrency minus buffer', done => {\n      var calls = [];\n      var q = async.queue((task, cb) => {\n        calls.push('process ' + task);\n        async.setImmediate(cb);\n      }, 4);\n      q.unsaturated(() => {\n        calls.push('unsaturated');\n      });\n      q.empty(() => {\n        expect(calls.indexOf('unsaturated')).to.be.above(-1);\n        setTimeout(() => {\n          expect(calls).eql(['process foo0', 'process foo1', 'process foo2', 'process foo3', 'foo0 cb', 'unsaturated', 'process foo4', 'foo1 cb', 'unsaturated', 'foo2 cb', 'unsaturated', 'foo3 cb', 'unsaturated', 'foo4 cb', 'unsaturated']);\n          done();\n        }, 50);\n      });\n      q.push('foo0', () => {\n        calls.push('foo0 cb');\n      });\n      q.push('foo1', () => {\n        calls.push('foo1 cb');\n      });\n      q.push('foo2', () => {\n        calls.push('foo2 cb');\n      });\n      q.push('foo3', () => {\n        calls.push('foo3 cb');\n      });\n      q.push('foo4', () => {\n        calls.push('foo4 cb');\n      });\n    });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should be the same length as running()",
            "suites": [
                "queue",
                "workersList"
            ],
            "updatePoint": {
                "line": 653,
                "column": 46
            },
            "line": 653,
            "code": "    it('should be the same length as running()', done => {\n      var q = async.queue((task, cb) => {\n        async.setImmediate(() => {\n          expect(q.workersList().length).to.equal(q.running());\n          cb();\n        });\n      }, 2);\n      q.drain(() => {\n        expect(q.workersList().length).to.equal(0);\n        expect(q.running()).to.equal(0);\n        done();\n      });\n      q.push('foo');\n      q.push('bar');\n      q.push('baz');\n    });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should contain the items being processed",
            "suites": [
                "queue",
                "workersList"
            ],
            "updatePoint": {
                "line": 669,
                "column": 48
            },
            "line": 669,
            "code": "    it('should contain the items being processed', done => {\n      var itemsBeingProcessed = {\n        'foo': ['foo'],\n        'foo_cb': ['foo', 'bar'],\n        'bar': ['foo', 'bar'],\n        'bar_cb': ['bar', 'baz'],\n        'baz': ['bar', 'baz'],\n        'baz_cb': ['baz']\n      };\n\n      function getWorkersListData(q) {\n        return q.workersList().map(v => {\n          return v.data;\n        });\n      }\n\n      var q = async.queue((task, cb) => {\n        expect(getWorkersListData(q)).to.eql(itemsBeingProcessed[task]);\n        expect(q.workersList().length).to.equal(q.running());\n        async.setImmediate(() => {\n          expect(getWorkersListData(q)).to.eql(itemsBeingProcessed[task + '_cb']);\n          expect(q.workersList().length).to.equal(q.running());\n          cb();\n        });\n      }, 2);\n      q.drain(() => {\n        expect(q.workersList()).to.eql([]);\n        expect(q.workersList().length).to.equal(q.running());\n        done();\n      });\n      q.push('foo');\n      q.push('bar');\n      q.push('baz');\n    });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "remove",
            "suites": [
                "queue",
                "workersList"
            ],
            "updatePoint": {
                "line": 704,
                "column": 12
            },
            "line": 704,
            "code": "  it('remove', done => {\n    var result = [];\n    var q = async.queue((data, cb) => {\n      result.push(data);\n      async.setImmediate(cb);\n    });\n    q.push([1, 2, 3, 4, 5]);\n    q.remove(node => {\n      return node.data === 3;\n    });\n    q.drain(() => {\n      expect(result).to.eql([1, 2, 4, 5]);\n      done();\n    });\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should be iterable",
            "suites": [
                "queue",
                "workersList"
            ],
            "updatePoint": {
                "line": 719,
                "column": 24
            },
            "line": 719,
            "code": "  it('should be iterable', done => {\n    var q = async.queue((data, cb) => {\n      if (data === 3) {\n        q.push(6);\n        expect([...q]).to.eql([4, 5, 6]);\n      }\n\n      async.setImmediate(cb);\n    });\n    q.push([1, 2, 3, 4, 5]);\n    expect([...q]).to.eql([1, 2, 3, 4, 5]);\n    q.drain(() => {\n      expect([...q]).to.eql([]);\n      done();\n    });\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should error when re-assigning event methods",
            "suites": [
                "queue",
                "workersList"
            ],
            "updatePoint": {
                "line": 735,
                "column": 50
            },
            "line": 735,
            "code": "  it('should error when re-assigning event methods', () => {\n    var q = async.queue(() => {});\n    expect(() => {\n      q.drain = () => {};\n    }).to.throw();\n  });",
            "file": "queue.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should call each function in parallel and callback with first result",
            "suites": [
                "race"
            ],
            "updatePoint": {
                "line": 6,
                "column": 74
            },
            "line": 6,
            "code": "  it('should call each function in parallel and callback with first result', done => {\n    var finished = 0;\n    var tasks = [];\n\n    function eachTest(i) {\n      var index = i;\n      return function (next) {\n        finished++;\n        next(null, index);\n      };\n    }\n\n    for (var i = 0; i < 10; i++) {\n      tasks[i] = eachTest(i);\n    }\n\n    async.race(tasks, (err, result) => {\n      assert.ifError(err); //0 finished first\n\n      assert.strictEqual(result, 0);\n      assert.strictEqual(finished, 1);\n      async.setImmediate(() => {\n        assert.strictEqual(finished, 10);\n        done();\n      });\n    });\n  });",
            "file": "race.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should callback with the first error",
            "suites": [
                "race"
            ],
            "updatePoint": {
                "line": 33,
                "column": 42
            },
            "line": 33,
            "code": "  it('should callback with the first error', done => {\n    var tasks = [];\n\n    function eachTest(i) {\n      var index = i;\n      return function (next) {\n        setTimeout(() => {\n          next(new Error('ERR' + index));\n        }, 50 - index * 2);\n      };\n    }\n\n    for (var i = 0; i <= 5; i++) {\n      tasks[i] = eachTest(i);\n    }\n\n    async.race(tasks, (err, result) => {\n      assert.ok(err);\n      assert.ok(err instanceof Error);\n      assert.strictEqual(typeof result, 'undefined');\n      assert.strictEqual(err.message, 'ERR5');\n      done();\n    });\n  });",
            "file": "race.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should callback when task is empty",
            "suites": [
                "race"
            ],
            "updatePoint": {
                "line": 57,
                "column": 40
            },
            "line": 57,
            "code": "  it('should callback when task is empty', done => {\n    async.race([], (err, result) => {\n      assert.ifError(err);\n      assert.strictEqual(typeof result, 'undefined');\n      done();\n    });\n  });",
            "file": "race.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should callback in error the task arg is not an Array",
            "suites": [
                "race"
            ],
            "updatePoint": {
                "line": 64,
                "column": 59
            },
            "line": 64,
            "code": "  it('should callback in error the task arg is not an Array', () => {\n    var errors = [];\n    async.race(null, err => {\n      errors.push(err);\n    });\n    async.race({}, err => {\n      errors.push(err);\n    });\n    assert.strictEqual(errors.length, 2);\n    assert.ok(errors[0] instanceof TypeError);\n    assert.ok(errors[1] instanceof TypeError);\n  });",
            "file": "race.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reduce",
            "suites": [
                "reduce"
            ],
            "updatePoint": {
                "line": 10,
                "column": 12
            },
            "line": 10,
            "code": "  it('reduce', done => {\n    var call_order = [];\n    async.reduce([1, 2, 3], 0, (a, x, callback) => {\n      call_order.push(x);\n      callback(null, a + x);\n    }, (err, result) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(result).to.equal(6);\n      expect(call_order).to.eql([1, 2, 3]);\n      done();\n    });\n  });",
            "file": "reduce.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reduce async with non-reference memo",
            "suites": [
                "reduce"
            ],
            "updatePoint": {
                "line": 22,
                "column": 42
            },
            "line": 22,
            "code": "  it('reduce async with non-reference memo', done => {\n    async.reduce([1, 3, 2], 0, (a, x, callback) => {\n      setTimeout(() => {\n        callback(null, a + x);\n      }, Math.random() * 100);\n    }, (err, result) => {\n      expect(result).to.equal(6);\n      done();\n    });\n  });",
            "file": "reduce.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reduce error",
            "suites": [
                "reduce"
            ],
            "updatePoint": {
                "line": 32,
                "column": 18
            },
            "line": 32,
            "code": "  it('reduce error', done => {\n    async.reduce([1, 2, 3], 0, (a, x, callback) => {\n      callback('error');\n    }, err => {\n      expect(err).to.equal('error');\n    });\n    setTimeout(done, 50);\n  });",
            "file": "reduce.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reduce canceled",
            "suites": [
                "reduce"
            ],
            "updatePoint": {
                "line": 40,
                "column": 21
            },
            "line": 40,
            "code": "  it('reduce canceled', done => {\n    var call_order = [];\n    async.reduce([1, 2, 3], 0, (a, x, callback) => {\n      call_order.push(x);\n      callback(x === 2 ? false : null, a + x);\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 2]);\n      done();\n    }, 25);\n  });",
            "file": "reduce.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "inject alias",
            "suites": [
                "reduce"
            ],
            "updatePoint": {
                "line": 53,
                "column": 18
            },
            "line": 53,
            "code": "  it('inject alias', done => {\n    expect(async.inject).to.equal(async.reduce);\n    done();\n  });",
            "file": "reduce.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "foldl alias",
            "suites": [
                "reduce"
            ],
            "updatePoint": {
                "line": 57,
                "column": 17
            },
            "line": 57,
            "code": "  it('foldl alias', done => {\n    expect(async.foldl).to.equal(async.reduce);\n    done();\n  });",
            "file": "reduce.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reduceRight",
            "suites": [
                "reduce"
            ],
            "updatePoint": {
                "line": 61,
                "column": 17
            },
            "line": 61,
            "code": "  it('reduceRight', done => {\n    var call_order = [];\n    var arr = [1, 2, 3];\n    async.reduceRight(arr, 0, (a, x, callback) => {\n      call_order.push(x);\n      callback(null, a + x);\n    }, (err, result) => {\n      expect(result).to.equal(6);\n      expect(call_order).to.eql([3, 2, 1]);\n      expect(arr).to.eql([1, 2, 3]);\n      done();\n    });\n  });",
            "file": "reduce.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "reduceRight canceled",
            "suites": [
                "reduce"
            ],
            "updatePoint": {
                "line": 74,
                "column": 26
            },
            "line": 74,
            "code": "  it('reduceRight canceled', done => {\n    var call_order = [];\n    async.reduceRight([1, 2, 3], 0, (a, x, callback) => {\n      call_order.push(x);\n      callback(x === 2 ? false : null, a + x);\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([3, 2]);\n      done();\n    }, 25);\n  });",
            "file": "reduce.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "foldr alias",
            "suites": [
                "reduce"
            ],
            "updatePoint": {
                "line": 87,
                "column": 17
            },
            "line": 87,
            "code": "  it('foldr alias', done => {\n    expect(async.foldr).to.equal(async.reduceRight);\n    done();\n  });",
            "file": "reduce.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "retry when attempt succeeds",
            "suites": [
                "retry"
            ],
            "updatePoint": {
                "line": 13,
                "column": 33
            },
            "line": 13,
            "code": "  it('retry when attempt succeeds', done => {\n    var failed = 3;\n    var callCount = 0;\n    var expectedResult = 'success';\n\n    function fn(callback) {\n      callCount++;\n      failed--;\n      if (!failed) callback(null, expectedResult);else callback(true); // respond with error\n    }\n\n    async.retry(fn, (err, result) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      assert.equal(callCount, 3, 'did not retry the correct number of times');\n      assert.equal(result, expectedResult, 'did not return the expected result');\n      done();\n    });\n  });",
            "file": "retry.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "retry when all attempts fail",
            "suites": [
                "retry"
            ],
            "updatePoint": {
                "line": 31,
                "column": 34
            },
            "line": 31,
            "code": "  it('retry when all attempts fail', done => {\n    var times = 3;\n    var callCount = 0;\n    var error = 'ERROR';\n    var erroredResult = 'RESULT';\n\n    function fn(callback) {\n      callCount++;\n      callback(error + callCount, erroredResult + callCount); // respond with indexed values\n    }\n\n    async.retry(times, fn, (err, result) => {\n      assert.equal(callCount, 3, \"did not retry the correct number of times\");\n      assert.equal(err, error + times, \"Incorrect error was returned\");\n      assert.equal(result, erroredResult + times, \"Incorrect result was returned\");\n      done();\n    });\n  });",
            "file": "retry.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "retry fails with invalid arguments",
            "suites": [
                "retry"
            ],
            "updatePoint": {
                "line": 49,
                "column": 40
            },
            "line": 49,
            "code": "  it('retry fails with invalid arguments', done => {\n    expect(() => {\n      async.retry(\"\");\n    }).to.throw();\n    expect(() => {\n      async.retry();\n    }).to.throw();\n    expect(() => {\n      async.retry(() => {}, 2, () => {});\n    }).to.throw();\n    done();\n  });",
            "file": "retry.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "retry with interval when all attempts fail",
            "suites": [
                "retry"
            ],
            "updatePoint": {
                "line": 61,
                "column": 48
            },
            "line": 61,
            "code": "  it('retry with interval when all attempts fail', function (done) {\n    this.retries(3); // this test is flakey due to timing issues\n\n    var times = 3;\n    var interval = 50;\n    var callCount = 0;\n    var error = 'ERROR';\n    var erroredResult = 'RESULT';\n\n    function fn(callback) {\n      callCount++;\n      callback(error + callCount, erroredResult + callCount); // respond with indexed values\n    }\n\n    var start = Date.now();\n    async.retry({\n      times,\n      interval\n    }, fn, (err, result) => {\n      var duration = Date.now() - start;\n      expect(duration).to.be.above(interval * (times - 1) - times);\n      assert.equal(callCount, 3, \"did not retry the correct number of times\");\n      assert.equal(err, error + times, \"Incorrect error was returned\");\n      assert.equal(result, erroredResult + times, \"Incorrect result was returned\");\n      done();\n    });\n  });",
            "file": "retry.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "retry with custom interval when all attempts fail",
            "suites": [
                "retry"
            ],
            "updatePoint": {
                "line": 88,
                "column": 55
            },
            "line": 88,
            "code": "  it('retry with custom interval when all attempts fail', done => {\n    var times = 3;\n    var retryCounts = [];\n\n    var intervalFunc = function (retryCount) {\n      retryCounts.push(retryCount);\n      return retryCount * 100;\n    };\n\n    var callCount = 0;\n    var error = 'ERROR';\n    var erroredResult = 'RESULT';\n\n    function fn(callback) {\n      callCount++;\n      callback(error + callCount, erroredResult + callCount); // respond with indexed values\n    }\n\n    var start = Date.now();\n    async.retry({\n      times,\n      interval: intervalFunc\n    }, fn, (err, result) => {\n      var duration = Date.now() - start;\n      expect(duration).to.be.above(300 - times);\n      assert.equal(callCount, 3, \"did not retry the correct number of times\");\n      assert.equal(err, error + times, \"Incorrect error was returned\");\n      assert.equal(result, erroredResult + times, \"Incorrect result was returned\");\n      assert.deepEqual(retryCounts, [1, 2]);\n      done();\n    });\n  });",
            "file": "retry.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not require a callback",
            "suites": [
                "retry"
            ],
            "updatePoint": {
                "line": 120,
                "column": 35
            },
            "line": 120,
            "code": "  it(\"should not require a callback\", done => {\n    var called = false;\n    async.retry(3, cb => {\n      called = true;\n      cb();\n    });\n    setTimeout(() => {\n      assert(called);\n      done();\n    }, 10);\n  });",
            "file": "retry.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not require a callback and use the default times",
            "suites": [
                "retry"
            ],
            "updatePoint": {
                "line": 131,
                "column": 61
            },
            "line": 131,
            "code": "  it(\"should not require a callback and use the default times\", done => {\n    var calls = 0;\n    async.retry(cb => {\n      calls++;\n      cb(\"fail\");\n    }).catch(() => {});\n    setTimeout(() => {\n      expect(calls).to.equal(5);\n      done();\n    }, 100);\n  });",
            "file": "retry.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should be cancelable",
            "suites": [
                "retry"
            ],
            "updatePoint": {
                "line": 142,
                "column": 26
            },
            "line": 142,
            "code": "  it(\"should be cancelable\", done => {\n    var calls = 0;\n    async.retry(2, cb => {\n      calls++;\n      cb(calls > 1 ? false : 'fail');\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(calls).to.equal(2);\n      done();\n    }, 10);\n  });",
            "file": "retry.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "retry does not precompute the intervals (#1226)",
            "suites": [
                "retry"
            ],
            "updatePoint": {
                "line": 155,
                "column": 53
            },
            "line": 155,
            "code": "  it('retry does not precompute the intervals (#1226)', done => {\n    var callTimes = [];\n\n    function intervalFunc() {\n      callTimes.push(Date.now());\n      return 100;\n    }\n\n    function fn(callback) {\n      callback({}); // respond with indexed values\n    }\n\n    async.retry({\n      times: 4,\n      interval: intervalFunc\n    }, fn, () => {\n      expect(callTimes[1] - callTimes[0]).to.be.above(90);\n      expect(callTimes[2] - callTimes[1]).to.be.above(90);\n      done();\n    });\n  });",
            "file": "retry.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "retry passes all resolve arguments to callback",
            "suites": [
                "retry"
            ],
            "updatePoint": {
                "line": 176,
                "column": 52
            },
            "line": 176,
            "code": "  it('retry passes all resolve arguments to callback', done => {\n    function fn(callback) {\n      callback(null, 1, 2, 3); // respond with indexed values\n    }\n\n    async.retry(5, fn, _.rest(args => {\n      expect(args).to.be.eql([null, 1, 2, 3]);\n      done();\n    }));\n  }); // note this is a synchronous test ensuring retry is synchrnous in the fastest (most straightforward) case",
            "file": "retry.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "retry calls fn immediately and will call callback if successful",
            "suites": [
                "retry"
            ],
            "updatePoint": {
                "line": 187,
                "column": 69
            },
            "line": 187,
            "code": "  it('retry calls fn immediately and will call callback if successful', () => {\n    function fn(callback) {\n      callback(null, {\n        a: 1\n      });\n    }\n\n    async.retry(5, fn, (err, result) => {\n      expect(result).to.be.eql({\n        a: 1\n      });\n    });\n  });",
            "file": "retry.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "retry when all attempts fail and error continue test returns true",
            "suites": [
                "retry"
            ],
            "updatePoint": {
                "line": 200,
                "column": 71
            },
            "line": 200,
            "code": "  it('retry when all attempts fail and error continue test returns true', done => {\n    var times = 3;\n    var callCount = 0;\n    var error = 'ERROR';\n    var special = 'SPECIAL_ERROR';\n    var erroredResult = 'RESULT';\n\n    function fn(callback) {\n      callCount++;\n      callback(error + callCount, erroredResult + callCount);\n    }\n\n    function errorTest(err) {\n      return err && err !== special;\n    }\n\n    var options = {\n      times,\n      errorFilter: errorTest\n    };\n    async.retry(options, fn, (err, result) => {\n      assert.equal(callCount, 3, \"did not retry the correct number of times\");\n      assert.equal(err, error + times, \"Incorrect error was returned\");\n      assert.equal(result, erroredResult + times, \"Incorrect result was returned\");\n      done();\n    });\n  });",
            "file": "retry.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "retry when some attempts fail and error test returns false at some invokation",
            "suites": [
                "retry"
            ],
            "updatePoint": {
                "line": 227,
                "column": 83
            },
            "line": 227,
            "code": "  it('retry when some attempts fail and error test returns false at some invokation', done => {\n    var callCount = 0;\n    var error = 'ERROR';\n    var special = 'SPECIAL_ERROR';\n    var erroredResult = 'RESULT';\n\n    function fn(callback) {\n      callCount++;\n      var err = callCount === 2 ? special : error + callCount;\n      callback(err, erroredResult + callCount);\n    }\n\n    function errorTest(err) {\n      return err && err === error + callCount; // just a different pattern\n    }\n\n    var options = {\n      errorFilter: errorTest\n    };\n    async.retry(options, fn, (err, result) => {\n      assert.equal(callCount, 2, \"did not retry the correct number of times\");\n      assert.equal(err, special, \"Incorrect error was returned\");\n      assert.equal(result, erroredResult + 2, \"Incorrect result was returned\");\n      done();\n    });\n  });",
            "file": "retry.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "retry with interval when some attempts fail and error test returns false at some invokation",
            "suites": [
                "retry"
            ],
            "updatePoint": {
                "line": 253,
                "column": 97
            },
            "line": 253,
            "code": "  it('retry with interval when some attempts fail and error test returns false at some invokation', function (done) {\n    this.retries(3); // flakey test\n\n    var interval = 50;\n    var callCount = 0;\n    var error = 'ERROR';\n    var erroredResult = 'RESULT';\n    var special = 'SPECIAL_ERROR';\n    var specialCount = 3;\n\n    function fn(callback) {\n      callCount++;\n      var err = callCount === specialCount ? special : error + callCount;\n      callback(err, erroredResult + callCount);\n    }\n\n    function errorTest(err) {\n      return err && err !== special;\n    }\n\n    var start = Date.now();\n    async.retry({\n      interval,\n      errorFilter: errorTest\n    }, fn, (err, result) => {\n      var duration = Date.now() - start;\n      expect(duration).to.be.above(interval * (specialCount - 1) - specialCount);\n      assert.equal(callCount, specialCount, \"did not retry the correct number of times\");\n      assert.equal(err, special, \"Incorrect error was returned\");\n      assert.equal(result, erroredResult + specialCount, \"Incorrect result was returned\");\n      done();\n    });\n  });",
            "file": "retry.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "retry when first attempt succeeds and error test should not be called",
            "suites": [
                "retry"
            ],
            "updatePoint": {
                "line": 286,
                "column": 75
            },
            "line": 286,
            "code": "  it('retry when first attempt succeeds and error test should not be called', done => {\n    var callCount = 0;\n    var error = 'ERROR';\n    var erroredResult = 'RESULT';\n    var continueTestCalled = false;\n\n    function fn(callback) {\n      callCount++;\n      callback(null, erroredResult + callCount);\n    }\n\n    function errorTest(err) {\n      continueTestCalled = true;\n      return err && err === error;\n    }\n\n    var options = {\n      errorFilter: errorTest\n    };\n    async.retry(options, fn, _.rest(args => {\n      assert.equal(callCount, 1, \"did not retry the correct number of times\");\n      expect(args).to.be.eql([null, erroredResult + callCount]);\n      assert.equal(continueTestCalled, false, \"error test function was called\");\n      done();\n    }));\n  });",
            "file": "retry.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basics",
            "suites": [
                "retryable"
            ],
            "updatePoint": {
                "line": 10,
                "column": 12
            },
            "line": 10,
            "code": "  it('basics', done => {\n    var calls = 0;\n    var retryableTask = async.retryable(3, (arg, cb) => {\n      calls++;\n      expect(arg).to.equal(42);\n      cb('fail');\n    });\n    retryableTask(42, err => {\n      expect(err).to.equal('fail');\n      expect(calls).to.equal(3);\n      done();\n    });\n  });",
            "file": "retryable.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "success",
            "suites": [
                "retryable"
            ],
            "updatePoint": {
                "line": 23,
                "column": 13
            },
            "line": 23,
            "code": "  it('success', done => {\n    var calls = 0;\n    var retryableTask = async.retryable(3, (arg, cb) => {\n      calls++;\n      expect(arg).to.equal(42);\n      if (calls > 1) return cb(null, 1, 2);\n      cb('fail');\n    });\n    retryableTask(42, (err, a, b) => {\n      expect(err).to.eql(null);\n      expect(calls).to.equal(2);\n      expect([a, b]).to.eql([1, 2]);\n      done();\n    });\n  });",
            "file": "retryable.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basics with error test function",
            "suites": [
                "retryable"
            ],
            "updatePoint": {
                "line": 38,
                "column": 37
            },
            "line": 38,
            "code": "  it('basics with error test function', done => {\n    var calls = 0;\n    var special = 'special';\n    var opts = {\n      errorFilter(err) {\n        return err == special;\n      }\n\n    };\n    var retryableTask = async.retryable(opts, (arg, cb) => {\n      calls++;\n      expect(arg).to.equal(42);\n      cb(calls === 3 ? 'fail' : special);\n    });\n    retryableTask(42, err => {\n      expect(err).to.equal('fail');\n      expect(calls).to.equal(3);\n      done();\n    });\n  });",
            "file": "retryable.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should work as an embedded task",
            "suites": [
                "retryable"
            ],
            "updatePoint": {
                "line": 58,
                "column": 37
            },
            "line": 58,
            "code": "  it('should work as an embedded task', done => {\n    var retryResult = 'RETRY';\n    var fooResults;\n    var retryResults;\n    async.auto({\n      dep: async.constant('dep'),\n      foo: ['dep', function (results, callback) {\n        fooResults = results;\n        callback(null, 'FOO');\n      }],\n      retry: ['dep', async.retryable((results, callback) => {\n        retryResults = results;\n        callback(null, retryResult);\n      })]\n    }, (err, results) => {\n      assert.equal(results.retry, retryResult, \"Incorrect result was returned from retry function\");\n      assert.equal(fooResults, retryResults, \"Incorrect results were passed to retry function\");\n      done();\n    });\n  });",
            "file": "retryable.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should work as an embedded task with interval",
            "suites": [
                "retryable"
            ],
            "updatePoint": {
                "line": 78,
                "column": 51
            },
            "line": 78,
            "code": "  it('should work as an embedded task with interval', done => {\n    var start = new Date().getTime();\n    var opts = {\n      times: 5,\n      interval: 20\n    };\n    async.auto({\n      foo(callback) {\n        callback(null, 'FOO');\n      },\n\n      retry: async.retryable(opts, callback => {\n        callback('err');\n      })\n    }, () => {\n      var duration = new Date().getTime() - start;\n      var expectedMinimumDuration = (opts.times - 1) * opts.interval;\n      assert(duration >= expectedMinimumDuration, \"The duration should have been greater than \" + expectedMinimumDuration + \", but was \" + duration);\n      done();\n    });\n  });",
            "file": "retryable.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should be cancelable",
            "suites": [
                "retryable"
            ],
            "updatePoint": {
                "line": 99,
                "column": 26
            },
            "line": 99,
            "code": "  it('should be cancelable', done => {\n    var calls = 0;\n    var retryableTask = async.retryable(3, (_, cb) => {\n      calls++;\n      cb(calls > 1 ? false : 'fail');\n    });\n    retryableTask('foo', () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(calls).to.equal(2);\n      done();\n    }, 25);\n  });",
            "file": "retryable.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "seq",
            "suites": [
                "seq"
            ],
            "updatePoint": {
                "line": 10,
                "column": 9
            },
            "line": 10,
            "code": "  it('seq', done => {\n    var add2 = function (n, cb) {\n      expect(n).to.equal(3);\n      setTimeout(() => {\n        cb(null, n + 2);\n      }, 50);\n    };\n\n    var mul3 = function (n, cb) {\n      expect(n).to.equal(5);\n      setTimeout(() => {\n        cb(null, n * 3);\n      }, 15);\n    };\n\n    var add1 = function (n, cb) {\n      expect(n).to.equal(15);\n      setTimeout(() => {\n        cb(null, n + 1);\n      }, 100);\n    };\n\n    var add2mul3add1 = async.seq(add2, mul3, add1);\n    add2mul3add1(3, (err, result) => {\n      if (err) {\n        return done(err);\n      }\n\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(result).to.equal(16);\n      done();\n    });\n  });",
            "file": "seq.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "seq error",
            "suites": [
                "seq"
            ],
            "updatePoint": {
                "line": 43,
                "column": 15
            },
            "line": 43,
            "code": "  it('seq error', done => {\n    var testerr = new Error('test');\n\n    var add2 = function (n, cb) {\n      expect(n).to.equal(3);\n      setTimeout(() => {\n        cb(null, n + 2);\n      }, 50);\n    };\n\n    var mul3 = function (n, cb) {\n      expect(n).to.equal(5);\n      setTimeout(() => {\n        cb(testerr);\n      }, 15);\n    };\n\n    var add1 = function (n, cb) {\n      assert(false, 'add1 should not get called');\n      setTimeout(() => {\n        cb(null, n + 1);\n      }, 100);\n    };\n\n    var add2mul3add1 = async.seq(add2, mul3, add1);\n    add2mul3add1(3, err => {\n      expect(err).to.equal(testerr);\n      done();\n    });\n  });",
            "file": "seq.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "seq canceled",
            "suites": [
                "seq"
            ],
            "updatePoint": {
                "line": 73,
                "column": 18
            },
            "line": 73,
            "code": "  it('seq canceled', done => {\n    var call_order = [];\n\n    var add2 = function (n, cb) {\n      call_order.push('add2');\n      cb(null, n + 2);\n    };\n\n    var mul3 = function (n, cb) {\n      call_order.push('mul3');\n      cb(false, n * 3);\n    };\n\n    var add1 = function () {\n      throw new Error('add1 - should not get here');\n    };\n\n    var add2mul3add1 = async.seq(add2, mul3, add1);\n    add2mul3add1(3, () => {\n      throw new Error('final callback - should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql(['add2', 'mul3']);\n      done();\n    }, 25);\n  });",
            "file": "seq.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "seq binding",
            "suites": [
                "seq"
            ],
            "updatePoint": {
                "line": 99,
                "column": 17
            },
            "line": 99,
            "code": "  it('seq binding', done => {\n    var testcontext = {\n      name: 'foo'\n    };\n\n    var add2 = function (n, cb) {\n      expect(this).to.equal(testcontext);\n      setTimeout(() => {\n        cb(null, n + 2);\n      }, 50);\n    };\n\n    var mul3 = function (n, cb) {\n      expect(this).to.equal(testcontext);\n      setTimeout(() => {\n        cb(null, n * 3);\n      }, 15);\n    };\n\n    var add2mul3 = async.seq(add2, mul3);\n    add2mul3.call(testcontext, 3, (err, result) => {\n      if (err) {\n        return done(err);\n      }\n\n      expect(result).to.equal(15);\n      done();\n    });\n  });",
            "file": "seq.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "seq without callback",
            "suites": [
                "seq"
            ],
            "updatePoint": {
                "line": 128,
                "column": 26
            },
            "line": 128,
            "code": "  it('seq without callback', done => {\n    var testcontext = {\n      name: 'foo'\n    };\n\n    var add2 = function (n, cb) {\n      expect(this).to.equal(testcontext);\n      setTimeout(() => {\n        cb(null, n + 2);\n      }, 50);\n    };\n\n    var mul3 = function () {\n      expect(this).to.equal(testcontext);\n      setTimeout(() => {\n        done();\n      }, 15);\n    };\n\n    var add2mul3 = async.seq(add2, mul3);\n    add2mul3.call(testcontext, 3);\n  });",
            "file": "seq.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "series",
            "suites": [
                "series"
            ],
            "updatePoint": {
                "line": 12,
                "column": 12
            },
            "line": 12,
            "code": "  it('series', done => {\n    var call_order = [];\n    async.series([function (callback) {\n      setTimeout(() => {\n        call_order.push(1);\n        callback(null, 1);\n      }, 25);\n    }, function (callback) {\n      setTimeout(() => {\n        call_order.push(2);\n        callback(null, 2);\n      }, 50);\n    }, function (callback) {\n      setTimeout(() => {\n        call_order.push(3);\n        callback(null, 3, 3);\n      }, 15);\n    }], (err, results) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(results).to.eql([1, 2, [3, 3]]);\n      expect(call_order).to.eql([1, 2, 3]);\n      done();\n    });\n  });",
            "file": "series.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "with reflect",
            "suites": [
                "series"
            ],
            "updatePoint": {
                "line": 36,
                "column": 18
            },
            "line": 36,
            "code": "  it('with reflect', done => {\n    var call_order = [];\n    async.series([async.reflect(callback => {\n      setTimeout(() => {\n        call_order.push(1);\n        callback(null, 1);\n      }, 25);\n    }), async.reflect(callback => {\n      setTimeout(() => {\n        call_order.push(2);\n        callback(null, 2);\n      }, 50);\n    }), async.reflect(callback => {\n      setTimeout(() => {\n        call_order.push(3);\n        callback(null, 3, 3);\n      }, 15);\n    })], (err, results) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(results).to.eql([{\n        value: 1\n      }, {\n        value: 2\n      }, {\n        value: [3, 3]\n      }]);\n      expect(call_order).to.eql([1, 2, 3]);\n      done();\n    });\n  });",
            "file": "series.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "empty array",
            "suites": [
                "series"
            ],
            "updatePoint": {
                "line": 66,
                "column": 17
            },
            "line": 66,
            "code": "  it('empty array', done => {\n    async.series([], (err, results) => {\n      expect(err).to.equal(null);\n      expect(results).to.eql([]);\n      done();\n    });\n  });",
            "file": "series.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "error",
            "suites": [
                "series"
            ],
            "updatePoint": {
                "line": 73,
                "column": 11
            },
            "line": 73,
            "code": "  it('error', done => {\n    async.series([function (callback) {\n      callback('error', 1);\n    }, function (callback) {\n      assert(false, 'should not be called');\n      callback('error2', 2);\n    }], err => {\n      expect(err).to.equal('error');\n    });\n    setTimeout(done, 100);\n  });",
            "file": "series.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "canceled",
            "suites": [
                "series"
            ],
            "updatePoint": {
                "line": 84,
                "column": 14
            },
            "line": 84,
            "code": "  it('canceled', done => {\n    async.series([function (callback) {\n      callback(false, 1);\n    }, function (callback) {\n      assert(false, 'second function should not be called');\n      callback('error2', 2);\n    }], () => {\n      assert(false, 'final callback should not be called');\n    });\n    setTimeout(done, 25);\n  });",
            "file": "series.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "error with reflect",
            "suites": [
                "series"
            ],
            "updatePoint": {
                "line": 95,
                "column": 24
            },
            "line": 95,
            "code": "  it('error with reflect', done => {\n    async.series([async.reflect(callback => {\n      callback('error', 1);\n    }), async.reflect(callback => {\n      callback('error2', 2);\n    }), async.reflect(callback => {\n      callback(null, 1);\n    }), async.reflect(callback => {\n      callback('error3');\n    })], (err, results) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(results).to.eql([{\n        error: 'error',\n        value: 1\n      }, {\n        error: 'error2',\n        value: 2\n      }, {\n        value: 1\n      }, {\n        error: 'error3'\n      }]);\n      done();\n    });\n  });",
            "file": "series.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "no callback",
            "suites": [
                "series"
            ],
            "updatePoint": {
                "line": 120,
                "column": 17
            },
            "line": 120,
            "code": "  it('no callback', done => {\n    async.series([function (callback) {\n      callback();\n    }, function (callback) {\n      callback();\n      done();\n    }]);\n  });",
            "file": "series.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "object",
            "suites": [
                "series"
            ],
            "updatePoint": {
                "line": 128,
                "column": 12
            },
            "line": 128,
            "code": "  it('object', done => {\n    var call_order = [];\n    async.series(getFunctionsObject(call_order), (err, results) => {\n      expect(err).to.equal(null);\n      expect(results).to.eql({\n        one: 1,\n        two: 2,\n        three: [3, 3]\n      });\n      expect(call_order).to.eql([1, 2, 3]);\n      done();\n    });\n  });",
            "file": "series.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "call in another context @nycinvalid @nodeonly",
            "suites": [
                "series"
            ],
            "updatePoint": {
                "line": 141,
                "column": 51
            },
            "line": 141,
            "code": "  it('call in another context @nycinvalid @nodeonly', done => {\n    var vm = require('vm');\n\n    var sandbox = {\n      async,\n      done\n    };\n\n    var fn = \"(\" + function () {\n      async.series([function (callback) {\n        callback();\n      }], err => {\n        if (err) {\n          return done(err);\n        }\n\n        done();\n      });\n    }.toString() + \"())\";\n\n    vm.runInNewContext(fn, sandbox);\n  }); // Issue 10 on github: https://github.com/caolan/async/issues#issue/10",
            "file": "series.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "falsy return values",
            "suites": [
                "series"
            ],
            "updatePoint": {
                "line": 164,
                "column": 25
            },
            "line": 164,
            "code": "  it('falsy return values', done => {\n    function taskFalse(callback) {\n      async.nextTick(() => {\n        callback(null, false);\n      });\n    }\n\n    function taskUndefined(callback) {\n      async.nextTick(() => {\n        callback(null, undefined);\n      });\n    }\n\n    function taskEmpty(callback) {\n      async.nextTick(() => {\n        callback(null);\n      });\n    }\n\n    function taskNull(callback) {\n      async.nextTick(() => {\n        callback(null, null);\n      });\n    }\n\n    async.series([taskFalse, taskUndefined, taskEmpty, taskNull], (err, results) => {\n      expect(results.length).to.equal(4);\n      assert.strictEqual(results[0], false);\n      assert.strictEqual(results[1], undefined);\n      assert.strictEqual(results[2], undefined);\n      assert.strictEqual(results[3], null);\n      done();\n    });\n  });",
            "file": "series.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basics",
            "suites": [
                "setImmediate"
            ],
            "updatePoint": {
                "line": 8,
                "column": 12
            },
            "line": 8,
            "code": "  it('basics', done => {\n    var call_order = [];\n    async.setImmediate(() => {\n      call_order.push('two');\n    });\n    call_order.push('one');\n    setTimeout(() => {\n      expect(call_order).to.eql(['one', 'two']);\n      done();\n    }, 25);\n  });",
            "file": "setImmediate.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "extra args",
            "suites": [
                "setImmediate"
            ],
            "updatePoint": {
                "line": 19,
                "column": 16
            },
            "line": 19,
            "code": "  it(\"extra args\", done => {\n    async.setImmediate((a, b, c) => {\n      expect([a, b, c]).to.eql([1, 2, 3]);\n      done();\n    }, 1, 2, 3);\n  });",
            "file": "setImmediate.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "some true",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 10,
                "column": 15
            },
            "line": 10,
            "code": "  it('some true', done => {\n    async.some([3, 1, 2], (x, callback) => {\n      setTimeout(() => {\n        callback(null, x === 1);\n      }, 0);\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.equal(true);\n      done();\n    });\n  });",
            "file": "some.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "some false",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 21,
                "column": 16
            },
            "line": 21,
            "code": "  it('some false', done => {\n    async.some([3, 1, 2], (x, callback) => {\n      setTimeout(() => {\n        callback(null, x === 10);\n      }, 0);\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.equal(false);\n      done();\n    });\n  });",
            "file": "some.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "some early return",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 32,
                "column": 23
            },
            "line": 32,
            "code": "  it('some early return', done => {\n    var call_order = [];\n    async.some([1, 2, 3], (x, callback) => {\n      setTimeout(() => {\n        call_order.push(x);\n        callback(null, x === 1);\n      }, x * 5);\n    }, () => {\n      call_order.push('callback');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 'callback', 2, 3]);\n      done();\n    }, 25);\n  });",
            "file": "some.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "some error",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 47,
                "column": 16
            },
            "line": 47,
            "code": "  it('some error', done => {\n    async.some([3, 1, 2], (x, callback) => {\n      setTimeout(() => {\n        callback('error');\n      }, 0);\n    }, (err, result) => {\n      expect(err).to.equal('error');\n      expect(result).to.not.exist;\n      done();\n    });\n  });",
            "file": "some.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "some canceled",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 58,
                "column": 19
            },
            "line": 58,
            "code": "  it('some canceled', done => {\n    var call_order = [];\n    async.some([3, 1, 2], (x, callback) => {\n      call_order.push(x);\n\n      if (x === 1) {\n        return callback(false);\n      }\n\n      callback();\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([3, 1, 2]);\n      done();\n    }, 25);\n  });",
            "file": "some.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "some no callback",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 76,
                "column": 22
            },
            "line": 76,
            "code": "  it('some no callback', done => {\n    var calls = [];\n    async.some([1, 2, 3], (val, cb) => {\n      calls.push(val);\n      cb();\n    });\n    setTimeout(() => {\n      expect(calls).to.eql([1, 2, 3]);\n      done();\n    }, 10);\n  });",
            "file": "some.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "someLimit true",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 87,
                "column": 20
            },
            "line": 87,
            "code": "  it('someLimit true', done => {\n    async.someLimit([3, 1, 2], 2, (x, callback) => {\n      setTimeout(() => {\n        callback(null, x === 2);\n      }, 0);\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.equal(true);\n      done();\n    });\n  });",
            "file": "some.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "someLimit false",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 98,
                "column": 21
            },
            "line": 98,
            "code": "  it('someLimit false', done => {\n    async.someLimit([3, 1, 2], 2, (x, callback) => {\n      setTimeout(() => {\n        callback(null, x === 10);\n      }, 0);\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.equal(false);\n      done();\n    });\n  });",
            "file": "some.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "someLimit canceled",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 109,
                "column": 24
            },
            "line": 109,
            "code": "  it('someLimit canceled', done => {\n    var call_order = [];\n    async.someLimit([1, 1, 2, 2, 3], 2, (x, callback) => {\n      call_order.push(x);\n      async.setImmediate(() => {\n        if (x === 2) {\n          return callback(false);\n        }\n\n        callback();\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 1, 2, 2]);\n      done();\n    }, 50);\n  });",
            "file": "some.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "someSeries canceled",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 128,
                "column": 25
            },
            "line": 128,
            "code": "  it('someSeries canceled', done => {\n    var call_order = [];\n    async.someSeries([1, 2, 3], (x, callback) => {\n      call_order.push(x);\n      async.setImmediate(() => {\n        if (x === 2) {\n          return callback(false);\n        }\n\n        callback();\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 2]);\n      done();\n    }, 50);\n  });",
            "file": "some.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "someLimit short-circuit",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 147,
                "column": 29
            },
            "line": 147,
            "code": "  it('someLimit short-circuit', done => {\n    var calls = 0;\n    async.someLimit([3, 1, 2], 1, (x, callback) => {\n      calls++;\n      callback(null, x === 1);\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.equal(true);\n      expect(calls).to.equal(2);\n      done();\n    });\n  });",
            "file": "some.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "someSeries doesn't cause stack overflow (#1293)",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 159,
                "column": 54
            },
            "line": 159,
            "code": "  it('someSeries doesn\\'t cause stack overflow (#1293)', done => {\n    var arr = _.range(10000);\n\n    let calls = 0;\n    async.someSeries(arr, (data, cb) => {\n      calls += 1;\n      async.setImmediate(_.partial(cb, null, true));\n    }, err => {\n      expect(err).to.equal(null);\n      expect(calls).to.equal(1);\n      done();\n    });\n  });",
            "file": "some.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "someLimit doesn't cause stack overflow (#1293)",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 172,
                "column": 53
            },
            "line": 172,
            "code": "  it('someLimit doesn\\'t cause stack overflow (#1293)', done => {\n    var arr = _.range(10000);\n\n    let calls = 0;\n    async.someLimit(arr, 100, (data, cb) => {\n      calls += 1;\n      async.setImmediate(_.partial(cb, null, true));\n    }, err => {\n      expect(err).to.equal(null);\n      expect(calls).to.equal(100);\n      done();\n    });\n  });",
            "file": "some.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "any alias",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 185,
                "column": 15
            },
            "line": 185,
            "code": "  it('any alias', () => {\n    expect(async.any).to.equal(async.some);\n  });",
            "file": "some.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "anyLimit alias",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 188,
                "column": 20
            },
            "line": 188,
            "code": "  it('anyLimit alias', () => {\n    expect(async.anyLimit).to.equal(async.someLimit);\n  });",
            "file": "some.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "anySeries alias",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 191,
                "column": 21
            },
            "line": 191,
            "code": "  it('anySeries alias', () => {\n    expect(async.anySeries).to.be.a('function');\n    expect(async.anySeries).to.equal(async.someSeries);\n  });",
            "file": "some.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "sortBy",
            "suites": [
                "sortBy"
            ],
            "updatePoint": {
                "line": 10,
                "column": 12
            },
            "line": 10,
            "code": "  it('sortBy', done => {\n    async.sortBy([{\n      a: 1\n    }, {\n      a: 15\n    }, {\n      a: 6\n    }], (x, callback) => {\n      setTimeout(() => {\n        callback(null, x.a);\n      }, 0);\n    }, (err, result) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(result).to.eql([{\n        a: 1\n      }, {\n        a: 6\n      }, {\n        a: 15\n      }]);\n      done();\n    });\n  });",
            "file": "sortBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "sortBy inverted",
            "suites": [
                "sortBy"
            ],
            "updatePoint": {
                "line": 33,
                "column": 21
            },
            "line": 33,
            "code": "  it('sortBy inverted', done => {\n    async.sortBy([{\n      a: 1\n    }, {\n      a: 15\n    }, {\n      a: 6\n    }], (x, callback) => {\n      setTimeout(() => {\n        callback(null, x.a * -1);\n      }, 0);\n    }, (err, result) => {\n      expect(result).to.eql([{\n        a: 15\n      }, {\n        a: 6\n      }, {\n        a: 1\n      }]);\n      done();\n    });\n  });",
            "file": "sortBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "sortBy error",
            "suites": [
                "sortBy"
            ],
            "updatePoint": {
                "line": 55,
                "column": 18
            },
            "line": 55,
            "code": "  it('sortBy error', done => {\n    var error = new Error('asdas');\n    async.sortBy([{\n      a: 1\n    }, {\n      a: 15\n    }, {\n      a: 6\n    }], (x, callback) => {\n      async.setImmediate(() => {\n        callback(error);\n      });\n    }, err => {\n      expect(err).to.equal(error);\n      done();\n    });\n  });",
            "file": "sortBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "sortBy canceled",
            "suites": [
                "sortBy"
            ],
            "updatePoint": {
                "line": 72,
                "column": 21
            },
            "line": 72,
            "code": "  it('sortBy canceled', done => {\n    var call_order = [];\n    async.sortBy([{\n      a: 1\n    }, {\n      a: 15\n    }, {\n      a: 6\n    }], (x, callback) => {\n      call_order.push(x.a);\n\n      if (x.a === 15) {\n        return callback(false, x.a);\n      }\n\n      callback(null, x.a);\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 15, 6]);\n      done();\n    }, 25);\n  });",
            "file": "sortBy.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "timeout with series",
            "suites": [
                "timeout"
            ],
            "updatePoint": {
                "line": 8,
                "column": 25
            },
            "line": 8,
            "code": "  it('timeout with series', done => {\n    async.series([async.timeout(callback => {\n      setTimeout(() => {\n        callback(null, 'I didn\\'t time out');\n      }, 25);\n    }, 50), async.timeout(callback => {\n      setTimeout(() => {\n        callback(null, 'I will time out');\n      }, 75);\n    }, 50)], (err, results) => {\n      expect(err.message).to.equal('Callback function \"anonymous\" timed out.');\n      expect(err.code).to.equal('ETIMEDOUT');\n      expect(err.info).to.equal(undefined);\n      expect(results[0]).to.equal('I didn\\'t time out');\n      done();\n    });\n  });",
            "file": "timeout.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "timeout with series and info",
            "suites": [
                "timeout"
            ],
            "updatePoint": {
                "line": 25,
                "column": 34
            },
            "line": 25,
            "code": "  it('timeout with series and info', done => {\n    var info = {\n      custom: 'info about callback'\n    };\n    async.series([async.timeout(callback => {\n      setTimeout(() => {\n        callback(null, 'I didn\\'t time out');\n      }, 25);\n    }, 50), async.timeout(callback => {\n      setTimeout(() => {\n        callback(null, 'I will time out');\n      }, 75);\n    }, 50, info)], (err, results) => {\n      expect(err.message).to.equal('Callback function \"anonymous\" timed out.');\n      expect(err.code).to.equal('ETIMEDOUT');\n      expect(err.info).to.equal(info);\n      expect(results[0]).to.equal('I didn\\'t time out');\n      done();\n    });\n  });",
            "file": "timeout.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "timeout with parallel",
            "suites": [
                "timeout"
            ],
            "updatePoint": {
                "line": 45,
                "column": 27
            },
            "line": 45,
            "code": "  it('timeout with parallel', done => {\n    async.parallel([async.timeout(callback => {\n      setImmediate(() => {\n        callback(null, 'I didn\\'t time out');\n      });\n    }, 20), async.timeout(callback => {\n      setTimeout(() => {\n        callback(null, 'I will time out');\n      }, 75);\n    }, 20)], (err, results) => {\n      expect(err.message).to.equal('Callback function \"anonymous\" timed out.');\n      expect(err.code).to.equal('ETIMEDOUT');\n      expect(err.info).to.equal(undefined);\n      expect(results[0]).to.equal('I didn\\'t time out');\n      done();\n    });\n  });",
            "file": "timeout.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "timeout with multiple calls (#1418)",
            "suites": [
                "timeout"
            ],
            "updatePoint": {
                "line": 62,
                "column": 41
            },
            "line": 62,
            "code": "  it('timeout with multiple calls (#1418)', done => {\n    var timeout = async.timeout((n, callback) => {\n      if (n < 1) {\n        setTimeout(() => {\n          callback(null, 'I will time out');\n        }, 75);\n      } else {\n        async.setImmediate(() => {\n          callback(null, 'I didn\\'t time out');\n        });\n      }\n    }, 20);\n    async.series([function (cb) {\n      timeout(0, (err, result) => {\n        expect(err.message).to.equal('Callback function \"anonymous\" timed out.');\n        expect(err.code).to.equal('ETIMEDOUT');\n        expect(err.info).to.equal(undefined);\n        expect(result).to.equal(undefined);\n        cb();\n      });\n    }, function (cb) {\n      timeout(1, (err, result) => {\n        expect(err).to.equal(null);\n        expect(result).to.equal('I didn\\'t time out');\n        cb();\n      });\n    }], err => {\n      expect(err).to.equal(null);\n      done();\n    });\n  });",
            "file": "timeout.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "times",
            "suites": [
                "times"
            ],
            "updatePoint": {
                "line": 10,
                "column": 11
            },
            "line": 10,
            "code": "  it('times', done => {\n    async.times(5, (n, next) => {\n      next(null, n);\n    }, (err, results) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(results).to.eql([0, 1, 2, 3, 4]);\n      done();\n    });\n  });",
            "file": "times.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "times 3",
            "suites": [
                "times"
            ],
            "updatePoint": {
                "line": 19,
                "column": 13
            },
            "line": 19,
            "code": "  it('times 3', done => {\n    var args = [];\n    async.times(3, (n, callback) => {\n      setTimeout(() => {\n        args.push(n);\n        callback();\n      }, 15);\n    }, err => {\n      if (err) throw err;\n      expect(args).to.eql([0, 1, 2]);\n      done();\n    });\n  });",
            "file": "times.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "times 0",
            "suites": [
                "times"
            ],
            "updatePoint": {
                "line": 32,
                "column": 13
            },
            "line": 32,
            "code": "  it('times 0', done => {\n    async.times(0, (n, callback) => {\n      assert(false, 'iteratee should not be called');\n      callback();\n    }, err => {\n      if (err) throw err;\n      assert(true, 'should call callback');\n    });\n    setTimeout(done, 25);\n  });",
            "file": "times.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "times error",
            "suites": [
                "times"
            ],
            "updatePoint": {
                "line": 42,
                "column": 17
            },
            "line": 42,
            "code": "  it('times error', done => {\n    async.times(3, (n, callback) => {\n      callback('error');\n    }, err => {\n      expect(err).to.equal('error');\n    });\n    setTimeout(done, 10);\n  });",
            "file": "times.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "times canceled",
            "suites": [
                "times"
            ],
            "updatePoint": {
                "line": 50,
                "column": 20
            },
            "line": 50,
            "code": "  it('times canceled', done => {\n    var call_order = [];\n    async.times(5, (n, callback) => {\n      call_order.push(n);\n\n      if (n === 2) {\n        return callback(false, n);\n      }\n\n      callback(null, n);\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([0, 1, 2]);\n      done();\n    }, 25);\n  });",
            "file": "times.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "timesSeries",
            "suites": [
                "times"
            ],
            "updatePoint": {
                "line": 68,
                "column": 17
            },
            "line": 68,
            "code": "  it('timesSeries', done => {\n    var call_order = [];\n    async.timesSeries(5, (n, callback) => {\n      setTimeout(() => {\n        call_order.push(n);\n        callback(null, n);\n      }, 5);\n    }, (err, results) => {\n      expect(call_order).to.eql([0, 1, 2, 3, 4]);\n      expect(results).to.eql([0, 1, 2, 3, 4]);\n      done();\n    });\n  });",
            "file": "times.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "timesSeries error",
            "suites": [
                "times"
            ],
            "updatePoint": {
                "line": 81,
                "column": 23
            },
            "line": 81,
            "code": "  it('timesSeries error', done => {\n    async.timesSeries(5, (n, callback) => {\n      callback('error');\n    }, err => {\n      expect(err).to.equal('error');\n    });\n    setTimeout(done, 10);\n  });",
            "file": "times.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "timesSeries canceled",
            "suites": [
                "times"
            ],
            "updatePoint": {
                "line": 89,
                "column": 26
            },
            "line": 89,
            "code": "  it('timesSeries canceled', done => {\n    var call_order = [];\n    async.timesSeries(5, (n, callback) => {\n      call_order.push(n);\n      async.setImmediate(() => {\n        if (n === 2) {\n          return callback(false, n);\n        }\n\n        callback(null, n);\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([0, 1, 2]);\n      done();\n    }, 25);\n  });",
            "file": "times.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "timesLimit",
            "suites": [
                "times"
            ],
            "updatePoint": {
                "line": 108,
                "column": 16
            },
            "line": 108,
            "code": "  it('timesLimit', done => {\n    var limit = 2;\n    var running = 0;\n    async.timesLimit(5, limit, (i, next) => {\n      running++;\n      assert(running <= limit && running > 0, running);\n      setTimeout(() => {\n        running--;\n        next(null, i * 2);\n      }, (3 - i) * 10);\n    }, (err, results) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(results).to.eql([0, 2, 4, 6, 8]);\n      done();\n    });\n  });",
            "file": "times.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "timesLimit canceled",
            "suites": [
                "times"
            ],
            "updatePoint": {
                "line": 124,
                "column": 25
            },
            "line": 124,
            "code": "  it('timesLimit canceled', done => {\n    var call_order = [];\n    async.timesLimit(5, 2, (n, callback) => {\n      call_order.push(n);\n      async.setImmediate(() => {\n        if (n === 2) {\n          return callback(false, n);\n        }\n\n        callback(null, n);\n      });\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([0, 1, 2, 3]);\n      done();\n    }, 25);\n  });",
            "file": "times.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "transform implictly determines memo if not provided",
            "suites": [
                "transform"
            ],
            "updatePoint": {
                "line": 8,
                "column": 57
            },
            "line": 8,
            "code": "  it('transform implictly determines memo if not provided', done => {\n    async.transform([1, 2, 3], (memo, x, v, callback) => {\n      memo.push(x + 1);\n      callback();\n    }, (err, result) => {\n      expect(result).to.eql([2, 3, 4]);\n      done();\n    });\n  });",
            "file": "transform.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "transform async with object memo",
            "suites": [
                "transform"
            ],
            "updatePoint": {
                "line": 17,
                "column": 38
            },
            "line": 17,
            "code": "  it('transform async with object memo', done => {\n    async.transform([1, 3, 2], {}, (memo, v, k, callback) => {\n      setTimeout(() => {\n        memo[k] = v;\n        callback();\n      });\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.eql({\n        0: 1,\n        1: 3,\n        2: 2\n      });\n      done();\n    });\n  });",
            "file": "transform.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "transform iterating object",
            "suites": [
                "transform"
            ],
            "updatePoint": {
                "line": 33,
                "column": 32
            },
            "line": 33,
            "code": "  it('transform iterating object', done => {\n    async.transform({\n      a: 1,\n      b: 3,\n      c: 2\n    }, (memo, v, k, callback) => {\n      setTimeout(() => {\n        memo[k] = v + 1;\n        callback();\n      });\n    }, (err, result) => {\n      expect(err).to.equal(null);\n      expect(result).to.eql({\n        a: 2,\n        b: 4,\n        c: 3\n      });\n      done();\n    });\n  });",
            "file": "transform.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "transform error",
            "suites": [
                "transform"
            ],
            "updatePoint": {
                "line": 53,
                "column": 21
            },
            "line": 53,
            "code": "  it('transform error', done => {\n    async.transform([1, 2, 3], (a, v, k, callback) => {\n      callback('error');\n    }, err => {\n      expect(err).to.equal('error');\n      done();\n    });\n  });",
            "file": "transform.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "transform canceled",
            "suites": [
                "transform"
            ],
            "updatePoint": {
                "line": 61,
                "column": 24
            },
            "line": 61,
            "code": "  it('transform canceled', done => {\n    var call_order = [];\n    async.transform([1, 2, 3], (a, v, k, callback) => {\n      call_order.push(v);\n      a.push(v + 1);\n      callback(v === 2 ? false : null);\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1, 2, 3]);\n      done();\n    }, 25);\n  });",
            "file": "transform.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "transform with two arguments",
            "suites": [
                "transform"
            ],
            "updatePoint": {
                "line": 75,
                "column": 34
            },
            "line": 75,
            "code": "  it('transform with two arguments', done => {\n    try {\n      async.transform([1, 2, 3], (a, v, k, callback) => {\n        callback();\n      });\n      done();\n    } catch (e) {\n      expect.fail();\n    }\n  });",
            "file": "transform.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "no callback",
            "suites": [
                "tryEach"
            ],
            "updatePoint": {
                "line": 10,
                "column": 17
            },
            "line": 10,
            "code": "  it('no callback', () => {\n    async.tryEach([]);\n  });",
            "file": "tryEach.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "empty",
            "suites": [
                "tryEach"
            ],
            "updatePoint": {
                "line": 13,
                "column": 11
            },
            "line": 13,
            "code": "  it('empty', done => {\n    async.tryEach([], (err, results) => {\n      expect(err).to.equal(null);\n      expect(results).to.eql(undefined);\n      done();\n    });\n  });",
            "file": "tryEach.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "one task, multiple results",
            "suites": [
                "tryEach"
            ],
            "updatePoint": {
                "line": 20,
                "column": 32
            },
            "line": 20,
            "code": "  it('one task, multiple results', done => {\n    var RESULTS = ['something', 'something2'];\n    async.tryEach([function (callback) {\n      callback(null, RESULTS[0], RESULTS[1]);\n    }], (err, results) => {\n      expect(err).to.equal(null);\n      expect(results).to.eql(RESULTS);\n      done();\n    });\n  });",
            "file": "tryEach.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "one task",
            "suites": [
                "tryEach"
            ],
            "updatePoint": {
                "line": 30,
                "column": 14
            },
            "line": 30,
            "code": "  it('one task', done => {\n    var RESULT = 'something';\n    async.tryEach([function (callback) {\n      callback(null, RESULT);\n    }], (err, results) => {\n      expect(err).to.equal(null);\n      expect(results).to.eql(RESULT);\n      done();\n    });\n  });",
            "file": "tryEach.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "two tasks, one failing",
            "suites": [
                "tryEach"
            ],
            "updatePoint": {
                "line": 40,
                "column": 28
            },
            "line": 40,
            "code": "  it('two tasks, one failing', done => {\n    var RESULT = 'something';\n    async.tryEach([function (callback) {\n      callback(new Error('Failure'), {});\n    }, function (callback) {\n      callback(null, RESULT);\n    }], (err, results) => {\n      expect(err).to.equal(null);\n      expect(results).to.eql(RESULT);\n      done();\n    });\n  });",
            "file": "tryEach.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "two tasks, both failing",
            "suites": [
                "tryEach"
            ],
            "updatePoint": {
                "line": 52,
                "column": 29
            },
            "line": 52,
            "code": "  it('two tasks, both failing', done => {\n    var ERROR_RESULT = new Error('Failure2');\n    async.tryEach([function (callback) {\n      callback(new Error('Should not stop here'));\n    }, function (callback) {\n      callback(ERROR_RESULT);\n    }], (err, results) => {\n      expect(err).to.equal(ERROR_RESULT);\n      expect(results).to.eql(undefined);\n      done();\n    });\n  });",
            "file": "tryEach.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "two tasks, non failing",
            "suites": [
                "tryEach"
            ],
            "updatePoint": {
                "line": 64,
                "column": 28
            },
            "line": 64,
            "code": "  it('two tasks, non failing', done => {\n    var RESULT = 'something';\n    async.tryEach([function (callback) {\n      callback(null, RESULT);\n    }, function () {\n      assert.fail('Should not been called');\n    }], (err, results) => {\n      expect(err).to.equal(null);\n      expect(results).to.eql(RESULT);\n      done();\n    });\n  });",
            "file": "tryEach.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "canceled",
            "suites": [
                "tryEach"
            ],
            "updatePoint": {
                "line": 76,
                "column": 14
            },
            "line": 76,
            "code": "  it('canceled', done => {\n    var call_order = [];\n    async.tryEach([function (callback) {\n      call_order.push('task1');\n      callback(false);\n    }, function () {\n      assert.fail('task2 should not been called');\n    }], () => {\n      assert.fail('should not been called');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql(['task1']);\n      done();\n    }, 25);\n  });",
            "file": "tryEach.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "until",
            "suites": [
                "until"
            ],
            "updatePoint": {
                "line": 10,
                "column": 11
            },
            "line": 10,
            "code": "  it('until', done => {\n    var call_order = [];\n    var count = 0;\n    async.until(cb => {\n      expect(cb).to.be.a('function');\n      call_order.push(['test', count]);\n      return cb(null, count == 5);\n    }, cb => {\n      call_order.push(['iteratee', count]);\n      count++;\n      cb(null, count);\n    }, (err, result) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(result).to.equal(5, 'last result passed through');\n      expect(call_order).to.eql([['test', 0], ['iteratee', 0], ['test', 1], ['iteratee', 1], ['test', 2], ['iteratee', 2], ['test', 3], ['iteratee', 3], ['test', 4], ['iteratee', 4], ['test', 5]]);\n      expect(count).to.equal(5);\n      done();\n    });\n  });",
            "file": "until.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "until canceling",
            "suites": [
                "until"
            ],
            "updatePoint": {
                "line": 29,
                "column": 21
            },
            "line": 29,
            "code": "  it('until canceling', done => {\n    let counter = 0;\n    async.until(cb => cb(null, false), cb => {\n      counter++;\n      cb(counter === 2 ? false : null);\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(counter).to.equal(2);\n      done();\n    }, 10);\n  });",
            "file": "until.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doUntil",
            "suites": [
                "until"
            ],
            "updatePoint": {
                "line": 42,
                "column": 13
            },
            "line": 42,
            "code": "  it('doUntil', done => {\n    var call_order = [];\n    var count = 0;\n    async.doUntil(cb => {\n      call_order.push(['iteratee', count]);\n      count++;\n      cb(null, count);\n    }, (c, cb) => {\n      expect(c).to.equal(count);\n      call_order.push(['test', count]);\n      return cb(null, count == 5);\n    }, (err, result) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(result).to.equal(5, 'last result passed through');\n      expect(call_order).to.eql([['iteratee', 0], ['test', 1], ['iteratee', 1], ['test', 2], ['iteratee', 2], ['test', 3], ['iteratee', 3], ['test', 4], ['iteratee', 4], ['test', 5]]);\n      expect(count).to.equal(5);\n      done();\n    });\n  });",
            "file": "until.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doUntil callback params",
            "suites": [
                "until"
            ],
            "updatePoint": {
                "line": 61,
                "column": 29
            },
            "line": 61,
            "code": "  it('doUntil callback params', done => {\n    var call_order = [];\n    var count = 0;\n    async.doUntil(cb => {\n      call_order.push(['iteratee', count]);\n      count++;\n      cb(null, count);\n    }, (c, cb) => {\n      call_order.push(['test', c]);\n      return cb(null, c == 5);\n    }, (err, result) => {\n      if (err) throw err;\n      expect(result).to.equal(5, 'last result passed through');\n      expect(call_order).to.eql([['iteratee', 0], ['test', 1], ['iteratee', 1], ['test', 2], ['iteratee', 2], ['test', 3], ['iteratee', 3], ['test', 4], ['iteratee', 4], ['test', 5]]);\n      expect(count).to.equal(5);\n      done();\n    });\n  });",
            "file": "until.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doUntil canceling",
            "suites": [
                "until"
            ],
            "updatePoint": {
                "line": 79,
                "column": 23
            },
            "line": 79,
            "code": "  it('doUntil canceling', done => {\n    let counter = 0;\n    async.doUntil(cb => {\n      counter++;\n      cb(counter === 2 ? false : null);\n    }, cb => cb(null, false), () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(counter).to.equal(2);\n      done();\n    }, 10);\n  });",
            "file": "until.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "basics",
            "suites": [
                "waterfall"
            ],
            "updatePoint": {
                "line": 10,
                "column": 12
            },
            "line": 10,
            "code": "  it('basics', done => {\n    var call_order = [];\n    async.waterfall([function (callback) {\n      call_order.push('fn1');\n      setTimeout(() => {\n        callback(null, 'one', 'two');\n      }, 0);\n    }, function (arg1, arg2, callback) {\n      call_order.push('fn2');\n      expect(arg1).to.equal('one');\n      expect(arg2).to.equal('two');\n      setTimeout(() => {\n        callback(null, arg1, arg2, 'three');\n      }, 25);\n    }, function (arg1, arg2, arg3, callback) {\n      call_order.push('fn3');\n      expect(arg1).to.equal('one');\n      expect(arg2).to.equal('two');\n      expect(arg3).to.equal('three');\n      callback(null, 'four');\n    }, function (arg4, callback) {\n      call_order.push('fn4');\n      expect(call_order).to.eql(['fn1', 'fn2', 'fn3', 'fn4']);\n      callback(null, 'test');\n    }], err => {\n      expect(err === null, err + \" passed instead of 'null'\");\n      done();\n    });\n  });",
            "file": "waterfall.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "empty array",
            "suites": [
                "waterfall"
            ],
            "updatePoint": {
                "line": 39,
                "column": 17
            },
            "line": 39,
            "code": "  it('empty array', done => {\n    async.waterfall([], err => {\n      if (err) throw err;\n      done();\n    });\n  });",
            "file": "waterfall.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "non-array",
            "suites": [
                "waterfall"
            ],
            "updatePoint": {
                "line": 45,
                "column": 15
            },
            "line": 45,
            "code": "  it('non-array', done => {\n    async.waterfall({}, err => {\n      expect(err.message).to.equal('First argument to waterfall must be an array of functions');\n      done();\n    });\n  });",
            "file": "waterfall.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "no callback",
            "suites": [
                "waterfall"
            ],
            "updatePoint": {
                "line": 51,
                "column": 17
            },
            "line": 51,
            "code": "  it('no callback', done => {\n    async.waterfall([function (callback) {\n      callback();\n    }, function (callback) {\n      callback();\n      done();\n    }]);\n  });",
            "file": "waterfall.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "async",
            "suites": [
                "waterfall"
            ],
            "updatePoint": {
                "line": 59,
                "column": 11
            },
            "line": 59,
            "code": "  it('async', done => {\n    var call_order = [];\n    async.waterfall([function (callback) {\n      call_order.push(1);\n      callback();\n      call_order.push(2);\n    }, function (callback) {\n      call_order.push(3);\n      callback();\n    }, function () {\n      expect(call_order).to.eql([1, 3]);\n      done();\n    }]);\n  });",
            "file": "waterfall.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "error",
            "suites": [
                "waterfall"
            ],
            "updatePoint": {
                "line": 73,
                "column": 11
            },
            "line": 73,
            "code": "  it('error', done => {\n    async.waterfall([function (callback) {\n      callback('error');\n    }, function (callback) {\n      assert(false, 'next function should not be called');\n      callback();\n    }], err => {\n      expect(err).to.equal('error');\n      done();\n    });\n  });",
            "file": "waterfall.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "canceled",
            "suites": [
                "waterfall"
            ],
            "updatePoint": {
                "line": 84,
                "column": 14
            },
            "line": 84,
            "code": "  it('canceled', done => {\n    const call_order = [];\n    async.waterfall([function (callback) {\n      call_order.push(1);\n      callback(false);\n    }, function (callback) {\n      call_order.push(2);\n      assert(false, 'next function should not be called');\n      callback();\n    }], () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(call_order).to.eql([1]);\n      done();\n    }, 10);\n  });",
            "file": "waterfall.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "multiple callback calls",
            "suites": [
                "waterfall"
            ],
            "updatePoint": {
                "line": 101,
                "column": 29
            },
            "line": 101,
            "code": "  it('multiple callback calls', () => {\n    var arr = [function (callback) {\n      callback(null, 'one', 'two');\n      callback(null, 'one', 'two');\n    }, function (arg1, arg2, callback) {\n      callback(null, arg1, arg2, 'three');\n    }];\n    expect(() => {\n      async.waterfall(arr, () => {});\n    }).to.throw(/already called/);\n  });",
            "file": "waterfall.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "multiple callback calls (trickier) @nodeonly",
            "suites": [
                "waterfall"
            ],
            "updatePoint": {
                "line": 112,
                "column": 50
            },
            "line": 112,
            "code": "  it('multiple callback calls (trickier) @nodeonly', done => {\n    // do a weird dance to catch the async thrown error before mocha\n    var listeners = process.listeners('uncaughtException');\n    process.removeAllListeners('uncaughtException');\n    process.once('uncaughtException', err => {\n      listeners.forEach(listener => {\n        process.on('uncaughtException', listener);\n      }); // can't throw errors in a uncaughtException handler, defer\n\n      setTimeout(checkErr, 0, err);\n    });\n\n    function checkErr(err) {\n      expect(err.message).to.match(/already called/);\n      done();\n    }\n\n    async.waterfall([function (callback) {\n      setTimeout(callback, 0, null, 'one', 'two');\n      setTimeout(callback, 2, null, 'one', 'two');\n    }, function (arg1, arg2, callback) {\n      setTimeout(callback, 15, null, arg1, arg2, 'three');\n    }]);\n  });",
            "file": "waterfall.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "call in another context @nycinvalid @nodeonly",
            "suites": [
                "waterfall"
            ],
            "updatePoint": {
                "line": 136,
                "column": 51
            },
            "line": 136,
            "code": "  it('call in another context @nycinvalid @nodeonly', done => {\n    var vm = require('vm');\n\n    var sandbox = {\n      async,\n      done\n    };\n\n    var fn = \"(\" + function () {\n      async.waterfall([function (callback) {\n        callback();\n      }], err => {\n        if (err) {\n          return done(err);\n        }\n\n        done();\n      });\n    }.toString() + \"())\";\n\n    vm.runInNewContext(fn, sandbox);\n  });",
            "file": "waterfall.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not use unnecessary deferrals",
            "suites": [
                "waterfall"
            ],
            "updatePoint": {
                "line": 158,
                "column": 42
            },
            "line": 158,
            "code": "  it('should not use unnecessary deferrals', done => {\n    var sameStack = true;\n    async.waterfall([function (cb) {\n      cb(null, 1);\n    }, function (arg, cb) {\n      cb();\n    }], () => {\n      expect(sameStack).to.equal(true);\n      done();\n    });\n    sameStack = false;\n  });",
            "file": "waterfall.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "whilst",
            "suites": [
                "whilst"
            ],
            "updatePoint": {
                "line": 10,
                "column": 12
            },
            "line": 10,
            "code": "  it('whilst', done => {\n    var call_order = [];\n    var count = 0;\n    async.whilst(cb => {\n      expect(cb).to.be.a('function');\n      call_order.push(['test', count]);\n      return cb(null, count < 5);\n    }, cb => {\n      call_order.push(['iteratee', count]);\n      count++;\n      cb(null, count);\n    }, (err, result) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(result).to.equal(5, 'last result passed through');\n      expect(call_order).to.eql([['test', 0], ['iteratee', 0], ['test', 1], ['iteratee', 1], ['test', 2], ['iteratee', 2], ['test', 3], ['iteratee', 3], ['test', 4], ['iteratee', 4], ['test', 5]]);\n      expect(count).to.equal(5);\n      done();\n    });\n  });",
            "file": "whilst.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "errors",
            "suites": [
                "whilst"
            ],
            "updatePoint": {
                "line": 29,
                "column": 12
            },
            "line": 29,
            "code": "  it('errors', done => {\n    async.whilst(cb => cb(new Error('bad test')), cb => cb(), err => {\n      expect(err.message).to.equal('bad test');\n      done();\n    });\n  });",
            "file": "whilst.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "errors (iteratee)",
            "suites": [
                "whilst"
            ],
            "updatePoint": {
                "line": 35,
                "column": 23
            },
            "line": 35,
            "code": "  it('errors (iteratee)', done => {\n    async.whilst(cb => cb(null, true), cb => cb(new Error('bad iter')), err => {\n      expect(err.message).to.equal('bad iter');\n      done();\n    });\n  });",
            "file": "whilst.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "whilst optional callback",
            "suites": [
                "whilst"
            ],
            "updatePoint": {
                "line": 41,
                "column": 30
            },
            "line": 41,
            "code": "  it('whilst optional callback', done => {\n    var counter = 0;\n    async.whilst(cb => cb(null, counter < 2), cb => {\n      counter++;\n      cb();\n    });\n    expect(counter).to.equal(2);\n    done();\n  });",
            "file": "whilst.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "whilst canceling",
            "suites": [
                "whilst"
            ],
            "updatePoint": {
                "line": 50,
                "column": 22
            },
            "line": 50,
            "code": "  it('whilst canceling', done => {\n    var counter = 0;\n    async.whilst(cb => cb(null, counter < 3), cb => {\n      counter++;\n      cb(counter === 2 ? false : null);\n    }, () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(counter).to.equal(2);\n      done();\n    }, 10);\n  });",
            "file": "whilst.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "should not error when test is false on first iteration",
            "suites": [
                "whilst"
            ],
            "updatePoint": {
                "line": 63,
                "column": 60
            },
            "line": 63,
            "code": "  it('should not error when test is false on first iteration', done => {\n    var counter = 0;\n    async.whilst(cb => cb(null, false), cb => {\n      counter++;\n      cb(null);\n    }, (err, result) => {\n      expect(err).to.eql(null);\n      expect(result).to.be.undefined;\n      expect(counter).to.equal(0);\n      done();\n    });\n  });",
            "file": "whilst.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doWhilst",
            "suites": [
                "whilst"
            ],
            "updatePoint": {
                "line": 75,
                "column": 14
            },
            "line": 75,
            "code": "  it('doWhilst', done => {\n    var call_order = [];\n    var count = 0;\n    async.doWhilst(cb => {\n      call_order.push(['iteratee', count]);\n      count++;\n      cb(null, count);\n    }, (c, cb) => {\n      expect(c).to.equal(count);\n      call_order.push(['test', count]);\n      return cb(null, count < 5);\n    }, (err, result) => {\n      assert(err === null, err + \" passed instead of 'null'\");\n      expect(result).to.equal(5, 'last result passed through');\n      expect(call_order).to.eql([['iteratee', 0], ['test', 1], ['iteratee', 1], ['test', 2], ['iteratee', 2], ['test', 3], ['iteratee', 3], ['test', 4], ['iteratee', 4], ['test', 5]]);\n      expect(count).to.equal(5);\n      done();\n    });\n  });",
            "file": "whilst.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doWhilst callback params",
            "suites": [
                "whilst"
            ],
            "updatePoint": {
                "line": 94,
                "column": 30
            },
            "line": 94,
            "code": "  it('doWhilst callback params', done => {\n    var call_order = [];\n    var count = 0;\n    async.doWhilst(cb => {\n      call_order.push(['iteratee', count]);\n      count++;\n      cb(null, count);\n    }, (c, cb) => {\n      call_order.push(['test', c]);\n      return cb(null, c < 5);\n    }, (err, result) => {\n      if (err) throw err;\n      expect(result).to.equal(5, 'last result passed through');\n      expect(call_order).to.eql([['iteratee', 0], ['test', 1], ['iteratee', 1], ['test', 2], ['iteratee', 2], ['test', 3], ['iteratee', 3], ['test', 4], ['iteratee', 4], ['test', 5]]);\n      expect(count).to.equal(5);\n      done();\n    });\n  });",
            "file": "whilst.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doWhilst - error",
            "suites": [
                "whilst"
            ],
            "updatePoint": {
                "line": 112,
                "column": 22
            },
            "line": 112,
            "code": "  it('doWhilst - error', done => {\n    var error = new Error('asdas');\n    async.doWhilst(cb => {\n      cb(error);\n    }, () => {}, err => {\n      expect(err).to.equal(error);\n      done();\n    });\n  });",
            "file": "whilst.js",
            "skipped": false,
            "dir": "test"
        },
        {
            "name": "doWhilst canceling",
            "suites": [
                "whilst"
            ],
            "updatePoint": {
                "line": 121,
                "column": 24
            },
            "line": 121,
            "code": "  it('doWhilst canceling', done => {\n    let counter = 0;\n    async.doWhilst(cb => {\n      counter++;\n      cb(counter === 2 ? false : null);\n    }, cb => cb(null, true), () => {\n      throw new Error('should not get here');\n    });\n    setTimeout(() => {\n      expect(counter).to.equal(2);\n      done();\n    }, 10);\n  });",
            "file": "whilst.js",
            "skipped": false,
            "dir": "test"
        }
    ],
    "badge": "caolan__async.svg"
}